<!DOCTYPE html>
<html lang="zh-CN">
<head>

  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#4c4c4c"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#4c4c4c">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.css" integrity="sha256-RvRHGSuWAxZpXKV9lLDt2e+rZ+btzn48Wp4ueS3NZKs=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinklive1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#369","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="&#96;冯·诺依曼计算机特点– 计算机由五大部件组成• 输入数据和程序的“输入设备”• 记忆程序和数据的“存储器”• 完成数据加工处理的“运算器”• 控制程序执行的“控制器”• 输出处理结果的“输出设备”">
<meta property="og:type" content="article">
<meta property="og:title" content="基于苏大ppt的计算机硬件笔记">
<meta property="og:url" content="https://thinklive1.github.io/2023/09/29/%E7%A1%AC%E4%BB%B6%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="thinklive">
<meta property="og:description" content="&#96;冯·诺依曼计算机特点– 计算机由五大部件组成• 输入数据和程序的“输入设备”• 记忆程序和数据的“存储器”• 完成数据加工处理的“运算器”• 控制程序执行的“控制器”• 输出处理结果的“输出设备”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230531113546.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230531113559.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230531113735.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230531114156.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230603134629.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230610145852.png">
<meta property="article:published_time" content="2023-09-29T02:18:45.993Z">
<meta property="article:modified_time" content="2023-09-21T15:32:04.039Z">
<meta property="article:author" content="thinklive">
<meta property="article:tag" content="课程笔记">
<meta property="article:tag" content="计算机组成">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thinklive1.github.io/images/obsidian/20230531113546.png">


<link rel="canonical" href="https://thinklive1.github.io/2023/09/29/%E7%A1%AC%E4%BB%B6%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://thinklive1.github.io/2023/09/29/%E7%A1%AC%E4%BB%B6%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/","path":"2023/09/29/硬件总和笔记/","title":"基于苏大ppt的计算机硬件笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>基于苏大ppt的计算机硬件笔记 | thinklive</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --></head>
<script src="/js/tab-title.js"></script>
<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  
  
<script type="text/javascript" async src="/js/fairyDustCursor.js"></script>
  

  <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">thinklive</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">dirichlet labrary</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索 | search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页-|-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页 | home</a></li><li class="menu-item menu-item-标签-|-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags</a></li><li class="menu-item menu-item-分类-|-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories</a></li><li class="menu-item menu-item-归档-|-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archives</a></li><li class="menu-item menu-item-相册-|-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册 | photos</a></li><li class="menu-item menu-item-留言-|-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言 | guestbook</a></li><li class="menu-item menu-item-感谢-|-thanks"><a href="/thanks/" rel="section"><i class="fa custom thanks fa-fw"></i>感谢 | thanks</a></li><li class="menu-item menu-item-游戏-|-game"><a href="/game/index.html" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏 | game</a></li><li class="menu-item menu-item-资源地图-|-resourcemap"><a href="/webstack/" rel="section"><i class="fa fa-sitemap fa-fw"></i>资源地图 | resourcemap</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">
<img src="/images/thinklive_cyber.png"; z-index: 0; style="max-width: 100%; width: auto; height: auto;background-color: #fff;">
<!--网易云音乐插件-->
<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->
<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--网易云playlist外链地址-->   
<meting-js
    server="netease"
    type="playlist" 
    id="2762741085"
    mini="false"
    fixed="false"
    list-folded="true"
    autoplay="true"
    volume="0.4"
    theme="#4c4c4c"
    order="random"
    loop="all"
    preload="auto"
    lrc-type="2"
    mutex="true">
</meting-js>
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CISC%E5%92%8CRISC%E6%98%AFCPU%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">CISC和RISC是CPU的两种基本架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RISC%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">RISC特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">程序执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">寻址方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8086-8088%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">8086&#x2F;8088微处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%98%9F%E5%88%97%E7%BC%93%E5%86%B2%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">指令队列缓冲器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="nav-number">2.2.</span> <span class="nav-text">寻址空间计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">编程结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">主存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E5%A4%84%E4%BA%8E%E4%B8%AD%E5%BF%83%E5%9C%B0%E4%BD%8D%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">主存储器处于中心地位的原因：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%8C%87%E6%A0%87"><span class="nav-number">3.2.</span> <span class="nav-text">存储器的分类和指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">读写存储器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8086-8088%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87"><span class="nav-number">4.</span> <span class="nav-text">8086&#x2F;8088存储器组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">指令格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-1"><span class="nav-number">6.1.</span> <span class="nav-text">寻址方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-number">7.</span> <span class="nav-text">通用数据传送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">8.</span> <span class="nav-text">目标地址传送类指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">9.</span> <span class="nav-text">算术运算类指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">10.</span> <span class="nav-text">逻辑运算类指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="nav-number">11.</span> <span class="nav-text">移位指令和循环移位指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-number">12.</span> <span class="nav-text">串操作指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">13.</span> <span class="nav-text">程序控制类指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-number">15.</span> <span class="nav-text">伪指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E7%BB%84%E6%88%90"><span class="nav-number">16.</span> <span class="nav-text">存储器的分类与组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B"><span class="nav-number">16.1.</span> <span class="nav-text">读写过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">16.2.</span> <span class="nav-text">只读存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">16.3.</span> <span class="nav-text">拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">16.4.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">16.5.</span> <span class="nav-text">外部存储器（辅助存储器</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="thinklive"
      src="/images/thive.png">
  <p class="site-author-name" itemprop="name">thinklive</p>
  <div class="site-description" itemprop="description">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinklive1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinklive1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/xlithive@stu.suda.edu.cn" title="E-Mail → xlithive@stu.suda.edu.cn" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/38099250" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;38099250" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/thinklive" title="steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;thinklive" rel="noopener me" target="_blank"><i class="fa custom steam fa-fw"></i>steam</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thinklive1.github.io/2023/09/29/%E7%A1%AC%E4%BB%B6%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/thive.png">
      <meta itemprop="name" content="thinklive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="thinklive">
      <meta itemprop="description" content="起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="基于苏大ppt的计算机硬件笔记 | thinklive">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于苏大ppt的计算机硬件笔记
        </h1>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-29 10:18:45" itemprop="dateCreated datePublished" datetime="2023-09-29T10:18:45+08:00">2023-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-21 23:32:04" itemprop="dateModified" datetime="2023-09-21T23:32:04+08:00">2023-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课程笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>&#96;冯·诺依曼计算机特点<br>– 计算机由五大部件组成<br>• 输入数据和程序的“输入设备”<br>• 记忆程序和数据的“存储器”<br>• 完成数据加工处理的“运算器”<br>• 控制程序执行的“控制器”<br>• 输出处理结果的“输出设备”  </p>
<span id="more"></span>
<p>– 指令和数据以同等地位存于存储器，可按地址寻访<br>– 指令和数据用二进制表示<br>– 指令由操作码和地址码组成<br>– 以运算器为中心<br>基础逻辑电路：与门，非门，或门，异或门，与非门，或非门，同或门<br>半加器<br>– 𝑆𝑖当前位， 𝐶𝑖进位符<br>全加器  （包括之前的进位cn-1）<br>– 𝐹𝑛当前位， 𝐶𝑛进位符<br>𝐶𝑛 &#x3D; 𝑋𝑛 ⋅ 𝑌𝑛 + 𝑋𝑛⨁𝑌𝑛 ⋅ 𝐶𝑛−1<br><img src="/images/obsidian/20230531113546.png" alt="图片" title="image"><br><img src="/images/obsidian/20230531113559.png" alt="图片" title="image"><br><img src="/images/obsidian/20230531113735.png" alt="图片" title="image"><br>CPU与外设之间的数据交换必须通过接口来完成，通常接口有<br>以下一些功能：<br>– 设置数据的寄存、缓冲逻辑，以适应CPU与外设之间的速度差异；<br>– 进行信息格式的转换，例如串行和并行的转换；<br>– 协调CPU和外设两者在信息的类型和电平的差异，如电平转换驱动器、<br>数&#x2F;模或模&#x2F;数转换器等；<br>– 协调时序差异；<br>– 地址译码和设备选择功能；<br>– 设置中断和DMA（直接存储器存取）控制逻辑，以保证在中断和DMA<br>允许的情况下产生中断和DMA请求信号，并在接受到中断和DMA应答<br>之后完成中断处理和DMA传输。<br>&#96;为何要用二进制表示（冯.诺依曼核心）<br>– 无法制造多个稳定状态的物理器件<br>– 编码、计数、运算规则简单<br>– 和逻辑的真、假对应，通过逻辑门电路可实现算数运算<br>BCD码<br>– 机器中用4位二进制对每个十进制数位进行编码方法<br>– 4位二进制有16种组合，选取其中的十个。<br>– 常用的方法有：8421码、余3码、格雷码</p>
<p>为什么要用BCD码<br>– 高精确度的计算<br>– 耗费更多的存储空间<br><code>数的定点与浮点表示   – 十进制的公式表示：𝑁 = 10𝐸 ∗ 𝑆   – 二进制数的公式表示：𝑁 = 2𝐸 ∗ 𝑆   • 定点数：阶码𝐸位置固定，存储时统一忽略阶码   – 定点整数: 𝐸 = 0， 𝑆为纯整数，小数点固定在数值部分的右边   – 定点小数: 𝐸 = 0， 𝑆为纯小数，小数点固定在数值部分的左边 </code>浮点数详解<br>– 浮点数的表示范围<br>• 阶码E的范围：−128 ≤ 𝑒 &lt; 127<br>• 最大正数：0.111 … 1 × 2011…1 &#x3D; (1 − 2^−23) × 2^127<br>• 最小正数：0.100 … 0 × 2100…0 &#x3D; 1<br>2 × 2−128 &#x3D; 2−129<br>– 浮点数的表示精度<br>• 总位数不变<br>– 阶码越大：数值表示范围越大<br>– 尾数越少：精度变低<br><img src="/images/obsidian/20230531114156.png" alt="图片" title="image"><br>机器数的表示形式：原码、反码、补码<br>– 原码：符号+真值<br>• +41 原 &#x3D; 0 0101001， −41 原 &#x3D; 1 0101001<br>• +0 原 &#x3D; 0 0000000， −0 原 &#x3D; 1 0000000<br>– 反码：正数不变，负数时符号不变，其他各位取反<br>• +41 反 &#x3D; 0 0101001， −41 反 &#x3D; 1 1010110<br>• +0 反 &#x3D; 0 0000000， −0 反 &#x3D; 1 1111111<br>– 补码：正数不变，负数为反码+1（计算机表示带符号数的方法）<br>• +41 补 &#x3D; 0 0101001， −41 补 &#x3D; 1 1010111<br>• +0 补 &#x3D; 0 0000000， −0 补 &#x3D; 0 0000000<br>• +127 补 &#x3D; 0 1111111， −127 补 &#x3D; 1 0000001<br>• −128 补 &#x3D; 1 0000000<br>&#96;溢出<br>– 运算结果超出机器数所能表示的范围时，称为溢出<br>– 定点数溢出的判断方法<br>• 两个同符号的数相加，得到的和的符号与相加数的符号不一致。<br>– 采用双符号位：正数的符号位为00，负数的符号位为11。符号位参加运算。如果<br>两个符号位不相同，则溢出。（浪费资源）<br>• 任意两数相加，如果数值最高位的进位不等于符号位的进位，则溢出。<br>– 浮点数溢出的判断方法<br>• 看阶码是否溢出！</p>
<p>BCD码：用四位二进制数表达一个十进制数，方便运算和显示<br>浮点数：尾数S和阶码E<br>符号+阶码+符号+尾数<br>反码：正数不变，负数除了符号位取反<br>补码：正数不变，负数除了符号位加一<br>+0：00000000<br>-128:10000000<br>[x+y]补&#x3D;[x]补+[y]补<br>[x-y]补&#x3D;[x]补+[-y]补</p>
<p>有效地址EA&#x3D;基址（BX&#x2F;BP）+变址值(SI&#x2F;DI)+位移量DISP<br>+段基址&#x3D;物理地址</p>
<h2 id="CISC和RISC是CPU的两种基本架构"><a href="#CISC和RISC是CPU的两种基本架构" class="headerlink" title="CISC和RISC是CPU的两种基本架构"></a>CISC和RISC是CPU的两种基本架构</h2><p>– CISC：寻址方式多，方便编程<br>– RISC：寻址方式少，指令短、规整</p>
<h3 id="RISC特点"><a href="#RISC特点" class="headerlink" title="RISC特点"></a>RISC特点</h3><p>– 指令系统<br>• RISC指令长度相同；寻址方式少；指令执行时间相当<br>– RISC CPU内部寄存器多<br>– 存储器操作<br>• 只有取数&#x2F;存数指令访问存储器，大部分指令都在寄存器之间进行<br>– 代码量增多，实现特殊功能时程序复杂<br>– 较少的单元电路，面积小，功耗低<br>– 结构简单，设计周期短</p>
<h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h3><p>– PC发起地址查询<br>– 内存依据地址返回指令&#x2F;数据<br>– CPU进行指令解析<br>– PC增量或PC赋值<br>• 指令结构<br>– 操作码+地址码（操作数所在地）</p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>立即数寻址（办理人随身携带）<br>– 操作数由指令的地址码部分直接给出来<br>• 操作码+操作数  </li>
<li>寄存器直接寻址（办理人已寄存）<br>– 指令地址码部分给出某一通用寄存器地址<br>– 从寄存器存取数据比主存快得多<br>– 由于寄存器的数量较少，其地址码字段短</li>
<li>直接寻址（办理人在队伍里）<br>– 指令中地址码字段给出操作数的地址<br>• PC赋值——取操作数</li>
<li>间接寻址（办理人在哪问家长）<br>– 指令中给出的地址是存放操作数地址的地址<br>– 寄存器间接寻址（家长已寄存）<br>– 存储器间接寻址（家长在队伍里）</li>
<li>偏移寻址（相对寻址）<br>– 从我往后数A个<br>– EA：有效地址<br>– 相对寻址： EA&#x3D;A+(PC) 相对于当前指令处位移量为A的单元<br>– 基址寻址： EA&#x3D;A+(B) 相对于基址(B)处位移量为A的单元<br>– 变址寻址： EA&#x3D;A+(I) 相对于首址A处位移量为(I)的单元</li>
</ul>
<h2 id="8086-8088微处理器"><a href="#8086-8088微处理器" class="headerlink" title="8086&#x2F;8088微处理器"></a>8086&#x2F;8088微处理器</h2><h3 id="指令队列缓冲器"><a href="#指令队列缓冲器" class="headerlink" title="指令队列缓冲器"></a>指令队列缓冲器</h3><p>– 取指令时，每当指令队列缓冲区满一条指令，EU立即开始执行<br>– 当指令队列中有2个空字节（8088一个）BIU自动去取指<br>– EU从指令队列中去取指，然后执行指令，当该指令需要内存或<br>I&#x2F;O访问，EU请求BIU进入总线周期完成访问：<br>• BIU空闲状态：立即响应<br>• 正在取指：取指完后响应<br>– 指令队列已满，EU没有对BIU有请求，BIU进入空闲状态<br>– 执行转移、调用、返回指令：指令队列中的内容（原顺序指令）<br>被清除，BIU去取EU所指示的新的程序段指令</p>
<h3 id="寻址空间计算"><a href="#寻址空间计算" class="headerlink" title="寻址空间计算"></a>寻址空间计算</h3><p>– 8位机寻址：8根地址线<br>• 地址范围：0~255<br>• 最大内存空间：28 &#x3D; 256Byte<br>– 16位机：216 &#x3D; 64KB<br>– 32位机：232 &#x3D; 4GB<br>– 64位机：264 &#x3D; 16EB</p>
<h3 id="编程结构"><a href="#编程结构" class="headerlink" title="编程结构"></a>编程结构</h3><p><img src="/images/obsidian/20230603134629.png" alt="图片" title="image"><br>– 4个通用寄存器(16位)<br>• AX、BX、CX、DX（可8位单独使用）<br>– 4个专用寄存器(16位)<br>• BP（Base Pointer）基数指针<br>• SP（Stack Pointer）堆栈指针<br>• SI（Source Index）源变址<br>• DI（Destination Index）目的变址<br>– 4个段寄存器（16位）<br>• CS（Code Segment）代码段寄存器<br>• DS（Data Segment）数据段寄存器<br>• SS（Stack Segment）堆栈段寄存器<br>• ES（Extra Segment）扩展段寄存器<br>– CS用来存放程序当前使用的代码段的段地址，CPU执行的指令<br>将从代码段取得<br>• CS:IP构成传统意义的PC<br>– SS用来存放堆栈段的段地址，堆栈操作的数据就在堆栈段中<br>• 通常SS:SP和SS:BP构成堆栈段的访问<br>– DS用来存放数据段的段地址，一般地说，程序所用的数据就存<br>放在数据段中<br>• 通常DS:XX（通用寄存器）构成对数据段的访问；<br>– ES用来存放附加段的段地址，也用来存放数据，但典型用法是<br>存放处理后的数据</p>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存储器处于中心地位的原因："><a href="#主存储器处于中心地位的原因：" class="headerlink" title="主存储器处于中心地位的原因："></a>主存储器处于中心地位的原因：</h3><p>• 当前计算机正在执行的程序和数据均存放在存储器中，<br>CPU直接从存储器取指令或数据；<br>• 输入输出设备增多，数据传输速度加快，因此采用了<br>DMA(直接存储器存取)技术和输入&#x2F;输出通道技术，<br>在存储器与输入&#x2F;输出系统之间直接传送数据；<br>• 共享存储器的多处理机的出现，利用存储器存放共享<br>数据，并实现处理机之间的通信。</p>
<h3 id="存储器的分类和指标"><a href="#存储器的分类和指标" class="headerlink" title="存储器的分类和指标"></a>存储器的分类和指标</h3><p>随机存储器（random access memory，RAM）<br>• 又称读写存储器，指通过指令可以随机地、个别地对<br>各个存储单元进行访问（读写）的存储器<br>• 访问所需时间基本固定，与存储单元地址无关<br>• 停电会造成信号丢失<br>非易失性存储器<br>• 停电仍能保持其内容<br><code>容量 • 计算机可寻址的最小单位是一个存储字，一个存储字   所包括的二进制位数称为字长   • 一个字节（Byte）为8个二进制位（bit），一个字可   以由若干字节组成，一个字的字长通常是8的倍数。   • 主存储器的容量：以字或字节为单位来表示主存储器   存储单元的总数   • 单位：B、KB、MB、GB、 TB、PB、EB、ZB...   • 指令中地址码的位数决定了主存储器的可直接寻址的   最大空间   • 32位微型机提供32位物理地址，支持对4G字节的物理主存   空间的访问 </code>存储器存取时间(Memory Access Time)<br>• 又称存储器访问时间<br>• 启动一次存储器操作到完成该操作所经历的时间。<br>&#96;存储周期(Memory Cycle Time)<br>• 连续启动两次独立的存储器操作(例如连续两次读操<br>作)所需间隔的最小时间<br>• 主存储器和CPU是由总线连接的。CPU通过使<br>用AR（地址寄存器）和DR（数据寄存器）个<br>主存储器进行数据传送。若AR为K位字长，<br>DR为n位字长，则允许主存包含2^k个可寻址<br>字节或字。<br>• 在一个周期内，CPU和主存储器之间进行n位<br>数据传送。<br>读操作：存储器→CPU<br>• CPU把信息字的地址送到<br>AR,经地址总线送往主存<br>储器<br>• CPU通过控制总线发读<br>(Read)命令<br>• CPU等待主存储器的<br>Ready回答信号，Ready<br>为 1，表示信息已读出经<br>数据总线,送入DR。<br>AR：地址寄存器<br>DR：数码寄存器<br>主存储器的基本操作</p>
<p>• 写操作：CPU→存储器<br>• CPU把信息字的地址送<br>到AR，经地址总线送往<br>主存储器,并将信息字送<br>往DR<br>• CPU通过控制总线发写<br>(Write)命令<br>• CPU等待主存储器的<br>Ready回答信号，Ready<br>为 1，表示信息已从DR<br>经数据总线写入主存储<br>器</p>
<h3 id="读写存储器"><a href="#读写存储器" class="headerlink" title="读写存储器"></a>读写存储器</h3><p>按存储元件在运行中能否长时间保存信息分为静<br>态存储器SRAM和动态存储器DRAM两种<br>• 静态存储器：利用双稳态触发器来保存信息，只<br>要不断电，信息就不会丢失<br>• 动态存储器：利用MOS电容存储电荷来保存信<br>息，使用时需不断给电容充电才能使信息保持<br>• 静态存储器的集成度低，功耗较大；动态存储器<br>的集成度高，功耗小，主要用于大容量存储器<br>• DRAM每片容量大，引脚少; 价格低; 功耗低; 但<br>速度低，须再生。 DRAM一般用作计算机的主<br>存储器。<br>• SRAM速度快，价格较高，一般用作容量不大的<br>高速存储器。<br>DRAM和SRAM是可任意读写的随机存储器，当发生掉电时，存储的<br>内容容易立即消失，属于易失性存储器。<br>非易失性存储器，即使掉电，内容也不会消失：<br>只读存储器(ROM)<br>• 掩膜式ROM，由芯片制造商在制造时写入内容，以后只能读不能写<br>可编程序的只读存储器(PROM)<br>• 用户根据自己需要确定ROM的内容；<br>• 有熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元<br>的熔丝(写入)。<br>可擦除可编程序的只读存储器(EPROM)<br>• 产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线<br>照射后,浮置栅上的电子将逸散,即整体擦除。<br>可用电擦除的可编程序的只读存储器(E2PROM)<br>• 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写<br>入周期要几毫秒,寿命为10万次。<br>闪速存储器(Flash Memory)<br>• 用电擦除,但只能整体擦除或分区擦除。</p>
<h2 id="8086-8088存储器组织"><a href="#8086-8088存储器组织" class="headerlink" title="8086&#x2F;8088存储器组织"></a>8086&#x2F;8088存储器组织</h2><p>存储器分段<br>– 为什么分段<br>• 地址寄存器均为16位： 216 &#x3D; 64KB<br>– 分段方便操作系统进行存储管理<br>– 如何分段<br>• 8086地址空间为20位&#x3D;1MB，地址为5位16进制数：00000H~FFFFFH<br>– 从偏移地址考虑，理论上最多16个不重叠的地址段<br>– 从段地址考虑，最多可以定义216个不同段<br>– 段重叠<br>• 段区分配通常由操作系统完成<br>– CS、DS、SS、ES存储与程序相关的段基址<br>– IP、SP、BP、SI、DI存储与程序相关的偏移地址<br>逻辑地址和物理地址<br>– 逻辑地址<br>• 程序和指令表示的一种地址<br>• 包括两部分：段地址和偏移地址<br>– 物理地址<br>• 段地址*\16+偏移地址&#x3D;物理地址<br>– 寻址操作根据操作系统默认规则完成<br>堆栈（段）<br>– 机制<br>• 栈顶为唯一出入口<br>– 地址较小的一端<br>• 后进先出原则<br>– 作用<br>• 数据暂存<br>• 保留轨迹<br>段加偏移”寻址机制允许重定位<br>– 重定位是指一个完整的程序块或数据块可以在存储器所允许的空<br>间内任意浮动，并定位到一个新的可寻址的区域<br>– 允许程序和数据不需要做任何修改</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>• 微处理器的设计有CISC与RISC两种基本架构。深入理解16位微处理器8086的内部结构<br>及其工作原理，是掌握微机工作原理的基础和关键。Intel系列高档微处理器内部的复杂<br>结构及其工作原理，都是在8086CPU的结构基础上逐步分解结构和细化流水线操作而发<br>展起来的。透彻地掌握8086CPU的基础，将有利于理解高档微处理器的技术发展。<br>• 8086&#x2F;8088 CPU的内部结构由总线接口单元BIU和执行单元EU两部分组成。其内部有3<br>组共14个寄存器，必须了解它们各自的功能，并能掌握它们的使用方法。<br>• 总线周期是理解CPU按时序工作的重要概念。8086&#x2F;8088 CPU一个最基本的总线周期由<br>4个时钟周期组成，简称为4个状态，即T1、T2、T3与T4这4个状态。<br>• 微处理器的引脚及其功能是其重要的外部特性。由于8086／8088 CPU只有40条引脚，<br>学习和掌握它们的功能相对于高档微处理器说来就比较简单。</p>
<p>CF - 进位标志(Carry Flag),表示上一条指令的运算是否产生进位。如果产生进位,CF为1,否则为0。OF - 溢出标志(Overflow Flag),表示上一条指令的结果是否越界。如果结果超出目的操作数可以表示的范围,OF为1,否则为0。<br>SF - 符号标志(Sign Flag),表示上一条指令运算结果的符号。如果结果为负数,SF为1,如果为正数,SF为0。<br>ZF - 零标志(Zero Flag),表示上一条指令的运算结果是否为0。如果结果为0,ZF为1,否则为0。</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>计算机是通过指令来处理各种数据，为指出数据的来源、<br>操作结果的去向及执行何操作，一条指令必须包含以下信<br>息：<br>– (1) 操作码——位数及位置。<br>– (2) 操作数的地址——操作数的个数<br>– (3) 操作结果的存储地址。<br>– (4) 下一条指令的地址<br><code>指令长度   – 可以等于机器字长，也可以大于或小于机器字长。   • 尽可能短   • 等于字节的整数倍。   – 若所有指令的长度都是相等的，称为定长指令字结构   • RISC指令大多采用定长指令结构   – 若各种指令的长度随指令功能而异， </code>操作码<br>– 操作码的位数取决于计算机指令系统的规模<br>– 定长编码和变长编码<br>变长编码：分散地放在指令字的不同字段中，如INTEL 8086&#x2F;Pentium<br>– 优点：能表示更多的指令<br>– 缺点：增加了译码难度，控制器复杂<br><code>指令涉及的数据类型   – 地址：无符号数，一般是加减操作（含移位）   • 8、16或32位   – 数值数据   • 定点数（整数）：补码表示   – 16位、32位、64位   • 浮点数（实数）：IEEE754标准   – 位、位串、字符与字符串   • 用来表示文本、声音和图像等   • 字节、字(16位)、双字(32位)、四字(64位)   – 现代32位计算机通常以32位为一个字：字节、半字(16位)、字(32位)、双字(64位)   – 逻辑数据   • 按位操作（0-假/非0-真） </code>数据寻址方式<br>– 有效地址EA（Effective Address）&#x3D;基址值（BX或BP）+变址<br>值（SI或DI）+位移量DISP<br>• +段基址&#x3D;物理地址<br>– 根据命令判断字段长短<br>• 通常由寄存器长度决定</p>
<h3 id="寻址方式-1"><a href="#寻址方式-1" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>直接数据寻址</li>
<li>寄存器间接寻址（间接寻址目标为存储器，故不能确定目标位置长度）</li>
<li>基址加变址寻址</li>
<li>寄存器相对寻址</li>
<li>相对基址加变址寻址(带DISP的基址加变址寻址)<br>程序存储器寻址方式<br>– 实现程序转移<br>• 条件转移<br>– 段内短转移（-128~+127）<br>• JMP<br>– 段内&#x2F;段间，直接&#x2F;间接寻址<br>• CALL<br>– 段内&#x2F;段间，直接&#x2F;间接寻址<br>• 中断<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">其他寻址方式  </span><br><span class="line">– 串操作指令寻址方式  </span><br><span class="line">• 操作类别：清0、复制、比较等  </span><br><span class="line">• 源数据地址：DS:SI  </span><br><span class="line">• 目标数据地址：ES:DI  </span><br><span class="line">– I/O端口寻址方式  </span><br><span class="line">• 直接端口寻址  </span><br><span class="line">– IN AL, n OUT n, AL  </span><br><span class="line">– 端口号：0～255  </span><br><span class="line">• 间接端口寻址  </span><br><span class="line">– IN AL, DX OUT DX, AL  </span><br><span class="line">– 端口号：0～65535</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通用数据传送"><a href="#通用数据传送" class="headerlink" title="通用数据传送"></a>通用数据传送</h2><p>&#x2F;&#x2F;CS - Code Segment,代码段寄存器。它保存代码段的起始地址,用于查找程序的指令。IP - Instruction Pointer,指令指针寄存器。它保存下条指令的地址,用于告诉CPU去哪里找到下一条要执行的指令。<br>1、基本传送指令 MOV（Move）：传送<br>– 一般形式：MOV dest, src<br>• dest  src，将源操作数src复制到目的操作数dest，src不变<br>2、堆栈操作<br>– PUSH src<br>– POP dest<br>– LIFO后进先出<br>– 堆栈操作按字进行<br>– 不能POP CS<br>3、XCHG（Exchange）：交换<br>– 一般形式：<br>• XCHG oprd1, oprd2 ;交换oprd1与oprd2的内容<br>– 语法格式：<br>• XCHG reg&#x2F;mem, reg&#x2F;mem<br>4.字节翻译指令XLAT（代码转换或查表指令）<br>– BX 基址：代码转换表首地址（表大小：0~255）<br>– AL 偏移（码值）<br>MOV BX,0030H<br>MOV AL,5<br>XLAT</p>
<h2 id="目标地址传送类指令"><a href="#目标地址传送类指令" class="headerlink" title="目标地址传送类指令"></a>目标地址传送类指令</h2><p><code>LEA（Load Effective Address）装入有效地址   – 语法格式：LEA reg16, mem ;reg16 = mem的有效地址   – 通常用于建立串操作   – 对标志位的影响：无。   – 【例】设BX = 5678H   • LEA SI, 2\[BX]   ;执行后，SI = 567AH 将计算结果放入BX寄存器,而不会访问那个地址的值 </code>LDS reg16, mem<br>– 定位串操作源地址<br>– LDS SI, [DI+100AH]<br>– 低16位存入reg16，高16位存入DS<br><code>LES reg16, mem   – 定位串操作目标地址   – 同上，高16位存入ES </code>LAHF、SAHF（保存和设置标志位）<br>– 与AH寄存器交互<br>– SF：符号标志：运算结果符号位<br>– ZF：零标志：运算结果是否为0<br>– AF：辅助进位标志：低四位是否向高四位进位<br>– PF：奇偶标志：是否有偶数个1<br>– CF：进位标志：是否进位&#x2F;借位</p>
<h2 id="算术运算类指令"><a href="#算术运算类指令" class="headerlink" title="算术运算类指令"></a>算术运算类指令</h2><p>加法<br>– 一般形式：<br>• ADD dest, src ; dest  dest + src<br>• ADC dest, src ; dest  dest + src + CF<br>• INC oprd ;oprd  oprd + 1<br>– 语法格式：<br>• ADD reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• ADC reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• INC reg&#x2F;mem<br>– 对标志位的影响：<br>• ADD、ADC：按一般规则影响CF、OF、SF和ZF<br>• INC：不影响CF，其它同ADD<br>• ADD与ADC的2个操作数必须类型匹配，且不能同时是内存操作数<br>减法<br>– 一般形式：<br>• SUB dest, src ; dest  dest - src<br>• SBB dest, src ; dest  dest - src - CF<br>• CMP oprd1, oprd2 ; oprd1 - oprd2<br>– 与SUB的区别在于，不将减法结果存入dest，只影响标志位<br>• DEC oprd ; oprd  oprd - 1<br>• NEG oprd ; oprd  0 – oprd &#x3D; oprd + 1<br>– 语法格式：<br>• SUB reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• SBB reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• CMP reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• DEC reg&#x2F;mem<br>• NEG reg&#x2F;mem<br>SUB、SBB、CMP：影响CF、OF、SF、ZF、AF和PF<br>• DEC：不影响CF，其它同SUB<br>• SUB与SBB的2个操作数必须类型匹配，且不能同时是内存操作数<br>乘法<br><code>– MUL（Unsigned Multiplication）：无符号乘法   – 一般形式：   • MUL src   – 语法格式：   • MUL reg8/mem8 ; AX = AL × src   • MUL reg16/mem16 ; DX:AX = AX × src   • 对标志位的影响：若8位×8位、16位×16位的结果分别能由8、16位容   纳（即结果的高一半为0），则CF = OF = 0，否则，CF = OF = 1；其   余标志无定义。   • 由于2个n位数的乘积可能需要2n位，因此，若操作数是8位，则结果为   16位；同样，16位操作数相乘结果为32位（80386中32位数相乘结果   为64位）。 </code>IMUL（Integer Multiplication）：带符号乘法<br>– 一般形式：<br>• IMUL src<br>– 语法格式：<br>• IMUL reg8&#x2F;mem8 ; AX &#x3D; AL × src<br>• IMUL reg16&#x2F;mem16 ; DX:AX &#x3D; AX × src<br>• 对标志位的影响：若结果的高一半为低一半的符号扩展，则CF &#x3D; OF &#x3D;<br>0，否则，CF &#x3D; OF &#x3D; 1；其余标志无定义<br>– 【例】对于同一个二进制数，采用 MUL与IMUL执行的结果可能<br>不同。设AL &#x3D; 0FFH，BL &#x3D; 1，分别执行下列指令，会得出不同<br>结果。<br>• MUL BL ; AX &#x3D; 00ffh（255D）<br>• IMUL BL ; AX &#x3D; 0ffffh（-1D）<br>除法<br>– 一般形式：<br>• DIV src ; 无符号数除法<br>• IDIV src ; 带符号数除法<br>– 语法格式：<br>• DIV reg&#x2F;mem<br>• IDIV reg&#x2F;mem<br>– 功能描述：<br>• src是8位：AX÷src，结果商在AL、余数在AH<br>• src是16位：DX:AX÷src，结果商在AX、余数在DX<br>– 对标志位的影响：无定义<br>– 若是8位÷8位或16位÷16位怎么解决？</p>
<p>符号扩展<br>– 对标志位的影响：无<br>– CBW、CWD（Convert Byte&#x2F;Word to Word&#x2F;Double word）<br>– 语法格式：<br>• CBW ; AL符号扩展为AX<br>– (若AL为正数,则零扩展,若AL为负数,则扩展部分全1)<br>• CWD ; AX符号扩展为32位数DX:AX<br>– 【例】设AL &#x3D; 0FEH，给出依次执行下列指令后的结果。<br>• CBW ; ax &#x3D; fffeh<br>• CWD ; dx &#x3D; ffffh, ax不变，即dx:ax &#x3D; -2<br>• 十进制调整指令（不要求）<br>– BCD码的加减乘除</p>
<h2 id="逻辑运算类指令"><a href="#逻辑运算类指令" class="headerlink" title="逻辑运算类指令"></a>逻辑运算类指令</h2><p>AND reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– OR reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– XOR reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– NOT reg&#x2F;mem<br>– TEST reg&#x2F;mem, reg&#x2F;mem&#x2F;imm；执行AND操作但不存储<br>结果<br>• 对标志位的影响：<br>– NOT：无。<br>– 其它指令：CF &#x3D; OF &#x3D; 0，按一般规则影响SF和ZF<br>&#96;使某位变反，其余位保持不变：对应位异或1，其余位为0<br>• 例： XOR AL, 60H ; 使第5、6两位为原来码的反码<br>• 特例： XOR AL, 0FFH &#x3D; NOT AL</p>
<h2 id="移位指令和循环移位指令"><a href="#移位指令和循环移位指令" class="headerlink" title="移位指令和循环移位指令"></a>移位指令和循环移位指令</h2><p>一般形式：<br>– SHL dest, count ; dest逻辑左移，count为移位次数<br>– SAL dest, count ; dest算术左移<br>– SHR dest, count ; dest逻辑右移<br>– SAR dest, count ; dest算术右移<br>– ROL, ROR循环左&#x2F;右移；RCL, RCR带进位标志循环左&#x2F;右移<br>对标志位的影响：<br>– 移位次数为1时，若移位后符号位发生了变化，则OF &#x3D; 1，否则<br>OF &#x3D; 0；若移位次数 &gt; 1，则OF无定义<br>– 按一般规则影响ZF与SF。然而，若移位次数为0，则不影响标志<br>位；CF为最后移入位<br>• 参数规范：当count &#x3D; 1时，可以立即数输入，否则需先<br>存入CL中；count取值范围0~255<br>• 【例】设AX的值为一个2字节非压缩BCD码，将其转换为<br>1字节压缩BCD码存入AL。<br>MOV CL, 4<br>SHL AH, CL ; ah低4位移到高4位<br>AND AL , 0FH ; al高4位清0<br>OR AL , AH</p>
<h2 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h2><p>目标和源都是存储器 (字、字节)<br>– DS:SI 提供源，ES:DI提供目的，CX提供长度<br>• 种类<br>– MOVS（Move）传送<br>– CMPS（Compare）比较<br>– SCAS（Scan）搜索<br>– LODS（Load）读<br>– STOS（Store）写<br>• 方向（DF标志位）<br>• 重复前缀<br>– REP（Repeat）<br>– REPE&#x2F;REPZ<br>– REPNE&#x2F;REPNZ</p>
<h2 id="程序控制类指令"><a href="#程序控制类指令" class="headerlink" title="程序控制类指令"></a>程序控制类指令</h2><p>无条件转移JMP（Jump）<br>• 一般形式：<br>– JMP target ; 转移到target指定的目标地址处<br>– 根据转移的距离，JMP指令可分为下列两类：<br>• 段内转移：在同一代码段内进行，又称近（Near）转移，只要修改IP的<br>值即可实现<br>• 段间转移：可在不同代码段之间进行，又称远（Far）转移，需要同时<br>修改CS和IP的值<br>– 根据目标地址的指定方式，JMP指令又可分为直接转移和间接转<br>移<br>• 直接转移：是指转移的目标地址直接出现在指令中，在程序执行前就已<br>确定<br>• 间接转移：指转移的目标地址是寄存器或内存操作数的值，只有执行到<br>该条指令时才能确定<br>– 直接转移<br>• JMP [NEAR PTR] label ; 段内转移<br>– 目标地址 &#x3D; IP + label（2字节） ; ±32KB<br>例：JMP ADDR1 ; ADDR1代表一个段内目标地址<br>ADDR1与当前IP位移量1235H, CS&#x3D;1500H, IP&#x3D;2400H<br>目的地址：18638H<br>JMP SHORT label<br>– 目标地址 &#x3D; IP + label（1字节） ; -128~127<br>• JMP FAR PTR label ; 段间转移<br>– 间接转移<br>• JMP reg16&#x2F;WORD PTR mem<br>; IP &#x3D; reg16&#x2F;mem16 段内间接转移<br>例：JMP FAR PTR ADDR2 ; ADDR2代表一个段间目标地址<br>ADDR2所在CS&#x3D;6500H，IP&#x3D;020CH<br>目的地址：6520CH<br>例：JMP BX ；BX→IP，CS不变<br>JMP WORD PTR [DI] ；[DS:DI] →IP，CS不变<br>JMP DWORD PTR mem<br>– ; CS &#x3D; [mem+2]，IP &#x3D; [mem]<br>例：当前CS&#x3D;1000H, IP&#x3D;026AH<br>DS&#x3D;2000H, BX&#x3D;1400H, ADDR3&#x3D;020AH<br>JMP DWORD PTR [BX+ADDR3]<br>CS&#x3D;4000H, IP&#x3D;320EH<br>• CALL过程名<br>– CALL NEAR PROC 段内直接寻址（修改IP, CS不变）<br>– CALL BX 段内间接转移（BX → IP）<br>– CALL FAR PROC 段间直接调用<br>• IP、CS都改变，例如：CALL 2000H:5600H<br>• 返回地址入栈包括CS和IP<br>– CALL DWORD PTR [reg16] 段间间接调用<br>• 低字 → IP，高字 → CS<br>– CALL与JMP区别<br>• CALL调用时会将修改前IP（或IP与CS）入栈，且完成后会返回当前位置<br>• RET<br>– 要和CALL调用类型对应：RET（段内）与RETF（段间）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例】求AX累加器和BX累加器中两个无符号数之差的绝  </span><br><span class="line">对值，结果放在2800H单元中  </span><br><span class="line">CMP AX, BX  </span><br><span class="line">JB AA  </span><br><span class="line">SUB AX, BX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], AX  </span><br><span class="line">JMP STOP ;该句缺少怎样？  </span><br><span class="line">AA: SUB BX, AX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], BX  </span><br><span class="line">STOP： HLT</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【例】从外设71H中取一个数M,判断其值是否在10和20之  </span><br><span class="line">间，如果M≥20，则送0FFH给外设73H;如果M&lt;10,则送  </span><br><span class="line">00H给外设73H;如果10≤M&lt;20,则送88H给外设73H  </span><br><span class="line">IN AL, 71H  </span><br><span class="line">CMP AL, 10  </span><br><span class="line">JNC LP1  </span><br><span class="line">MOV AL, 00H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP1: CMP AL, 20  </span><br><span class="line">JNC LP2  </span><br><span class="line">MOV AL, 88H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP2: MOV AL, 0FFH  </span><br><span class="line">LP3: OUT 73H, AL  </span><br><span class="line">HLT</span><br></pre></td></tr></table></figure>
<p>循环控制（短地址区间）<br>– LOOP 目标地址<br>• CX-1,如CX≠0,转移到目标地址（负值）<br>– LOOPE&#x2F;LOOPZ 目标地址<br>• CX-1,如ZF&#x3D;1且CX≠0循环（LOOPNE&#x2F;LOOPNZ时ZF&#x3D;0）  </p>
<figure class="highlight plaintext"><figcaption><span>【例】求2个数组之和，每个数组长度为N。如遇到2个组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数元素都为0，则停止求和  </span><br><span class="line">MOV SI, -1  </span><br><span class="line">MOV CX, N  </span><br><span class="line">NEXT: INC SI  </span><br><span class="line">MOV AL, [ADDR1 + SI]  </span><br><span class="line">ADD AL, [SI + ADDR2]  </span><br><span class="line">MOV [SI + ADDR3], AL  </span><br><span class="line">LOOPNZ NEXT</span><br></pre></td></tr></table></figure>
<p>中断指令<br>– INT 中断类型<br>• 0-255<br>• 中断向量表<br>– 每种中断占4个字节<br>» 前两个为偏移地址，后两个为段地址<br>– 和CALL的区别<br>• 相同点：断点入栈<br>• 不同点<br>– 清除中断标志IF<br>– 清除单步标志TF<br>– 标志寄存器入栈<br>• 【例】 INT 20H<br>– IRET<br>– INTO 溢出中断（中断号04H）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">延时一秒</span><br><span class="line">START: MOV CX, 1000  </span><br><span class="line">DELAY1S: CALL DELAY1MS  </span><br><span class="line">LOOP DELAY1S  </span><br><span class="line">HLT  </span><br><span class="line">DELAY1MS: PUSH CX  </span><br><span class="line">MOV CX, 374  </span><br><span class="line">LP1: PUSHF  </span><br><span class="line">POPF  </span><br><span class="line">LOOP LP1  </span><br><span class="line">POP CX  </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><code>汇编流程   – 汇编源程序：用助记符指令、变量名和标号编写的程序。   • 文件名：\*\*\*.ASM   – 目标程序：机器能识别的二进制代码程序。   • 文件名：\*\*\*.OBJ   – 执行程序：为PC系统所接受的应用程序。   • 文件名：\*\*\*.EXE   • 工具程序   –</code> 汇编程序：把汇编源程序翻译成机器能识别的机器指令程序的工<br><code>具程序。   • 文件名：MASM.EXE   – 连接程序：把目标文件与库文件以及其他目标文件连接在一起。   • 文件名：LINK.EXE </code>汇编语言语句类型<br>– 指令性语句——真指令<br>• 实际的CPU指令<br>• 汇编程序将其翻译成机器目标代码<br>• 由四部分组成：<br>[标号:] 指令助记符 [操作数] [; 注释]<br>– 指示性语句——伪指令[伪操作指令]<br>• 方便编制程序<br>• 不产生代码<br>[名字] 伪操作命令 [操作数表] [; 注释]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SSEG SEGMENT PARA STACK ; 堆栈段定义  </span><br><span class="line">DW 256 DUP (?)  </span><br><span class="line">SSEG ENDS  </span><br><span class="line">DSEG SEGMENT ; 数据段定义  </span><br><span class="line">MESS DB &#x27;HELLO&#x27;, 0DH, 0AH, &#x27;$&#x27;  </span><br><span class="line">DSEG ENDS  </span><br><span class="line">CSEG SEGMENT ; 代码段(指令区)  </span><br><span class="line">ASSUME CS:CSEG, DS:DSEG ; 规定段的性质  </span><br><span class="line">START: MOV AX, DSEG ; 设置数据段基值  </span><br><span class="line">MOV DS, AX  </span><br><span class="line">MOV DX, OFFSET MESS ; 显示字符串信息  </span><br><span class="line">MOV AH, 09  </span><br><span class="line">INT 21H  </span><br><span class="line">MOV AH,4CH ; 结束本程序运行，返回DOS  </span><br><span class="line">INT 21H  </span><br><span class="line">CSEG ENDS  </span><br><span class="line">END START  </span><br><span class="line">汇编语言有若干个段  </span><br><span class="line">段名、开始、结束  </span><br><span class="line">唯一的END结束  </span><br><span class="line">定义起始执行地址</span><br></pre></td></tr></table></figure>
<p>表达式和运算符<br>– 由汇编程序计算<br>• 值<br>• 地址<br>– 算术运算符（7种）<br>• +、-、*、&#x2F;<br>• MOD<br>• SHL、SHR<br>逻辑运算符（4种）<br>• AND、OR、XOR、NOT<br>• 和指令助记符的区别<br>• MOV AL, 0ADH AND 0EAH → MOV AL, 0A8H<br>– 关系运算符（6种）<br>• EQ、NE、LT、GT、LE、GE<br>• 关系成立时返回0FFFFH，不成立时返回0<br>– 数值返回运算符<br>• SEG<br>• OFFSET<br>• TYPE<br>• SIZE<br>• LENGTH<br>属性运算符<br>• PTR 修改操作数类型<br>• THIS</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>数据定义伪指令（变量定义）<br>– 数据定义伪指令用来为数据分配内存空间(规定变量的类型），<br>并设置相应内存单元的初始值。<br>– 形式：<br>变量名 变量定义符 操作数, 操作数, …, 操作数<br>• 其中，变量名是一个符号地址，表示其后操作数的首地址，变量名为可<br>选项，给出变量名只是为了按名存取其对应的内存单元。<br>变量定义符主要包括下列几种<br>– DB（Define Byte）：定义字节，后面的每个操作数占1个字节。<br>– DW（Define Word）：定义字，后面的每个操作数占1个字。<br>– DD（Define Dword）：定义双字，后面的每个操作数占2个字。<br>– 操作数可以是<br>• 常数 例：DATA DB 10, 4, 10H<br>• 表达式 例：DATA DW 2*3, 8&#x2F;4<br>• 字符串 例：DATA DB ‘ABCD’<br>– ？表示只保留内存空间，未定义初始值。<br>• 例：DATA DD ？, 1, ？<br>• 重复次数 DUP （操作数，．．．，操作数）<br>– 例：DATA DB 3 DUP（？，9）</p>
<h2 id="存储器的分类与组成"><a href="#存储器的分类与组成" class="headerlink" title="存储器的分类与组成"></a>存储器的分类与组成</h2><p><code>存储器分类   – 程序的执行是从主存中自动的取指令到控制器进行解释执行，需   要的数据也放在主存中根据指令需要存取。   – 按存储介质分类   • 半导体存储器：双极型，静态MOS型，动态MOS型   • 磁表面存储器：磁盘（Disk）、磁带 （Tape）   • 光存储器：CD、CD-ROM、DVD   – 按断电后信息的可保存性分类   • 非易失性存储器   – 信息可一直保留，不需电源维持（如 ：ROM、磁表面存储器、光存储器等）   • 易失性存储器   – 电源关闭时信息自动丢失。（如：RAM、Cache等） – 按存储器功能分类   • 读写存储器（Read/Write Memory)：可读可写   • 只读存储器（Read Only Memory)：只能读不能写   – 按工作方式/存取方式分类   • 随机存取存储器Random Access Memory (RAM)   – 每个单元读写时间一样，且与各单元所在位置无关，如：内存。   • 顺序存取存储器Sequential Access Memory (SAM)   – 数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置   有关，例如：磁带。   • 直接存取存储器Direct Access Memory (DAM)   – 直接定位到要读写的数据块，在读写某个数据块时按顺序进行。例如：磁盘。   • 相联存储器Associate Memory/Content Addressed Memory (CAM）   – 按内容存储与检索，根据内容访问存储位置并进行读写。例如：快表。 – 按容量/速度   • 寄存器   • 高速缓存   • 主存   • 外存储器 </code>参数<br>– 存取速度：<br>• 存取时间𝑇𝑎：指的是CPU从启动一次存储器操作到完成所需要的时间。<br>• 存取周期𝑇𝑚：是指连续启动两次独立的存储器操作所需最小时间间隔。<br>• 带宽（数据传输速度）</p>
<h3 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h3><p>– 读<br>• CPU先把读单元地址送到AR，经过地址总线送往主存，同时CPU通过控<br>制总线发一个读请求，然后CPU等待从主存储器发来的信号，通知CPU<br>读操作已经完成。<br>• 存储器通过ready线回答，如果ready信号为1，说明存储字的内容已经<br>读出，并放在数据总线上，送往DR。<br>– 写<br>• CPU先将写单元地址经AR送往地址总线，并把写内容字送DR，同时通<br>过控制总线发出写命令，然后CPU等待写操作完成信号。<br>• 主存把收到的信息字写入CPU指定的地址后通过ready线发出完成信号。</p>
<h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><p>分类<br>– ROM<br>• 芯片的内容在制造时已经输入，只能读，不能修改。<br>• 存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。存储<br>元件：二极管或晶体管。<br>– PROM（Programmable ROM, PROM）<br>• 用户可根据自己的需要来确定ROM里的内容，常见的是熔丝式PROM<br>是以熔丝的接通来表示1、断开表示0。常用于工业控制机。<br>– EPROM（Erasable PROM, EPROM）<br>• 紫外线擦除，只能对芯片进行整体擦除，而不能对芯片中个别需要改写<br>的存储单元单独擦除。编程次数不受限制。<br>E2PROM（Electrically EPROM）<br>• 电擦除，可以用字擦除方式擦除，也可以用数据块擦除方式擦除。以字<br>擦除方式操作时，能够只擦除被选中的那个存储单元的内容；在数据块<br>擦除方式操作时，可擦除数据块内所有单元的内容。编程次数受限制。<br>– 闪速存储器（Flash Memory）<br>• 一种快擦写型存储器，它的主要特点是：既可在不加电的情况下长期保<br>存信息，又能进行快速擦除（整体擦除或分区擦除）与重写，兼备了E2<br>PROM和RAM的优点。<br>• 闪存的读取速度与DRAM相近，是磁盘的100倍左右；写数据（快擦－<br>编程）则与硬盘相近。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li>字扩展（位数不变、扩充容量）</li>
<li>位扩展（字数不变，位数扩展）</li>
<li>字位同时扩展（字和位同时扩展）</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>解决内存访问速度慢的措施有三个：<br>• 提高主存芯片本身的速度<br>• 采用多模块存储器技术<br>• 在主存和CPU之间加入Cache</p>
<h3 id="外部存储器（辅助存储器"><a href="#外部存储器（辅助存储器" class="headerlink" title="外部存储器（辅助存储器"></a>外部存储器（辅助存储器</h3><p>磁表面存储器<br>– 两类：数字磁记录和模拟磁记录。<br>– 原理：磁性材料沉积在基体上形成记录介质，通过磁头与记录介<br>质的相对运动来读写信息。<br>– 优点：<br>①容量大，位价低<br>②记录介质可重复使用<br>③信息可长期保存甚至可脱机保存<br>④非破坏性读出<br>– 缺点：<br>①速度慢<br>②对工作环境要求高<br>光存储器<br>– 记录原理：用激光在具有感光特性的介质上非接触地记录高密度<br>信息，以介质材料的光学性质的变化来表示0或1。<br>– 优点：容量大、可替换（便携带）<br>– 缺点：速度慢。</p>
<p>寻址时间<br>– 寻址时间包括两部分：磁头寻找目标磁道所需的寻道时间和找到<br>磁道后磁头等待所需要读写的区段旋转到磁头下方的等待时间。<br>– 平均寻址时间&#x3D;平均寻道时间+平均等待时间<br>– 平均等待时间与磁盘转速有关，用磁盘旋转一周所需时间的一半<br>来表示。<br>数据传输率<br>– 外部：磁表面存储器的缓存在单位时间内与主机之间传送数据的<br>位数或字节数。<br>• 单位bps。<br>• 取决于总线的类型和标准<br>– ATA、SCSI、SATA、SAS<br>– 内部：磁头与硬盘内存之间的数据传输率。<br>• 传输率&#x3D;记录密度D x 运动速度V<br>• 误码率<br>– 衡量磁表面存储器的出错概率，等于出错信息的位数和读出的总<br>信息位数比。<br>磁盘cache<br>– 基本情况：硬盘内存速度差 (ms-ns)<br>• 可采用增加磁盘主轴转速<br>• 提高I&#x2F;O总线速度<br>• 改进读写算法<br>• 采用磁盘cache等方法<br>– 缓存的大小与速度是直接关系到硬盘的传输速度的重要因素。<br>– 主流硬盘的缓存8M以上（有些甚至1G）。<br>– 类型一般是DRAM或SDRAM。<br>– 采用预读策略（局部性规则）：对顺序数据特别有效<br>• 视频数据<br>• 图像文件<br>磁盘阵列存储器（RAID）<br>• 廉价冗余磁盘阵列（RAID）是用多台磁盘储存器组成的大<br>容量外存储子系统。（Redundant Arrays of<br>Inexpensive Disk）由美国加州大学伯克利分校提出。<br>• 目的<br>– 组合小的廉价磁盘来代替大的昂贵的磁盘，降低大批量数据存储<br>的费用；<br>– 希望采用冗余信息的方式，使得磁盘失效时不会使对数据的访问<br>受损失；<br>– 能适当的提升数据传输速度。<br>– 保证数据的可靠性和高可用性<br>RAID的实现<br>– 专门的控制芯片来完成<br>– 用软件的方法来实现，<br>RAID 0级（无冗余和无校验的数据分块）<br>– 将连续的数据块分别存放在不同的磁盘上。具有最高的I&#x2F;O性能<br>和磁盘空间利用率，无数据冗余，无容错能力，不能应用于数据<br>安全性要求高的场合。<br>• RAID 1级（镜像磁盘阵列）<br>– 由磁盘对组成，每一个工作盘都有对应的镜像盘，上面保存着与<br>工作盘完全相同的数据，安全性高，但磁盘空间的利用率只有<br>50%<br>RAID 2级（具有纠错海明码的磁盘阵列）<br>– 采用海明码纠错技术和位交叉技术，用户需增加足够的校验盘来<br>提供单纠错和双验错功能。当阵列内有G个数据盘时，则所需的<br>校验盘数C要满足公式： 2𝐶 ≥ 𝐺 + 𝐶 + 1，如果有4个数据盘，<br>则需要3个校验盘。对数据的访问涉及到磁盘阵列中的每一个盘，<br>对大数据量传送有较高性能，但不利于小数据量的传送。RAID<br>2很少使用。<br>位交叉存取<br>– 将一个数据段中的各位分别存储在不同的磁盘上，以同步方式进<br>行读写，最小访问数据单位是每个磁盘的最小读写单位（例如扇<br>区）X磁盘数。<br>– 适合传送批量数据<br>• 块交叉存取<br>– 以数据块为单位，将连续的数据块分别存放在不同的磁盘上，最<br>小访问数据单位是每个磁盘的最小读写单位（例如扇区）<br>– 适合传送少量数据<br>RAID 5级（无专用校验盘的奇偶校验磁盘阵列）<br>– 无专用的校验盘，将校验信息分布到组内所有盘上，对大、小数<br>据量的读写都有很好的性能，因而是一种较好的方案。<br>• RAID 10级（RAID 0级+RAID 1级）<br>– 由分块和镜像组成，是所有RAID中性能最好的磁盘阵列，但每<br>次写入时要写两个互为镜像的盘， CPU占用率高，磁盘的利用<br>率低<br>磁盘存储器与光盘存储器的比较<br>– 两种存储器的记录原理、组成部分等方面都是相同的。在计算机<br>中它们各有自己的特点与功能。<br>– 硬盘驱动器<br>• 容量大、数据传输率高、等待时间短。<br>– 光盘驱动器<br>• 存储密度高、容量大、价格低。但是光盘与主机的速度不匹配所以不能<br>作为中间存储器，即不能替代硬盘<br><img src="/images/obsidian/20230610145852.png" alt="图片" title="image"><br>为什么这种层次化结构是有效的？<br>– 时间局部性（Temporal Locality）<br>• 含义：刚被访问过的单元很可能不久又被访问<br>• 做法：让最近被访问过的信息保留在靠近CPU的存储器中<br>– 空间局部性 （Spatial Locality）<br>• 含义：刚被访问过的单元的邻近单元很可能不久被访问<br>• 做法：将刚被访问过的单元的邻近单元调到靠近CPU的存储器中<br>– 大量典型程序的运行情况分析结果表明：程序具有访问局部性特<br>征<br>• 指令：指令按序存放，地址连续，循环程序段或子程序段重复执行<br>• 数据：连续存放，数组元素重复、按序访问</p>
<p>• 键盘<br>– 键盘是一组排列成阵列形式的按键开关，按下一个键就产生一个<br>相应的字符，然后转换成ASCII或其他码送往主机<br>– 键盘输入信号处理可分为三个步骤：<br>• (1) 按下一个键；<br>• (2) 查出按下的是哪一个键；<br>• (3) 将该键翻译成能被计算机接收的代码<br>• 键盘的种类<br>– 机械式键盘<br>• 触点的导通或断开<br>• 每个键由底座、轴帽、轴帽固定卡、弹簧、金属支脚、触点金属片<br>导电橡胶式键盘<br>• 通过导电的橡胶实现触点的连接<br>– 电容式键盘<br>• 当人体（手指）接触金属感应片的时候，由于人体相当于一个接大地的<br>电容，因此会在感应片和大地之间形成一个电容<br>薄膜式键盘<br>• 无机械磨损<br>• 低价格<br>• 低噪音<br>• 低成本<br>• 市场占有相当份额<br>• 鼠标<br>– 一种坐标定位部件，只能用来输入相对坐标。<br>• CMOS传感器将每一幅图像都发送给数字信号处理器（DSP）进行分析。<br>• DSP检测各图像中的图案，并分析图像中图案的位置如何变动。<br>• 根据一系列图像中图案位置的变化，DSP确定鼠标的移动距离并将相应<br>坐标发送给计算机。<br>• 计算机根据从鼠标接收到的坐标信息，移动屏幕上的光标。<br>– 与轨迹球鼠标相比，光电鼠标具有下列优势：<br>• 没有可移动的零部件，这意味着磨损更少、故障率更低。<br>• 灰尘无法进入鼠标内部并干扰跟踪传感器。<br>• 增加的跟踪分辨率意味着响应更顺畅。<br>• 不需要鼠标垫等专用表面。<br>触摸屏<br>– 电阻式：利用压力感应进行控制电阻<br>– 电容式：利用人体的电流感应进行工作<br>– 红外式：在显示器上加上光点距架框，在屏幕表面形成一个红外<br>线网<br>– 表面声波触摸屏：玻璃屏的左上角和右下角各固定了竖直和水平<br>方向的超声波发射换能器，右上角则固定了两个相应的超声波接<br>收换能器。玻璃屏的四个周边则刻有45°角由疏到密间隔非常精<br>密的反射条纹<br>条形码（Bar Code）<br>– 由一组宽度和反射率不同的平行相邻条和空按预先规定的编码规<br>则组合起来，用来表示一组数据的符号<br>主要类型<br>• 堆叠式&#x2F;行排式<br>– 建立在一维条码基础之上，按需要堆积成二行或多行<br>– 继承了一维条码的一些特点<br>– 需要对行进行判定，其译码算法与软件也不完全相同于一维条码<br>• 矩阵式二维码<br>– 它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码<br>– 用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制<br>的“0”，点的排列组合确定了矩阵式二维条码所代表的意义<br>显示器显色原理<br>– 像素点：颜色显示的最小单元<br>• 一个像素点包含三原色<br>• 通过调整三原色的显示强弱来控制颜色<br>CRT<br>– 可用于字符、图形和图像显示器。<br>– CRT是一个真空器件，由电子枪、偏转装置和荧光屏组成。<br>– 玻璃屏内壁涂有荧光粉，它将电子束的动能转换成光能，显示出<br>光点。不同的荧光粉在电子束的轰击下发出不同的颜色。<br>– 对电子束的要求<br>• （1）电子束要有足够的强度和速度。<br>• （2）电子束要足够细。<br>• （3）电子束的运动方向要高度可控<br>有机发光二极管（OLED）<br>– 自发光的二极管，无需背光<br>• 等离子显示器（PDP）<br>– 利用惰性气体在一定电压下产生气体放电现象而实现的发光技术。<br>• 显示技术的重要技术指标<br>– 分辨率<br>• 字符显示方式<br>– 一屏可显示的最多字符数称为分辨率，例如80列×25行，表示每屏最多可显示25<br>行，每行可有80个字符。<br>• 在图形显示方式<br>– 一屏可显示的像点数称为分辨率，例如800×600，表示一屏可包含600条水平扫<br>描线，每线可分为800点。<br>• 分辨率越高，显示的信息越多<br>颜色数（位深）：每个像素点可显示的颜色数（灰度级）<br>• 每种原色由8位表示灰度，三原色共计224种颜色<br>• 实际传输过程中采用32位表示一种颜色，而高端显示器每种原色用10位<br>表示，总共可表示230，约10.7亿色<br>按打字原理分：击打式打印机（点阵针式打印机）和非击<br>打式打印机（喷墨打印机、激光打印机）。<br>• 按工作方式分：串行打印机和行式打印机。串行打印机一<br>次只能打一个字，行式打印机一次可以打印一行<br>• 常见打印机类型<br>– 点阵针式打印机<br>– 激光打印机<br>– 喷墨打印机<br>– 热转印和热敏打字机<br>• 发展趋势<br>– 击打式和非击打式并存<br>– 击打式的多样化、特殊化：银行、铁路、超市、酒店</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag"># 课程笔记</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="tag"># 计算机组成</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/" rel="prev" title="基于恐龙书和苏大ppt的操作系统笔记">
                  <i class="fa fa-angle-left"></i> 基于恐龙书和苏大ppt的操作系统笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/29/linux%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/" rel="next" title="基于北大前沿计算实践课和missing semester的linux等编程工具笔记">
                  基于北大前沿计算实践课和missing semester的linux等编程工具笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">thinklive</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">167k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:32</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 技术支持
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.7" zIndex="-2" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.umd.js" integrity="sha256-q8XkJ6dj5VwSvzI8+nATCHHQG+Xv/dAZBCgqmu93zOY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://thinklive1.github.io/2023/09/29/%E7%A1%AC%E4%BB%B6%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"thinklive1/blog_comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
