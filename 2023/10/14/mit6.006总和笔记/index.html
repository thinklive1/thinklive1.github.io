<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinklive1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础  算法合订本  数据结构  算法性质 循环不变式主要用来帮助我们理解算法的正确性。关千循环不变式，我们必须证明三条 性质： 初始化：循环的第一次迭代之前，它为真。 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助千证明算法是正确的。">
<meta property="og:type" content="article">
<meta property="og:title" content="基于mit6.006和hello-algo的算法笔记">
<meta property="og:url" content="https://thinklive1.github.io/2023/10/14/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="thinklive">
<meta property="og:description" content="基础  算法合订本  数据结构  算法性质 循环不变式主要用来帮助我们理解算法的正确性。关千循环不变式，我们必须证明三条 性质： 初始化：循环的第一次迭代之前，它为真。 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助千证明算法是正确的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/algo.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231016191822017.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230519150021.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230522103507.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230522140116.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230522140235.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230523213613.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_brute_force.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231016192215938.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231017150534371.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231014112423645.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_heap/build_heap.assets/heapify_operations_count.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231017101953076.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231017102411122.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231017102819736.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231017105216748.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231018222936126.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231018223015529.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231018223211763.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231016200400451.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231019194313076.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231019195835085.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231019110047558.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231019110111354.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231020131123959.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231020135416200.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231020140715299.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231020141331913.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231020141401286.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/QQ%E5%9B%BE%E7%89%8720231121160100.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231024194703867.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231023103416467.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231023104514707.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231024112814756.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231025202308176.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231024193957638.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231024193915317.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231025082230441.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231025092945965.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231025093817635.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231025080815803.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231025213904004.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231027103835269.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231027112657842.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231027200057225.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231027200227456.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231028110550677.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231027201108930.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/image-20231027201117355.png">
<meta property="article:published_time" content="2023-10-14T12:31:46.082Z">
<meta property="article:modified_time" content="2023-11-26T16:04:09.425Z">
<meta property="article:author" content="thinklive">
<meta property="article:tag" content="课程笔记">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="麻省理工">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thinklive1.github.io/assets/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/algo.png">


<link rel="canonical" href="https://thinklive1.github.io/2023/10/14/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://thinklive1.github.io/2023/10/14/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/","path":"2023/10/14/mit6.006总和笔记/","title":"基于mit6.006和hello-algo的算法笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>基于mit6.006和hello-algo的算法笔记 | thinklive</title>
  







 <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
<script type="text/javascript" async src="/js/fairyDustCursor.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --></head>
<script src="/js/tab-title.js"></script>
<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">thinklive</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">dirichlet labrary</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索 | search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页-|-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页 | home</a></li><li class="menu-item menu-item-标签-|-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags</a></li><li class="menu-item menu-item-分类-|-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories</a></li><li class="menu-item menu-item-归档-|-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archives</a></li><li class="menu-item menu-item-相册-|-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册 | photos</a></li><li class="menu-item menu-item-留言-|-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言 | guestbook</a></li><li class="menu-item menu-item-感谢-|-thanks"><a href="/thanks/" rel="section"><i class="fa custom thanks fa-fw"></i>感谢 | thanks</a></li><li class="menu-item menu-item-游戏-|-game"><a href="/game/bad1.html" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏 | game</a></li><li class="menu-item menu-item-神龛-|-shrine"><a href="/cyberblog/" rel="section"><i class="fa fa-microchip fa-fw"></i>神龛 | shrine</a></li><li class="menu-item menu-item-资源地图-|-resourcemap"><a href="/webstack/" rel="section"><i class="fa fa-list fa-fw"></i>资源地图 | resourcemap</a></li><li class="menu-item menu-item-思维导图-|-mindmap"><a href="/mindmap/index.html" rel="section"><i class="fa fa-map fa-fw"></i>思维导图 | mindmap</a></li><li class="menu-item menu-item-网站地图-|-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>网站地图 | sitemap</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">


<!--网易云音乐插件-->
<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->
<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--网易云playlist外链地址-->   
<meting-js
    server="netease"
    type="playlist" 
    id="2762741085"
    mini="false"
    fixed="false"
    list-folded="true"
    autoplay="false"
    volume="0.2"
    theme="#4c4c4c"
    order="random"
    loop="all"
    preload="auto"
    lrc-type="2"
    mutex="true">
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%B4%A8"><span class="nav-number">1.2.</span> <span class="nav-text">算法性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%E9%80%92%E5%BD%92"><span class="nav-number">1.3.</span> <span class="nav-text">分治法（递归）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E5%B3%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">寻峰算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.5.</span> <span class="nav-text">最大子数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E5%85%A5%E6%B3%95%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">代入法求解递归式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%A0%91%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">递归树法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%92%8C%E6%9F%A5%E6%89%BE"><span class="nav-number">2.</span> <span class="nav-text">选择和查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">2.1.</span> <span class="nav-text">二分搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE"><span class="nav-number">2.2.</span> <span class="nav-text">哈希查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.</span> <span class="nav-text">随机查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">比较排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91"><span class="nav-number">3.1.</span> <span class="nav-text">决策树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">3.2.1.</span> <span class="nav-text">最大堆的生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">3.2.2.</span> <span class="nav-text">时间复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AD%96%E7%95%A5"><span class="nav-number">3.2.3.</span> <span class="nav-text">排序策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#top-k%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.4.</span> <span class="nav-text">top-k问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.3.</span> <span class="nav-text">动态规划和二分搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91avl"><span class="nav-number">3.4.</span> <span class="nav-text">平衡二叉搜索树AVL</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-number">4.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">哈希的优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%93%88%E5%B8%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">利用哈希的字符串匹配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#karp-rabin-algorithm"><span class="nav-number">4.3.1.</span> <span class="nav-text">Karp-Rabin Algorithm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80"><span class="nav-number">4.4.</span> <span class="nav-text">开放寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">4.4.1.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">4.4.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">4.4.3.</span> <span class="nav-text">与链表的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E5%93%88%E5%B8%8C"><span class="nav-number">4.5.</span> <span class="nav-text">安全领域的哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">线性时间排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">5.1.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">5.2.</span> <span class="nav-text">基数排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97"><span class="nav-number">6.</span> <span class="nav-text">数值运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#catalan-numbers"><span class="nav-number">6.1.</span> <span class="nav-text">Catalan numbers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#newtons-method%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">Newton’s Method牛顿迭代法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="nav-number">6.2.1.</span> <span class="nav-text">高精度乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="nav-number">6.2.2.</span> <span class="nav-text">高精度除法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-number">7.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84"><span class="nav-number">7.1.1.</span> <span class="nav-text">路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bst"><span class="nav-number">7.2.</span> <span class="nav-text">BST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dst"><span class="nav-number">7.3.</span> <span class="nav-text">DST</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.1.</span> <span class="nav-text">拓扑排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.2.</span> <span class="nav-text">循环检测算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">7.4.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">7.4.1.</span> <span class="nav-text">简单最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%9D%83%E5%9B%BE%E5%9F%BA%E7%A1%80"><span class="nav-number">7.4.2.</span> <span class="nav-text">有权图基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">7.4.2.1.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dag%E6%9D%BE%E5%BC%9B%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.2.</span> <span class="nav-text">DAG松弛算法:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generic-s.p.-algorithm%E9%80%9A%E7%94%A8%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.3.</span> <span class="nav-text">Generic S.P. Algorithm通用最短路径算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E6%97%A0%E8%B4%9F%E6%95%B0%E8%BE%B9%E7%9A%84%E5%9B%BE"><span class="nav-number">7.4.4.</span> <span class="nav-text">迪杰斯特拉（无负数边的图）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%81%E6%98%8E"><span class="nav-number">7.4.4.1.</span> <span class="nav-text">证明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">7.4.4.2.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2"><span class="nav-number">7.4.4.3.</span> <span class="nav-text">优化——双向搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#a%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.4.4.</span> <span class="nav-text">A*算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9D%E5%B0%94%E6%9B%BC%E7%A6%8F%E7%89%B9"><span class="nav-number">7.4.5.</span> <span class="nav-text">贝尔曼福特</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E5%BE%AA%E7%8E%AF%E6%A3%80%E6%B5%8B"><span class="nav-number">7.4.5.1.</span> <span class="nav-text">负循环检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">7.4.5.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E7%9F%AD%E7%AE%80%E5%8D%95%E8%B7%AF%E5%BE%84"><span class="nav-number">7.4.5.3.</span> <span class="nav-text">最长简单路径和最短简单路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#johnsons-algorithm"><span class="nav-number">7.5.</span> <span class="nav-text">Johnson’s Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#all-pairs-shortest-paths-apsp"><span class="nav-number">7.5.1.</span> <span class="nav-text">All-Pairs Shortest Paths (APSP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">7.5.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="nav-number">7.5.3.</span> <span class="nav-text">时间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E7%8E%87"><span class="nav-number">8.</span> <span class="nav-text">概率</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E7%A4%BA%E5%99%A8%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F"><span class="nav-number">8.1.</span> <span class="nav-text">指示器随机变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="nav-number">8.2.</span> <span class="nav-text">随机算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">9.</span> <span class="nav-text">递归和动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lis"><span class="nav-number">9.0.1.</span> <span class="nav-text">LIS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alternating-coin-game"><span class="nav-number">9.0.2.</span> <span class="nav-text">Alternating Coin Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rod-cutting"><span class="nav-number">9.0.3.</span> <span class="nav-text">Rod Cutting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#subset-sum"><span class="nav-number">9.0.4.</span> <span class="nav-text">Subset Sum</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">9.1.</span> <span class="nav-text">复杂度</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="thinklive"
      src="/images/thive.png">
  <p class="site-author-name" itemprop="name">thinklive</p>
  <div class="site-description" itemprop="description">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinklive1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinklive1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/xthive@stu.suda.edn.cn" title="E-Mail → xthive@stu.suda.edn.cn" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/38099250?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;38099250?spm_id_from&#x3D;333.1007.0.0" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/thinklive" title="steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;thinklive" rel="noopener me" target="_blank"><i class="fa custom steam fa-fw"></i>steam</a>
      </span>
  </div>
<img src="/images/thinklive_cyber.png"; z-index: 0; style="max-width: 100%; width: auto; height: auto;background-color: #fff;">

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thinklive1.github.io/2023/10/14/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/thive.png">
      <meta itemprop="name" content="thinklive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="thinklive">
      <meta itemprop="description" content="起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="基于mit6.006和hello-algo的算法笔记 | thinklive">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于mit6.006和hello-algo的算法笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-14 20:31:46" itemprop="dateCreated datePublished" datetime="2023-10-14T20:31:46+08:00">2023-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-27 00:04:09" itemprop="dateModified" datetime="2023-11-27T00:04:09+08:00">2023-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课程笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>57 分钟</span>
    </span>
</div>

        
        </div>
      </header>
   

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="基础">基础</h1>
<figure>
<img src="/assets/mit6.006总和笔记/algo.png" alt="" /><figcaption>算法合订本</figcaption>
</figure>
<h2 id="数据结构">数据结构</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231016191822017.png" /></p>
<h2 id="算法性质">算法性质</h2>
<p><code>循环不变式</code>主要用来帮助我们理解算法的正确性。关千<code>循环不变式</code>，我们必须证明三条<br />
性质：<br />
初始化：循环的第一次迭代之前，它为真。<br />
保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。<br />
终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助千证明算法是正确的。</p>
<span id="more"></span>
<p>f(n) = O(g(n)) 类似于 a&lt;=b</p>
<p>f(n) = Ω (g(n)) 类似于 a&gt;=b</p>
<p>f(n) = θ (g(n)) 类似于 a=b</p>
<p>f(n) = o(g(n)) 类似于 a&lt;b</p>
<p>f(n) = w(g(n)) 类似于 a&gt;b <img src="/images/obsidian/20230519150021.png" title="image" alt="图片" /></p>
<h2 id="分治法递归">分治法（递归）</h2>
<h3 id="选择排序">选择排序</h3>
<ul>
<li>在A[:i+1]内找到最大的元素，和A[i]交换</li>
<li>递归地排序A[:i]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def selection_sort(A, i = None): # T(i)</span><br><span class="line">’’’Sort A[:i + 1]’’’</span><br><span class="line">    if i is None: i = len(A) - 1 # O(1)</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        j = prefix_max(A, i) # S(i)</span><br><span class="line">        A[i], A[j] = A[j], A[i] # O(1)</span><br><span class="line">        selection_sort(A, i - 1) # T(i - 1)</span><br><span class="line"></span><br><span class="line">def prefix_max(A, i): # S(i)找到最大元素的索引值</span><br><span class="line">’’’Return index of maximum in A[:i + 1]’’’</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        j = prefix_max(A, i - 1) # S(i - 1)</span><br><span class="line">        if A[i] &lt; A[j]: # O(1)</span><br><span class="line">            return j # O(1)</span><br><span class="line">    return i # O(1)</span><br></pre></td></tr></table></figure>
<p>python实现(迭代)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        k = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[k]:</span><br><span class="line">                k = j  <span class="comment"># 记录最小元素的索引</span></span><br><span class="line">        <span class="comment"># 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        nums[i], nums[k] = nums[k], nums[i]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">• prefix max analysis:</span><br><span class="line">– Base case: for i = 0, array has one element, so index of max is i</span><br><span class="line">– Induction: assume correct for i, maximum is either the maximum of A[:i] or A[i],</span><br><span class="line">returns correct index in either case</span><br><span class="line">• selection sort analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, last number of a sorted output is a largest number of</span><br><span class="line">the array, and the algorithm puts one there; then A[:i] is sorted by inductio</span><br></pre></td></tr></table></figure>
<p>性质：O(n^2)，非稳定原地排序</p>
<h3 id="插入排序">插入排序</h3>
<ul>
<li>类似扑克牌，从右侧选择未排序元素，逐个插入左侧的已排序部分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def insertion_sort(A, i = None): # T(i)</span><br><span class="line">’’’Sort A[:i + 1]’’’</span><br><span class="line">    if i is None: i = len(A) - 1 # O(1)</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        insertion_sort(A, i - 1) # T(i - 1)</span><br><span class="line">        insert_last(A, i) # S(i)</span><br><span class="line"></span><br><span class="line">def insert_last(A, i): # S(i)</span><br><span class="line">’’’Sort A[:i + 1] assuming sorted A[:i]’’’</span><br><span class="line">    if i &gt; 0 and A[i] &lt; A[i - 1]: # O(1)</span><br><span class="line">        A[i], A[i - 1] = A[i - 1], A[i] # O(1)</span><br><span class="line">        insert_last(A, i - 1) # S(i - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• insert last analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, if A[i] &gt;= A[i - 1], array is sorted; otherwise,</span><br><span class="line">swapping last two elements allows us to sort A[:i] by induction</span><br><span class="line"></span><br><span class="line">• insertion sort analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, algorithm sorts A[:i] by induction, and then</span><br><span class="line">insert last correctly sorts the rest as proved above</span><br></pre></td></tr></table></figure>
<p>python实现（迭代）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        base = nums[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; base:</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]  <span class="comment"># 将 nums[j] 向右移动一位</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = base  <span class="comment"># 将 base 赋值到正确位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性：复杂度O(n^2)，原地稳定排序</p>
<h3 id="归并排序">归并排序</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">A, a = <span class="number">0</span>, b = <span class="literal">None</span></span>): <span class="comment"># T(b - a = n)</span></span><br><span class="line">’’’Sort A[a:b]’’’</span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span>: b = <span class="built_in">len</span>(A) <span class="comment"># O(1)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> &lt; b - a: <span class="comment"># O(1)</span></span><br><span class="line">        c = (a + b + <span class="number">1</span>) // <span class="number">2</span> <span class="comment"># O(1)</span></span><br><span class="line">        merge_sort(A, a, c) <span class="comment"># T(n / 2)</span></span><br><span class="line">        merge_sort(A, c, b) <span class="comment"># T(n / 2)</span></span><br><span class="line">        L, R = A[a:c], A[c:b] <span class="comment"># O(n)</span></span><br><span class="line">        merge(L, R, A, <span class="built_in">len</span>(L), <span class="built_in">len</span>(R), a, b) <span class="comment"># S(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">L, R, A, i, j, a, b</span>): <span class="comment"># S(b - a = n)</span></span><br><span class="line">’’’Merge <span class="built_in">sorted</span> L[:i] <span class="keyword">and</span> R[:j] into A[a:b]’’’</span><br><span class="line">    <span class="keyword">if</span> a &lt; b: <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= <span class="number">0</span>) <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] &gt; R[j - <span class="number">1</span>]): <span class="comment"># O(1)</span></span><br><span class="line">            A[b - <span class="number">1</span>] = L[i - <span class="number">1</span>] <span class="comment"># O(1)</span></span><br><span class="line">            i = i - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># O(1)</span></span><br><span class="line">        A[b - <span class="number">1</span>] = R[j - <span class="number">1</span>] <span class="comment"># O(1)</span></span><br><span class="line">        j = j - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line">    merge(L, R, A, i, j, a, b - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">• merge analysis:</span><br><span class="line">– Base case: for n = 0, arrays are empty, so vacuously correct</span><br><span class="line">– Induction: assume correct for n, item in A[r] must be a largest number from remaining</span><br><span class="line">prefixes of L and R, and since they are sorted, taking largest of last items suffices;</span><br><span class="line">remainder is merged by induction</span><br><span class="line"> merge sort analysis:</span><br><span class="line">– Base case: for n = 1, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for k &lt; n, algorithm sorts smaller halves by induction, and then merge merges into a sorted array as proved above.</span><br></pre></td></tr></table></figure>
<p>python实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, mid: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并左子数组和右子数组&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 左子数组区间 [left, mid], 右子数组区间 [mid+1, right]</span></span><br><span class="line">    <span class="comment"># 创建一个临时数组 tmp ，用于存放合并后的结果</span></span><br><span class="line">    tmp = [<span class="number">0</span>] * (right - left + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 初始化左子数组和右子数组的起始索引</span></span><br><span class="line">    i, j, k = left, mid + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 当左右子数组都还有元素时，比较并将较小的元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将左子数组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        tmp[k] = nums[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">        tmp[k] = nums[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tmp)):</span><br><span class="line">        nums[left + k] = tmp[k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;归并排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 当子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="comment"># 划分阶段</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span>  <span class="comment"># 计算中点</span></span><br><span class="line">    merge_sort(nums, left, mid)  <span class="comment"># 递归左子数组</span></span><br><span class="line">    merge_sort(nums, mid + <span class="number">1</span>, right)  <span class="comment"># 递归右子数组</span></span><br><span class="line">    <span class="comment"># 合并阶段</span></span><br><span class="line">    merge(nums, left, mid, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性：O(nlgn)，稳定排序</p>
<h3 id="寻峰算法">寻峰算法</h3>
<p>一维情况： 实际上是一种二分查找，先查看中点是不是峰值，如果不是则选取邻居节点较大的一侧递归寻找 复杂度lgn</p>
<p>二维情况下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">• Pick middle column j = m/2</span><br><span class="line">• Find global maximum on column j at (i, j)</span><br><span class="line">• Compare (i, j − 1), (i, j), (i, j + 1)</span><br><span class="line">• Pick left columns of (i, j − 1) &gt; (i, j)</span><br><span class="line">• Similarly for right</span><br><span class="line">• (i, j) is a 2D-peak if neither condition holds</span><br><span class="line">• Solve the new problem with half the number of columns.</span><br><span class="line">• When you have a single column, find global maximum and you‘re done.</span><br><span class="line"></span><br><span class="line">T (n, m) = T (n, m/2) + Θ(n) (to find global maximum on a column — (n rows))</span><br><span class="line">T (n, m) = (Θ(n) + . . . + Θ(n))log m= Θ(n log m) = Θ(n log n) if m = n</span><br></pre></td></tr></table></figure>
<p>这种解法思路是：</p>
<ol type="1">
<li><p>对数组的中间一列寻找最大值</p></li>
<li><p>如果最大值是峰值，可以返回</p></li>
<li><p>否则对数组最大的邻居所在的一侧进行递归(即子问题大小为原来的一半)</p></li>
</ol>
<p>除此以外还有一种贪心解法：从(0,0)开始，不断寻找当前节点的最大邻居，并不断迭代，时间复杂度O(n^2) 还有一种θ(n)的解法，详见<a href="https://thinklive1.github.io/2023/11/20/mit6.006%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/">作业解析</a></p>
<h3 id="最大子数组">最大子数组</h3>
<p>算法思路： 元素和最大的子数组有三种情况：在左半数组，右半数组，或者跨越中点，第一和第二种情况可以用递归遍历解决，第三种情况则分为两个半边数组的组合，只要从中点出发寻找最大子数组，然后组合就可以了</p>
<p><code>时间复杂度分析</code>：，其中线性时间为跨越中点的子数组，最终需要时间为O(NlogN) <img src="/images/obsidian/20230522103507.png" title="image" alt="图片" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, low， high)  </span><br><span class="line">    if high== low  </span><br><span class="line">        return (low, high, A[low])  </span><br><span class="line">    else mid=mod((low 十 high)/2) </span><br><span class="line">        (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)  </span><br><span class="line">    </span><br><span class="line">        (right-low, right-high, right-sum) =  FIND-MAXIMUM-SUBARRAY(A, mid+l. high)  </span><br><span class="line">    </span><br><span class="line">        (cross-low, cross-high, cross-sum) =  FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)  </span><br><span class="line">    </span><br><span class="line">    if left-sum&gt;=right-sum and left-sum&gt;=cross-sum  </span><br><span class="line">        return (left-low, left-high, left-sum)  </span><br><span class="line">    </span><br><span class="line">    elseif rightr-sum&gt;= left-sum and right-sum&gt;= cross-sum  </span><br><span class="line">        return (right-low, right-high, right-sum)  </span><br><span class="line">    </span><br><span class="line">    else return (cross-low, cross-high, cross-sum)</span><br><span class="line"></span><br><span class="line">FIND-MAX-CROSSING--SUBARRAY(A, low, mid, high)  </span><br><span class="line">    left-sum = -oo  </span><br><span class="line">    sum=O  </span><br><span class="line">    for i = mid downto low  </span><br><span class="line">        sum=sum+A[i]  </span><br><span class="line">        if sum&gt; left-sum  </span><br><span class="line">            left-sum = sum  </span><br><span class="line">            max-left = i  </span><br><span class="line">    right-sum= -oo  </span><br><span class="line">    sum=O  </span><br><span class="line">    for j = mid + 1 to high</span><br><span class="line">        sum=sum + A[j]  </span><br><span class="line">        if sum &gt; right-sum  </span><br><span class="line">            right-sum = sum  </span><br><span class="line">            max-right = j  </span><br><span class="line">    return (max-left, max-right, left-sum + right-sum)</span><br></pre></td></tr></table></figure>
<h2 id="代入法求解递归式">代入法求解递归式</h2>
<ol type="1">
<li>猜测解的形式。<br />
</li>
<li>用数学归纳法求出解中的常数，并证明解是正确的。 猜测T(n)的上界，将其带入递归式，求出一个上界，随后寻找一个N0证明对所有n&gt;=n0，递归式T(n)成立 <img src="/images/obsidian/20230522140116.png" title="image" alt="图片" /> <img src="/images/obsidian/20230522140235.png" title="image" alt="图片" /></li>
</ol>
<h2 id="递归树法">递归树法</h2>
<p>递归树是良好的猜测递归式时间复杂度的方法，但由于构建递归树经常伴随简化，所以用其证明的话则不够严谨 以递归式 T(n)=3T(ln/4 」) +S(n2) 为例，来看一下如何用递归树生成一个好的猜测 递归树有 log4n+l 层， <img src="/images/obsidian/20230523213613.png" title="image" alt="图片" /> 由于根结点对总代价的贡献为 cn^2, 所以根结点的代价占总代价的一个常数 比例。换句话说，根结点的代价支配了整棵树的总代价。</p>
<h1 id="选择和查找">选择和查找</h1>
<h2 id="二分搜索">二分搜索</h2>
<p>普通的二分查找：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_lcro</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找（左闭右开）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 循环，当搜索区间为空时跳出（当 i = j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            i = m + <span class="number">1</span>  <span class="comment"># 此情况说明 target 在区间 [m+1, j) 中</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">            j = m  <span class="comment"># 此情况说明 target 在区间 [i, m) 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> m  <span class="comment"># 找到目标元素，返回其索引</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标元素，返回 -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样的二分查找只适用于不重复元素，如果有重复元素，需要寻找到左边界作为插入点，则需要进一步处理 即：当找到等于目标的索引值后，进一步在左侧区间运行二分查找，直到找到最左侧的值 循环完成后， i指向最左边的 <code>target</code> ， j指向首个小于 <code>target</code> 的元素，<strong>因此索引</strong> <code>i</code><strong>就是插入点</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_insertion</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找插入点（存在重复元素）&quot;&quot;&quot;</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            i = m + <span class="number">1</span>  <span class="comment"># target 在区间 [m+1, j] 中</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">            j = m - <span class="number">1</span>  <span class="comment"># target 在区间 [i, m-1] 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = m - <span class="number">1</span>  <span class="comment"># 首个小于 target 的元素在区间 [i, m-1] 中</span></span><br><span class="line">    <span class="comment"># 返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查找左边界</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_left_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找最左一个 target&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 等价于查找 target 的插入点</span></span><br><span class="line">    i = binary_search_insertion(nums, target)</span><br><span class="line">    <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[i] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到 target ，返回索引 i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p>我们可以利用查找最左元素的函数来查找最右元素，具体方法为：<strong>将查找最右一个 <code>target</code> 转化为查找最左一个 <code>target + 1</code></strong>。搜索结束后<code>j</code>指向最右一个 <code>target</code> ，<strong>因此返回</strong><code>j</code> <strong>即可</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_right_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找最右一个 target&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 转化为查找最左一个 target + 1</span></span><br><span class="line">    i = binary_search_insertion(nums, target + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># j 指向最右一个 target ，i 指向首个大于 target 的元素</span></span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> nums[j] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到 target ，返回索引 j</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当数组不包含 <code>target</code> 时，最终 <code>i</code>和<code>j</code></p>
<p>会分别指向首个大于、小于 <code>target</code> 的元素。</p>
<p>因此，可以构造一个数组中不存在的元素，用于查找左右边界。</p>
<ul>
<li>查找最左一个 <code>target</code> ：可以转化为查找 <code>target - 0.5</code> ，并返回指针<code>i</code></li>
<li>查找最右一个 <code>target</code> ：可以转化为查找 <code>target + 0.5</code> ，并返回指针<code>j</code></li>
</ul>
<h2 id="哈希查找">哈希查找</h2>
<p>Q:给定一个整数数组 <code>nums</code> 和一个目标元素 <code>target</code> ，请在数组中搜索“和”为 <code>target</code> 的两个元素，并返回它们的数组索引。返回任意一个解即可。</p>
<p>借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组</p>
<ol type="1">
<li>判断数字 <code>target - nums[i]</code> 是否在哈希表中，若是则直接返回这两个元素的索引。</li>
<li>将键值对 <code>nums[i]</code> 和索引 <code>i</code> 添加进哈希表。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_brute_force.png" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_sum_hash_table</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;方法二：辅助哈希表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 辅助哈希表，空间复杂度 O(n)</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="comment"># 单层循环，时间复杂度 O(n)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> [dic[target - nums[i]], i]</span><br><span class="line">        dic[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n),由于需要维护一个额外的哈希表，因此空间复杂度为O(n)</p>
<h2 id="随机查找">随机查找</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT (A, p, r, i)</span><br><span class="line">    if p==r</span><br><span class="line">        return A[p]</span><br><span class="line">    q = RANDOMlZED-PARTITION(A, p, r)</span><br><span class="line">    k = q-p+I</span><br><span class="line">    if i == k // the pivot value is the answer</span><br><span class="line">        return A[q]</span><br><span class="line">    else if i&lt;k</span><br><span class="line">        return RANOOMIZED-SELECT(A, p, q-1, i)</span><br><span class="line">    else return RANOOMIZED-SELECT(A, q+l, r, i-k</span><br></pre></td></tr></table></figure>
<h1 id="比较排序">比较排序</h1>
<p><img src="/assets/mit6.006总和笔记/image-20231016192215938.png" /></p>
<h2 id="决策树">决策树</h2>
<p>决策树</p>
<ul>
<li>任何算法都可以被视为所执行操作的决策树</li>
<li>内部节点表示二进制比较，分支为 True 或 False</li>
<li>对于比较算法，决策树是二元的</li>
<li>叶子代表算法终止，产生算法输出</li>
<li>根到叶路径表示算法在某些输入上的执行</li>
<li>比较排序的决策树是完全二叉树，因此高度h&gt;=lg(叶节点数)</li>
<li>叶结点数是排列数量，即n!</li>
<li>决策树高度，或者说每条路径的长度就是时间复杂度 <span class="math display">\[n! = \sqrt{2\pi n}\Bigl(\frac{n}{\mathrm{e}}\Bigr)^{n}\Bigl(1 + \frac{1}{12n} + \frac{1}{288n^2} + \cdots\Bigr),\]</span> <span class="math display">\[\ln n! = n\ln n - n +\frac{1}{2}\ln(2\pi n) + \frac{1}{12n} - \frac{1}{360n^3} + \cdots.\]</span> 因此排序下界是nlgn</li>
</ul>
<p>对应的，搜索算法的叶节点数为n个，因此下界是lgn</p>
<h2 id="堆排序">堆排序</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231017150534371.png" /> <strong>本质上是在序列数据结构（数组）之上实现集合数据结构</strong></p>
<p>二叉堆：将数组解释为完全二叉树，深度 i 处最多有 2i 个节点，除了 在最大深度，所有节点均左对齐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left(i) = 2i + 1</span><br><span class="line">right(i) = 2i + 2</span><br><span class="line">parent(i) = mod(i-1/2)</span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231014112423645.png" /></p>
<h3 id="最大堆的生成">最大堆的生成</h3>
<p>本质上是自底向上建堆，从下到上维护最大堆属性，即从倒数第二层由大索引值向顶部进行最大堆性质的维护</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Max_Heapify(A,i)</span><br><span class="line">    l = left(i)</span><br><span class="line">    r = right(i)</span><br><span class="line">    if (l &lt;= heap-size(A) and A[l] &gt; A[i])</span><br><span class="line">        then largest = l </span><br><span class="line">    else largest = i</span><br><span class="line">    if (r &lt;= heap-size(A) and A[r] &gt; A[largest])</span><br><span class="line">        then largest = r</span><br><span class="line">    if largest != i</span><br><span class="line">        then exchange A[i] and A[largest]</span><br><span class="line">    Max_Heapify(A, largest)</span><br><span class="line"></span><br><span class="line">//Converts A[1…n] to a max heap</span><br><span class="line">Build_Max_Heap(A):</span><br><span class="line">    for i=n/2 downto 1</span><br><span class="line">        do Max_Heapify(A, i)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Why start at n/2?</span><br><span class="line">Because elements A[n/2 + 1 … n] are all leaves of the tree</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度分析">时间复杂度分析</h3>
<p>每层的时间代价等于节点数乘以节点高度 <img src="https://www.hello-algo.com/chapter_heap/build_heap.assets/heapify_operations_count.png" /> <span class="math display">\[\begin{aligned}
T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \dots + 2^{(h-1)}\times1 \newline
2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \dots + 2^{h-1} + 2^h \newline
\end{aligned}\]</span> <span class="math display">\[\begin{aligned}
T(h) &amp; = 2 \frac{1 - 2^h}{1 - 2} - h \newline
&amp; = 2^{h+1} - h - 2 \newline
&amp; = O(2^h)
\end{aligned}\]</span> 综上得到 <span class="math display">\[O(2^h) = O(n)\]</span></p>
<h3 id="排序策略">排序策略</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sorting Strategy:</span><br><span class="line">1. 从未排序数组中构建一个堆</span><br><span class="line">2. 找到最大元素 A[1]并与A[n]交换;</span><br><span class="line">3. n索引处元素出堆，从顶部节点开始维护最大堆属性</span><br><span class="line">4. 顶部节点开始和比它大的最大子节点交换，直到叶节点</span><br></pre></td></tr></table></figure>
<h3 id="top-k问题">top-k问题</h3>
<p>基于堆更加高效地解决 Top-K 问题</p>
<ol type="1">
<li><p>初始化一个最小堆</p></li>
<li><p>前k个元素入堆</p></li>
<li><p>对之后的元素，如果有比堆顶大的元素，则堆顶出堆，该元素入堆</p></li>
<li><p>最后得到top-k元素组成的堆</p></li>
</ol>
<p>时间复杂度是nlgk，不超过nlgn</p>
<h2 id="动态规划和二分搜索树">动态规划和二分搜索树</h2>
<p>实例——机场的动态规划：</p>
<ol type="1">
<li>机场维护一个跑道队列</li>
<li>未来的着陆预定登记到队列</li>
<li>一架飞机着陆后就出队</li>
<li>有新的请求且需要着陆时间t时，如果k时间内没有其他需求，则需求t时间的请求入队(k可以实时改变)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init: R = [ ]</span><br><span class="line">req(t): if t &lt; now: return &quot;error&quot;</span><br><span class="line">for i in range (len(R)):</span><br><span class="line">    if abs(t-R[i]) &lt; k: return &quot;error&quot;</span><br><span class="line">R.append(t)</span><br><span class="line">R = sorted(R)</span><br><span class="line">land: t = R[0]</span><br><span class="line">if (t != now) return error</span><br><span class="line">R = R[1: ] (drop R[0] from R)</span><br></pre></td></tr></table></figure>
<p>Goal: Run this system efficiently in O(lg n) time 常见数据结构运行时间分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">排序链表</span><br><span class="line">- 添加元素并排序需要Θ(nlgn)时间。但是,可以找到插入新时间/航班的位置而不需要添加并排序,但是插入需Θ(n)时间。一旦找到插入位置,k分钟检查可以在O(1)时间内完成。</span><br><span class="line"></span><br><span class="line">排序数组</span><br><span class="line">- 可以使用二分搜索在O(lg n)时间内找到插入位置。使用二分搜索,找到插入索引i,即大于或等于t的最小元素。然后将R[i]和R[i-1]与t进行比较。然而,实际插入需要移位元素,需Θ(n)时间。</span><br><span class="line"></span><br><span class="line">未排序链表/数组</span><br><span class="line">- k分钟检查需要O(n)时间。</span><br><span class="line"></span><br><span class="line">最小堆</span><br><span class="line">- 可以在O(lg n)时间内插入。但是,k分钟检查仍需O(n)时间。</span><br><span class="line"></span><br><span class="line">字典或Python集合</span><br><span class="line">- 插入需要O(1)时间。k分钟检查需要Ω(n)时间</span><br></pre></td></tr></table></figure>
<p>BST的定义： 每个节点都有一个key,左节点的key小于等于父节点，右节点的key大于等于父节点</p>
<p>所有操作都是O(h)即O(lgn)</p>
<p>动态规划中需要找到比一个值大的值中的最小值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">next-larger(x) # x is a node in the BST</span><br><span class="line">if right child not NIL, return minimum(right)</span><br><span class="line">else y = parent(x)</span><br><span class="line">while y not NIL and x = right(y)</span><br><span class="line">    x = y; y = parent(y)</span><br><span class="line">return(y);</span><br></pre></td></tr></table></figure>
<p><code>子问题</code>：如何计算小于等于时间t内着陆的飞机数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 遍历树找到目标时间</span><br><span class="line">2. 从左子树开始遍历，把左侧节点的数量加一则是当前节点的排名，排名则是问题的答案</span><br></pre></td></tr></table></figure>
<p><strong>搜索二叉树可以使用set或者sequence两种数据结构</strong></p>
<p>set:遍历顺序由key的顺序决定</p>
<p>sequence:数组索引就是遍历顺序</p>
<p><img src="/assets/mit6.006总和笔记/image-20231017101953076.png" /> <strong>查找第i大的节点(sequence)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 查找当前节点的排序rank</span><br><span class="line">2. 如果rank &lt; i在右子树寻找排名i-rank的节点</span><br><span class="line">3. 如果rank &gt; i在左子树递归寻找</span><br><span class="line">4. 如果等于，则找到了目标</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以对每个节点维护一个size属性，用左子树的size确认排名</li>
<li>搜索二叉树插入节点很容易实现，但删除节点，如果是有子树的节点，就需要把左子树的最大值或者右子树的最小值与其交换后删除</li>
<li>二叉树的中序遍历正好就是一个排序数组</li>
</ul>
<h2 id="平衡二叉搜索树avl">平衡二叉搜索树AVL</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231017102411122.png" /> • 在动态操作下保持 O(log n) 高度的二叉树称为平衡二叉树 – 有许多平衡方案（红黑树、八字树、2-3 树……） – 第一个提出的平衡方案是 AVL 树 <strong>树的旋转</strong> <img src="/assets/mit6.006总和笔记/image-20231017102819736.png" /> • 定理：O(n) 次旋转可以将二叉树转换为具有相同遍历顺序的任何其他二叉树。 • 证明：按照遍历顺序重复执行最后可能的右旋转； 结果树是 规范链。 每次旋转都会使最后一个节点的深度增加 1。 最后一个节点的深度最多为 n − 1，因此最多执行 n − 1 次旋转，就可以将输入树旋转为目标树。</p>
<p><strong>平衡</strong> AVL 树保持高度平衡（也称为 AVL 属性）</p>
<ul>
<li>如果一个节点的左右子树的高度最多相差 1，则该节点是高度平衡的</li>
<li>节点的倾斜为其右子树的高度减去左子树的高度</li>
<li>如果节点的倾斜度为 −1、0 或 1，则该节点是高度平衡的</li>
</ul>
<p><strong>平衡的维持</strong> 每次对树的修改最多导致左右子树高度相差2，如果相差2，一次旋转就可以重新平衡树 <img src="/assets/mit6.006总和笔记/image-20231017105216748.png" /> <img src="/assets/mit6.006总和笔记/image-20231018222936126.png" /> <img src="/assets/mit6.006总和笔记/image-20231018223015529.png" /> <img src="/assets/mit6.006总和笔记/image-20231018223211763.png" /></p>
<p>AVL 树通过在每个节点存储额外的高度信息,并在每个节点做平衡操作来保持平衡。其平衡调整原则如下:</p>
<ol type="1">
<li>如果左右子树高度相差大于 1,进行旋转操作调整;</li>
<li>进行左旋转的情况:左子树高度 - 右子树高度 &gt; 1,即左子树比右子树高(左重),需要右旋;</li>
<li>进行右旋转的情况:右子树高度 - 左子树高度 &gt; 1,即右子树比左子树高(右重),需要左旋;</li>
<li>旋转后更新节点的高度信息。</li>
<li>每进行一次插入或删除节点后,从该节点开始向上遍历,如果发现任一节点的左右子树高度差大于 1,则在该节点进行旋转操作,调整树的平衡。 由于树的高度最高为lgn，所以logn时间内就可以完成增删节点的操作 <strong>高度属性的维护</strong> 必须确保每个节点的height属性可以通过对height属性的一个O(1)操作完成，这样维护height就不会改变动态操作的复杂度</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">balanceFactor</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>旋转的实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rightRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;left;</span><br><span class="line">    TreeNode *grandChild = child-&gt;right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;right;</span><br><span class="line">    TreeNode *grandChild = child-&gt;left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一共有四种需要平衡的情况 <img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png" /></p>
<table>
<thead>
<tr class="header">
<th>失衡节点的平衡因子</th>
<th>子节点的平衡因子</th>
<th>应采用的旋转方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;1（即左偏树）</td>
<td>&gt;=0</td>
<td>右旋</td>
</tr>
<tr class="even">
<td>&gt;1（即左偏树）</td>
<td>&lt;0</td>
<td>先左旋后右旋</td>
</tr>
<tr class="odd">
<td>&lt;-1（即右偏树）</td>
<td>&lt;=0</td>
<td>左旋</td>
</tr>
<tr class="even">
<td>&lt;-1（即右偏树）</td>
<td>&gt;0</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<p><strong>数据结构的选取</strong> • Set AVL trees achieve O(lg n) time for all set operations, except O(n log n) time for build and O(n) time for iter • Sequence AVL trees achieve O(lg n) time for all sequence operations, except O(n) time for build and iter <strong>插入和删除</strong> 此外，插入节点和删除节点在搜索二叉树基础上，需要分别自底向上和自上向下进行恢复平衡的操作</p>
<h1 id="哈希">哈希</h1>
<p>哈希有可能产生碰撞，需要特定处理或者数据结构，检索元素时间最后会由负载因数(n/m)决定 <img src="/assets/mit6.006总和笔记/image-20231016200400451.png" /> 一般有<strong>链表</strong>和<strong>开放寻址</strong>两种方式解决碰撞</p>
<ul>
<li>链表 期望的查找时间，θ(1+α)，1是哈希函数用时，阿尔法则是查找具体链表需要的时间（链表的期望长度）</li>
<li>开放寻址</li>
</ul>
<h2 id="哈希函数">哈希函数</h2>
<p>常见的哈希函数</p>
<ol type="1">
<li><code>h(k) = k mod m（m是素数，慢)</code></li>
<li><code>h(k) = [(a · k) mod 2w] &gt;&gt; (w − r)</code>(where a is random, k is w bits, and m = 2r.且需要a处于2<sup>(w-1)和2</sup>w之间，且不靠近端点)</li>
<li><code>h(k) = [(ak + b) mod p]</code> mod m where a and b are random ∈ {0, 1, . . . p − 1}, and p is a large prime (&gt; |U|).(了解即可,6.046内容)</li>
</ol>
<h2 id="哈希的优化">哈希的优化</h2>
<p><strong>rehash</strong></p>
<p>Θ(n + m) time = Θ(n) if m = Θ(n)</p>
<p><strong>shrink</strong></p>
<p>当n到达m/4时，收缩到n/2</p>
<h2 id="利用哈希的字符串匹配算法">利用哈希的字符串匹配算法</h2>
<h3 id="karp-rabin-algorithm">Karp-Rabin Algorithm</h3>
<p>Rabin-Karp算法是一种字符串匹配算法,利用滚动哈希技术实现。其基本思想是:</p>
<ol type="1">
<li>对文本和模式分别计算哈希值;</li>
<li>滚动文本,每次比较文本窗口和模式的哈希值;</li>
<li>如果哈希值相同,则进行字符匹配确认;</li>
<li>如果不相同,则可以直接跳到下一位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• Compare h(s) == h(t[i : i + len(s)])</span><br><span class="line">• If hash values match, likely so do strings</span><br><span class="line">– can check s == t[i : i + len(s)] to be sure ∼ cost O(|s|)</span><br><span class="line">– if yes, found match — done</span><br><span class="line">– if no, happened with probability &lt; 1/|s|</span><br><span class="line">= expected cost is O(1) per i.</span><br><span class="line">⇒</span><br><span class="line">• need suitable hash function.</span><br><span class="line">• expected time = O(|s| + |t| · cost(h)).</span><br><span class="line">– naively h(x) costs |x|</span><br><span class="line">– we’ll achieve O(1)!</span><br><span class="line">– idea: t[i : i + len(s)] ≈ t[i + 1 : i + 1 + len(s)]</span><br></pre></td></tr></table></figure>
<p><strong>rolling hash</strong> Rolling Hash ADT Maintain string x subject to • r(): reasonable hash function h(x) on string x • r.append(c): add letter c to end of string x • r.skip(c): remove front letter from string x, assuming it is 伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for c in s: rs.append(c)</span><br><span class="line">for c in t[:len(s)]: rt.append(c)</span><br><span class="line">if rs() == rt(): ...</span><br><span class="line">//This first block of code is O( s )</span><br><span class="line">for i in range(len(s), len(t)):</span><br><span class="line">rt.skip(t[i-len(s)])</span><br><span class="line">rt.append(t[i])</span><br><span class="line">if rs() == rt(): ...</span><br><span class="line">//The second block of code is O(|t|) + O(# matches − |s|) to verify.</span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231019194313076.png" /></p>
<h2 id="开放寻址">开放寻址</h2>
<p>哈希时需要引入哈希次数i，持续哈希直到找到空槽 <strong>插入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in xrange(m):</span><br><span class="line">    if T [h(k, i)] is None: #empty slot</span><br><span class="line">        T [h(k, i)] = (k, v) #store item</span><br><span class="line">        return</span><br><span class="line">raise ‘full&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>查找</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in xrange(m):</span><br><span class="line">    if T [h(k, i)] is None: #empty slot?</span><br><span class="line">        return None #end of “chain”</span><br><span class="line">    elif T [h(k, i)][∅] == k: #matching key</span><br><span class="line">    return T [h(k, i)] #return item</span><br><span class="line">    return None ˙ #exhausted table</span><br></pre></td></tr></table></figure>
<p><strong>删除</strong></p>
<p>由于防止查找操作误判，需要特定的删除标志，把待删除函数设置为已删除，让插入视为None,查找视为存在 <img src="/assets/mit6.006总和笔记/image-20231019195835085.png" /></p>
<h3 id="优化">优化</h3>
<p>问题：可能出现<em>簇</em>现象，某些元素连续聚集于一处，导致查找操作耗时较高</p>
<p>eg.线性哈希h(k, i) = (h′(k) +i)</p>
<p>更好的解决方案：<code>h(k, i) =(h1(k) +i·h2(k)) mod m</code> where h1(k) and h2(k) are two ordinary hash func-tions.</p>
<h3 id="性能">性能</h3>
<p>第一次查找成功的概率p=m-n/m</p>
<p>第二次概率为m-n/m-1大于p</p>
<p>由此类推，成功概率至少为p</p>
<p>1/p=1/1-α</p>
<p>所以期望时间为O(1/(1 − α))</p>
<h3 id="与链表的比较">与链表的比较</h3>
<p>优点：更有效地利用空间，不需要储存指针</p>
<p>缺点：链表对哈希函数和负载值的要求更低，开放寻址高负载时性能大降，且无法有大于一的α</p>
<h2 id="安全领域的哈希">安全领域的哈希</h2>
<p>哈希在加密上应用广泛，例如：</p>
<ol type="1">
<li>加密密码，存储密码的哈希码来防止泄露的危害</li>
<li>文件完整性校验，利用哈希来给出文件几乎唯一的哈希值来防止对文件的暗中篡改，也用于git之类的版本控制软件</li>
<li>数字签名，用私钥加密数据，其他人可以用公钥检验，来确保发信者身份正规 <a href="https://thinklive1.github.io/2023/10/12/sysadmin/">详细可见Sysadmin decal笔记</a></li>
</ol>
<h1 id="线性时间排序">线性时间排序</h1>
<h2 id="计数排序">计数排序</h2>
<p>构建1-(k-1)的列表，随后遍历待排序数组，对每个数字，将其作为索引，列表该索引处值+1，O(n+k) <img src="/assets/mit6.006总和笔记/image-20231019110047558.png" /></p>
<h2 id="基数排序">基数排序</h2>
<p>开辟log base(决定进制)|k个桶， O((n+b)log b|k) b(base)=O(n)时时间复杂度最低 *k&lt;=cn时，为O(nc)，即范围较小时，为线性复杂度 <img src="/assets/mit6.006总和笔记/image-20231019110111354.png" /></p>
<h1 id="数值运算">数值运算</h1>
<h2 id="catalan-numbers">Catalan numbers</h2>
<p>Set P of balanced parentheses strings(平衡括号字符串) are recursively defined as • λ ∈ P (λ is empty string) • If α, β ∈ P , then (α)β ∈ P Cn: number of balanced parentheses strings with exactly n pairs of parentheses 也等于n+1个叶节点构成满二叉树的形状个数 <img src="/assets/mit6.006总和笔记/image-20231020131123959.png" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印前 n 个卡特兰数</span></span><br><span class="line">ans, n = <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br></pre></td></tr></table></figure>
<h2 id="newtons-method牛顿迭代法">Newton’s Method牛顿迭代法</h2>
<p><span class="math display">\[
x_{i+1} = x_{i} - \frac{f(x_{i})}{f&#39;(x_{i})}
\]</span></p>
<h3 id="高精度乘法">高精度乘法</h3>
<p>Multiplying two n-digit numbers (radix r = 2, 10) 0 ≤ x, y &lt; rn x1 = high half;x0 = low half <span class="math display">\[
x = x_{1} \cdot r^{\frac{n}{2}} + x_{0}
\]</span> <span class="math display">\[
y = y_{1} \cdot r^{\frac{n}{2}} + y_{0}
\]</span> <span class="math display">\[
z = x · y = x_1y_1 · r^n + (x_0 · y_1 + x_1 · y_0)r^{n/2} + x_0 · y_0
\]</span></p>
<p>θ(n^2) time</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Schönhage-Strassen算法是一种快速整数乘法算法,由Arnold Schönhage和Volker Strassen在1971年提出。它比传统的乘法算法要快得多,其时间复杂度为O(n log n log log n)。</span><br><span class="line">Schönhage-Strassen算法的基本思想是:</span><br><span class="line">1. 将两个n位数a和b拆分成大约n/2位数的块。例如,1234 = 12, 34;   2345 = 23, 45。</span><br><span class="line">2. 计算所有块之间的乘积,得到4个结果:a1b1, a1b2, a2b1, a2b2。这可以用递归方式计算。</span><br><span class="line">3. 根据分块的位数 Shift 加上进位,得到a1b1*(10^n), a1b2*10^n/2, a2b1*10^n/2, a2b2。</span><br><span class="line">4. 最后将4个结果相加,得到a*b。</span><br><span class="line">5. 例如,计算12345 * 6789:</span><br><span class="line">6. 分块:12, 34,   67, 892. 计算块间乘积:12 * 67 = 804,   12 * 89 = 1068, 34 * 67 = 2298, 34 * 89 = 3026 </span><br><span class="line">7. Shift并加进位:804 * 10000, 1068 * 5000, 2298 * 5000, 30264. </span><br><span class="line">8. 相加:8040000 + 5340000 + 11490000 + 15130000 = 123456791这种算法通过分块和递归减少每一步的计算量,在计算两个大整数的乘积时有很高的效率,尤其适用于超长整数的相乘。它在一定程度上简化了超长整数运算,是数论和计算机科学中很有价值的一种算法。</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong> <img src="/assets/mit6.006总和笔记/image-20231020135416200.png" /> <strong>误差分析</strong> <img src="/assets/mit6.006总和笔记/image-20231020140715299.png" /> <span class="math display">\[
ε_{n+1} =  \frac{ε_n^2}{2*(1+ε_n)}
\]</span></p>
<h3 id="高精度除法">高精度除法</h3>
<p>a/b -&gt; 1/b*a - &gt; mod(R/b) // R是一个容易除的较大值</p>
<p><img src="/assets/mit6.006总和笔记/image-20231020141331913.png" /> <img src="/assets/mit6.006总和笔记/image-20231020141401286.png" /> 除法的复杂度等于乘法 To understand this, assume that the complexity of multiplication is Θ(nα) for n- digit numbers, with α ≥ 1. Division requires multiplication of different-sized numbers at each iteration. Initially the numbers are small, and then they grow to d digits.</p>
<p>We apply a first level of Newton’s method to solve f (x) = x2 − a. Each iteration of this first level1 requires a division. If we set the precision to d digits right from the beginning, then convergence at the first level will require lg d iterations. This means the complexity of computing a square root will be Θ(dα lg d) if the complexity of multiplication is Θ(dα), given that we have shown that the complexity of division is the same as the complexity of multiplication. However, we can do better, if we recognize that the number of digits of precision we need at beginning of the first level of Newton’s method starts out small and then grows. If the complexity of a d-digit division is Θ(dα), then a similar summation to the one above tells us that the complexity of computing square roots is Θ(dα)</p>
<h1 id="图论">图论</h1>
<h2 id="概念">概念</h2>
<p>图：for each vertex u ∈ V, Adj[u] stores u’s neighbors, i.e., {v ∈ V | (u, v) ∈ E}. Adj 的大小为 θ(|V |)，而每个 Adj(u) 的大小为 θ(deg(u))</p>
<p>表示分为邻接表和邻接矩阵 <img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png" /> <img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png" /> <img src="/assets/mit6.006总和笔记/QQ图片20231121160100.png" /></p>
<h3 id="路径">路径</h3>
<ul>
<li>路径是顶点序列p=(v1,v2,...,vk),其中(vi,vi+1)∈E, 1≤i&lt;k<br />
</li>
<li>如果路径上没有重复顶点,则为简单路径<br />
</li>
<li>路径p的长度为路径上的边数<br />
</li>
<li>u到v的距离δ(u,v)为从u到v的最短路径长度</li>
</ul>
<p><strong>路径问题</strong>:</p>
<ul>
<li>图中的多种路径问题:<br />
  - 单源可达性:s是否可达t<br />
  - 单源最短路径:返回δ(s,t)和s到t的最短路径<br />
  - 单源最短路径:返回从s到所有v的δ(s,v)和最短路径树<br />
</li>
<li>如何对每个顶点返回从源s的最短路径?<br />
</li>
<li>返回所有路径需Ω(|V|^2)时间<br />
</li>
<li>只存储每个v的父节点P(v),s的父节点为空<br />
</li>
<li>父节点构成包含从s可达所有最短路径的最短路径树,大小为O(|V|)</li>
</ul>
<h2 id="bst">BST</h2>
<p><strong>应用</strong></p>
<ul>
<li>网络抓取（Google 如何查找页面）</li>
<li>社交网络（Facebook 好友查找器）</li>
<li>网络广播路由</li>
<li>垃圾收集</li>
<li>模型检查（有限状态机）</li>
<li>检查数学猜想</li>
<li>解决谜题和游戏</li>
</ul>
<p>如何计算图中所有顶点v的δ(s,v)和P(v)?</p>
<ul>
<li>使用集合数据结构来存储每个顶点v对应的δ(s,v)距离和P(v)父节点。<br />
</li>
<li>如果从起点s到v没有路径,则不存储在P中,δ(s,v)设为无穷大。</li>
</ul>
<p><strong>基本思路</strong>: - 按照与起点s的距离依次增大的顺序探索图的节点。</p>
<p><strong>目标</strong>:<br />
- 计算所有与起点s距离为i的顶点的集合Li。结论:<br />
- Li中的任意顶点v必须与L_{i-1}中的某个顶点u相连。<br />
- 不会有任何距离起点距离为j(j&lt;i)的顶点出现在Li中。</p>
<p><strong>循环不变量:</strong><br />
- 在计算到Li之前,δ(s,v)和P(v)对于所有Lj(j&lt;i)中的顶点v都已正确赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BFS (V,Adj,s): See CLRS for queue-based implementation</span><br><span class="line">    level = &#123; s: 0 &#125;</span><br><span class="line">    parent = &#123;s : None &#125;</span><br><span class="line">    i = 1</span><br><span class="line">    frontier = [s] # previous level, i − 1</span><br><span class="line">    while frontier:</span><br><span class="line">        next = [ ] # next level, i</span><br><span class="line">        for u in frontier:</span><br><span class="line">            for v in Adj [u]:</span><br><span class="line">                if v not in level: # not yet seen</span><br><span class="line">                    level[v] = i # = level[u] + 1</span><br><span class="line">                    parent[v] = u</span><br><span class="line">                    next.append(v)</span><br><span class="line">        frontier = next</span><br><span class="line">        i + =1</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">graph_bfs</span>(<span class="params">graph: GraphAdjList, start_vet: Vertex</span>) -&gt; <span class="built_in">list</span>[Vertex]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;广度优先遍历 BFS&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">    <span class="comment"># 顶点遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    visited = <span class="built_in">set</span>[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 队列用于实现 BFS</span></span><br><span class="line">    que = deque[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(que) &gt; <span class="number">0</span>:</span><br><span class="line">        vet = que.popleft()  <span class="comment"># 队首顶点出队</span></span><br><span class="line">        res.append(vet)  <span class="comment"># 记录访问顶点</span></span><br><span class="line">        <span class="comment"># 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> adj_vet <span class="keyword">in</span> graph.adj_list[vet]:</span><br><span class="line">            <span class="keyword">if</span> adj_vet <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 跳过已被访问过的顶点</span></span><br><span class="line">            que.append(adj_vet)  <span class="comment"># 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adj_vet)  <span class="comment"># 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment"># 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本情况(i=1):</p>
<ul>
<li>L0={s},δ(s,s)=0,P(s)=None归纳步骤: (L表示level)</li>
<li>计算Li时:<br />
  - 对Li-1中的每个顶点u:<br />
    - 对于任一不在Lj(j&lt;i)中的相邻顶点v:<br />
      - 将v加入Li,设置δ(s,v)=i,P(v)=u重复计算:</li>
<li>按i递增顺序重复计算Li,直到Li为空集<br />
</li>
<li>对任一不可达顶点v,设置δ(s,v)=∞</li>
<li>因此通过归纳证明,广度优先搜索可以正确计算所有δ(s,v)和P(v)。</li>
</ul>
<p><strong>时间复杂度分析</strong>:</p>
<ul>
<li>用支持快速遍历和插入的数据结构存储Li<br />
</li>
<li>通过检查P来判断一个顶点是否在Lj(j&lt;i)中<br />
</li>
<li>用支持O(1)操作的字典结构存储δ和P<br />
</li>
<li>每个顶点u最多加入一个Li,并对每个邻点v做O(1)操作<br />
</li>
<li>以上这些部分是O(|E|)</li>
<li>最后处理不可达顶点需O(|V|)<br />
</li>
<li>所以总时间复杂度是O(|V|+|E|)</li>
</ul>
<p><span class="math display">\[
level[v] = \begin{cases}
           level &amp; \text{if } v \text{ assigned level} \\\\
           \infty &amp; \text{else (no path)}
\end{cases}
\]</span></p>
<h2 id="dst">DST</h2>
<p>基本思想:</p>
<ul>
<li>递归访问出边邻接顶点,但不重复访问已访问过的顶点。<br />
</li>
<li>尽可能深入探索路径,直到无法继续,然后回溯找到未探索的路径。 执行步骤:</li>
<li>初始化P(s)=None,执行visit(s)过程:<br />
  - 对每个未在P中出现的邻接顶点v:设P(v)=u并递归调用visit(v)<br />
  - 标记访问完顶点u(用于拓扑排序) 不用返回distance,因此时间是O(E)</li>
</ul>
<p>全BFS和全DFS:</p>
<ul>
<li>目标是探索整个图,而不仅仅是一个源点可达的部分。<br />
</li>
<li>重复在任一未访问顶点s上运行BFS或DFS,直到所有顶点都被访问。<br />
</li>
<li>时间复杂度都是O(|V| + |E|)</li>
</ul>
<p>连通分量:</p>
<ul>
<li>将无向图的顶点集分割成子集Vi,使每个Vi内部连通,Vi之间无边。连通性算法:<br />
</li>
<li>任意单源可达性算法A都可以求解连通分量。<br />
</li>
<li>重复运行全A,每次A访问的顶点集就是一个连通分量。</li>
</ul>
<p>连通性算法:</p>
<ul>
<li>任意单源可达性算法A都可以求解连通分量。<br />
</li>
<li>重复运行全A,每次A访问的顶点集就是一个连通分量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parent = &#123;s: None&#125;</span><br><span class="line">DFS-visit (V, Adj, s):</span><br><span class="line">    for v in Adj [s]:</span><br><span class="line">        if v not in parent:</span><br><span class="line">            parent [v] = s</span><br><span class="line">            DFS-visit (V, Adj, v)</span><br><span class="line">DFS (V, Adj):</span><br><span class="line">    parent = &#123; &#125;</span><br><span class="line">    for s in V:</span><br><span class="line">        if s not in parent:</span><br><span class="line">            parent [s] = None</span><br><span class="line">            DFS-visit (V, Adj, s)</span><br></pre></td></tr></table></figure>
<p>O(V + E)</p>
<p><strong>总结</strong>：</p>
<ul>
<li>Single-Source Shortest Paths with BFS in O(|V | + |E|) time (return distance per vertex)</li>
<li>Single-Source Reachability with BFS or DFS in O(|E|) time (return only reachable vertices)</li>
<li>Connected components with Full-BFS or Full-DFS in O(|V | + |E|) time</li>
<li>Topological Sort of a DAG with Full-DFS in O(|V | + |E|) time</li>
</ul>
<h3 id="拓扑排序算法">拓扑排序算法</h3>
<ul>
<li>DFS访问每个顶点v时,记录DFS结束顺序finish[v]<br />
</li>
<li>按finish[v]递减顺序输出顶点具体步骤:</li>
</ul>
<ol type="1">
<li>通过DFS遍历图<br />
</li>
<li>将顶点按finish[v]时间降序插入order<br />
</li>
<li>将order反转 <strong>正确性证明</strong>:<br />
对任意边(u,v)有u在v之前</li>
</ol>
<ul>
<li>如果u先访问:<br />
  - 在访问u结束前会访问v(直接或间接)<br />
  - 因此v结束时间在u之前<br />
</li>
<li>如果v先访问:<br />
  - 图无环<br />
  - 无法从v访问u<br />
  - 因此v结束时间在u之前因此DFS结束时间递减顺序即为拓扑排序顺序。</li>
</ul>
<h3 id="循环检测算法">循环检测算法</h3>
<p><strong>利用全DFS检测环</strong>:</p>
<ul>
<li>如果无向图无环,全DFS的反序order就是拓扑排序。<br />
</li>
<li>对每条边 (u, v)，反序中如果v不在u前，就有环<br />
</li>
<li>可以在O(|E|)时间内检测反序是否有环（哈希或者数组的数据结构）</li>
</ul>
<p><strong>定位环的算法</strong>:</p>
<ul>
<li>在全DFS过程中维护当前顶点的祖先集合</li>
<li>如果DFS遍历到一条从v到其祖先的边,则存在环。</li>
</ul>
<p><strong>正确性证明</strong>:</p>
<ul>
<li>设图包含环(v0,v1,...,vk,v0),假设v0首先被DFS访问。<br />
</li>
<li>对每个vi,在访问vi结束前会访问vi+1并结束。<br />
</li>
<li>最后在访问vk结束前会访问v0,此时v0是vk的祖先。</li>
</ul>
<h2 id="最短路径">最短路径</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231024194703867.png" /></p>
<ul>
<li>路径π的权重w(π)是路径上所有边权重之和<br />
</li>
<li>s到t的最短路径是从s到t权重最小的路径</li>
<li>δ(s,t)表示从s到t的最短路径权重</li>
<li>对一般权图,还不知道O(|V|+|E|)的最短路径算法<br />
</li>
<li>但对DAG可以在O(|V|+|E|)时间内求解</li>
</ul>
<h3 id="简单最短路径">简单最短路径</h3>
<p>简单的最短路径 • 如果图表包含循环和负权重，则可能包含负权重循环 • 如果图形不包含负权环，则最短路径很简单！ • 主张 1：如果 δ(s, v) 是有限的，则存在一条到 v 的最短路径，该路径很简单 • 证明： 通过反证法： – 假设没有简单的最短路径； 设 π 为顶点最少的最短路径 – π 不简单，所以 π 中存在环 C； C 具有非负权重（或者 δ(s, v) = −∞） – 从 π 中删除 C 形成路径 π0，具有更少的顶点和权重 w(π0) ≤ w(π) • 由于简单路径不能重复顶点，因此有限最短路径最多包含 |V | − 1 条边</p>
<h3 id="有权图基础">有权图基础</h3>
<h4 id="最小生成树">最小生成树</h4>
<p>If know δ(s, v) for all vertices v ∈ V , can construct shortest-path tree in O(|V | + |E|) time</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Initialize empty parent pointer P and set P(s) = NoneFor each vertex u ∈ V where δ(s, u) is finite:  </span><br><span class="line">  For each outgoing neighbor v ∈ Adj+(u):  </span><br><span class="line">    If P(v) is not assigned and δ(s, v) = δ(s, u) + w(u, v):  </span><br><span class="line">      There exists a shortest path through edge (u, v), so set P(v) = uParent pointers may traverse cycles of zero weight. Mark each vertex in such a cycle.For each unmarked vertex u ∈ V (including vertices later unmarked):  </span><br><span class="line">  For each v ∈ Adj+(u) where v is marked and δ(s, v) = δ(s, u) + w(u, v):  </span><br><span class="line">    Unmark vertices in cycle containing v by traversing parent pointers from v  </span><br><span class="line">    Set P(v) = u, breaking the cycle</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>初始化父节点指针P，设置P(s)为空</li>
<li>对u的每条出边通向的节点v</li>
<li>如果P(v)为空且s-&gt;v最短路径是s-&gt;u-&gt;v,则P(v)=u</li>
<li>父节点可能导致一个权值为0的循环，如果有环则标记出来</li>
<li>对每个没有被标记的u(包括之后会被标记的)</li>
<li>如果有标记的邻居v满足最短路径条件</li>
<li>通过遍历v的父节点清除对它和它的父节点的标记</li>
<li>设置P(v)=u，打破循环</li>
</ol>
<h4 id="dag松弛算法">DAG松弛算法:</h4>
<ol type="1">
<li><p>对每个顶点v维护一个距离估计d(s,v),初始化为无穷大,始终上界真实最短距离δ(s,v)</p></li>
<li><p>当边(u,v)违反三角不等式时,通过松弛操作将d(s,v)降低为d(s,u)+w(u,v)</p></li>
<li><p>松弛操作保证了d(s,v)始终是到v的某条路径的权重(或无穷大)</p></li>
<li><p>算法流程:<br />
  - 初始化d(s,v)=无穷大,d(s,s)=0<br />
   - 按拓扑排序顺序遍历每个顶点u<br />
     - 对每个出边(u,v),如果d(s,v) &gt; d(s,u)+w(u,v),执行松弛操作</p></li>
<li><p>可以证明当算法结束时,d(s,v)=δ(s,v),即正确计算出最短距离</p></li>
<li><p>时间复杂度为O(V+E),是线性时间算法</p></li>
<li><p>主要思想是利用DAG没有环的特点,通过松弛操作逐步收紧距离上界,直到使其等于最短距离</p></li>
<li><p>利用拓扑排序的顺序,保证每次松弛时通过的顶点u的d(s,u)已经是最短距离</p></li>
</ol>
<h3 id="generic-s.p.-algorithm通用最短路径算法">Generic S.P. Algorithm通用最短路径算法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Initialize:            for v in V:</span><br><span class="line">                            d[v] ← ∞</span><br><span class="line">                            Π[v] ← NIL</span><br><span class="line">                        d[s] ← 0</span><br><span class="line"></span><br><span class="line">Main:                  Repeat</span><br><span class="line">                       select edge (u, v)</span><br><span class="line">Relax edge (u, v):         if d[v] &gt; d[u] + w(u, v):</span><br><span class="line">                               d[v] ← d[u] + w(u, v)</span><br><span class="line">                               Π[v] ← u</span><br><span class="line">                        until you can’t relax any more edges or you’re tired or . .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 u 到 v 的最短路径权重是 δ(u, v)。 如果从 u 无法到达 v，则 δ(u, v) 为 Infini， 如果从 u 到 v 的某个路径上存在负循环，则未定义。 <img src="/assets/mit6.006总和笔记/image-20231023103416467.png" /> <img src="/assets/mit6.006总和笔记/image-20231023104514707.png" /> PATHological示例:设置n个节点,前3对节点的边权为2<sup>n/2,第二组节点边权为2</sup>(n/2)-1,以此类推。这样设置权重,从v0到vn-1的距离约为2<sup>n。算法可能每次只将距离减少1,需重复2</sup>n次,时间复杂度为O(2^n)。 因此最短路径算法的性能很大程度上取决于图的结构,存在PATHological情况时算法效率很低。需设计改进的算法,避免指数时间复杂度。</p>
<h3 id="迪杰斯特拉无负数边的图">迪杰斯特拉（无负数边的图）</h3>
<ol type="1">
<li>初始化:对每个顶点v,设置d(s,v)=∞,d(s,s)=0。</li>
<li>构建一个优先队列Q,每个顶点v以(v,d(s,v))为项加入Q。</li>
<li>循环直到Q为空:<br />
   - 出队Q中key最小的顶点u<br />
   - 对每个出边(u,v):<br />
      - 如果d(s,v) &gt; d(s,u) + w(u,v):<br />
         - 进行松弛操作         -  降低Q中v的key值到新的d(s,v)</li>
<li>时间复杂度O(E+VlogV),使用二叉堆可以达到O(E+VlogV)</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html">演示</a> 1. 对每个边(u,v),假设权重w(u,v)≥0,维护一个集合S,包含已确定最短路径权重的顶点。 2. 重复地从V-S中选择一个离源点最近的顶点u,将u加入S,松弛u的所有出边,即比较点u连通的其他节点，从点u出发的路径是否比距离表内的短 3. 伪代码: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Dijkstra (G, W, s) //uses priority queue Q</span><br><span class="line"> Initialize (G, s)</span><br><span class="line"> S ← φ</span><br><span class="line"> Q ← V [G] //Insert into Q</span><br><span class="line"> while Q != φ</span><br><span class="line">  do u ← EXTRACT-MIN(Q) //deletes u from Q</span><br><span class="line">  S = S ∪ &#123;u&#125;</span><br><span class="line">  for each vertex v ∈ Adj[u]</span><br><span class="line">   do RELAX (u, v, w) ← this is an implicit DECREASE KEY operation</span><br><span class="line"></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RELAX(u, v, w)</span><br><span class="line"> if d[v] &gt; d[u] + w(u, v)</span><br><span class="line">  then d[v] ← d[u] + w(u, v)</span><br><span class="line">  Π[v] ← u</span><br><span class="line">放松是安全的</span><br><span class="line"> 引理：松弛算法对于所有的情况都保持 d[v] ≥ δ(s, v) 的不变量</span><br><span class="line"> v ∈ V 。</span><br><span class="line"> 证明：通过步数归纳。</span><br><span class="line"> 考虑 RELAX(u, v, w)。  通过归纳法 d[u] ≥ δ(s, u)。  通过三角形 -</span><br><span class="line"> 等式，δ(s, v) ≤ δ(s, u) + δ(u, v)。  这意味着 δ(s, v) ≤ d[u] + w(u, v)，因为</span><br><span class="line"> d[u] ≥ δ(s, u) 且 w(u, v) ≥ δ(u, v)。  因此设置 d[v] = d[u] + w(u, v) 是安全的。</span><br><span class="line"></span><br></pre></td></tr></table></figure> 4. 通过重复选择最近顶点,逐步确定最短路径,时间复杂度为O(|E|+|V|log|V|)。 <img src="/assets/mit6.006总和笔记/image-20231024112814756.png" /></p>
<h4 id="证明">证明</h4>
<p>归纳法证明当顶点v从Q中取出时,d(s,v) = δ(s,v)成立: 基础:s第一个取出,d(s,s)=0 = δ(s,s)成立 - 归纳假设:对前k-1个顶点成立 - 考虑第k个顶点v0:    - 取v0到s的最短路径π,w(π)=δ(s,v0)   - 设(x,y)是π中第一个y不在前k-1个顶点的边    - 当x取出时,d(s,x)=δ(s,x)(归纳假设)    - 所以取出x时松弛(x,y),d(s,y) ≤ δ(s,x) + w(x,y) = δ(s,y)   - 由于松弛操作的安全性,d(s,v0) ≤ δ(s,v0)    - 又因为v0是Q中key最小的,d(s,v0) ≥ δ(s,v0)    - 所以d(s,v0) = δ(s,v0)</p>
<h4 id="时间复杂度">时间复杂度</h4>
<div class="line-block">操作 | 时间复杂度 | 在Dijkstra中的出现次数|</div>
<p>|-|-|-| <br />
|Q.build(X) (n = |X|)| Bn | 1 |<br />
|Q.delete min()| Mn | |V| |<br />
|Q.decrease key(id, k)| Dn | |E| | 总计O(B|V | + |V | · M|V | + |E| · D|V |) 对一个对顶点所有节点可达的图（修建过）： <img src="/assets/mit6.006总和笔记/image-20231025202308176.png" /> 对不同稀疏密度的图,使用不同的数据结构实现Dijkstra算法可以得到不同的时间复杂度: - 如果图是密集的,即 |E| = Θ(|V|<sup>2),使用数组实现优先队列Q,时间复杂度为O(|V|</sup>2) - 如果图是稀疏的,即 |E| = Θ(|V|),使用二叉堆实现Q,时间复杂度为 O(|V|log|V|) - Fibonacci堆在理论上对任意图都很好,但是实践中不常用 - 在理论分析中,通常假设Dijkstra算法的时间复杂度为O(|E| + |V|log|V|) 总结 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Dijkstra Complexity</span><br><span class="line"> Θ(v) inserts into priority queue</span><br><span class="line"> Θ(v) EXTRACT MIN operations</span><br><span class="line"> Θ(E) DECREASE KEY operations</span><br><span class="line">Array impl:</span><br><span class="line"> Θ(v) time for extra min</span><br><span class="line"> Θ(1) for decrease key</span><br><span class="line"> Total: Θ(V.V + E.1) = Θ(V 2 + E) = Θ(V 2)</span><br><span class="line">Binary min-heap:</span><br><span class="line"> Θ(lg V ) for extract min</span><br><span class="line"> Θ(lg V ) for decrease key</span><br><span class="line"> Total: Θ(V lg V + E lg V )</span><br><span class="line">Fibonacci heap (not covered in 6.006):</span><br><span class="line"> Θ(lg V ) for extract min</span><br><span class="line"> Θ(1) for decrease key</span><br><span class="line"> amortized cost</span><br><span class="line"> Total: Θ(V lg V + E)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="优化双向搜索">优化——双向搜索</h4>
<p>如果只需要s到t的最短路径，则只需要进行到t出队时结束算法 1. 双向搜索可以加速搜索,但不改变最坏时间复杂度,实际上可以减少访问的节点数。 2. 双向搜索同时进行:     - 从s节点进行正向搜索    - 从t节点进行反向搜索(沿边反向移动) 3. 正向搜索距离标记为df(u),反向为db(u) 4. 当一个节点w同时被两边搜索删除出队列时,搜索终止。 5. 终止后,找到df(x)+db(x)最小的节点x,x不一定是终止节点w。 6. 使用正向predecessor树Πf找到s到x的最短路径,使用反向树Πb找到t到x的最短路径。 7. 节点x一定已经被某一边搜索删除出队列。 <img src="/assets/mit6.006总和笔记/image-20231024193957638.png" /></p>
<h4 id="a算法">A*算法</h4>
<ol type="1">
<li>A*通过势函数修改边权重指引搜索方向:w'(u,v) = w(u,v) - λ(u) + λ(v)</li>
<li>选择势函数使修改后的权重保持最短路径不变,且权重非负,以适用于Dijkstra算法。</li>
<li>设定目标势值为0,源点势值足够大,可以引导搜索方向。</li>
<li>使用landmark技巧:预计算顶点到一些landmark节点的最短距离δ(u,l)。定义势函数λ(u)=δ(u,l)-δ(t,l),可以证明是可行的。</li>
<li>对每个landmark l计算势函数λ,取最大值作为最终势函数,仍可行。</li>
<li>A*相比普通搜索可以显著减少搜索范围,提高效率。但最坏情况时间复杂度未改变。</li>
</ol>
<p>Modify edge weights with potential function over vertices <span class="math display">\[
\overline{w}(u, v) = w(u, v) - λ(u) + λ(v)
\]</span></p>
<p>So shortest paths are maintained in modified graph with w(overline) weights <span class="math display">\[
\overline{w}(p) = w(p) - λ_t(u) + λ_t(t)
\]</span> Small set of landmarks LCV . For all u ∈ V, l ∈ L, pre-compute δ(u, l). Potential <span class="math display">\[
λ_t^{(l)}(u) = δ(u, l) − δ(t, l)
\]</span> <img src="/assets/mit6.006总和笔记/image-20231024193915317.png" /></p>
<h3 id="贝尔曼福特">贝尔曼福特</h3>
<h4 id="负循环检测">负循环检测</h4>
<ol type="1">
<li>定义k边距离δk(s,v):从s到v的路径中最多包含k条边的最小路径权重。</li>
<li>计算出δ|V|-1(s,v)和δ|V|(s,v),如果δ|V|(s,v)&lt;δ|V|-1(s,v),则v是一个负环见证人(witness)。</li>
<li>任意有向图中，对每个v∈V，计算δ(s,v)和δ|V|-1(s,v):<br />
   - 如果δ(s,v)&lt;δ|V|-1(s,v),则δ|V |(s, v) =- ∞，把v视为负循环见证人    - 如果δ(s,v)!=−∞,则δ(s,v)=δ|V|-1(s,v)(简单最短路径原理)    - 如果δ(s,v)=−∞,v可以从某个见证人出发而到达</li>
<li>证明思路:<br />
</li>
</ol>
<ul>
<li>假设某个负环C可达且不包含见证人,则对C中任一顶点v有:<br />
δ|V|(s,v) ≤ δ|V|-1(s,v的前驱)+w(v的前驱,v) &lt; δ|V|-1(s,v)<br />
</li>
<li>矛盾,所以C中必须存在见证人。</li>
<li><img src="/assets/mit6.006总和笔记/image-20231025082230441.png" /></li>
</ul>
<h4 id="定义">定义</h4>
<p><img src="/assets/mit6.006总和笔记/image-20231025092945965.png" /> 正确性： s到vk(k表示层数)的最短路径是每层可能的路径的最短者，贝尔曼福特算法穷举每一种可能，所以最后能得出最短的|V|-1层路径，从|V|-1到|V|则取决于图有没有负循环，如果有负循环，则s到见证人可达的结点路径为负无穷长 运行时间 1. 构建多层图G'需O(|V|(|V|+|E|)) 2. 在G'上运行DAG最短路径算法需O(|V|(|V|+|E|))，即G'大小的线性时间 3. 处理每个负环见证人需O(1),找到一个见证人的所有可达结点是O(|E|)见证人最多V个，找到所有见证人的可达性需O(|V||E|) 4. 如果把G修整成s开始的s可达子图，时间复杂度为O(|V||E|)</p>
<p>扩展思考: <img src="/assets/mit6.006总和笔记/image-20231025093817635.png" /></p>
<p><img src="/assets/mit6.006总和笔记/image-20231025080815803.png" /> • |V | + 1 levels: vertex vk in level k represents reaching vertex v from s using ≤ k edges • If edges only increase in level, resulting graph is a DAG • Construct new DAG G0 = (V 0, E0) from G = (V, E): – G' has |V |(|V | + 1) vertices v_k for all v ∈ V and k ∈ {0, . . . , |V |} – G' has |V |(|V | + |E|) edges: ∗ |V | edges (vk−1, vk) for k ∈ {1, . . . , |V |} of weight zero for each v ∈ V ∗ |V | edges (uk−1, vk) for k ∈ {1, . . . , |V |} of weight w(u, v) for each (u, v) ∈ <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Bellman-Ford(G,W,s)</span><br><span class="line"> Initialize ()</span><br><span class="line"> for i = 1 to |V | − 1</span><br><span class="line">  for each edge (u, v) ∈ E:</span><br><span class="line">   Relax(u, v)</span><br><span class="line"> for each edge (u, v) ∈ E</span><br><span class="line">  do if d[v] &gt; d[u] + w(u, v)</span><br><span class="line">   then report a negative-weight cycle exists</span><br><span class="line">//At the end, d[v] = δ(s, v), if no negative-weight cycles</span><br><span class="line"></span><br></pre></td></tr></table></figure> 1. 初始化,进行|V|-1轮松弛操作,每轮对每个边(u,v)做relax操作，非负的图最多需要|V|-I次操作就可以松弛到任意点出发的任意路径都是最短路径 2. 如果第|V|轮还可以relax任意边,说明存在负权环。 3. 如果图中无负权环,Bellman-Ford执行结束后d[v]=δ(s,v)。 4. 推论:如果d[v]在|V|-1轮未收敛,说明存在从s可达的负权环。 5. Bellman-Ford时间复杂度为O(|V||E|),适合稠密图。</p>
<h4 id="最长简单路径和最短简单路径">最长简单路径和最短简单路径</h4>
<p>在具有非负边权重的图中找到最长的简单路径是一个 NP- hard问题，不存在已知的多项式时间算法。 假设一个 只需否定每个边权重并运行 Bellman-Ford 来计算最短 路径。 贝尔曼-福特不一定会计算原始路径中的最长路径 图，因为可能存在可从源到达的负权重循环，并且 算法将中止。 类似地，如果我们有一个具有负循环的图，并且我们希望找到最长的 从源 s 到顶点 v 的简单路径，我们不能使用 Bellman-Ford。 最短的 简单路径问题也是NP- hard问题</p>
<h2 id="johnsons-algorithm">Johnson’s Algorithm</h2>
<h3 id="all-pairs-shortest-paths-apsp">All-Pairs Shortest Paths (APSP)</h3>
<ul>
<li>输入:有向带权图G=(V,E),权值函数w:E→Z</li>
<li>输出:对所有u,v∈V,求出δ(u,v),如果有负权回路则报错</li>
<li>应用:理解整个网络,如交通、电路布线、供应链等</li>
<li>直接运行|V|次单源算法时间复杂度:     - DAG松弛: |V|·O(|V|+|E|),无环<br />
  - BFS: |V|·O(|V|+|E|),非负权值<br />
  - Dijkstra: |V|·O(|V|log|V|+|E|),非负权值<br />
  - Bellman-Ford: |V|·O(|V||E|),一般图</li>
</ul>
<p>思路：重构权值函数,使G变为G',其中G'没有负权边,且G的最短路径在G'上也是最短路径。如果成功,就可以在G'上运行Dijkstra 实现： 对每个顶点v:<br />
- 从v出发的边权加上h<br />
- 进入v的边权减去h<br />
- 这样可以保证最短路径不变<br />
- 证明:<br />
  - 任意从v开始的路径权值改变了h<br />
  - 任意到v结束的路径权值改变了-h<br />
  - 通过v的路径权值局部不变</p>
<p><img src="/assets/mit6.006总和笔记/image-20231025213904004.png" /></p>
<h3 id="算法">算法</h3>
<ul>
<li>构造含新顶点x的图Gx,x到每个顶点v有权值为0的边</li>
<li>对Gx运行Bellman-Ford算法计算δx(x,v)</li>
<li>如果δx(x,v)为无穷大,说明G中有负权回路,报错退出</li>
<li>否则,用δx重新调整每个边的权值构造G'</li>
<li>对G'运行Dijkstra算法|V|次计算每个顶点的最短路径 </li>
<li>从G'的最短路径恢复G的最短路径</li>
</ul>
<h3 id="时间复杂度-1">时间复杂度</h3>
<ul>
<li>构造Gx需O(|V|+|E|)</li>
<li>Bellman-Ford需O(|V||E|)</li>
<li>构造G'需O(|V|+|E|)</li>
<li>|V|次Dijkstra需O(|V|(|V|log|V| + |E|))</li>
<li>用G'恢复G的距离需O(|V|^2)</li>
<li>总计O({|V|^2}log|V| + |V||E|)</li>
</ul>
<h1 id="概率">概率</h1>
<p>雇佣问题 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">best = 0</span><br><span class="line">hired = null</span><br><span class="line">for i = 1 to n</span><br><span class="line">if candidates[i] &gt; best</span><br><span class="line"> best = candidates[i]</span><br><span class="line"> hired = i</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="指示器随机变量">指示器随机变量</h2>
<p>指示器随机变量可以用于对随机输入的算法分析 <span class="math display">\[I(A) = \begin{cases}  
           1 &amp; \text{event A occurs} \\  
           0 &amp; \text{otherwise}  
\end{cases}\]</span> 把期望转化成指示器期望的相加</p>
<h2 id="随机算法">随机算法</h2>
<p>在此基础上可以在算法中进行随机数处理，排除输入的影响 比如在雇佣问题中，对输入的候选者数组进行随机排序 随机排序： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">n = A.length</span><br><span class="line">let P[1-n] be a new array</span><br><span class="line">for i=1 to n</span><br><span class="line"> P[i] = RANDOM(1,n^3)</span><br><span class="line">sort A,use P</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="递归和动态规划">递归和动态规划</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># recursive solution (top down)</span><br><span class="line">def fib(n):</span><br><span class="line"> memo = &#123;&#125;</span><br><span class="line"> def F(i):</span><br><span class="line">  if i &lt; 2: return i # base cases</span><br><span class="line">  if i not in memo: # check memo</span><br><span class="line">   memo[i] = F(i - 1) + F(i - 2) # relation</span><br><span class="line">  return memo[i]</span><br><span class="line"> return F(n) # original</span><br><span class="line"># iterative solution (bottom up)</span><br><span class="line">def fib(n):</span><br><span class="line"> F = &#123;&#125;</span><br><span class="line"> F[0], F[1] = 0, 1 # base cases</span><br><span class="line"> for i in range(2, n + 1): # topological order</span><br><span class="line">  F[i] = F[i - 1] + F[i - 2] # relation</span><br><span class="line"> return F[n] # original</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231027103835269.png" /> <img src="/assets/mit6.006总和笔记/image-20231027112657842.png" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># recursive solution (top down)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bowl</span>(<span class="params">v</span>):</span><br><span class="line"> memo = &#123;&#125;</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">B</span>(<span class="params">i</span>):</span><br><span class="line">  <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(v): <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># base cases</span></span><br><span class="line">  <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> memo: <span class="comment"># check memo</span></span><br><span class="line">  memo[i] = <span class="built_in">max</span>(B(i+<span class="number">1</span>), <span class="comment"># relation: skip pin i</span></span><br><span class="line">   v[i] + B(i+<span class="number">1</span>), <span class="comment"># OR bowl pin i separately</span></span><br><span class="line">   v[i] * v[i+<span class="number">1</span>] + B(i+<span class="number">2</span>)) <span class="comment"># OR bowl pins i and i+1 together</span></span><br><span class="line">   <span class="keyword">return</span> memo[i]</span><br><span class="line">  <span class="keyword">return</span> B(<span class="number">0</span>) <span class="comment"># original</span></span><br><span class="line"><span class="comment"># iterative solution (bottom up)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bowl</span>(<span class="params">v</span>):</span><br><span class="line"> B = &#123;&#125;</span><br><span class="line"> B[<span class="built_in">len</span>(v)] = <span class="number">0</span> <span class="comment"># base cases</span></span><br><span class="line"> B[<span class="built_in">len</span>(v)+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(v))): <span class="comment"># topological order</span></span><br><span class="line">  B[i] = <span class="built_in">max</span>(B[i+<span class="number">1</span>], <span class="comment"># relation: skip pin i</span></span><br><span class="line">   v[i] + B(i+<span class="number">1</span>), <span class="comment"># OR bowl pin i separately</span></span><br><span class="line">   v[i] * v[i+<span class="number">1</span>] + B(i+<span class="number">2</span>)) <span class="comment"># OR bowl pins i and i+1 together</span></span><br><span class="line"> <span class="keyword">return</span> B[<span class="number">0</span>] <span class="comment"># original</span></span><br></pre></td></tr></table></figure>
<p>如何关联子问题解决方案 • 我们遵循的一般方法来定义子问题解决方案的关系： - 确定一个有关子问题解决方案的问题，如果知道答案，则该问题将减少到“更小的”子问题 - 在打保龄球的情况下，问题是“我们如何打第一对球瓶？” - 然后通过尝试所有可能的答案并采取最好的答案来本地暴力解决问题 - 在保龄球的情况下，我们取最大值，因为问题要求最大化 - 或者，我们可以考虑正确猜测问题的答案，然后 直接递归； 但随后我们实际上检查所有可能的猜测，并返回“最佳” • 效率的关键是问题有少量（多项式）可能的可能性。答案，所以暴力破解并不太昂贵 • 通常（但并非总是）计算关系的非递归工作等于数字 我们正在尝试的答案 ## 动态规划 ### LCS</p>
<p>• x(i, j) = A[i :] 和 B[j :]的最大公共子序列 • For 0 &lt;= i &lt;= |A| and 0 &lt;=0 j &lt;= |B| 最长公共子序列问题(LCS): 1. 定义了子问题x(i,j),表示 A[i:]和B[j:]的最长公共子序列长度。 2. 列出了递归关系 - 如果A[i]==B[j],那么x(i,j)等于x(i+1,j+1)+1,否则等于x(i+1,j)和x(i,j+1)的最大值。 3. 指出了拓扑顺序,子问题依赖更大的i或j。 4. 给出了 base cases —— 当一个字符串为空时,LCS长度为0。x(i, |B|) = x(|A|, j) = 0 5. 原问题可以通过x(0,0)求解,同时需要parent pointers构建最长子序列。 6. 时间复杂度分析也正确,子问题数为O(|A|*|B|),每件工作为O(1),所以总时间为O(|A|*|B|)。 <span class="math display">\[
x(i,j) =
\begin{cases}
   x(i+1,j+1)+1, &amp; \text{if }A[i]=B[j] \\
   max(x(i + 1, j), x(i, j + 1)) , &amp; otherwise
\end{cases}
\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">A, B</span>):</span><br><span class="line"> a, b = <span class="built_in">len</span>(A), <span class="built_in">len</span>(B)</span><br><span class="line"> x = [[<span class="number">0</span>] * (b + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a + <span class="number">1</span>)]<span class="comment">#x 的最终形状是一个 (a + 1) x (b + 1) 的二维列表,每个元素初始化为 0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(b)):</span><br><span class="line">   <span class="keyword">if</span> A[i] == B[j]:</span><br><span class="line">    x[i][j] = x[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">    x[i][j] = <span class="built_in">max</span>(x[i + <span class="number">1</span>][j], x[i][j + <span class="number">1</span>])</span><br><span class="line"> <span class="keyword">return</span> x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment">#如果A[i] == B[j],那么最长公共子序列可以在A[i+1:]和B[j+1:]的基础上再加上A[i]这个字符,所以x[i][j] = x[i+1][j+1] + 1。</span></span><br><span class="line"><span class="comment">#如果A[i] != B[j],那么A[i]和B[j]不可能同时在最长公共子序列中,需要舍弃一个字符。所以x[i][j]取x[i+1][j]和x[i][j+1]中的最大值。</span></span><br><span class="line"><span class="comment">#依次遍历,直到i或j变为-1,即遍历完两个字符串。</span></span><br></pre></td></tr></table></figure>
<h3 id="lis">LIS</h3>
<p><code>Longest Increasing Subsequence (LIS)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lis</span>(<span class="params">A</span>):</span><br><span class="line"> a = <span class="built_in">len</span>(A)</span><br><span class="line"> x = [<span class="number">1</span>] * a</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, a):</span><br><span class="line">   <span class="keyword">if</span> A[j] &gt; A[i]:</span><br><span class="line">    x[i] = <span class="built_in">max</span>(x[i], <span class="number">1</span> + x[j])</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">max</span>(x)</span><br></pre></td></tr></table></figure>
<p>x(i)是A[i:]的最长递增子数组 O(|A|^2) running time - 外层循环i是在寻找以每个元素结尾的LIS长度。 - 内层循环j是在寻找可以接在A[i]后面的最大LIS长度。 - x数组缓存了每个位置的LIS长度,避免重复计算。 - 通过从后向前遍历,可以保证每个x[i]都是最新的最大LIS长度。</p>
<h3 id="alternating-coin-game">Alternating Coin Game</h3>
<ul>
<li>两名玩家（“我”和“你”）轮流</li>
<li>轮流取出剩余硬币中的第一个或最后一个硬币</li>
<li>我的目标是最大化我所拿走的硬币的总价值，这是我首先要做的 x(i, j) =我可以从 vi, . . . , vj中拿走的最大硬币总价值 <img src="/assets/mit6.006总和笔记/image-20231027200057225.png" /> 子问题: O(n^2) • 每个子问题相加: O(n) to compute sums • O(n^3) running time #### 优化</li>
</ul>
<ol type="1">
<li>扩展定义子问题x(i,j,p),添加了一个表示下一步该谁走的状态p。</li>
<li>列出了四个递归关系式,区分我方走与对方走的不同情况。</li>
<li>拓扑顺序及base case与第一种解法相同。</li>
<li>计算原问题时,状态为我方走。</li>
</ol>
<p>x(i, j, p) = maximum total value I can take when player p ∈ {me, you} starts from coins of values vi, . . . , vj</p>
<p>Player p must choose either coin i or coin j • If p = me, then I get the value; otherwise, I get nothing • Then it’s the other player’s turn • x(i, j, me) = max{vi + x(i + 1, j, you), vj + x(i, j + 1, you)} • x(i, j, you) = min{x(i + 1, j, me), x(i, j + 1, me)} <img src="/assets/mit6.006总和笔记/image-20231027200227456.png" /> <strong>时间</strong> • subproblems: ⇥(n2) • work per subproblem: ⇥(1) • ⇥(n2) running time 扩展子问题可以提供递归所需信息,但代价是子问题数目增加,计算复杂度上升。需要权衡取舍。</p>
<h3 id="rod-cutting">Rod Cutting</h3>
<p>切一根棍子，切割长度产生的收益如表</p>
<table>
<thead>
<tr class="header">
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>0</td>
<td>1</td>
<td>10</td>
<td>13</td>
<td>18</td>
<td>20</td>
<td>31</td>
<td>32</td>
</tr>
</tbody>
</table>
<p>x(l): maximum value obtainable by cutting rod of length x(l) = max{v(p) + x(l-p) | p 2 {1, . . . ,l }} time: - subproblems: L + 1 - work per subproblem: O(l) = O(L) - O(L^2) running time</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># recursive</span></span><br><span class="line">x = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">l, v</span>):</span><br><span class="line"> <span class="keyword">if</span> l &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># base case</span></span><br><span class="line"> <span class="keyword">if</span> l <span class="keyword">not</span> <span class="keyword">in</span> x: <span class="comment"># check memo</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + cut_rod(l - piece, v) <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> (l <span class="keyword">not</span> <span class="keyword">in</span> x) <span class="keyword">or</span> (x[l] &lt; x_): <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line"> <span class="keyword">return</span> x[l]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iterative</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">L, v</span>):</span><br><span class="line"> x = [<span class="number">0</span>] * (L + <span class="number">1</span>) <span class="comment"># base case</span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>): <span class="comment"># topological order</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + x[l - piece] <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> x[l] &lt; x_: <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line"> <span class="keyword">return</span> x[L]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iterative with parent pointers</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod_pieces</span>(<span class="params">L, v</span>):</span><br><span class="line"> x = [<span class="number">0</span>] * (L + <span class="number">1</span>) <span class="comment"># base case</span></span><br><span class="line"> parent = [<span class="literal">None</span>] * (L + <span class="number">1</span>) <span class="comment"># parent pointers</span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>): <span class="comment"># topological order</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + x[l - piece] <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> x[l] &lt; x_: <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line">    parent[l] = l - piece <span class="comment"># update parent</span></span><br><span class="line"> l, pieces = L, []</span><br><span class="line"> <span class="keyword">while</span> parent[l] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># walk back through parents</span></span><br><span class="line">  piece = l - parent[l]</span><br><span class="line">  pieces.append(piece)</span><br><span class="line">  l = parent[l]</span><br><span class="line"> <span class="keyword">return</span> piece</span><br></pre></td></tr></table></figure>
<h3 id="subset-sum">Subset Sum</h3>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0322014dc357?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes">相关博客</a> A = {a0, a1, . . . , an} 是否存在A的子集A'，A'的元素总和为T x(i, j): True if can make sum j using items 1 to i, False otherwis <span class="math display">\[
x(i,j) =
\begin{cases}
   x(i - 1, j - A[i]), &amp; \text{if j &gt;= A[i] } \\
   x(i - 1, j), &amp; always
\end{cases}
\]</span> - x(i, 0) = True for i ∈ {0, . . . , n} (trivial to make zero sum!) - x(0, j) = False for j ∈ {1, . . . , T} (impossible to make positive sum from empty set - for i ∈ {0, . . . , n}, j ∈ {0, . . . , T}</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp_subset</span>(<span class="params">arr,S</span>):</span><br><span class="line">    </span><br><span class="line">    subset = np.zeros((<span class="built_in">len</span>(arr),S+<span class="number">1</span>),dtype=<span class="built_in">bool</span>) <span class="comment">#构造二维数组</span></span><br><span class="line">    subset[:,<span class="number">0</span>] = <span class="literal">True</span> <span class="comment"># 第一列 设为True</span></span><br><span class="line">    subset[<span class="number">0</span>,: ] = <span class="literal">False</span> <span class="comment">#第一列 设为 False</span></span><br><span class="line">    subset[<span class="number">0</span>,arr[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, S+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; s:</span><br><span class="line">                subset[i , s] = subset[i-<span class="number">1</span> , s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = subset[i-<span class="number">1</span> , s ]</span><br><span class="line">                B = subset[i-<span class="number">1</span> , s - arr[i]]</span><br><span class="line">                subset[i,s] = A <span class="keyword">or</span> B</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    row ,cell = subset.shape</span><br><span class="line">    <span class="keyword">return</span> subset[row-<span class="number">1</span>,cell-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">arr  = [<span class="number">1</span>,<span class="number">2</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]            </span><br><span class="line">dp_subset(arr,<span class="number">7</span>) </span><br><span class="line">out:<span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231028110550677.png" /></p>
<p>subproblems: O(nT ), O(1) work per subproblem, O(nT ) time # 其他 ## 多项式时间的判定 只有在算法时间复杂度仅与问题规模有多项式关系时，才可称为多项式时间复杂度算法。 存在如基数排序之类时间复杂度依赖于输入数据的算法，称为伪多项式时间复杂度，此时算法的时间复杂度是输入数据大小的多项式时间表达，但却是输入数据长度（输入规模）的指数时间表达</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">冒泡排序：给定 n 个64位的数字，进行 n-1 次扫描交换，将数字从小到大排序。</span><br><span class="line">素数测试：给定数字 n，通过从 2 到根号 n 的整数遍历，判断 n 是否为素数。</span><br><span class="line">字面上看，两者复杂度都是 O(n^k) ( k 为整数) 。但区别在于，前者的 n 是数字个数的多少，后者的 n 是数字的大小。</span><br><span class="line">因此，前者输入总规模 s1 增长与数字大小无关，s1 = 64n；后者增长规模与数字大小紧密相关，输入总规模为 s2 = logn 。</span><br><span class="line">所以可知冒泡排序中复杂度 O(n^2) = O(s1^2/64^2) 为多项式算法，后者素数测试O(n) = O(2^(s2)) 为伪多项式算法</span><br></pre></td></tr></table></figure>
<h2 id="复杂度">复杂度</h2>
<ul>
<li>决策问题:将输入归类为YES或NO的问题。</li>
<li>算法/程序:能够在一定时间内解决问题的常量长度代码。</li>
<li>如果问题有算法可以在有限时间内解决,则该问题是可判定的。</li>
<li>程序是有限的,问题是无限的,因此大多数决策问题是不可判定的。</li>
<li>即使可判定,也以不同的时间复杂度分类:</li>
</ul>
<ol type="1">
<li>R类:有限时间可判定</li>
<li>EXP类:指数时间可判定</li>
<li>P类:多项式时间可判定(我们关注的)</li>
</ol>
<ul>
<li>这些类满足 P⊆EXP⊆R 的包含关系。 NP与P问题参考<a href="https://thinklive1.github.io/2023/10/06/61b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/">61b笔记</a></li>
</ul>
<p>mit的后续课程 <img src="/assets/mit6.006总和笔记/image-20231027201108930.png" /> <img src="/assets/mit6.006总和笔记/image-20231027201117355.png" /></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag"># 课程笔记</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
              <a href="/tags/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5/" rel="tag"># 麻省理工</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/14/%E8%8B%8F%E5%A4%A7linux_ppt/" rel="prev" title="基于中科大linux101和苏大ppt的linux笔记">
                  <i class="fa fa-angle-left"></i> 基于中科大linux101和苏大ppt的linux笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/14/%E8%AE%A1%E7%BD%91/" rel="next" title="基于中科大郑烇老师授课的计算机网络笔记(待续)">
                  基于中科大郑烇老师授课的计算机网络笔记(待续) <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">thinklive</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">178k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:46</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 技术支持
  </div><script defer src="/lib/three.js"></script><script defer src="/lib/lines.js"></script><script defer src="/lib/waves.js"></script><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://thinklive1.github.io/2023/10/14/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"thinklive1/blog_comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

   <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
