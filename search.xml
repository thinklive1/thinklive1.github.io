<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>thinklive的迪瑞克拉图书馆</title>
    <url>/2023/09/17/thinklive%E7%9A%84%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E5%9B%BE%E4%B9%A6%E9%A6%86/</url>
    <content><![CDATA[<video src="/images/thinklive.mp4" autoplay >
</video>

<h1 id="欢迎来到迪瑞克拉"><a href="#欢迎来到迪瑞克拉" class="headerlink" title="欢迎来到迪瑞克拉"></a>欢迎来到迪瑞克拉</h1><p>这里是thinklive的个人博客，不定时地会发一些个人技术学习心得和生活体会<br>使用左侧的分类来定位内容</p>
<h2 id="迪瑞克拉的由来"><a href="#迪瑞克拉的由来" class="headerlink" title="迪瑞克拉的由来"></a>迪瑞克拉的由来</h2><p><code>狄利克雷函数</code>（英语：<code>dirichlet function</code>）是一个定义在实数范围上、值域不连续的函数。<code>狄利克雷函数</code>的图像以Y轴为对称轴，是一个偶函数，它处处不连续，处处极限不存在，不可黎曼积分。这是一个处处不连续的可测函数。<br>在我看来它象征着混沌，不可知与无限的可能性，<code>狄利克雷</code>换一种方式音译就成了迪瑞克拉</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><span id="more"></span>
<p>2023&#x2F;9&#x2F;17<br>迪瑞克拉博客的生日，当天增加了背景音乐，搜索，相册，标签，目录，置顶等基础功能</p>
<p>2023&#x2F;9&#x2F;18<br>新增了评论，预估阅读时间，字数统计，网站访问统计,加载进度条功能,将背景音乐的歌曲改为歌单,为了方便使用，菜单切换成了中英双语</p>
<p>2023&#x2F;9&#x2F;19<br>新增了多级分类的特性，让返回顶部的进步条已读百分比，页面底部能看到阅读进度条了，新增了代码块复制功能，现在可以通过书签功能自动储存阅读进度，使退出后重进仍是当初的进度，也可以手动点击右上角书签图标实现相同效果,新增了彩带背景，并把背景色改成黑色</p>
<p>2023&#x2F;9&#x2F;20<br>替换一些页面ui文本，为一些页面ui文本加入了颜文字</p>
<p>2023&#x2F;9&#x2F;26<br>在guestbook和首页嵌入了好友做的一个赛博朋克logo视频</p>
<p>2023&#x2F;9&#x2F;27<br>开启了一些next的小功能，侧边栏加了一个thinklive的赛博朋克logo</p>
<p>2023&#x2F;9&#x2F;28<br>新增了加密页面，由秘密这个目录名检索，密码不会向任何人透露，部分页面会有提示</p>
<p>2023&#x2F;9&#x2F;29<br>新增了资源地图菜单，点击会跳转到使用不同主题的子站，可以通过子站的侧边栏回到主页</p>
<p>2023&#x2F;9&#x2F;30<br>给子站加了看板娘，主站加了鼠标轨迹，子站加了鼠标轨迹和点击烟花特效，看板娘有截屏，提示等功能，但是主站不会加，毕竟主站定位比较严肃嘛,顺便加了个小彩蛋，离开页面一秒后就能看到</p>
<p>2023&#x2F;10&#x2F;1<br>修了一下标签页彩蛋的bug，新增了线条特效，鼠标不动时会慢慢聚集起来,由于next层级的原因，主站只有背景会生效，改起来很麻烦，正好对主站来说也有点太花哨了，就只在子站用吧<br>主站加了个小游戏页面，左上角回到主站，只能玩一把是故意的，避免一直摸鱼，绝对不是懒得写</p>
<p>2023&#x2F;10&#x2F;2<br>新增了神龛子站，用来放一些文学创作之类的玩意，更新随缘，主要是赛博朋克风挺好看的想整一个,返回主站会开新标签页是因为，伊卡洛斯这个主题没有不开新标签页的api，所以将就一下吧</p>
]]></content>
  </entry>
  <entry>
    <title>游戏简评</title>
    <url>/2023/09/30/%E6%B8%B8%E6%88%8F%E7%AE%80%E8%AF%84/</url>
    <content><![CDATA[<h1 id="428被封锁的涩谷"><a href="#428被封锁的涩谷" class="headerlink" title="428被封锁的涩谷"></a>428被封锁的涩谷</h1><p>希腊神话将命运女神履行职能的过程写作织网，这无疑是一种极为贴切的比喻，对网状结构来说，在中心处的轻轻一拨，边缘处就是极大的震动，越是深入核心，就越是复杂，但所有分支无论看上去多么没有规律，最后都会收束到中心网点，我想这就是428的编剧想实现的叙事结构。</p>
<span id="more"></span>
<p>这样的结构需要极致的严谨和巨大的工作量，正如正统的本格派推理一样丝丝入扣，同时还要维持各个部分的信息量尽量均布，各个网点处都有关键悬念留待读者，但，他们做到了，7位主角的命运与城市里大大小小配角的命运，就这样纠缠在一起，并收束到了一个巨大的阴谋上，更令人称奇的是，尽管使用了这样的结构，制作组仍然做到了悬念的均布，几乎没有出现信息量失衡的情况。<br>于是，玩家得以在4月28日的涩谷当一天的命运女神，只要在一个个节点上轻轻拨正些许紊乱的蛛丝，蛛丝就会自然而然地化为网状，事实上没有我说的这么轻松，因为这些命运的线条起初似乎是绕成一团，理清它们的过程也少不了误解和错误。<br>为了确保这个过程的顺畅，85个bad end大部分都有提示，以每一小时为节点，只有理清一小时内的所有事件，命运才能向前推进，起初似乎是一些不成规律的线，但逐渐就开始交错，纠缠，而作为有着神力的玩家，只需要制造一些偶然，改变一两个小小的决定就能够造成一连串的蝴蝶效应。<br>对这种操控命运的讨论很容易回到一些宿命论的思潮上来，幸运的是428的编剧在这个方面却有着很积极的态度，于是在结局，命运的线条汇聚在一起，无数偶然交错下，产生的必然却孕育着希望，尽管多少有些日式的大团圆味道，但流露出的价值观确实积极的。<br>如果说这样精巧的叙事结构有没有问题，那么当然也是有的，叙事必须依靠逻辑的支撑，如此庞大的网状结构，逻辑当然不可能天衣无缝，事实上依然有很多巧合和偶然，为了配合结构的需要，甚至部分主角也免不了当工具人，但你很难对此苛责什么，通过有限的角色实现如此复杂的剧本，不免要让一些角色承担过多的推进剧情的作用，相对来说编剧已经做得很不错了。<br>此外的问题是大部分日式游戏难免的幼稚气，叙事结构是精巧且充满悬念的，但一些抒情节点，以及一些过度夸张以至于模板化的人物性格，依然为其减色不少。不过我也能理解编剧，毕竟这种精密的结构确实很难填补完全恰如其分的内容<br>总的来说428在叙事结构方面可以说是当今电子游戏的最高峰水平，尽管它的其他部分可能只是优秀或者不错的程度，依旧是一款剧情类的神作</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>龙腾世纪三部曲</title>
    <url>/2023/09/30/%E9%BE%99%E8%85%BE%E4%B8%96%E7%BA%AA/</url>
    <content><![CDATA[<h1 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h1><p>本世纪的欧美rpg里最出名的应该是巫师三了，你可能曾因为好奇去搜过cdpr的发家史，也就是从卖盗版游戏到引进游戏并本土化赚到了第一桶金，这个引进的游戏是博德之门，博德之门的开发商是生软。</p>
<span id="more"></span>
<p>这里插一句，波兰人的首秀巫师一在开发阶段几乎遇到了一个新游戏能想到的所有问题，这时生软仗义地扶了波兰人一把，才有了巫师一的面世，遂成rpg界一段佳话，不过后来二者先后拉了（<br>龙腾世纪本来在定位上是博德之门的替代品，因为版权问题生软不能继续开发博德之门，于是便做出了龙腾世纪起源，这一项目立项在02年，但直到07年得到了EA的支持才在09年把这一“神作”做了出来，直到这时EA还是带善人的形象，并没有露出狰狞的獠牙，而在生软的黄金时代打磨了7年的起源，我可以毫不夸张地说，哪怕今年推出这款游戏，它依然是年度最佳候选级别的神作。<br>我先说说，我为什么要做这个视频，其实在一开始，dao在我的心中的地位还没有要我做一个视频出来的程度，但在玩了龙腾世纪的后两作后，DAO在我心中地位飙升，可见对比的力量，这个杂谈系列会讲完我对龙腾世纪整个系列的感受，当然是纯个人感受，我不<br>是什么rpg遗老，只是一个当代rpg爱好者而已，如有不同意之处，反正我也不会改的。</p>
<p>当你打开dao建立存档时，你可以选择三个种族，三个职业，在种族内甚至有平民和贵族的区别，根据职业和种族的不同，光开头剧情就有六种，由此开始，玩家就能感受到dao的超高自由度。<br>当然，对于rpg来说，自由度并不是什么稀奇的东西，但dao的自由度是有其独特之处的，以自由度出名的上古卷轴五，它的自由度体现于扮演的角色的多样性，龙裔，战友团成员，冬堡法师等等，这几种身份并没有交集，是独立的，而起源的自由度体现在行为的自由，自由度再高的游戏也不能完全模拟现实，但高自由度的游戏只需要模拟到玩家一时间能想到或者能让他们觉得有趣的所有选项就够了，DAO做到了这点，举例来说，当你接到了调查黑恶势力的任务，你可以当个正义的使者把邪恶势力端了，也可以接受贿赂，甚至可以献祭奴隶来提高自己的力量，你可以与邪教合作玷污圣物，也可以屠杀邪教，杀死恶龙，扮演被选召的勇士，很多时候当你背叛道德时得到的奖励反而更好，高道德的行为除了增加部分队友的好感度并没有太多作用，与巫师类似，起源遵循着成人的价值观，尽管选择大部分时候不像巫师那么残酷，而且起源中后悔也是很容易的一件事，相对削弱了选择的分量。</p>
<p>我们再来说说提高起源代入感的另一个设计——队友系统，独身在一个苍茫浩瀚的魔幻世界冒险难免会感到孤独，巫师的解决方式是让杰洛特和爱人与亲友保持时不时的联系，上古卷轴的解决方式，嗯，我没感到有什么解决方式，至少本体没有，当然如果装了随从mod肯定就完全不一样了。在龙腾世纪起源中你绝不会感到孤独，相比其他知名rpg，生软最显著的优点应该就是队友塑造了，dao的队友大部分有着讨喜且有深度的人设，这是由海量的工作量撑起来的，在冒险时会随机出现队友间的闲聊，几乎所有队友两两组合都有为数不少的对话，或八卦，或正经或取笑，这让人感到队友都是活生生的人，同时也可想而知其中的工作量，单个角色的对话文字量往往都要以万为单位，此外，在营地和队友闲聊也能通过一些选项增减好感度，所有队友都有为数不少的对话树，并且随着好感度的增减还会解锁额外选项。<br>队友间除了友情也能发展出爱情，这就不得不提我认为在魔幻rpg中最有魅力的女角色——莫瑞甘，她是个荒野女巫的女儿，，价值观完全是混乱中立甚至偏邪恶的，你做好事她嫌你磨叽，做坏事说不定夸你有魄力，好感度低时会邀请你滚床单并声明只是玩玩，好感度高起来了反而不愿继续亲近——“明明说了只是玩玩，怎么你当真了呢”在游戏的结局莫瑞甘会不可避免地离去，而在一个（拿感情骗钱的）的dlc里沃顿却能不远万里追踪到正欲逃走的她，最终让莫瑞甘也承认了爱情的存在，不得不说我真被这段爱情所感动了，这种细腻的感情戏其实不输我们以感情线为特色的双剑系列（当然续作就没这么顶了）<br>代入感之外，起源的战斗系统也是极有意思的，多有意思呢，大概比巫师三好几十个上古卷轴五吧（不是）起源的系统在今天看也不算过时，采用一种可以随时暂停的即时战斗系统，同时可以为队友ai设置战术，选项极为详细，大佬光靠设置ai应该就可以全自动战斗，我这种咸鱼打boss还是要几步一暂停，很明显这是一种重策略轻即时的系统，不设技能栏上限让法师成为了团队灵魂，控制，辅助，aoe，单体爆发应有尽有，可以说带够蓝药，法师就是无敌的（大部分Boss远程攻击弱于近战），即便职业平衡不是那么好，但队友是可以随意搭配的，丰富的技能树，转职，加点策略，装备系统让起源的战斗和养成充满乐趣，当然大型迷宫各种怪潮难免会腻烦，不过比起后面两作真的是让我体验最好的战斗系统了。<br>最后我们来说说起源的剧情和任务设计，大恶魔苏醒，黑潮突起，作为临危受命的灰袍守护者，沃顿利用古老盟约集结联军，手刃大恶魔，可以说是一个很俗套的故事，怎么把这种看起来很俗的故事讲好呢，答案是独立的小故事相加辅以大量填充细节和设定，起源的几条线，法师，矮人，精灵，伯爵都是相对独立的故事，套路很简单：求援——当地陷入危机——解决危机——得到援助，期间夹杂背叛者洛根使绊的故事线，每个地方引出了一部分的世界观设定，起源有着极其繁杂的文本，尽管套路类似，但每条线提供的信息量都是复杂且独特的，同时也有着世界观内各个势力特有的风貌，安教的圣洁，矮人的森严都得到了体现，即使很想比较，龙腾世纪的世界观也是独特且复杂的，当然，相比起源的主线，支线反而比较一般，不乏收集的填充式支线，当然，队友的支线还是很有趣的，也有一些补充世界观的有趣支线。<br>说了这么多，应该基本说完了起源的特点，当然也有很多具体内容我并没有提及，事实上起源并不是没有缺点，比如优化太差，自带防沉迷，玩几个小时就会卡顿到没完继续，只能重启，此外，敌人种类稀缺，也存在强行推动剧情而忽略合理性的情节，甚至有手刃大恶魔实力的主角有的时候莫名其妙就当垫脚石了，但起源仍然是神作，作为一个玩惯了10年后游戏的人，我玩起源没有感到任何系统在恶心我，可见制作组对玩家体验的重视，这是龙腾世纪的续作都未能做到的，，这也是我为龙腾世纪和生软感到可惜的原因，下一期我会叙述我对两部续作的看法，当然批评为主，，，<br>出道即巅峰的起源全平台销量不过470w，或许正是这样的销量驱使着生软不惜与老玩家对立也要向着主机倾斜，只可惜了龙腾世纪成为了开幕即巅峰，出场即绝唱的一个悲剧……</p>
<h1 id="da2"><a href="#da2" class="headerlink" title="da2"></a>da2</h1><p>今天我们来说说龙腾世纪二，，龙腾世纪二是系列中一部很，额，很独特的作品，他刚发售时的风评，作为后来人我不是很清楚，不过就现在来看，da2的风评呈现一种两极分化的形势。<br>这里插一句奥，我个人感觉rpg游戏的受众是个很宽容的群体，我这种认为2077是款好游戏的人放一些地方可能被叫孝子了，但对现在龙腾世纪的粉丝来说这可能都不算事，举个例子吧，写文案的这天龙腾世纪吧有个直接辱骂起源人气角色的，甚至没什么人骂回去，这放在其他单机游戏圈子里是难以想象的，所以对于龙腾世纪二这样极其赶工的，大部分玩家评价起来基本没什么戾气，当然事实上我很喜欢这一点，也是这点造成了da2并没有招致较为深入的批评，今天我会详细地阐述这部作品的缺点，当然是以我的角度，同时我也不会带有什么负面情绪，我个人其实很喜欢这个系列，二代我也不是那么讨厌，但它的问题确实是露骨的，毕竟太温和往往就意味着圈子的自净能力不够，对一些问题往往就不能看的那么透彻。<br>我之前说了da2是一部赶工明显的作品，有多赶工呢，2077和它相比那都不算事，生软甚至没有给二代一个后缀名……<br>我们先从系统性的问题说起<br>首先作为一个rpg游戏，da2从头到尾（一共三章）几乎一直在重复利用十几个地图，一样的别墅，一样的山洞（还Tm贼亮）等等，这也是所有玩家都承认的一个问题，考虑到14个月的工期，这点可能也是难以避免的，不过这个问题实际上并不止这么简单，因为地图的数量太少，各种任务线又要在不停阶段换来换去，这就给玩家造成了一个两难的问题——如果按任务线推不得不忍受一个又一个重复度极高的地图，如果以最高效率的原则一个地点一个地点地清，又会错失现状的任务叙事，这种矛盾是稀缺的地图造成的，也是da2在叙事上的一个根本性的缺点<br>然后，整个战斗系统可以说在da2迎来了史诗性的大改，或许是制作组没有力气做大规模的技能，所以被官方钦定为法师的霍克技能远远没有一代多，对一个技能你要投至少两个点数进去才能强化到底，更别提一个系的被动build需要投入更多，法师的技能树相比战士盗贼完全没有优势，还有那个攻击动作，法师舞得和金箍棒似的，搞act化不能这么搞啊，怕不是设计师想起自己做《翡翠帝国》（生软以前的东方题材rpg）曾经看过的西游记，把法杖当金箍棒设计……然后是二代的刷兵机制，科克沃是个小城市，但在本作中你可以看到如同下饺子一样天降的敌人杂兵——分批次有顺序地入场，先不说不集结优势兵力在战术上有多不明智，二代的aoe法术是大削过的，我基本上要带两个输出法师才能确保范围伤害足够……<br>然后是Boss战的秘之设计，堆血加流程化战斗，什么意思呢，举个例子，在最后一章有个杀龙的支线，Boss血贼厚，而且打一会它就会飞走留一堆小杂兵，自己在打不到的高台上放冷箭，有一说一，不难打，但确实恶心，我记得贴吧有个最高难度的老哥打了一小时，我估计啊，制作组对赶工做的boss没信心，所以用这种机制来给玩家提供“紧张感”<br>本作队友的战术槽给得更多了，这是个好事，但相应的队友的装备系统反而被砍了（武器能换）也就是当霍克捡到非自己职业的装备时，这就是垃圾，还有本作的dlc装备，又多又杂……steam上的全dlc装备过了100件，而且大多是毕业装备的水平，当然本来装备系统也没什么收集的乐趣，dlc出了应该也是破罐子破摔……<br>当然成功的革新也不是没有，队友的感情线是得到了深化的，高对立和高友好都能得到buff和对应技能树，这有利于玩家不顾及队友好感度地遵循本心去做选择，也增加了build的多样性以及跨职业的连击，不过相应的礼物系统和营地闲聊也砍了……（但我个人还是更喜欢起源的策略性战斗）……<br>随后的一大麻烦就是剧情，da的小格局剧情在魔幻rpg中应该算少见，虽然这种选择多半也是因为无奈，很多玩家或许是因为新奇而觉得这样的叙事很有意思，确实，不能说da2的故事无聊，但是缺点和漏洞也很明显，我们先把剧情大纲给复习一遍。<br>枯潮来袭，叛教法师之子霍克与家人逃难到科克沃，在一次矮人矿坑冒险中发家致富，几年后解决了库纳利人的叛乱成为捍卫者，最终面临圣法矛盾的激烈化，并在安德斯的一次恐怖袭击后解决了发布灭法师环令的圣殿骑士领导者梅疯子，圣法大战的时代就此拉开序幕。<br>只看大纲其实生软的编剧还是有点东西的，有转折，有历史大势，有多方势力的牵扯，看起来很好，是吧，但如果你抛开糟糕的跑任务体验去仔细审视这个故事，你就会发现很难立得住脚。<br>我猜想啊，14个月的工期一给，编剧拍脑子一想，咱做个小格局故事，矛盾层层激化，来点刺激的，然后开始考虑怎么让角色对号入座，为什么这么说呢，因为da2的故事是典型的情节推动型，霍克从始至终跟着情节走，不是说这么不好，不过da2处理得相对不太行，同年的巫师二也是分三章的小格局叙事，但他们着眼点是主角，杰洛特的立场很明确，找老婆顺便寻回过去记忆，政治那是附带的，他被牵着走，被逼着站队，很合理，互相利用嘛；da2有所不同，霍克从始至终都是城里有排面的人物，就是第一章也是和城里卫队小队长有裙带关系的王牌佣兵，他不能一直被动吧，你da招牌式的自由度呢？<br>我们来按顺序捋一下故事线，第一章用一些小任务引出了血法师与激进派圣殿骑士两大毒瘤作为引子其实还行，不过霍克听了瓦里克几句忽悠就要下坑道了略显仓促，当然瓦叔是一代口才点满那种人物，系列里忽悠谁谁信，不过下坑道不带安德斯霍克的弟弟就会死着实是个离谱的安排，奥尔加过后大家应当都知道对一个重要人物的出退场不能那么仓促，但奥尔加死的仓促是因为不这么做编不下去，da2是图什么？沃顿和队友杀了不知道多少暗裔，就没受过伤？怎么就你卡沃毒抗负数，你要说是为了霍克成长也不现实，da这种强调主角就是自己的游戏是不会有主角成长的需要的，只能说这段是真的迷惑，除了让卡沃有机会当沃顿没有任何意义<br>然后进入第二章，这一章的主线是库纳利人线，这段剧情其实写得不错，库纳利人的塑造很有趣，但问题在于二代本就是个内容不足的游戏，着力想展现的圣法之争和库纳利人一点关系也没有，这段想抬升霍克地位的意图实在是明显过头了，再加上一大段剧情给了库纳利人，分散了玩家注意力不说，让圣法大战本就不足的铺垫和描写雪上加霜，当然第二章也有支线，支线讲了什么呢，全讲了血法师是怎么毒害大众的，事实上本作除了第一章有几个法师卖惨，其他的戏份几乎全给了血法师以及安德斯这种激进派，这就导致了一个很搞笑的问题，你说法师不能迫害，但梅疯子一开始也没杀人，你这城市逢一个法师十有八九练血魔法不管你管谁呢？其实圣法之争的核心问题很简单——法师到底多容易堕落，在一代中一个法师用血魔法能屠大半个法环，很危险，但召唤恶魔者本来就是个危险分子，血魔法对他来说只是工具，你要说恶魔诱惑法师有多容易就很难说，同是老血法师的莫姐不就啥事没有，这个问题不挑明，法师的存废很难有定论。<br>我们再来说说全游戏的高潮——第三章，da2的剧情呈现一个很神奇的现象，你要说层层递进那确实是这样，但递进的未免比较太快了，纵观全游戏你基本看不到什么温和派——无论圣法，对编剧来说激进派确实好用啊，超快节奏推剧情，但对玩家就会感到憋屈。全游戏最激进的梅疯子，她疯吧，但面对霍克这个叛教法师之子，公然的血魔法使用者她一点也不刁难你，霍克还有个顶着精灵和血法师双重debuff的梅丽尔，她也不管，霍克既然这么有面子，那联合一下城里的势力反对她不难吧，结果没给选项，更神奇的是圣殿和法师还有有识之士站出来想把梅疯子杀了，这时候编剧又觉得梅疯子真被保守派刀了结局没得放了，于是让这些人绑架了霍克的家人，这也算了，真密会了还有血法师跳出来把温和派圣殿杀了，你们搞秘密集会成员审查就这水平？放进来个血法师不说还在关键时刻内讧，真的可以，事实上你在游戏里遇到的法师不是莫名其妙疯了就是几乎没有塑造，情节推着所有角色在走，再举一个例子，蕾莉安娜这种间谍头子怎么着也是雷厉风行的实战派了吧，科城的局势像在火上烤，教皇把蕾莉安娜这种重量级角色派来，你猜派来做什么，派来劝现任主教快走，那科克沃怎么办呢，蕾妹连句懂得都懂都没和霍克说<br>几边都这么随波逐流，主线怎么推进呢，于是安德斯直接开始搞起来恐怖袭击，不得不说这段真的是异常生硬，安德斯前几章还一副弱受的样子没一点铺垫直接搞恐怖主义了，而且搞完还一副为大义牺牲的样子，问题的根源不解决，法师永远会被歧视，这样的情节有什么意义呢，要在魔幻世界观谈政治本就是件很难圆的事情，更别提生软还处理得这么生硬<br>可能有人会说这样神转折也很震撼啊，但正如我之前说的，奥尔加之死也是神转折，但没有足够铺垫的生硬转折在剧本创作里肯定是要避免的，可以说二代编剧本来应该想写出霍克身为科克沃捍卫者也对历史大势卷携着无能为力的剧本，但实际效果呢，是各路代表不了大势的牛鬼蛇神作死，而我们的霍日天在一边看着准备收拾残局。<br>我一直坚持在文艺创作领域风格和水平要分开看，就比如我知道二代有很多拥护者，但他们可能大部分是喜欢这种以小见大的叙事风格，而不是充满漏洞的叙事水平，da2虽然我说了他的很多缺点，但生软的剧本虽然很难跻身一流，但保持二流水平还是可以的，剧情演出的信息量能淹没很多人对不合理处的关注便是明证。<br>Da2故事上的失败很大部分要归因于赶工和工期的匮乏，这一游戏的大部分问题皆来自于此，至于一个世界观宏大的rpg讲小格局故事是否明智，从后见之明的角度看，da2在作为da3的引子方面还算是成功的，但无可否认da2在设定上根本没什么进展，我们要知道dao在世界观构建上只是刚刚展开，还没到成熟的地步，直接在这种半成品框架下讲故事对完善世界观有所期待的玩家肯定不会满意<br>大部分da2的玩家应该都为这款游戏感到可惜，如果再有一年的时间可能以上的问题能解决个大半，但奈何生软摊上ea这么一个急功近利的老板，而在下一作，生软带给我的就更多是愤怒，而不是惋惜了……to be continued<br>以下是个人的碎碎念<br>一代赶路神技加速术居然砍成限时Buff了,而且这游戏强调同性恋是不是有点过了，安德斯动不动一脸弱受的样子，而且那啥院居然还有不问你性取向直接调情的男妓……这算性骚扰了吧，伊莎贝拉一代可没那么黑啊，这是在海上漂了几十年人种都换了？生软搞zzzq真的由来已久</p>
<h1 id="dai"><a href="#dai" class="headerlink" title="dai"></a>dai</h1><p>今天我们要介绍的这款游戏，于2014年以压倒性优势赢得了tga年度最佳，没有任何一个竞争者是与它同一个量级的，gta5，最后生还者为了避其锋芒不得不选择在13年发售，巫师三被吓得跳票到15年，在得知14年有这款游戏后，宫崎英高慌得只得把黑魂三继续打磨到16年，它就是古往今来最强的rpg游戏——龙腾世纪审判！！！<br>对审判的评价有个很神奇的现象，刚推出的年份似乎风评尚可，但随着时间推移，评价越来越差，这似乎意味着这是一款开创先河的游戏，无论是填充式的开放世界，还是泛滥的政治正确，都在这款14年的游戏中得到了体现，当然我不怀疑生软的目的，毕竟制作组高层就有同性恋，甚至现在看来惨不忍睹的开放世界当初的生软可能真的觉得很好（虽然被第二年的巫师三干碎了）<br>审判在我心中一直是一部很独特的作品，如果你让我说明da系列的优点，一代的优点不胜枚举，二代我至少可以说风格很独特，三代就比较神奇，它的优点，额，藏得比较深<br>那我们不妨就先说说它的优点，审判在世界观和时间上的推进上有巨大的建树，我的意思是，填了几个坑的同时挖了更多的坑，生软在下一盘很大的棋，无论是揭开奥莱斯的帷幕，教会的黑暗过去，亦或是把古代精灵的设定全部推倒，都能让我们感受到生软在剧本上的用心，确实，理论上讲，dai的剧情是很有看头的，但生软把自己的缺点推向台前，把优点深藏幕后，让我在玩的时候频频破防，也是真的厉害<br>我们还是先从系统问题说起，不知道是什么给了制作组勇气，本作的引擎换成了做战地的寒霜，这个引擎对rpg的适配性极差，为了实现存档生软就不得不对其做了大量魔改，乃至系列核心功能的存档继承还要通过一个网站实现（没有中文支持哦），不知道是不是为了照顾主机，即时演算cg还是锁30帧的，配合僵硬的人物动作，让我感觉在看ppt，审判还有一种极为奇妙的油腻效果，你要用在植被景物上我就当做油画风格了，但奈何人物也是这个样子，个个都像青春期几个月不洗脸一样满脸反光，在这里我澄清一下啊，有黑子造谣叫索拉斯“蛋头”，索拉斯什么时候配碰瓷我们鸡蛋了，你家鸡蛋反光到这种程度？<br>审判主打一个开放世界，什么叫开放世界呢，每个地图给你一堆无聊的收集式支线，跑断腿去吧，此外，除了某些装备词条，审判官没有任何提高那慢的像残废一样的移速的手段，偏偏生软还恶趣味地把地图做的很大，收集式支线的收集品路线拉得很长，如果不修改游戏速度，或者有什么特殊癖好我觉得是撑不下去的，顺便一提也基本没有什么像样的奖励，生软不会真的觉得这种任务能留得住玩家吧，就算14年大家还没有被育碧的填充式开放世界搞得审美疲劳，也不会对这种设计甘之若饴吧<br>当然了，也有人反驳，又没有强迫你做，不喜欢大可不做，首先呢，为了推主线总归是要做支线积攒势力点的，其次，这也涉及到游戏设计的一个问题，一个叙事向游戏，最根本的是什么，我认为就是像玩家提供信息，一个优秀的的叙事游戏必须在游玩过程中高密度同时高质量的提供给玩家信息，同时这个过程必须是有导向性的，要将玩家的注意力导向最能给予他们信息的方向，因此任务日志里主线永远要在c位，即使是巫师三这种支线质量领先业界的作品，也有粗制滥造纯跑腿的任务，但这些任务流程不会长，也就是，虽然提供不了什么和世界观塑造或者叙事相关的信息，但由于时间短，这段时间的信息密度并没有低到无法忍受，我们看看dai是怎么处理的，首先支线在基本没有信息量的同时，极度磨叽，当然这也就算了，毕竟不喜欢可以不玩嘛，但制作组自作聪明地把这些制作水平极度粗糙的支线，给塞在了日志里，一打开日志界面就是密密麻麻的0&#x2F;X，我相信但凡是个正常人都会感到烦躁，这就是很失败的一点，它将玩家的注意力导向了最错误的方向，是个极度离谱的设计<br>同样是为了照顾主机，本作的技能栏进一步精简到了8个技能，8个技能，战士和盗贼都没有过这么吃紧的技能栏，你让法师玩什么？虽然是个人喜好问题，但这种革新是不是有点太过分了一点呢？说实话dai我是一点玩法师的欲望也没有，不是说强度有多少削弱，而是策略选择的灵活性没有了，说到策略，本作更迷惑的一点是取消了战术设定，可以说是向即时act全面转进，da系列每代都有极大的革新，我也不知道是图个什么，我们就当是因为商业利益不得不妥协了吧。<br>再说剧情和人设的问题，只看大纲，审判的剧情和一代很像，都是主角临危受命杀死大魔王拯救世界的故事，区别也是有点，审判的格局宏大的多，看得出编剧很有野心，一代的费罗登和仅仅提及过的奥莱斯都是本作的舞台，但问题在于呈现的方式，极度草率，我之前说dai是开放世界，其实这不完全准确，因为只有地图和任务是开放的，能去的地方其实就几个，而且大多是荒郊野外，根本不足以展示末日将临下两国的反应，当然生软也想了个办法，就是决策桌系统，说实话这就是个挂机文字游戏，而且频繁进出还很浪费时间，尽管事件很丰富，但寥寥几语文字提供不了多少信息量，一代通过支线我起码看出了点费罗登人应对枯潮的绝望与恐惧，审判恕我直言，完全没什么感觉，当然我不否认主线的几个大事件做的不错，但相应的小格局叙事的空缺让我感觉到这场灾难的苍白，试想一下，审判团之外判官直接接触过什么组织什么人，没几个，是吧。<br>再说人物，本作的大反派，考爷，不得不说异常苍白，一代的反派洛根虽然傲慢愚蠢但至少性格是有几个侧面的，考爷有什么呢，纯粹的邪恶与野心，其实这样也行，我一向认为刻画人物有两条路，一条是通过各种细节展示其多面性或者成长与突变，一种就是把一个性格特质发挥到极致，比如jojo福音的田最环，就是个坏人，但他诡计多端会演戏，文能严刑逼供心理施压，武能压着吉良和仗助打，这就是把恶这一性格写到极致，但考爷两边都不沾，风头全被我们男判官的好兄弟，女判官的好情人索光头抢走了，真的是惨。<br>反观入侵者dlc可以说才是真的点睛之笔，回过头来想想，几乎整个审判本体都在给这个dlc作铺垫，不得不说这个dlc确实让我感受到了生软最后的实力<br>再说队友，其实dai的队友一直给我一种神奇的疏离感，但本着科学严谨的态度，我思考了好一阵为什么会有这种感觉，在这里和大家分享一下<br>首先是身份上的疏离，一二代的队友都各有各的不同，但总归是人类，精灵，矮人三个基本分类，而且归属上都是费罗登的人，审判就比较神奇，铁牛是库纳利人，科尔是个灵体，其他队友从费罗登奥莱斯两对头，到遥不可及的德凡特，都有，当然这只是最浅显的一点，但身份的疏离明显加大了队友间的隔阂<br>其次，考虑一下一二代与三代主角的不同，一二代都是有所谓初始剧情的，因此他们都有自己的死忠与初始势力，一代的沃顿初始有同事A哥和受了母亲命令的莫姐两大死忠才开始招募队友的旅程，二代的霍克不仅有弟弟&#x2F;妹妹还有艾芙琳的支持，更重要的是，加入的队友大部分是孤家寡人，都是孤身投奔梁山的类型，而审判就不同了，初始就有自己势力的卡姐，率部投奔的萨拉，间谍铁牛，法师领袖薇薇安，瓦里克还是霍克的死忠（十年老交情不可能完全站在判官这边）导致判官严格来说甚至没有可以信任的亲信，相反，还要应付各怀异心的队友<br>最后，对于角色的塑造来说，一共有三个过程，不成熟，成熟，升华，举例来说，一代鲜有不成熟的角色，成熟的利己人格莫姐最后接纳了爱情这是对其人设的升华，成熟的温奶最后决定牺牲自己造福世人，这也是一种升华，一代是不缺少有自己成熟价值观的人物的，看着傻白甜的蕾妹实际上早就身经百战了，而三代不成熟人格就多起来了，卡姐看着霸气，实际上被瓦里克骗了很久，而且天真的没有意识到圣殿骑士膨胀的权力必然导致的对法师的压迫，科尔更不必说，黑墙直到赎罪后才形成了成熟的人格<br>再说一些其他方面的问题，我是指，政治正确，不知何时起gayware的游戏已经成了同性恋人群的狂欢处了，在尊重同性恋的同时我能请生软尊重一下异性恋吗，队友里能推的只有卡姐？生软塑造女性角色的功底可以说在倒退了，相反的，光头倒颇有一代莫姐的风采，然后是黑人姐姐薇薇安，据我所知龙腾世纪并没有任何关于人种肤色的设定，但我们的薇薇安姐姐就这么不羁地出现在我们眼前，似乎不认为自己在满世界的白皮人中有任何特殊之处，更神奇的是这位姐姐的人设还是交际高手，我很好奇奥莱死的权贵们难道真能把薇薇安当同族看待？据我所知一个明显与交际圈所有人都不同的人，被排挤才是正常操作吧，而我们的薇薇安姐，不仅顶着异于常人的肤色，还有着其貌不扬的一张脸，能成为帝国圈内炙手可热的交际花也是相当励志了。顺便一提，有人说叠buff拿年度最佳是美末二首创，其实是dai玩剩下的，从这点看可以说是非常有创造性的一作了<br>总的来说，虽然定位上dai是一部中兴之作，但这部作品在最底层的设计逻辑上存在很大的问题，整个路都走错了，如果生软把做开放地图和低质量支线的精力拿来做出一代那种不乏少数有趣支线的线性地图，把决策桌换成各种小任务，那么呈现出的效果必然会好很多，同时，恼人的政治正确，油光满面的建模，浮夸的网游式特效，让审判在外观上都显得不讨喜，我由衷的希望da4里生软能认清自己，摆脱这些乱七八糟的问题。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>龙腾世纪</tag>
      </tags>
  </entry>
  <entry>
    <title>被所有人遗忘的故事，巫师二之殇</title>
    <url>/2023/09/30/%E5%B7%AB%E5%B8%88%E4%BA%8C/</url>
    <content><![CDATA[<p>熟悉我的朋友都知道，我本人是巫师系列的死忠，如果让我给rpg游戏做一个排行，我会把巫师放在第一位，有的人可能会说，巫师固然是rpg佳作，但在浩如烟海，名作辈出的rpg里可未必排的上号，又有的人可能会说，说这么多不过是“情怀党”的矫情而已。</p>
<span id="more"></span>
<p>不错，巫师系列对我来说不只是一个游戏，如果说每个人最大的爱好都有一个启蒙物，那么可以说正是巫师，将我带进了那些着重于叙事的游戏的坑。不过与大部分人不同的是，我初次接触巫师系列是巫师的二代。<br>那是一个普通的暑假，我费力地思考着，家里残破的笔记本电脑到底能玩点什么游戏，这时我突然想到，听说有个叫巫师三的游戏挺有名，我不如试试它的前作好了。就这样我搜到了巫师一二，巫师一画面陈旧，操作蹩脚，我毫不犹豫地排除了它，但二代却有着在那个年代来说不错的画质，于是我找到了它的资源，试着玩了起来。<br>听到这里可能大家觉得我无非在说一些陈词滥调，但我想说的是，巫师二即使以我现在不知道涨了多少的阅历来看，依旧是一款特立独行的游戏。在此之前我也玩过不少游戏，但我从来没有见过一个没有政治诉求纯粹为了自己的利益行动的主角，我从来没有见过一个每个人都栩栩如生，有自己行事逻辑的世界，我从来都没有见过，一个以阴暗的政治冲突，种族歧视为背景的游戏，即使以rpg来说，巫师二也是个很有勇气的游戏，在巫师二不长的序章过后，就会面临两个截然不同的分歧，并且这两条分支路线的重复内容并不多，如此大的分支毫无疑问是不多见的。现在回想起来，巫师二可能是我唯一一个一点也没有碰支线的rpg游戏，固然因为当时我懵懂无知，但其波澜壮阔的主线确实无比吸引我，<br>是的，这是一个非常有突破性的游戏，可谓是cdpr写政治戏码的巅峰，但是，很神奇的是，这又是一个被遗忘的游戏，不仅是被引流来的巫师三玩家遗忘，就连cdpr好像也忘了它，巫师三和二代基本没有什么关系，可能有人会反驳我，巫师三的开头就要模拟二代抉择，但事实上，对一个强调选择的rpg游戏来说，重要的不仅是选择，更是选择带来的后果，而巫师二那些惊心动魄的选择，在三代中几乎都成了定局，无论上亚甸是否赢得了独立，最后的区别不过是沦陷在亨赛特的军队下还是尼弗嘉德军队下而已。无论是否救回泰莫利亚最后的王室血脉，罗契都只能带着他的兄弟们再度流亡。更神奇的是二代最成功的女性角色，龙女居然不知所踪，事实上龙女和伊欧菲斯在巫师三曾有过一个现在沦为废案的任务，但因为赶工期被砍掉了。我们对比一下同样三部曲的龙腾世纪，一代的诸多队友都会在二代亮相，甚至还能在三代中当重要角色。而巫师三部间的关联则少得可怜，一代的女主角夏妮在石之心才出场，也就雷索与罗契在三代的戏份多一点，这无疑大大削弱了巫师中选择的分量。当然，我也能理解cdpr，三代是系列中唯一重启主线的一部，与更像外传的一二部有着极大的区别，并且这一作有着不小的制作规模，必须放弃前作壁垒，放低身段吸引新玩家，种种考量下，三代注定是相对独立的一作，更何况在二代一番精心算计下，事线固然优秀，但已经形成了逻辑闭环，也很难找到延续的办法。而三代为了种种考量，强行让南北形成均势，更破坏了延续巫师二剧情的可能性，尽管可惜，但巫师二作为一个完整的故事，也可以称得上优秀。<br>接下来我们就来讨论一下一款游戏。<br>首先，依照惯例，巫师二的系统，巫师二的画面在当年算得上不错，但毕竟此时的cdpr并没有太大经验，因此整部游戏的一些地方仍然显得很生涩，比如说，巫师二是没有跳跃功能的，只能让玩家去寻找攀爬点才能上下移动，而这些攀爬点则都做的很隐蔽，配合拙劣的导路功能，跑图体验难言理想，随后巫师二的战斗相比巫师三繁琐不少，同样分为三种流派，近战，炼金和法印，法印有单独的储备槽，能随着时间恢复，这点有点像dnd，近战则有和三代近似华丽但破绽很大的剑术，并且翻滚是没有无敌帧的，也就是说翻滚途中被攻击打断是常用的事。药剂和炸弹都是一次性用品，众所周知，rpg游戏的一次性用品就是不打最终boss能不用就不用的东西，因此虽然炼金流算得上强力，但由于合成的琐碎以及造价昂贵，走这条线的并不算多。总的来说巫师的战斗系统基本都是在及格线上徘徊的水平，实在没有多少意思。<br>而论起剧情，就很有的说了<br>巫师二的叙事有什么特点呢？<br>第一，选择<br>巫师二依旧采取了巫师系列道德困境式的抉择，有不少人批评说这种列车难题式的道德抉择千篇一律，然而，我很好奇的是，他们指望在一个商业游戏里看到怎么样的抉择设定呢？巫师的抉择可能算不上精巧，但在rpg可以说是独树一帜的有分量，重要人物的生死，一个王国的命运，巫师二充斥着各种意义上的抉择，甚至包括第二章两个截然不同的路线。放眼整个rpg史，我敢说有如此大主线分歧的也是寥寥无几，而这样独特的设计，其实与巫师二的剧情结构有不少关系。<br>第二，双线叙事<br>我们的杰洛特一向对政治敬而远之，而巫师二构思巧妙之处在于，让一个对政治最没有兴趣的人成了北境局势的关键人物，在游戏中，双线并进的结构被广泛的运用。杰洛特的态度是模糊的，归根到底他不过是想洗脱罪名并寻回自己的记忆，这两大主线目标，前者为主线后者为暗线，都被牵扯到了同一个人身上——雷索。而对于雷索的刺杀行动而言，女术士集会所的阴谋浮现在明处，而隐藏最深的则是尼弗伽德入侵的阴谋。对于游戏中涉及的北境势力而言，两大对抗者，上亚甸和科德温，杰洛特在游戏中任选其一作为明线，另一方便会成为暗线穿插其中。几条剧情路线互相交叉，且彼此间都有说不清道不明的关系，可以说巫师二颇有些戏剧的风格，重要人物算不上多，但却有着极为复杂的人物关系，整个故事都十分耐人寻味。<br>第三，演出水平<br>巫师在剧情演出上向来不遗余力，这点倒是颇有生软的师传，巫师二增强版的开场cg对一个11年的游戏来说可以说无比华丽，而在随后的剧情中，也有不少制作不错的cg的即时演出，更有趣的是，不知道是不是为了赶时髦，巫师二还做了两个系列中少有的巨型boss战，在11年来说，这样的演出效果可以说相当不错了，说到这里不得不佩服cdpr的勇气，只做过一部巫师一就敢砸这么多钱到一个前景不明的项目去。<br>第四，政治阴谋<br>大部分宫廷政治故事都是肮脏的，巫师二也不例外，开篇我们就能看到为了自己和妹妹的私生子发动王国内战的妹控王，要说这妹控王也是个有勇有谋之辈，但把自己荒淫无度的行径公开到整个国家民众面前的行为，着实是让人叹为观止。如果你觉得这已经很毁三观了，那么我可以负责任地告诉你说，福尔泰斯特在北境执政者里是道德楷模级别的存在，整部游戏里你碰到的政治家，浮港的总督是个没有下限的人渣，亨赛特是个粗暴蛮横的野心家，此时看上去正常的拉多维德对待自己的恩师也是“无微不至”，就连浓眉大眼的斯坦尼斯王子，都能为了上位一脸坦荡地毒害龙女。<br>当然了，也有萨奇亚这种浑身坦荡的完美领袖，上亚甸是巫师中难得直接描写非人种族抗争的一段剧情，十分正能量和主旋律，算是难得地调剂了巫师阴暗冷酷的风格，巫师对“义军”的描写并没有落入俗套，龙女一身正气但是并不迂腐，伊欧菲斯虽然仇恨人类，但并不是不择手段之辈，他会对萨奇亚动心，会对救了他的命的杰洛特予以回报，矮人往往看上去豪放，却不失狡诈和算计，而义军中也有斯坦尼斯王子和菲丽芭这种野心家。Cdpr对上亚甸线是很上了些功夫的，多种族混杂的特点被个性迥异的npc完美地体现了出来。可以说，在有政治戏码的rpg中，巫师二绝对是一部水准上的作品。<br>稍微扯开一点话题，巫师二的最终boss雷索，我个人认为是rpg游戏设计得最成功的反派人物之一，雷索的人物志在b站就有，在此不做赘述，纵观其生平，不得不说无论是公事还是私德上，雷索都是一个近乎完美的角色，公事上为了复兴自己的学派，雷索完美执行了恩希尔大帝的命令，他的刺杀行动无不是计划周详，下手果断，善后的处理的也无可挑剔，甚至面对女术士集会所的谋划，将计就计把北境的大部分术士架上了火刑架，要知道，让术士吃这种大亏，这恐怕是猎魔人历史上都没几个人能做的壮举，更可贵的是雷索在做这些事的时候完全秉持公事公办，各为其主的态度，他没有因为杰洛特是福尔泰斯特的护卫就下手迟疑，也没有把自己兄弟的死记在杰洛特头上，他始终清楚地认识到自己不过是尼弗伽德的一把刀这个事实，即使三代中被恩希尔背刺了一刀，也很难说他会有多么吃惊，而在私德方面，为了答谢杰洛特的救命之恩，他跟着杰洛特去迎战几乎没有胜机的狂猎大军，保护叶奈法，甚至在最后把特莉丝从大屠杀中救了出来，而在整场游戏中，他一次也没有对杰洛特下死手。这种文能算计整个北境的术士，武能压制失忆期杰洛特的全能型人才，实在是比工具人白狼不知道高到哪里去了。可能每个巫师系列的粉丝都对巫师四有自己的想法，不过如果是我的话，我是很希望能有以雷索为主角的一部游戏，这个人设实在是太强了。<br>上述是我个人认为巫师二的优点，不过如果你要问我有没有缺点，那我也可以很明确的说，有的，而且还很明显，并且这个缺点贯穿了整个巫师系列。<br>我们知道，rpg的意思就是角色扮演游戏，意思就是可以让玩家扮演一个虚拟角色在一个虚拟世界中做出种种行为，巫师系列是21世纪rpg的一大系列，但巫师却并不是一个完全标准的rpg，为什么呢？因为杰洛特是有性格的，杰洛特大体的性格是，外冷内热，自尊心强，外表冷酷无情，内心深处其实是一个傲娇老好人，这样问题就来了，你杰洛特都有性格了，那玩家怎么做选择，cdpr的回答是，尽量把所有选择都做成两难式的，即使是杰洛特本人来选也会犹豫的那种，这也是为什么cdpr总是喜欢这种两难抉择的原因，但还有问题，总有一些真正的杰洛特不会犹豫的选择，比如说真正的杰洛特必然是椰奶的舔狗，而面对这种选择，玩家只能扮演自己，这就让巫师的剧情流程也有了一种割裂感，你是要扮演杰洛特还是扮演自己，这是在你打开巫师游戏前要先做出的选择。当然，两种选择都无可厚非，但这也必然会造成一些矛盾性的情况，像巫师二里，无论哪条线路，不去救特莉丝都会都会对游戏的重要角色大有益处，作为玩家，如果你查了攻略，你就会知道好兄弟雷索会帮你把萌特救出来，然而如果真让杰洛特选他绝对不会放弃自己的情人，也就意味着，要么玩家放弃选择权，要么就要忍受杰洛特的ooc（人设崩塌）。<br>我个人觉得这是个不大不小的问题，只要做好心理准备还是能忍受的，毕竟一个小说改游戏，碰到这种问题也是难免的，cdpr其实已经把平衡性做的挺好了，没必要太苛求。额，如果这也算孝子那就算吧，不狡辩。<br>回过头去看，巫师二确实是一部难得的rpg佳作，但它未必是一个合格的承上启下之作，巫师二讲了一个太过精彩的故事，导致接下来不怎么好编了，尼国平推北方顺理成章却很无趣，北方反攻又是天方夜谭，导致巫师三的政治形势显得十分强行，迪胖和拉多维德其实都像开了挂一样，要知道，历史是没有个人英雄主义的，区区一个统治者就能逆转尼弗伽德和北方天堑一般的差距吗？这多少有点机械降神了。这么说来巫师二某种意义上近乎把故事讲死了，不过如果我是cdpr估计也会很无奈，小说基本已经写到恩希尔大帝快一统天下的地步了，巫师由于以杰洛特这种政治无关人士作为主角，搞点宫廷刺杀已经是政治戏的极限了，还能怎么编呢？<br>写到这突然想到，巫师三里曾经对雷索喊打喊杀的杰洛特也成了“国王刺客”，这可真是，人终将活成自己最讨厌的样子。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>巫师二</tag>
      </tags>
  </entry>
  <entry>
    <title>影子工厂</title>
    <url>/2023/09/30/%E5%BD%B1%E5%AD%90%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<p>我本以为影子工厂会如简介说的一样，会是杂糅诸多风格的悬疑风，故事的一开始也的确如此，时间穿越配合豪宅血腥谋杀的经典模式别有一番风味，不过结合前传一贯的发展，不难想象出而在这之后又回到了我们熟悉的时间轴环节，比较特殊的是，这次高瞰老师罕见地采用了正叙的方式，而且此次的故事出奇的平淡，尽管感情上依旧无比细腻，但几乎没有什么出乎意料地发展。</p>
<span id="more"></span>
<p>而事实上，高瞰老师擅长的叙事诡计只是换了一种方式呈现在我们面前，这是一个一位身患绝症的女性在生活和事业中苦苦挣扎，在经历了孩子的夭折后，最后选择了事业的故事，尽管这个故事占了整部游戏大半的流程，但其实它本身并不是重点，因为在开头，影子工厂的主线就被堂而皇之地摆在了我们的面前，豪宅层出不穷的死亡案件，于是，在历览了女主的人生后，真相的追寻才真正开始，当然了，故事如何这里就不赘述了。<br>当然，相比前两作选材的独特，和层出不穷的叙事诡计，影子工厂显得平淡的多，正如lynri所说，昆西相比两位博士不过是一个观察者而已，他对于挚爱的lynri无能为力，面对自己不过是模拟的数据也无能为力，他的一生没有什么狂乱幻想，也没有多么丰富的内心世界，尽管他的内心是强大的，不过依旧没有什么意思。当昆西历览lynri的记忆时，我们会发现相比博士的聒噪，大部分时候他不过沉默地接受着，评价这一环节是在这段记忆中缺少的。而让这段记忆，一个不是最重要的故事占据叙事的大部分是可以的，但问题在于这一部分必须要穿插主线，否则会产生严重的割裂感，而就影子工厂来说，很难说这一部分和主线有着多大的关系，是否手术的分歧导致了之后的一切，但要拼凑出真相，我们需要知道的除了这个世界不是真实的以外，还有分歧点在于保大还是保小，以及lynri的姓氏，而这两点都没有结合进这个过程。抛开叙事结构，如果我们只看这个故事本身，昆西的爱情故事虽然不能说不好，但比起前作的惊艳未免显得俗套。可以说，如果把这个故事大刀阔斧地砍几笔，也不会有多大的差别，当然，就故事的首尾而言依旧是很有趣的。<br>不过即便如此，我也要说影子工厂是一部水准上的作品，它有着层层递归的脑洞，优秀的人物塑造，最重要的是，它还展示了高瞰老师填坑的一点点意愿，虽然到最后我们也不会知道两位博士之后到底会怎么发展。而对于系列中虽然重要但没有认真探讨过的记忆编辑技术，影子工厂也表明了一种态度，就是尽管这可能看上去虚无的，但就我们个人所及的知识与眼见来看，只有有过美好的时刻，它就是有意义的，这是一种积极向上的态度，尽管这只是一种态度，但对于虚无与否的讨论大部分时候都只能取决于我们的态度。能以合适的形式传达出这样的观点，就是一部很好的作品了。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>影子工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏互动性的新探索——步行模拟器</title>
    <url>/2023/09/30/%E6%AD%A5%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8/</url>
    <content><![CDATA[<p>步行模拟器，在本视频中取操作只局限于步行和一些简单动作，主要获取信息的途径为阅读和观察的游戏，这是一种颇为先锋，也颇为小众的游戏类型，在其中有一些火到出圈的佳作，也有缺点明细的庸作，但都有着共性在其中，今天，我就用一个业余爱好者的身份来浅析一下这类游戏。</p>
<span id="more"></span>
<p>我们先从步行模拟器的历史说起，由于我不是专业人士，也不是什么老玩家，所以只能大概地说说。<br>溯及这类游戏的根源是一件很难且没有必要的事情，所以我们只把目光放在本世纪好了，在2007年，一个传奇的年份，当时的游戏界见证了巫师一，质量效应一，刺客信条一等传奇系列首作的诞生，也有一些人注意到一款名为《亲爱的艾斯特》的奇异游戏，对一个原教旨主义者来说它可能算不上游戏，玩家操控着一位失去妻子的男人在孤岛上步行，整部游戏唯一的信息来源就是沿途的风景，壁画，以及男人的自言自语，某种意义上这带来了一种推理小说式的体验，你需要在文本中领略事件的来龙去脉，同时体验它压抑深沉的环境氛围。<br>亲爱的艾斯特取得了意想不到的小范围成功，本作为免费游戏的它在12年发布了付费版，并取得了80万的销量，可以说，近十年的步行模拟器很大程度上是由它启蒙的。<br>因此，以12年为分水岭，逐渐涌现出不少的步行模拟器游戏。<br>13年亮相的是著名的meta游戏史丹利的寓言和较为平庸的到家（gone home）<br>14年问世的是解密风的伊森卡特的消失<br>15年艾斯特的工作室发行了同类型的万众狂欢<br>16年则有看火人与弗吉尼亚出现<br>而在17年，此类型的集大成者，艾迪芬奇的记忆横空出世，成为了此类型至今为止的最优者<br>可能不少对此类游戏毫无兴趣的玩家会好奇，步行模拟器的卖点到底在哪?<br>在这个媒体资源空前丰富的时代，每个人都能输出自己的思想，因此思想的输出变得极为廉价，而接受者的地位却会被拔高，因此，门槛越高的思想输出方式就有着越大的不被接受的风险，导致晦涩隐喻的内容就会不受待见。尽管如此，这些晦涩的思想与表达依旧是存在的，步行模拟器就是一种方式。<br>事实上，接受他人的思想表达一直都有很大的风险，只要作者多加一点私货，或者在莫名其妙的地方整个活，接受者的思想就会收到极大的冲击，例子我就不举了，懂得都懂。所以很多人都会倾向于不去接受，晦涩的作品他们根本不会碰，也有的人沉迷于此类快感，不顾风险地追寻自己认为好的输出者，这两种选择没有高下之分，但体现在游戏上，我们就会发现后者经常会成为所谓的小众游戏爱好者，这并不意味着他们很优越，相反，他们可能已经踩过不知道多少雷了。<br>为此前的论述做一个总结，步行模拟器可以作为一个高门槛的思想输出方法，因此能吸引一些喜欢此类体验的玩家。事实上，它和同样强调探索的avg可能存在一些关系，但由于我对此没有足够的知识，就不献丑了。<br>在此基础上，我们来分析此类游戏的一些特性。<br>首先，第一个问题是，为什么要用步行模拟器这种形式，毫无疑问这种游戏的互动性基本不是很强，也没有刺激官能的要素，然而，正是因为这种自断一臂式的操作，让它能够把自己的叙事能力提高到大部分游戏所不能及的程度，玩法单一也就意味着玩家的注意力会完全集中于一点，制作者只要专注于此方面，就能高频度地向玩家提供信息，而不会让人一头雾水，因为这样的特点，相比大部分游戏，步行模拟器可以聚焦于很多与众不同的题材，可以选用不同的叙事方式，<br>另一个优点是，较小的游戏规模与如今相对成熟的游戏工业，让制作者能以较为低廉的成本做出不同的场景，美术效果和环境在步行模拟器中有很大的作用，我之所以这么说，不仅是因为它有着渲染气氛的作用，在很多此类游戏中，环境本身就承担着叙事的任务，尤其以艾迪芬奇的记忆而言，环境在这款游戏中达到了当代游戏的新高度，不同的房间布置在无言中传达了房间主人的个性，甚至在一些细节中暗示了主人的命运。可以这么说，在很多步行模拟器中，环境有着超越装饰的作用<br>步行模拟器还有一个特点，那就是它是第一人称的，你可能单纯地觉得这是为了提高代入感，但事实上，因为互动性的匮乏，步行模拟器往往更趋向于探索和体验，而不是扮演，更形象的说法是，在步行模拟器中看到的是别人的故事，因此在我看来，第一人称更多的意义是类似侦探小说的叙述主体，也就是说，以这个故事而言，第一人称对应的角色就是最适合展现故事全貌的人，同时，这个主体具体的身份也可以是一个谜题，伊森卡特的消失，艾迪芬奇的记忆都在这方面上做了文章，非常有趣。<br>上述特点事实上还是很笼统的，实际上的步行模拟器在风格和题材上都是各具特色，特点也不尽相同，但由于到目前为止出名的步行模拟器实在不多，所以我们就用穷举的方法来说说这些步行模拟器。<br>先从最早的亲爱的艾斯特说起<br>在所有步行模拟器中，艾斯特应该是互动性最低的一个，你能做的只有控制一个喃喃自语的男人在孤岛上乱走，然而，艾斯特依然是一部很优秀的游戏，优秀的文本质量和环境建模完美地融合在了一起，配合迷雾重重的故事，与四个风格迥异的场景与种种细节，成功营造出了一种哀伤中透着迷幻的气氛。虽然选取了悼念亡妻的题材，但艾斯特并没有直接表现哀伤，叙事主体的男子呈现的态度是思辨的，其文本很有些深度，艾斯特的氛围塑造与文本水平，我个人认为是步行模拟器中最优秀的之一，并没有被后来者超越，甚至也没有被他们自己超越。<br>史丹利的寓言<br>这游戏很难归类，它更为众人所熟悉的标签是meta游戏，举个不恰当的例子，meta游戏和游戏的区别就像文学批评和文学的区别，很难说史丹利的目的是对游戏这一创作形式进行批判还是呈现一段故事。<br>这游戏几乎是靠作者一个人的天才撑起来的，即便在meta游戏中有史丹利寓言这么强烈批判属性的游戏，据我所知也是不存在的，它很有创设性的给予了游戏四个视角两个阵营，呈现者阵营的游戏系统（游戏作者？）与旁白，接受者阵营的史丹利与玩家本人，史丹利的故事几乎都是两个阵营间不同角色的互动，它实现了大部分游戏都做不到的一点，即让玩家直接与游戏的底层逻辑对话。<br>现代游戏互动性的本质是什么，无非不过是选择而已，拟真度高的游戏也不过是多提供了一些选项，史丹利抓住了这个底层逻辑，因此哪怕是步行模拟器这一形式只要用好“选择”，就不会缺少互动性。<br>这样的策略让史丹利显得不是那么“步行模拟器”，但实际上这还是一部叙事游戏，只不过它的故事千变万化，且富有批判意味，而且它的叙事有着“选择”的成分，因此它包含了十几个不同的故事。<br>归家<br>归家是一部很有实验意义的作品，如果你情商比较高的话，应该就知道我的意思是这游戏有着不少的缺点，归家的故事发生在20世纪末的一个美国家庭，一个暴风雨之夜，家中的姐姐回到家中，发现妹妹离家出走，于是开始寻找原因，归家的核心机制是拾取&#x2F;查看物体触发回忆，核心谜题则是揭开妹妹的下落，然而这游戏的故事非常简单，简单到什么程度呢？在触发前三个回忆后你基本上就能猜到故事的梗概了——没错，一个俗套的恋爱被父母反对然后私奔的故事，稍微有些不同的是，主角是两位女同性恋，此外，游戏中有一些不怎么明显的机关且缺乏提示的机关，总体感觉实在是索然无味，尽管某种意义上它为有核心谜题的步行模拟器树了一个榜样，但论其素质十分乏善可陈，最大的优点可能是还算有20世纪风格的家居布置。<br>值得一提的是ign给了归家9.5的超高分，对ign来说这种分数是很少见的，我们之前提到的艾斯特得到了8分，史丹利寓言得到了8.8分，而品质平平的到家则得到了9.5分的超高评价，并且编辑的评论是没有缺点，联系其故事题材，此件原因令人深思，因为涉及敏感话题，我就不多说了<br>伊森卡特的消失<br>这是一部很有风格的作品，在场景建模上制作组创作性的采用了结合实景照片的做法，因此画质显得极为真实，配合微恐怖的风格，代入感极强，游戏的内容是一个有着回溯犯罪现场能力的侦探应伊斯卡特的邀请调查一个据说有着不可名状怪物的地区的系列凶杀案，抛开几乎为0的地图指引，游玩过程中你会觉得这似乎就是一个普通的解谜游戏，虽有称道之处，但综合来看质量一般，然而，这款游戏最值得称道的一点是，制作组为了一个有极大反转的结局在流程中埋了不少伏笔，因此伊森卡特的结局在我看来在叙事游戏中算最优秀的一档，当然实际上这也是见仁见智的一件事，或许也有不少人觉得铺垫不足。<br>在步行模拟器中悬疑风格的作品伊斯卡特应该可以说是最成功的。<br>万众狂欢<br>这是一部和亲爱的艾斯特风格迥异的作品，它没有叙事主体，玩家以超然的眼光去回顾一座村庄全员蒸发的惨剧，我认为这是一部失败的作品，为什么呢。作为一个拼凑出故事全貌的游戏，万众狂欢很不幸的选择了把最大的悬念放在开头——凶手是形似光球的不可名状生物，而游戏的过程则是目睹居民怎么一步步迈向死亡，整个过程中的互动，只有不如不做的触发回忆过程有——跟着手柄按QTE。具体到故事，恕我直言是很无聊的，寥寥几语的场景中大部分缺少让人身临其境的氛围营造，整部游戏有着浓郁的宗教风格，因此部分场景会有种神圣感，但也就仅此而已了，没有悬念，没有细腻的情感，没有复杂精彩的故事，更没有氛围的营造，万众狂欢在我看来是一部平庸的游戏<br>看火人<br>在众多步行模拟器中，看火人是极其冷门的纯写实题材，它选取了森林看护员这一冷门的职业视角来叙述故事，然而它的美术风格却是抽象的大色块风格，这造就了看火人实中有虚的奇妙质感，不论看火人的故事如何，这样的题材与美术创新是优秀的且值得鼓励的。<br>主角亨利在爱妻患病后心灰意冷，因为酗酒被妻子家人排挤的他最后来到了荒无人烟的森林公园成为了火情瞭望员，我们可以看到，游戏的主题几乎已经确定为心灵的救赎，但看火人的呈现方式是特别的，因为职业的特殊性，从始至终能与亨利交流的只有一位名为黛利拉的女性，在一片孤独的瞭望塔中这似乎是亨利唯一的情感支柱，事实上，看火人最大的优点就是情感的细腻，整个游戏几乎就是亨利与黛利拉互相的情感激励与救赎，最后这场类似柏拉图之恋的关系随着因为火情观察员撤离而收尾。<br>值得一提的是，看火人神奇的在游戏中夹杂了不少悬疑的成分，这让看火人的基调显得有些奇怪，由一开始的悠闲巡逻转到紧张的解密，随后又在急转直下后收尾，尽管不算无聊，但前后依旧有割裂感。<br>尽管如此，凭借细腻的情感描写，看火人依旧是一部优秀的游戏。<br>弗吉尼亚<br>这是一款很奇特的游戏，即使在步行模拟器里，它也是交互性最差的一类，它使用了一种极为抽象的风格，整个游戏由很多不明所以，充斥着象征的片段组成，而将这些片段串联到一起不过是一些点触的操作，坦白的说，我只能分离地去欣赏这些场景，单从象征的角度来说这些场景单独拿出来还挺有意思的，但你很难把这些片段连起来，事实上不让你把他们连起来可能正是这游戏的目的，此外，该游戏使用了很罕见的古典风格配乐，配合上本就很魔幻的内容产生了一种难以言喻的奇特的氛围。总的来说，这真的是一个很难评价的游戏，如果你有些猎奇心的话倒可以尝试一下<br>艾迪芬奇的记忆<br>艾迪芬奇的记忆是一款很优秀的游戏，但它的意义不仅如此，可以说在对互动性的新尝试方面，艾迪芬奇是游戏界最前沿的一个，游戏在叙事上最大的优势就是互动性，大部分游戏选择了剧情分支，qte之类的通解，而艾迪芬奇的记忆则在此基础上作出了创新，单论最简单的字幕，往往只被放置在屏幕底部用于阐释信息，而艾迪芬奇则将它放置在了场景之中，伴随着主角的前进逐渐浮现在路边，如此一来字幕甚至兼任了指引的作用。<br>依我看来，艾迪芬奇的主基调可以用魔幻二字来概括。随着艾迪依次探索旧宅，我们进入了一个个家族成员死前的景象中，但我们透过屏幕看到的不仅仅是一个个纪录片式的景象，还有情绪的具象化，例如令人啧啧称奇的操纵漫画中的角色一段，操纵角色在悬疑漫画的分镜中行走，这是一种崭新且绝妙的传递恐惧感的方式，艾迪芬奇的互动形式总是新颖的，角色伴随着开罐头喃喃自语，在切鱼的流水线上展开与工作融为一体的幻想，手柄的两遥感分别控制现实与幻想世界，此类新颖的设想，艾迪芬奇有近十种，可以这是一款极为奢侈的堆砌创意的游戏。<br>艾迪芬奇的家族大都耽于幻想，他们的幻想往往与现实融为一体，以此呈现出的情景显得分外的魔幻，以游戏的形式来叙述这样的故事，这一模式提供了一种特别的审视真实世界与内心世界的视角，这样类似魔幻现实主义的创作手法可以说极为前卫和有趣。<br>毫无疑问艾迪芬奇的互动性与创意是它最耀眼的闪光点，在此的映衬下，艾迪芬奇的剧情似乎显得暧昧不清，多个家庭成员的死亡都没有得到明确交代，尽管在一个个情景中我们能在画面中感知到情绪的具象化，尽管艾迪芬奇家族一向有着早死的诅咒，但艾迪芬奇没有，至少没有直接透露任何家庭成员对于死亡的看法，在一部探讨死亡的作品中这点显得很奇怪，似乎它只想将死亡本身呈现出来，却不想对此发表任何议论，我们很难说艾迪芬奇有什么主旨，在死亡这个主题上，制作组显得分外的冷漠，只留下玩家在原地回味。Steam上艾迪芬奇的商店页面有这样一句差评，艾迪芬奇的记忆有着美化死亡的嫌疑，这对那些有自杀倾向的人来说似乎太不友好了。这并不是没有道理。<br>总结<br>步行模拟器始终是个小众的品类，它固然有着一些创作上的优点，但成本和受众的因素始终制约着这一类型，导致作品寥寥无几，但在步行模拟器其实不乏对游戏这一创作形式的革新，作为新时代的叙事向avg游戏与独立游戏的一大阵营，步行模拟器的身上其实或多或少蕴含着电子游戏未来的一大方向，即作为有才能的作者表达自己的一种方式，对此我报以极大的期待。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>步行模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>不予播出——极端意识形态大乱斗</title>
    <url>/2023/09/30/%E4%B8%8D%E4%BA%88%E6%92%AD%E5%87%BA/</url>
    <content><![CDATA[<p>吉姆哈克：当一个国家走在下坡路上，必须有一个给它踩一脚油门。<br>你生活在一个贫富差距分化严重，外部国家敌意渐升的民主国家，而在此危难关头，一个名为先进党的政党，凭借集体主义的价值观，以及消灭富人扶持穷人的竞选纲领上了台，时代变换的帷幕在你面前缓缓拉开，这时，你能做什么呢？</p>
<span id="more"></span>
<p>这大概就是不予播出想呈现的故事，这个游戏是我认为近年zz题材最出彩的一部独立游戏。<br>我们先从游戏的形式说起<br>它选取了一个很少见的视角——电视台导播，也就是在电视内容被播放前负责镜头切换与简单后期音效处理的一个职位，这是一个虽然默默无名却十分重要的职位，制作组对此的选择非常高明，在这个位置上你能接收到一切媒体信息，同时决定哪些内容会被最后播出。<br>游戏的背景设定是魔改版的80年代英国，想想就知道在这个电视台的黄金时代这个职位意味着什么。<br>在我们这个娱乐至死的年代，恐怕我们的印象中很难会有什么凭良心的办事的媒体人，但在游戏中，随着举足轻重的影响力而来的同样还有巨大的责任，我们可以看到游戏的封面是一个被操控的提线木偶端坐于导播台前，这似乎预示着你不过是政党口中的喉舌，事实上，面对zz大势，大部分时候你确实是无力的，但总有一些事是你可以做的。游戏中，你能做的包括切换各种机位设置，添加后期音效这些普通的工作，你也可以转而接收反对党的信号，甚至在暗中支持他们。<br>可以说这样的玩法绝对算不上丰富，但是，为了这些内容制作组拍摄了极为大量的采访，节目，等等实景拍摄，这些作品的文案，演出水平都极为突出，也就是说，让你去观看这些节目，决定他们如何被呈现于观众面前，才是它的核心玩法。<br>于是，我们可以说说它的剧情了。<br>我为不予播出的剧情概括了一些特点，首先是荒谬性<br>国家晚间新闻，是一家有不少zz性的电台，在游戏的一开始，作为新上任的导播，我们的第一次工作就见证了前文提到的先进党的上台，在游戏的一开始我们能感受到强烈的荒谬感，就拿先进党举例，该党的带头人是一对夫妇，丈夫粗俗不堪，而妻子却圆滑世故，这样一对其貌不扬的夫妇在自己上任的第一天就大声向“富人”宣战，我们知道，如果对这些拥有大量资产的人过于苛刻就会造成大量资产外流，对此这对夫妇甚至采用强制手法禁止他们出境，这对一个“民主”国家而言恐怕很难想象，更为魔幻的是这样的举措确实赢得了大众为他们叫好，收归民有资产为国有，强制推行福利政策，提倡集体主义，一副宏伟的蓝图就这样在我们面前展开，即使对民粹主义者来说，这样狂野的改革恐怕也有些吓人，而这些种种举措以极快的速度在游戏中发生了，并且让你切实的体会到厉害之处——也就是游戏中各种惊慌失措的小资产阶级。如果你问大资产阶级咋样了，就有限的情报来说，似乎他们在与国家合作后过得很好。<br>这是一家很有煽动性的政党，但如果你细细去看他们做了什么，建立国家养老机构（把老人送进去就可以不管了）成立青少年队伍（洗脑从娃娃抓起）半强制推行政党性而不是国家性的身份卡（很明显，只是后续动作的开始）甚至把反对的国家的个别城市用特工安置的核弹统统炸上天。<br>很荒谬，不是吗？但这些事情确实如此发生了。</p>
<p>如果你很好奇对此的政治评论是怎样的，那么我们很快就会见识到该游戏另一个厉害之处——现实性的缺席。<br>在游戏的一开始国家晚间新闻是一家较为严肃的新闻频道，但随着游戏的进程，娱乐性的报道和节目越来越多（而且不乏先进党资助的无聊作品），这次过程中有着不少精妙的讽刺，例如领着先进党资助大搞政治正确的校园舞台剧组合，光明正大搞热水器的女明星等等，此时在早期的一些政治性节目中，也有不少让人啼笑皆非的人物，例如奉行白人至上主义，热爱sm的警察局局长，似乎几个小丑粉墨登场就能谈起国家大事。作为理应为公众揭露真相的媒体，自己就陷入了娱乐至死的泥潭<br>不过他们又能怎么办呢？对于一个奉行强权政治的政党，让一个电视台说不了真话简直太容易了。所以我们在游戏中看到的趋势是，节目变得越来越无聊，又臭又长，当批评声变得刺耳，那么连赞扬得不够卖力也成了罪责。<br>但游戏中依然有着保存着良心的媒体人，杰里米的爆发大概处于游戏中期，他挟持了摄像头，指责所有人都失去了说话的勇气，随后自绝于心爱的镜头前。这段的演出可以说全游戏最大的一个亮点，荒诞的现实与理想的缺席构成了极大的对比，将游戏荒谬而现实的矛盾感体现得极为突出。<br>然后，我们要说到极端意识形态题材作品的一体两面——压迫与反抗<br>哪里有压迫，哪里就有反抗，对于极端意识形态题材而言，对其的呈现与对反抗的呈现是一枚硬币的两面，与其他反乌托邦作品伟光正的反抗者不同，不予播出的反对者仅仅是走向了另一个极端。在游戏中有一个明确的反对者——打断组织，这个组织是什么样的呢？很大程度上可能由一些小资产阶级与无产阶级组成，面对集权，他们选择了暴力，游行，破坏，暴动甚至军事政变，我们很难说打断是一个多好的选择，事实上他们根本没有提出什么解决方案，似乎只是因为自己的利益受到了侵犯而已，在游戏的结局我们可以看到打断组织不过是军方扶持的傀儡，用完即扔。<br>再说回先进党，这一党派在游戏的中期收到全世界的敌视与孤立，不得不进行完全的内循环经济，究其原因，或许是对有产阶级的镇压并不符合经济全球化的要求，从而招致了其他国家的敌视，随后，他们向全世界部分国家的城市引爆核弹，建立起核威慑。<br>试问，如果你是一位普通人，你能做出什么样的选择呢？<br>说到这里，就不得不说不予播出另一个有趣的机制——在导播工作的间隙你将以视觉小说的形式看到作为普通人的自己如何在政治的漩涡中生活。与电视上光鲜亮丽的报道不同，即使作为被济的穷人，你也不过是从一贫如洗走向负债累累而已。<br>恐怕根本没有什么更好的选择。<br>最后，我们应该回归这部游戏贯穿始终的特点——讽刺性和娱乐性<br>可以说，这部游戏最终呈现的是一个荒谬的世界，在政治领域极端，疯狂，暴力构成了它的底色，这也是我称其为极端意识形态大乱斗的原因<br>你要问这样的构建是否过于疯狂而丢失了真实性，而且想要展现这样的世界观一个导播的视角也远远不够，可能的确是这样，但我认为这样极端之间的碰撞反而能增加不少的戏剧性。<br>可能根本不会有这么极端的政党，可能如此极端的政党根本得不到如此多的武力支持，或许吧，但说到底，这不过是个讽刺性游戏而已，用夸张的手法实属正常。<br>而在政治以外的社会领域呢？滑稽，疯癫，娱乐才是它的主题，你可以看到收藏大粪为乐的清洁工，无法控制肠道蠕动放出气体的“病患”等等极为魔幻的人物登上荧幕，可以说，游戏中所有的人物都是经过夸张化和娱乐化的，即使抛开政治性，你也可以当笑话看。这是我很欣赏不予播出的一点，它并不完全正经，但绝对有趣。</p>
<p>最后，做一个总结吧，根据关键节点的选择不同，游戏一共有14种结局，有一家独大，有天下大乱，也有非极端派兴起，这些结局有的因你而起，有的不过是大势所趋。不予播出从一个导播的小人物视角出发，呈现了一个极端意识形态偏向的荒谬社会的百态，有戏剧性的加工，也有对真实世界的化用与讽刺。<br>说实话，政治讽刺题材的乐趣不正是在此吗？</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>not for broadcast</tag>
      </tags>
  </entry>
  <entry>
    <title>【杀手3争议】拟真性与游戏性之争</title>
    <url>/2023/09/30/%E6%9D%80%E6%89%8B47/</url>
    <content><![CDATA[<p>2022年一月份，杀手3将解除一周年的独占，登录steam，而早在21年初，杀手3就成了一款有点话题性的游戏，这是因为游戏的一张重庆的地图，这一地图因为缝合了赛博朋克，老大哥等元素被指责有乳制品嫌疑。</p>
<span id="more"></span>
<p>在仔细讨论这件事前，让我们先来看看这是一个什么样的游戏。平心而论，作为一个系列续作，杀手3可以说还算合格，虽然刺杀方式上有缩水，但看得出制作组在氛围营造上投入了不少努力，有很多截一帧就是壁纸的远景或者特写。杀手系列可以说是一个好游戏，甚至可以说是刺杀游戏这一细分品类的霸主，但ioi是纯纯的懒狗，犯下了版本混乱，高价低质量dlc，违背承诺种种重大错误，ioi并不是一个好开发商，如果你骂ioi，我举双手赞成，但对杀手三3有没有乳，我认为还是要谨慎讨论。<br>我所好奇的是，杀手是不是一个拟真的游戏？<br>我想只要你玩过这个游戏，你就会知道答案是否定的，即便是游戏的核心——刺杀系统，也有很多方案并不具有现实可行性。，如果说起其他设定，就更没有真实性了，杀手三部曲的反派是一个势力遍及全球，由“社会精英”组成的阴谋论组织，我并不认为这样的组织有什么现实可行性，如果我们这种普通人都能知道这样的组织，那只有两个可能，1这样的组织情报保密工作很烂，那它早该被拿下来了2它故意泄露的，实际上我们对它一无所知，那就让我们一切的想法都成了臆测，阴谋论是一些无法质疑的假设，这样的假设我可以提出几百个。<br>当然，我们没必要对一个游戏上纲上线，即便涉及到阴谋论，也只能说杀手并不是一个拟真的游戏。那么，作为一个涉及到多个国家刺杀目标的游戏，杀手对其中的国家是怎么描写的呢？<br>摩洛哥在杀手里被描绘成政府软弱无能被军阀控制，甚至准备发动政变，我们且不论这是不是真的，无论如何这都不是什么很友好的描写，我们提到过的阴谋论组织的一位高层在法国有一个大葡萄酒厂，很符合我们对法国的刻板印象吧，然而这位律师有私人武装，甚至包括一队直接听命的狙击手，我想法国不会放任私人权利到这个地步。孟买的街头扛着步枪的武装士兵到处走，北欧的高端别墅区一栋不算特别大的别墅有十几个全副武装的保镖，这些对我一个中国人来说都觉得不合理，可见杀手这个系列根本没有多少写实性。<br>我们可以做一个总结了，无论从什么角度看杀手都不是一个贴近现实的游戏，特别是在zz方面，尤其口无遮拦，什么都编的得出来。<br>那让我们再看看重庆这张图，这张图有什么呢，赛博朋克+老大哥，大量的监控摄像头，华人街一样的街道和餐馆，秘密暗杀组织的不人道实验，改造人类街头的流浪汉，我们之前也说了，杀手的地图里编的成分很大，更何况设定上ICA最重要的实验室就在这里，与其说ioi想还原什么地方，倒不如说估计是他们看到一些关于重庆很赛博朋克的新闻，然后觉得可以蹭一下人设。试问这些元素有多少是真正不合适的呢，脑子正常的人都不会觉得现在有技术能操控人的思想或者改造人类吧，既然你不会觉得这些情节是真的，你为什么会觉得这座城市是真的这样呢？<br>当然，事实上这样的论述也是有模糊性的，你可以说不够还原就是不够尊重，也可以说法国，美国的图比中国的还原是歧视，在国际矛盾激化的今天，会在这样的事上比较敏感可以理解，但我想说，我希望并呼吁大家在至少在文娱领域多一些宽容，不要泛政治化，能疑罪从无就不要恶意去揣测。<br>47的目标有很多罪不至死，为了一己私欲杀死无罪者，这难道不是宣传不良价值观吗？但恐怕没人这么批评，为什么我们会在道德上对文娱作品这么宽容，在政治上却那么草木皆兵呢？<br>我很希望大家能多一些宽容，我也希望文娱作品无论何时都应该是一片不被zz过分染指的净土</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>hitman</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls剧情解析</title>
    <url>/2023/09/29/black%20souls%E5%89%A7%E6%83%85%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="冬之钟"><a href="#冬之钟" class="headerlink" title="冬之钟"></a>冬之钟</h1><p>由于black souls的故事远远没有完结，因此现阶段我们很难对<code>红白女王</code>与<code>梅贝尔</code>这些与格林牵扯极深的支配者们进行什么定论，只能就已有的剧情和文本进行一些归纳，本期视频我将就bs2比较难懂的一处地方，冬之钟的主线事件，进行一些个人向的分析。</p>
<span id="more"></span>
<p>在冬之钟最后一章地图能遇到5个白熊，白熊的身份迄今为止依然是谜团，但他们提供了整整五段发生在支配者之间的重要对话，我将概括一下这五段对话提供的主要信息以便进一步的分析<br>我们按解包后的地图顺序开始，<br>第一段对话发生于<code>梅贝尔</code>和妹妹爱丽丝之间，可以猜测妹妹爱丽丝属于支配者之一，数量众多的支配者都在奈亚的箱庭占据一个角色以便和格林繁殖，但随着时间推移，支配者们发现扮演角色的同时，他们也在被角色同化（<code>梅贝尔</code>所言），因此纷纷退场，妹妹爱丽丝也逐渐被角色影响对格林产生好感，此外，姐姐爱丽丝不知何故地退场。<br>第二场对话发生于<code>梅贝尔</code>和白之女王之间，对话中提及冬之钟正是白女王的箱庭，而白之女王由于爱上了格林自愿放弃女王的身份去守护他，而<code>梅贝尔</code>则对这场追寻爱的闹剧，以及陪着胡闹的其他支配者感到无聊，向白女王提出一个让格林摆脱循环，并且能够独占他的计划。<br>第三第四场对话都发生于红白女王之间，<code>红女王</code>为陷入痛苦轮回的格林而痛苦，不断进行自残，白女王制止了她，两人由于同样爱上格林而心意相通<br>第四场对话则告诉我们，<code>红女王</code>接过了白女王的权王冠（推测为箱庭权限），并以此创造出库因兰德，并使其能排除奈亚的监视，两人密谋让格林挣脱循环的方法，<code>红女王</code>恳请白女王放弃对格林的独占欲，白女王同意了，此外，<code>梅贝尔</code>也知晓这一计划，并根据后面的行动来看，她不知为何也参与了这个计划<br>第五场对话发生于白女王和玛丽苏之间，白女王夺走了玛丽苏的改变能力，并且根据混沌迷宫的情报，将其赋予了古兰剧场，玛丽苏察觉白女王爱上了格林，并且等待着格林的到来，结尾，玛丽苏等到了一个神秘人（黑山羊？）<br>总结这些信息，我们可以推测出针对格林，一共提出了两个计划，一个是<code>梅贝尔</code>怂恿的独占计划，一个是红偶像策划的拯救计划，这两个计划都必须有<code>诺登</code>的参与，但此时我们并不知道<code>诺登</code>的真正想法是哪个<br>在推进h结局的过程后，格林会有两个选择，1是和暗黑舞台合二为一2是打败舞台，夺取舞台的改变能力， “此时”的冬之钟虽然沉睡，但相信<code>诺登</code>依旧有一定的控制能力，然而不同于G结局的阻拦，此时的<code>诺登</code>选择了旁观，并在最后支持格林任意一个选择<br>总结一下大致发生的事件（以下事件的时间顺序难以具体确定）<br>1<code>诺登</code>作为支配者之一管理着自己的箱庭冬之钟，和奈亚创造自己箱庭的时间关系未知<br>2奈亚将格林带到箱庭，邀请支配者们参加繁殖游戏，根据牛津学院人偶爱丽丝的说法，是舞台装置创造出了让格林在舞台上登场的皮套（格林的灵魂出自玛丽苏的手笔，因此推测只能创造皮套），并且在创造格林时两者间确立了深远的联系，白女王也参加了这个游戏，可以肯定白女王为了心爱的格林才舍弃了王冠（王冠可能指代管理箱庭的权能），因此推测白女王在爱上格林后可能以放弃王冠为代价，得到了管理奈亚箱庭的权限和陪伴在格林身边的权力<br>3红偶像被奈亚切割，由于茶会时期她曾经打倒初代红之女王，因此此刻可以说她的身份是第二任红之女王，为格林自责的她不断紫餐，得到了白女王的同情，白女王将自己原来的王冠权能移交给被奈亚切割的<code>红女王</code>，让她在原冬之钟的地盘上创造出自己的箱庭。<br>4红白女王合谋，或者其中之一从奈亚手中夺走了玛丽苏并囚禁起来，为了避免红白女王相互猜疑，二者将从玛丽苏手上得到的改变能力赋予舞台装置古兰，创造出一个新的支配者暗黑舞台，藏于处于过去时间线的冬之钟，同时由于处于过去的时间线，冬之钟几乎没有被发现的风险，通过dlc3经常出现的齿轮与其他信息可以推测，舞台装置拥有着影响整个箱庭以及舞台上大部分“演员”的能力，即在部分地图的bg和格林脑中的“齿轮声”，是不思议之国这场戏的核心，此外，由于<code>诺登</code>为了管理这个箱庭必须借助舞台的力量，而红白女王理论上权能接近，因此本视频中猜测红白女王都有部分操控舞台的权限<br>4由于支配者们发现扮演箱庭的角色会改变自己的本质，因此纷纷退出，白女王被迫用自己和格林的子嗣填补空缺<br>5<code>梅贝尔</code>认为这场游戏无聊透顶，一场剧本烂透的戏剧重复多少遍也只会让人厌倦（她自己是这么说的），因此她怂恿白女王让格林脱出循环，并抢先独占他<br>6<code>红女王</code>努力让自己的领域能排除奈亚的监视，并在此向白女王提出了拯救格林的计划，这个计划<code>梅贝尔</code>也知情，白女王同意了拯救计划，我们不知道白女王听到这两个计划的顺序，但他们明显是冲突的<br>7可能是人为，可能是自发，舞台觉醒了自我意识呼唤着格林的爱，同时在<code>梅贝尔</code>的指引下格林也朝着舞台进发，一场死斗在所难免，可以推测，在夺取舞台能力的结局中，<code>诺登</code>执行了<code>红女王</code>的拯救计划，舍身为格林断后，使其在爱丽丝01，即现在的红偶像的帮助下回到现实。在舞台与格林合一的bad end中，<code>诺登</code>执行了<code>梅贝尔</code>提出的独占计划，该结局中<code>诺登</code>辅佐着通过合体得到创作能力的格林与奈亚进行斗争，并且前往世界尽头来逃避一切纷争和毁灭，顺便一提，我觉得这结局也不算坏，白女王很可能会确保格林在融合中占据主导，此时格林成为了名副其实的支配者，和白女王的结合甚至能和奈亚势均力敌，不过寿司在采访中提到执着于爱丽丝身份的奈亚无法发挥全力就是了，毫无疑问这时的格林是目前为止的（格林）战力巅峰。<br>这就是冬之钟里发生的主要事件了，下面我将对事件的主要参与者，红白女王和虚无的少女进行分析。<br>首先是参与程度较低的<code>梅贝尔</code>，<code>梅贝尔</code>虽然入局较浅，但却是格林的引导者，并帮助拖延了一下奈亚，也是她告诉我们打破这一循环只能正面和舞台装置对决，那么她的目的是什么呢？<br>首先，<code>梅贝尔</code>在混沌迷宫中会直接提及支配者间不可避免将爆发战争，并且导致阿撒托斯的苏醒毁灭一切，而身份不是支配者却可能得到支配者之器的格林，才能发动不会惊醒阿撒托斯的箱庭战争，这可能是她帮助格林的首要目的<br>其次，<code>梅贝尔</code>是个不可救药的收藏狂，她的箱庭是个巨大的垃圾场，什么都有，因此她也想把格林培养成一个完美收藏品或者棋子<br>最后，在个人感情上，很难定论<code>梅贝尔</code>到底产生了多少感情，她自称对永无止境的劣质戏剧循环感到厌倦，才会帮助格林创造自己的故事，但又在背叛剧情中声称想要让格林得到更高的器随后利用他，最后如果试图救她又会说自己涌现出了一些对格林的爱，由于信息过少，很难知道她到底觉醒了多少感情。<br>不过可以肯定的是，如果是<code>梅贝尔</code>真有意背叛动机是不充分的，如果她只需要格林成为拥有支配者之器的棋子，那么独占和拯救计划都能实现这个目的，并且由于白女王看着，融合后大概率是格林占主导地位，无非是好不好操控的问题，因此猜测<code>梅贝尔</code>实际上是真心帮助格林，只是在用激将法，或者习惯性毒舌。<br>冬之钟的棋局不管怎么走<code>梅贝尔</code>都不是输家，如果独占计划成功，白女王和格林则会成为一股对抗奈亚甚至其他支配者的强大力量，如果拯救计划成功，格林则会成为一个有着支配者的器，却对大部分支配者恨之入骨的棋子或潜在盟友，不论哪个结果都对<code>梅贝尔</code>阻止阿撒托斯苏醒的目的有利，而她的损失不过是万千分身中的一个而已<br>随后则是红之女王，尽管游戏中没有直接说<code>红女王</code>就是一代的爱丽丝01，以及茶会中的爱丽丝，但大量证据表明她和爱丽丝01有着千丝万缕的关系，爱丽丝01也极有可能就是茶会爱丽丝，所以本视频采纳这一说法，可以说最早钻进人类皮套的她是人性化最深的支配者，她人类的一面深爱格林，但又恐惧支配者的一面暴露，因此自觉配不上格林，甚至认为是自己导致了格林的一切悲剧，顺便一提关于茶会以及更早时期的资料实在太少，所以我们现在对这段剧情的讨论很可能是不完整甚至有较大误解的，因此在此我只能尽可能保守地做一些推测，由于支配者本性难以剥离，在她身上有着强烈的自毁倾向，想爱，却又自觉没有资格去爱，因此她只能用紫餐的方式填补内心的负罪感，H结局中，她以几乎自杀的方式当着奈亚的面帮助格林逃离了奈亚的掌控，可以说为了格林，<code>红女王</code>自降身份把自己变成了棋子，而且是必死的棋子，只为了能在后续将奈亚一军。<br>等待着这个叛徒的是什么结局，我们只能发挥一下想象力了<br>最后则是冬之钟的核心人物，白之女王<code>诺登</code>，<code>诺登</code>的原型之一是爱丽丝梦游仙境的白兔先生，白兔最明显的元素就是他永远匆忙的样子和怀表，这点也在<code>诺登</code>身上得以体现，白女王作为这场繁殖游戏事实上的管理者，为了协调任性的演员们可谓操碎了心，在轮回的最后，台上的演员几乎全部是她的子嗣（兔子可是繁殖力非常强的生物），可以猜测在制定剧本和排练上她也得下不少功夫，而dlc3的核心意象，齿轮，其实可以说既指着暗黑舞台的齿轮带动了戏码的上演，也指着<code>诺登</code>怀表的齿轮，<code>诺登</code>就是那个负责在指针快点到达终点前让齿轮倒转，重新开始计时的人，这也是为何她会在结局中说为齿轮停止感到害怕，让齿轮转动是她的职责，在她的内心深处或许也有着对无尽循环中格林真正爱上自己并一起逃到世界尽头的希望，但最后她选择成全格林真正的爱，而放弃管理齿轮的职责则意味着她与自己支配者的身份完全决裂，将一切奉献给人类的爱。此外，<code>诺登</code>的支配者原型则是所谓的幻梦境之主，这或许解释了为何是她在实际上管理着二代这个巨大的梦境<br>我在尸龙的人物解析说，类似尸龙的独占欲在红白女王身上也出现过，但<code>红女王</code>由于害怕自己的支配者本性选择放手，那么白女王呢？在h结局中，<code>梅贝尔</code>被古兰（推测，也可能是奈亚）针对性的陷阱解决，但拥有舞台权限的红白女王应该不受影响，<code>红女王</code>为了最后拯救格林必须蛰伏，因此辅助格林对抗古兰以及奈亚的任务只能交给白女王，但即使在此时此刻，白女王依旧有着独占格林的选项，如果她控制或者协助舞台装置强迫和格林融合，就可以抢先一步独占所有支配者都垂涎的格林，但如果把舞台的改变能力给予格林，那么失去王冠和舞台的<code>诺登</code>则会失去自己在棋局上的几乎所有棋子，面对这种选择，<code>诺登</code>将选择权给了格林，不能说她是完全无私的，但面对这样的诱惑，她也会尊重格林的选择，这不得不说是非常伟大的爱<br>可以说白女王是一个有着两面性的角色，她支配者的一面始终对格林有着独占欲，但她人性的一面始终压抑着这些黑暗的感情，她是一个徘徊于人与神界限的存在，但无论如何，她都尊重并支持着格林的选择，所以她闪耀着人性光辉的一面始终是压过支配者的黑暗一面的。<br>让我们给这幕疯狂剧场的落幕做一个总结吧，这局棋是红白女王和<code>梅贝尔</code>设下的，目的是为了让格林得到古兰的改变能力并逃离奈亚的箱庭，其中没有舞台权限的<code>梅贝尔</code>负责引导格林，<code>红女王</code>则在最后帮助得到改变能力的格林摆脱奈亚掌控，而白女王则有着最关键的决策权，即是否利用舞台独占格林，但她最后将决定权给了格林，而格林真正的选择应该是夺取舞台的改变能力，因此最后白女王舍弃了一切帮助格林逃离崩坏的舞台。<br>这场棋局中，<code>梅贝尔</code>横竖不亏，<code>红女王</code>陷入必死之局，最关键的棋手就是白女王，只要她愿意，随时可以下出必赢的一着，但最后她依旧选择了放弃自己的棋子，把终结棋局的希望留给了格林<br>在经历如此多的牺牲之后，格林终于从棋子升为了棋手，只是不知道他又会下出怎样的一着</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>基于斯坦福cs106l的c++编程规范笔记</title>
    <url>/2023/09/29/cs106l%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="c-特性"><a href="#c-特性" class="headerlink" title="c++特性"></a>c++特性</h2><ul>
<li>更好的C<br>C++支持<code>命令式编程</code>，一种编程风格，其中程序按顺序执行的命令序列。从这个意义上讲，C++ 可以看作是对C 编程语言，使日常命令式编程更加直观和更容易使用。课程阅读器的这一部分介绍了一些 C++ 最常用的库,包括标准模板库，并展示了如何使用这些库来构建命令程式。 此外，它探索了最初出现在 C++ 语言中的新原语。C 编程语言，即指针、C 字符串和预处理器。<span id="more"></span></li>
<li>数据抽象</li>
</ul>
<p>C++与其兄弟C的最大区别在于_数据抽象_,程序执行的方式可以与程序执行的方式分开  程序员谈论那个程序。</p>
<ul>
<li>面向对象编程</li>
</ul>
<p>. 面向对象编程是一种完全不同的方式考虑程序设计，可以极大地简化复杂的软件系统。 钥匙  面向对象背后的概念很简单，但要真正体会到面向对象的力量  编程，您将需要一次又一次地看到它的运行情况。 这部分课程  读者探索了面向对象编程中的主要概念以及如何在 C++ 中实现它继承和多态。  </p>
<ul>
<li>泛型编程</li>
</ul>
<p>泛型编程是一种编程风格，旨在构建可以解决一系列远远超出最初设想的问题的软件<br>履行。 虽然泛型编程的完整处理远远超出了介绍性的范围C++ 编程课，泛型编程的许多思想都可以访问并且可以从根本上改变了您对 C++ 编程的看法。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>Can’t declare non-const reference to const variable<br>Can’t declare non-const reference to const vari</p>
<p><img src="/images/obsidian/20230215213916.png" alt="图片" title="image"><br><img src="/images/obsidian/20230215214023.png" alt="图片" title="image"></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><img src="/images/obsidian/20230215215043.png" alt="图片" title="image"><br>函数指针：将函数作为对象传递</p>
<h2 id="stl"><a href="#stl" class="headerlink" title="stl"></a>stl</h2><p>sequence:线性，有顺序<br>associative:不一定线性，有索引机制(map)</p>
<p>vector:有顺序的相同类型的数据集合，大小可控制<br>—子属性：<em>size:元素数量<br>—capacity</em>:单个元素大小<br><img src="/images/obsidian/20230214194657.png" alt="图片" title="image"><br>vector最常用，deque用于首部插入场合，list用于多种列表</p>
<p>associative(关联数组):有顺序的需要有比较方法，无序的需要哈希函数（更快）<br>iterators（迭代器）：用于访问容器中的所有数据<br>–常用函数，begin(),end(),iter++,*(pointer),&#x3D;&#x3D; !&#x3D;,&#x3D;（赋值,复制）,<br><img src="/images/obsidian/20230214200501.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214200805.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214201819.png" alt="图片" title="image"></p>
<h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><p>First call to std::cin &gt;&gt; creates a command line<br>prompt that allows the user to type until they hit enter  </p>
<ul>
<li>Each &gt;&gt; ONLY reads until the next whitespace  </li>
<li>Whitespace &#x3D; tab, space, newline  </li>
<li>Everything after the first whitespace gets saved and<br>used the next time std::cin &gt;&gt; is called  </li>
<li>The place its saved is called a buffer<br><img src="/images/obsidian/20230213213832.png" alt="图片" title="image"><br><img src="/images/obsidian/20230213214430.png" alt="图片" title="image"><br><img src="/images/obsidian/20230213214751.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214102508.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214104421.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214162731.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214162820.png" alt="图片" title="image"></li>
</ul>
<h2 id="hashmap的c-实现"><a href="#hashmap的c-实现" class="headerlink" title="hashmap的c++实现"></a>hashmap的c++实现</h2><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数HashMap():</span><br><span class="line">接受参数count(值的个数),hash function(有默认值)</span><br><span class="line"></span><br><span class="line">参数(typename fitst,typename last,bucket_count,H)</span><br><span class="line">//用一个容器首尾指针初始化hashmap</span><br><span class="line">eg.</span><br><span class="line">hashmap&lt;k,m&gt; map&#123;vec.begin(),vec.end()&#125;</span><br><span class="line"></span><br><span class="line">参数(init_list init,bucket_count,H)</span><br><span class="line">//用容器直接初始化hashmap</span><br><span class="line">eg.</span><br><span class="line">HashMap&lt;char, int&gt; map&#123;&#123;&#x27;a&#x27;, 3&#125;, &#123;&#x27;b&#x27;, 5&#125;, &#123;&#x27;c&#x27;, 7&#125;&#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">key-键</span><br><span class="line">mapped-被加密的值(int)</span><br><span class="line">H-哈希函数</span><br><span class="line">bucket_count(存储的键值对数组容量)</span><br><span class="line">load_factor(内联函数，返回size/bucket_count，即实际储存值的键值对)</span><br><span class="line">contains(参数const K&amp; key判断是否存在改键，返回bool值)</span><br><span class="line">at(参数k，返回mapped的引用)</span><br><span class="line">clear(清空键值对)</span><br><span class="line">insert(参数为键值对引用，返回一对pair&lt;iterator,bool&gt;,iter指向改键值对，无论是否已存在，bool表示是否成功添加，如为false则已存在该键值对)</span><br><span class="line">erase(key为参数，返回bool值)</span><br><span class="line">earse(iter为参数，返回该指针下一个位置)</span><br><span class="line">rehash(size_t为参数，重新哈希为给出的新的指针数组大小)</span><br><span class="line">begin(根据hashmap是否为const给出iter或const iter)</span><br><span class="line">end(返回伪指针)</span><br><span class="line">debug(打印所有哈希键值对以及哈希表所有参数，注意，必须基于重载&lt;&lt;运算符的基础)</span><br><span class="line"></span><br><span class="line">符号重载：</span><br><span class="line">M&amp; [](const key&amp; ,返回insert(key)的返回pair的first成员的second成员，即mapped值)</span><br><span class="line">//用于给key对应的value(mapped)赋值</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">node(struct，包含next指针和value)</span><br><span class="line">nodepair(前后node的pair)</span><br><span class="line">findnode(参数key，返回指针对&lt;prev,curr&gt;)</span><br><span class="line">first_not_empty_bucket()</span><br><span class="line">make_iterator(参数node*curr)</span><br><span class="line">_bucket_array(vector&lt;node*&gt;,其中一个node*为ptr,则ptr-&gt;value为&lt;key ,mapped&gt;)</span><br><span class="line"></span><br><span class="line">//指针构造</span><br><span class="line"></span><br><span class="line">_bucket_array：由指针组成的数组,每个成员都是一个指针</span><br><span class="line">储存的值为next指针和一个pair&lt;key,mapped&gt;</span><br><span class="line">operator-&gt; is a bit of an odd-ball. When you write p-&gt;m, it is interpreted as (p.operator-&gt;())-&gt;m.</span><br><span class="line"></span><br><span class="line">- This means operator-&gt; should return a pointer to the object that has the field m.</span><br></pre></td></tr></table></figure>
<h3 id="涉及的c-特性"><a href="#涉及的c-特性" class="headerlink" title="涉及的c++特性"></a>涉及的c++特性</h3><p>匿名函数<br>基本lambda语法<br>基本形式如下：<br>【capture】（parameters）-&gt;return-type {body}</p>
<p>typename function()<br>return {x,y,z}<br>即用{}的参数初始化原函数返回的类型</p>
<p>ptrdiff_t:用于储存两个指针的差</p>
<p>conditional_t&lt;func,x,y&gt;如果func为true则x，为false则y</p>
<p>forward_iterator_tag：单方向迭代器（可读写）<br>++iter，iter+&#x3D;1随后返回对自身的引用<br>iter++，先返回一个对自身的复制，随后iter+&#x3D;1</p>
<p>std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p>
<p>ate：从文件尾部开始<br>strsub(start,length)<br>移动语义(c++11新特性)<br>clss(classname &amp;&amp;)<br>利用右值引用的部分数据直接初始化新的类，并在初始化之后将右值删除，可以通过std::move()强制转化左值为右值。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利ds100的数据科学笔记pandas部分</title>
    <url>/2023/09/29/jupyter%20notebook/</url>
    <content><![CDATA[<h2 id="notebook"><a href="#notebook" class="headerlink" title="notebook"></a>notebook</h2><ol>
<li><code>Ctrl</code> + <code>Return</code>（或者 <code>Cmd</code> + <code>Return</code>在 Mac 上）： <em>评估当前单元格</em></li>
<li><code>Shift</code> + <code>Return</code>： <em>评估当前单元格并移至下一个单元格</em></li>
<li><code>ESC</code>： <em>命令模式</em> （在使用以下任何命令之前可能需要按）</li>
<li><code>a</code>: <em>在上面创建一个单元格</em></li>
<li><code>b</code>： <em>在下面创建一个单元格</em></li>
<li><code>dd</code>: <em>删除一个单元格</em></li>
<li><code>z</code>： <em>撤消上一次单元格操作</em></li>
<li><code>m</code>： <em>将单元格转换为 Markdown</em></li>
<li><code>y</code>： <em>将单元格转换为代码</em><span id="more"></span></li>
</ol>
<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="创建表格DataFrame"><a href="#创建表格DataFrame" class="headerlink" title="创建表格DataFrame"></a>创建表格DataFrame</h3><p>按列创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info = pd.DataFrame(</span><br><span class="line">    data = &#123;&#x27;fruit&#x27;: [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;raspberry&#x27;],</span><br><span class="line">          &#x27;color&#x27;: [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;],</span><br><span class="line">          &#x27;price&#x27;: [1.0, 0.75, 0.35, 0.05]</span><br><span class="line">          &#125;)</span><br><span class="line">fruit_info</span><br></pre></td></tr></table></figure>

<p>按行创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info2 = pd.DataFrame(</span><br><span class="line">    [(&quot;red&quot;, &quot;apple&quot;, 1.0), (&quot;orange&quot;, &quot;orange&quot;, 0.75), (&quot;yellow&quot;, &quot;banana&quot;, 0.35),</span><br><span class="line">     (&quot;pink&quot;, &quot;raspberry&quot;, 0.05)], </span><br><span class="line">    columns = [&quot;color&quot;, &quot;fruit&quot;, &quot;price&quot;])</span><br></pre></td></tr></table></figure>

<h3 id="选择行和列"><a href="#选择行和列" class="headerlink" title="选择行和列"></a>选择行和列</h3><ul>
<li>loc<br>两个详细运算符中的第一个是 <code>loc</code>，它需要两个参数。 第一个是一个或多个行 <strong>标签</strong> ，第二个是一个或多个列 <strong>标签</strong> 。</li>
</ul>
<p>所需的行或列可以单独提供、以切片表示法或作为列表提供。<br>单独提供会返回series<br>单独切片参数默认返回行</p>
<p><img src="/assets/jupyter%20notbook/image-20230924084033386.png"><br><img src="/assets/jupyter%20notbook/image-20230924084006924.png"><br><img src="/assets/jupyter%20notbook/image-20230924084050655.png"><br>● loc selects items by label. First argument is rows, second argument is columns.<br>● iloc selects items by number. First argument is rows, second argument is columns.<br>● [] only takes one argument, which may be:<br>○ A slice of row numbers.<br>○ A list of column labels.<br>○ A single column label.<br>That is,[] is context sensitive.</p>
<ul>
<li>列名一般唯一，可以强制重复</li>
<li>行名可以重复<br>pandas支持裸操作,但此时无法使用切片</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Here we&#x27;re providing a list of fruits as single argument to []</span><br><span class="line">fruit_info[[&quot;fruit&quot;, &quot;color&quot;, &quot;price&quot;]]</span><br></pre></td></tr></table></figure>

<h3 id="其他行列操作"><a href="#其他行列操作" class="headerlink" title="其他行列操作"></a>其他行列操作</h3><p>添加行和列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info[&#x27;rank1&#x27;] = [1,2,3,4]</span><br><span class="line">fruit_info.loc[:,&#x27;rank2&#x27;] = [1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>使用 <code>.drop()</code>方法来 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html">删除</a> 这两个 <code>rank1</code>和 <code>rank2</code>您创建的列。 确保使用 <code>axis</code>参数正确。 注意 <code>drop</code>不会更改表，而是返回一个具有较少列或行的新表，除非您设置可选 <code>inplace</code>范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info</span><br><span class="line">fruit_info_original = fruit_info.drop([&#x27;rank1&#x27;,&#x27;rank2&#x27;],axis=1)</span><br><span class="line">fruit_info_original</span><br></pre></td></tr></table></figure>

<p>重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info_caps=fruit_info_original.rename(columns=&#123;&#x27;fruit&#x27;:&#x27;F&#x27;,&#x27;color&#x27;:&#x27;C&#x27;,&#x27;price&#x27;:&#x27;P&#x27;&#125;)</span><br><span class="line">fruit_info_caps</span><br></pre></td></tr></table></figure>

<h3 id="布尔数组筛选和查询"><a href="#布尔数组筛选和查询" class="headerlink" title="布尔数组筛选和查询"></a>布尔数组筛选和查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = baby_names[(baby_names[&#x27;Year&#x27;]==2000) &amp; (baby_names[&#x27;Count&#x27;]&gt;3000)]</span><br><span class="line">result_using_query = baby_names.query(&#x27;Year==2000 &amp; Count&gt;3000&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="slides实例"><a href="#slides实例" class="headerlink" title="slides实例"></a>slides实例</h3><p>提取列数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections[&quot;Candidate&quot;].tail(5).to_frame()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提取目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For row labels, use DataFrame.index:</span><br><span class="line">For column labels, use DataFrame.columns:</span><br></pre></td></tr></table></figure>

<p>支持布尔数组检索<br><img src="/assets/jupyter%20notbook/image-20230924090511103.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections[elections[&quot;Party&quot;] == &quot;Independent&quot;]</span><br><span class="line">elections[(elections[&quot;Result&quot;] == &quot;win&quot;) &amp; (elections[&quot;%&quot;] &lt; 47)]</span><br></pre></td></tr></table></figure>

<p>支持用其他数组检索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a_parties = [&quot;Anti-Masonic&quot;, &quot;American&quot;, &quot;Anti-Monopoly&quot;, &quot;American Independent&quot;]</span><br><span class="line">elections[elections[&quot;Party&quot;].isin(a_parties)]</span><br></pre></td></tr></table></figure>

<p>查询类似sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections.query(&#x27;Result == &quot;win&quot; and Party not in @parties&#x27;)</span><br></pre></td></tr></table></figure>

<p>匿名函数辅助查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What if we wanted to find the longest names in California?</span><br><span class="line">babynames.query(&#x27;Sex == &quot;M&quot; and Year == 2020&#x27;)</span><br><span class="line">.sort_values(&quot;Name&quot;, key = lambda x: x.str.len(),</span><br><span class="line">ascending = False)</span><br></pre></td></tr></table></figure>

<p>创建删除列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">babyname_lengths = babynames[&quot;Name&quot;].str.len()</span><br><span class="line">#add that series to the dataframe as a column</span><br><span class="line">babynames[&quot;name_lengths&quot;] = babyname_lengths</span><br><span class="line">babynames = babynames.sort_values(by = &quot;name_lengths&quot;, ascending=False)</span><br><span class="line">babynames = babynames.drop(&quot;name_lengths&quot;, axis = &#x27;columns&#x27;)//删除列(默认为行)</span><br></pre></td></tr></table></figure>

<p>map方法使用函数统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def dr_ea_count(string):</span><br><span class="line">return string.count(&#x27;dr&#x27;) + string.count(&#x27;ea&#x27;)</span><br><span class="line">babynames[&quot;dr_ea_count&quot;] = babynames[&quot;Name&quot;].map(dr_ea_count)</span><br><span class="line">babynames = babynames.sort_values(by = &quot;dr_ea_count&quot;, ascending=False)</span><br></pre></td></tr></table></figure>

<p>字典创建表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#build dictionary where each entry is the rtp for a given name</span><br><span class="line">#e.g. rtps[&quot;jennifer&quot;] should be 0.0231</span><br><span class="line">rtps = &#123;&#125;</span><br><span class="line">for name in babynames[&quot;Name&quot;].unique():</span><br><span class="line">counts_of_current_name = female_babynames[female_babynames[&quot;Name&quot;] == name][&quot;Count&quot;]</span><br><span class="line">rtps[name] = ratio_to_peak(counts_of_current_name)</span><br><span class="line">#convert to series</span><br><span class="line">rtps = pd.Series(rtps)</span><br></pre></td></tr></table></figure>

<p>使用group建立新表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">female_babynames.groupby(&quot;Name&quot;).agg(ratio_to_peak)</span><br></pre></td></tr></table></figure>

<p><img src="/assets/jupyter%20notbook/image-20230924092636108.png"><br>groupby的其他用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given a DataFrameGroupBy object, can use various functions to generate DataFrames (or</span><br><span class="line">Series). agg is only one choice:</span><br><span class="line">● agg: Creates a new DataFrame with one aggregated row per subframe.</span><br><span class="line">● max: Creates a new DataFrame aggregated using the max function.</span><br><span class="line">● size: Creates a new Series with the size of each subframe.</span><br><span class="line">● filter: Creates a copy of the original DataFrame, but keeping only rows from subframes</span><br><span class="line">that obey the provided condition.</span><br></pre></td></tr></table></figure>

<p>合并表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">merged = pd.merge(left = elections, right = male_2020_babynames,</span><br><span class="line">left_on = &quot;First Name&quot;, right_on = &quot;Name&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据科学</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>基于北大前沿计算实践课和missing semester的vim笔记</title>
    <url>/2023/09/29/vim%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="you-are-your-dotfiles"><a href="#you-are-your-dotfiles" class="headerlink" title="you are your dotfiles"></a>you are your dotfiles</h1><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>按f1或命令行输入help开启在线帮助<br>&lt;Cw&gt;切换到另一个窗口q关闭窗口</p>
<span id="more"></span>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>如之前所述，Vim最主要的编辑模式是Insert模式，想要修改文本，先将光标在Normal模式下移动到对应位置，然后再键入<code>i</code>进入Insert模式，在这个模式下添加或者删除文本。但是当我们需要修改的地方非常多时，每次都需要先移动光标再输入<code>i</code>就是一个相对麻烦的操作，因而Vim提供了一些命令将移动光标和进入Insert模式合成一步：</p>
<ul>
<li><code>i</code>在当前位置输入（光标前），<code>I</code>在行首输入</li>
<li><code>a</code>在光标后输入(append)，<code>A</code>在行尾输入</li>
<li><code>o</code>在当前行下新建一行输入，<code>O</code>在当前行上新建一行输入</li>
<li><code>c</code>+光标移动命令会先删除然后进入Insert模式，比如<code>cl</code>会删除下一个字符，<code>cw</code>会删除到单词尾，<code>c10l</code>会删除10个字符。此外，<code>ciw</code>会删除整个单词，<code>cc</code>会删除整行，<code>ci(</code>(change in)会删除小括号里的内容，<code>ca(</code>(change around)则会删除小括号以及小括号里的内容，这在修改代码里的字符串、修改函数变量之类的工作中极其有用</li>
<li><code>s</code>(substitute)会删除当前字符并进入Insert模式，等同于<code>cl</code></li>
<li><code>r</code>(replace)替换当前字母</li>
<li><code>p</code>把上次删除的行放置在当前位置</li>
</ul>
<p>进入Insert模式之后，Vim也有一些奇奇怪怪的命令，比如<code>&lt;C-h&gt;</code>等同于删除键，会删除前一个字符，<code>&lt;C-j&gt;</code>等同于回车键，将光标后的文本移到下一行，但是否要这样做就全凭个人喜好了。<br>其实在Normal模式下也能进行一些删除操作，<code>x</code>会删除当前字符，<code>d</code>+光标移动命令会删除对应文本，与<code>s</code>以及<code>c</code>命令的区别仅仅在于<code>x</code>和<code>d</code>操作完之后依然处在Normal模式，所以<code>s</code>也等同于<code>xi</code>。此外，<code>r</code>的作用也是替换当前字符，键入<code>r</code>之后会提示输入一个字符，输入完成之后自动回到Normal模式，想要替换长文本就需要键入<code>R</code>进入Replace模式。因此如果想要替换一个字符成x，最快的方法是<code>r</code>+x，也可以<code>s</code>+x+<code>&lt;ESC&gt;</code>，也可以<code>xi</code>+x+<code>&lt;ESC&gt;</code>，也可以<code>cl</code>+x+<code>&lt;ESC&gt;</code>。<br>撤销和重做也是非常常用的编辑命令，在Vim中分别对应Normal模式下的<code>u</code>(undo)和<code>U</code>，同时<code>.</code>可以重复之前最后一个命令。<br>“U”（行撤销）。恢复整行的所有操作<br>&lt;C-r&gt;重做上一个 被撤销的命令</p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>在Normal模式下键入<code>:</code>就会进入命令行模式，此时光标已经移动到了最下面。命令行中可以输入的命令种类非常多：</p>
<ul>
<li><code>w</code>保存文件，但是不退出</li>
<li><code>w !sudo tee %</code>使用sudo保存文件<br> w filename保存文件到当前目录</li>
<li><code>wq</code>、<code>x</code>、<code>ZZ</code>保存并退出</li>
<li><code>q!</code>、<code>ZQ</code>退出但不保存</li>
<li><code>!</code>+命令 可以在shell环境下执行命令</li>
<li><code>r !</code>+命令 可以在shell环境下执行命令并插入到当前光标下一行</li>
<li><code>e</code>+文件 可以加载新的文件（当前文件没保存的话会报错）</li>
<li><code>e!</code>+文件 加载新文件并丢弃当前更改</li>
<li><code>f</code>显示当前文件的文件名</li>
<li><code>%s/old/new/g</code>搜索所有<code>old</code>并替代成<code>new</code>，支持正则表达式o<br>命令行界面输入&lt;Cd&gt;显示可以选择的命令，tab自动补全o</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>除了这些直接跳转命令，Vim也提供了搜索机制。<br>首先是行内的搜索，<code>f</code>、<code>t</code>、<code>F</code>、<code>T</code>后面加上任意字符x，代表跳转到当前光标下一个x、跳转到下一个x之前、跳转到上一个x、跳转到上一个x之后，搜索到了之后也可以继续按<code>,</code>和<code>;</code>在搜索结果之间前后移动。<br>然后是文件内的搜索，<br>直接键入<code>/</code>或者<code>?</code>会进入命令行搜索模式，<code>/</code>是从开头开始搜索，<code>?</code>是从结尾开始搜索，后面可以加上任意长度的字符<br>然后键入<code>&lt;CR&gt;</code>就可以高亮显示所有的搜索结果，按<code>n</code>和<code>N</code>就可以在搜索结果之间向前和向后移动。<br>输入:set ic(ignore case)忽略大小写搜索 set noic取消<br>仅搜索一次忽略大小写:&#x2F;search_sth\s<br>输入:set hls is高亮搜索结果<br>&#x2F;&#x2F;‘ic’ ‘ignorecase’ ignore upper&#x2F;lower case when searching</p>
<p>‘is’ ‘incsearch’ show partial matches for a search phrase</p>
<p>‘hls’ ‘hlsearch’ highlight all matching phrases<br>搜索模式支持正则表达式。最后如果想要关闭搜索结果的高亮，需要借助命令行命令，输入<code>:noh</code>即可关闭高亮。<br>type :#,#s&#x2F;old&#x2F;new&#x2F;g where #,# are the line numbers of the range</p>
<p>of lines where the substitution is to be done.</p>
<p>Type :%s&#x2F;old&#x2F;new&#x2F;g to change every occurrence in the whole file.</p>
<p>Type :%s&#x2F;old&#x2F;new&#x2F;gc to find every occurrence in the whole file,</p>
<p>with a prompt whether to substitute or not.</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>编辑文本和代码难免要复制和粘贴，复制操作涉及到选择需要复制的文本，在Vim中这需要在Visual模式下进行。在Normal模式中键入<code>v</code>进入选择模式，可以跟在Normal模式下一样移动光标，被选择的文本就会高亮。<br>或者在Normal模式中键入<code>V</code>进入行选择模式，被选择的行会高亮。选择完成后，如果直接按<code>&lt;ESC&gt;</code>就会返回Normal模式，并且选择的内容高亮消失，因此不应该这么做，而应该直接在Visual模式下键入<code>y</code>(yank)复制高亮的文本，如果输入的是<code>d</code>则会删除被选择的文本，此时会自动回到Normal模式。<br>不管是<code>y</code>还是<code>d</code>操作，被选择的文本都会被操作到Vim的缓存中，在Normal模式下按<code>p</code>就会粘贴其中的文本到当前位置。与之前介绍的<code>cc</code>、<code>dd</code>类似，也可以直接在Normal模式下输入<code>yy</code>，对应复制当前行。<br>Vim还提供了列选择模式，在Normal模式下键入<code>&lt;C-V&gt;</code>进入，选择完列之后可以跟Normal模式一样进行<code>r</code>、<code>d</code>等操作，这在制表、注释中非常有用。</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>Vim中所有键盘输入都可以视为命令，可以被记录下来映射到快捷键。在Normal模式下，最基本的命令是控制光标移动的命令<code>hjkl</code>，其中<code>jk</code>控制上下(大写状态下删除行间空格)，<code>hl</code>控制左右，方向键同样可以控制光标，但是因为方向键盘离打字的范围比较远，所以推荐大家熟悉<code>hjkl</code>这四个键。在没有鼠标的情况下想实现长距离的光标跳转，每次只能移动一个单位显然是低效的，好在Vim为光标跳转提供了多种命令：</p>
<ul>
<li><p>单词间：<code>w</code>可以跳转到下一个单词的开头，<code>b</code>跳转到当前单词的开头，继续按跳转到上一个单词的开头，<code>e</code>跳转到当前单词的结尾，继续按跳转到下一个单词的结尾</p>
<blockquote>
<p>遗憾的是中文很难分词，所以在中文中键入<code>w</code>会跳转到下一个短句</p>
</blockquote>
</li>
<li><p>括号、引号间：如果光标在括号或者引号中间，<code>%</code>会高亮显示括号或引号，继续按会在头和尾反复横跳</p>
</li>
<li><p>行内：<code>0</code>跳转到行的开头，<code>^</code>跳转到行的第一个非空格的字符，<code>$</code>跳转到行的结尾</p>
</li>
<li><p>段落间：<code>&#123;</code>跳转到上一段，<code>&#125;</code>跳转到下一段</p>
</li>
<li><p>屏幕内：<code>H</code>跳转到屏幕最上面，<code>M</code>跳转到屏幕最中间，<code>L</code>跳转到屏幕最下面</p>
</li>
<li><p>屏幕滑动：<code>&lt;C-u&gt;</code>向上滑动，<code>&lt;C-d&gt;</code>向下滑动</p>
</li>
<li><p>文件内：<code>gg</code>跳转到文件开头，<code>G</code>跳转到文件结尾,</p>
</li>
<li><p>&lt;CG&gt;显示当前行数，数字G跳转到对应行</p>
</li>
<li><p>其他：<code>zz</code>会将光标置于屏幕中心</p>
</li>
</ul>
<p>这些基本命令可以和数字进行组合，输入任意数字（默认情况下显示在右下角），然后输入<code>j</code>就会向下移动对应行数，同理，如果是数字+<code>w</code>，就会移动对应单词数。另外，数字+<code>&lt;CR&gt;</code>等同于数字+<code>j</code>，数字+<code>G</code>会跳转到整个文件的第几行。  </p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>Normal模式是最基本的模式，在这个模式下基本只能移动光标，不能直接输入文本，因为此时键入任何字符都会被当成是Vim的命令而非插入到文本中。想要输入文本需要切换到Insert模式，可以直接键入<code>i</code>进入Insert模式，此时输入任何字符都会插入到光标所在位置。想从输入模式中返回Normal模式，只需要键入<code>&lt;ESC&gt;</code>。事实上，在任何模式下键入<code>&lt;ESC&gt;</code>都 能回到Normal模式。Normal模式和Insert模式是Vim中最常用的两种模式，理论上我们只需要这两种模式就能完成修改文本的所有操作，其他 模式和命令都是用来更快地完成一些任务。默认情况下，所处模式会显示在Vim窗口的左下角，Normal模式没有显示，Insert模式会显示<code>--INSERT--</code>，Command-line模式会显示所输入的命令等等。在Normal模式下键入<code>R</code>进入Replace模式，用于替换当前光标处的文本，键入<code>v</code>进入Visual模式，用于选择文本。</p>
<p><img src="/images/obsidian/vim-mode.jpg" alt="图片" title="image"></p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>.命令重复上一次命令，可用于简化操作</p>
<ul>
<li>C&#x3D;c$</li>
<li>s&#x3D;cl</li>
<li>S&#x3D;^C&#x2F;&#x2F;整行替换</li>
<li>I&#x3D;^i</li>
<li>A&#x3D;$a</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>vim</tag>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉rpg设定集</title>
    <url>/2023/09/29/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89rpg%E8%AE%BE%E5%AE%9A%E9%9B%86/</url>
    <content><![CDATA[<h1 id="队友"><a href="#队友" class="headerlink" title="队友"></a>队友</h1><h2 id="雷克"><a href="#雷克" class="headerlink" title="雷克"></a>雷克</h2><p>帝国法律系学生，成长于如今兄弟会的前身，幼时被走投无路的父母托付给了盗贼兄弟会，并经受了盗贼训练，随后由于帝国发展进程，盗贼兄弟会决定洗白自己，于是选拔了手下聪明的学徒接受高等教育并改名兄弟会，雷克就是其中的佼佼者。</p>
<span id="more"></span>
<p>然而比起兄弟会肮脏的勾当，接触帝国新兴教育的雷克逐渐有了叛逆之心，比起法律他对医学更有兴趣，一开始是偷一些新鲜死体进行解剖，随后甚至发展成了诛杀一些地痞流氓并进行各种实验和解剖的连环杀人犯，因为这些经历，雷克下手狠辣，反应敏捷，是个优秀的盗贼。<br>偷挖尸体时被无名氏发现，并且无名氏的强大气息让他不敢敌对，由于无名氏缺少一个熟悉帝国的向导，雷克就这样被要挟着加入了队伍<br>性格意外地开朗，似乎是个不错的朋友，但很难定论他的内心藏着多少黑暗<br>阵营守序中立</p>
<h2 id="莉思"><a href="#莉思" class="headerlink" title="莉思"></a>莉思</h2><p>法师塔的高材生，学徒转正的试炼中，大法师们补下幻象，让她对决所有的同届学生，想让她意识到团结的力量，但聪明的她早就对所有人做了各种应对方案，在随机应变和一些运气下，莉思真的击败了所有对手，并且由于情况危急，她下了死手。<br>试炼完成后，在场的法师们不约而同地认识到她危险的性格是个定时炸弹，想要剥夺她的法师资格，绝望的莉思却听到了一个神秘的声音，随着声音的指引她发动了不可能成功的传送法术去到了帝国边境。<br>在那里她隐姓埋名，用几年时间成为了一位名气不小的实战派法师，随后遇到了无名氏。<br>“你身上有强大法术的气息，让我感到熟悉,我希望能与你同行”<br>阵营中立邪恶</p>
<h2 id="默克"><a href="#默克" class="headerlink" title="默克"></a>默克</h2><p>因为违反规则，徘徊于主物质界的欲灵<br>欲灵必须满足驯服他们的人类的三个愿望，但如果另一个欲灵驯服了他呢？结果就是他被规则诅咒只能徘徊于主物质界。<br>有一个欲灵伪装成人类向他许愿，这个愿望则来自一个驯服他的人类，也就是无名氏，因此才出现了这种错误。<br>这个愿望是忘记一切过去，但不知为何空间也出现了扭曲，实现愿望后，无名氏和默克被传送到一座古墓，醒来的无名氏逮住了他，思考后默克决定与他行动，寻找那个肆意妄为的欲灵。<br>为了不引发好奇，设置了一个猫头鹰幻身<br>阵营混乱中立</p>
<h2 id="欲灵女王"><a href="#欲灵女王" class="headerlink" title="欲灵女王"></a>欲灵女王</h2><p>传闻中她是一个强大的欲灵，因此能统率大批同类为其所用，但实际上她只是一个人类法师，因为善于倾听欲灵的烦恼并安抚它们，她曾让不少欲灵摆脱了由于灵魂不纯而徘徊物质界与元素界之间的痛苦，作为回报，欲灵们生前的回忆与知识有部分被她所理解，因此论阅历属于当世法师的佼佼者。<br>其自称自己的天赋一般，并对胜负毫不在意，所以，平常不会显露出多强的实力，但总感觉她留了一手<br>年龄未知，自称对玩弄无名氏的欲灵感兴趣而与他同行<br>阵营中立善良</p>
<h1 id="npc"><a href="#npc" class="headerlink" title="npc"></a>npc</h1><h2 id="苦惨女士"><a href="#苦惨女士" class="headerlink" title="苦惨女士"></a>苦惨女士</h2><p>“去杀戮，去破坏，去抢夺吧，除此以外没有获得救赎的办法了，而我会在此，为您承担所有的罪孽”</p>
<p>对七苦圣母的信仰，由于教规和神迹的苛刻，在几百年间逐渐地消失了，苦惨之女，数百年前经过血祭仪式得到圣母祝福之人，如今以及经过了她第七个，也是最后一个人生，苦恼着如何度过最后时日的她遇到了无名氏，在他身上纠缠着的痛苦命运让她深受感化。<br>“或许经历这样的痛苦才能有所领悟”<br>因此她向无名氏提出了请求，再次进行仪式，让她承担无名氏战斗时收到伤害的一半。<br>在伤害积累到一定程度后，她会死去，并在死后继续赋予无名氏减伤的祝福<br>如果拒绝她，或者积累的伤害不够，苦惨女士由于没有领悟到七苦之义，在之后的时日度过了平凡而幸福的一生。</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉世界观设定集</title>
    <url>/2023/09/29/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E4%B8%96%E7%95%8C%E8%A7%82/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生……</span><br></pre></td></tr></table></figure>

<p>  这是邪神辛克莱温教徒传颂的创世神话，也是目前为止我们所知最早的创世神话，可以说后世诸多关于创世的传说都有它的影子。</p>
<span id="more"></span>

<p>邪神辛克莱温的信徒有着自己的语言，这种符号文字晦涩难懂，虽然给传播教义造成了困难，却成为维系着邪神教绵延几千年信仰的纽带。<br>邪神辛克莱温是……                                           </p>
<p>——选自帝国学者载丝莉《邪神起源探究》</p>
<h2 id="克雷多斯族"><a href="#克雷多斯族" class="headerlink" title="克雷多斯族"></a>克雷多斯族</h2><pre><code>      平庸是进化论所给我们最后的仁慈——帝国医学教科书扉页
</code></pre>
<p>奥诺斯是社会达尔文主义者的神，他的教义就是物竞天择，适者生存，让优秀的种族淘汰低劣的种族。放到现在他肯定会被当做邪神。奥诺斯创造过很多种族，大部分在穷兵黩武中走向了灭亡，然而其中有一个民族最为他所垂青——克雷多斯族。这一种族刚出现时平平无奇，但他们的眼中只有强者，尊严的力量促使着他们不断发挥着潜力，追逐着比自己强大无数倍的敌人。他们逐渐走向强盛，但后来因为自相残杀导致族人寥寥无几。这时，一位天才创造出了一种把他们一分为二的方法，以此来把自己当做对手，起初，克雷多斯族凭借这一方法几乎成为世界上最令人恐惧的种族，深深地让奥诺斯感到自豪。然而，在与自己的斗争中，有的族人学会了“阴谋”，将另一个自己与其他敌人算计致死，有的人学会了“隐忍”，进而学会了妥协与认输，最终，他们都选择了“平庸”。为了心爱的子民惋惜不止的奥诺斯神来到了最后一个保持着绝对尊严的战士面前：</p>
<p>“我也给予你选择平庸的权利。”</p>
<p>“你要我变得和他们一样吗?绝不！！！”</p>
<p>战士怒吼着冲向了最后一个对手。从此，奥诺斯和他的战士消失于迪瑞克拉世界。</p>
<h2 id="沉默峡谷"><a href="#沉默峡谷" class="headerlink" title="沉默峡谷"></a>沉默峡谷</h2><p>沉默不是逃避，而是一种选择——沉默沼泽路牌上的涂鸦</p>
<p>沉默峡谷被命名并正式标在官方地图上是帝国历387年的事了，在此之前它只是个普通的荒凉之处而已，当然，还是偶尔进入的旅客发现这里——但他们有的没能走出来，有的在出来后被别人或自己当成了疯子。</p>
<p>沉默峡谷的土壤和两侧的山岩有种特殊的性质，能几乎把所有的声音消除，巴比伦塔的学者曾对此展开研究，然而他们一无所获。除此以外，沉默峡谷就是个普通的荒凉峡谷，稀疏的杂草养不出大型动物，对一个经验丰富的旅行者而言，找到水源，辨别方向和驱散毒虫都不算难 ——只要他能忍受无尽的沉默</p>
<p>在被载入地图后，这里逐渐成了修士的圣地，当然，也有人进去后再也没有出来</p>
<h2 id="幻影沼泽"><a href="#幻影沼泽" class="headerlink" title="幻影沼泽"></a>幻影沼泽</h2><p>警告！魔术师慎入！</p>
<p>这是沉默峡谷一处著名的景点，和峡谷本身一样，这里也几乎没什么异常，对有防备的旅行者而言并没什么危险。传说中一位善于擅长表演幻影魔术的魔术师来到这里时，将自己当做了幻影，而把幻影当成了真实。于是他迷失在这里，将此处化成了一片沼泽，如果一位有真才实学的魔术师来到这里，那么他绝对无法精神正常地离开，尽管对其他人而言，这里能看到的异象仅仅是偶尔出现魔术师忧郁的身影而已。</p>
<h2 id="沉默王国"><a href="#沉默王国" class="headerlink" title="沉默王国"></a>沉默王国</h2><p>………………………………</p>
<p>沉默王国一直是个传说，一开始只是有少数人怀疑那些进了峡谷再没有出来的人到底去了哪里？这些怀疑逐渐被时间埋葬，直到帝国标记了沉默峡谷的存在导致一批旅行者来此游览，，有些旅行家发现了沉默王国的存在，很难想象一个王国会存在于荒野，事实上，那里只是寥寥几个人的聚居处。住民们给了旅行家一些食物和饮水，并为他指明了道路，从始至终，他们都带着沉默，从未试图张开嘴唇过。</p>
<p>此后又陆陆续续地出现了类似住民目击报告，但都被帝国封锁，最终，这一切成为了传说或是怪谈，奇怪的是，帝国似乎对此颇为忌惮，从此以后沉默峡谷再也没有出现在官方文件上过。</p>
<p>  我们认为那些住民的存在涉及了达瑞克拉世界的源论，可以肯定那是一些向往沉默的人，不知何时他们聚集起来，用各自的思虑创造了一个无声的世界——或许跟0号研究所揭示的结果一致，这十分危险，一旦被人们知道，达瑞克拉世界或许会因此毁灭。</p>
<pre><code>                                 ——《关于沉默王国的报告》
</code></pre>
<h2 id="0号研究所"><a href="#0号研究所" class="headerlink" title="0号研究所"></a>0号研究所</h2><p>我思故我在，我在故我思。——帝国哲学家卡尔迪</p>
<p>0号研究是科学组织浮士德所进行的一场实验，没错，与大多数我同事的想法相反，它并不是个邪教组织，从同行的角度来说，我很佩服他们的开创性。</p>
<p>0号研究所本是个普通的小镇，如果不是那件事的发生，我们永远不会知道这里曾发生过这样的实验。</p>
<p>帝国的审讯所抓到过一个浮士德的高层，今天他们终于设法让他开口了，由此我们终于知道他们是怎么进行实验的。首先，小镇只是出现了一些以屠戮人民，掠夺财物为乐的人，他们穿着迥异的衣服，却意外有着纯正的当地口音，经过一番协力，这些人不久就被送上了断头台。</p>
<p>奇怪的是，他们面对死亡毫无畏惧，自称“玩家”的他们发出了下次进犯的预告，然后在断头台上化成白光消失了。</p>
<p>当天，一切有关他们的消息被政府封锁，几乎同时不少“智者”跳了，要求让民众得知真相，惴惴不安中，很多小册子在民众中传阅——上面说这个世界只是虚构，完全为了让那些玩家取乐而存在（至于为何能让民众了解虚幻的概念，或许浮士德的教育机制还是挺有成效的）</p>
<p>第二天，更多所谓的“玩家从天而降”，所有住民都陷入了绝望与怀疑，就在这时我们所知的异变发生了，没人知道这是怎么做到的，但整个克罗利安镇就这么化为一片混沌之地，我们的不少调查员在第一眼看到它的遗址时就发疯了——我们没人知道为什么。</p>
<p>现在那里应该已经封闭了，我的建议是，永远封闭下去，或许邪神辛克莱温是对的，这个世界确实由我们的思想决定。我希望所有人都能对此提高警惕，永远不要让类似的事故重演 </p>
<h2 id="帕斯卡王国"><a href="#帕斯卡王国" class="headerlink" title="帕斯卡王国"></a>帕斯卡王国</h2><p>世上哪有不建立在剥削上的幸福？</p>
<p>帝国前36年，在正片大陆一个名不见经传的角落有一个小国，这个国家物资贫瘠，人口稀疏，尽管气候不算恶劣，但人民常常处于食不果腹的状态。</p>
<p>国王帕列斯是位平庸的君主，他的儿子——王子恩西斯却是位有想法的年轻人，尽管刚刚成年，他已经开始思索如何壮大自己的国家，这位王子曾经游学诸国，每次看到国民因营养不良而矮小纤弱的身材，他都会在心中发誓一定要找到让子民过上幸福快乐生活的方法</p>
<p>有一天，他带着这个愿望，带着几位侍从出门远行，在一番艰难跋涉后，王子在荒野中迷路了，他仿徨了几天，终于有一天他发现了一个村落</p>
<p>这个村落贫瘠弱小，王子注意到他们大量以烤制生肉，野菜，甚至昆虫而食，他们没有国王或者地位高于其他居民的人，尽管如此，他们的脸上却常常洋溢着笑容</p>
<p>王子作为外来人并没有对这些野人产生太多影响，于是他也学着野人的样子，用茅草和树枝搭起简易的居所，尝试融入野人的生活</p>
<p>一个月后，当国王派出的宫廷军顺着王子迷路时留下的标记找到他时，王子正喃喃自语道：我要找到的道路，就在这里啊</p>
<p>归国后几月，王子继位成为了国王，他实现了自己的诺言，在他的治理下，他的子民过上了物质丰富，精神充足的生活——凭借着王子制定并实现的驯养土著成为奴隶的方法。建立帕索斯帝国后五年，王子临终，面对伏在病榻前痛苦的子孙，他淡淡地说：他们以前就没有国王，以后也不会有吧。随后他保持着沉默，任凭御医记录他由有到无的脉搏直至最后</p>
<p>帝国历364年，历经三百年的不懈斗争，萨曼人杰出的领袖终于为族人争取到了自由，帝国，这一最先实现奴隶制的国家，最终成为了民主共和的起源……              ——《帝国通史》</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉世界观轶事集</title>
    <url>/2023/09/29/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E8%BD%B6%E4%BA%8B%E9%9B%86/</url>
    <content><![CDATA[<h2 id="泰特斯"><a href="#泰特斯" class="headerlink" title="泰特斯"></a>泰特斯</h2><p>正如童话故事常见的开头一样，泰特斯是个贫穷而有志气的青年，有一天当他在王国的大街上闲逛时，他遇到了公主的轿子，年轻的泰特斯对美丽淑慧的公主一见钟情，他下定决心一定要当上王国的驸马爷。</p>
<span id="more"></span>
<p>当时开国皇帝恩西斯去世没有多久，年轻的皇帝卡奥斯也是为年轻气盛的青年，泰特斯认为这是成为皇帝亲信的好机会。</p>
<p>当时无权无势的人想要上位有两种办法，一是参军博得战功，二是进入帝国大学谋求文官职位，泰特斯身体虚弱，而且厌恶战争，但却有个不错的头脑，于是在他刻苦攻读下终于进入了帝国的最高学府学习数学，十年后，泰特斯已经是位小有名气的数学家了。</p>
<p>新帝卡奥斯是个奇怪的皇帝，他不甚喜欢锦衣玉食,也不爱美人或者诗琴书赋，唯独对数学很感兴趣，帝国的数学家往往是些老古董，唯有泰特斯名声卓著，血气方刚，二人一见如故，泰特斯如愿以偿成为皇帝的亲信。</p>
<p>卡奥斯将各项赋税与各种工程的设计实施交给了泰特斯，结果无不让他满意，为了表示对泰特斯的欣赏，皇帝决定将自己的妹妹嫁给他。</p>
<p>当公主府的使臣带着婚书拜访泰特斯时，他礼貌而不失坚决地回绝了，此时在他看来任何不懂数学之美的人都是庸俗的，除了数学女神的青睐，他对任何女人不屑一顾。</p>
<p>当然，这件事传到了皇帝的耳朵里，同时传导的还有群臣的议论，皇帝敏感地察觉到在大部分人眼中泰特斯才是帝国最聪明的人，心怀不满的皇帝半强迫地让公主嫁给了泰特斯。当然，皇帝并不无情，否则如果他将所有比他强的数学家都杀了，那么帝国早就没几个大数学家了——要知道他的水平只是二流的</p>
<p>为了自己与泰特斯的安危，贤惠的公主规劝丈夫，聪明的泰特斯恍然大悟，从此以后他收敛锋芒，沉迷于公主府奢华的生活，最终，他与公主幸福地生活到了最后。</p>
<p>泰特斯关于数学研究的遗著于共和历11年首次出现在公众面前，最后屡经辗转进入了共和国首都博物馆的展馆 </p>
<h2 id="黎明"><a href="#黎明" class="headerlink" title="黎明"></a>黎明</h2><p>外交官是位三十出头的年轻人（就他的职位而言），一个月前，他被尊贵的皇帝陛下召见，并被赋予和葛雷氏族谈判的任务。他精于谈判之道，自从帝国决定用经济而不是武力的手段来征服那些遮布隆（帝国语，未开化的人）他变成了谈判桌上最可怕的对手，有人说他的鹰眼能轻易看穿对手的心理底线，有人说他的眼线分布各地，实际上，在外交官的心中，他的才能无关轻重，仅仅是帝国的威亚所致罢了，在早先的黑暗岁月中，遮布隆大多被帝国的屠杀，谎言与掠夺打败。</p>
<p>葛雷族有着一支装备精良的武装，他们背靠大陆大方最大的矿系，然而在帝国面前，这一切毫无意义，诚然，他们完全可以炸毁矿道，但那并不能躲避他们沦为帝国仆从的命运。</p>
<p>当我走进葛雷族的营地时，几乎所有人都对我怒目而视，其中大多是野性，却也带着几份文明，族长是位很硬朗的老人。</p>
<p>“知道吗，按我们的习俗，只要学到知识，就是师徒，你毕业于帝国大学，而我读过帝国大学出版的书，所以我们应该是师兄弟”</p>
<p>我对这老人不合时宜的幽默搞得一点摸不清头脑，“过来，我想让你看个东西”老人领着我向营地的深处走去，在巨大的仓库群前停了下来。</p>
<p>当他打开大门的时候我就知道了——金子，宝石，帝国经济体系中不可或缺的存在，自此帝国历234年定下贵金属和帝国货币的兑换关系后，它们就成了帝国最坚实的支柱。</p>
<p>“这是祖先为我们留下的，留着我们营地的大约只有十分之一””</p>
<p>“你们没有告诉我们这里的矿脉有黄金和宝石？”</p>
<p>“我现在不是告诉你们了吗？”</p>
<p>“……”</p>
<p>“你们帝国的经济命脉就是流通在市场上的黄金吧，如果这种规模的黄金瞬间涌入你们的市场，会发生什么？”</p>
<p>“……”</p>
<p>“好了，开始谈判吧”</p>
<p>历时3天的谈判后，帝国开出了有史以来最宽松的条件，葛雷族的所有自治权予以保留，唯一的条件是，必须与帝国展开全方面的贸易</p>
<h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只是两个小人物的故事</span><br></pre></td></tr></table></figure>
<p>一般来说，这年头很难遇到算命的，至于在酒吧里看到算命的就更少见了，用算命来骗酒喝已经是不知多少年前的老故事了，然而，在此时此刻，却有两个中年男人在酒吧里对饮。</p>
<p>“你是刚来这座城市吗？”</p>
<p>“恰恰相反，我在这待了很多年了”</p>
<p>发问者并没有追问</p>
<p>“你活过3000帝国币吗？”</p>
<p>莫名其妙的问题，乡巴佬的叫法，发问者心想，一时间他不知对方是什么意思</p>
<p>“我的父亲在活到566布朗时咽了气，他本指望着活到700布朗的，呵呵，然后我就到这里来了”</p>
<p>和一个不知从哪个穷乡僻壤来的家伙聊天或许能让自己以后酒场吹牛添一些料，中年人想，于是他决定听下去。</p>
<p>“来到这里后，一时间我很不适应，你们似乎总喜欢用在时间和空间上均匀分布的事物当做度量的标准，真是奇怪”</p>
<p>提问者忍不住做出了回答“你是说你们甚至没有时空的概念？”</p>
<p>“用你们的话说，我们的时间是经济学，空间则是社会学。当然，你们的语言和概念是无法完全解释的，300克朗昭示着步入成年，数不过来的人意味着一个国家，扎在一定的一堆人意味着一个省，这只是比喻。”</p>
<p>他自嘲般地说“我来的时候觉得在那地方我始终是客子，来到这里后又感觉并非家乡”</p>
<p>窗外一只先前飞走的蝴蝶盘旋一圈后又回到了树梢。</p>
<p>“知道吗？你会活过394杯酒。”他没头没脑地说了一句。</p>
<p>另一位中年人沉默着，他每周的同一时间都会来这里点一杯酒。</p>
<p>“而我，会活过自己度量过的第1944位客户”</p>
<p>“你指望我为你的疯话付钱吗？”</p>
<p>”我不适应你们的语言，我也不适应你们的思维……每一秒，每一厘米对你们而言都是无法更改的，你为什么觉得作为我故乡度量——金钱是能更改的呢？对你来说这是一天，对我而言这是6帝国币，二者都是神圣不可更改的。”</p>
<p>中年人有些可悲地看着他“你需要去补补数学和物理的课”</p>
<p>“我只想知道自己该用什么来度量”他显得有些颓废。</p>
<p>“结账，他那杯也算我的”占卜师指着中年男人桌上的酒，向服务员喊道。</p>
<p>占卜师离开酒吧的背影显得并不年轻，“我是他的第几个客户？”中年男人想到。</p>
<p>中年人从此再也没有喝过酒，一年后，一种以果汁为主成分的硬饮料在帝国风靡一时，中年人在一次应酬中举起了一杯苹果汁，当他察觉到一丝酒味后已经晚了，作为一个厌恶半途而废的男人，他选择一饮而尽，随后咽了气。 </p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls人物解析</title>
    <url>/2023/09/29/black%20souls%E4%BA%BA%E7%89%A9%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="尸龙贾巴沃克"><a href="#尸龙贾巴沃克" class="headerlink" title="尸龙贾巴沃克"></a>尸龙贾巴沃克</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在天之繁星哟！命数已定之众哟！尽管去为爱所煎熬吧，为嫉妒之苦吧！呜呼！感激涕零吧！为这幸灾乐祸暗黑舞台点缀色彩就好！！！</span><br></pre></td></tr></table></figure>
<p>象征着腐败与神秘的紫黑色，遍布全身的缝合痕迹与绷带，恶魔一样的卷曲角，晦暗如死尸的肤色，以及左眼燃烧着的灵魂之火（致敬黑岩射手可能性微存），<code>尸龙</code>姐姐的人物形象无时无刻不在传达着神秘强大而阴暗的气氛，本视频将对<code>尸龙</code>的整个人物进行解析</p>
<span id="more"></span>
<p><code>尸龙</code>在爱丽丝镜中奇遇的原型是一首小诗，这首诗的大意是勇者手提沃伯尔之剑斩杀邪龙<code>贾巴沃克</code>，游戏中也承袭了这一设定，<code>贾巴沃克</code>一直都以死尸的形象登场<br>要解析这一角色，我们首先从最直接的行为说起，按游戏的时间线，<code>尸龙</code>姐姐大概做了以下这些事<br>1把童话（具体哪本未知，根据混沌迷宫的狼外婆信息推测可能是小红帽）给了渴望母爱的玛丽.苏，从而激发了虫虫的创作能力，导致她创造出一代的箱庭。顺便一提，关于<code>尸龙</code>和<code>玛丽苏</code>的关系，游戏里没有直接证据支持姐妹说，混沌迷宫提到黑山羊有两个子嗣，米兰达认为<code>尸龙</code>有黑山羊的气息，且明显<code>尸龙</code>和<code>玛丽苏</code>有一定关系，这些是确定的，但并未明说姐妹，有人从克苏鲁的设定中寻找论据，但本人对克系了解不多在此不评价。<br>2红偶像约会中电影《三人的茶会》提及茶会时期的三人曾经打倒过贾巴沃奇，不知是否和<code>尸龙</code>有关，此外<code>尸龙</code>也曾被昔日的勇者，如今的猎头兔打倒，自称在之后洗心革面，但相关资料太少，我们不知道是不是她放水或另有隐情<br>3格林被引导进<code>玛丽苏</code>的箱庭开始一代的故事，此时<code>尸龙</code>（不知道<code>玛丽苏</code>是否知情）已经乱入到一代的不思议之国，为格林一行人提供帮助，通关d结局后找她对话，她会直接把二代给剧透了，不过由于时间线上d结局应该直接接上二代，所以“正史”上可能没有这件事，顺便一提，一代的不思议之国是爱丽丝的箱庭，或者说<code>玛丽苏</code>的仿造品，也没有定论，所以很难推测<code>尸龙</code>是入侵还是本来就在那里<br>4来到二代时间线，由于不思议之国是奈亚的箱庭，而黑山羊则是奈亚的“配偶”，所以<code>尸龙</code>出现在这倒是理所应当，此时的<code>尸龙</code>以四噩梦之一的身份登场，，但工作内容则是在卡罗尔川上堆雪人，以及在格林面前装出温柔大姐姐的形象，十足的关系户做派。<br>里路线中，格林和米兰达等人可以先后对战三噩梦，以及杀死其余两个噩梦后现出真身的<code>尸龙</code>，值得一提的是这似乎是她全系列中唯一一次全力出手，并且在此战中死亡，但考虑到支配者的特性，是否死透了依旧存疑<br>以上就是<code>尸龙</code>在系列中的行动，接下来我将对这些行动的目的与<code>尸龙</code>的性格进行归纳。<br><code>尸龙</code>首先是一个安静的观察者，一代中她只是在一棵树下扮尸体，二代则在河边堆雪人，如果格林不找她，在里线之前不会和她有任何交集，然而，隐藏和善表面下的真相是<code>尸龙</code>其实是个性格扭曲唯恐天下不乱的乐子人，是她启发了<code>玛丽苏</code>创造自己的黑童话箱庭，间接引发之后所有的故事，而一开始的目的可能只是以<code>玛丽苏</code>面对求而不得的母爱痛苦挣扎的样子为乐，也是她诅咒了狩猎邪龙的英雄，使兔子一族成为贪食尸体的魔兽，其中被沃波尔斩下头颅可能是她行事风格的分界线，其自述死前曾是无恶不作的邪龙，在复活后变得收敛，但其实依旧不改邪龙本质，只是变得只在关键时刻推波助澜<br>而将这两种性格统一起来的则是她的创作欲，没错，和<code>玛丽苏</code>一样，<code>尸龙</code>对创作也有自己的执念，在<code>玛丽苏</code>涌现起黑暗的创作力之后，<code>尸龙</code>意识到，<code>玛丽苏</code>那邪恶的灵魂一定程度其实是自己的作品，如果说<code>玛丽苏</code>是支配者中第一个创造故事的人，<code>尸龙</code>就是第一个“创作者”，这激发出她内心最深层的欲望，那就是创作出足够黑暗污秽的灵魂，方法则是让一个灵魂在无尽的痛苦与求而不得中循环。<br>可以说在这点上<code>尸龙</code>和奈亚有一定的共同点，就是让格林经历无数次的痛苦循环，但二者还是有着分歧，奈亚想要的是格林求而不得的爱，<code>尸龙</code>则想要格林本就污秽的灵魂更加黑暗。<br>这时我们就可以理解<code>尸龙</code>的行为了，由于里线实际上也处于轮回之中，所以对<code>尸龙</code>来说，告诉格林一些真相只会让他的反抗更加激烈，也会在反抗之后更加绝望，这样才符合她的目的。<br>而以上依旧是<code>贾巴沃克</code>的表层性格，而她隐藏最深的性格则是扭曲的独占欲，在卡罗尔川的地牢中有个四个雪人，分别是<code>玛丽苏</code>，小红帽，爱丽丝和格林，此外，班达斯奈奇的住处也有着一个写着想将其变为收藏品的雪人（sen0才能看到真相），可见<code>尸龙</code>内心最深的欲望其实是独占欲，培育最污秽的灵魂，随后将其收藏起来，这才是<code>尸龙</code>的愿景，但她为何要隐藏这一欲望呢，在qf<code>尸龙</code>失败的逆监禁剧情里，由于<code>尸龙</code>发现格林的灵魂已经黑暗到想要独占自己，<code>尸龙</code>就会唯一一次直接暴露自己的独占欲来收割这个丰硕的成果，然而，奈亚或者其他支配者绝不会容忍这种行为，所以一旦<code>尸龙</code>试图独占格林就会立刻被排除出世界，这就是<code>尸龙</code>一直压抑着独占欲的原因。<br>此外，根据dlc3入口处的对话以及数量庞大的雪人，或许可以猜测<code>尸龙</code>曾经一边观察一边玩弄过很多灵魂，但这些灵魂最后都因为经历过多的痛苦和绝望后变得麻木，因此才会对有着无穷成长性的格林视若珍宝<br>一切温柔的言语都不过是为了将格林引导向更绝望的结局，独占污秽的黑之魂，玩到腻后就扔掉，对<code>贾巴沃克</code>之魂的描述为包藏在虚伪的母性之下的独占欲之影可谓恰如其分。<br>值得一提的是，独占欲这种感情不止在<code>尸龙</code>一人上出现，大部分支配者都有着这种感情，如白之女王诺登就承认自己多次有独占格林的想法，爱丽丝01也曾吐露自己害怕不可控制地想要独占格林，但她们与<code>尸龙</code>的区别则是，她们能够理解人类的爱，并为了人类的幸福选择放手，与红白女王的对比或许也是<code>尸龙</code>人物形象设计的一个目的<br>现在可以做一个总结了，<code>尸龙</code>姐姐是一个对格林有着强烈爱意的角色，她的母性是虚伪的，但这种爱意却不是，尽管她扭曲，残酷，自私，虚伪，但是她始终知道自己要做什么并理性地付出行动，即使失败了也不失风度从容自若，相较于虫虫几乎写在脸上的扭曲性格，直截了当的作恶行径，以及一有挫败就大呼小叫的行径，<code>尸龙</code>的感情更加内敛，行事也更加隐秘，但可谓是个很有恶人魅力的反派角色<br>同时，由于bs的碎片化叙事并且尚未完结，关于<code>尸龙</code>依旧有很多谜团，例如她和<code>玛丽苏</code>以及其他支配者的具体关系，里线中她是不是仍然在演戏，她究竟为何会给<code>玛丽苏</code>童话书，<code>尸龙</code>等三噩梦和三个爱丽丝的关系等等，就期待续作的解答了<br>大家都来和<code>尸龙</code>姐姐做朋友吧，尸门</p>
<h1 id="玛丽苏"><a href="#玛丽苏" class="headerlink" title="玛丽苏"></a>玛丽苏</h1><p><code>玛丽苏</code>，作为bs中自称的女主角，是bs唯二个三代都有出场（包括红森）的支配者，还有一个是<code>贾巴沃克</code>），在此过程中做过的好事可谓数不胜数，罄竹难书，我们来按着时间线整理一下<br>1一开始的<code>玛丽苏</code>是个渴望母爱的孩子，尽管我们不知道bs设定下一开始的支配者到底会不会有类似人类的亲情，她掌管自己的世界，倾听子民的祈祷，开始感到厌烦，这时<code>贾巴沃克</code>不知出于什么目的，送了她一本童话书，这本书，我们不知道是哪个童话，但本人猜测很可能这本书的作者是<code>玛丽苏</code>第一个抓住的，并在黑之魂的融合中有重要地位，根据青鸟的文本，卡罗尔并不是第一个抓住的素材，所以基本可以排除梦游仙境，结合男主角格林的名字和混沌迷宫的狼外婆，我个人猜测是小红帽，她开始渴望创作自己的故事来打动母亲，至少一开始是这样，她派遣属下四处收集童话作者的灵魂作为素材，同时肆意进行同人创作。<br>2<code>玛丽苏</code>的处女作是小红帽，也是她第二得意的作品，根据一些信息，小红帽的灵魂可能以现实世界的一个女学生为素材，在魔改剧情的同时，她还给了小红帽注定20岁早逝的设定，并可能赋予了小红帽通过镜子穿梭位面之类的特殊能力来担任女主角，但不知道为什么她又不满意，想做一个男主角出来，但她对小红帽的善后却颇有些问题，小红帽不仅杀穿了红森，而且还能意识到她这个黑幕的存在。<br>3缝合了众多童话作家灵魂的格林诞生了，并被赋予了给周围的女主角带来不幸的设定，格林污秽的黑之魂有成为支配者的潜质，<code>玛丽苏</code>甚至还大胆地保留了他的部分创作能力，因为最关键的改变权能在她手上，为什么叫做格林则未知，可能是最初的童话书就是格林童话的一本，这之后格林不知道为什么，以什么身份在一个叫不思议之国的地方和叫爱丽丝和祈祷主的存在开起了茶会，随后格林与爱丽丝01相恋，嫉妒的祈祷主呼唤了<code>玛丽苏</code>，导致格林被带走了，连同格林不知何时创造出的故事们也被篡改<br>4基于以上提到的各种童话故事素材，<code>玛丽苏</code>魔改出了失落帝国的箱庭，把格林放进去经历一次次绝望故事的轮回，自己则担任女主角欣赏故事，还设计把母亲叫了进来欣赏自己的大作。不知多少次循环后，这个大好局面被打破了，母亲黑山羊为了逃离这个世界和她战斗，连圣森都磨灭了，战胜母亲后，奈亚丽丝前来捡漏带走格林进行新一轮追寻爱的游戏，本来想顺带着把<code>玛丽苏</code>也灭了，但在诺登的劝阻以及可能的其他考量下放过了她<br>5奈亚，红女王，白女王中的某位或若干位剥夺了她的改变权能，把她囚禁在库因兰德，失去权能的她改名为玛丽安，但不知何时也不知何人前来探访了她，到格林试图从梦中醒来的里线，玛丽安乘乱逃出，由于正史上不太可能发生f结局，所以此时应该是g结局，也有可能正史上g结局有少许与游戏不同，不管怎么说此时的玛丽安应该被格林小红帽两人打败，但h结局中可以看到她没有死，而且不知道怎么逃了出来<br>可以说，bs中的一切悲剧，<code>玛丽苏</code>至少有五成功劳，接下来让我们来分析一下<code>玛丽苏</code>的角色特质。<br>首先，最直接的一点，<code>玛丽苏</code>是个典型的支配者，高高在上地支配着人类这样的低等种族，但<code>玛丽苏</code>特殊之处在于，她可能是最能理解人类感情的支配者之一，首先我们就可以看到她居然渴望所谓的母爱，而根据2代大部分支配者的表现，即使因融入皮套逐渐有了感情，也没有第二个有亲情这种非常类似人类感情的支配者，此外，她还以玩弄人类的灵魂为乐，当然有这种兴趣的支配者恐怕不少，但这股风气可以说是<code>玛丽苏</code>带起来的，也是她最先玩出各种花样。<br>因此可以引出<code>玛丽苏</code>的第二个特点了，她是很像人类的一个支配者，尽管理解非常片面，但她确实懂得并拥有不少人性，而她为什么这么喜欢玩弄人类呢？这也很容易理解，一般来说越通人性的动物越被人类亲近，逗猫逗狗远远比逗蚂蚁有意思，因为这些宠物的智力和人类更接近，人类可以很容易地理解它们在想什么，然后在逗弄它们的过程中获得一种智力上的优越感，以及一种“支配感”，这恐怕就是<code>玛丽苏</code>看到自己编排的好戏上演的感觉。<br>这点可以说是我们对<code>玛丽苏</code>进行解析的基石，毕竟任何角色首先都是人的投影，而人性越丰富，就有越多的性格侧面。<br><code>玛丽苏</code>第三个特点就是由此衍生的纯粹性，当然，此处并不是说纯洁善良云云，而是某种意义上的纯粹之恶，很多支配者在扮演人类后都会被皮套影响而恐慌或纠结，但<code>玛丽苏</code>却没有这种烦恼，她以融入人类扮演人类为乐（小精灵也算类人种族），她作为支配者的漆黑本性和人性之恶完美地兼容了，不会有徘徊二者之间的身份认同问题，而她大部分所作所为也就是为了践行人性之恶，什么是恶呢，比较狭隘的解释就是为了为了自己的利益或者取乐而伤害他人，而<code>玛丽苏</code>的邪恶就很纯粹，就是为了取乐，甚至有损自己利益也要作恶，如果解救了被囚禁的<code>玛丽苏</code>，此时她会自认为东山再起，但她想的不是第一时间抹杀已经成长了的格林或者藏起来，而是想再让格林经历一次悲惨的故事，可以说她作恶的动机相当纯粹，也相当执着。<br>在此之上的第四个特点，就是她的创作者身份，很多支配者都会赞扬她的创作能力，连奈亚构建的不思议之国都有不少<code>玛丽苏</code>箱庭的影子，但这种创造力也只是对于支配者来说了，如果我们用人类的视角看如何呢？寿司在访谈时轻蔑地说到“她说到底也只是<code>玛丽苏</code>，也只能整点二次创作了”可以说道出了<code>玛丽苏</code>所谓创作的本质，说到底，<code>玛丽苏</code>就是那种典型的黑深残小鬼，把一个可能有很多种解释的作品曲解为单一的猎奇世界观，当然不是说这样不行，如果原创一个黑深残世界观自娱自乐当然是可以接受的，但<code>玛丽苏</code>的行为就是最恶劣的一种同人女行为，魔改原来的作品，把自己做成角色代入进去搞cp，还要把所有其他角色踩一遍，情节和人物关系只要对自己代入的角色有利就行，然后把这部除了自己看谁也不会喜欢的同人拿给原作者看，我就不详细说这种行为的恶劣程度了，但这种作品折射出来的创作观我必须要辩驳一下。<br>当然，本视频所有讨论只局限于二次元文化内，<br>荒木飞吕彦认为漫画有四要素，角色、剧情、世界观、主题，我们就用这四个维度来剖析<code>玛丽苏</code>的所谓创作。<br>首先是角色，直接创作一个鲜活的灵魂对强大的支配者来说也是一件难事，所以对于角色的选取，<code>玛丽苏</code>很可能都是使用现实存在的灵魂然后再魔改来适配进童话或者传说的人物，因此她笔下所谓角色虽然很多但其实并不是她自己的功劳，而她为了把这些灵魂塞进角色对设定随意删改，把小红帽的外婆和母亲缝成了一笔烂账，人物关系更是一团乱麻，怎么方便怎么来，角色设定连基本的自洽也做不到，水平着实不敢恭维<br>随后是世界观，失落帝国这个箱庭本质上来说就是个童话故事的缝合体，没有历史演化，没有详细设定，这并不是一个鲜活的世界观，只不过是一个临时搭建的舞台而已，当然，很多线性的故事并不需要一个多详尽的世界观，在这点上<code>玛丽苏</code>只能说无功无过<br>最后是剧情和主题，<code>玛丽苏</code>的主题是简单粗暴的黑深残，剧情则是当常规的rpg剧本演到最后的happy end时毫无铺垫伏笔地急转直下变成bad end，当然，能设置这么大规模的箱庭，还写了不少支线剧情，证明<code>玛丽苏</code>确实是有一些笔力的，但首先，她的角色基本靠抓人，故事则都有童话原型，故事演变她只需要把握大方向，其他可以让角色自己来，而最后没有任何铺垫的bad end依旧表明了她创作的失败，如果一个设定没有任何铺垫和暗示，直到使用时才抛出，那只能证明这部作品情节编排的失败，因为一部作品的生命周期不是作者创作出来就结束了的，而要等到读者看完理解了故事才会结束，这个过程作者读者应该处于相对公平的地位，根据故事的设定，人物有充分的理由这样行动，这样才能让读者认同这个故事，而<code>玛丽苏</code>却完全相反，滥用作者的权能让故事不仅没有逻辑，还自相矛盾，很明显，对<code>玛丽苏</code>来说她是作者也自认为是唯一的读者，那些被抓走被改造的灵魂不过是用完即扔的工具罢了，不需要自圆其说，只要自己看得高兴就行了，或许就支配者的立场来说她不过是自娱自乐罢了，但对人类（至少灵魂上是人类），以及同样作为创作者的格林来说，首先就绝不可能认同这种恶行，更不可能认同自己的作品被改成这样的烂作<br>说到这里，就可以讨论一下<code>玛丽苏</code>对于格林的看法了，直观地说，是<code>玛丽苏</code>创造了名为格林的污秽黑之魂，但其实在最初，是格林等童话作家激发了<code>玛丽苏</code>的创作欲，因此，事实上，两者是相互创造的关系，<code>玛丽苏</code>创造格林的目的，首先是为了成为她作品的男主角，让她能够代入女主角的位置欣赏这个故事，这样说来似乎格林除了男主角的身份和其他角色也没什么本质的不同。但格林还有一点对<code>玛丽苏</code>有着重大意义，就是他童话作家灵魂集合体的身份，即使自我中心如<code>玛丽苏</code>这种存在，也会有对别人欣赏自己作品的渴望，因此<code>玛丽苏</code>特地设置了一个c结局，用演戏的形式让格林得以了解她的整个创作生涯，至于目的，除了单纯的表现欲和欣赏格林的痛苦以外，恐怕也有一丝希望作为原作者的格林认同自己的心情，哪怕是厌恶，<code>玛丽苏</code>也想得到一些对创作的反馈，而格林是唯一能在创作这个领域和她有一些共鸣的人，作者，读者，男主角，格林三位一体的身份对<code>玛丽苏</code>来说，可以说是难得的知己，尽管这种关系非常扭曲，但不能否认，在这点上<code>玛丽苏</code>作为创作者的心情是有些真心的。而<code>玛丽苏</code>会渴望认同这点，一开始是希望得到母爱，但在得到格林这个玩具之后，<code>玛丽苏</code>就一点也不在意黑山羊的死活了，这也是佐证。<br>最后不得不提的是，<code>玛丽苏</code>的特殊性质，很大程度上她是寿司这个作者的投影，我个人觉得<code>玛丽苏</code>这个角色有不少表达寿司自己创作观的成分，这也解释了寿司为何这么偏爱她当然，一部好的作品，任何角色都是基于自己的设定和世界观行动，不可能因为是作者的投影就有特别待遇，所以可以说，<code>玛丽苏</code>虽然很大程度上是寿司的投影，但投影的目的其实是对比，<code>玛丽苏</code>的创作肤浅，笔下的故事只是无聊的黑深残，但寿司却喜欢在绝望时写一些希望，在希望中铺设绝望，最后的反转再怎么说都是有因可循，单论创作的层次来说就高出绿虫子太多了，当然，我也不是在吹寿司笔力多高，因为高出<code>玛丽苏</code>这个水平的创作者多如牛毛。<br>寿司设置<code>玛丽苏</code>这个角色，其实是使用了一种嵌套的结构来讲故事，首层是童话的原作，这些是毋庸置疑的好故事，随后是虫子和奈亚魔改出的箱庭，是烂故事的典型，最后一层寿司想讲的重点其实是格林怎么察觉真相，挣脱出烂故事的循环，书写自己的结局的故事，在这三层中，第一层<code>玛丽苏</code>是读者，格林等人是作者，只出现在设定层面，第二层<code>玛丽苏</code>是一半作者一半角色，格林是一半读者一半角色，体现在abc结局，最后一层中寿司是唯一的作者，<code>玛丽苏</code>和格林就都是角色了，体现在d结局以及之后的二代，这种层层演变虽然有些炫技，但确实非常有意思。<br>就<code>玛丽苏</code>这个角色而言，整个泛二次元文化里她这样的反派也不常见，究其原因，则是因为一个有能力玩弄主角取乐的boss必然会导致战力失衡，冲突不起来，让读者感到憋屈，因此想要打败这种boss要么机械降神唯心爆发，比如一代c结局（虽然是演的），要么引入新的boss和同伴体系取代她如d结局，也因此，虽然我个人很喜欢一代，但一代的真结局d结局远没有2代h结局震撼<br>来做个总结吧，<code>玛丽苏</code>无疑是个纯粹邪恶的支配者，一个烂到骨子里的创作者，她作为创作者无疑是失败的，但作为bs这个故事里的角色反而是很成功的，不仅纯粹有特点，还有很多角色侧面可以挖掘，寿司巧妙地利用她读者，创作者和角色的三重身份来塑造她的多面性，颇有荒木在漫画术中写的“在作恶道路上高歌猛进”的成功反派角色风格。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>基于斯坦福cs106b的c++数据结构笔记</title>
    <url>/2023/09/29/cs106b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一些查找和排序算法"><a href="#一些查找和排序算法" class="headerlink" title="一些查找和排序算法"></a>一些查找和排序算法</h2><p>二分查找法<br><img src="/images/obsidian/20230226101843.png" alt="图片" title="image"><br>最坏情况：log2n</p>
<span id="more"></span>
<p>寻找最小排序<br><img src="/images/obsidian/20230224172126.png" alt="图片" title="image"><br>向前插入算法<br><img src="/images/obsidian/20230226090109.png" alt="图片" title="image"></p>
<p>合并算法接受两个排序的 列出并将它们组合成一个 排序列表。 ● 虽然两个列表都是非空的，但比较它们的 第一要素。 删除较小的元素 并将其附加到输出。 ● 一旦一个列表为空，添加所有元素 另一个列表输出。 ● 它运行时间为 O(n)，其中 n 是总数 合并的元素数量。<br><img src="/images/obsidian/20230226090958.png" alt="图片" title="image"><br>无限递归后的合并算法<br><img src="/images/obsidian/20230226093232.png" alt="图片" title="image"><br>复杂度：nlog2n</p>
<h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p><code>set（集合）：无序不允许重复的容器类，可以添加删除元素 You can add a value to a Set by writing   set += value;  s. ● You can remove a value from a Set by writing   set -= value;   ● You can check if a value exists in a Set by writing   set.contains(value) </code>map(键值对的集合)<br>如果没有对应key的value，返回默认值（见定义文件）<br>&#96;vector<br>vector的remove根据移除元素的索引有1-n的复杂度，移除尾部为O(1)，如果不在意索引，可以交换要移除元素和尾部元素再移除</p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表的负载因子α表示元素和表格键数量的比，决定了查找速度</p>
<h2 id="检查表中是否存在元素"><a href="#检查表中是否存在元素" class="headerlink" title="检查表中是否存在元素"></a>检查表中是否存在元素</h2><p>● 计算元素的散列码。<br>● 跳转到表格中的那个位置。<br>● 向前扫描——必要时环绕——直到项目或一个 发现空插槽。</p>
<h2 id="将元素插入表中"><a href="#将元素插入表中" class="headerlink" title="将元素插入表中"></a>将元素插入表中</h2><p>● 如果项目已经存在，什么也不做。<br>● 否则，跳转到元素哈希码给定的槽。 向前走——必要时环绕——直到一个空白点或 找到墓碑插槽。 然后，将项目放在那里。</p>
<h2 id="从表中删除一个元素"><a href="#从表中删除一个元素" class="headerlink" title="从表中删除一个元素"></a>从表中删除一个元素</h2><p>● 跳转到由元素的散列码给定的槽。<br>● 向前走——必要时环绕——直到物品或 发现空插槽。 如果找到该项目，请将其替换为 墓碑。</p>
<h2 id="“罗宾汉哈希表”"><a href="#“罗宾汉哈希表”" class="headerlink" title="“罗宾汉哈希表”"></a>“罗宾汉哈希表”</h2><ul>
<li>如果插入的值比其将插入的位置的值距离索引更远，则替换插入值和当前值</li>
<li>删除值时，将后其离原键远的元素前移</li>
<li>★ 罗宾汉哈希一览 ★</li>
<li>检查表中是否存在元素：</li>
<li>● 跳转到表中由元素的散列码给出的位置。</li>
<li>● 向前扫描——如有必要环绕——记录有多少步 你拿走了。 当您找到该项目、找到一个空白槽或找到一个 离家更近的空位比你走的步数还多。</li>
<li>将元素插入表中：</li>
<li>● 如果该元素已在表中，则什么也不做。</li>
<li>● 跳转到由元素的散列码给出的表槽。 向前扫描 - 换行 如有必要，四处走走——记录所走的步数。 如果你找到一个 空插槽，将元素放在那里。 否则，如果当前插槽已满并且 比您插入的元素更靠近家，将要插入的项目放在那里， 替换那个位置的元素，然后继续插入，就好像你 正在插入被置换的元素。</li>
<li>从表中删除一个元素：</li>
<li>● 跳转到由元素的散列码给定的槽。</li>
<li>● 向前走——如有必要，环绕——直到物品或空槽被放置 成立。 如果找到该项目，请将其删除。 然后，继续前进——包裹 around as necessary – 将表中的元素向后移动一个槽位，直到 找到空插槽或位于其原始位置的项目</li>
</ul>
<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>str::npos表示容器的最后一个成员位置<br>if (s.find(“e”) !&#x3D; string::npos)<br>&#x2F;&#x2F;find函数找不到时返回npos<br>if s in str:<br>string obj;<br>obj.substr(int pos)   &#x2F;&#x2F;pos为要包含的第一个字符串的位置<br><a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> a &#x3D; “0123456789abcdefghij”;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    // count is npos, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub1 = a.substr(10);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub1 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // both pos and pos+count are within bounds, returns [pos, pos+count)</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub2 = a.substr(5, 3);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub2 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // pos is within bounds, pos+count is not, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub4 = a.substr(a.size()-3, 50);</span><br><span class="line">    // this is effectively equivalent to</span><br><span class="line">    // std::string sub4 = a.substr(17, 3);</span><br><span class="line">    // since a.size() == 20, pos == a.size()-3 == 17, and a.size()-pos == 3</span><br><span class="line"></span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub4 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // pos is out of bounds, throws</span><br><span class="line">        [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub5 = a.substr(a.size()+3, 50);</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub5 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125; catch(const [std::out_of_range](http://en.cppreference.com/w/cpp/error/out_of_range)&amp; e) &#123;</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; &quot;pos exceeds string size\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">abcdefghij</span><br><span class="line">567</span><br><span class="line">hij</span><br><span class="line">pos exceeds string size</span><br></pre></td></tr></table></figure>
<p>&#96;replace和insert<br>str1.insert(start, str2)<br>str1.replace(start, length, str2)</p>
<h2 id="一些实现"><a href="#一些实现" class="headerlink" title="一些实现"></a>一些实现</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &quot;HeapPQueue.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">HeapPQueue::HeapPQueue() &#123;</span><br><span class="line">    elems = new DataPoint[INITIAL_SIZE] &#123;&#125;;</span><br><span class="line">    for (int i=0;i&lt;INITIAL_SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[i].weight=0;</span><br><span class="line">    &#125;</span><br><span class="line">    allocatedSize=INITIAL_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapPQueue::~HeapPQueue() &#123;</span><br><span class="line">    delete [] elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int HeapPQueue::size() const &#123;</span><br><span class="line">    return logicalSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool HeapPQueue::isEmpty() const &#123;</span><br><span class="line">    return logicalSize==0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapPQueue::enqueue(const DataPoint&amp; data) &#123;</span><br><span class="line">    if (logicalSize+1&lt;allocatedSize)</span><br><span class="line">    &#123;</span><br><span class="line">        if (logicalSize==0)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[1]=data;</span><br><span class="line">            logicalSize++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            logicalSize++;</span><br><span class="line">            int i=1;</span><br><span class="line">            while (data.weight&gt;elems[i].weight &amp;&amp; i&lt;=logicalSize &amp;&amp; elems[i].weight!=0)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i&lt;logicalSize)</span><br><span class="line">            &#123;</span><br><span class="line">                DataPoint temp=elems[i];</span><br><span class="line">                elems[i]=data;</span><br><span class="line">                for(i;i&lt;logicalSize;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    DataPoint temp_plus=elems[i+1];</span><br><span class="line">                    elems[i+1]=temp;</span><br><span class="line">                    temp=temp_plus;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                elems[i]=data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::peek() const &#123;</span><br><span class="line">    return elems[logicalSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::dequeue() &#123;</span><br><span class="line">    DataPoint to_return=elems[1];</span><br><span class="line">    if(!isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (int i=1;i&lt;logicalSize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[i]=elems[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        elems[logicalSize]=&#123;&#125;;</span><br><span class="line">        logicalSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    return to_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>首先算出最大值，然后用一个数组的索引存储待排序数组的成员，其索引对应值存储出现次数，然后用两个同步的for循环和递增的next参数表示排序中的索引值来进行排序（也就是重新赋值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Given a Vector&lt;int&gt;, returns the largest number in that Vector. */</span><br><span class="line">int maxOf(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Bounds-check inputs. */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        error(&quot;Can&#x27;t find the maximum of no values.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = values[0];</span><br><span class="line">    for (int i = 1; i &lt; values.size(); i++) &#123;</span><br><span class="line">        result = max(result, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a list of numbers, creates a histogram from those numbers. */</span><br><span class="line">Vector&lt;int&gt; histogramFor(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Create a histogram with the right number of slots. Initially, all values</span><br><span class="line">     * in the histogram will be zero.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; histogram(maxOf(values) + 1);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the input vector, incrementing the histogram values. */</span><br><span class="line">    for (int value: values) &#123;</span><br><span class="line">        histogram[value]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return histogram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void countingSort(Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Edge Case: If the array is empty, then it&#x27;s already sorted. This is</span><br><span class="line">     * needed because we can&#x27;t take the maximum value of an empty vector.</span><br><span class="line">     */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Form the histogram. */</span><br><span class="line">    auto histogram = histogramFor(values);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the histogram writing out the appropriate number of copies</span><br><span class="line">     * of each value. We track the index of the next free spot to write to,</span><br><span class="line">     * as it varies based on how many items we&#x27;ve written out so far.</span><br><span class="line">     */</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (int value = 0; value &lt; histogram.size(); value++) &#123;</span><br><span class="line">        /* Write out the right number of copies. */</span><br><span class="line">        for (int copy = 0; copy &lt; histogram[value]; copy++) &#123;</span><br><span class="line">            values[next] = value;</span><br><span class="line">            next++;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><h3 id="递归的效率优化"><a href="#递归的效率优化" class="headerlink" title="递归的效率优化"></a>递归的效率优化</h3><p>每次递归都会创造所有变量的临时复制<br>基于递归的这种性质，它会需要巨大的时间和空间来完成任务，并且会造成算力上的浪费。<br>通过记忆表机制能部分解决这个问题，方法是每次递归的返回值都会按索引存入一个表格，并且每次递归前查询表格中是否有结果，这样可以让每个临时副本的运算结果能被所有函数共享。</p>
<h3 id="递归计算给定元素的不同结构哈夫曼树的数量"><a href="#递归计算给定元素的不同结构哈夫曼树的数量" class="headerlink" title="递归计算给定元素的不同结构哈夫曼树的数量"></a>递归计算给定元素的不同结构哈夫曼树的数量</h3><p>对每个给定元素集来说，首先要做到是确定根节点元素是第几个大的元素，确定之后，左子树和右子树的元素数也随之确定，在此之后分别对左节点和右节点作为根节点做同样的递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int numBSTsOfSize(int n) &#123;</span><br><span class="line"></span><br><span class="line">  /* Base case: There’s only one tree of size 0, namely, the empty BST. */</span><br><span class="line">  if (n == 0) return 1;</span><br><span class="line">  </span><br><span class="line">  /* Recursive case: Imagine all possible ways to choose a root and build the</span><br><span class="line">   * left and right subtrees.</span><br><span class="line">  */</span><br><span class="line">  int result = 0;</span><br><span class="line">  </span><br><span class="line">  /* Put the the nodes at indices 0, 1, 2, ..., n-1 up at the root. */</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    /* Each combination of a BST of i elements and a BST of n - 1 - i elements</span><br><span class="line">     * can be used to build one BST of n elements. The number of pairs of</span><br><span class="line">     * trees we can make this way is given by the product of the number of</span><br><span class="line">     * trees of each type.</span><br><span class="line">     */</span><br><span class="line">     result += numBSTsOfSize(i) * numBSTsOfSize(n - 1 - i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归解决吃巧克力问题"><a href="#递归解决吃巧克力问题" class="headerlink" title="递归解决吃巧克力问题"></a>递归解决吃巧克力问题</h3><h1 id="求出吃法数量"><a href="#求出吃法数量" class="headerlink" title="求出吃法数量"></a>求出吃法数量</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (numSquares&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">    error(&quot;输入数据不能为负数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (numSquares&lt;=1)</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    return numWaysToEat(numSquares-1)+numWaysToEat(numSquares-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印每种吃法"><a href="#打印每种吃法" class="headerlink" title="打印每种吃法"></a>打印每种吃法</h1><p>&#96;需要一个辅助向量储存历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Print all ways to eat numSquares more squares, given that we&#x27;ve</span><br><span class="line"> * already taken the bites given in soFar.</span><br><span class="line"> */</span><br><span class="line">void printWaysToEatRec(int numSquares, const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /* Base Case: If there are no squares left, the only option is to use</span><br><span class="line">     * the bites we&#x27;ve taken already in soFar.</span><br><span class="line">     */</span><br><span class="line">    if (numSquares == 0) &#123;</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If there is one square lfet, the only option is to eat</span><br><span class="line">     * that square.</span><br><span class="line">     */</span><br><span class="line">    else if (numSquares == 1) &#123;</span><br><span class="line">        cout &lt;&lt; soFar + 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Otherwise, we take take bites of size one or of size two. */</span><br><span class="line">    else &#123;</span><br><span class="line">        printWaysToEatRec(numSquares - 1, soFar + 1);</span><br><span class="line">        printWaysToEatRec(numSquares - 2, soFar + 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printWaysToEat(int numSquares) &#123;</span><br><span class="line">    if (numSquares &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me some chocolate!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We begin without having made any bites. */</span><br><span class="line">    printWaysToEatRec(numSquares, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决翻煎饼问题"><a href="#递归解决翻煎饼问题" class="headerlink" title="递归解决翻煎饼问题"></a>递归解决翻煎饼问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isSorted(Stack&lt;double&gt; pancakes) &#123;</span><br><span class="line">    double last = -1; // No pancakes have negative size;</span><br><span class="line"></span><br><span class="line">    while (!pancakes.isEmpty()) &#123;</span><br><span class="line">        /* Check the next pancake. */</span><br><span class="line">        double next = pancakes.pop();</span><br><span class="line">        if (next &lt; last) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Pancakes are in increasing order! */</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a stack of pancakes and a flip size, flips that many pancakes</span><br><span class="line"> * on the top of the stack.</span><br><span class="line"> */</span><br><span class="line">Stack&lt;double&gt; flip(Stack&lt;double&gt; pancakes, int numToFlip) &#123;</span><br><span class="line">    /* Take the top pancakes off the stack and run them into a queue.</span><br><span class="line">     * This preserves the order in which they were removed.</span><br><span class="line">     */</span><br><span class="line">    Queue&lt;double&gt; buffer;</span><br><span class="line">    for (int i = 0; i &lt; numToFlip; i++) &#123;</span><br><span class="line">        buffer.enqueue(pancakes.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Move the pancakes back. */</span><br><span class="line">    while (!buffer.isEmpty()) &#123;</span><br><span class="line">        pancakes.push(buffer.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pancakes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; sortStack(Stack&lt;double&gt; pancakes, int numFlips) &#123;</span><br><span class="line">    /* Base Case: If the stack is sorted, great! We&#x27;re done, and no flips</span><br><span class="line">     * were needed.</span><br><span class="line">     */</span><br><span class="line">    if (isSorted(pancakes)) &#123;</span><br><span class="line">        return &#123; &#125;; // No flips</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If the stack isn&#x27;t sorted and we&#x27;re out of flips, then</span><br><span class="line">     * there is no way to sort things.</span><br><span class="line">     */</span><br><span class="line">    else if (numFlips == 0) &#123;</span><br><span class="line">        return Nothing;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive Case: The stack isn&#x27;t sorted and we still have flips left.</span><br><span class="line">     * The next flip could flip 1, 2, 3, ..., or all N of the pancakes.</span><br><span class="line">     * Try each option and see whether any of them work.</span><br><span class="line">     */</span><br><span class="line">    for (int numToFlip = 1; numToFlip &lt;= pancakes.size(); numToFlip++) &#123;</span><br><span class="line">        /* Make the flip and see if it works. */</span><br><span class="line">        auto result = sortStack(flip(pancakes, numToFlip), numFlips - 1);</span><br><span class="line">        if (result != Nothing) &#123;</span><br><span class="line">            /* The result holds all the remaining flips but doesn&#x27;t know about</span><br><span class="line">             * the flip we just did. Insert that flip at the beginning.</span><br><span class="line">             */</span><br><span class="line">            result.value().insert(0, numToFlip);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we&#x27;re here, then no matter which flip we make first, we cannot</span><br><span class="line">     * get the pancakes sorted. Give up.</span><br><span class="line">     */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归解决天平问题"><a href="#递归解决天平问题" class="headerlink" title="递归解决天平问题"></a>递归解决天平问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isMeasurableRec(int amount, const Vector&lt;int&gt;&amp; weights, int index) &#123;</span><br><span class="line">  if (index == weights.size()) &#123;</span><br><span class="line">      return amount == 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      return isMeasurableRec(amount,                  weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount + weights[index], weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount - weights[index], weights, index + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMeasurable(int amount, const Vector&lt;int&gt;&amp; weights) &#123;</span><br><span class="line">    return isMeasurableRec(amount, weights, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象一下，我们首先将要测量的数量（称为 <em>n</em> ）放在天平的左侧。 这使得规模上的不平衡等于 <em>n</em> 。 想象一下，有某种方法可以测量 <em>n</em> 。 如果我们一次将一个重量放在秤上，我们可以查看第一个重量的放置位置（假设它的重量为 <em>w</em> ）。 它必须：</p>
<ul>
<li>向左走，使规模上的净不平衡 <em>n + w</em> ，或</li>
<li>向右走，使规模上的净不平衡 <em>n – w</em> ，或</li>
<li>根本不习惯，留下净不平衡 <em>n</em> 。</li>
</ul>
<p>如果确实有可能测量 <em>n</em> ，那么这三个选项之一必须是实现它的方法，即使我们不知道它是哪一个。 然后我们要问的问题是，是否有可能使用剩余的权重来衡量新的净失衡——我们可以递归地确定！ 另一方面，如果无法测量 <em>n</em> ，那么无论我们选择哪个选项，我们都会发现没有办法使用剩余的权重来使一切平衡！</p>
<p>如果我们递归地进行，我们在这里，我们需要考虑我们的基本情况。 我们可以选择的选项有很多。 一个简单的方法如下：假设我们根本没有任何重量，我们被要求查看是否可以不使用重量来测量某些重量。 在什么情况下我们可以这样做？ 好吧，如果我们称重的东西有一个非零重量，我们就不可能测量它——把它放在秤上会使它倾斜到某一边，但这并不能告诉我们它有多少重量。 另一方面，如果我们称量的东西是完全失重的，那么把它放在秤上也不会导致它倾斜，让我们相信它确实是失重的！ 因此，作为我们的基本情况，我们会说当我们减少到没有剩余权重时， <em>，我们可以精确测量n</em> 如果 <em>n &#x3D; 0</em> 。 考虑到这一点，这是我们的代码：</p>
<h3 id="递归解决找零问题"><a href="#递归解决找零问题" class="headerlink" title="递归解决找零问题"></a>递归解决找零问题</h3><h1 id="不使用记忆的情况"><a href="#不使用记忆的情况" class="headerlink" title="不使用记忆的情况"></a>不使用记忆的情况</h1><p>&#96;从第一个硬币开始遍历，并穷举它的所有枚数，将其作为下一枚硬币的参数传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    else if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (coins.isEmpty()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins.first();</span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsFor(cents - copies * coin,</span><br><span class="line">                                                     coins - coin);</span><br><span class="line">          /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用记忆进行优化"><a href="#使用记忆进行优化" class="headerlink" title="使用记忆进行优化"></a>使用记忆进行优化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* How few coins are needed to make the total, given that we can only use</span><br><span class="line"> * coins from index startIndex and onward?</span><br><span class="line"> */</span><br><span class="line">int fewestCoinsRec(int cents, const Vector&lt;int&gt;&amp; coins, int startIndex,Grid&lt;int&gt;&amp; memo) &#123;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (startIndex == coins.size()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: We already know the answer. */</span><br><span class="line">    else if (memo[cents][startIndex] != -1) &#123;</span><br><span class="line">        return memo[cents][startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line"></span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins[startIndex];</span><br><span class="line"></span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsRec(cents - copies * coin,</span><br><span class="line">                                                     coins, startIndex + 1,</span><br><span class="line">                                                     memo);</span><br><span class="line"></span><br><span class="line">            /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        memo[cents][startIndex] = bestSoFar;</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Convert from a Set&lt;int&gt; to a Vector&lt;int&gt; so we have a nice ordering</span><br><span class="line">     * on things.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; coinVec;</span><br><span class="line">    for (int coin: coins) &#123;</span><br><span class="line">        coinVec += coin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build our memoization table. Since the number of cents left ranges from</span><br><span class="line">     * 0 to cents, we need cents+1 rows. Since the start index of the coin</span><br><span class="line">     * ranges from 0 to coins.size(), we make coins.size() + 1 columns.</span><br><span class="line">     *</span><br><span class="line">     * -1 is used as a sentinel to indicate &quot;nothing has been computed here</span><br><span class="line">     * yet.&quot;</span><br><span class="line">     */</span><br><span class="line">    Grid&lt;int&gt; memo(cents + 1, coins.size() + 1, -1);</span><br><span class="line"></span><br><span class="line">    /* Now ask how many coins are needed to make the total, using any coins</span><br><span class="line">     * from index 0 onward.</span><br><span class="line">     */</span><br><span class="line">    return fewestCoinsRec(cents, coinVec, 0, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归穷举付账单"><a href="#递归穷举付账单" class="headerlink" title="递归穷举付账单"></a>递归穷举付账单</h3><p>递归机制：对第一个人来说，0-total所有金额都会付一遍，随后传递给下一个人，当只有一人时，付清所有余额并打印账单<br>传递参数：string,int的映射存储目前为止的账单，string集合存储所有付账者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void listPossiblePaymentsRec(int total, const Set&lt;string&gt;&amp; people,const Map&lt;string, int&gt;&amp; payments) &#123;</span><br><span class="line">    /* Base case: if there&#x27;s one person left, they have to pay the whole bill. */</span><br><span class="line">    if (people.size() == 1) &#123;</span><br><span class="line">        Map&lt;string, int&gt; finalPayments = payments;</span><br><span class="line">        finalPayments[people.first()] = total;</span><br><span class="line">        cout &lt;&lt; finalPayments &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: The first person has to pay some amount between 0 and the</span><br><span class="line">     * total amount. Try all of those possibilities.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int payment = 0; payment &lt;= total; payment++) &#123;</span><br><span class="line">            /* Create a new assignment of people to payments in which this first</span><br><span class="line">             * person pays this amount.</span><br><span class="line">             */</span><br><span class="line">            Map&lt;string, int&gt; updatedPayments = payments;</span><br><span class="line">            updatedPayments[people.first()] = payment;</span><br><span class="line">            listPossiblePaymentsRec(total - payment, people - people.first(),updatedPayments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void listPossiblePayments(int total, const Set&lt;string&gt;&amp; people) &#123;</span><br><span class="line">    /* Edge cases: we can&#x27;t pay a negative total, and there must be at least one</span><br><span class="line">     * person.</span><br><span class="line">     */</span><br><span class="line">    if (total &lt; 0) error(&quot;Guess you&#x27;re an employee?&quot;);</span><br><span class="line">    if (people.isEmpty()) error(&quot;Dine and dash?&quot;);</span><br><span class="line"> listPossiblePaymentsRec(total, people, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归寻找完全平方数列"><a href="#递归寻找完全平方数列" class="headerlink" title="递归寻找完全平方数列"></a>递归寻找完全平方数列</h3><p>主要参数为sofar——用于存储目前的序列和一个set用于存储还没放入数列的数字，&#96;确保这两者同时被传递，且其并集为所有数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSquareSequence(int n) &#123;</span><br><span class="line">    /*Validate input.*/</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        error(&quot;Don&#x27;t be so negative!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build a set of the numbers 1, 2, 3, ..., n. */</span><br><span class="line">    Set&lt;int&gt; options;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        options += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return findSequenceRec(options, &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSequenceRec(const Set&lt;int&gt;&amp; unused,</span><br><span class="line">                                      const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /*Base Case: If all numbers are used, we have our sequence!*/</span><br><span class="line">    if (unused.isEmpty()) &#123;</span><br><span class="line">        return soFar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Recursive Case: Some number comes next. Try each of them and see which</span><br><span class="line">     * one we should pick.</span><br><span class="line">     */</span><br><span class="line">    for (int next: unused) &#123;</span><br><span class="line">        /* We can use this if either</span><br><span class="line">         *</span><br><span class="line">         * 1. the sequence is empty, so we&#x27;re first in line, or</span><br><span class="line">         * 2. the sequence is not empty, but we sum to a perfect square</span><br><span class="line">         *    with the previous term.</span><br><span class="line">         */</span><br><span class="line">        if (soFar.isEmpty() ||</span><br><span class="line">            isPerfectSquare(next + soFar[soFar.size() - 1])) &#123;</span><br><span class="line">            /* See what happens if we extend with this number. */</span><br><span class="line">            auto result = findSequenceRec(unused - next, soFar + next);</span><br><span class="line">            if (result != Nothing) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Tried all options and none of them worked. Oh well! */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="汉诺塔递归"><a href="#汉诺塔递归" class="headerlink" title="汉诺塔递归"></a>汉诺塔递归</h3><p>假设有三座汉诺塔，<code>start ,temp ,finish</code><br>对n层的汉诺塔问题，先考虑n-1层的，随后考虑n-2层，到最后只需要考虑两层问题，两层的汉诺塔非常容易解决，起点为start,终点是temp,临时塔为finish，最后我们得到temp上的两层汉诺塔<br>这时将start的3移动到finish塔，这时只要将两层汉诺塔转移到finish则完成了三层汉诺塔，这个过程中的起点为temp,终点是finish,临时塔是start<br>以此类推，四层塔基于三层塔，<code>n</code>层塔基于<code>n-1</code>塔，汉诺塔问题解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int moveTower(int numDisks, char start, char finish, char temp) &#123;</span><br><span class="line">    if (numDisks == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int movesOne = moveTower(numDisks - 1, start, temp, finish);</span><br><span class="line">        moveSingleDisk(start, finish);</span><br><span class="line">        int movesTwo = moveTower(numDisks - 1, temp, finish, start);</span><br><span class="line"></span><br><span class="line">        return 1 + movesOne + movesTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利cs61a的python笔记</title>
    <url>/2023/09/29/61a%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="python语言特性"><a href="#python语言特性" class="headerlink" title="python语言特性"></a>python语言特性</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>名称也可以与函数绑定。例如，名称 <code>max</code> 就和我们之前使用的 <code>max</code> 函数进行了绑定。与数字不同，函数很难以文本呈现，因此当询问一个函数时，Python 会打印一个标识来描述：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; max</span><br><span class="line">&lt;built-in function max&gt;</span><br></pre></td></tr></table></figure>

<p>赋值语句可以为现有函数赋予新名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f = max</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;built-in function max&gt;</span><br><span class="line">&gt;&gt;&gt; f(2, 3, 4)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>以下指南改编自 <a href="http://www.python.org/dev/peps/pep-0008">Python 代码风格指南</a>, 它可以作为所有（非叛逆的）Python 程序员的指南。这些共享的约定使开发者社区的成员之间的沟通能够顺利进行。作为遵循这些约定的副作用，你会发现你的代码在内部变得更加一致。</p>
<ol>
<li>函数名是小写的，单词之间用下划线分隔。鼓励使用描述性名称。</li>
<li>函数名称通常反映解释器应用于参数的操作（例如， <code>print, add, square</code> ）或结果（例如， <code>max, abs, sum</code> ）。</li>
<li>参数名称是小写的，单词之间用下划线分隔。首选单个词的名称。</li>
<li>参数名称应该反映参数在函数中的作用，而不仅仅是允许的参数类型。</li>
<li>当作用明确时，单字参数名称可以接受，但应避免使用 l（小写的 L）和 O（大写的 o）或 I（大写的 i）以避免与数字混淆。</li>
</ol>
<h3 id="函数设计原则"><a href="#函数设计原则" class="headerlink" title="函数设计原则"></a>函数设计原则</h3><ul>
<li>每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。</li>
<li>不要重复自己（Don’t repeat yourself）是软件工程的核心原则。这个所谓的 DRY 原则指出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。如果你发现自己正在复制粘贴一段代码，那么你可能已经找到了进行函数抽象的机会。</li>
<li>定义通用的函数。比如作为 <code>pow</code> 函数的一个特例的平方函数就不在 Python 库中，因为 <code>pow</code> 函数可以将数字计算为任意次方。<br>当你使用函数名称作为参数调用 <code>help</code> 时，你会看到它的文档字符串（键入 q 以退出 Python help）。<br>Python 中的注释可以附加到 <code>#</code> 号后的行尾。例如，上面代码中的注释 <code>玻尔兹曼常数</code> 描述了 <code>k</code> 变量的含义。这些注释不会出现在 Python 的 <code>help</code> 中，而且会被解释器忽略，它们只为人类而存在。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help(pressure)</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Link:</span><br><span class="line">        &quot;&quot;&quot;A linked list with a first element and the rest.&quot;&quot;&quot;</span><br><span class="line">        empty = ()</span><br><span class="line">        def __init__(self, first, rest=empty):</span><br><span class="line">            assert rest is Link.empty or isinstance(rest, Link)</span><br><span class="line">            self.first = first</span><br><span class="line">            self.rest = rest</span><br><span class="line">        def __getitem__(self, i):</span><br><span class="line">            if i == 0:</span><br><span class="line">                return self.first</span><br><span class="line">            else:</span><br><span class="line">                return self.rest[i-1]</span><br><span class="line">        def __len__(self):</span><br><span class="line">            return 1 + len(self.rest)</span><br></pre></td></tr></table></figure>

<h3 id="抽象障碍"><a href="#抽象障碍" class="headerlink" title="抽象障碍"></a>抽象障碍</h3><p>每当程序的一部分可以使用更高级别的函数而不是使用较低级别的函数时，就会违反抽象障碍。例如，计算有理数平方的函数最好用 <code>mul_rational</code> 实现，它不对有理数的实现做任何假设。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_rational(x):</span><br><span class="line">        return mul_rational(x, x)</span><br></pre></td></tr></table></figure>

<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><pre><code>范围通常出现在 for 语句 header 中的表达式，以指定 `&lt;suite&gt;` 应执行的次数。如果 `&lt;name&gt;` 没有被用在 `&lt;suite&gt;`，一个惯用的使用方式是，使用下划线表示 `&lt;name&gt;`。
</code></pre>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for _ in range(3):</span><br><span class="line">        print(&#x27;Go Bears!&#x27;)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure>

<p>对解释器而言，下划线只是环境中的另一个名称，但对程序员具有约定俗成的含义，表示该名称不会出现在任何未来的表达式中。<br>列表推导式的一般形式是：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;</span><br></pre></td></tr></table></figure>

<p>为了运算列表推导式，Python 首先评估 <code>&lt;sequence expression&gt;</code>，它必须返回一个 iterable 值。然后，每个元素依次绑定到 <code>&lt;name&gt;</code>，再运算 <code>&lt;filter expression&gt;</code>；如果产生一个真值，运算 <code>&lt;map expression&gt;</code>。最后 <code>&lt;map expression&gt;</code> 的值被收集到一个列表中</p>
<p><code>reduce</code> 可用于将序列的所有元素相乘。使用 <code>mul</code> 作为 <code>reduce_fn</code>， 1 作为 <code>initial</code> 值， <code>reduce</code> 可用于将各数字相乘。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(mul, [2, 4, 8], 1)</span><br><span class="line">64</span><br></pre></td></tr></table></figure>

<p>**多行文字 (Multiline Literals)**。字符串不限于一行。跨越多行的字符串文字可以用三重引号括起。我们已经在文档字符串中广泛使用了这种三重引号。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器的用处源自以下事实： 迭代器的一系列数据可能不会在内存中显式表示。 迭代器提供了一种考虑一系列值中的每一个的机制 轮，但所有这些元素不需要同时存储。 相反，当迭代器请求下一个元素时，该元素可能会 按需计算，而不是从现有内存中检索 来源。</p>
<p>范围能够惰性地计算序列的元素，因为 表示的序列是统一的，并且任何元素都很容易从 范围的开始和结束边界。 迭代器允许延迟生成 更广泛的底层序列数据集类别，因为它们不需要 提供对底层系列的任意元素的访问。 反而， 迭代器只需要按顺序计算该系列的下一个元素， 每次请求另一个元素时。 虽然不像访问那样灵活 序列的任意元素（称为 <em>随机访问</em> ）、 <em>顺序访问</em> 顺序数据通常足以满足数据处理应用程序的需要。<br>函数 map 是惰性的：调用它并不执行计算 需要计算其结果的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def double_and_print(x):</span><br><span class="line">        print(&#x27;***&#x27;, x, &#x27;=&gt;&#x27;, 2*x, &#x27;***&#x27;)</span><br><span class="line">        return 2*x</span><br><span class="line">&gt;&gt;&gt; s = range(3, 7)</span><br><span class="line">&gt;&gt;&gt; doubled = map(double_and_print, s)  # double_and_print not yet called</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called once</span><br><span class="line">*** 3 =&gt; 6 ***</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called again</span><br><span class="line">*** 4 =&gt; 8 ***</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; list(doubled)                       # double_and_print called twice more</span><br><span class="line">*** 5 =&gt; 10 ***</span><br><span class="line">*** 6 =&gt; 12 ***</span><br><span class="line">[10, 12]</span><br></pre></td></tr></table></figure>

<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p>可迭代的 Letters 实例 b_to_k 和 LetterIter 迭代器 实例 first_iterator 和 second_iterator的 不同之处在于 字母 实例不会改变，而迭代器实例会改变 每次调用 next （或等效地，每次调用 <strong>next</strong> ）。 迭代器通过顺序数据跟踪进度，而可迭代器 代表数据本身。</p>
<p>Python 中的许多内置函数都采用可迭代参数并返回迭代器。 函数 map 例如， 接受一个函数和一个可迭代对象。 它返回 将函数参数应用于每个元素的结果的迭代器 在可迭代的参数中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;  caps   =   map  (  lambda   x  :   x  .  upper  (),   b_to_k ) </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;B&#x27; </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;C&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器函数是生成值而不是返回值的函数<br> 普通函数返回一次；  一个生成器函数可以产生多次<br> 生成器是通过调用生成器函数自动创建的迭代器<br> 当调用生成器函数时，它返回一个迭代其产量的生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def plus_minus(x):</span><br><span class="line">... yield x</span><br><span class="line">... yield -x</span><br><span class="line">&gt;&gt;&gt; t = plus_minus(3)</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">-3</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">&lt;generator object plus_minus ...&gt;</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="嵌套定义"><a href="#嵌套定义" class="headerlink" title="嵌套定义"></a>嵌套定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def sqrt(a):</span><br><span class="line">        def sqrt_update(x):</span><br><span class="line">            return average(x, a/x)</span><br><span class="line">        def sqrt_close(x):</span><br><span class="line">            return approx_eq(x * x, a)</span><br><span class="line">        return improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure>

<p>与局部赋值一样，局部 <code>def</code> 语句只影响当前局部帧。这些函数仅在求解 <code>sqrt</code> 时在作用域内。与求解过程一致，这些局部 <code>def</code> 语句在调用 <code>sqrt</code> 之前都不会被求解。</p>
<p>词法作用域（Lexical scope）：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， <code>sqrt_update</code> 引用名称 <code>a</code>，它是其封闭函数 <code>sqrt</code> 的形式参数。这种在嵌套定义之间共享名称的规则称为词法作用域。最重要的是，内部函数可以访问定义它们的环境中的名称（而不是它们被调用的位置）。</p>
<p>我们需要对我们的环境模型实现两个扩展来启用词法作用域。</p>
<ol>
<li>每个用户定义的函数都有一个父环境：定义它的环境。</li>
<li>调用用户定义的函数时，其局部帧会继承其父环境。<br> Python 中词法作用域的两个关键优势。</li>
</ol>
<ul>
<li>局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。</li>
<li>局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。</li>
</ul>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>不像  定义  语句、lambda 表达式可以用作运算符或<br>调用表达式的操作数。  这是因为它们只是一行<br>计算结果为函数的表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; what = lambda x : x + 5</span><br><span class="line">&gt;&gt;&gt; what</span><br><span class="line">&lt;function &lt;lambda&gt; at 0xf3f490&gt;</span><br><span class="line">&gt;&gt;&gt; (lambda y: y + 5)(4)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">     def __init__(self, account_holder):</span><br><span class="line">            self.balance = 0</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<p>内置函数 <code>getattr</code> 还按名称返回对象的属性。它是点表示法的函数等效物。使用 <code>getattr</code> ，我们可以使用字符串查找属性，就像我们对调度字典所做的那样。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(spock_account, &#x27;balance&#x27;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>我们还可以测试应该对象是否具有 <code>hassattr</code> 的名命属性。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(spock_account, &#x27;deposit&#x27;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>我们可以通过对点表达式的返回值调用 <code>type</code> 来查看交互式解释器的差异。作为类的属性，方法只是一个函数，但作为实例的属性，它是一个绑定方法：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(Account.deposit)</span><br><span class="line">&lt;class &#x27;Function&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(spock_account.deposit)</span><br><span class="line">&lt;class &#x27;method&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>这两个结果的区别仅在于第一个是参数为 <code>self</code> 和 <code>amount</code> 的标准双参数函数。第二种是单参数方法，调用方法时，名称 <code>self</code> 将自动绑定到名为 <code>spock_account</code> 的对象，而参数 <code>amount</code> 将绑定到传递给方法的参数。这两个值（无论是函数值还是绑定方法值）都与相同的 <code>deposit</code> 函数体相关联。<br>在某些情况下，有一些实例变量和方法与对象的维护和一致性相关，我们不希望对象的用户看到或使用。它们不是类定义的抽象的一部分，而是实现的一部分。Python 的约定规定，如果属性名称以下划线开头，则只能在类本身的方法中访问它，而不是用户访问。</p>
<p>计算点表达式：</p>
<ol>
<li>点表达式左侧的 <code>&lt;expression&gt;</code> ，生成点表达式的对象。</li>
<li><code>&lt;name&gt;</code> 与该对象的实例属性匹配；如果存在具有该名称的属性，则返回属性值。</li>
<li>如果实例属性中没有 <code>&lt;name&gt;</code> ，则在类中查找 <code>&lt;name&gt;</code>，生成类属性。</li>
<li>除非它是函数，否则返回属性值。如果是函数，则返回该名称绑定的方法。</li>
</ol>
<h2 id="约束传递-Propagating-Constraints"><a href="#约束传递-Propagating-Constraints" class="headerlink" title="约束传递 (Propagating Constraints)"></a>约束传递 (Propagating Constraints)</h2><p>可变数据允许我们模拟具有变化的系统，也允许我们构建新的抽象类型。在这个扩展示例中，我们结合了非局部赋值、列表和字典来构建一个支持多方向计算的基于约束系统。将程序表示为约束是一种声明式编程，在这种编程中，程序员声明要解决的问题的结构，而不是抽象出问题解决方案的具体计算方式的细节。</p>
<p>计算机程序传统上被组织为单向计算，它对预先指定的参数执行操作以产生所需的输出。另一方面，我们通常希望根据数量之间的关系对系统进行建模。例如，我们之前考虑过理想气体定律，它通过玻尔兹曼常数 (k) 将理想气体的压力 (p)、体积 (v)、数量 (n) 和温度 (t) 联系起来：</p>
<p><code>p * v = n * k * t</code></p>
<p>这样的方程不是单向的。给定任何四个量，我们可以使用这个方程来计算第五个。然而，将方程式翻译成传统的计算机语言会迫使我们选择一个量来根据其他四个量进行计算。因此，计算压力的函数不能用于计算温度，即使这两个量的计算来自同一个方程。</p>
<p>在本节中，我们概述了线性关系的一般模型的设计。我们定义了在数量之间保持的原始约束，例如强制数学关系 a + b &#x3D; c 的 adder(a, b, c) 约束。</p>
<p>我们还定义了一种组合方式，以便可以组合原始约束来表达更复杂的关系。这样，我们的程序就类似于一种编程语言。我们通过构建一个网络来组合约束，在该网络中约束由连接器 (connector) 连接。连接器是一个对象，它“持有”一个值并且可以参与一个或多个约束。</p>
<p>例如，我们知道华氏温度和摄氏温度之间的关系是：</p>
<p><code>9 * c = 5 * (f - 32)</code></p>
<p>该等式是 c 和 f 之间的复杂约束。这样的约束可以被认为是一个由原始加法器 (adder) 、乘法器 (multiplier) 和常量 (constant) 约束组成的网络。</p>
<p><img src="https://composingprograms.netlify.app/sicp/celsius_fahrenheit_constraint.png" alt="celsius_fahrenheit_constraint"></p>
<p>在此图中，我们在左侧看到一个乘数框，其中包含三个端子，标记为 a 、b 和 c。这些将乘数连接到网络的其余部分，如下所示：终端连接到连接器 celsius，该连接器将保持摄氏温度。b 端子连接到连接器 w，该连接器链接到常量 9。乘数盒约束为 a 和 b 乘积的 c 端链接到另一个乘法盒的 c 端，其 b 连接到常量 5，其 a 连接到和约束中的项之一。</p>
<p>这种网络的计算过程如下：当一个连接器被赋予一个值时（由用户或由它链接到的约束框），它会唤醒所有相关的约束（除了刚刚唤醒它的约束） 以告诉他们它有值。每个被唤醒的约束框之后轮流询问其连接器，以查看是否有足够的信息来确定连接器的值。如果有，该框设置该连接器，然后唤醒所有关联的约束，依此类推。例如，在摄氏度和华氏度之间的转换中， w、 x 和 y 立即被常量框分别设置为 9、 5 和 32。连接器唤醒乘法器和加法器，它们确定没有足够的信息继续进行。如果用户（或网络的其他部分）将摄氏连接器设置为一个值（比如 25），最左边的乘法器将被唤醒，它将 u 设置为 25 * 9 &#x3D; 225。然后你唤醒第二个乘法器，将 v 设置为 45，v 唤醒加法器，将 fahrenheit 连接器设置为 77。</p>
<p>**使用约束系统 (Using the Constraint System)**。要使用约束系统执行上述温度计算，我们首先通过调用连接器构造函数创建两个命名连接器，摄氏度 celsius 和华氏度 fahrenheit。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius = connector(&#x27;Celsius&#x27;)</span><br><span class="line">&gt;&gt;&gt; fahrenheit = connector(&#x27;Fahrenheit&#x27;)</span><br></pre></td></tr></table></figure>

<p>然后，我们将这些连接器链接到一个反映上图的网络中。函数转换器 (converter) 组装网络中的各种连接器和约束。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def converter(c, f):</span><br><span class="line">        &quot;&quot;&quot;用约束条件连接 c 到 f ，将摄氏度转换为华氏度.&quot;&quot;&quot;</span><br><span class="line">        u, v, w, x, y = [connector() for _ in range(5)]</span><br><span class="line">        multiplier(c, w, u)</span><br><span class="line">        multiplier(v, x, u)</span><br><span class="line">        adder(v, y, f)</span><br><span class="line">        constant(w, 9)</span><br><span class="line">        constant(x, 5)</span><br><span class="line">        constant(y, 32)</span><br></pre></td></tr></table></figure>

<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; converter(celsius, fahrenheit)</span><br></pre></td></tr></table></figure>

<p>我们将使用消息传递系统来协调约束和连接器。约束是不包含局部状态本身的字典。它们对消息的响应是非纯函数，会更改它们约束的连接器。</p>
<p>连接器是保存当前值并响应操纵该值的消息的字典。约束不会直接更改连接器的值，而是通过发送消息来更改，以便连接器可以通知其他约束以响应更改。这样，一个连接器既代表了一个数字，同时也封装了连接器的行为。</p>
<p>我们可以发送给连接器的一条消息是设置它的值。在这里，我们（ “ user ” ）将 celsius 的值设置为 25。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;set_val&#x27;](&#x27;user&#x27;, 25)</span><br><span class="line">Celsius = 25</span><br><span class="line">Fahrenheit = 77.0</span><br></pre></td></tr></table></figure>

<p>不仅 celsius 的值变为 25，而且它的值通过网络传播，因此 fahrenheit 的值也发生变化。打印这些更改是因为我们在构造它们时命名了这两个连接器。</p>
<p>现在我们可以尝试将 fahrenheit 度设置为一个新值，比如 212。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Contradiction detected: 77.0 vs 212</span><br></pre></td></tr></table></figure>

<p>连接器抱怨说它感觉到了一个矛盾：它的值为 77.0，而有人试图将它设置为 212。如果我们真的想用新值应用到网络，我们可以告诉 celsius 忘记它的旧值：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;forget&#x27;](&#x27;user&#x27;)</span><br><span class="line">Celsius is forgotten</span><br><span class="line">Fahrenheit is forgotten</span><br></pre></td></tr></table></figure>

<p>连接器 celsius 发现最初设置其值的用户现在收回该值，因此 celsius 同意失去其值，并将这一事实通知网络的其余部分。这个信息最终传播到 fahrenheit，它现在发现它没有理由继续相信它自己的值是 77。因此，它也放弃了它的值。</p>
<p>现在 fahrenheit 没有值，我们可以将其设置为 212：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Fahrenheit = 212</span><br><span class="line">Celsius = 100.0</span><br></pre></td></tr></table></figure>

<p>这个新值在通过网络传播时会迫使 celsius 的值变为 100。我们使用了完全相同的网络来计算给定 celsius 的 fahrenheit 和给定 fahrenheit 的 celsius。这种计算的非方向性是基于约束的系统的显着特征。</p>
<p>**实施约束系统 (Implementing the Constraint System)**。正如我们所见，连接器是将消息名称映射到函数和数据值的字典。我们将实施响应以下消息的连接器：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; connector [&#x27;set_val&#x27;](source, value)  &quot;&quot;&quot;表示 source 在请求连接器将当前值设为 value&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;has_val&#x27;]()  &quot;&quot;&quot;返回连接器是否已经具有值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;val&#x27;]  &quot;&quot;&quot;是连接器的当前值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;forget&#x27;](source)  &quot;&quot;&quot;告诉连接器 source 请求遗忘它的值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;connect&#x27;](source)  &quot;&quot;&quot;告诉连接器参与新的约束，即 source&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>约束也是字典，它通过两条消息从连接器接收信息：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; constraint[\&#x27;new_val&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器具有新的值。&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; constraint[\&#x27;forget&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器遗忘了值。&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>当约束收到这些消息时，它们会将消息传播到其他连接器。</p>
<p>adder 函数在三个连接器上构造一个加法器约束，其中前两个必须与第三个相加：a + b &#x3D; c。为了支持多向约束传播，加法器还必须指定它从 c 中减去 a 得到 b，同样地从 c 中减去 b 得到 a。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import add, sub</span><br><span class="line">&gt;&gt;&gt; def adder(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a+b=c&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, add, sub, sub)</span><br></pre></td></tr></table></figure>

<p>我们想实现一个通用的三元（三向）约束，它使用来自 adder 的三个连接器和三个函数来创建一个接受 new_val 和 forget 消息的约束。对消息的响应是局部函数，它们被放置在称为约束的字典中。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_ternary_constraint(a, b, c, ab, ca, cb):</span><br><span class="line">        &quot;&quot;&quot;约束ab(a,b)=c，ca(c,a)=b，cb(c,b)=a。&quot;&quot;&quot;</span><br><span class="line">        def new_value():</span><br><span class="line">            av, bv, cv = [connector[&#x27;has_val&#x27;]() for connector in (a, b, c)]</span><br><span class="line">            if av and bv:</span><br><span class="line">                c[&#x27;set_val&#x27;](constraint, ab(a[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">            elif av and cv:</span><br><span class="line">                b[&#x27;set_val&#x27;](constraint, ca(c[&#x27;val&#x27;], a[&#x27;val&#x27;]))</span><br><span class="line">            elif bv and cv:</span><br><span class="line">                a[&#x27;set_val&#x27;](constraint, cb(c[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">        def forget_value():</span><br><span class="line">            for connector in (a, b, c):</span><br><span class="line">                connector[&#x27;forget&#x27;](constraint)</span><br><span class="line">        constraint = &#123;&#x27;new_val&#x27;: new_value, &#x27;forget&#x27;: forget_value&#125;</span><br><span class="line">        for connector in (a, b, c):</span><br><span class="line">            connector[&#x27;connect&#x27;](constraint)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>

<p>称为约束的字典是一个调度字典，也是约束对象本身。它响应约束接收到的两条消息，但也作为调用其连接器的 source 参数传递。</p>
<p>每当约束被告知其连接器之一具有值时，就会调用约束的局部函数 new_value。该函数首先检查 a 和 b 是否都有值。如果是，它告诉 c 将其值设置为函数 ab 的返回值，在加法器的情况下为 add。约束将自身（约束）作为连接器的 source 参数传递，该连接器是加法器对象。如果 a 和 b 不同时都有值，则约束检查 a 和 c，依此类推。</p>
<p>如果约束被告知它的一个连接器遗忘了它的值，它会请求它的所有连接器遗忘它们的值。（实际上只有那些由此约束设置的值会丢失。）</p>
<p>乘法器与加法器非常相似。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import mul, truediv</span><br><span class="line">&gt;&gt;&gt; def multiplier(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a*b=c.&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, mul, truediv, truediv)</span><br></pre></td></tr></table></figure>

<p>常量也是一种约束，但它永远不会发送任何消息，因为它只涉及它在构造时设置的单个连接器。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def constant(connector, value):</span><br><span class="line">        &quot;&quot;&quot;常量赋值.&quot;&quot;&quot;</span><br><span class="line">        constraint = &#123;&#125;</span><br><span class="line">        connector[&#x27;set_val&#x27;](constraint, value)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>

<p>这三个约束足以实现我们的温度转换网络。</p>
<p>**连接器表示 (Representing connectors)**。连接器表示为包含值的字典，也有具备局部状态的响应函数。连接器必须跟踪为其提供当前值的信息提供者，以及它参与的约束列表。</p>
<p>构造函数连接器具有用于设置和遗忘值的局部函数，这些值是对来自约束的消息的响应。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def connector(name=None):</span><br><span class="line">        &quot;&quot;&quot;限制条件之间的连接器.&quot;&quot;&quot;</span><br><span class="line">        informant = None</span><br><span class="line">        constraints = []</span><br><span class="line">        def set_value(source, value):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            val = connector[&#x27;val&#x27;]</span><br><span class="line">            if val is None:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = source, value</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;=&#x27;, value)</span><br><span class="line">                inform_all_except(source, &#x27;new_val&#x27;, constraints)</span><br><span class="line">            else:</span><br><span class="line">                if val != value:</span><br><span class="line">                    print(&#x27;Contradiction detected:&#x27;, val, &#x27;vs&#x27;, value)</span><br><span class="line">        def forget_value(source):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            if informant == source:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = None, None</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;is forgotten&#x27;)</span><br><span class="line">                inform_all_except(source, &#x27;forget&#x27;, constraints)</span><br><span class="line">        connector = &#123;&#x27;val&#x27;: None,</span><br><span class="line">                     &#x27;set_val&#x27;: set_value,</span><br><span class="line">                     &#x27;forget&#x27;: forget_value,</span><br><span class="line">                     &#x27;has_val&#x27;: lambda: connector[&#x27;val&#x27;] is not None,</span><br><span class="line">                     &#x27;connect&#x27;: lambda source: constraints.append(source)&#125;</span><br><span class="line">        return connector</span><br></pre></td></tr></table></figure>

<p>连接器也是约束用于与连接器通信的五个消息的调度字典。四个响应是函数，最后的响应是值本身。</p>
<p>当有设置连接器值的请求时调用局部函数 set_value。如果连接器当前没有值，它将设置它的值并记住请求设置值的源约束作为信息提供者。然后连接器将通知它的所有参与约束，除了请求设置值的约束。这是使用以下迭代函数完成的。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def inform_all_except(source, message, constraints):</span><br><span class="line">        &quot;&quot;&quot;告知信息除了source外的所有约束条件，。&quot;&quot;&quot;</span><br><span class="line">        for c in constraints:</span><br><span class="line">            if c != source:</span><br><span class="line">                c[message]()</span><br></pre></td></tr></table></figure>

<p>如果要求连接器遗忘其值，它会调用局部函数 forget-value，该函数首先检查以确保请求来自与最初设置值相同的约束。如果是这样，连接器会通知其关联的约束有关值的丢失。</p>
<p>对消息 has_val 的响应表明连接器是否有值。 对消息连接的响应将源约束添加到约束列表中。</p>
<p>我们设计的约束程序引入了许多将在面向对象编程中再次出现的思想。约束和连接器都是通过消息操作的抽象。当连接器的值发生变化时，它会通过一条消息进行更改，该消息不仅会更改值，还会验证它（检查源）并传播其效果（通知其他约束）。事实上，我们将在本章后面使用具有字符串值键和函数值的字典的类似架构来实现面向对象的系统</p>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>请注意，回溯中的行似乎是配对在一起的。 该对中的第一行具有以下格式：<br>文件“&lt;文件名&gt;”，第 &lt;编号&gt; 行，&lt;函数&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;&lt;file name&gt;&quot;, line &lt;number&gt;, in &lt;function&gt;</span><br></pre></td></tr></table></figure>

<p>该行为您提供以下信息： 文件名：包含问题的文件的名称。 Number：文件中引起问题的行号，或包含下一个函数调用的行号 函数：可以在其中找到该行的函数的名称。<br>回溯消息中的最后一行是错误语句。 错误语句具有以下格式： &lt;错误类型&gt;：&lt;错误消息&gt; 这一行为您提供了两条信息： 错误类型：引起的错误类型（例如SyntaxError，TypeError）。 这些通常具有足够的描述性，可以帮助您缩小错误原因的搜索范围。 错误消息：更详细地描述导致错误的原因。 不同的错误类型会产生不同的错误消息。</p>
<h2 id="Running-doctests"><a href="#Running-doctests" class="headerlink" title="Running doctests"></a>Running doctests</h2><p>Python has a great way to quickly write tests for your code. These are called doctests, and look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    &quot;&quot;&quot;A random function.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; foo(4)</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; foo(5)</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>The lines in the docstring that look like interpreter outputs are the <strong>doctests</strong>. To run them, go to your terminal and type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m doctest file.py</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m doctest file.py -v</span><br><span class="line">除了告诉你哪些文档测试失败之外，它还会 告诉您哪些文档测试通过了。</span><br></pre></td></tr></table></figure>

<p>许多程序员喜欢研究他们的代码的一种方法是使用交互式 REPL。 也就是说，您可以在其中直接运行函数并检查其输出的终端。<br>通常，要完成此操作，您可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -i file.py</span><br></pre></td></tr></table></figure>

<h3 id="使用-assert声明"><a href="#使用-assert声明" class="headerlink" title="使用 assert声明"></a>使用 <code>assert</code>声明</h3><p>Python 有一个特性称为 <code>assert</code>语句，它可以让您测试条件是否为真，并打印错误 否则在一行中消息。 如果您知道某些条件在某些点需要为真，这会很有用 在你的程序中。 例如，如果您正在编写一个接受整数并将其加倍的函数，那么它可能会很有用 确保您的输入实际上是一个整数。 然后你可以编写以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def double(x):</span><br><span class="line">    assert isinstance(x, int), &quot;The input to double(x) must be an integer&quot;</span><br><span class="line">    return 2 * x</span><br></pre></td></tr></table></figure>

<p>请注意，我们并没有真正调试 <code>double</code>在这里，我们正在做的是确保任何拨打电话的人 <code>double</code>正在以正确的论点这样做。 例如，如果我们有一个函数 <code>g</code>接受一个字符串和一个数字 并将字符串的长度添加到数字的两倍，其实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def g(x, y):</span><br><span class="line">    return double(x) + y # should be double(y) + len(x)</span><br></pre></td></tr></table></figure>

<h3 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a><code>SyntaxError</code></h3><ul>
<li><p><strong>原因</strong> ：代码语法错误</p>
</li>
<li><p><strong>示例</strong> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    def incorrect(f)</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决办法</strong> ： <code>^</code>符号指向包含的代码 无效的语法。 错误消息没有告诉你 <em>什么</em> 是 错了，但它确实告诉你 <em>在哪里</em> 。</p>
</li>
<li><p><strong>注意</strong> ：Python 将检查 <code>SyntaxErrors</code>执行之前 任何代码。 这与其他错误不同，其他错误仅 在运行时引发。</p>
</li>
</ul>
<h3 id="IndentationError"><a href="#IndentationError" class="headerlink" title="IndentationError"></a><code>IndentationError</code></h3><ul>
<li><p><strong>原因</strong> ：缩进不当</p>
</li>
<li><p><strong>示例</strong> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    print(&#x27;improper indentation&#x27;)</span><br><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong> ：显示缩进不正确的行。 只需重新缩进即可。</p>
</li>
<li><p><strong>注意</strong> ：如果制表符和空格不一致，Python 将提出其中之一。 确保使用空格！ （只是少了点 在 Python 中使用空格和所有 cs61a 内容通常令人头痛 使用空格）。</p>
</li>
</ul>
<h3 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a><code>TypeError</code></h3><ul>
<li><p><strong>原因一</strong> ：</p>
<ul>
<li><p>原始运算符的操作数类型无效。 你是 可能尝试加&#x2F;减&#x2F;乘&#x2F;除不兼容 类型。</p>
</li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError: unsupported operand type(s) for +: &#x27;function&#x27; and &#x27;int&#x27;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>原因2</strong> ：</p>
<ul>
<li><p>在函数调用中使用非函数对象。</p>
</li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; square = 3</span><br><span class="line">&gt;&gt;&gt; square(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &#x27;int&#x27; object is not callable</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>原因3</strong> ：</p>
<ul>
<li><p>向函数传递错误数量的参数。</p>
</li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: add expected 2 arguments, got 1</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="NameError"><a href="#NameError" class="headerlink" title="NameError"></a><code>NameError</code></h3><ul>
<li><p><strong>原因</strong> ：变量没有分配给任何东西或者没有分配 存在。 这包括函数名称。</p>
</li>
<li><p><strong>示例</strong> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  y = x + 3</span><br><span class="line">NameError: global name &#x27;x&#x27; is not defined</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong> ：确保您正在初始化变量（即 在使用之前为变量分配一个值）。</p>
</li>
<li><p><strong>注意</strong> ：错误消息显示“全局名称”的原因是 因为Python将从a开始搜索变量 函数的本地框架。 如果在那里找不到该变量， Python将继续搜索父框架，直到到达 全球框架。 如果仍然找不到变量，Python 引发错误。</p>
</li>
</ul>
<h3 id="IndexError"><a href="#IndexError" class="headerlink" title="IndexError"></a><code>IndexError</code></h3><ul>
<li><p><strong>原因</strong> ：尝试索引序列（例如元组、列表、 string）的数字超过了序列的大小。</p>
</li>
<li><p><strong>示例</strong> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  x[100]</span><br><span class="line">IndexError: tuple index out of range</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong> ：确保索引在范围内 顺序。 如果您使用变量作为索引（例如 <code>seq[x]</code>, 确保变量被分配给正确的索引。</p>
</li>
</ul>
<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>因为两个列表可能内容相同，但实际上是不同的列表，所以我们需要一种方法来测试两个对象是否是同一个。Python 包括两个比较运算符，称为 is 和 is not，它们测试两个表达式实际上是否计算为相同的对象。如果两个对象的当前值相等，则它们是相同的，并且对一个对象的任何更改都将始终反映在另一个对象中。身份是比相等更强大的条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suits is [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; suits == [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>字典也确实有一些限制：</p>
<ul>
<li>字典的键不能是或包含可变值。</li>
<li>对于给定的键，最多只能有一个对应的值。<br>非局部语句 (nonlocal statement)。当我们调用 make_withdraw 时，我们将 balance 绑定到初始金额。然后我们定义并返回一个局部函数 withdraw，它会在调用时更新并返回 balance 的值。</li>
</ul>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_withdraw(balance):</span><br><span class="line">        &quot;&quot;&quot;返回一个每次调用都会减少余额的 withdraw 函数&quot;&quot;&quot;</span><br><span class="line">        def withdraw(amount):</span><br><span class="line">            nonlocal balance                 # 声明 balance 是非局部的</span><br><span class="line">            if amount &gt; balance:</span><br><span class="line">                return &#x27;Insufficient funds&#x27;</span><br><span class="line">            balance = balance - amount       # 重新绑定</span><br><span class="line">            return balance</span><br><span class="line">        return withdraw</span><br></pre></td></tr></table></figure>
<p>非局部语句声明：每当我们更改 balance 的绑定时，绑定关系都会在已经绑定 balance 的第一帧中更改。回想一下，如果没有非局部语句，赋值语句将始终在当前环境的第一帧中绑定。非局部语句指示名称不会出现在第一个（局部）帧或最后一个（全局）帧，而是其他地方。</p>
<h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><figure class="highlight plaintext"><figcaption><span>inc_subseqs(s):</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Assuming that S is a list, return a nested list of all subsequences</span><br><span class="line"></span><br><span class="line">    of S (a list of lists) for which the elements of the subsequence</span><br><span class="line"></span><br><span class="line">    are strictly nondecreasing. The subsequences can appear in any order.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs = inc_subseqs([1, 3, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1, 2], [1, 3], [2], [3]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; inc_subseqs([])</span><br><span class="line"></span><br><span class="line">    [[]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs2 = inc_subseqs([1, 1, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs2)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1], [1, 1], [1, 1, 2], [1, 2], [1, 2], [2]]</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def subseq_helper(s, prev):</span><br><span class="line"></span><br><span class="line">        if not s:</span><br><span class="line"></span><br><span class="line">            return [[]]</span><br><span class="line"></span><br><span class="line">        elif s[0] &lt; prev:</span><br><span class="line"></span><br><span class="line">            return subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            a = subseq_helper(s[1::],s[0])</span><br><span class="line"></span><br><span class="line">            b = subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">            return insert_into_all(s[0], a) + b</span><br><span class="line"></span><br><span class="line">    return subseq_helper(s,0)</span><br><span class="line"></span><br><span class="line">seqs = inc_subseqs([1, 3, 2])</span><br></pre></td></tr></table></figure>

<h3 id="反转奇数深度树的标签"><a href="#反转奇数深度树的标签" class="headerlink" title="反转奇数深度树的标签"></a>反转奇数深度树的标签</h3><figure class="highlight plaintext"><figcaption><span>t.is_leaf():</span></figcaption><table><tr><td class="code"><pre><span class="line">        return </span><br><span class="line">    label_list = []</span><br><span class="line">    for b in t.branches:</span><br><span class="line">        label_list.append(b.label)</span><br><span class="line">    for b, new_label in zip(t.branches, reversed(label_list)):</span><br><span class="line">        b.label = new_label</span><br><span class="line">        for bb in b.branches:</span><br><span class="line">            reverse_other(bb)</span><br><span class="line"></span><br><span class="line">我的解法：</span><br><span class="line">def helper(t,depth):</span><br><span class="line"></span><br><span class="line">        if depth%2==0:</span><br><span class="line"></span><br><span class="line">            if t.is_leaf():</span><br><span class="line"></span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            else:</span><br><span class="line"></span><br><span class="line">                for branch in t.branches:</span><br><span class="line"></span><br><span class="line">                    helper(branch,depth+1)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            labels=[]</span><br><span class="line"></span><br><span class="line">            brans=t.branches</span><br><span class="line"></span><br><span class="line">            for branch in brans:</span><br><span class="line"></span><br><span class="line">                labels.insert(0,branch.label)</span><br><span class="line"></span><br><span class="line">            for new_label,new_branch in zip(labels,brans):</span><br><span class="line"></span><br><span class="line">                new_branch.label=new_label</span><br><span class="line"></span><br><span class="line">            for bran in brans:</span><br><span class="line"></span><br><span class="line">                helper(bran,depth+1)</span><br><span class="line"></span><br><span class="line">    helper(t,1)</span><br></pre></td></tr></table></figure>

<h3 id="生成器的生成器"><a href="#生成器的生成器" class="headerlink" title="生成器的生成器"></a>生成器的生成器</h3><figure class="highlight plaintext"><figcaption><span>make_generators_generator(g):</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Generates all the &quot;sub&quot;-generators of the generator returned by</span><br><span class="line"></span><br><span class="line">    the generator function g.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_m_ints_to(n, m):</span><br><span class="line"></span><br><span class="line">    ...     i = 0</span><br><span class="line"></span><br><span class="line">    ...     while (i &lt;= n):</span><br><span class="line"></span><br><span class="line">    ...         yield i</span><br><span class="line"></span><br><span class="line">    ...         i += m</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_3_ints_to_10():</span><br><span class="line"></span><br><span class="line">    ...     for item in every_m_ints_to(10, 3):</span><br><span class="line"></span><br><span class="line">    ...         yield item</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; for gen in make_generators_generator(every_3_ints_to_10):</span><br><span class="line"></span><br><span class="line">    ...     print(&quot;Next Generator:&quot;)</span><br><span class="line"></span><br><span class="line">    ...     for item in gen:</span><br><span class="line"></span><br><span class="line">    ...         print(item)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    9</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">    def gen_helper(lst):</span><br><span class="line"></span><br><span class="line">        yield from lst</span><br><span class="line"></span><br><span class="line">    yield_sofar = []</span><br><span class="line"></span><br><span class="line">    gg = g()</span><br><span class="line"></span><br><span class="line">    for x in gg:</span><br><span class="line"></span><br><span class="line">        yield_sofar.append(x)</span><br><span class="line"></span><br><span class="line">        yield gen_helper(yield_sofar.copy())</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="生成器生成树的搜索路径"><a href="#生成器生成树的搜索路径" class="headerlink" title="生成器生成树的搜索路径"></a>生成器生成树的搜索路径</h3><pre><code>if t.label == value:
        yield [value]
    for b in t.branches:
        for path in path_yielder(b, value):
            yield [t.label] + path
</code></pre>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls原著梗解析</title>
    <url>/2023/09/29/blacksouls%E5%8E%9F%E8%91%97%E6%A2%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><p>众所周知，black souls的原型，或者说最重要的灵感来源就是爱丽丝梦游仙境以及它衍生的爱丽丝镜中奇遇，我本人一直对游戏和原著的对应关系感到很好奇，但由于工作量很大，一直没下定决心做这件事，但最近突然想到，如果分期做一些整理会不会就没那么麻烦了呢，于是决定开启这个系列。</p>
<span id="more"></span>
<p>由于是第一期，我就扯一些闲话，爱丽丝的原著可谓有着非常深远的影响，首先，他就是最著名的童话之一，在儿童里的传播极为广泛，在我小时候就听说并读过这个作品，但说实话爱丽丝的原著对孩童来说实在太过思维跳脱，导致我虽然通读了几遍但完全没看进去，考虑到当时的儿童文学相比现在的完善可以说几乎不存在，这本书可谓有着相当的意义，不过我毕竟没有研究过相关文学史所以不多评价了，对于爱丽丝的原著，我最深刻的印象就是其无比丰富的想象力以及跳脱的情节（由于卡罗尔是数学家，他还塞了不少数学梗进去），可能这就是莉耶芙喜欢这本书的初衷吧。<br>此外，爱丽丝这一形象与整个不思议之国以无数的二次创作形象疯狂地在各种娱乐作品里传播，关于这点，我认为是爱丽丝原著符号性强烈的特点导致的，永无止境的茶会，跳进兔子洞等元素非常具有符号性，它们奇怪到引人注目，但谁也不知道到底指的什么，可能有意义，可能没有意义，二次创作者可以非常自由地阐释这些元素，因此导致了在二次元文化里，爱丽丝近乎成了最常见的一个人名或者说符号<br>最后则是它的现实作者，金属冶炼在欧美文化里是个很敏感的话题，关于原作者此方面的谣言可以说满天飞，但对此我只能说疑罪从无，没有直接证据表明这一点，就连一些间接证据在我看来也很明显是牵强附会，基于道德的角度，我们不该用一些间接证据指责两个世纪前人物的私事，此外，black souls是毋庸置疑的架空世界观作品，不管怎么编故事也和现实中的卡罗尔毫无关系。<br>当然black souls设定下的卡罗尔也是个经常被讨论的问题，由于冬之钟那个崩坏的adv，很多人认为black souls的卡罗尔是个炼金术师，但是很明显小剧场不过是哪个支配者的大作，而且是个很有虫虫风格的作品，没有任何证据表明black souls设定下现实的卡罗尔干了相同的事，总的来说我认为black souls世界观的卡罗尔，除了他一直深爱爱丽丝以外和爱丽丝一家的关系是没有确切信息的，而且这种爱也可能不是男女之爱，只是柏拉图之恋罢了。<br>好吧，关于原著以外的讨论就说到这里，接下来我们开始具体情节的对照分析。<br>第一章的开头，小爱丽丝和姐姐一起坐在河边，姐姐在看一本没有插图没有对话的书，让小爱丽丝感到无聊。<br>书在black souls中是个很常见的意象，没有插图的书只在牛津学院的回忆中提到过一次，读书的倒是有几个，一代的爱丽丝02一直看着书，书上的内容似乎是格林被玛丽苏毁灭时的遗言，此外，一代的尸龙也在读着书，而且二代时她也在河边，根据她念出来的部分，其实就是我们这个世界的卡罗尔描写邪龙贾巴沃克被打倒的那首诗，个人猜测有可能black souls中卡罗尔没有给爱丽丝送出去的礼物其实是他的作品集，后来卡罗尔被玛丽苏捉走，这本书则被尸龙拿走，最后，二代的白女王诺登也是个看书人,这本书格林无法阅读，但0sen下能看到轮回次数<br>由于02不是任何人的姐姐，白女王虽然很御姐，但原型明显是白兔先生，所以对应度最高的其实是贾巴沃克，此外尸龙摸鱼的时候摘花，而此时的爱丽丝也有摘花的意图，可能暗指温柔的尸龙姐姐摘花编成花环想送给爱丽丝（迫真）<br>随后就是经典的爱丽丝跟着匆忙的白兔先生进了兔子洞的环节，此时的白兔先生声称自己是急着去找公爵夫人<br>兔子洞在一二代都有对应，一代追寻着原著顺序，跟着白兔，从兔子洞跳下就能到达不思议之国，二代却是相反的，格林先到坠落之间，然后才到兔子洞<br>此外，原著对坠落的描述是，途中有很多书架以及各种柜子，这点在坠落之间和兔子洞都有体现，爱丽丝在坠落后第二次见到了匆忙的白兔先生，而按通常的流程，也是格林过了兔子洞后进行度为1才能见到白兔诺登，此外原著中爱丽丝第一次来到的门厅顶上有一排灯，这可能是图书馆的进行度灯的灵感来源，原著中爱丽丝用钥匙打开一扇门后来到了放有变大变小药的房间，游戏可以直接到达，喝了我和吃了我是非常经典的原作梗。<br>以上是爱丽丝原著第一章和游戏的对应关系，那么今天就到此为止了</p>
<h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><p>接下来开始第二章的分析<br>吃下蛋糕后的爱丽丝身形变得非常巨大，也因此挤不进她想去的花园，此时她哭泣的眼泪形成了泪水池，对应bs的血泪之池，有种说法是红偶像紫餐产生的血泪形成了血泪之池，如果从致敬原著看的角度倒是不无可能<br>这时白兔先生经过，被爱丽丝吓跑，留下了手套和扇子，扇子有着让人变小的能力，但此时不知情的爱丽丝一边扇扇子一边开始自我怀疑，正是这时她提到了梅贝尔这个名字。<br>根据爱丽丝的说法，梅贝尔什么都不知道，住在又破又小的房子，没有玩具还要天天念书，对应bs中的梅贝尔，某种程度上讲还挺还原的<br>随后被扇子变小的爱丽丝掉进了泪水池，并在池子里遇到了一只耗子以及其他动物，她们一起游上了岸。<br>接下来就是第三章了<br>此时耗子开始上起了历史课，这段剧情在bs有两个对应点，一个就在酒馆里耗子直接出场给我们上课，而则是牛津学院的回忆提到爱丽丝讨厌历史课。<br>随后为了让湿透的衣服变干，渡渡鸟为她的动物朋友们召开了一场赛跑会，跑完宣布大家都赢了，但奖品让爱丽丝颁发，甚至包括爱丽丝自己的奖品，于是爱丽丝给所有人每人一颗糖，给自己发了一只丁真，很对应游戏血泪之池的渡渡赛跑会，但游戏中只有杀害渡渡会得到一颗糖果,杀害其它动物没有奖品（私藏奖品的屑），附近可以捡到糖果，此外，游戏和原著中的赛跑参与者是不完全对应的，赛跑中白鹅会提到鹦鹉和鹰缺席了，原因吗，因为涉及一些书本以外的东西我们以后再说<br>此后螃蟹母子的对话会提到好脾气的牡蛎，可能对应bs的dlc1嚣张的牡蛎<br>第四章中爱丽丝被白兔错认为了玛丽.安，白兔家的女仆，这就是为什么被白兔诺登剥夺神力的虫虫改名成玛丽.安并且穿着女仆装。<br>爱丽丝喝了让自己再次变大的药水，然后被挤进了房子里无法动弹，此时她吐露了自己不想长大的愿望，随后，蜥蜴比尔被派去搬来梯子，爬进烟囱里查探情况，被爱丽丝一脚踢飞出去，这段对应bs大圣堂里比尔搭梯子的剧情，顺便一提，比尔除了倒霉蛋属性外在bs里几乎全被魔改了，合理怀疑是莉耶芙加了什么私货进去。<br>随后爱丽丝吃下了被扔进来的蛋糕，再次变小，并逃进了一个长着高大蘑菇的森林，并在蘑菇上遇到了抽烟的青虫，对应游戏中的孢子之森，第四章结束<br>也就是说原作爱丽丝的路线就是兔子洞-血泪之池-孢子之森，这也是为什么进行度0时会在森林遇到爱丽丝的幻象，虽然这一路线并不一定遇到比尔<br>格林和希夏的对话基本对应原作爱丽丝和它的见面，一开始不理不睬，但离去时希夏开口挽留，原著毛虫让爱丽丝背了首威廉老爹的诗，对应孢子之森的boss，游戏与原作不同的是，原作的虫子告诉爱丽丝吃下蘑菇可以变大变小，游戏中直接让格林去找公爵夫人<br>爱丽丝见过青虫后有段剧情，爱丽丝吃下蘑菇后脖子变得很长，被一只孵蛋的鸽子认作来吃蛋的长虫，这里译本的长虫其实就是大蛇的意思，这段剧情在游戏也有两个对应，一是游戏中的物品鸽子蛋，孢子之森能捡到鸽子蛋，杀害希夏会掉落鸽子蛋，正好符合原作顺序，对其的描述是少女不吃生蛋，蛇却很喜欢吃，也符合原作，bs中的蛇只有蛇神，而0sen下看到他的脖子很长，也对应原著情节；第二个疑似的对应点则是卡罗尔川的矮胖子，可以孵化出雏鸟，但除此以外和原著没什么对应</p>
<h1 id="03"><a href="#03" class="headerlink" title="03"></a>03</h1><p>接下来我们开始第六章，公爵夫人的章节<br>公爵夫人馆外能遇到名为幼犬的怪物，这应该对应书中第四章，遇到青虫前爱丽丝遇到的小狗，馆内可以遇到鱼和蛙之听差，原作中他们分别是女王派来邀请打縋球和公爵夫人处接受邀请信的佣人。<br>公爵夫人是比较还原原著的一个角色，基本上所有行为举止都有对应。爱丽丝初见她的场景和游戏中几乎完全对得上，婴儿和猪的转化则用sen值来实现（顺便一提屠宰场也有类似的转换），只有柴郡猫没有出现，但馆内一张挂画上则会出现柴郡猫，这张挂画上随着sen值不同也会出现猪和婴儿的转变，此外，由于公爵夫人还原度很高，我把台词中的对应点用图整理如下<br>公爵夫人另一个原型，也是她名字和贪食属性的由来则是一幅画作，这幅画作（比较哈人就不放了）可能的历史原型是一位贵族女性，她在历史上有大嘴的外号，并且和丈夫并不恩爱（甚至没同过房？），这解释了里线中她的台词<br>游戏中柴郡猫瞬忽隐忽现，还有标志性的微笑都出自此章，不过对她来说似乎更认同爱丽丝家的猫的身份，然而她又部分否定了戴娜的身份<br>值得一提的是，此前我们提到的原作路线都是有着某种程度上的认证的，到森林的路线有爱丽丝幻影，随后有希夏的指引，但从公爵夫人开始跳脱出了梦游仙境，让我们去了镜中奇遇，并且地图到了这里也确实是死路，如果继续按公爵夫人的指引，到达库因兰德这条死路后也确实找到了爱丽丝，虽然格林并不知情。<br>而如果我们想要继续原著路线，就要踏上不同的路，经过牛津学院到达永不终焉的茶会，为什么呢？<br>关于茶会我很有些个人想法，但我们先从原著的角度说起<br>虽然一二代都有茶会，但比较对应原著茶会一段的是二代的茶会，原著中帽匠和三月兔被柴郡猫钦定为疯子，可以说是整部作品里最荒诞的一段，在bs中也不遑多让，我们先从三人的现实原型说起，帽子屋的原型是中世纪的帽匠，由于工艺会用到水银，所以有着疯疯癫癫的形象（游戏也提到这点），三月兔的原型是一句俗语，这句俗语的由来据说是兔子三月处于繁殖期而狂躁不安，所以会有这种人设，睡鼠原型则是一种常见的宠物，非常嗜睡，当时人们喜欢把它养在茶壶里。<br>我们分人物说起，首先是帽匠<br>原著一见到爱丽丝，帽匠就大喊没位置了，并且抛出了乌鸦桌子的谜语，和游戏一样，这段谜语若干年后卡罗尔才公布答案，所以游戏的帽子屋说不知道答案。<br>随后，爱丽丝说自己说的和想的一样，三人一人一句地反驳了她，其中除了三月兔抛出的两句话，都是主语宾语单项包含关系，但游戏中爱丽丝的话由帽子屋说出，并只有睡鼠保留着这种逻辑关系。<br>面包黄油的对话几乎完全致敬原著。<br>原著爱丽丝与柴郡猫对话提及此刻是五月，和帽子屋对话提及今天是4号，游戏中时计塔的密码1852正是爱丽丝的生年，所以游戏中帽子屋会说擅长happy birthday<br>帽匠会提及，自己和时间闹翻了（红心女王的说法是谋杀时间），所以茶会被永远定格到这个时间，餐盘只能越积越多，这可能是游戏中帽子屋不死能力的来源，监禁后她离开了茶会，所以又可以杀死了，此外，游戏中狂鸟一定程度上和时间有着关系，并且帽子屋很讨厌她，或许和原著这段情节有关（但帽子屋又称呼时间为先生）<br>随后是三月兔，原著中三月兔头顶缠着稻草，卡罗尔说这表示她疯了，游戏致敬了这点。<br>原著的三月兔打翻了牛奶，游戏中是红茶<br>最后是睡鼠，睡鼠在原著中唱歌和讲故事都和游戏里对应，故事中三个小姑娘的名字对应利德尔三姐妹，讲故事时，三人责怪爱丽丝打岔，在游戏中里线战斗对话有体现。<br>好了，以上是和游戏原著比较对应的地方，接下来我就说说对茶会的个人理解，再强调一下，都是个人理解。<br>茶会可以说是bs2中一个很重要的地图，它和牛津学院直接相连，并且两张地图连续有一个回忆，而进入牛津学院主流的路线就是从精神病院开始通过路德维希市街，见证伊迪斯和杰克的悲剧，顺便一提关于利德尔三姐妹，我之后会出个特辑，这里先不谈，漫布迷雾的街道明显是在neta伦敦，并且卡罗尔是英国人，曾在牛津学院任职，这条路线可以说是最贴近现实的一条路。<br>此外，如果要防止狂鸟唱歌，就必须先来到茶会去往时计塔，并且时计和箱庭的运转息息相关，而狂鸟唱歌的目的应该就是让格林别乱跑了去找爱丽丝，此外，不思议之国的大部分地方都很有着阴森的氛围，而且弯弯绕绕，只有茶会非常狭小却坐拥一个篝火而且阳光明媚氛围悠闲，几乎可以磨灭格林的斗志了，茶会的三个参与者就更有意思了<br>如果我们给三人归纳一个关键词，一个是疯狂，一个是爱欲，一个是睡梦，三者加在一起几乎概括出了整个二代的特点，这恐怕是奈亚不想让格林意识到的，此外，来到茶会必然会遇到伊迪斯，按原作顺序之后就是红心女王罗丽娜，两人是乱入者，且都曾和卡罗尔关系亲密，奈亚不希望她们引发卡罗尔的回忆，所以才会让夫人把我们支开。<br>对这三人和她们的象征意义，疯狂和爱欲其实不必多说，但睡梦其实是一条相对的暗线，我一直认为寿司是一个很喜欢前后对照的作者，所以就让我们来分析一下，不少npc会提及此处是个梦境，但最早是在op，游戏的开头是格林苏醒，看到爱丽丝，然后不知道为什么再次睡去，因此我们如果认真看开头就会知道不思议之国是个梦境，那么为什么设定成梦境呢，首先是由于协助创造箱庭的诺登的原型是所谓的幻梦境之主，其次呢就是因为原著的结局会发现爱丽丝的奇遇是一场梦，光是这点就很有意思，两者揭露梦境的时间点完全相反。<br>那么问题来了，已经在梦境了，如果再次做梦不就有了梦中梦？而如果是梦境是虚假，梦中梦则是虚假的虚假，会不会是真实呢？格林做过几次梦中梦呢，第一次是精神病院看到师匠，第二次是孢子之森的幻觉爱丽丝，第三次是海底的旅社，第四次是冬之钟adv，牛津学院的月面比较特殊就不论了，这几次梦中梦，虽然未必都是真实，但都揭示了部分真相或者现实。<br>既然如此，有一个人就很奇怪了，睡鼠，她是格林外唯一一个能在梦境中沉睡的人，如果是格林自己的梦还可以做梦中梦，但睡鼠一个梦境中的角色怎么还能入梦呢？除非她只是装睡，对话中睡鼠会说她没有睡，所有人的对话她都没有听漏，这很有可能就是真相（虽然里线又说真在睡），并且她随后说了一句要杀了所有人，然后辩解说是梦话，结果全监禁后她真的这么做了。<br>因此个人猜测睡鼠表面虽然入梦，但其实是最清醒敏锐的，她有着监视格林的任务，一旦格林不照着剧本做梦，滞留在一次轮回中，就会把风险清除掉，逼迫他进入下个轮回。<br>而h结局中在冬之钟我们能看到三月兔和帽子屋，她们的对话反过来看就是冬之钟的本质，为什么只有这两个人呢？一是三人的对话提到除了睡鼠两人都想来冬之钟，二则是根据我的想法，此时格林意识上已经从梦里醒来，剩下的问题就是奈亚的爱欲，以及舞台带来的疯狂，也就是茶会的这两个人的象征。<br>当然，以上不过是个人解读，大家看个乐就行。<br>可能有人问，那么一代的茶会呢？这个由于时间线的原因我们以后再讲。</p>
<h1 id="04"><a href="#04" class="headerlink" title="04"></a>04</h1><p>让我们开始第八章的分析<br>七章末尾，爱丽丝被疯疯癫癫的三人惹恼，离开了茶会，进入了一片森林，在她迷路时出现了一道门，让她回到了最初的兔子洞大厅，随后她利用变大变小的能力走进了最初看到的庭院。<br>这段路线，如果我们忽略茶会怎么回到兔子洞这个问题，可能对应利德尔墓地到心脏庭院，墓地这块确实是森林，并且进入庭院的入口确实是一道门，虽然顺序颇有些问题。<br>原著中，入口旁的三个扑克园丁忙着把种错的白玫瑰刷成红心王后喜欢的红色，随后被王后发现要杀头，游戏中只有一个庭师在干活，而且不是上漆而是上血，另外两个则在说格里芬的闲话。可能是rpgmaker的素材问题，原著和游戏的扑克种类对不上<br>原著中红心王后杀头的表达翻译过来大概是这样的：他们的头没了吗？士兵的回答是：“他们的头不见了”由此王后认为确实杀头了，这里是个文字游戏，原著中这三个园丁藏了起来，头确实看不见了，但没有杀头，这可能是游戏中红心女王不看处刑场面的由来。<br>杀头后王后邀请爱丽丝打追球，但是球棍是火烈鸟，球是刺猬，两者都会在游戏出现，区别是火烈鸟0sen变成弯曲的球棍，球则在0sen才出现<br>打球的时候公爵夫人来向爱丽丝搭话送了她几句教训，对应游戏中公爵夫人出现在追球场并且满口教训，随后王后再次出现在爱丽丝面前，带她回去打球，这次过程中王后把除了国王的所有人判了死刑，随后国王赦免了他们。<br>可能是由于实际上外来者的缘故，红心王后也被魔改得很厉害，基本上只有性格和杀头的口头禅是还原原著的，此外，原著的红心王后虽然没杀过一个人的头（狮鹫的说法），但被所有身边人畏惧，这点也沿用到了游戏中，红心王后可能的原型是当时的英国女王，这也是为什么游戏中红城bgm是掷弹兵进行曲。公爵夫人会说红女王和红心女王一样残暴，这段可能来自于卡罗尔自己对两位皇后的解释。原著的红心国王直接删掉了，是梦游仙境唯二个游戏里没有对应的主要人物（还有个是红桃杰克），当然也有可能对应格林（笑）。<br>之后，王后让狮鹫带爱丽丝去听假海龟的故事，对应游戏里罗丽娜发布布告让部下去讨伐食尸鬼，因为会在那里见到假海龟。原著中在女王走远后，狮鹫说到女王从来没有成功杀过一个人的头，对应游戏中格里芬说女王不敢看处刑场面<br>这里顺便一提，狮鹫是卡罗尔任职的牛津学院的三一学院的院徽，假海龟出自当时用牛肉汤代替昂贵海龟汤的习惯，原著中狮鹫懒散，假海龟则惶恐不安，和游戏对应，假海龟哭哭啼啼地讲起了自己的故事，它曾在深海的学校上课云云，这里是非常典型卡罗尔造生词环节，游戏中有原台词化用<br>说完上课的事后，狮鹫提出跳龙虾方块舞，游戏中则是龙虾舞，为什么呢，我给大家三秒钟猜一下，因为格里芬是方块骑士，所以已经有方块了，这很可能是方块骑士身份的来源，因为除此以外原著只有一些方块廷臣，其中的歌是假海龟唱的，游戏中也有体现，格里芬说自己不记得歌词<br>随后狮鹫让爱丽丝背了几首诗，最后假海龟唱了一首海龟汤，对应游戏中让假海龟做料理的台词<br>关于爱丽丝的线索，女王和格里菲会引导格林去市街，市街的卡面来打会引导格林去墓地方向，随后线索就断了。<br>这之后就是梦游仙境最后一个场景，审判庭，关于审判这件事的信息，翻遍二代也只能找到狮鹫去邀请比尔当陪审员这件事，其中，他们会说审判已经发生过一遍，那么是在哪呢？<br>很有可能是在一代的不思议之国。已然终结的茶会，最明显的是守门的班达斯奈奇，他提出的问题和答案部分和原著的审判相对应，茶会中的一只兔子会提到疯帽子三人以及爱丽丝的消失，这正是原著剧情，收集童话出现的里门，爱丽丝排列成类似法庭陪审团的形式面朝格林，这很有可能也是表示审判。<br>此外，我也有些个人想法，杀害02得到的缎带物品描述是追寻梦中的爱丽丝，这几乎可以肯定指的二代，而爱丽丝原著正是在最后的审判后告诉我们一切都是梦，然后见到了姐姐，而这和一代也在读书的尸龙姐姐勉强对得上，审判后的爱丽丝消失了，奈亚丽丝用格林取代了她的位置一直梦游到了审判剧情前，这样一来就构成了一个循环，爱丽丝梦游仙境结束后开始格林梦游仙境，这是很有寿司风格的前后对照。<br>此外，还有一种可能的解读是，审判其实是奈亚丽丝内部召开的，最后判决结果是把爱丽丝01驱逐出去，产生了红偶像<br>总之，审判这段原著情节在bs有没有对应大家就见仁见智吧<br>好了，这样一来对梦游仙境的解析就结束了，下一期作为拾遗篇，我会说说卡罗尔和利德尔三姐妹在游戏中的暗线。</p>
<h1 id="拾遗篇"><a href="#拾遗篇" class="headerlink" title="拾遗篇"></a>拾遗篇</h1><p>查尔斯·道奇森，一个天赋型的数学家，笔名刘易斯.卡罗尔，最知名的作品是两本以知名幻想角色爱丽丝为主角的作品，与同时代知名的柯南道尔（福尔摩斯系列的作者）同是一个灵异研究学会的成员，还有一个较晚出生的知名的同时代人是克苏鲁体系的作者洛夫克拉夫特<br>有意思的是以上提到的三人分别是三种文学流派的奠基人，并且这三种衍生文化不同程度地影响了bs系列<br>1855年，卡罗尔23岁，结识了自己任职学院的院长一家，一年后认识了三姐妹，随后的时间他时常和这家的三姐妹一起聚会，1962年7月4日，一个黄金的午后，当时三姐妹的长女罗丽娜13岁，次女10岁，三女8岁，与卡罗尔一起泛舟湖上，卡罗尔讲了一个日后成为梦游仙境原稿的故事，两年后整理成了一部名为地底冒险的手稿送给次女。<br>1863 年 6 月，利德尔一家和卡罗尔之间的关系突然破裂，没有直接证据能说明原因，几个月后有所缓和，但已经无法还原如初的美好了。<br>再之后，长女没有在历史上留下痕迹，次女和三女都和一位王子有过绯闻，但可能因为身份原因没有成，可怜的三女在即将结婚时22岁因病早逝（精神病院的开门次数），似乎最受上天关爱的次女于28岁结婚，成为哈格里夫斯夫人。<br>这是我们这个世界历史上的卡罗尔和三姐妹的故事。那么bs世界里这四人发生了什么呢？</p>
<p>最直接的证据是六段苦涩的回忆，虽然对他们的来龙去脉或是真假完全没有确论，但它们提供了大部分相关信息，我们按现实时间顺序一个一个说起。<br>卡罗尔川的回忆直接用了梦游仙境的卷首诗，描述了这个故事的原初，并且由于卡罗尔生活时期正是英国盛世，泰晤士河污染严重，黄金午后的那条河流从属于泰晤士河，和游戏中污染的描述也对得上<br>按现实顺序随后的应该是牛津学院的回忆，卡罗尔和利德尔一家的交恶<br>随后则是槌球场，这里应该对应现实中黄金午后的两年后，卡罗尔送给了爱丽丝地底冒险手稿，这部手稿有卡罗尔自己的插画，但并非圣诞礼物，卡罗尔曾和爱丽丝一家打槌球玩，因此会出现在槌球场，但游戏中此时二家似乎没有交恶，因此bs中可能存在顺序调换。<br>之后就是纯粹的架空时间线了<br>之后是叹息的海边，回忆中摄影的阁楼有现实对应，正是牛津大学的建筑，回忆描述了两人的再次重逢，至于为什么是海边，可能是因为卡罗尔在1876年出版的《猎蛇鲨记》，这是他最后一部知名作品，次女和卡罗尔的重逢历史上没有什么资料，事实上，即使卡罗尔逝世时，次女也就46岁，不可能是老婆婆，但梦游仙境的改编的戏剧于1886年圣诞节期间上映，卡罗尔也去看了，顺便一提，演睡鼠的是一位叫多萝西的女士。这是有记载的卡罗尔最后一次见到次女，而有记载的次女最后一次与卡罗尔有交集，是在1932年卡罗尔逝后的100年诞辰，这时她已经80岁了<br>再后面是库因兰德的回忆，库因兰德的女王原型是镜中奇遇的红女王，而镜中奇遇出版于1871年。这段回忆似乎提到卡罗尔把另一个人当做代餐，可能是bs世界观的罗丽娜？<br>最后是完全架空的茶会回忆，和现实基本没有关系了。<br>其次还有若干原著彩蛋在游戏中使用，如卷首诗，也就是第一段回忆的little和利德尔同音，血泪之池的鹦鹉和小鹰分别是长女和三女的书中化身，睡鼠的故事也化用了三姐妹的名字等</p>
<p>卡罗尔在bs中和现实基本对应得上，但还有的问题是，猎蛇鲨记，贾巴沃克等作品的来源没有交代，其中贾巴沃克这首诗尸龙基本给我们念了一遍，有可能原稿在她手上，此外卡罗尔虽然终身未婚，但依然有很多朋友，如猎蛇鲨记就受一位忘年交的启发，可能是冬之钟小剧场那张照片中的女人<br>顺便一提，现实中的弗朗西斯.利德尔1965年出生，自他记事起卡罗尔和利德尔一家应该都不怎么来往了，现实中的三姐妹和当时的大部分贵族女性一样在家中由私教授课，不可能叫卡罗尔老师</p>
<p>之后我们来分别探讨一下三姐妹在bs的暗线<br>现实中的长女资料最少，但书中的鹦鹉有卖弄自己年纪大的特点，并且有一种说法是，当年的长女对卡罗尔非常依恋，这些特点沿用到了游戏中，有可能bs中的卡罗尔倾吐虚假爱意的对象就是她。根据其自述，罗丽娜向邪神献祭灵魂才会来到不思议之国，但时间点未知，如果是在次女后，那么游戏中的罗丽娜是完全的少女心性就很奇怪了。还有一种说法是，罗丽娜和她的母亲名字一样，所以小剧场那张照片的真身有可能是……不过我觉得这可能很小就是了<br>心脏女王也是个谜点重重的角色，如果我们给有梦游仙境原型的誓约角色所需魂数量排序，那么由小到大依次是白兔，渡渡，比尔，希夏，公爵夫人与假海龟，帽子屋，心脏女王<br>其中除了假海龟都参照原作出场顺序，她虽然是乱入者，但不思议之国大部分住民都会提到并认同女王是名义上的统治者，她不知为何能指挥魔兽化的手下，让唯一有理智的格里菲去全国巡逻，每天用审判来控制人口，还给大工批了大把建筑费用来上达天听，不知道是奈亚的命令还是什么其他原因，她确实做了很多管理不思议之国的事，此外，还是唯一一个非格林子女却有里线战斗的<br>三女伊迪丝在游戏中是精神病院的boss，对于她怎么来到箱庭，仅有的线索是混沌迷宫和电影院的两段没头没尾的故事，游戏里和三女私奔的王子，很可能也是杰克，这位角色现实原型之一很可能是利奥波德王子，正如前文所说，据传他曾与伊迪丝相爱，伊迪丝22岁早夭后，王子为她抬棺，王子和伊迪丝一样病弱，患有血友病，三女辞世的8年后，王子以30岁的年龄逝世，这或许是游戏中他也住院的原因，另外两个明显原型是开膛手杰克和福尔摩斯，或许是因为卡罗尔曾被看做开膛手杰克的嫌疑人，而同时代柯南道尔也曾经研究过这个案件，顺便一提上文王子的一个侄子也是一大嫌疑人<br>伊迪丝在冬之钟小剧场里头戴着枯萎的花圈，可能暗示着她的早逝，并且多次有小鹰的元素出现，但罗丽娜除了大姐作风却没有明显的鹦鹉元素，这点也有些让人在意<br>最后是次女，这里的次女指的是观星引来奈亚的人类个体，关于这个个体的信息反而是最少的，只知道她和卡罗尔心心相惜却被拆散，她和现实次女的履历是否一样未知，她的最终去向未知，牛津学院的学寮长是否就是她父亲的灵魂所化也未知。<br>关于现实中的对应，现实的次女并非常见的金发形象而是黑发，并且和梦游仙境的爱丽丝有很多差异，游戏中似乎没怎么提到过发色，不知道如何设定，次女和南丁格尔是同时代的人，因此院长认识爱丽丝可能是认识人类状态的次女，此外，小剧场的次女会有很多致敬原著的台词，出示如下<br>在群星之夜后，似乎她的名字成为了禁忌，也是里线剧情的关键，关于次女我还有一个，，<br>等等，次女的名字，为什么，我想不起来次女的名字，对了，她的名字，她的名字不就是<br>爱丽丝.利德尔<br>勿呼其名，唤则得知，蠕动前行而来<br>縺ｩ縺?＠縺ｦ遘√＇谤｢縺辅↑縺代ｌ縺ｰ縺ｪ繧峨↑縺??縺ｧ縺呐°<br>繧｢繝ｪ繧ｹ繧呈尔縺励※缧ゅい繝ｪ繧ｹ繧呈?縺励※缧ゅい繝ｪ繧ｹ繧贞ｿ倥ｌ縺ｪ縺?〒缧<br>诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ<br>诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ</p>
<h1 id="ex01"><a href="#ex01" class="headerlink" title="ex01"></a>ex01</h1><p>相较梦游仙境，镜中奇遇在bs中的对应情节明显变少，但依旧有分析的价值<br>首先是镜中奇遇的卷首诗，这首诗提到了卡罗尔此时和现实的爱丽丝年龄相差一倍，语气中某种程度上可能透露了卡罗尔对无法回到往日时光的惋惜，不管怎么说，此时爱丽丝已经长大了，看童话故事的美好时光已经不会回来了<br>开篇剧情中爱丽丝在和戴娜生下的小猫玩，对应普通结局少女的房间中柴郡猫说自己产下小猫后死去，虽然我们不知道现实的戴娜是怎么死的。<br>随后爱丽丝会提到镜子屋，也就是镜子里的相反的房间，这在之后成为整本书的主题，在bs中镜子屋对应公爵夫人提到了通过血泪之池镜子才能到达的镜之国，但同样和镜子有莫大关系的还有一位小红帽，值得一提的是，镜之国库因兰德是为数不多没有柴郡猫出现的篝火。<br>随后爱丽丝在镜子屋看到了一些会说话的棋子，并随意摆布它们，这段有点像bs奈亚的作风<br>她翻到了一首叫贾巴沃克的诗，当然这里其实是卡罗尔引用之前的作品，贾巴沃克这首诗非常晦涩难懂，以后有机会我会谈谈在它在bs里的对应。<br>之后爱丽丝飞跃滑下楼梯，想跑去屋外的花园，这里的下楼梯法在冬之钟小剧场有对应</p>
<p>爱丽丝想走到一座小山丘俯视花园上，但怎么走都会回到原点，这 里可能对应精神病院的走法，也可能对应库因兰德的迷宫，于是她只能转而去往一个小花园，遇到了一群会说话的花，这些花对应一代圣森和不思议之国的会说话的花，以及在bs2中，红女王的房间里的花，一些花很吵闹，爱丽丝威胁把它们拔下来，对应道具咒骂之花，<br>随后爱丽丝遇到了红王后，原著中的红王后被卡罗尔描述为典型的家庭教师，原型可能就是爱丽丝的家教，bs中红女王的名字直接用了这位家教的名字，有一种说法是卡罗尔利用三姐妹来追求她造成两家决裂<br>爱丽丝羡慕地说想成为王后，红王后告诉她需要前进八格，然后拉着她全力奔跑，贡献了一句经典台词，前进八格成后这是国际象棋的规则，而红王后的台词在bs中对应库因兰德的一个留言和冬之钟柴郡猫的台词<br>值得一提的是在原著中有重要意义的棋盘在bs中也有同样的重要性，红女王的库因兰德遍布着棋子，梅贝尔在自己的箱庭部下棋局，而白女王则把王冠，也就是走了八步后成王的关键放在了冬之钟，可以推测原著中想要成后的爱丽丝其实对应着bs中想要得到改变权能而成王的格林。<br>红王后指引爱丽丝成后的走法，提到了需要乘火车，对应去库因兰德的火车<br>火车上爱丽丝遇到了一只会说话的虫子，在一阵颠簸后她们发现自己安静地坐在树下，爱丽丝和它讨论了一下命名学，虫子告诉爱丽丝前方有着无名之森，对应bs里的那张地图，这只虫子可能也对应无名之森的一只虫形怪物<br>无名之森里爱丽丝遇到了一只小鹿，对应bs中无名之森的小鹿，但bs中通过无名之森才能坐火车，与原著相反<br>本章的末尾，爱丽丝遇到了双子</p>
<h1 id="ex02"><a href="#ex02" class="headerlink" title="ex02"></a>ex02</h1><p>爱丽丝接下来遇到的是崔德尔双子，二者一开始站立不动，让爱丽丝觉得他们是蜡人偶，也就是蜡像，游戏中反了过来，游戏中双子提到了站立不动的格林是蜡像的可能<br>两兄弟的原型是一首英国童谣，童谣提到了丢失的拨浪鼓和飞来筑巢的乌鸦，在游戏双子的台词有体现，筑巢的大鸟应该就是伊迪丝<br>随后两兄弟给爱丽丝背了首海象和木匠的诗，大意是海象和木匠偏小牡蛎来做客，然后把它们吃完了，游戏中很明显海象对应希伏契，木匠对应大工，吃牡蛎的剧情也在希伏契对话中有体现，且，双子誓约对话会提到两人<br>之后，爱丽丝发现了附近正在做梦的红王，在双子对话中有原意复用<br>双子中的蒂看到了他弄坏的拨浪鼓，让两兄弟起了矛盾，对应游戏中的台词，随后两人约定决斗，可能对应游戏里的双子相残，就在这时乌鸦飞了过来，打断了决斗<br>书中的两兄弟按棋谱来说是白方，这解释了她们为何与dlc3的克里米亚有一定关系</p>
<p>为了躲避大鸟，爱丽丝逃进树林遇到了白王后，与严肃的红王后不同，白王后非常随和友好，并且她声称自己是倒着过日子的，这解释了白女王诺登管理重启轮回的职能<br>交谈一会后，爱丽丝突然转移到了一间商店里，店主是一只绵羊，发生了很多怪事后爱丽丝又闪现到了小船上和绵羊一起划船，对应游戏里老羊的台词<br>书中这段空间转换非常频繁，可能因此寿司在老羊商店里放了一堆来源不明的谏言</p>
<p>一连串的转换后爱丽丝看到了矮胖子，这位角色也来自于一首英国民谣，矮胖子很多台词台词在游戏里有直接对应，整理如下<br>值得一提的是矮胖子解释了一些贾巴沃克诗的生造词，为后世的译者提供了不少信息。<br>在爱丽丝和它不欢而散后，听到了蛋壳碎裂的声音，暗示它的跌落，但游戏中矮胖子是因为孵化而裂开</p>
<p>爱丽丝再次前进，遇到了白国王和他的部下，信差告诉了他独角兽和狮子为了王冠争斗，这里的两只动物对应苏格兰和英格兰，并且依旧来源于一首民谣，游戏中冬之钟小剧场长女会引用，并且冬之钟也有很多争斗的对应情节，整理如下<br>独角兽傲慢，狮子凶恶，游戏中有一定程度上的体现，两者对应的棋子走法一个诡异难测，一个横冲直撞，也在游戏中对应</p>
<p>随后，爱丽丝遇到了前来将她军的红骑士，但埋伏在旁的白骑士反吃了红骑士，护送爱丽丝成王前的最后一段路，这段几乎没有在游戏里的直接对应，除了冬之钟小剧场he中卡罗尔让三姐妹为他挥手帕用了原台词，并且也有说法是白骑士是作者的投影。<br>但我个人对此有一些猜测，这段很可能对应整个冬之钟剧场，根据一些主流猜测，这段其实是梅贝尔和古兰合谋困住了追击的奈亚，如果我们认为红方是敌方，那么就对应奈亚，指引爱丽丝成王的红王后对应反水的红女王，红骑士表示前来追击的奈亚，白骑士就可能是白女王方的梅贝尔，那么这段剧情就成了，奈亚前来将住格林，梅贝尔前来解围，护送格林到了成王之路</p>
<p>终于，爱丽丝戴上了王冠，格林成了“王”，在此之后的剧情对应很少，青蛙佣人招待爱丽丝去了晚宴，对应游戏中去往古兰晚宴前向海因里希托付女儿，爱丽丝梦醒后红白王后成了黑白两只小猫，对应红女王的台词，可能会在续作有进一步的阐释</p>
<p>至此，对卡罗尔爱丽丝系列的作品就完全结束了，之后有机会可以说说贾巴沃克和猎蛇鲨记</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>基于北大前沿计算实践课和missing semester的linux等编程工具笔记</title>
    <url>/2023/09/29/linux%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://en.wikipedia.org/wiki/Linux">Linux</a>是一群<strong>开源</strong>的、基于<strong>Linux内核</strong>的<strong>类Unix操作系统</strong>集合。</p>
<ul>
<li>操作系统(operating system)：管理计算机硬件和软件资源的程序，为用户程序提供硬件抽象和接口。</li>
<li>操作系统内核(operating system kernel)：操作系统最核心的部分，管理系统的进程、内存、设备驱动程序、文件和网络系统，一直在内存中，不包括图形界面、Shell等功能</li>
<li>Shell：内核的封装，为用户提供更高级的抽象，比如<code>echo</code>、<code>ls</code>、<code>cd</code>等命令，以及进程间通信功能（管道）<span id="more"></span></li>
<li>Unix内核：最早形成规模，被广泛使用的操作系统，由肯•汤普森(Ken Thompson)和丹尼斯•里奇(Dennis Ritchie)发明，使用C编写，现在常用的基于UNIX内核的操作系统有<a href="https://www.oracle.com/solaris/solaris11/">Solaris</a>、<a href="https://www.freebsd.org/">FreeBSD</a></li>
<li>Linux内核：由李纳斯•托瓦兹(Linus Torvalds)在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版UNIX操作系统Minix太难用了，于是决定自己开发一个操作系统。第1版本于1991年9月发布，当时仅有10000行代码。李纳斯•托瓦兹没有保留Linux源代码的版权，公开了代码，并邀请他人一起完善Linux。据估计，现在只有2%的Linux核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有Linux内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权(Benevolent dictator for life, BDFL)。</li>
</ul>
<h2 id="shell的配置"><a href="#shell的配置" class="headerlink" title="shell的配置"></a>shell的配置</h2><p>很多程序的配置都是通过纯文本格式的被称作_点文件_的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p>
<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a> 有非常好的资源</p>
<p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH=&quot;$PATH:/path/to/program/bin&quot;</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p>
<p>还有一些其他的工具也可以通过_点文件_进行配置：</p>
<ul>
<li><code>bash</code> - <code>~/.bashrc</code>, <code>~/.bash_profile</code></li>
<li><code>git</code> - <code>~/.gitconfig</code></li>
<li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li>
<li><code>ssh</code> - <code>~/.ssh/config</code></li>
<li><code>tmux</code> - <code>~/.tmux.conf</code></li>
</ul>
<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p>
<ul>
<li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li>
<li><strong>可以执行</strong>: 您的工具在任何地方都以相同的配置工作</li>
<li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li>
<li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li>
<li>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</li>
</ul>
<p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"></span><br><span class="line"># 使用和 shell 相关的配置时先检查当前 shell 类型</span><br><span class="line">if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"></span><br><span class="line"># 您也可以针对特定的设备进行配置</span><br><span class="line">if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then &#123;do_something&#125;; fi</span><br></pre></td></tr></table></figure>

<p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure>

<p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Test if ~/.aliases exists and source it</span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>在Ubuntu下，我们也可以在网站上下载软件包，后缀为<code>.deb</code>，然后调用<code>dpkg</code>进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure>

<p><code>.deb</code>文件后缀是<a href="https://www.debian.org/">Debian</a>系统的 软件包格式，Ubuntu基于Debian开发因此使用相同的软件包格式，里面包含了程序的二进制文件、配置文件、man&#x2F;info帮助页面等信息。用户 不同的任务依赖大量的软件支撑，不同的软件往往有着复杂的依赖关系，一个软件往往也有很多版本，为了管理这么多的软件，Ubuntu提供了统一的软件管理 机制，也就是<code>dpkg</code>和<code>ap![[download.gif]]t</code>。 <code>dpkg</code>的用法如上所示，<code>dpkg -l</code>可以列出所有的以安装软件，<code>dpkg -r</code>卸载软件，更多命令可以使用<code>dpkg --help</code>或者<code>man dpkg</code>。dpkg安装完成之后，默认文件存放位置如下：</p>
<ul>
<li>二进制文件：<code>/usr/bin</code></li>
<li>库文件：<code>/usr/lib</code></li>
<li>配置文件：<code>/etc</code></li>
<li>使用手册和帮助文档：<code>/usr/share/doc</code></li>
<li>man帮助页面：<code>/usr/share/man</code></li>
</ul>
<p>然而dpkg并不是万能的，当某个软件的依赖项没有安装时dpkg就会报错，需要用户手动安装依赖项。apt很好地解决了这一问题。首先开发者会将 编译后的二进制文件和软件信息存放在Ubuntu的源服务器上，当需要安装软件时，apt会自动从服务器上获取软件依赖信息，然后从服务器上下载依赖并安 装，然后再安装需要的软件。服务器的信息记录在本地的<code>/etc/apt/sources.list</code>中：</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash中的字符串通过<code>&#39;</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。以<code>&#39;</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 _进程替换_（_process substitution_）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找所有名称为src的文件夹</span><br><span class="line">find . -name src -type d</span><br><span class="line"># 查找所有文件夹路径中包含test的python文件</span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"># 查找前一天修改的所有文件</span><br><span class="line">find . -mtime -1</span><br><span class="line"># 查找所有大小在500k至10M的tar.gz文件</span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除全部扩展名为.tmp 的文件</span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"># 查找全部的 PNG 文件并将其转换为 JPG</span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure>

<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name &#39;*PATTERN*&#39;</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h3><p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。<br>它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：****</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找所有使用了 requests 库的文件</span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"># 查找所有的foo字符串，并打印其之后的5行</span><br><span class="line">rg foo -A 5</span><br><span class="line"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure>

<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><h3 id="建立别名"><a href="#建立别名" class="headerlink" title="建立别名"></a>建立别名</h3><p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias alias_name=&quot;command_to_alias arg1 arg2&quot;</span><br></pre></td></tr></table></figure>

<p>注意， <code>=</code>两边是没有空格的，因为 <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p>
<p>别名有许多很方便的特性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建常用命令的缩写</span><br><span class="line">alias ll=&quot;ls -lh&quot;</span><br><span class="line"></span><br><span class="line"># 能够少输入很多</span><br><span class="line">alias gs=&quot;git status&quot;</span><br><span class="line">alias gc=&quot;git commit&quot;</span><br><span class="line">alias v=&quot;vim&quot;</span><br><span class="line"></span><br><span class="line"># 手误打错命令也没关系</span><br><span class="line">alias sl=ls</span><br><span class="line"></span><br><span class="line"># 重新定义一些命令行的默认行为</span><br><span class="line">alias mv=&quot;mv -i&quot;           # -i prompts before overwrite</span><br><span class="line">alias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed</span><br><span class="line">alias df=&quot;df -h&quot;           # -h prints human readable format</span><br><span class="line"></span><br><span class="line"># 别名可以组合使用</span><br><span class="line">alias la=&quot;ls -A&quot;</span><br><span class="line">alias lla=&quot;la -l&quot;</span><br><span class="line"></span><br><span class="line"># 在忽略某个别名</span><br><span class="line">\ls</span><br><span class="line"># 或者禁用别名</span><br><span class="line">unalias la</span><br><span class="line"></span><br><span class="line"># 获取别名的定义</span><br><span class="line">alias ll</span><br><span class="line"># 会打印 ll=&#x27;ls -lh&#x27;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是<code>.bashrc</code> 或 <code>.zshrc</code>，</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>右击边框开启设置菜单<br><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。<br><a href="https://github.com/clvv/fasd"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a> 对文件和文件排序，也就是说它会同时针对频率（_frequency_）和时效（_recency_）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<h2 id="命令行环境"><a href="#命令行环境" class="headerlink" title="命令行环境"></a>命令行环境</h2><h3 id="默认环境变量"><a href="#默认环境变量" class="headerlink" title="默认环境变量"></a>默认环境变量</h3><p>因为Shell中定义的环境变量之后影响子进程，为了避免我们每次都需要在使用前定义环境变量，我们可以将这一设置写进<code>~/.bashrc</code>里，这个配置文件会在每次启动bash时执行。<code>~/.bashrc</code>中已经包含了很多配置，我们要做的就是在最后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HELLO=hello</span><br></pre></td></tr></table></figure>

<p>然后执行<code>source ~/.bashrc</code>，这样就可以在每次打开Shell的时候定义这一环境变量。利用这个机制，假如我们想把自定义的命令加入<code>PATH</code>中时就可以在<code>~/.bashrc</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/path/to/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>这样命令就会添加到Shell的搜索路径中。需要注意的一点是，如果使用的是zsh，需要修改的就不是<code>~/.bashrc</code>，而是<code>~/.zshrc</code></p>
<h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>
<p>此时就需要进行 _端口转发_。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p>
<p><strong>本地端口转发</strong> <img src="https://i.stack.imgur.com/a28N8.png" alt="Local Port Forwarding" title="本地端口转发"></p>
<p><strong>远程端口转发</strong> <img src="https://i.stack.imgur.com/4iK3b.png" alt="Remote Port Forwarding" title="远程端口转发"></p>
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>
<h3 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h3><p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p>
<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> 信号到进程。</p>
<p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code> 信号，通过输入<code>Ctrl-\</code>可以发送该信号。<br>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。<br>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p>
<p>我们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code> ，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，您可以使用终端多路复用器来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"></span><br><span class="line">$ nohup sleep 2000 &amp;</span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ bg %1</span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -STOP %1</span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %1</span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %2</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill %2</span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>
<h3 id="tmux多路终端复用"><a href="#tmux多路终端复用" class="headerlink" title="tmux多路终端复用"></a>tmux多路终端复用</h3><p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>
<p>像 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a> 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p>
<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>
<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p>
<p>现在最流行的终端多路器是 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>
<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p>
<ul>
<li><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口<ul>
<li><code>tmux</code> 开始一个新的会话</li>
<li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li>
<li><code>tmux ls</code> 列出当前所有会话</li>
<li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</li>
<li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li>
</ul>
</li>
<li><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分<ul>
<li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code>关闭</li>
<li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的</li>
<li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li>
<li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li>
<li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li>
<li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li>
</ul>
</li>
<li><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell<ul>
<li><code>&lt;C-b&gt; &quot;</code> 水平分割</li>
<li><code>&lt;C-b&gt; %</code> 垂直分割</li>
<li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li>
<li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li>
<li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li>
<li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li>
</ul>
</li>
</ul>
<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></table></figure>

<p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p>
<h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。 <code>ssh foobar@server ls</code> 可以直接在用foobar的命令下执行 <code>ls</code> 命令。 想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p>
<h4 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h4><p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p>
<h4 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h4><p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>

<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h4 id="基于密钥的认证机制"><a href="#基于密钥的认证机制" class="headerlink" title="基于密钥的认证机制"></a>基于密钥的认证机制</h4><p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>

<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h3 id="G-基于密钥的认证机制"><a href="#G-基于密钥的认证机制" class="headerlink" title="G# 基于密钥的认证机制"></a>G# 基于密钥的认证机制</h3><p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat .ssh/id_ed25519 | ssh foobar@remote &#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br></pre></td></tr></table></figure>

<p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></table></figure>

<h2 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h2><ul>
<li>当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>&#123;&#125;</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
<li>![[Pasted image 20230128155221.png]]</li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code> 除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>擅长文本处理的编程语言<br><code>&#123;print $2&#125;</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名<br>让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| awk &#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27; | wc -l</span><br></pre></td></tr></table></figure>

<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是<code>&#123;...&#125;</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN &#123; rows = 0 &#125;</span><br><span class="line">$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; rows += $1 &#125;</span><br><span class="line">END &#123; print rows &#125;</span><br></pre></td></tr></table></figure>

<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。</p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>即便守护进程（daemon）这个词看上去有些陌生，你应该已经大约明白它的概念。大部分计算机都有一系列在后台保持运行，不需要用户手动运行或者交互的进程。这些进程就是守护进程。以守护进程运行的程序名一般以 <code>d</code> 结尾，比如 SSH 服务端 <code>sshd</code>，用来监听传入的 SSH 连接请求并对用户进行鉴权。</p>
<p>Linux 中的 <code>systemd</code>（the system daemon）是最常用的配置和运行守护进程的方法。运行 <code>systemctl status</code> 命令可以看到正在运行的所有守护进程。这里面有很多可能你没有见过，但是掌管了系统的核心部分的进程：管理网络、DNS解析、显示系统的图形界面等等。用户使用 <code>systemctl</code> 命令和 <code>systemd</code> 交互来<code>enable</code>（启用）、<code>disable</code>（禁用）、<code>start</code>（启动）、<code>stop</code>（停止）、<code>restart</code>（重启）、或者<code>status</code>（检查）配置好的守护进程及系统服务。</p>
<p><code>systemd</code> 提供了一个很方便的界面用于配置和启用新的守护进程或系统服务。下面的配置文件使用了守护进程来运行一个简单的 Python 程序。文件的内容非常直接所以我们不对它详细阐述。<code>systemd</code> 配置文件的详细指南可参见 <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">freedesktop.org</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/systemd/system/myapp.service</span><br><span class="line">[Unit]</span><br><span class="line"># 配置文件描述</span><br><span class="line">Description=My Custom App</span><br><span class="line"># 在网络服务启动后启动该进程</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"># 运行该进程的用户</span><br><span class="line">User=foo</span><br><span class="line"># 运行该进程的用户组</span><br><span class="line">Group=foo</span><br><span class="line"># 运行该进程的根目录</span><br><span class="line">WorkingDirectory=/home/foo/projects/mydaemon</span><br><span class="line"># 开始该进程的命令</span><br><span class="line">ExecStart=/usr/bin/local/python3.7 app.py</span><br><span class="line"># 在出现错误时重启该进程</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"># 相当于Windows的开机启动。即使GUI没有启动，该进程也会加载并运行</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"># 如果该进程仅需要在GUI活动时运行，这里应写作：</span><br><span class="line"># WantedBy=graphical.target</span><br><span class="line"># graphical.target在multi-user.target的基础上运行和GUI相关的服务</span><br></pre></td></tr></table></figure>

<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>任何没有备份的数据都可能在一个瞬间永远消失。复制数据很简单，但是可靠地备份数据很难。下面列举了一些关于备份的基础知识，以及一些常见做法容易掉进的陷阱。</p>
<p>首先，复制存储在同一个磁盘上的数据不是备份，因为这个磁盘是一个单点故障（single point of failure）。这个磁盘一旦出现问题，所有的数据都可能丢失。放在家里的外置磁盘因为火灾、抢劫等原因可能会和源数据一起丢失，所以是一个弱备份。推荐的做法是将数据备份到不同的地点存储。</p>
<p>同步方案也不是备份。即使方便如 Dropbox 或者 Google Drive，当数据在本地被抹除或者损坏，同步方案可能会把这些“更改”同步到云端。同理，像 RAID 这样的磁盘镜像方案也不是备份。它不能防止文件被意外删除、损坏、或者被勒索软件加密。</p>
<p>有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。对备份的数据实施版本控制保证了用户可以从任何记录过的历史版本中恢复数据。在备份中检测并删除重复数据，使其仅备份增量变化可以减少存储开销。在安全性方面，作为用户，你应该考虑别人需要有什么信息或者工具才可以访问或者完全删除你的数据及备份。最后一点，不要盲目信任备份方案。用户应该经常检查备份是否可以用来恢复数据。</p>
<p>备份不限制于备份在本地计算机上的文件。云端应用的重大发展使得我们很多的数据只存储在云端。当我们无法登录这些应用，在云端存储的网络邮件，社交网络上的照片，流媒体音乐播放列表，以及在线文档等等都会随之丢失。用户应该有这些数据的离线备份，而且已经有项目可以帮助下载并存储它们。</p>
<h2 id="常见命令行标志参数及模式"><a href="#常见命令行标志参数及模式" class="headerlink" title="常见命令行标志参数及模式"></a>常见命令行标志参数及模式</h2><p>命令行工具的用法千差万别，阅读 <code>man</code> 页面可以帮助你理解每种工具的用法。即便如此，下面我们将介绍一下命令行工具一些常见的共同功能。</p>
<ul>
<li><p>大部分工具支持 <code>--help</code> 或者类似的标志参数（flag）来显示它们的简略用法。</p>
</li>
<li><p>会造成不可撤回操作的工具一般会提供“空运行”（dry run）标志参数，这样用户可以确认工具真实运行时会进行的操作。这些工具通常也会有“交互式”（interactive）标志参数，在执行每个不可撤回的操作前提示用户确认。</p>
</li>
<li><p><code>--version</code> 或者 <code>-V</code> 标志参数可以让工具显示它的版本信息（对于提交软件问题报告非常重要）。</p>
</li>
<li><p>基本所有的工具支持使用 <code>--verbose</code> 或者 <code>-v</code> 标志参数来输出详细的运行信息。多次使用这个标志参数，比如 <code>-vvv</code>，可以让工具输出更详细的信息（经常用于调试）。同样，很多工具支持 <code>--quiet</code> 标志参数来抑制除错误提示之外的其他输出。</p>
</li>
<li><p>大多数工具中，使用 <code>-</code> 代替输入或者输出文件名意味着工具将从标准输入（standard input）获取所需内容，或者向标准输出（standard output）输出结果。</p>
</li>
<li><p>会造成破坏性结果的工具一般默认进行非递归的操作，但是支持使用“递归”（recursive）标志函数（通常是 <code>-r</code>）。</p>
</li>
<li><p>有的时候你可能需要向工具传入一个 <em>看上去</em> 像标志参数的普通参数，比如：</p>
<ul>
<li><p>使用 <code>rm</code> 删除一个叫 <code>-r</code> 的文件；</p>
</li>
<li><p>在通过一个程序运行另一个程序的时候（<code>ssh machine foo</code>），向内层的程序（<code>foo</code>）传递一个标志参数。</p>
<p>这时候你可以使用特殊参数 <code>--</code> 让某个程序 <em>停止处理</em> <code>--</code> 后面出现的标志参数以及选项（以 <code>-</code> 开头的内容）：</p>
</li>
<li><p><code>rm -- -r</code> 会让 <code>rm</code> 将 <code>-r</code> 当作文件名；</p>
</li>
<li><p><code>ssh machine --for-ssh -- foo --for-foo</code> 的 <code>--</code> 会让 <code>ssh</code> 知道 <code>--for-foo</code> 不是 <code>ssh</code> 的标志参数。</p>
</li>
</ul>
</li>
</ul>
<h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><h3 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h3><p>在我们使用<code>strace</code>调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p>
<p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）。下面是关于常见命令的简介：</p>
<ul>
<li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li>
<li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li>
<li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li>
<li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li>
</ul>
<h3 id="资源监控"><a href="#资源监控" class="headerlink" title="资源监控"></a>资源监控</h3><p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。</p>
<ul>
<li><strong>通用监控</strong> - 最流行的工具要数 <a href="https://htop.dev/"><code>htop</code></a>,了，它是 <a href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a>的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、 <code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。 还可以留意一下 <a href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I&#x2F;O、网络、 CPU 利用率、上下文切换等等；</li>
<li><strong>I&#x2F;O 操作</strong> - <a href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I&#x2F;O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li>
<li><strong>磁盘使用</strong> - <a href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的 <code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；</li>
<li><strong>内存使用</strong> - <a href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</li>
<li><strong>打开文件</strong> - <a href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a> 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</li>
<li><strong>网络连接和配置</strong> - <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 <a href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</li>
<li><strong>网络使用</strong> - <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对网络占用进行监控的交互式命令行工具。</li>
</ul>
<p>如果您希望测试一下这些工具，您可以使用 <a href="https://linux.die.net/man/1/stress"><code>stress</code></a> 命令来为系统人为地增加负载。</p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="source-script-sh-和-script-sh-有什么区别"><a href="#source-script-sh-和-script-sh-有什么区别" class="headerlink" title="source script.sh 和 ./script.sh 有什么区别?"></a><code>source script.sh</code> 和 <code>./script.sh</code> 有什么区别?</h3><p>这两种情况 <code>script.sh</code> 都会在bash会话中被读取和执行，不同点在于哪个会话执行这个命令。 对于 <code>source</code> 命令来说，命令是在当前的bash会话中执行的，因此当 <code>source</code> 执行完毕，对当前环境的任何更改（例如更改目录或是定义函数）都会留存在当前会话中。 单独运行 <code>./script.sh</code> 时，当前的bash会话将启动新的bash会话（实例），并在新实例中运行命令 <code>script.sh</code>。 因此，如果 <code>script.sh</code> 更改目录，新的bash会话（实例）会更改目录，但是一旦退出并将控制权返回给父bash会话，父会话仍然留在先前的位置（不会有目录的更改）。 同样，如果 <code>script.sh</code> 定义了要在终端中访问的函数，需要用 <code>source</code> 命令在当前bash会话中定义这个函数。否则，如果你运行 <code>./script.sh</code>，只有新的bash会话（进程）才能执行定义的函数，而当前的shell不能。</p>
<h3 id="各种软件包和工具存储在哪里？引用过程是怎样的-bin-或-lib-是什么？"><a href="#各种软件包和工具存储在哪里？引用过程是怎样的-bin-或-lib-是什么？" class="headerlink" title="各种软件包和工具存储在哪里？引用过程是怎样的? /bin 或 /lib 是什么？"></a>各种软件包和工具存储在哪里？引用过程是怎样的? <code>/bin</code> 或 <code>/lib</code> 是什么？</h3><p>根据你在命令行中运行的程序，这些包和工具会全部在 <code>PATH</code> 环境变量所列出的目录中查找到， 你可以使用 <code>which</code> 命令(或是 <code>type</code> 命令)来检查你的shell在哪里发现了特定的程序。 一般来说，特定种类的文件存储有一定的规范，<a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">文件系统，层次结构标准（Filesystem, Hierarchy Standard）</a>可以查到我们讨论内容的详细列表。</p>
<ul>
<li><code>/bin</code> - 基本命令二进制文件</li>
<li><code>/sbin</code> - 基本的系统二进制文件，通常是root运行的</li>
<li><code>/dev</code> - 设备文件，通常是硬件设备接口文件</li>
<li><code>/etc</code> - 主机特定的系统配置文件</li>
<li><code>/home</code> - 系统用户的主目录</li>
<li><code>/lib</code> - 系统软件通用库</li>
<li><code>/opt</code> - 可选的应用软件</li>
<li><code>/sys</code> - 包含系统的信息和配置(<a href="https://missing-semester-cn.github.io/2020/course-shell/">第一堂课</a>介绍的)</li>
<li><code>/tmp</code> - 临时文件( <code>/var/tmp</code> ) 通常重启时删除</li>
<li><code>/usr/</code> - 只读的用户数据<ul>
<li><code>/usr/bin</code> - 非必须的命令二进制文件</li>
<li><code>/usr/sbin</code> - 非必须的系统二进制文件，通常是由root运行的</li>
<li><code>/usr/local/bin</code> - 用户编译程序的二进制文件</li>
</ul>
</li>
<li><code>/var</code> -变量文件 像日志或缓存</li>
<li>## 我应该用 <code>apt-get install</code> 还是 <code>pip install</code> 去下载软件包呢?</li>
</ul>
<p>这个问题没有普遍的答案。这与使用系统程序包管理器还是特定语言的程序包管理器来安装软件这一更笼统的问题相关。需要考虑的几件事：</p>
<ul>
<li><p>常见的软件包都可以通过这两种方法获得，但是小众的软件包或较新的软件包可能不在系统程序包管理器中。在这种情况下，使用特定语言的程序包管理器是更好的选择。</p>
</li>
<li><p>同样，特定语言的程序包管理器相比系统程序包管理器有更多的最新版本的程序包。</p>
</li>
<li><p>当使用系统软件包管理器时，将在系统范围内安装库。如果出于开发目的需要不同版本的库，则系统软件包管理器可能不能满足你的需要。对于这种情况，大多数编程语言都提供了隔离或虚拟环境，因此你可以用特定语言的程序包管理器安装不同版本的库而不会发生冲突。对于 Python，可以使用 virtualenv，对于 Ruby，使用 RVM 。</p>
</li>
<li><p>根据操作系统和硬件架构，其中一些软件包可能会附带二进制文件或者软件包需要被编译。例如，在树莓派（Raspberry Pi）之类的ARM架构计算机中，在软件附带二进制文件和软件包需要被编译的情况下，使用系统包管理器比特定语言包管理器更好。这在很大程度上取决于你的特定设置。 你应该仅使用一种解决方案，而不同时使用两种方法，因为这可能会导致难以解决的冲突。我们的建议是尽可能使用特定语言的程序包管理器，并使用隔离的环境（例如 Python 的 virtualenv）以避免影响全局环境</p>
</li>
<li><h3 id="Docker和虚拟机有什么区别"><a href="#Docker和虚拟机有什么区别" class="headerlink" title="Docker和虚拟机有什么区别?"></a>Docker和虚拟机有什么区别?</h3></li>
</ul>
<p>Docker 基于容器这个更为概括的概念。关于容器和虚拟机之间最大的不同是，虚拟机会执行整个的 OS 栈，包括内核（即使这个内核和主机内核相同）。与虚拟机不同，容器避免运行其他内核实例，而是与主机分享内核。在Linux环境中，有LXC机制来实现，并且这能使一系列分离的主机像是在使用自己的硬件启动程序，而实际上是共享主机的硬件和内核。因此容器的开销小于完整的虚拟机。</p>
<p>另一方面，容器的隔离性较弱而且只有在主机运行相同的内核时才能正常工作。例如，如果你在macOS 上运行 Docker，Docker 需要启动 Linux虚拟机去获取初始的 Linux内核，这样的开销仍然很大。最后，Docker 是容器的特定实现，它是为软件部署而定制的。基于这些，它有一些奇怪之处：例如，默认情况下，Docker 容器在重启之间不会有以任何形式的存储。</p>
<h3 id="还有更多的-Vim-小窍门吗？"><a href="#还有更多的-Vim-小窍门吗？" class="headerlink" title="还有更多的 Vim 小窍门吗？"></a>还有更多的 Vim 小窍门吗？</h3><p>更多的窍门：</p>
<ul>
<li>插件 - 花时间去探索插件。有很多不错的插件修复了vim的缺陷或者增加了能够与现有vim工作流结合的新功能。关于这部分内容，资源是<a href="https://vimawesome.com/">VimAwesome</a> 和其他程序员的dotfiles。</li>
<li>标记 - 在vim里你可以使用 <code>m&lt;X&gt;</code> 为字母 <code>X</code> 做标记，之后你可以通过 <code>&#39;&lt;X&gt;</code> 回到标记位置。这可以让你快速定位到文件内或文件间的特定位置。</li>
<li>导航 - <code>Ctrl+O</code> 和 <code>Ctrl+I</code> 命令可以使你在最近访问位置前后移动。</li>
<li>撤销树 - vim 有不错的更改跟踪机制，不同于其他的编辑器，vim存储变更树，因此即使你撤销后做了一些修改，你仍然可以通过撤销树的导航回到初始状态。一些插件比如 <a href="https://github.com/sjl/gundo.vim">gundo.vim</a> 和 <a href="https://github.com/mbbill/undotree">undotree</a> 通过图形化来展示撤销树。</li>
<li>时间撤销 - <code>:earlier</code> 和 <code>:later</code> 命令使得你可以用时间而非某一时刻的更改来定位文件。</li>
<li><a href="https://vim.fandom.com/wiki/Using_undo_branches#Persistent_undo">持续撤销</a> - 是一个默认未被开启的vim的内置功能，它在vim启动之间保存撤销历史，需要配置在 <code>.vimrc</code> 目录下的<code>undofile</code> 和 <code>undodir</code>，vim会保存每个文件的修改历史。</li>
<li>热键（Leader Key） - 热键是一个用于用户自定义配置命令的特殊按键。这种模式通常是按下后释放这个按键（通常是空格键）并与其他的按键组合去实现一个特殊的命令。插件也会用这些按键增加它们的功能，例如，插件UndoTree使用 <code>&lt;Leader&gt; U</code> 去打开撤销树。</li>
<li>高级文本对象 - 文本对象比如搜索也可以用vim命令构成。例如，<code>d/&lt;pattern&gt;</code> 会删除下一处匹配 pattern 的字符串，<code>cgn</code> 可以用于更改上次搜索的关键字。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编程工具</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>基于苏大ppt的计算机硬件笔记</title>
    <url>/2023/09/29/%E7%A1%AC%E4%BB%B6%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&#96;冯·诺依曼计算机特点<br>– 计算机由五大部件组成<br>• 输入数据和程序的“输入设备”<br>• 记忆程序和数据的“存储器”<br>• 完成数据加工处理的“运算器”<br>• 控制程序执行的“控制器”<br>• 输出处理结果的“输出设备”  </p>
<span id="more"></span>
<p>– 指令和数据以同等地位存于存储器，可按地址寻访<br>– 指令和数据用二进制表示<br>– 指令由操作码和地址码组成<br>– 以运算器为中心<br>基础逻辑电路：与门，非门，或门，异或门，与非门，或非门，同或门<br>半加器<br>– 𝑆𝑖当前位， 𝐶𝑖进位符<br>全加器  （包括之前的进位cn-1）<br>– 𝐹𝑛当前位， 𝐶𝑛进位符<br>𝐶𝑛 &#x3D; 𝑋𝑛 ⋅ 𝑌𝑛 + 𝑋𝑛⨁𝑌𝑛 ⋅ 𝐶𝑛−1<br><img src="/images/obsidian/20230531113546.png" alt="图片" title="image"><br><img src="/images/obsidian/20230531113559.png" alt="图片" title="image"><br><img src="/images/obsidian/20230531113735.png" alt="图片" title="image"><br>CPU与外设之间的数据交换必须通过接口来完成，通常接口有<br>以下一些功能：<br>– 设置数据的寄存、缓冲逻辑，以适应CPU与外设之间的速度差异；<br>– 进行信息格式的转换，例如串行和并行的转换；<br>– 协调CPU和外设两者在信息的类型和电平的差异，如电平转换驱动器、<br>数&#x2F;模或模&#x2F;数转换器等；<br>– 协调时序差异；<br>– 地址译码和设备选择功能；<br>– 设置中断和DMA（直接存储器存取）控制逻辑，以保证在中断和DMA<br>允许的情况下产生中断和DMA请求信号，并在接受到中断和DMA应答<br>之后完成中断处理和DMA传输。<br>&#96;为何要用二进制表示（冯.诺依曼核心）<br>– 无法制造多个稳定状态的物理器件<br>– 编码、计数、运算规则简单<br>– 和逻辑的真、假对应，通过逻辑门电路可实现算数运算<br>BCD码<br>– 机器中用4位二进制对每个十进制数位进行编码方法<br>– 4位二进制有16种组合，选取其中的十个。<br>– 常用的方法有：8421码、余3码、格雷码</p>
<p>为什么要用BCD码<br>– 高精确度的计算<br>– 耗费更多的存储空间<br><code>数的定点与浮点表示   – 十进制的公式表示：𝑁 = 10𝐸 ∗ 𝑆   – 二进制数的公式表示：𝑁 = 2𝐸 ∗ 𝑆   • 定点数：阶码𝐸位置固定，存储时统一忽略阶码   – 定点整数: 𝐸 = 0， 𝑆为纯整数，小数点固定在数值部分的右边   – 定点小数: 𝐸 = 0， 𝑆为纯小数，小数点固定在数值部分的左边 </code>浮点数详解<br>– 浮点数的表示范围<br>• 阶码E的范围：−128 ≤ 𝑒 &lt; 127<br>• 最大正数：0.111 … 1 × 2011…1 &#x3D; (1 − 2^−23) × 2^127<br>• 最小正数：0.100 … 0 × 2100…0 &#x3D; 1<br>2 × 2−128 &#x3D; 2−129<br>– 浮点数的表示精度<br>• 总位数不变<br>– 阶码越大：数值表示范围越大<br>– 尾数越少：精度变低<br><img src="/images/obsidian/20230531114156.png" alt="图片" title="image"><br>机器数的表示形式：原码、反码、补码<br>– 原码：符号+真值<br>• +41 原 &#x3D; 0 0101001， −41 原 &#x3D; 1 0101001<br>• +0 原 &#x3D; 0 0000000， −0 原 &#x3D; 1 0000000<br>– 反码：正数不变，负数时符号不变，其他各位取反<br>• +41 反 &#x3D; 0 0101001， −41 反 &#x3D; 1 1010110<br>• +0 反 &#x3D; 0 0000000， −0 反 &#x3D; 1 1111111<br>– 补码：正数不变，负数为反码+1（计算机表示带符号数的方法）<br>• +41 补 &#x3D; 0 0101001， −41 补 &#x3D; 1 1010111<br>• +0 补 &#x3D; 0 0000000， −0 补 &#x3D; 0 0000000<br>• +127 补 &#x3D; 0 1111111， −127 补 &#x3D; 1 0000001<br>• −128 补 &#x3D; 1 0000000<br>&#96;溢出<br>– 运算结果超出机器数所能表示的范围时，称为溢出<br>– 定点数溢出的判断方法<br>• 两个同符号的数相加，得到的和的符号与相加数的符号不一致。<br>– 采用双符号位：正数的符号位为00，负数的符号位为11。符号位参加运算。如果<br>两个符号位不相同，则溢出。（浪费资源）<br>• 任意两数相加，如果数值最高位的进位不等于符号位的进位，则溢出。<br>– 浮点数溢出的判断方法<br>• 看阶码是否溢出！</p>
<p>BCD码：用四位二进制数表达一个十进制数，方便运算和显示<br>浮点数：尾数S和阶码E<br>符号+阶码+符号+尾数<br>反码：正数不变，负数除了符号位取反<br>补码：正数不变，负数除了符号位加一<br>+0：00000000<br>-128:10000000<br>[x+y]补&#x3D;[x]补+[y]补<br>[x-y]补&#x3D;[x]补+[-y]补</p>
<p>有效地址EA&#x3D;基址（BX&#x2F;BP）+变址值(SI&#x2F;DI)+位移量DISP<br>+段基址&#x3D;物理地址</p>
<h2 id="CISC和RISC是CPU的两种基本架构"><a href="#CISC和RISC是CPU的两种基本架构" class="headerlink" title="CISC和RISC是CPU的两种基本架构"></a>CISC和RISC是CPU的两种基本架构</h2><p>– CISC：寻址方式多，方便编程<br>– RISC：寻址方式少，指令短、规整</p>
<h3 id="RISC特点"><a href="#RISC特点" class="headerlink" title="RISC特点"></a>RISC特点</h3><p>– 指令系统<br>• RISC指令长度相同；寻址方式少；指令执行时间相当<br>– RISC CPU内部寄存器多<br>– 存储器操作<br>• 只有取数&#x2F;存数指令访问存储器，大部分指令都在寄存器之间进行<br>– 代码量增多，实现特殊功能时程序复杂<br>– 较少的单元电路，面积小，功耗低<br>– 结构简单，设计周期短</p>
<h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h3><p>– PC发起地址查询<br>– 内存依据地址返回指令&#x2F;数据<br>– CPU进行指令解析<br>– PC增量或PC赋值<br>• 指令结构<br>– 操作码+地址码（操作数所在地）</p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>立即数寻址（办理人随身携带）<br>– 操作数由指令的地址码部分直接给出来<br>• 操作码+操作数  </li>
<li>寄存器直接寻址（办理人已寄存）<br>– 指令地址码部分给出某一通用寄存器地址<br>– 从寄存器存取数据比主存快得多<br>– 由于寄存器的数量较少，其地址码字段短</li>
<li>直接寻址（办理人在队伍里）<br>– 指令中地址码字段给出操作数的地址<br>• PC赋值——取操作数</li>
<li>间接寻址（办理人在哪问家长）<br>– 指令中给出的地址是存放操作数地址的地址<br>– 寄存器间接寻址（家长已寄存）<br>– 存储器间接寻址（家长在队伍里）</li>
<li>偏移寻址（相对寻址）<br>– 从我往后数A个<br>– EA：有效地址<br>– 相对寻址： EA&#x3D;A+(PC) 相对于当前指令处位移量为A的单元<br>– 基址寻址： EA&#x3D;A+(B) 相对于基址(B)处位移量为A的单元<br>– 变址寻址： EA&#x3D;A+(I) 相对于首址A处位移量为(I)的单元</li>
</ul>
<h2 id="8086-8088微处理器"><a href="#8086-8088微处理器" class="headerlink" title="8086&#x2F;8088微处理器"></a>8086&#x2F;8088微处理器</h2><h3 id="指令队列缓冲器"><a href="#指令队列缓冲器" class="headerlink" title="指令队列缓冲器"></a>指令队列缓冲器</h3><p>– 取指令时，每当指令队列缓冲区满一条指令，EU立即开始执行<br>– 当指令队列中有2个空字节（8088一个）BIU自动去取指<br>– EU从指令队列中去取指，然后执行指令，当该指令需要内存或<br>I&#x2F;O访问，EU请求BIU进入总线周期完成访问：<br>• BIU空闲状态：立即响应<br>• 正在取指：取指完后响应<br>– 指令队列已满，EU没有对BIU有请求，BIU进入空闲状态<br>– 执行转移、调用、返回指令：指令队列中的内容（原顺序指令）<br>被清除，BIU去取EU所指示的新的程序段指令</p>
<h3 id="寻址空间计算"><a href="#寻址空间计算" class="headerlink" title="寻址空间计算"></a>寻址空间计算</h3><p>– 8位机寻址：8根地址线<br>• 地址范围：0~255<br>• 最大内存空间：28 &#x3D; 256Byte<br>– 16位机：216 &#x3D; 64KB<br>– 32位机：232 &#x3D; 4GB<br>– 64位机：264 &#x3D; 16EB</p>
<h3 id="编程结构"><a href="#编程结构" class="headerlink" title="编程结构"></a>编程结构</h3><p><img src="/images/obsidian/20230603134629.png" alt="图片" title="image"><br>– 4个通用寄存器(16位)<br>• AX、BX、CX、DX（可8位单独使用）<br>– 4个专用寄存器(16位)<br>• BP（Base Pointer）基数指针<br>• SP（Stack Pointer）堆栈指针<br>• SI（Source Index）源变址<br>• DI（Destination Index）目的变址<br>– 4个段寄存器（16位）<br>• CS（Code Segment）代码段寄存器<br>• DS（Data Segment）数据段寄存器<br>• SS（Stack Segment）堆栈段寄存器<br>• ES（Extra Segment）扩展段寄存器<br>– CS用来存放程序当前使用的代码段的段地址，CPU执行的指令<br>将从代码段取得<br>• CS:IP构成传统意义的PC<br>– SS用来存放堆栈段的段地址，堆栈操作的数据就在堆栈段中<br>• 通常SS:SP和SS:BP构成堆栈段的访问<br>– DS用来存放数据段的段地址，一般地说，程序所用的数据就存<br>放在数据段中<br>• 通常DS:XX（通用寄存器）构成对数据段的访问；<br>– ES用来存放附加段的段地址，也用来存放数据，但典型用法是<br>存放处理后的数据</p>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存储器处于中心地位的原因："><a href="#主存储器处于中心地位的原因：" class="headerlink" title="主存储器处于中心地位的原因："></a>主存储器处于中心地位的原因：</h3><p>• 当前计算机正在执行的程序和数据均存放在存储器中，<br>CPU直接从存储器取指令或数据；<br>• 输入输出设备增多，数据传输速度加快，因此采用了<br>DMA(直接存储器存取)技术和输入&#x2F;输出通道技术，<br>在存储器与输入&#x2F;输出系统之间直接传送数据；<br>• 共享存储器的多处理机的出现，利用存储器存放共享<br>数据，并实现处理机之间的通信。</p>
<h3 id="存储器的分类和指标"><a href="#存储器的分类和指标" class="headerlink" title="存储器的分类和指标"></a>存储器的分类和指标</h3><p>随机存储器（random access memory，RAM）<br>• 又称读写存储器，指通过指令可以随机地、个别地对<br>各个存储单元进行访问（读写）的存储器<br>• 访问所需时间基本固定，与存储单元地址无关<br>• 停电会造成信号丢失<br>非易失性存储器<br>• 停电仍能保持其内容<br><code>容量 • 计算机可寻址的最小单位是一个存储字，一个存储字   所包括的二进制位数称为字长   • 一个字节（Byte）为8个二进制位（bit），一个字可   以由若干字节组成，一个字的字长通常是8的倍数。   • 主存储器的容量：以字或字节为单位来表示主存储器   存储单元的总数   • 单位：B、KB、MB、GB、 TB、PB、EB、ZB...   • 指令中地址码的位数决定了主存储器的可直接寻址的   最大空间   • 32位微型机提供32位物理地址，支持对4G字节的物理主存   空间的访问 </code>存储器存取时间(Memory Access Time)<br>• 又称存储器访问时间<br>• 启动一次存储器操作到完成该操作所经历的时间。<br>&#96;存储周期(Memory Cycle Time)<br>• 连续启动两次独立的存储器操作(例如连续两次读操<br>作)所需间隔的最小时间<br>• 主存储器和CPU是由总线连接的。CPU通过使<br>用AR（地址寄存器）和DR（数据寄存器）个<br>主存储器进行数据传送。若AR为K位字长，<br>DR为n位字长，则允许主存包含2^k个可寻址<br>字节或字。<br>• 在一个周期内，CPU和主存储器之间进行n位<br>数据传送。<br>读操作：存储器→CPU<br>• CPU把信息字的地址送到<br>AR,经地址总线送往主存<br>储器<br>• CPU通过控制总线发读<br>(Read)命令<br>• CPU等待主存储器的<br>Ready回答信号，Ready<br>为 1，表示信息已读出经<br>数据总线,送入DR。<br>AR：地址寄存器<br>DR：数码寄存器<br>主存储器的基本操作</p>
<p>• 写操作：CPU→存储器<br>• CPU把信息字的地址送<br>到AR，经地址总线送往<br>主存储器,并将信息字送<br>往DR<br>• CPU通过控制总线发写<br>(Write)命令<br>• CPU等待主存储器的<br>Ready回答信号，Ready<br>为 1，表示信息已从DR<br>经数据总线写入主存储<br>器</p>
<h3 id="读写存储器"><a href="#读写存储器" class="headerlink" title="读写存储器"></a>读写存储器</h3><p>按存储元件在运行中能否长时间保存信息分为静<br>态存储器SRAM和动态存储器DRAM两种<br>• 静态存储器：利用双稳态触发器来保存信息，只<br>要不断电，信息就不会丢失<br>• 动态存储器：利用MOS电容存储电荷来保存信<br>息，使用时需不断给电容充电才能使信息保持<br>• 静态存储器的集成度低，功耗较大；动态存储器<br>的集成度高，功耗小，主要用于大容量存储器<br>• DRAM每片容量大，引脚少; 价格低; 功耗低; 但<br>速度低，须再生。 DRAM一般用作计算机的主<br>存储器。<br>• SRAM速度快，价格较高，一般用作容量不大的<br>高速存储器。<br>DRAM和SRAM是可任意读写的随机存储器，当发生掉电时，存储的<br>内容容易立即消失，属于易失性存储器。<br>非易失性存储器，即使掉电，内容也不会消失：<br>只读存储器(ROM)<br>• 掩膜式ROM，由芯片制造商在制造时写入内容，以后只能读不能写<br>可编程序的只读存储器(PROM)<br>• 用户根据自己需要确定ROM的内容；<br>• 有熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元<br>的熔丝(写入)。<br>可擦除可编程序的只读存储器(EPROM)<br>• 产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线<br>照射后,浮置栅上的电子将逸散,即整体擦除。<br>可用电擦除的可编程序的只读存储器(E2PROM)<br>• 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写<br>入周期要几毫秒,寿命为10万次。<br>闪速存储器(Flash Memory)<br>• 用电擦除,但只能整体擦除或分区擦除。</p>
<h2 id="8086-8088存储器组织"><a href="#8086-8088存储器组织" class="headerlink" title="8086&#x2F;8088存储器组织"></a>8086&#x2F;8088存储器组织</h2><p>存储器分段<br>– 为什么分段<br>• 地址寄存器均为16位： 216 &#x3D; 64KB<br>– 分段方便操作系统进行存储管理<br>– 如何分段<br>• 8086地址空间为20位&#x3D;1MB，地址为5位16进制数：00000H~FFFFFH<br>– 从偏移地址考虑，理论上最多16个不重叠的地址段<br>– 从段地址考虑，最多可以定义216个不同段<br>– 段重叠<br>• 段区分配通常由操作系统完成<br>– CS、DS、SS、ES存储与程序相关的段基址<br>– IP、SP、BP、SI、DI存储与程序相关的偏移地址<br>逻辑地址和物理地址<br>– 逻辑地址<br>• 程序和指令表示的一种地址<br>• 包括两部分：段地址和偏移地址<br>– 物理地址<br>• 段地址*\16+偏移地址&#x3D;物理地址<br>– 寻址操作根据操作系统默认规则完成<br>堆栈（段）<br>– 机制<br>• 栈顶为唯一出入口<br>– 地址较小的一端<br>• 后进先出原则<br>– 作用<br>• 数据暂存<br>• 保留轨迹<br>段加偏移”寻址机制允许重定位<br>– 重定位是指一个完整的程序块或数据块可以在存储器所允许的空<br>间内任意浮动，并定位到一个新的可寻址的区域<br>– 允许程序和数据不需要做任何修改</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>• 微处理器的设计有CISC与RISC两种基本架构。深入理解16位微处理器8086的内部结构<br>及其工作原理，是掌握微机工作原理的基础和关键。Intel系列高档微处理器内部的复杂<br>结构及其工作原理，都是在8086CPU的结构基础上逐步分解结构和细化流水线操作而发<br>展起来的。透彻地掌握8086CPU的基础，将有利于理解高档微处理器的技术发展。<br>• 8086&#x2F;8088 CPU的内部结构由总线接口单元BIU和执行单元EU两部分组成。其内部有3<br>组共14个寄存器，必须了解它们各自的功能，并能掌握它们的使用方法。<br>• 总线周期是理解CPU按时序工作的重要概念。8086&#x2F;8088 CPU一个最基本的总线周期由<br>4个时钟周期组成，简称为4个状态，即T1、T2、T3与T4这4个状态。<br>• 微处理器的引脚及其功能是其重要的外部特性。由于8086／8088 CPU只有40条引脚，<br>学习和掌握它们的功能相对于高档微处理器说来就比较简单。</p>
<p>CF - 进位标志(Carry Flag),表示上一条指令的运算是否产生进位。如果产生进位,CF为1,否则为0。OF - 溢出标志(Overflow Flag),表示上一条指令的结果是否越界。如果结果超出目的操作数可以表示的范围,OF为1,否则为0。<br>SF - 符号标志(Sign Flag),表示上一条指令运算结果的符号。如果结果为负数,SF为1,如果为正数,SF为0。<br>ZF - 零标志(Zero Flag),表示上一条指令的运算结果是否为0。如果结果为0,ZF为1,否则为0。</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>计算机是通过指令来处理各种数据，为指出数据的来源、<br>操作结果的去向及执行何操作，一条指令必须包含以下信<br>息：<br>– (1) 操作码——位数及位置。<br>– (2) 操作数的地址——操作数的个数<br>– (3) 操作结果的存储地址。<br>– (4) 下一条指令的地址<br><code>指令长度   – 可以等于机器字长，也可以大于或小于机器字长。   • 尽可能短   • 等于字节的整数倍。   – 若所有指令的长度都是相等的，称为定长指令字结构   • RISC指令大多采用定长指令结构   – 若各种指令的长度随指令功能而异， </code>操作码<br>– 操作码的位数取决于计算机指令系统的规模<br>– 定长编码和变长编码<br>变长编码：分散地放在指令字的不同字段中，如INTEL 8086&#x2F;Pentium<br>– 优点：能表示更多的指令<br>– 缺点：增加了译码难度，控制器复杂<br><code>指令涉及的数据类型   – 地址：无符号数，一般是加减操作（含移位）   • 8、16或32位   – 数值数据   • 定点数（整数）：补码表示   – 16位、32位、64位   • 浮点数（实数）：IEEE754标准   – 位、位串、字符与字符串   • 用来表示文本、声音和图像等   • 字节、字(16位)、双字(32位)、四字(64位)   – 现代32位计算机通常以32位为一个字：字节、半字(16位)、字(32位)、双字(64位)   – 逻辑数据   • 按位操作（0-假/非0-真） </code>数据寻址方式<br>– 有效地址EA（Effective Address）&#x3D;基址值（BX或BP）+变址<br>值（SI或DI）+位移量DISP<br>• +段基址&#x3D;物理地址<br>– 根据命令判断字段长短<br>• 通常由寄存器长度决定</p>
<h3 id="寻址方式-1"><a href="#寻址方式-1" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>直接数据寻址</li>
<li>寄存器间接寻址（间接寻址目标为存储器，故不能确定目标位置长度）</li>
<li>基址加变址寻址</li>
<li>寄存器相对寻址</li>
<li>相对基址加变址寻址(带DISP的基址加变址寻址)<br>程序存储器寻址方式<br>– 实现程序转移<br>• 条件转移<br>– 段内短转移（-128~+127）<br>• JMP<br>– 段内&#x2F;段间，直接&#x2F;间接寻址<br>• CALL<br>– 段内&#x2F;段间，直接&#x2F;间接寻址<br>• 中断<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他寻址方式  </span><br><span class="line">– 串操作指令寻址方式  </span><br><span class="line">• 操作类别：清0、复制、比较等  </span><br><span class="line">• 源数据地址：DS:SI  </span><br><span class="line">• 目标数据地址：ES:DI  </span><br><span class="line">– I/O端口寻址方式  </span><br><span class="line">• 直接端口寻址  </span><br><span class="line">– IN AL, n OUT n, AL  </span><br><span class="line">– 端口号：0～255  </span><br><span class="line">• 间接端口寻址  </span><br><span class="line">– IN AL, DX OUT DX, AL  </span><br><span class="line">– 端口号：0～65535</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通用数据传送"><a href="#通用数据传送" class="headerlink" title="通用数据传送"></a>通用数据传送</h2><p>&#x2F;&#x2F;CS - Code Segment,代码段寄存器。它保存代码段的起始地址,用于查找程序的指令。IP - Instruction Pointer,指令指针寄存器。它保存下条指令的地址,用于告诉CPU去哪里找到下一条要执行的指令。<br>1、基本传送指令 MOV（Move）：传送<br>– 一般形式：MOV dest, src<br>• dest  src，将源操作数src复制到目的操作数dest，src不变<br>2、堆栈操作<br>– PUSH src<br>– POP dest<br>– LIFO后进先出<br>– 堆栈操作按字进行<br>– 不能POP CS<br>3、XCHG（Exchange）：交换<br>– 一般形式：<br>• XCHG oprd1, oprd2 ;交换oprd1与oprd2的内容<br>– 语法格式：<br>• XCHG reg&#x2F;mem, reg&#x2F;mem<br>4.字节翻译指令XLAT（代码转换或查表指令）<br>– BX 基址：代码转换表首地址（表大小：0~255）<br>– AL 偏移（码值）<br>MOV BX,0030H<br>MOV AL,5<br>XLAT</p>
<h2 id="目标地址传送类指令"><a href="#目标地址传送类指令" class="headerlink" title="目标地址传送类指令"></a>目标地址传送类指令</h2><p><code>LEA（Load Effective Address）装入有效地址   – 语法格式：LEA reg16, mem ;reg16 = mem的有效地址   – 通常用于建立串操作   – 对标志位的影响：无。   – 【例】设BX = 5678H   • LEA SI, 2\[BX]   ;执行后，SI = 567AH 将计算结果放入BX寄存器,而不会访问那个地址的值 </code>LDS reg16, mem<br>– 定位串操作源地址<br>– LDS SI, [DI+100AH]<br>– 低16位存入reg16，高16位存入DS<br><code>LES reg16, mem   – 定位串操作目标地址   – 同上，高16位存入ES </code>LAHF、SAHF（保存和设置标志位）<br>– 与AH寄存器交互<br>– SF：符号标志：运算结果符号位<br>– ZF：零标志：运算结果是否为0<br>– AF：辅助进位标志：低四位是否向高四位进位<br>– PF：奇偶标志：是否有偶数个1<br>– CF：进位标志：是否进位&#x2F;借位</p>
<h2 id="算术运算类指令"><a href="#算术运算类指令" class="headerlink" title="算术运算类指令"></a>算术运算类指令</h2><p>加法<br>– 一般形式：<br>• ADD dest, src ; dest  dest + src<br>• ADC dest, src ; dest  dest + src + CF<br>• INC oprd ;oprd  oprd + 1<br>– 语法格式：<br>• ADD reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• ADC reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• INC reg&#x2F;mem<br>– 对标志位的影响：<br>• ADD、ADC：按一般规则影响CF、OF、SF和ZF<br>• INC：不影响CF，其它同ADD<br>• ADD与ADC的2个操作数必须类型匹配，且不能同时是内存操作数<br>减法<br>– 一般形式：<br>• SUB dest, src ; dest  dest - src<br>• SBB dest, src ; dest  dest - src - CF<br>• CMP oprd1, oprd2 ; oprd1 - oprd2<br>– 与SUB的区别在于，不将减法结果存入dest，只影响标志位<br>• DEC oprd ; oprd  oprd - 1<br>• NEG oprd ; oprd  0 – oprd &#x3D; oprd + 1<br>– 语法格式：<br>• SUB reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• SBB reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• CMP reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• DEC reg&#x2F;mem<br>• NEG reg&#x2F;mem<br>SUB、SBB、CMP：影响CF、OF、SF、ZF、AF和PF<br>• DEC：不影响CF，其它同SUB<br>• SUB与SBB的2个操作数必须类型匹配，且不能同时是内存操作数<br>乘法<br><code>– MUL（Unsigned Multiplication）：无符号乘法   – 一般形式：   • MUL src   – 语法格式：   • MUL reg8/mem8 ; AX = AL × src   • MUL reg16/mem16 ; DX:AX = AX × src   • 对标志位的影响：若8位×8位、16位×16位的结果分别能由8、16位容   纳（即结果的高一半为0），则CF = OF = 0，否则，CF = OF = 1；其   余标志无定义。   • 由于2个n位数的乘积可能需要2n位，因此，若操作数是8位，则结果为   16位；同样，16位操作数相乘结果为32位（80386中32位数相乘结果   为64位）。 </code>IMUL（Integer Multiplication）：带符号乘法<br>– 一般形式：<br>• IMUL src<br>– 语法格式：<br>• IMUL reg8&#x2F;mem8 ; AX &#x3D; AL × src<br>• IMUL reg16&#x2F;mem16 ; DX:AX &#x3D; AX × src<br>• 对标志位的影响：若结果的高一半为低一半的符号扩展，则CF &#x3D; OF &#x3D;<br>0，否则，CF &#x3D; OF &#x3D; 1；其余标志无定义<br>– 【例】对于同一个二进制数，采用 MUL与IMUL执行的结果可能<br>不同。设AL &#x3D; 0FFH，BL &#x3D; 1，分别执行下列指令，会得出不同<br>结果。<br>• MUL BL ; AX &#x3D; 00ffh（255D）<br>• IMUL BL ; AX &#x3D; 0ffffh（-1D）<br>除法<br>– 一般形式：<br>• DIV src ; 无符号数除法<br>• IDIV src ; 带符号数除法<br>– 语法格式：<br>• DIV reg&#x2F;mem<br>• IDIV reg&#x2F;mem<br>– 功能描述：<br>• src是8位：AX÷src，结果商在AL、余数在AH<br>• src是16位：DX:AX÷src，结果商在AX、余数在DX<br>– 对标志位的影响：无定义<br>– 若是8位÷8位或16位÷16位怎么解决？</p>
<p>符号扩展<br>– 对标志位的影响：无<br>– CBW、CWD（Convert Byte&#x2F;Word to Word&#x2F;Double word）<br>– 语法格式：<br>• CBW ; AL符号扩展为AX<br>– (若AL为正数,则零扩展,若AL为负数,则扩展部分全1)<br>• CWD ; AX符号扩展为32位数DX:AX<br>– 【例】设AL &#x3D; 0FEH，给出依次执行下列指令后的结果。<br>• CBW ; ax &#x3D; fffeh<br>• CWD ; dx &#x3D; ffffh, ax不变，即dx:ax &#x3D; -2<br>• 十进制调整指令（不要求）<br>– BCD码的加减乘除</p>
<h2 id="逻辑运算类指令"><a href="#逻辑运算类指令" class="headerlink" title="逻辑运算类指令"></a>逻辑运算类指令</h2><p>AND reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– OR reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– XOR reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– NOT reg&#x2F;mem<br>– TEST reg&#x2F;mem, reg&#x2F;mem&#x2F;imm；执行AND操作但不存储<br>结果<br>• 对标志位的影响：<br>– NOT：无。<br>– 其它指令：CF &#x3D; OF &#x3D; 0，按一般规则影响SF和ZF<br>&#96;使某位变反，其余位保持不变：对应位异或1，其余位为0<br>• 例： XOR AL, 60H ; 使第5、6两位为原来码的反码<br>• 特例： XOR AL, 0FFH &#x3D; NOT AL</p>
<h2 id="移位指令和循环移位指令"><a href="#移位指令和循环移位指令" class="headerlink" title="移位指令和循环移位指令"></a>移位指令和循环移位指令</h2><p>一般形式：<br>– SHL dest, count ; dest逻辑左移，count为移位次数<br>– SAL dest, count ; dest算术左移<br>– SHR dest, count ; dest逻辑右移<br>– SAR dest, count ; dest算术右移<br>– ROL, ROR循环左&#x2F;右移；RCL, RCR带进位标志循环左&#x2F;右移<br>对标志位的影响：<br>– 移位次数为1时，若移位后符号位发生了变化，则OF &#x3D; 1，否则<br>OF &#x3D; 0；若移位次数 &gt; 1，则OF无定义<br>– 按一般规则影响ZF与SF。然而，若移位次数为0，则不影响标志<br>位；CF为最后移入位<br>• 参数规范：当count &#x3D; 1时，可以立即数输入，否则需先<br>存入CL中；count取值范围0~255<br>• 【例】设AX的值为一个2字节非压缩BCD码，将其转换为<br>1字节压缩BCD码存入AL。<br>MOV CL, 4<br>SHL AH, CL ; ah低4位移到高4位<br>AND AL , 0FH ; al高4位清0<br>OR AL , AH</p>
<h2 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h2><p>目标和源都是存储器 (字、字节)<br>– DS:SI 提供源，ES:DI提供目的，CX提供长度<br>• 种类<br>– MOVS（Move）传送<br>– CMPS（Compare）比较<br>– SCAS（Scan）搜索<br>– LODS（Load）读<br>– STOS（Store）写<br>• 方向（DF标志位）<br>• 重复前缀<br>– REP（Repeat）<br>– REPE&#x2F;REPZ<br>– REPNE&#x2F;REPNZ</p>
<h2 id="程序控制类指令"><a href="#程序控制类指令" class="headerlink" title="程序控制类指令"></a>程序控制类指令</h2><p>无条件转移JMP（Jump）<br>• 一般形式：<br>– JMP target ; 转移到target指定的目标地址处<br>– 根据转移的距离，JMP指令可分为下列两类：<br>• 段内转移：在同一代码段内进行，又称近（Near）转移，只要修改IP的<br>值即可实现<br>• 段间转移：可在不同代码段之间进行，又称远（Far）转移，需要同时<br>修改CS和IP的值<br>– 根据目标地址的指定方式，JMP指令又可分为直接转移和间接转<br>移<br>• 直接转移：是指转移的目标地址直接出现在指令中，在程序执行前就已<br>确定<br>• 间接转移：指转移的目标地址是寄存器或内存操作数的值，只有执行到<br>该条指令时才能确定<br>– 直接转移<br>• JMP [NEAR PTR] label ; 段内转移<br>– 目标地址 &#x3D; IP + label（2字节） ; ±32KB<br>例：JMP ADDR1 ; ADDR1代表一个段内目标地址<br>ADDR1与当前IP位移量1235H, CS&#x3D;1500H, IP&#x3D;2400H<br>目的地址：18638H<br>JMP SHORT label<br>– 目标地址 &#x3D; IP + label（1字节） ; -128~127<br>• JMP FAR PTR label ; 段间转移<br>– 间接转移<br>• JMP reg16&#x2F;WORD PTR mem<br>; IP &#x3D; reg16&#x2F;mem16 段内间接转移<br>例：JMP FAR PTR ADDR2 ; ADDR2代表一个段间目标地址<br>ADDR2所在CS&#x3D;6500H，IP&#x3D;020CH<br>目的地址：6520CH<br>例：JMP BX ；BX→IP，CS不变<br>JMP WORD PTR [DI] ；[DS:DI] →IP，CS不变<br>JMP DWORD PTR mem<br>– ; CS &#x3D; [mem+2]，IP &#x3D; [mem]<br>例：当前CS&#x3D;1000H, IP&#x3D;026AH<br>DS&#x3D;2000H, BX&#x3D;1400H, ADDR3&#x3D;020AH<br>JMP DWORD PTR [BX+ADDR3]<br>CS&#x3D;4000H, IP&#x3D;320EH<br>• CALL过程名<br>– CALL NEAR PROC 段内直接寻址（修改IP, CS不变）<br>– CALL BX 段内间接转移（BX → IP）<br>– CALL FAR PROC 段间直接调用<br>• IP、CS都改变，例如：CALL 2000H:5600H<br>• 返回地址入栈包括CS和IP<br>– CALL DWORD PTR [reg16] 段间间接调用<br>• 低字 → IP，高字 → CS<br>– CALL与JMP区别<br>• CALL调用时会将修改前IP（或IP与CS）入栈，且完成后会返回当前位置<br>• RET<br>– 要和CALL调用类型对应：RET（段内）与RETF（段间）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例】求AX累加器和BX累加器中两个无符号数之差的绝  </span><br><span class="line">对值，结果放在2800H单元中  </span><br><span class="line">CMP AX, BX  </span><br><span class="line">JB AA  </span><br><span class="line">SUB AX, BX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], AX  </span><br><span class="line">JMP STOP ;该句缺少怎样？  </span><br><span class="line">AA: SUB BX, AX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], BX  </span><br><span class="line">STOP： HLT</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例】从外设71H中取一个数M,判断其值是否在10和20之  </span><br><span class="line">间，如果M≥20，则送0FFH给外设73H;如果M&lt;10,则送  </span><br><span class="line">00H给外设73H;如果10≤M&lt;20,则送88H给外设73H  </span><br><span class="line">IN AL, 71H  </span><br><span class="line">CMP AL, 10  </span><br><span class="line">JNC LP1  </span><br><span class="line">MOV AL, 00H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP1: CMP AL, 20  </span><br><span class="line">JNC LP2  </span><br><span class="line">MOV AL, 88H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP2: MOV AL, 0FFH  </span><br><span class="line">LP3: OUT 73H, AL  </span><br><span class="line">HLT</span><br></pre></td></tr></table></figure>
<p>循环控制（短地址区间）<br>– LOOP 目标地址<br>• CX-1,如CX≠0,转移到目标地址（负值）<br>– LOOPE&#x2F;LOOPZ 目标地址<br>• CX-1,如ZF&#x3D;1且CX≠0循环（LOOPNE&#x2F;LOOPNZ时ZF&#x3D;0）  </p>
<figure class="highlight plaintext"><figcaption><span>【例】求2个数组之和，每个数组长度为N。如遇到2个组</span></figcaption><table><tr><td class="code"><pre><span class="line">数元素都为0，则停止求和  </span><br><span class="line">MOV SI, -1  </span><br><span class="line">MOV CX, N  </span><br><span class="line">NEXT: INC SI  </span><br><span class="line">MOV AL, [ADDR1 + SI]  </span><br><span class="line">ADD AL, [SI + ADDR2]  </span><br><span class="line">MOV [SI + ADDR3], AL  </span><br><span class="line">LOOPNZ NEXT</span><br></pre></td></tr></table></figure>
<p>中断指令<br>– INT 中断类型<br>• 0-255<br>• 中断向量表<br>– 每种中断占4个字节<br>» 前两个为偏移地址，后两个为段地址<br>– 和CALL的区别<br>• 相同点：断点入栈<br>• 不同点<br>– 清除中断标志IF<br>– 清除单步标志TF<br>– 标志寄存器入栈<br>• 【例】 INT 20H<br>– IRET<br>– INTO 溢出中断（中断号04H）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">延时一秒</span><br><span class="line">START: MOV CX, 1000  </span><br><span class="line">DELAY1S: CALL DELAY1MS  </span><br><span class="line">LOOP DELAY1S  </span><br><span class="line">HLT  </span><br><span class="line">DELAY1MS: PUSH CX  </span><br><span class="line">MOV CX, 374  </span><br><span class="line">LP1: PUSHF  </span><br><span class="line">POPF  </span><br><span class="line">LOOP LP1  </span><br><span class="line">POP CX  </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><code>汇编流程   – 汇编源程序：用助记符指令、变量名和标号编写的程序。   • 文件名：\*\*\*.ASM   – 目标程序：机器能识别的二进制代码程序。   • 文件名：\*\*\*.OBJ   – 执行程序：为PC系统所接受的应用程序。   • 文件名：\*\*\*.EXE   • 工具程序   –</code> 汇编程序：把汇编源程序翻译成机器能识别的机器指令程序的工<br><code>具程序。   • 文件名：MASM.EXE   – 连接程序：把目标文件与库文件以及其他目标文件连接在一起。   • 文件名：LINK.EXE </code>汇编语言语句类型<br>– 指令性语句——真指令<br>• 实际的CPU指令<br>• 汇编程序将其翻译成机器目标代码<br>• 由四部分组成：<br>[标号:] 指令助记符 [操作数] [; 注释]<br>– 指示性语句——伪指令[伪操作指令]<br>• 方便编制程序<br>• 不产生代码<br>[名字] 伪操作命令 [操作数表] [; 注释]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSEG SEGMENT PARA STACK ; 堆栈段定义  </span><br><span class="line">DW 256 DUP (?)  </span><br><span class="line">SSEG ENDS  </span><br><span class="line">DSEG SEGMENT ; 数据段定义  </span><br><span class="line">MESS DB &#x27;HELLO&#x27;, 0DH, 0AH, &#x27;$&#x27;  </span><br><span class="line">DSEG ENDS  </span><br><span class="line">CSEG SEGMENT ; 代码段(指令区)  </span><br><span class="line">ASSUME CS:CSEG, DS:DSEG ; 规定段的性质  </span><br><span class="line">START: MOV AX, DSEG ; 设置数据段基值  </span><br><span class="line">MOV DS, AX  </span><br><span class="line">MOV DX, OFFSET MESS ; 显示字符串信息  </span><br><span class="line">MOV AH, 09  </span><br><span class="line">INT 21H  </span><br><span class="line">MOV AH,4CH ; 结束本程序运行，返回DOS  </span><br><span class="line">INT 21H  </span><br><span class="line">CSEG ENDS  </span><br><span class="line">END START  </span><br><span class="line">汇编语言有若干个段  </span><br><span class="line">段名、开始、结束  </span><br><span class="line">唯一的END结束  </span><br><span class="line">定义起始执行地址</span><br></pre></td></tr></table></figure>
<p>表达式和运算符<br>– 由汇编程序计算<br>• 值<br>• 地址<br>– 算术运算符（7种）<br>• +、-、*、&#x2F;<br>• MOD<br>• SHL、SHR<br>逻辑运算符（4种）<br>• AND、OR、XOR、NOT<br>• 和指令助记符的区别<br>• MOV AL, 0ADH AND 0EAH → MOV AL, 0A8H<br>– 关系运算符（6种）<br>• EQ、NE、LT、GT、LE、GE<br>• 关系成立时返回0FFFFH，不成立时返回0<br>– 数值返回运算符<br>• SEG<br>• OFFSET<br>• TYPE<br>• SIZE<br>• LENGTH<br>属性运算符<br>• PTR 修改操作数类型<br>• THIS</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>数据定义伪指令（变量定义）<br>– 数据定义伪指令用来为数据分配内存空间(规定变量的类型），<br>并设置相应内存单元的初始值。<br>– 形式：<br>变量名 变量定义符 操作数, 操作数, …, 操作数<br>• 其中，变量名是一个符号地址，表示其后操作数的首地址，变量名为可<br>选项，给出变量名只是为了按名存取其对应的内存单元。<br>变量定义符主要包括下列几种<br>– DB（Define Byte）：定义字节，后面的每个操作数占1个字节。<br>– DW（Define Word）：定义字，后面的每个操作数占1个字。<br>– DD（Define Dword）：定义双字，后面的每个操作数占2个字。<br>– 操作数可以是<br>• 常数 例：DATA DB 10, 4, 10H<br>• 表达式 例：DATA DW 2*3, 8&#x2F;4<br>• 字符串 例：DATA DB ‘ABCD’<br>– ？表示只保留内存空间，未定义初始值。<br>• 例：DATA DD ？, 1, ？<br>• 重复次数 DUP （操作数，．．．，操作数）<br>– 例：DATA DB 3 DUP（？，9）</p>
<h2 id="存储器的分类与组成"><a href="#存储器的分类与组成" class="headerlink" title="存储器的分类与组成"></a>存储器的分类与组成</h2><p><code>存储器分类   – 程序的执行是从主存中自动的取指令到控制器进行解释执行，需   要的数据也放在主存中根据指令需要存取。   – 按存储介质分类   • 半导体存储器：双极型，静态MOS型，动态MOS型   • 磁表面存储器：磁盘（Disk）、磁带 （Tape）   • 光存储器：CD、CD-ROM、DVD   – 按断电后信息的可保存性分类   • 非易失性存储器   – 信息可一直保留，不需电源维持（如 ：ROM、磁表面存储器、光存储器等）   • 易失性存储器   – 电源关闭时信息自动丢失。（如：RAM、Cache等） – 按存储器功能分类   • 读写存储器（Read/Write Memory)：可读可写   • 只读存储器（Read Only Memory)：只能读不能写   – 按工作方式/存取方式分类   • 随机存取存储器Random Access Memory (RAM)   – 每个单元读写时间一样，且与各单元所在位置无关，如：内存。   • 顺序存取存储器Sequential Access Memory (SAM)   – 数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置   有关，例如：磁带。   • 直接存取存储器Direct Access Memory (DAM)   – 直接定位到要读写的数据块，在读写某个数据块时按顺序进行。例如：磁盘。   • 相联存储器Associate Memory/Content Addressed Memory (CAM）   – 按内容存储与检索，根据内容访问存储位置并进行读写。例如：快表。 – 按容量/速度   • 寄存器   • 高速缓存   • 主存   • 外存储器 </code>参数<br>– 存取速度：<br>• 存取时间𝑇𝑎：指的是CPU从启动一次存储器操作到完成所需要的时间。<br>• 存取周期𝑇𝑚：是指连续启动两次独立的存储器操作所需最小时间间隔。<br>• 带宽（数据传输速度）</p>
<h3 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h3><p>– 读<br>• CPU先把读单元地址送到AR，经过地址总线送往主存，同时CPU通过控<br>制总线发一个读请求，然后CPU等待从主存储器发来的信号，通知CPU<br>读操作已经完成。<br>• 存储器通过ready线回答，如果ready信号为1，说明存储字的内容已经<br>读出，并放在数据总线上，送往DR。<br>– 写<br>• CPU先将写单元地址经AR送往地址总线，并把写内容字送DR，同时通<br>过控制总线发出写命令，然后CPU等待写操作完成信号。<br>• 主存把收到的信息字写入CPU指定的地址后通过ready线发出完成信号。</p>
<h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><p>分类<br>– ROM<br>• 芯片的内容在制造时已经输入，只能读，不能修改。<br>• 存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。存储<br>元件：二极管或晶体管。<br>– PROM（Programmable ROM, PROM）<br>• 用户可根据自己的需要来确定ROM里的内容，常见的是熔丝式PROM<br>是以熔丝的接通来表示1、断开表示0。常用于工业控制机。<br>– EPROM（Erasable PROM, EPROM）<br>• 紫外线擦除，只能对芯片进行整体擦除，而不能对芯片中个别需要改写<br>的存储单元单独擦除。编程次数不受限制。<br>E2PROM（Electrically EPROM）<br>• 电擦除，可以用字擦除方式擦除，也可以用数据块擦除方式擦除。以字<br>擦除方式操作时，能够只擦除被选中的那个存储单元的内容；在数据块<br>擦除方式操作时，可擦除数据块内所有单元的内容。编程次数受限制。<br>– 闪速存储器（Flash Memory）<br>• 一种快擦写型存储器，它的主要特点是：既可在不加电的情况下长期保<br>存信息，又能进行快速擦除（整体擦除或分区擦除）与重写，兼备了E2<br>PROM和RAM的优点。<br>• 闪存的读取速度与DRAM相近，是磁盘的100倍左右；写数据（快擦－<br>编程）则与硬盘相近。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li>字扩展（位数不变、扩充容量）</li>
<li>位扩展（字数不变，位数扩展）</li>
<li>字位同时扩展（字和位同时扩展）</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>解决内存访问速度慢的措施有三个：<br>• 提高主存芯片本身的速度<br>• 采用多模块存储器技术<br>• 在主存和CPU之间加入Cache</p>
<h3 id="外部存储器（辅助存储器"><a href="#外部存储器（辅助存储器" class="headerlink" title="外部存储器（辅助存储器"></a>外部存储器（辅助存储器</h3><p>磁表面存储器<br>– 两类：数字磁记录和模拟磁记录。<br>– 原理：磁性材料沉积在基体上形成记录介质，通过磁头与记录介<br>质的相对运动来读写信息。<br>– 优点：<br>①容量大，位价低<br>②记录介质可重复使用<br>③信息可长期保存甚至可脱机保存<br>④非破坏性读出<br>– 缺点：<br>①速度慢<br>②对工作环境要求高<br>光存储器<br>– 记录原理：用激光在具有感光特性的介质上非接触地记录高密度<br>信息，以介质材料的光学性质的变化来表示0或1。<br>– 优点：容量大、可替换（便携带）<br>– 缺点：速度慢。</p>
<p>寻址时间<br>– 寻址时间包括两部分：磁头寻找目标磁道所需的寻道时间和找到<br>磁道后磁头等待所需要读写的区段旋转到磁头下方的等待时间。<br>– 平均寻址时间&#x3D;平均寻道时间+平均等待时间<br>– 平均等待时间与磁盘转速有关，用磁盘旋转一周所需时间的一半<br>来表示。<br>数据传输率<br>– 外部：磁表面存储器的缓存在单位时间内与主机之间传送数据的<br>位数或字节数。<br>• 单位bps。<br>• 取决于总线的类型和标准<br>– ATA、SCSI、SATA、SAS<br>– 内部：磁头与硬盘内存之间的数据传输率。<br>• 传输率&#x3D;记录密度D x 运动速度V<br>• 误码率<br>– 衡量磁表面存储器的出错概率，等于出错信息的位数和读出的总<br>信息位数比。<br>磁盘cache<br>– 基本情况：硬盘内存速度差 (ms-ns)<br>• 可采用增加磁盘主轴转速<br>• 提高I&#x2F;O总线速度<br>• 改进读写算法<br>• 采用磁盘cache等方法<br>– 缓存的大小与速度是直接关系到硬盘的传输速度的重要因素。<br>– 主流硬盘的缓存8M以上（有些甚至1G）。<br>– 类型一般是DRAM或SDRAM。<br>– 采用预读策略（局部性规则）：对顺序数据特别有效<br>• 视频数据<br>• 图像文件<br>磁盘阵列存储器（RAID）<br>• 廉价冗余磁盘阵列（RAID）是用多台磁盘储存器组成的大<br>容量外存储子系统。（Redundant Arrays of<br>Inexpensive Disk）由美国加州大学伯克利分校提出。<br>• 目的<br>– 组合小的廉价磁盘来代替大的昂贵的磁盘，降低大批量数据存储<br>的费用；<br>– 希望采用冗余信息的方式，使得磁盘失效时不会使对数据的访问<br>受损失；<br>– 能适当的提升数据传输速度。<br>– 保证数据的可靠性和高可用性<br>RAID的实现<br>– 专门的控制芯片来完成<br>– 用软件的方法来实现，<br>RAID 0级（无冗余和无校验的数据分块）<br>– 将连续的数据块分别存放在不同的磁盘上。具有最高的I&#x2F;O性能<br>和磁盘空间利用率，无数据冗余，无容错能力，不能应用于数据<br>安全性要求高的场合。<br>• RAID 1级（镜像磁盘阵列）<br>– 由磁盘对组成，每一个工作盘都有对应的镜像盘，上面保存着与<br>工作盘完全相同的数据，安全性高，但磁盘空间的利用率只有<br>50%<br>RAID 2级（具有纠错海明码的磁盘阵列）<br>– 采用海明码纠错技术和位交叉技术，用户需增加足够的校验盘来<br>提供单纠错和双验错功能。当阵列内有G个数据盘时，则所需的<br>校验盘数C要满足公式： 2𝐶 ≥ 𝐺 + 𝐶 + 1，如果有4个数据盘，<br>则需要3个校验盘。对数据的访问涉及到磁盘阵列中的每一个盘，<br>对大数据量传送有较高性能，但不利于小数据量的传送。RAID<br>2很少使用。<br>位交叉存取<br>– 将一个数据段中的各位分别存储在不同的磁盘上，以同步方式进<br>行读写，最小访问数据单位是每个磁盘的最小读写单位（例如扇<br>区）X磁盘数。<br>– 适合传送批量数据<br>• 块交叉存取<br>– 以数据块为单位，将连续的数据块分别存放在不同的磁盘上，最<br>小访问数据单位是每个磁盘的最小读写单位（例如扇区）<br>– 适合传送少量数据<br>RAID 5级（无专用校验盘的奇偶校验磁盘阵列）<br>– 无专用的校验盘，将校验信息分布到组内所有盘上，对大、小数<br>据量的读写都有很好的性能，因而是一种较好的方案。<br>• RAID 10级（RAID 0级+RAID 1级）<br>– 由分块和镜像组成，是所有RAID中性能最好的磁盘阵列，但每<br>次写入时要写两个互为镜像的盘， CPU占用率高，磁盘的利用<br>率低<br>磁盘存储器与光盘存储器的比较<br>– 两种存储器的记录原理、组成部分等方面都是相同的。在计算机<br>中它们各有自己的特点与功能。<br>– 硬盘驱动器<br>• 容量大、数据传输率高、等待时间短。<br>– 光盘驱动器<br>• 存储密度高、容量大、价格低。但是光盘与主机的速度不匹配所以不能<br>作为中间存储器，即不能替代硬盘<br><img src="/images/obsidian/20230610145852.png" alt="图片" title="image"><br>为什么这种层次化结构是有效的？<br>– 时间局部性（Temporal Locality）<br>• 含义：刚被访问过的单元很可能不久又被访问<br>• 做法：让最近被访问过的信息保留在靠近CPU的存储器中<br>– 空间局部性 （Spatial Locality）<br>• 含义：刚被访问过的单元的邻近单元很可能不久被访问<br>• 做法：将刚被访问过的单元的邻近单元调到靠近CPU的存储器中<br>– 大量典型程序的运行情况分析结果表明：程序具有访问局部性特<br>征<br>• 指令：指令按序存放，地址连续，循环程序段或子程序段重复执行<br>• 数据：连续存放，数组元素重复、按序访问</p>
<p>• 键盘<br>– 键盘是一组排列成阵列形式的按键开关，按下一个键就产生一个<br>相应的字符，然后转换成ASCII或其他码送往主机<br>– 键盘输入信号处理可分为三个步骤：<br>• (1) 按下一个键；<br>• (2) 查出按下的是哪一个键；<br>• (3) 将该键翻译成能被计算机接收的代码<br>• 键盘的种类<br>– 机械式键盘<br>• 触点的导通或断开<br>• 每个键由底座、轴帽、轴帽固定卡、弹簧、金属支脚、触点金属片<br>导电橡胶式键盘<br>• 通过导电的橡胶实现触点的连接<br>– 电容式键盘<br>• 当人体（手指）接触金属感应片的时候，由于人体相当于一个接大地的<br>电容，因此会在感应片和大地之间形成一个电容<br>薄膜式键盘<br>• 无机械磨损<br>• 低价格<br>• 低噪音<br>• 低成本<br>• 市场占有相当份额<br>• 鼠标<br>– 一种坐标定位部件，只能用来输入相对坐标。<br>• CMOS传感器将每一幅图像都发送给数字信号处理器（DSP）进行分析。<br>• DSP检测各图像中的图案，并分析图像中图案的位置如何变动。<br>• 根据一系列图像中图案位置的变化，DSP确定鼠标的移动距离并将相应<br>坐标发送给计算机。<br>• 计算机根据从鼠标接收到的坐标信息，移动屏幕上的光标。<br>– 与轨迹球鼠标相比，光电鼠标具有下列优势：<br>• 没有可移动的零部件，这意味着磨损更少、故障率更低。<br>• 灰尘无法进入鼠标内部并干扰跟踪传感器。<br>• 增加的跟踪分辨率意味着响应更顺畅。<br>• 不需要鼠标垫等专用表面。<br>触摸屏<br>– 电阻式：利用压力感应进行控制电阻<br>– 电容式：利用人体的电流感应进行工作<br>– 红外式：在显示器上加上光点距架框，在屏幕表面形成一个红外<br>线网<br>– 表面声波触摸屏：玻璃屏的左上角和右下角各固定了竖直和水平<br>方向的超声波发射换能器，右上角则固定了两个相应的超声波接<br>收换能器。玻璃屏的四个周边则刻有45°角由疏到密间隔非常精<br>密的反射条纹<br>条形码（Bar Code）<br>– 由一组宽度和反射率不同的平行相邻条和空按预先规定的编码规<br>则组合起来，用来表示一组数据的符号<br>主要类型<br>• 堆叠式&#x2F;行排式<br>– 建立在一维条码基础之上，按需要堆积成二行或多行<br>– 继承了一维条码的一些特点<br>– 需要对行进行判定，其译码算法与软件也不完全相同于一维条码<br>• 矩阵式二维码<br>– 它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码<br>– 用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制<br>的“0”，点的排列组合确定了矩阵式二维条码所代表的意义<br>显示器显色原理<br>– 像素点：颜色显示的最小单元<br>• 一个像素点包含三原色<br>• 通过调整三原色的显示强弱来控制颜色<br>CRT<br>– 可用于字符、图形和图像显示器。<br>– CRT是一个真空器件，由电子枪、偏转装置和荧光屏组成。<br>– 玻璃屏内壁涂有荧光粉，它将电子束的动能转换成光能，显示出<br>光点。不同的荧光粉在电子束的轰击下发出不同的颜色。<br>– 对电子束的要求<br>• （1）电子束要有足够的强度和速度。<br>• （2）电子束要足够细。<br>• （3）电子束的运动方向要高度可控<br>有机发光二极管（OLED）<br>– 自发光的二极管，无需背光<br>• 等离子显示器（PDP）<br>– 利用惰性气体在一定电压下产生气体放电现象而实现的发光技术。<br>• 显示技术的重要技术指标<br>– 分辨率<br>• 字符显示方式<br>– 一屏可显示的最多字符数称为分辨率，例如80列×25行，表示每屏最多可显示25<br>行，每行可有80个字符。<br>• 在图形显示方式<br>– 一屏可显示的像点数称为分辨率，例如800×600，表示一屏可包含600条水平扫<br>描线，每线可分为800点。<br>• 分辨率越高，显示的信息越多<br>颜色数（位深）：每个像素点可显示的颜色数（灰度级）<br>• 每种原色由8位表示灰度，三原色共计224种颜色<br>• 实际传输过程中采用32位表示一种颜色，而高端显示器每种原色用10位<br>表示，总共可表示230，约10.7亿色<br>按打字原理分：击打式打印机（点阵针式打印机）和非击<br>打式打印机（喷墨打印机、激光打印机）。<br>• 按工作方式分：串行打印机和行式打印机。串行打印机一<br>次只能打一个字，行式打印机一次可以打印一行<br>• 常见打印机类型<br>– 点阵针式打印机<br>– 激光打印机<br>– 喷墨打印机<br>– 热转印和热敏打字机<br>• 发展趋势<br>– 击打式和非击打式并存<br>– 击打式的多样化、特殊化：银行、铁路、超市、酒店</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>基于恐龙书和苏大ppt的操作系统笔记</title>
    <url>/2023/09/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机系统可以分为四个部分</span><br><span class="line">硬件(Hardware) – 提供基本的计算资源</span><br><span class="line">CPU, memory, I/O devices</span><br><span class="line">操作系统(Operating System)</span><br><span class="line">控制和协调各用户的应用程序对硬件的使用</span><br><span class="line">应用程序(Application programs) – 规定了用户按何种方式使用系统资源</span><br><span class="line">字处理程序, 编译器, 网络浏览器, 数据库系统, 视频游戏</span><br><span class="line">用户(Users)</span><br><span class="line">人, 机器, 其他计算机</span><br><span class="line">操作系统的目标:</span><br><span class="line">运行用户程序  ---核心目标</span><br><span class="line">更方便使用计算机 ---面向用户</span><br><span class="line">更高效使用计算机 ---面向系统</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>计算机启动时，会启动引导程序，来初始化系统的各个组件，加载操作系统并开始执行<br>操作系统加载到内存后，开始为系统和用户提供服务，成为系统进程或者后台程序该阶段完成后系统完全启动并且等待事件发生。<br>事件发生通过”中断“机制来通知，cpu被中断时，停止正在做的事，并立即转到固定位置继续执行中断服务程序，执行完后继续执行被中断的计算</p>
<ul>
<li>中断：指当出现需要时，CPU暂时停止当前程序的执行，转而执行处理新情况的程序和执行过程</li>
<li>中断号：外部设备进行I&#x2F;O操作时产生的中断信号，发送给CPU</li>
<li>中断向量：中断服务程序的入口地址</li>
<li>中断服务程序：执行中断处理的代码</li>
<li>陷阱(trap):是由于出错或用户请求引起的软件生成的中断<br>操作系统是中断驱动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在冯·诺依曼体系结构( von Neumann architecture)上执行时，一个典型的指令执行周期是，首先从内存中获取指令，并存到指令寄存器( instruction register)。接着，该指令被解码，也可能会从内存中获取操作数据并且存到内部寄存器。在指令完成对操作数据的执行后，结果也可存到内存。注意:内存单元只能看到内存地址的流，而并不知道它们如何产生(通过指令计数器、索引、间接、常量地址或其他方式)或它们是什么样（指令或数据）的地址。相应地，我们可以忽略程序如何产生内存地址，而只关注由程序运行所生成的地址序列。</span><br></pre></td></tr></table></figure>

<h2 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h2><p>由两个或多个独立的系统耦合起来<br>共享数据 storage-area network (SAN)。<br>提供高可用性。<br>一定的冗余<br>非对称集群(Asymmetric Clustering)：一台机器运行应用程序，而其他机器处于热备份模式。<br>对称集群(Symmetric Clustering)：多个主机都运行应用程序<br>提供high-performance computing (HPC)<br>用专门的应用程序利用集群，并行计算parallelization</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多道程序设计：在内存中同时存在多道作业，在管理程序控制下相互穿插运行</span><br><span class="line">通过作业调度(Job Scheduling)选中一个作业并运行</span><br><span class="line">当该作业必须等待时 (如等待I/O), 切换到另一个作业</span><br><span class="line">目的:提高CPU的利用率，充分发挥计算机系统部件的并行性</span><br></pre></td></tr></table></figure>

<p>分时系统：控制响应时间较短，使计算机可交互，一般采用时间片轮转方式使一台计算机为多个用户服务<br>并行：两个或者多个作业在同一时刻运行<br>并发：两个或多个作业在同一时间间隔内依次运行<br>双重模式：允许OS保护自身和其他系统部件<br>用户模式(user mode)和内核模式(kernel mode)，由硬件提供模式位<br>特权指令：可能引起系统崩溃的指令，只能运行在内核模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果操作系统不能获得CPU控制权，就无法管理系统</span><br><span class="line">eg.用户程序死循环，用户程序不调用系统调用</span><br><span class="line">解决方法：定时器</span><br><span class="line">在一段时间后发生中断，CPU控制权返回操作系统</span><br><span class="line">固定时间和可变时间定时器</span><br><span class="line">利用时钟和计数器实现</span><br></pre></td></tr></table></figure>

<p>I&#x2F;O保护<br>防止用户程序执行非法I&#x2F;O<br>解决方法：所有I&#x2F;O指令都是特权指令<br>用户程序通过系统调用进行I&#x2F;O操作<br>内存保护<br>防止内存非法访问<br>解决方法：存储保护机制<br>硬件支持<br>程序运行必须的存储设备<br>CPU只能直接访问寄存器、高速缓存和内存<br>处理前和处理后的所有数据都在内存<br>执行的指令都在内存<br>内存管理：提供内存的分配、回收、地址转换、共享和保护等功能<br>提高内存利用率<br>提高内存访问速度<br>从而提高计算机运行效率</p>
<p>操作系统服务提供对用户很有用的函数:</p>
<ul>
<li><p>用户界面 – 所有的操作系统都有用户界面(UI)<br>形式有命令行界面(CLI)、图形用户界面(GUI)、批界面</p>
</li>
<li><p>程序执行 – 系统必须能将程序转入内存并运行程序。程序必须能结束执行，包括正常或不正常结束（指明错误）</p>
</li>
<li><p>I&#x2F;O 操作 -  运行程序可能需要I&#x2F;O,这些I&#x2F;O可能涉及文件或设备.</p>
</li>
<li><p>文件系统操作 -  文件系统特别重要。很明显，程序需要读写文件和目录，创建和删除文件，搜索文件，列出文件信息，访问管理</p>
</li>
<li><p>通信 – 进程间可能需要交换信息，发生同一台计算机运行的进程间或由网络连接的不同计算机上的进程间(消息传递和共享内存)<br>通信可以通过共享内存或消息交换技术来实现 (消息包由OS移动)</p>
</li>
<li><p>错误检测 – OS 需要知道可能出现的错误<br>错误可能发生在CPU 或内存硬件、I&#x2F;O设备和用户程序中<br>对于每种类型的错误，OS 应该采取适当的动作以确保正确和一致的计算<br>调试工具可以在很大程度上加强用户和程序员有效使用系统的能力</p>
</li>
</ul>
<p><code>层次结构</code>：操作系统划分为若干层，在低层上构建高层，底层（0层）为硬件，最高层（ N层）为用户层，每层只使用低层次的功能和服务<br>优点<br>简化了系统设计和实现，便于调试和升级维护<br>缺点<br>层定义困难，效率差<br><code>微内核</code>：<br>问题：内核越来越大，越来越难管理<br>内核微型化：核内移出尽可能多功能到用户空间<br>好处:<br>便于扩充，便于移植操作系统到新架构系统上，更稳定 (更少的代码运行在核心态)，更安全<br>坏处:<br>用户空间和内核空间通信的系统开销增加<br>解决方法：提出消息传递机制<br><code>模块化</code>：<br>大部分现代操作系统采用模块结构(Linux, Solaris)<br>使用面向对象方法<br>每个核心部件分开<br>每个与其他模块的会话被称为接口<br>每个模块在需要时被加载到内核<br>总体而言，类似于分层方法，但更灵活</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个程序可对应一个或多个进程，同样一个进程可对应一个或多个程序</span><br><span class="line">程序是进程的代码部分</span><br><span class="line">进程是活动(active)实体，程序静止（被动passive）实体</span><br><span class="line">进程在内存，程序在外存</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>Control Block)</span></figcaption><table><tr><td class="code"><pre><span class="line">PCB包含同进程有关的信息，包括：</span><br><span class="line">进程状态</span><br><span class="line">程序计数器</span><br><span class="line">CPU寄存器</span><br><span class="line">CPU调度信息</span><br><span class="line">内存管理信息</span><br><span class="line">计账信息</span><br><span class="line">I/O状态信息</span><br></pre></td></tr></table></figure>

<p><img src="/images/obsidian/20230529221113.png" alt="图片" title="image"><br><code>进程调度队列</code>：<br>作业队列 - 在系统中的所有进程的集合<br>就绪队列 - 在主内存中的，就绪并等待执行的所有进程的集合<br>设备队列 - 等待某一I&#x2F;O设备的进程队列<br>在各种队列之间进程的迁移<br><code>进程终止</code>：</p>
<ul>
<li>进程执行最后一项并退出（exit）<br>从子进程向父进程输出数据（通过wait）<br>操作系统收回进程的资源<br>父进程可中止子进程的执行（ abort）</li>
<li>子进程超量分配资源<br>赋予子进程的任务不再需要<br>若父进程终止，一些系统不允许子进程继续存在<br>所有子进程终止– 级联终止</li>
<li>父进程可以等子进程结束<br>调用wait()系统调用<br><code>进程通信</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息传递在微内核中的应用</span><br><span class="line">远程通信无法采用共享内存</span><br><span class="line">两个操作 :</span><br><span class="line">发送send(message) - 固定或可变大小消息</span><br><span class="line">接收receive(message)</span><br><span class="line">若P与Q要通信，需要:</span><br><span class="line">建立通信连接</span><br><span class="line">通过send/receive交换消息</span><br><span class="line">通信连接的实现</span><br><span class="line">物理的（如，共享存储，硬件总线）</span><br><span class="line">逻辑的（如，逻辑特性）</span><br><span class="line">消息传递可阻塞（blocking）或非阻塞（non-blocking）</span><br><span class="line">阻塞-同步</span><br><span class="line">阻塞send：发送进程阻塞，直到消息被接收</span><br><span class="line">阻塞receive：接受者进程阻塞，直到有消息可用</span><br><span class="line">非阻塞-异步</span><br><span class="line">非阻塞send：发送进程发送消息并继续操作</span><br><span class="line">非阻塞receive: 接收者收到一个有效消息或空消息</span><br><span class="line">如果通过信箱，则可分为直接和间接通信</span><br></pre></td></tr></table></figure>

<p><code>线程</code>（轻型进程lightweight process, LWP ）是CPU使用的一个基本单元，包括</p>
<ul>
<li>线程ID</li>
<li>程序计数器</li>
<li>寄存器集<br><code>栈空间</code><br>一个线程与它的对等线程共享：</li>
<li>代码段</li>
<li>数据段</li>
<li>操作系统资源<br>总体作为一个任务<br>多线程的优点：</li>
<li>响应性</li>
<li>资源共享</li>
<li>经济</li>
<li>可伸缩性：可在多处理核上并行运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调度</span><br><span class="line">线程是调度的基本单位，同一进程中的线程切换不会引起进程切换。</span><br><span class="line">并发</span><br><span class="line">线程可以提高系统的并发性。</span><br><span class="line">资源</span><br><span class="line">进程拥有资源，是资源分配的基本单位，而线程则不拥有资源，但它可以访问创建它的进程所拥有的资源</span><br><span class="line">上下文切换</span><br><span class="line">线程的上下文切换的代价比进程小。</span><br></pre></td></tr></table></figure>

<p>可分为数据并行和任务并行<br><img src="/images/obsidian/20230530184144.png" alt="图片" title="图片"><br><img src="/images/obsidian/20230530184243.png" alt="图片" title="图片"><br><img src="/images/obsidian/20230530185433.png" alt="图片" title="图片"><br>&#x2F;&#x2F;S是应用程序的一部分，N是它在N个处理器上串行运行<br><code>线程的分类</code>：</p>
<ul>
<li>用户线程：由用户线程库进行管理的线程<br>内核看不到用户线程<br>用户线程的创建和调度在用户空间中，不需要内核的干预<br>应用于传统的只支持进程的操作系统</li>
<li>内核线程：内核进行管理的线程<br>需要内核支持<br>由内核完成线程调度<br>由内核进行创建和撤销<br><code>多线程模型的分类</code>：</li>
<li>多对一模型：<br>不支持内核线程的操作系统<br>内核只有进程<br>内核只看到一个进程<br>多个线程不能并行运行在多个处理器上<br>进程中的用户线程由进程自己管理<br>进程内线程切换不会导致进程切换<br>一个线程的系统调用会导致整个进程阻塞</li>
<li>一对一模型<br>用于支持线程的操作系统<br>用户线程一对一映射到内核线程<br>操作系统管理这些线程<br>并发性好：多个线程可并行运行在多个处理器上<br>内核开销大</li>
<li>多对多模型：<br>多个用户线程映射为相等或更小数目的内核线程<br>并发性和效率兼顾<br>增加复杂度<br><code>线程库</code><br>为程序员提供API来创建和管理线程<br>两种模式：</li>
<li>用户库（用户线程）<br>存在于用户空间<br>没有内核支持<br>调用线程库不会产生系统调用</li>
<li>内核库（内核线程）<br>存在于内核<br>操作系统支持<br>调用线程库会产生系统调用<br><code>隐式线程</code>：在编译或者运行的时候由编译器或者运行库决定而不是编程者<br><code>线程池</code>：在池中创建一批线程，等待任务<br>优点：<br>利用线程池中的线程来响应请求比创建一个线程更加快速<br>允许一个应用程序中的线程数量达到线程池的上限<br><code>大中央调度</code>:<br>Apple 技术用于Mac OS X 和 iOS<br>扩展C, C++ languages, API, 和 run-time library<br>允许辨认可并行区段<br>管理线程的大多数细节<br>块格式“^{ }” -   ˆ{ printf(“I am a block”); }<br>块放置在调度队列中<br>在线程池中有可用的线程的时候离开队列<br><code>线程撤销</code>在完成前终止线程<br>要取消的线程称为目标线程 target thread<br>大体两种方法:<br>异步取消Asynchronous cancellation 立刻终止目标线程<br>延迟取消Deferred cancellation 允许目标线程周期性检查它是否应该被终止<br><code>调度程序激活</code></li>
<li>通常用一种中间数据结构在用户和内核线程间 – 轻量级进程 lightweight process (LWP)<br>类似虚拟处理器<br>每个 LWP 和内核进行相连<br>一定数量的LWP</li>
<li>调度器激活提供 upcalls – 一种线程库中内核使用upcall处理句柄 upcall handler 来告知特定事件<br><img src="/images/obsidian/20230530200404.png" alt="图片" title="image"><br>这种通讯允许一个应用程序保持正确数目的内核线程</li>
</ul>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>&#96;需要调度的四种情况</p>
<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程从运行切换到就绪状态（eg.出现中断）</li>
<li>进程从等待状态切换到就绪状态(eg.IO完成)</li>
<li>进程终止时<br>调度只发生在1，4情况下是非抢占调度<br><code>非抢占调度 一旦把CPU分配给某进程后，系统不可以抢占已分配的CPU并分配该其它进程 只有进程自愿释放CPU，才可把CPU分配给其他进程 优点：易实现，调度开销小，适合批处理系统 缺点：响应时间长，不适合交互式系统 </code>抢占调度<br>调度程序可根据某种原则暂停某个正在执行的进程，将已分配给它的CPU重新分配给另一进程<br>可防止单一进程长时间独占CPU<br>系统开销大<br>抢占式与非抢占式的区分<br>运行进程是否是自愿放弃CPU<br><code>长程调度 又称作业调度、高级调度 “新建”状态转换到“就绪”状态 由调度程序选择 控制多道程序的“道/度”（Degree） </code>短程调度<br>又称CPU调度、低级调度<br>调度程序选择下一个执行进程</li>
<li>切换频率<br>短程调度切换频率高<br>长程调度切换频率低</li>
<li>切换开销<br>短程调度开销小(milliseconds，切换快)<br>长程调度开销大(seconds&#x2F;minutes，切换慢)</li>
<li>操作系统中应用<br>短程调度：必需<br>长程调度：可选<br><code>中程调度 又称交换 将进程在内存和外存间换进换出 目的：节省内存空间 </code>就绪队列<code>- 在主内存中处于就绪状态并等待执行的所有进程集合</code>设备队列<code>- 等待某一I/O设备的进程队列 进程的执行过程实际上就是进程在各种队列之间的迁移</code>基本指标</li>
<li>CPU利用率 – 固定时间内CPU运行时间的比例</li>
<li>吞吐量 – 单位时间内运行完的进程数</li>
<li>周转时间 – 进程从提交到运行结束的全部时间</li>
<li>等待时间 – 进程等待调度（不运行）的时间片总和</li>
<li>响应时间 – 从进程提交到首次运行[而不是输出结果]的时间段，也就是第一段的等待时间</li>
</ul>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p><code>等待时间</code>&#x3D;开始处理时间-到达时间<br><code>周转时间</code>&#x3D;等待时间+处理时间</p>
<h2 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务-FCFS"></a>先来先服务-FCFS</h2><p>优点：实现简单<br>缺点：长进程在前会使多个短进程等待过久，增加平均等待时间</p>
<h2 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先-SJF"></a>短作业优先-SJF</h2><p>SJF是最优的 – 对一组指定的进程而言，它给出了最短的平均等待时间</p>
<h3 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><p>有比当前进程所需时间更短进程到达时，更换目前进行进程<br>常用于长进程调度，缺点在于进程的cpu区间难以估计<br>通常用指数平均估计</p>
<h3 id="非抢占式调度"><a href="#非抢占式调度" class="headerlink" title="非抢占式调度"></a>非抢占式调度</h3><p>进程只在结束后让出cpu</p>
<h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>基于进程紧迫程度赋予优先级，cpu分配给最高优先级进程<br>优点<br>实现简单，考虑了进程的紧迫程度<br>灵活，可模拟其它算法</p>
<ul>
<li>静态优先级<br>进程创建时确定，运行期间不变</li>
<li>动态优先级<br>优先级随着进程推进或者等待时间增加而改变</li>
</ul>
<p>&#96;问题</p>
<ul>
<li>饥饿：低优先级进程可能永远无法运行</li>
<li>老化：视进程等待时间延长提高优先级</li>
</ul>
<h3 id="响应比高者优先调度"><a href="#响应比高者优先调度" class="headerlink" title="响应比高者优先调度"></a>响应比高者优先调度</h3><p>响应比&#x3D;（开始时间-到达时间）&#x2F;运行时间</p>
<ul>
<li>如等待时间相同，运行时间越短，优先级越高，类似于SJF</li>
<li>如运行时间相同，优先级取决于其等待时间，类似于FCFS</li>
<li>长进程的优先级可随等待时间的增加而提高，最终可得到服务</li>
<li>缺点：每次调度之前，都需要计算响应比，增加系统开销</li>
</ul>
<h2 id="轮转调度-RR"><a href="#轮转调度-RR" class="headerlink" title="轮转调度-RR"></a>轮转调度-RR</h2><p>将较小的时间单元定义为时间片，就绪队列为循环队列，调度程序循环整个队列，为每个进程分配不超过一个时间片的cpu</p>
<h2 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h2><p>进程分为前台进程（交互进程）和后台进程（批处理进程）<br>不同类型的进程需要不同策略<br>交互进程需要短的响应时间<br>批处理进程需要短的等待时间<br><code>多级队列梯度</code>系统中存在多个就绪队列，每个队列有自己的调度算法</p>
<h3 id="多级反馈序列-MLFQ"><a href="#多级反馈序列-MLFQ" class="headerlink" title="多级反馈序列-MLFQ"></a>多级反馈序列-MLFQ</h3><p><em>(MultiLevel Feedback Queue Scheduling)</em><br>多级队列的延伸<br>不同：</p>
<ul>
<li>多级队列：进程不能在不同队列间移动</li>
<li>多级反馈队列：进程能在不同队列间移动</li>
<li>多级反馈队列调度需要考虑以下问题：<br>队列数<br>每一队列的调度算法<br>决定进程升级（低级队列到高级队列）的方法<br>决定进程降级（高级队列到低级队列）的方法<br>决定新进程将进入哪个队列的方法<br>&#96;最常用的调度算法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">Q0-RR时间片8ms</span><br><span class="line">Q1-RR时间片16ms</span><br><span class="line">Q2-FCFS</span><br></pre></td></tr></table></figure>

<p>缺点：优先级一开始确定，无法调整</p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><p>区别用户层和内核层<br>调度线程而不是进程<br>多对多和多对一模型，线程库在可用的LWP上调度用户层线程<br>process-contention scope (PCS) 在进程中进行调度竞争<br>通常由程序员通过优先级设置<br>内核线程通过system-contention scope (SCS) 在CPU上调度– 系统中统一竞争<br>一对一模型仅使用SCS，如Windows， Linux</p>
<h2 id="局部调度"><a href="#局部调度" class="headerlink" title="局部调度"></a>局部调度</h2><p>[[线程库]]决定哪个线程列入轻量级进程LWP</p>
<h2 id="全局调度"><a href="#全局调度" class="headerlink" title="全局调度"></a>全局调度</h2><p>内核决定下一个运行的内核线程</p>
<h1 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h1><p>调度类似单处理器，但需要将任务平均分配</p>
<h2 id="对称多处理器-SMP"><a href="#对称多处理器-SMP" class="headerlink" title="对称多处理器-SMP"></a>对称多处理器-SMP</h2><h3 id="单队列多核调度方法-SQMP"><a href="#单队列多核调度方法-SQMP" class="headerlink" title="单队列多核调度方法(SQMP)"></a>单队列多核调度方法(SQMP)</h3><p>系统有一个就绪队列。当任意一个CPU空闲时，就从就绪队列中选择一个进程到该CPU上运行<br>优点：<br>容易从单核调度算法推广到多核&#x2F;多处理器、<br>实现简单，负载均衡<br>缺点：<br>不具有亲和性<br>加锁问题</p>
<h3 id="多队列调度方法-MQMP"><a href="#多队列调度方法-MQMP" class="headerlink" title="多队列调度方法(MQMP)"></a>多队列调度方法(MQMP)</h3><p>系统有多个就绪队列，一般每个CPU一个。每个就绪队列有自己的调度算法，并且每个就绪队列的调度相对独立<br>优点：<br>亲和性好<br>不需要加锁<br>缺点：<br>负载不均衡<br>策略：“偷”进程<br><code>每个处理器决定自己调度方式 定期检测每个cpu负载，分配任务给空闲处理器 </code>亲和性：进程倾向于在给定cpu上运行</p>
<ul>
<li>软亲和性：不强制禁止迁移</li>
<li>硬亲和性：禁止迁移</li>
</ul>
<h3 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h3><p>共享队列，分配给不同cpu<br>不具有亲和性</p>
<h3 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h3><p>不同cpu有各自队列<br><code>优点</code>：亲和性较好，不需要加锁<br><code>缺点</code>：负载不均匀</p>
<h2 id="非对称处理器-ASMP"><a href="#非对称处理器-ASMP" class="headerlink" title="非对称处理器-ASMP"></a>非对称处理器-ASMP</h2><p>仅一个处理器处理系统数据结构，减轻共享需求</p>
<h1 id="实时cpu调度"><a href="#实时cpu调度" class="headerlink" title="实时cpu调度"></a>实时cpu调度</h1><ul>
<li>软实时系统：不保证调度关键实时进程</li>
<li>硬实时系统：任务必须在截止期限前完成<br>对实时调度，必须支持抢占式、优先级调度<br>但仅仅支持软实时<br>对硬实时必须提供满足截止时间的能力<br>需要调度进程的新特性：<br>周期性 periodic 定期需要CPU<br>有进程时间 t, 截止时间 d, 周期 p<br>0 ≤ t ≤ d ≤ p<br>周期任务的速率Rate 1&#x2F;p</li>
</ul>
<h2 id="单速速度调度"><a href="#单速速度调度" class="headerlink" title="单速速度调度"></a>单速速度调度</h2><p>依照周期倒数分配一个优先级<br><code>优点</code>：最大化cpu利用率<br><code>缺点</code>：不保证每个进程都赶上截止期限(周期内执行不完)</p>
<h2 id="最早截止期限优先调度-EDF"><a href="#最早截止期限优先调度-EDF" class="headerlink" title="最早截止期限优先调度-EDF"></a>最早截止期限优先调度-EDF</h2><p>根据截止时间分配优先级<br>越早截止期限，优先级越高</p>
<h2 id="比例分享调度"><a href="#比例分享调度" class="headerlink" title="比例分享调度"></a>比例分享调度</h2><p>所有应用中分配T股，确保所有进程有固定的cpu时间，如果新加入进程大于T股剩余量，则不允许进入</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li>实时任务有静态优先级（友好值）</li>
<li>抢占式<br>没有真正的线程</li>
</ul>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul>
<li>抢占调度</li>
<li>优先级</li>
</ul>
<p>对共享数据的并发访问可能导致数据的不一致性，需要保证并发进程正确执行顺序的机制<br><code>竞争条件</code>：多个进程并发访问同一共享数据</p>
<ul>
<li><code>同步</code>：协调执行次序</li>
<li><code>互斥</code>：进程排他性运行，可以独占资源<br><code>临界资源</code>：一次只允许一个进程使用的资源，又称互斥资源、独占资源或共享变量<br><code>共享资源</code>：一次允许多个进程使用的资源</li>
</ul>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><ul>
<li><code>互斥</code>：临界区执行的进程排斥其他进程（有相同临界资源）</li>
<li><code>进步</code>:临界区无进程执行，不能无限期延长下一个需要临界区进程的等待时间</li>
<li><code>优先等待</code>：一个进程进入临界区时，其他进程进入<code>临界区</code>有次数限制</li>
<li>进入区：互斥</li>
<li>退出区：有空让进</li>
<li>每个临界区不能过大：有限等待<br>空闲则入：其他进程均不处于临界区；<br>忙则等待：已有进程处于其临界区；<br>有限等待：等待进入临界区的进程不能”死等”；<br>让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peterson算法</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">  flag [i]:= true;  </span><br><span class="line">  turn = j;  </span><br><span class="line">  while (flag [j] and turn == j) ;</span><br><span class="line"></span><br><span class="line">  critical section</span><br><span class="line"></span><br><span class="line">  flag [i] = false;</span><br><span class="line"></span><br><span class="line">  remainder section</span><br><span class="line"></span><br><span class="line">  &#125; while (1);</span><br></pre></td></tr></table></figure>

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acquire() &#123;  </span><br><span class="line">       while (!available)</span><br><span class="line">          ; /* busy wait */</span><br><span class="line">       available = false;;</span><br><span class="line">    &#125;</span><br><span class="line">   release() &#123;</span><br><span class="line">       available = true;</span><br><span class="line">    &#125;</span><br><span class="line">   do &#123;</span><br><span class="line"></span><br><span class="line">    acquire lock</span><br><span class="line"></span><br><span class="line">       critical section</span><br><span class="line"></span><br><span class="line">    release lock</span><br><span class="line"></span><br><span class="line">      remainder section</span><br><span class="line"></span><br><span class="line"> &#125; while (true);</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁（自旋锁）"><a href="#互斥锁（自旋锁）" class="headerlink" title="互斥锁（自旋锁）"></a>互斥锁（自旋锁）</h3><p>原子执行acquire(),release()<br>acquire：while(!available) waiting;<br>available&#x3D;false<br>release:available&#x3D;false</p>
<h3 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h3><ul>
<li>在进入临界区前，每个进程接收一个号码。具有最小号码的进程进入临界区。</li>
<li>如果进程Pi和Pj接收到同样的号码，如果i &lt; j ，则Pi先得到服务，否则Pj先得到服务。</li>
<li>这种号码方案总是以递增序列产生号码；如： 1,2,3,3,3,3,4,5…</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  choosing[i] = true;</span><br><span class="line">  number[i] = max(number[0], number[1], …, number [n – 1])+1;</span><br><span class="line">  choosing[i] = false;</span><br><span class="line">  for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">  while (choosing[j]) ;</span><br><span class="line">  while ((number[j] != 0) &amp;&amp; (number[j,j] &lt; number[i,i])) ;</span><br><span class="line">  &#125;</span><br><span class="line">  critical section</span><br><span class="line">  number[i] = 0;</span><br><span class="line">  remainder section</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>

<h2 id="信号量（软件解决方案）"><a href="#信号量（软件解决方案）" class="headerlink" title="信号量（软件解决方案）"></a>信号量（软件解决方案）</h2><ul>
<li>保证多个代码段不被并发调用</li>
<li>进入关键代码段前，进程必须获取信号量，否则不能运行</li>
<li>执行完关键代码段，必须释放信号量</li>
<li>信号量有值，说明空闲，为负说明忙碌</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信号量S – 整型变量</span><br><span class="line">提供两个不可分割的[原子操作]访问信号量</span><br><span class="line">wait (S):</span><br><span class="line">     while S&lt;= 0 do no-op;  </span><br><span class="line">     S--;  </span><br><span class="line">signal(S):</span><br><span class="line">     S++;</span><br><span class="line">wait (S)又称为P(S)</span><br><span class="line">signal(S)又称为V(S)</span><br></pre></td></tr></table></figure>

<p>&#96;分类</p>
<ul>
<li>计数信号量：没有限制的整型值计数信号量&#x3D;同步信号量</li>
<li>二值信号量：0 || 1 二值信号量&#x3D;互斥信号量<br>&#96;使用<br>必须取一次且仅有一次初值<br>初值不为负<br>除了初始化，只能通过执行P、V操作来访问S</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：P1  和 P2 需要 C1 比C2先运行</span><br><span class="line">       semaphore s=0</span><br><span class="line">P1:</span><br><span class="line">   C1;</span><br><span class="line">   signal(s);</span><br><span class="line"></span><br><span class="line">P2:</span><br><span class="line">   wait(s);</span><br><span class="line">   C2;</span><br></pre></td></tr></table></figure>

<p>死锁 – 两个或多个进程无限期地等待一个事件的发生，而该事件正是由其中的一个等待进程引起的.<br>P0  P1<br>  P(S);  P(Q);<br>  P(Q);  P(S);<br>  V(S);  V(Q);<br>  V(Q)  V(S);<br>饥饿 – 无限期地阻塞。进程可能永远无法从它等待的信号量队列中移去.</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><p><code>生产者 把产品放入指定缓冲区 in:所有的生产者对in指针需要互斥 counter：所有生产者消费者进程对counter互斥 </code>消费者<br>从指定缓冲区取出产品<br>out:所有的消费者对out指针需要互斥<br>counter：所有生产者消费者进程对counter互斥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer[in] = nextProduced;</span><br><span class="line">in = (in + 1) % BUFFER_SIZE;</span><br><span class="line">counter++;</span><br><span class="line"></span><br><span class="line">nextConsumed = buffer[out];</span><br><span class="line">out = (out + 1) % BUFFER_SIZE;</span><br><span class="line">counter--;</span><br><span class="line"></span><br><span class="line">生产者：</span><br><span class="line"> &#123;</span><br><span class="line">  …</span><br><span class="line">  生产一个产品</span><br><span class="line">  …</span><br><span class="line">  wait(empty);</span><br><span class="line">  wait(m);</span><br><span class="line">   …</span><br><span class="line">  C1：把产品放入指定缓冲区</span><br><span class="line">   …</span><br><span class="line">  signal(m);</span><br><span class="line">  signal(full);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">消费者：</span><br><span class="line"> &#123;</span><br><span class="line">  …</span><br><span class="line">  wait(full)；</span><br><span class="line">  wait(m);</span><br><span class="line">   …</span><br><span class="line">  C2：从指定缓冲区取出产品</span><br><span class="line">   …</span><br><span class="line">  signal(m);</span><br><span class="line">  signal(empty);</span><br><span class="line">   …</span><br><span class="line">  消费取出的产品</span><br><span class="line">   …</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>&#96;同步分析</p>
<ul>
<li>找出需要同步的代码段</li>
<li>分析片段执行顺序</li>
<li>增加同步信号量并赋初始值</li>
<li>关键代码前后加wait和signal操作<br>&#96;生产者</li>
<li>判断是否能获得空缓冲区，否则阻塞</li>
<li>满缓冲区数量++，如果有消费者由于等待阻塞，唤醒该消费者<br>&#96;消费者</li>
<li>判断能否获得满缓冲区，否则阻塞</li>
<li>空缓冲区数量++，如果有生产者等待，唤醒该生产者</li>
</ul>
<h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><p>两组并发进程读者和写者,共享一组数据区进行读写<br>&#96;要求</p>
<ul>
<li>允许多个读者同时读</li>
<li>不允许读者、写者同时读写</li>
<li>不允许多个写者同时写<br>&#96;读者</li>
<li>无读者写者，新读者可读</li>
<li>有写者等，其他读者读，新读者可读</li>
<li>有写者写，新读者等<br>&#96;写者</li>
<li>无读者写者，新写者可写</li>
<li>有读者读，写者等</li>
<li>有其他写者，写者等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个读者计数器rc，设置初始值为0；</span><br><span class="line">读者：Repeat</span><br><span class="line">P(mutex);</span><br><span class="line">readcount:=readcount+1;</span><br><span class="line">if readcount=1</span><br><span class="line">then P (w);</span><br><span class="line">V(mutex);//mutex为互斥信号量，初始值为1</span><br><span class="line">读</span><br><span class="line">P(mutex);</span><br><span class="line">readcount:=readcount-1;</span><br><span class="line">if readcount=0</span><br><span class="line">then V(w);</span><br><span class="line">V(mutex);</span><br><span class="line">Until false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Writers</span><br><span class="line">……</span><br><span class="line">P(W);</span><br><span class="line">写</span><br><span class="line">V(W);</span><br><span class="line">…...</span><br></pre></td></tr></table></figure>

<p>&#96;问题：写者可能饥饿</p>
<ul>
<li>读者写者互斥，写者直到读者count为0才进入进程</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>5个哲学家、5根筷子，每个哲学家左右各有一根筷子，每个哲学家只有拿起左右两个筷子才能吃饭<br>五个元素数组储存筷子，对每个哲学家有拿起左右筷子，放下左右筷子的函数<br>&#96;防止死锁</p>
<h5 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h5><p>最多允许四个哲学家同时坐在桌子周围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semephore *chopstick[5];   //初始值为1</span><br><span class="line">semaphore *seat;  //初始值为4</span><br><span class="line">哲学家 i:</span><br><span class="line">  ……</span><br><span class="line">  P(seat);  //看看4个座位是否有空</span><br><span class="line">  P(chopStick[i]);  //拿左边筷子</span><br><span class="line">  P(chopStick[(i + 1) % 5]);  //拿右边筷子</span><br><span class="line">   吃饭</span><br><span class="line">   V(chopStick[i]);  //放下左边筷子</span><br><span class="line">   V(chopStick[(i + 1) % 5]);  //放下右边筷子</span><br><span class="line">   V(seat);  //释放占据的位置</span><br></pre></td></tr></table></figure>

<ul>
<li>左右筷子都可用时才拿起筷子</li>
<li>非对称解决，单号哲学家优先拿左边筷子，双号优先拿右边</li>
</ul>
<h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>仅当一个哲学家左右两边筷子都可用时，才允许他拿筷子<br>哲学家分为三个状态thinking,hungry,eating<br>设置5个信号量代表所有哲学家，仅当自身hungry且左右都不在吃饭时才开始eating</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(int i);</span><br><span class="line">    &#123;</span><br><span class="line">        if (state[i] == hungry) &amp;&amp;  //是否饿了</span><br><span class="line">          (state[(i+4)%5]!=eating) &amp;&amp; //左边哲学家是否在吃饭</span><br><span class="line">          (state[(i+1)%5]!=eating)  //右边哲学家是否在吃饭</span><br><span class="line">          &#123;</span><br><span class="line">                 state[i]=eating;  //设置哲学家状态为eating</span><br><span class="line">                 V(ph[i]);  //ph[i]设置为1</span><br><span class="line">           &#125;     </span><br><span class="line">     &#125;</span><br><span class="line">     state[i]=hungry；</span><br><span class="line">            P(m);</span><br><span class="line">            test(i);</span><br><span class="line">            V(m);</span><br><span class="line">            P(ph[i]);</span><br></pre></td></tr></table></figure>

<h5 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h5><p>给所有哲学家编号，奇数号哲学家必须首先拿左边筷子，偶数号哲学家则反之</p>
<h3 id="信号量总结"><a href="#信号量总结" class="headerlink" title="信号量总结"></a>信号量总结</h3><p>S&gt;0：有S个资源可用<br>S&#x3D;0：无资源可用<br>S&lt;0：则|S|表示S等待队列中的进程个数<br>P(S)：申请一个资源<br>V(S)：释放一个资源<br>互斥信号量初始值：一般为1<br>同步信号量初始值：0-N<br>&#96;P、V操作成对出现<br>互斥操作：P、V操作处于同一进程内<br>同步操作：P、V操作在不同进程内<br>两个一起的P操作的顺序至关重要<br>同步与互斥P操作一起时，同步P操作要在互斥P操作前<br>两个V操作的次序无关紧要</p>
<p><code>缺点</code>：同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如P、V操作的次序错误、重复或遗漏）<br>易读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序；<br>不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局；<br>正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误；</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据<br>封装数据以及对数据的操作<br>确保每次只要一个进程在管程内活动<br><code>互斥 管程中的变量只能被管程中的操作访问 任何时候只有一个进程在管程中操作 类似临界区 由编译器完成 </code>同步<br>条件变量<br>唤醒和阻塞操作<br>x.wait(): 进程阻塞直到另外一个进程调用x.signal()<br>x.signal()：唤醒另外一个进程</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>管程内可能存在不止1个进程<br>如：进程P调用signal操作唤醒进程Q后<br>存在的可能<br>P等待直到Q离开管程 （Hoare）<br>Q等待直到P离开管程（Lampson &amp; Redll，MESA语言）<br>P的signal操作是P在管程内的最后一个语句 (Hansen，并行Pascal)</p>
<h2 id="内存概念"><a href="#内存概念" class="headerlink" title="内存概念"></a>内存概念</h2><ul>
<li>程序必须装入内存才能被执行</li>
<li>CPU可以直接访问的存储器只有主存和寄存器</li>
<li>寄存器通常可以在一个（或少于一个）CPU时钟周期内完成访问</li>
<li>完成主存访问可能需要多个CPU时钟周期</li>
<li>CPU暂停（Stall）：在读取内存数据时，CPU空闲</li>
<li>Cache 位于主存和CPU寄存器之间，协调速度差异</li>
<li>内存保护需要保证正确的操作</li>
<li>基址寄存器（ Base）：进程最小的合法物理内存地址</li>
<li>界限寄存器（Limit）：进程地址的长度</li>
<li>CPU在执行指令时，需要进行地址合法性验证<br><code>给进程提供一段地址</code>：基地址寄存器（最小地址）和界限地址寄存器（地址范围）<br>物理地址对进程是隐藏的<br><code>地址绑定（程序加载地址）</code>：可以静态绑定也可以动态绑定，动态绑定生成可重定位代码<br><code>动态加载</code>，所有程序以可重定位格式存储在磁盘，只有在调用时才被加载<br><code>动态链接和共享库</code>:每个库程序都有一个存根，指出如何定位内存驻留库程序，或者程序不在内存时如何家在程序，执行存根时检查程序是否在内存，若不是，则加载程序到内存</li>
</ul>
<h3 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h3><p>地址绑定（重定位）：把程序中的相对地址转换为内存中的绝对地址的过程<br>指令和数据绑定到内存地址可在三个不同阶段：<br><code>编译时期（ Compile time） 如果内存位置已知，可生成绝对代码 如果开始位置改变，需要重新编译代码 </code>加载时期（ Load time）<br>如果存储位置在编译时不知，则必须生成可重定位（ relocatable ）代码<br>&#96;执行时期（ Execution time）<br>如果进程执行时可在内存移动，则地址绑定可延迟到运行时<br>需要硬件对地址映射的支持（例如基址和限长寄存器）<br>大部分操作系统用这个方法</p>
<h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><p>逻辑地址空间的概念同物理地址空间相关联，它是正确内存管理的中心<br>逻辑地址Logical address<br>由CPU产生<br>在进程内的相对地址<br>也称：虚拟地址、程序地址<br>物理地址Physical address<br>内存地址<br>所有内存统一编址<br>也称：绝对地址、实地址</p>
<h3 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h3><p>把虚拟地址映射到物理地址的硬件<br>是CPU用来管理内存的控制线路<br>在MMU策略中，基址寄存器中的值在其送入内存的时候被加入到由一个用户进程所产生的每个地址中<br>用户程序所对应到的是逻辑地址，物理地址对它从来都不可见</p>
<h3 id="动态加载和链接"><a href="#动态加载和链接" class="headerlink" title="动态加载和链接"></a>动态加载和链接</h3><p><code>加载 例程在调用之前并不加载 更好的内存空间利用率 没有被使用的例程不被载入 当需大量代码来处理不经常使用的功能时非常有用 </code>链接<br>和各种库文件的链接被推迟到执行时期<br>需要动态装载技术支持<br>一小段代码 - 存根，用来定位合适的保留在内存中的库程序<br>存根用例程地址来替换自己，并开始执行例程<br>操作系统需要检查例程是否在进程的内存空间，所以需要操作系统支持</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行。<br><code>备份区</code>—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">滚入，滚出(Roll out, roll in )—交换由于基于优先级的算法而不同，低优先级的进程被换出，这样高优先级的进程可以被装入和执行。</span><br><span class="line">交换时间的主要部分是转移时间，总的转移时间直接同交换的内存的数量成比例。</span><br><span class="line">在许多系统如：UNIX，Linux，Windows中，可以找到一些被修正过的交换措施。</span><br><span class="line">系统维持一个就绪队列，它包括在备份存储或在内存中准备运行的所有进程</span><br></pre></td></tr></table></figure>

<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><p>为一个用户程序分配一个连续的内存空间</p>
<ul>
<li>单一连续分配：单道程序环境下，仅装有一道用户程序，即整个内存的用户空间由该程序独占</li>
<li>固定分区分配<br>固定分配多个区域，用于放置单个进程<br>预先把可分配的主存空间分割成若干个连续区域，称为一个分区。<br>每个分区的大小可以相同也可以不同。但分区大小固定不变，每个分区装一个且只能装一个程序<br>内存分配：如果有一个空闲分区, 则分配给进程</li>
<li>可变分区分配：<br>用表格记录内存使用情况，根据内存块和孔调度进程<br>当一个进程到来的时候，它将从一个足够容纳它分区中分配内存。<br>操作系统包含以下信息:<br>a) 已分配的分区-已分配分区表   b) 空的分区-空闲分区表</li>
</ul>
<h3 id="选择孔"><a href="#选择孔" class="headerlink" title="选择孔"></a>选择孔</h3><ul>
<li>首次适应（First-fit）: 分配最先找到的合适的分区</li>
<li>最佳适应（Best-fit）: 搜索整个列表，找到适合条件的最小的分区进行分配</li>
<li>最差适应（Worst-fit）: 搜索整个列表，寻找最大的分区进行分配</li>
</ul>
<p><code>碎片</code>：</p>
<ul>
<li>外部碎片：存储被分为大量小孔</li>
<li>内部碎片：分配给进程的孔，进程不需要使用的部分则成为内部碎片<br>外碎片 –整个可用内存空间可以用来满足一个请求，但它不是连续的<br>内碎片 –分配的内存可能比申请的内存大一点，这两者之间的差别是在分区内部，但又不被使用<br>&#96;可通过紧缩来减少外碎片<br>把一些小的空闲内存结合成一个大的块。<br>只有重定位是动态的时候，才有可能进行紧缩，紧缩在执行时期进行</li>
</ul>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>一个程序是一些段的集合，一个段是一个逻辑单位<br>每个段用段名称和段偏移指定位置<br>一个逻辑地址是两个向量的集合:<br>&lt;segment-number, offset&gt;</p>
<p>段表 - 映射二维用户地址，每个表项包括:<br>基址 - 包含内存中段物理地址的起始地址<br>限长 - 指定段的长度<br>段表基址寄存器(STBR)指向段表在内存中的地址<br>段表限长寄存器(STLR)表明被一个程序所使用的段的数目<br>如果 s &lt; STLR，段号s 是合法的</p>
<p>由于段的长度各不相同，内存分配是一个动态存储-分配问题</p>
<p>&#96;内存分配<br>首先&#x2F;最佳适应法<br>外碎片问题</p>
<p>&#96;重定位<br>动态<br>由段表来执行</p>
<p>&#96;共享<br>共享的段<br>同样的段号</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>允许进程的物理地址不连续<br><code>基本方法</code>：将物理内存分为固定大小的块，称为帧或页帧，逻辑内存分为同样大小的块，称为页或页面<br>进程物理地址空间可能不连续<br>如果有可用的物理内存，它将分给进程<br>把物理内存分成大小固定的块，称为帧（Frame）<br>大小为2的幂<br>早期：512字节至8192字节<br>现在：4K-64K<br>把逻辑内存也分为同样大小的块，称为页（Page）<br>系统保留所有空闲帧的记录<br>运行一个有N页大小程序，需要找到N个空帧来装入程序<br>建立一个页表，把逻辑地址转换为物理地址<br>存在内碎片<br><code>内存保护 内存的保护由与每个帧相连的保护位来实现 有效-无效位附在页表的每个表项中: “有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页 “无效”表示页不在进程的逻辑地址空间中 </code>共享代码<br>如果代码是可重入代码（只读），可以在进程间共享 (如文本编辑器, 编译器, 数据库系统)<br>共享代码必须出现在所有进程的逻辑地址空间的相同位置<br>&#96;私有代码和数据<br>每个进程保留一个代码和数据副本<br>存有私有数据和代码的页能够出现在逻辑地址空间的任意位置</p>
<h3 id="页表的层次结构"><a href="#页表的层次结构" class="headerlink" title="页表的层次结构"></a>页表的层次结构</h3><h4 id="二层页表"><a href="#二层页表" class="headerlink" title="二层页表"></a>二层页表</h4><p>内存的保护由与每个帧相连的保护位来实现<br>有效-无效位附在页表的每个表项中:<br>“有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页<br>“无效”表示页不在进程的逻辑地址空间中<br><img src="/images/obsidian/20230605104632.png" alt="图片" title="image"></p>
<h4 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h4><p>虚拟页号被散列到一个页表中。这种页表的每一个条目都包括了一个链表元素，这些元素哈希成同一<br>虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。<br>虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。</p>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>对于每个真正的内存页或帧有一个条目。<br>每个条目保存在真正内存位置的页的虚拟地址，以及包括拥有这个页的进程的信息。<br>&#96;优缺点<br>减少了需要储存每个页表的内存，但是当访问一个页时，增加了寻找页表需要的时间。<br>使用哈希表来将查找限制在一个或少数几个页表条目。<br>实现共享内存困难</p>
<h4 id="段页式原理"><a href="#段页式原理" class="headerlink" title="段页式原理"></a>段页式原理</h4><p>分段和分页原理的结合<br>先将用户程序分成若干个段，再把每个段分成若干个页，并为每个段赋予一个段号<br>逻辑地址：&lt;段号，页号，页内偏移&gt;<br>存在内碎片<br>无外碎片</p>
<h3 id="内存扩充技术"><a href="#内存扩充技术" class="headerlink" title="内存扩充技术"></a>内存扩充技术</h3><ol>
<li>紧缩Compaction（可变分区）</li>
<li>覆盖技术Overlaying</li>
<li>交换技术Swapping</li>
<li>虚拟内存Virtual Memory</li>
</ol>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>解决问题à程序大小超过物理内存总和<br>程序执行时<br>只在内存中保留那些在任何时间都需要的指令和数据<br>程序的不同部分在内存中相互替换<br>由程序员声明覆盖结构，不需要操作系统的特别支持<br>覆盖结构的程序设计很复杂<br>应用于早期的操作系统</p>
<h4 id="交换-1"><a href="#交换-1" class="headerlink" title="交换"></a>交换</h4><p>在多道程序环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况<br>另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况<br>浪费资源，降低系统吞吐量。<br>一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行<br>备份区—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问<br>交换（备份区）：系统指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问</p>
<h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>资源类型 R1, R2, . . ., Rm<br>CPU周期，内存空间，I&#x2F;O设备<br>每一种资源Ri 有Wi  种实例<br>每一个进程通过如下方法来使用资源<br>申请，使用，释放<br>资源动态申请-常用方法<br>在进程运行过程中申请资源<br>资源静态申请<br>在进程运行前一次申请所有资源</p>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>死锁指一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组中其他进程所持有的资源</p>
<ul>
<li>互斥：一次只有一个进程可以使用一个资源</li>
<li>占用并等待：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源</li>
<li>非抢占：一个资源只有当持有它的进程完成任务后，自由的释放</li>
<li>循环等待：等待资源的进程之间存在环 {P0, P1, …, P0}</li>
</ul>
<h2 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h2><p>被分为两个部分<br>P &#x3D; {P1, P2, …, Pn}, 含有系统中全部的进程<br>R &#x3D; {R1, R2, …, Rm}, 含有系统中全部的资源<br>请求边：有向边Pi-&gt;Rj<br>分配边：有向边Ri-&gt;P</p>
<ul>
<li>如果图没有环，那么不会有死锁</li>
<li>如果图有环<br>如果每一种资源类型只有一个实例，那么死锁发生<br>如果一种资源类型有多个实例，可能死锁<br><img src="/images/obsidian/20230604203017.png" alt="图片" title="image"></li>
</ul>
<h2 id="死锁处理的分类"><a href="#死锁处理的分类" class="headerlink" title="死锁处理的分类"></a>死锁处理的分类</h2><ul>
<li>确保系统永远不会进入死锁状态<br>死锁预防<br>死锁避免</li>
<li>允许系统进入死锁状态，然后检测它，并加以恢复<br>死锁检测<br>死锁恢复</li>
<li>忽略这个问题，假装系统中从未出现过死锁。<br>这个方法被大部分的操作系统采用，包括UNIX、Windows<br>由开发人员自行处理死锁</li>
</ul>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>&#96;抑制死锁发生的必要条件</p>
<ul>
<li>互斥：可共享资源不涉及死锁，互斥资源必须强制互斥</li>
<li>持有并等待：保证进程申请资源时不占有其他资源，要求进程在执行前一次性申请全部资源，或者只有不占有资源时才可以分配资源，&#96;可能出现饥饿</li>
<li>抢占：</li>
</ul>
<ol>
<li>如果一个进程的申请没有实现，它要释放所有占有的资源</li>
<li>先占的资源放入进程等待资源列表中</li>
<li>进程在重新得到旧的资源的时候可以重新开始</li>
<li>进程申请资源时，如果资源可用则分配，如果不可用，检查资源是否被分配给等待额外资源的其他进程，如果是，抢占资源，否则，申请进程等待</li>
</ol>
<ul>
<li>循环等待:对所有资源完全排序，进程按顺序申请资源<br>银行家算法</li>
</ul>
<h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><ul>
<li>一个简单而有效的模型要求每一个进程声明它所需要的资源的最大数</li>
<li>死锁避免算法动态检查资源分配状态以确保循环等待条件不可能成立</li>
<li>资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量所决定</li>
</ul>
<h4 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h4><p>当进程申请一个有效的资源的时候，系统必须确定分配后是安全的<br>如果存在一个安全序列，系统处于安全态<br>进程序列&lt;P1, P2, …, Pn&gt;是安全的，如果每一个进程Pi所申请的可以被满足的资源数加上其他进程所持有的该资源数小于系统总数<br>如果 Pi 需要的资源不能马上获得，那么Pi 等待直到所有的Pi-1进程结束。<br>当Pi-1 结束后， Pi获得所需的资源，执行、返回资源、结束。<br>当Pi结束后， Pi+1获得所需的资源执行，依此类推。<br>&#96;定理<br>如果一个系统在安全状态，就没有死锁<br>如果一个系统不是处于安全状态，就有可能死锁<br>避免&#x3D;&gt;确保系统永远不会进入不安全状态</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>多个实例</li>
<li>每一个进程必须事先声明使用的最大量</li>
<li>当一个进程请求资源，它可能要等待</li>
<li>当一个进程得到所有的资源，它必须在有限的时间释放它们</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Available:  长度为 m的向量。 如果available[j]=k,那么资源Rj有k个实例有效</span><br><span class="line">Max: n x m 矩阵。 如果Max[i,j]=k,那么进程Pi最多可以请求k个资源Rj的实例</span><br><span class="line">Allocation:  n x m 矩阵。 如果Allocation[i,j]=k,那么进程Pj当前分配了k个资源Rj的实例</span><br><span class="line">Need:  n x m 矩阵。如果Need[,j]=k,那么进程Pj还需要k个资源Rj的实例</span><br><span class="line">Need [i,j] = Max[i,j] – Allocation [i,j].</span><br><span class="line">1.让Work和Finish作为长度为m和n的向量初始化：</span><br><span class="line">Work := Available</span><br><span class="line">Finish [i] = false for i - 1,2,3, …, n.</span><br><span class="line">2.  查找i</span><br><span class="line">(a) Finish [i] = false</span><br><span class="line">(b) Needi £ Work</span><br><span class="line">If no such i exists, go to step 4.</span><br><span class="line">3.  Work := Work + Allocationi  </span><br><span class="line">Finish[i] := true  </span><br><span class="line">go to step 2.</span><br><span class="line">4.  如果对所有i的 Finish [i] = true, 则系统处在安全状态。</span><br></pre></td></tr></table></figure>

<p>   Requesti &#x3D;进程 Pi 的资源请求向量.  如果Requesti [m] &#x3D; k 则进程 Pi 想要资源类型为Rjm的k个实例<br>1.  如果 Requesti £ Needi 转 step 2.  否则报错, 因为进程请求超出了其声明的最大值<br>2.  如果 Requesti £ Available, 转 step 3.  否则 Pi  必须等待, 因为资源不可用.<br>3.  假设通过修改下列状态来分配请求的资源给进程Pi :<br>  Available :&#x3D; Available - Requesti;<br>  Allocationi :&#x3D; Allocationi + Requesti;<br>  Needi :&#x3D; Needi – Requesti;;<br> <br>•如果系统安全 Þ 将资源分配给 Pi.<br>•如果系统不安全 Þ Pi 必须等待，恢复原有的资源分配状态</p>
<h3 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h3><p><code>每个资源类型有一个实例</code>：维护进程等待图<br><code>每个资源类型有多个实例</code>：用available和finished数组探查是否死锁<br>允许进入死锁状态并加以恢复<br>维护等待图<br>节点是进程<br>Pi-&gt;Pj表明Pi在等待Pj<br>定期调用算法来检查是否有环<br>一个检查图中是否有环的算法需要n^2的操作来进行，n为图中的节点数<br>Available ：一个长度为m的向量，表示每一种资源类型可用的实例数目<br>Allocation:  一个n x m 的矩阵，定义了当前分配的每一种资源类型的实例数目<br>Request: 一个n x m 的矩阵，表明了当前的进程请求。如果Request[i，j]&#x3D;k，那么进程Pi请求k个资源Rj的实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  让Work和Finish作为长度为m和n的向量初始化</span><br><span class="line">(a) Work = Available</span><br><span class="line">(b)  For i = 0,2, …, n-1, if Allocationi ¹ 0, thenFinish[i] = false;otherwise, Finish[i] = true.</span><br><span class="line"></span><br><span class="line">2.  找到满足下列条件的下标i</span><br><span class="line">(a)  Finish[i] = false</span><br><span class="line">(b)  Requesti &lt;= Work</span><br><span class="line">如果没有这样的i存在，转4</span><br><span class="line"></span><br><span class="line">3.  Work = Work + Allocationi  </span><br><span class="line">Finish[i] = true  </span><br><span class="line">转 2.</span><br><span class="line"></span><br><span class="line">4.如果有一些i (0 £ i &lt; n) , Finish[i] = false, 则系统处在死锁状态。而且， 如果 Finish[i] = false, 则进程 Pi 是死锁的。</span><br></pre></td></tr></table></figure>

<p>&#96;算法需要m x n^2 次操作来判断是否系统处于死锁状态</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>可以一次中断所有进程排查，也可以一个一个终结进程<br>选择牺牲进程：最小化代价<br>回滚：返回到安全的状态，然后重新开始进程<br>饥饿：同样进程的可能总是被选中。在代价因素中加入回滚次数</p>
<h2 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h2><p><code>局部性原理</code>：在一较短的时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域<br>一个程序只要部分装入内存就可以运行<br>整个程序不是同一时间都要运行<br>&#96;程序部分装入技术优点<br>进程大小不再受到物理内存大小限制<br>每个进程需要的内存更小<br>更多进程可以并发运行<br>I&#x2F;O更少</p>
<ul>
<li>虚拟存储技术：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存执行。</li>
<li>虚拟地址空间：分配给进程的虚拟内存</li>
<li>虚拟地址：在虚拟内存中指令或数据的位置</li>
<li>虚拟内存：把内存和磁盘有机结合起来使用，得到一个容量很大的“内存”，即虚存<br><code>特点 只有部分运行的程序需要在内存中 逻辑地址空间能够比物理地址空间大 允许多个进程享同一地址空间 允许更有效的进程创建 </code>虚拟内存能够通过以下手段来执行实现:<br>虚拟页式（虚拟存储技术+页式存储管理）<br>虚拟段式（虚拟存储技术+段式存储管理）<br>&#96;虚拟页式有两种方式<br>按需调页（ Demand paging ）<br>预调页（Prepaging）</li>
</ul>
<h2 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h2><p><code>基本思想 进程开始运行之前，不是装入全部页面，而是装入一个或零个页面 运行之后，根据进程运行需要，动态装入其他页面 当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面 </code>请求分页（按需调页）<br>只有在一个页需要的时候才把它换入内存<br>需要很少的I&#x2F;O<br>需要很少的内存<br>快速响应<br>多用户<br><code>懒惰交换</code>:只有在需要页时，才将它调入内存<br>交换程序(swapper)对整个进程进行操作<br>调页程序(pager)只是对进程的单个页进行操作</p>
<h3 id="有效无效位"><a href="#有效无效位" class="headerlink" title="有效无效位"></a>有效无效位</h3><p>每一个页表的表项有一个有效- 无效位相关联：<br>1表示在内存，0表示不在内存<br>在所有的表项中，这个位被初始化为0<br>一个页表映象的例子</p>
<h3 id="缺页中断的处理"><a href="#缺页中断的处理" class="headerlink" title="缺页中断的处理"></a>缺页中断的处理</h3><p>1.访问指令或数据<br>2.查看另一个表来决定:<br>无效引用 Þ 终止<br>仅仅不在内存<br>3.找到页在后备存储上的位置<br>4.得到空的页框，把页换入页框<br>5.重新设置页表，把有效位设为v<br>6.重启指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">极端情况：进程执行第一行代码时，内存内没有任何代码和数据</span><br><span class="line">进程创建时，没有为进程分配内存，仅建立PCB</span><br><span class="line">导致缺页中断</span><br><span class="line">纯请求分页（纯粹按需调页）</span><br><span class="line"></span><br><span class="line">一条指令可能导致多次缺页（涉及多个页面）</span><br><span class="line">幸运的是，程序具有局部性（locality of reference）</span><br><span class="line"></span><br><span class="line">请求调页需要硬件支持</span><br><span class="line">带有效无效位的页表</span><br><span class="line">交换空间</span><br><span class="line">指令重启</span><br><span class="line"></span><br><span class="line">缺页率（缺页的概率）：0 &lt;= p &lt;= 1.0</span><br><span class="line">如果 p = 0 ，没有缺页</span><br><span class="line">如果 p = 1， 每次访问都缺页</span><br><span class="line"></span><br><span class="line">有效访问时间（ EAT ）</span><br><span class="line">    EAT = (1 – p) x 内存访问时间+ p x 页错误时间</span><br><span class="line"></span><br><span class="line">页错误时间=处理缺页中断</span><br><span class="line">  + [页交换出去时间 ]</span><br><span class="line">  + 读入页时间</span><br><span class="line">  + 重启进程开销</span><br></pre></td></tr></table></figure>

<p><code>性能优化</code>：<br>页面转换时采用交换空间，而不是文件系统<br>交换区的块大，比文件系统服务快速</p>
<p>在进程装载时，把整个进程拷贝到交换区<br>基于交换区调页<br>早期的 BSD Unix</p>
<p>利用文件系统进行交换<br>Solaris和当前的BSD<br>部分内容仍旧需要交换区（堆栈等）<br><code>写时复制</code>:允许父进程和子进程在初始化时共享页面<br>如果其中一个进程修改了一个共享页面，会产生副本<br>更加高效<br>应用在Windows，Linux，macOS等系统</p>
<h3 id="需要页置换的情况"><a href="#需要页置换的情况" class="headerlink" title="需要页置换的情况"></a>需要页置换的情况</h3><p>页置换—找到内存中当前没有使用的一些页，换出<br>同一个页可能会被装入内存多次<br>基本页置换方法</p>
<ol>
<li>查找所需页在磁盘上的位置</li>
<li>查找一空闲帧<br>如果有空闲帧，就使用它<br>如果没有空闲帧，使用页置换算法选择一个“牺牲”页框<br>将“牺牲”帧的内容写到磁盘上，更新页表和帧表</li>
<li>将所需页读入（新）空闲帧，更新页表和帧表</li>
<li>重启用户进程</li>
</ol>
<p>如果发生页置换，则缺页处理时间加倍<br>使用修改位modify bit或脏 (dirty bit) 来防止页面转移过多—只有被修改的页面才写入磁盘<br>页置换完善了逻辑内存和物理内存的划分—在一个较小的物理内存基础之上可以提供一个大的虚拟内存</p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="先进先出-FIFO-算法"><a href="#先进先出-FIFO-算法" class="headerlink" title="先进先出(FIFO)算法"></a>先进先出(FIFO)算法</h3><p>置换在内存中驻留时间最长的页面<br>容易理解和实现、但性能不总是很好<br>实现：使用FIFO队列管理内存中的所有页<br>FIFO算法可能会产生Belady异常<br>更多的页框 &#x3D;&gt;更多的缺页</p>
<h3 id="最优置换算法OPT"><a href="#最优置换算法OPT" class="headerlink" title="最优置换算法OPT"></a>最优置换算法OPT</h3><p>被置换的页是将来不再需要的或最远的将来才会被使用的页<br>实现？<br>作用：作为一种标准来衡量其它算法的性能</p>
<h3 id="最近最少使用算法-LRU"><a href="#最近最少使用算法-LRU" class="headerlink" title="最近最少使用算法(LRU)"></a>最近最少使用算法(LRU)</h3><p>置换最长时间没有使用的页<br>性能接近OPT<br>实现：计数器（时间戳）或栈<br>开销大、需要硬件支持<br>栈实现—在一个双链表中保留一个记录页数目的栈:<br>被访问的页:<br>移到栈顶<br>需要改变6个指针<br>没有为置换进行查找</p>
<p>在没有硬件支持的系统中，可使用LRU近似算法访问位<br>每个页都与一个位相关联，初始值为0<br>当页访问时设位1</p>
<ul>
<li>附加引用位算法</li>
<li>二次机会算法</li>
<li>增强型二次机会算法</li>
</ul>
<h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>需要访问位<br>如果访问位为0，直接置换<br>如果将要交换的页访问位是1，则:<br>把访问位设位0<br>把页留在内存中<br>以同样的规则，替换下一个页</p>
<p>实现：时钟置换（顺时针方式）</p>
<h3 id="基于计数的页面置换"><a href="#基于计数的页面置换" class="headerlink" title="基于计数的页面置换"></a>基于计数的页面置换</h3><p>用一个计数器记录对每一个页的访问次数<br>LFU 以最小的计数置换一个页</p>
<h3 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h3><ol>
<li>总是保留一个空闲帧缓冲池</li>
</ol>
<ul>
<li>在缺页错误时有帧可用</li>
<li>读页面到空闲帧，无需等待写出牺牲帧</li>
<li>牺牲帧以后被写出后，添加到缓冲池</li>
</ul>
<ol start="2">
<li>扩展之一，维护一个修改页面的列表</li>
</ol>
<ul>
<li>当设备空闲时选择一个修改页面写到磁盘上，然后重置它的修改位</li>
</ul>
<ol start="3">
<li></li>
<li>另一种修改,保留一个空闲帧池，并且记着哪些页面在哪些帧内</li>
</ol>
<ul>
<li>如果在重用之前被再次需要，就不需要从磁盘上重新装载了</li>
<li>降低因错误选择牺牲页面而引起的开销</li>
</ul>
<h2 id="帧分配"><a href="#帧分配" class="headerlink" title="帧分配"></a>帧分配</h2><p>两种主要分配策略</p>
<ul>
<li>固定分配</li>
<li>优先分配</li>
</ul>
<h3 id="固定分配"><a href="#固定分配" class="headerlink" title="固定分配"></a>固定分配</h3><p>平均分配 Equal allocation– 例如，如果有100帧和5个进程，给每个进程20帧<br>在缓冲池里保存空闲帧<br>比例分配 Proportional allocation – 根据进程大小分配内存<br>按照多道程度而动态分配，进程分得的数量变化</p>
<h3 id="优先级分配"><a href="#优先级分配" class="headerlink" title="优先级分配"></a>优先级分配</h3><p>优先级分配:用优先级而不是大小来进行比例分配<br>如果进程 Pi 跑出页面错误,<br>从自己的帧里选择一个替代<br>从优先级较低的进程里选择一个替代</p>
<h3 id="全局-vs-局部分配"><a href="#全局-vs-局部分配" class="headerlink" title="全局 vs. 局部分配"></a>全局 vs. 局部分配</h3><p>全局置换 Global replacement – 允许进程从所有帧的集合中选择一个置换帧；一个进程可以从另一个进程那里获取帧<br>但是进程执行时间可能变化很大，不能控制缺页错误率<br>有更好的系统吞吐量，更常用<br>局部置换 Local replacement – 每个进程只从它自己分配的帧中进行选择<br>对每个进程的表现更一致<br>但是可能内存低利用</p>
<h4 id="非均匀内存访问（NUMA）"><a href="#非均匀内存访问（NUMA）" class="headerlink" title="非均匀内存访问（NUMA）"></a>非均匀内存访问（NUMA）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v以上假设所有内存可以被平等访问</span><br><span class="line"></span><br><span class="line">v很多系统如 NUMA – 内存访问速度变化的</span><br><span class="line"></span><br><span class="line">考虑CPU和内存在系统中通过总线互连</span><br><span class="line"></span><br><span class="line">v让分配的内存帧‘尽可能地靠近’运行进程的CPU</span><br><span class="line"></span><br><span class="line">通常意味着位于同一系统扳</span><br><span class="line"></span><br><span class="line">Solaris通过在内核中创建延迟组 lgroups</span><br><span class="line"></span><br><span class="line">v将相近的CPU和内存聚集在一起</span><br><span class="line"></span><br><span class="line">v在组内调度进程的所有线程，并分配它的所有内存</span><br><span class="line"></span><br><span class="line">v最大限度减少总体内存延迟，最大化CPU缓存命中率</span><br></pre></td></tr></table></figure>

<h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><p>如果一个进程没有足够的页，那么缺页率将很高，这将导致:<br>CPU利用率低下.<br>操作系统认为需要增加多道程序的道数<br>系统中将加入一个新的进程<br>颠簸（抖动）&#x3D;一个进程的页面经常换入换出<br>原因：分配的帧数 &lt; 局部大小之和</p>
<h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>工作集窗口 º 固定数目的页的引用<br>WSSi (进程Pi的工作集) &#x3D; 最近D中所有页的引用 (随时间变化)<br><img src="/images/obsidian/20230605190700.png" alt="图片" title="image"><br>vExample: D &#x3D; 10,000</p>
<p>每5000个时钟单位时钟中断</p>
<p>为每个页在内存中保留两个位</p>
<p>任何时候一个时钟中断拷贝，把所有访问位设为0</p>
<p>如果一个在内存中的位是0，说明页在工作集</p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>通过映射一个磁盘块成内存的一页，内存映象文件I&#x2F;O 允许文件I&#x2F;O 作为普通内存访问。<br>开始的文件访问按普通请求分页来进行，一页大小的部分文件从文件系统读入物理页。以后文件的读、写操作就按通常的内存访问来处理。<br>由于通过内存的文件操作而不是使用系统调用read() write() ，简化了文件访问和使用。<br>多个进程可以允许将同一文件映射到各自的虚拟内存中，以允许数据共享</p>
<h2 id="内核内存分配"><a href="#内核内存分配" class="headerlink" title="内核内存分配"></a>内核内存分配</h2><p>通常从空闲内存池中获取<br>内核需要为不同大小的数据结构分配内存<br>一些内核内存需要连续的物理页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v内核在使用内存块时有如下特点：</span><br><span class="line"></span><br><span class="line">    (1)内存块的尺寸比较小；</span><br><span class="line"></span><br><span class="line">    (2)占用内存块的时间比较短；</span><br><span class="line"></span><br><span class="line">    (3)要求快速完成分配和回收；</span><br><span class="line"></span><br><span class="line">    (4)不参与交换。</span><br><span class="line"></span><br><span class="line">    (5)频繁使用尺寸相同的内存块，存放同一结构的数据；</span><br><span class="line"></span><br><span class="line">    (6)要求动态分配和回收。</span><br></pre></td></tr></table></figure>
<h3 id="伙伴-Buddy-系统"><a href="#伙伴-Buddy-系统" class="headerlink" title="伙伴(Buddy)系统"></a>伙伴(Buddy)系统</h3><p>v主要用于Linux早期版本中内核底层内存管理<br>v一种经典的内存分配方案<br>v从物理上连续的大小固定的段上分配内存<br>v主要思想：内存按2的幂的大小进行划分，即4KB、8KB等，组成若干空闲块链表；查找链表找到满足进程需求的最佳匹配块<br>满足要求是以2的幂为单位的<br>如果请求不为2的幂，则需要调整到下一个更大的2的幂<br>当分配需求小于现在可用内存时，当前段就分为两个更小的2的幂段，继续上述操作直到合适的段大小<br>&#96;算法<br>首先将整个可用空间看作一块: 2^n<br>假设进程申请的空间大小为s，如果满足<br>2^(n-1)&lt;s&lt;&#x3D;2^n，则分配整个块<br>   否则，将块划分为两个大小相等的伙伴，大小为2^(n-1)<br>一直划分下去直到产生大于或等于s的最小块</p>
<h3 id="Slab-分配"><a href="#Slab-分配" class="headerlink" title="Slab 分配"></a>Slab 分配</h3><p>v内核分配的另一方案<br>vSlab 是由一个或多个物理上连续的页组成<br>vCache 含有一个或多个 slab<br>v每个内核数据结构都有一个cache<br>每个 cache 含有内核数据结构的对象实例</p>
<p>v当创建 cache 时, 包括若干个标记为空闲的对象<br>v当内核对象时，从cache上直接获取，并标识对象为使用<br>v当一个slab充满了已使用的对象时，下一个对象的分配从空的slab开始分配<br>如果没有空的slab, 则从物理连续页上分配新的slab<br>v优点<br>①没有因碎片而引起的内存浪费</p>
<p>②内存请求可以快速满足</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p><code>预调页面 v在进程启动初期，减少大量的缺页中断 v在引用前，调入进程的所有或一些需要的页面 v如果预调入的页面没有被使用，则内存被浪费 </code>页面尺寸大小<br>v碎片 – 需要小的页<br>v表大小 – 需要大的页<br>vI&#x2F;O 开销 – 需要大的页<br>v程序局部 – 需要小的页<br>v缺页次数 – 需要大的页<br>v其他因素<br>没有最佳答案，总的来说，趋向更大的页<br><code>TLB 范围 vTLB 范围 – 通过TLB所访问的内存量 vTLB 范围 = (TLB 大小) X (页大小) v理想情况下，一个进程的工作集应存放在 TLB中 否则会有大量的缺页中断 v增加页的大小 对于不需要大页的应用程序而言，这将导致碎片的增加 v提供多种页的大小 这允许需要大页的应用程序有机会使用大页而不增加碎片的大小 </code>倒置页表<br>v倒置页表降低了保存的物理内存<br>v不再包括进程逻辑地址空间的完整信息<br>v为了提供这种信息，进程必须保留一个外部页表<br>v外部页表可根据需要换进或换出内存<br>&#96;I&#x2F;O 联锁与页面锁定<br>v允许某些页在内存中被锁住</p>
<p>vI&#x2F;O时，正在进行I&#x2F;O的页面不允许被置换算法置换出内存<br><code>linux vSLAB vDemand paging vGlobal page replacement(LRU) v两个帧列：active_list和inactive_list vKswapd daemon 定期检查 </code>windows10<br>vBoth IA-32 and x86-64<br>v32bit支持4GB，64bit支持128TB内存<br>vShared memory, demand paging, copy-on-write, paging和memory compression<br>v按需调页-clustering，预调入3-7页<br>vWorking-Set 管理（最少50-最多345页）</p>
<h2 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h2><p><code>文件 计算机中信息存储的基本组织形式 相关信息结合 具有文件名 </code>文件名<br>按名存取：文件名     存储位置<br>文件名由一串ASCII码或(和)汉字构成<br>名字长度<br>v8.3规则：文件名8个字符，类型3个字符，之间有“.”分割<br>v长文件名：可以最多输入255多个字符作为文件名<br>文件名可能大小写敏感<br><code>文件的打开 v需要数据结构 打开文件表：跟踪打开文件 文件指针:指向最后一次读写的位置，每个进程1个 打开文件计数器：打开文件次数（调用open次数） 文件存储位置：文件存放在存储设备上的位置信息 访问权限：每个进程的访问权限 v优点 方便文件共享 提高文件存取效率 </code>文件锁<br>共享锁 Shared lock 类似于读者锁– 多个进程可以并发获取它。<br>独占锁 Exclusive lock 类似于写者锁<br>&#96;文件结构<br>v目的：便于程序理解文件内容<br>无结构：文字流、字节流等<br>简单记录结构：线性、固定长度、可变长度等<br>复杂结构：格式化文档、多媒体文件等<br>v谁决定了文件结构<br>操作系统<br>程序</p>
<h2 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h2><h3 id="逻辑文件"><a href="#逻辑文件" class="headerlink" title="逻辑文件"></a>逻辑文件</h3><p>v文件呈现在用户面前的组织结构<br>v又称为文件逻辑结构<br>v逻辑文件决定了文件访问方法<br>&#96;文件访问方式</p>
<ul>
<li>顺序访问<br>最简单的访问方式<br>文件信息按照存放顺序，一个记录一个记录地依次访问<br>顺序文件<br>典型存储设备：磁带</li>
<li>直接（随机）访问<br>可以直接定位到文件的某条记录进行访问<br>直接文件<br>典型设备：磁盘<br>v访问方式：直接（随机）访问<br>v直接通过计算得到需要读写记录的位置，直接跳转进行文件读写</li>
<li>索引文件<br>v基本方法：为顺序文件建立索引表<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">记录平均长度：40B   索引表项大小：4B   1M条记录长度：44MB</span><br><span class="line"></span><br><span class="line">访问第1万条记录：</span><br><span class="line"></span><br><span class="line">       1）计算得到第1万条记录的索引项在索引表中首址：10000*4=40000</span><br><span class="line"></span><br><span class="line">       2）从索引表地址40000处读入4个字节，内容为第1万条记录在顺序文件中的首址P</span><br><span class="line"></span><br><span class="line">       3）从顺序文件地址P处读入40个字节（假如第1万条记录长度为40B）</span><br><span class="line"></span><br><span class="line">合计读入：4+40=44B</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="文件控制块（FCB）"><a href="#文件控制块（FCB）" class="headerlink" title="文件控制块（FCB）"></a>文件控制块（FCB）</h3><p>存放操控文件所需的各类文件属性信息<br>文件名<br>长度<br>创建时间<br>存放位置<br>访问控制权限<br>类似一个索引项<br>v目录项<br>存放一个文件的各类属性<br>有的系统等同于文件控制块<br>v目录<br>包含着所有文件信息的节点集合<br>根据文件名检索文件的桥梁<br>目录项的有序集合<br>v目录文件<br>目录组织形式<br>目录作为一个文件存在于文件系统<br>v每个目录项中存放了文件在存储设备的存放地址<br>v目录和文件都驻留在存储设备（如磁盘）</p>
<h3 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h3><p>v文件检索是一个遍历目录项的过程<br>1.打开目录文件<br>2.从磁盘读入该目录文件的1个(物理)块，该块包含若干个目录项<br>3.根据文件名遍历内存中的该块，如找到则结束<br>4.判断该目录文件是否还有物理块没有读入，如果是转2；否则，结束。表示该目录中没有此文件名的文件<br>v目录项由于经常变化，一般不排序<br>v平均遍历目录项数：       （1+n）&#x2F;2<br>  不包括文件查不到的情况<br>  <br>  目录项大小&#x3D; ds bytes<br>目录中最多文件数 &#x3D; n<br>物理块大小 &#x3D; b<br>v那么<br>目录文件大小 &#x3D; ds*n bytes<br>目录文件需要的物理块数目 &#x3D; ds*n&#x2F;b<br>检索一个文件需要平均读入的块数&#x3D;(ds*n&#x2F;b+1)&#x2F;2</p>
<h3 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h3><p><code>设计目标 v效率 快速定位文件位置 提高文件访问效率 v命名 方便用户使用 同名的不同文件 不同名的相同文件 v分组 文件分组（子目录） 兼顾效率和方便性 </code>单层目录<br>v所有文件在同一目录中，只有一级目录：根目录<br>v根目录（&#x2F;）：一个文件系统最顶层的目录<br>v优点：结构简单<br>v缺点<br>检索效率差（目录下文件过多）<br>不能有同名文件，一个文件只能有一个名称<br>不能分组<br><code>双层目录 v每个用户有自己的目录结构 v目录下的目录 v缺点：1）无法分组；2）同一用户不能有相同文件名的文件 v优点：1）不同用户可有相同文件名的文件；2）比单层目录提高检索效率（文件分布在多个用户目录中） </code>树形目录<br>v特点<br>检索高效（子目录增多导致每个目录下文件减少）<br>可以分组<br>允许重名<br>v当前目录：工作目录<br>cd &#x2F;spell&#x2F;mail&#x2F;prog<br>type list<br>v绝对路径<br>从根开始的路径名<br>v相对路径<br>从当前目录开始的路径名<br>提高检索效率<br><code>（有向）无环图目录 v文件共享：不同目录中的文件指向同一个物理文件，也就是它们内容相同 v树型目录不能实现文件共享 v解决方法：图型目录 无环图目录 通用图目录（有环图） v无环图：有向边无环 </code>如何保证无环？<br>仅允许指向文件的链接，不允许指向子目录的链接<br>垃圾回收<br>每当加入新链接时，使用环路检测算法判断是否正确<br>优化遍历目录算法，避免对环的重复搜索</p>
<h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><p>v要访问一个文件系统，必须先安装它。<br>一个未安装的文件系统将被安装在一个安装点(mount point)上。</p>
<h3 id="远程文件系统"><a href="#远程文件系统" class="headerlink" title="远程文件系统"></a>远程文件系统</h3><p>v用网络使得远程计算机之间的联系成为可能<br>手动传输文件如 FTP<br>自动，直接访问文件用分布文件系统 distributed file systems<br>半自动用万维网 world wide web<br>vClient-server 客户机-服务器模型允许客户机登录远程服务器的文件系统<br>服务器可以服务多台客户机<br>识别客户可能是不安全和复杂的<br>NFS 是标准 UNIX 下客户机-服务器的文件共享协议<br>CIFS 是Windows下标准协议<br>标准操作系统文件调用翻译为远程调用<br>v分布式信息系统 (分布式命名服务 distributed naming services) 如LDAP, DNS, NIS。</p>
<h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>v所有文件系统都有故障模式<br>例如目录结构或者其他磁盘管理信息（元数据 metadata 损坏。<br>v远程文件系统加入新的故障模式，来自网络故障或者服务器故障<br>v从故障中恢复包含维护状态信息 state information<br>vStateless 无状态协议如NFC在每个请求里包含所有信息，允许较为容易的故障恢复但是不够安全</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>v规定系统的多个用户如何访问共享文件<br>类似于第六章的进程同步算法<br>v由于磁盘和网络的巨大延迟和很慢的传输速率，倾向于没这么复杂<br>Andrew File System (AFS) 实现了复杂共享语义<br>Unix file system (UFS) 使用:<br>v一个用户对已打开文件的写入，对于打开同一文件的其他用户立即可见。<br>v一种共享模式允许用户共享文件的当前位置指针。<br>AFS 有会话语义<br>v一旦文件关闭，对其所作的更改只能被后来打开的会话可见。</p>
<h3 id="访问控制权限和分组"><a href="#访问控制权限和分组" class="headerlink" title="访问控制权限和分组"></a>访问控制权限和分组</h3><p>v访问模式：读&#x2F;写&#x2F;执行<br>v三种类型的用户<br>  RWX<br>  a) 所有者  7  &#x3D;&gt;1 1 1    RWX<br>  b) 组用户  6  &#x3D;&gt;  1 1 0    RWX<br>  c) 公共用户  1  &#x3D;&gt;  0 0 1<br>v建立一个组，加入一些用户<br>v对特定的文件或目录(game) ，定义适当的访问权限</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>hate</title>
    <url>/2023/09/28/%E7%A7%98%E5%AF%861/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="b880b7d31b2b49c2d1e177670d81885ee25e5fa92eb9653e5cb1ab63ed299a20">5c9f2c161c18225a1213c4fb8eed69605f71b5e706a2596abb349b07a2d0e59d06cd1da79a833bfa6f93404c48a998620110bfb9a1ca59188af69a5ea757606d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好，这里需要密码。</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>秘密</category>
      </categories>
      <tags>
        <tag>秘密</tag>
      </tags>
  </entry>
</search>
