<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>thinklive的迪瑞克拉图书馆</title>
    <url>/2023/09/17/thinklive%E7%9A%84%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E5%9B%BE%E4%B9%A6%E9%A6%86/</url>
    <content><![CDATA[<video src="/images/thinklive.mp4" autoplay>
</video>
<h1 id="欢迎来到迪瑞克拉">欢迎来到迪瑞克拉</h1>
<p>这里是thinklive的个人博客，不定时地会发一些个人技术学习心得和生活体会</p>
<p>使用左侧的分类来定位内容</p>
<p><a href="/2023/10/05/建站指北">建站指北</a></p>
<h2 id="迪瑞克拉的由来">迪瑞克拉的由来</h2>
<p><code>狄利克雷函数</code>（英语：<code>dirichlet function</code>）是一个定义在实数范围上、值域不连续的函数。<code>狄利克雷函数</code>的图像以Y轴为对称轴，是一个偶函数，它处处不连续，处处极限不存在，不可黎曼积分。这是一个处处不连续的可测函数。</p>
<p>在我看来它象征着混沌，不可知与无限的可能性，<code>狄利克雷</code>换一种方式音译就成了迪瑞克拉</p>
<h2 id="更新日志">更新日志</h2>
<span id="more"></span>
<p>2023/9/17 迪瑞克拉博客的生日，当天增加了背景音乐，搜索，相册，标签，目录，置顶等基础功能</p>
<p>2023/9/18 新增了评论，预估阅读时间，字数统计，网站访问统计,加载进度条功能,将背景音乐的歌曲改为歌单,为了方便使用，菜单切换成了中英双语</p>
<p>2023/9/19 新增了多级分类的特性，让返回顶部的进步条已读百分比，页面底部能看到阅读进度条了，新增了代码块复制功能，现在可以通过书签功能自动储存阅读进度，使退出后重进仍是当初的进度，也可以手动点击右上角书签图标实现相同效果,新增了彩带背景，并把背景色改成黑色</p>
<p>2023/9/20 替换一些页面ui文本，为一些页面ui文本加入了颜文字</p>
<p>2023/9/26 在guestbook和首页嵌入了好友做的一个赛博朋克logo视频</p>
<p>2023/9/27 开启了一些next的小功能，侧边栏加了一个thinklive的赛博朋克logo</p>
<p>2023/9/28 新增了加密页面，由秘密这个目录名检索，密码不会向任何人透露，部分页面会有提示</p>
<p>2023/9/29 新增了资源地图菜单，点击会跳转到使用不同主题的子站，可以通过子站的侧边栏回到主页</p>
<p>2023/9/30 给子站加了看板娘，主站加了鼠标轨迹，子站加了鼠标轨迹和点击烟花特效，看板娘有截屏，提示等功能，但是主站不会加，毕竟主站定位比较严肃嘛,顺便加了个小彩蛋，离开页面一秒后就能看到</p>
<p>2023/10/1 修了一下标签页彩蛋的bug，新增了线条特效，鼠标不动时会慢慢聚集起来,由于next层级的原因，主站只有背景会生效，改起来很麻烦，正好对主站来说也有点太花哨了，就只在子站用吧 主站加了个小游戏页面，左上角回到主站，只能玩一把是故意的，避免一直摸鱼，绝对不是懒得写</p>
<p>2023/10/2 新增了神龛子站，用来放一些文学创作之类的玩意，更新随缘，主要是赛博朋克风挺好看的想整一个,返回主站会开新标签页是因为，伊卡洛斯这个主题没有不开新标签页的api，所以将就一下吧</p>
<p>2023/10/7 新增了点开源的threejs网页端特效小游戏</p>
<p>2023/10/19 现在首页的文章按更新时间排序了</p>
<p>2023/10/25 添加了基于pandoc的lateX公式支持，主要用于写算法的笔记</p>
<p>2023/11/20 更换了一下子站和资源站的logo图片</p>
<p>2023/11/22 新增了一个字符版bad apple，以及一个开源的思维导图页面</p>
<p>2023/11/25 升级了hexo到最新版本，代价是由于没备份配置文件重新做了一下配置，但相应的增加了一些功能，比如代码块折叠，还有改变了字数统计算法（缩水了一半，草）</p>
<p>2023/11/27 添加rss订阅 ，在左侧的社交栏,以及分享功能</p>
]]></content>
  </entry>
  <entry>
    <title>考研笔记——操作系统部分</title>
    <url>/2023/12/03/%E8%80%83%E7%A0%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="概论">概论</h1>
<p><code>操作系统</code>：控制管理计算机的硬件，协调控制资源分配，并为应用程序和用户提供接口以供使用</p>
<h2 id="基本特征">基本特征</h2>
<p><code>操作系统</code>的基本特征包括并发，共享，虚拟和异步</p>
<ol type="1">
<li><p>并发<br />
<code>并发</code>是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。这是通过类似时间片轮转的机制实现的。<br />
<code>并行性</code>是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的动作<code>并行性</code>要有相关硬件的支持, 如多流水线或多处理机硬件环境</p></li>
<li><p>共享<br />
<code>共享</code>：系统内的某些资源可以供并发的不同进程使用，分为以下几种方式<br />
<span id="more"></span></p>
<ol type="1">
<li>互斥共享 规定在一段时间内只充许 一个进程访问该资源，系统分配该资源前，必须确保没有其他进程正在使用它，分配后，在进程访问并释放该资源后，其他进程对资源的申请才会被操作系统允许。<br />
这种一段时间内只能被一个进程占有的资源被称为<code>临界资源</code><br />
大部分硬件，某些软件的栈，变量等都属于<code>临界资源</code><br />
</li>
<li>同时访问 某些系统资源可以在同一时间段内被多个进程同时访问，例如文件系统，这种同时访问可能是交替进行。<br />
互斥共享要求一种资源在一段时间内（哪怕是一段很小的时间）只能满足一个请求，同时访问通常要求一个请求可以分时间片间隔地完成，效果和连续完成相同</li>
</ol></li>
</ol>
<p>并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件：</p>
<ul>
<li>资源共享是以程序的并发为条件的：若系统不充许程序并发执行，则自然不存在资源共享问题<br />
</li>
<li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，其至根本无法并发执行。</li>
</ul>
<ol start="3" type="1">
<li><p>虚拟<br />
<code>虚拟</code>是指把一个物理上的实体变为若干逻辑上的对应物。<br />
虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一 个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务<br />
把一个物理cpu虚拟成多个虚拟cpu,称为虚拟处理器<br />
虚拟技术可以在时间或者空间上进行相应的现实虚拟转换</p></li>
<li><p>异步<br />
虽然进程可以并发进行，但推进速度，时间等是不确定的，操作系统必须确保，相同环境下相同操作的进程得到相同的结果，不论时间多久</p></li>
</ol>
<h2 id="功能">功能</h2>
<ol type="1">
<li>管理系统资源
<ol type="1">
<li>处理机（进程）的管理，包括创建，调度，死锁检测和恢复等</li>
<li>存储器管理，即内存的分配和管理</li>
<li>文件管理，即操作系统的文件系统空间，目录，格式等</li>
<li>设备管理，处理用户的I/O请求</li>
</ol></li>
<li>提供用户接口操作硬件和程序
<ol type="1">
<li>命令接口
<ol type="1">
<li>联机命令接口（交互式命令接口，适用于实时或分时系统）：用户通过终端实时输入命令与操作系统交换，输入一条，操作系统解释并执行一条，然后才可以输入下一条(shell)</li>
<li>脱机命令接口（批处理命令接口,适用于批处理系统）：用作业控制命令写成一本作业说明书，操作系统读取说明书，逐条解释执行 (脚本)</li>
</ol></li>
<li>程序接口：有一系列系统调用组成，，用户在程序中使用这些系统调用命令来让操作系统提供相应服务，例如GUI界面(严格的说gui界面只是使用了操作系统提供的图形相关的系统调用)</li>
</ol></li>
<li>实现了对计算机资源的扩充</li>
</ol>
<h2 id="历史">历史</h2>
<ol type="1">
<li>手工操作阶段<br />
缺点：1，cpu利用不充分。2，计算机资源利用率低下</li>
<li>批处理阶段
<ol type="1">
<li>单道批处理系统：操作系统一次只执行一个程序，依次处理，特征：
<ol type="1">
<li>自动性，磁带上的作业可以自动依次进行</li>
<li>顺序性，作业有明确顺序依次进入内存</li>
<li>单道性，内存中只有一个程序运行，任务完成或异常后才调入下一个 问题：任务间隔等待下一个调入时，I/O效率低下<br />
</li>
</ol></li>
<li>多道批处理程序，内存中可以有多个程序共享系统资源，交替运行，避免I/O期间的算力浪费，特点是：
<ol type="1">
<li>多道，内存存放多道程序</li>
<li>宏观上并行，内存中的程序都处于运行状态</li>
<li>微观上串行，程序交替使用cpu</li>
</ol></li>
</ol></li>
</ol>
<p>问题：处理器资源，内存资源和I/O的分配，以及如何组织处理大量的程序和数据 在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的 作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。</p>
<ul>
<li>优点：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用：系统吞吐量大，CPU和其他资源保持“忙碌”状态。</li>
<li>缺点：用户响应的时间较长：不提供人机交互能力， 用户既不能了解自已的程序的运行情况，又不能控制计算机。</li>
</ul>
<ol start="3" type="1">
<li><p>分时操作系统 所谓分时技术，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行， 把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己已独占一台计算机。<br />
分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰，同时有较快的交互速度<br />
特性：</p>
<ol type="1">
<li>同时性，允许多个用户同时使用一台计算机（多终端）</li>
<li>交互性</li>
<li>独立性，各个用户相对独立，不会互相影响</li>
<li>及时性，对用户请求用较快的速度回应</li>
</ol></li>
<li><p>实时操作系统 一些特殊场合（比如飞行器系统），对操作的时限有硬性要求（或者软性要求），这样的操作系统叫做实时操作系统<br />
其中绝对无法违反时限的是硬实时系统，偶尔可以违反的是软实时系统<br />
特点：</p></li>
</ol>
<ul>
<li>及时性</li>
<li>可靠性</li>
</ul>
<ol start="5" type="1">
<li><p>其他<br />
网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的 使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网 络中各种资源的共享及各台计算机之间的通信。<br />
分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过 通信方式交换信息：系统中的每台计算机都具有同等的地位，即没有主机也没有从机：每台计算 机上的资源为所有用户共享：系统中的任意台计算机都可以构成一个子系统，并且还能重构；任 何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的 操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网 络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。</p></li>
<li><p>个人计算机操作系统<br />
个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有Windows、Linux和Macintosh等。</p></li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231204211804.png" /></p>
<h2 id="运行环境">运行环境</h2>
<p>cpu一般执行两种程序，一种是操作系统内核程序，另一种是用户程序，因此对cpu指令需要做区分</p>
<ul>
<li>特权指令，是指不允许用户直接使用的指令，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</li>
<li>非特权指令，是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅 限子访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。 在具体实现上，将CPU的运行模式划分为用户态（目态）和核心态 （又称管态，内核态）</li>
</ul>
<h3 id="内核机制">内核机制</h3>
<ol type="1">
<li>时钟管理，提供计时功能，是时间片轮转，实时系统的截止时间等功能的基础</li>
<li>中断机制，操作系统的大部分功能都依赖中断，可以说现代操作系统是中断驱动的，中断机制只有一小部分属于内核，负责保护和恢复现场等</li>
<li>原语，操作系统的底层小程序，有以下特点
<ol type="1">
<li>最底层，最接/近硬件</li>
<li>操作有原子性，不可分割</li>
<li>运行时间短调用频繁</li>
</ol></li>
<li>系统控制的数据结构和处理,常见操作有
<ol type="1">
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ol></li>
</ol>
<h3 id="中断和异常">中断和异常</h3>
<p>由于用户态的某些操作需要核心态的一些功能，需要中断和异常机制，来让cpu从用户态进入核心态（这通过硬件实现，比如一个特殊寄存器）<br />
<code>中断</code>（Interruption）也称外中断，是指来自CPU执行指令外部的事件，通常用于信息输入/ 输出，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成。时钟中断，表示一个固定 的时间片已到，让处理机处理计时、启动定时运行的任务等<br />
<code>异常</code>（Exception）也称内中断，是指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺负及专门的陷入指令等引起的事件。异常不能被屏蔽，一出现，就应立即处理。<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231204215335.png" /> 二者的分类如图，其中故障（Fault）通常是由指令执行引起的异常，如非法操作码， 缺页故障、除数为0、运算溢出等。自陷（Trap）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序。终止（Abort）是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。故障异常和自陷异常属于软件中断（程序性异常，终止异常和外部中断属于硬件中断。</p>
<p>中断处理流程：操作系统发现中断请求或者异常后，打断当前程序，调转到中断或者异常的处理程序，如果程序能解决问题，就再次回到现场继续执行，如果是致命错误，则终止程序</p>
<h3 id="系统调用">系统调用</h3>
<p>一般涉及对系统资源的请求，都需要系统调用，系统调用可以视为一种特殊的公共子程序 常见类型：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能</li>
</ul>
<p>用户程序可以执行陷入指令（又称访管指令或trap指令）来发起系统调用，此时相当于cpu使用权被交给内核，来让cpu进入核心态执行特权指令，最后结果和cpu返还给程序 当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序：也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行 <img src="/assets/苏大linux_ppt/Pasted%20image%2020231204220927.png" /></p>
<p>执行系统调用的过程如下：正在运行的进程先传递系统调用参数，然后由陷入（trap）指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核态服务程序，最后返回用户态。</p>
<div class="note warning"><p>注意：</p>
<ul>
<li>由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的,此外，这个转变是硬件完成的，核心态到用户态则是操作系统完成</li>
<li>(访管指令在用户态使用，因此不是特权指令)</li>
<li>输入输出这种涉及到中断机制的指令，必须在核心态执行</li>
<li>命令解释这种与用户交互的程序在用户态执行，而进程调度则需要核心态(单个用户不应能影响进程这样的全局状态，否则就可以只让自己的进程优先执行)</li>
<li>一般来说，中断处理除了保留现场，还需要用一个寄存器存储程序的状态字</li>
<li>外部中断时，通用寄存器由操作系统保存，PC(程序计数器)则由中断指令自动保存</li>
<li>时钟中断后，服务程序应当更新内核中时钟变量的值,当前进程占用CPU的时间,当前进程在时间片内的剩余执行时间等全部时钟相关的数据</li>
<li>操作系统通过提供系统调用避免用户程序直接访问外设</li>
<li>当CPU检测到中断信号后，由硬件自动保存被中断程序的断点（即程序计数器PC），之后，硬件找到该中断信号对应的中断向量，中断向量指明中断服务程序入口地址（各中断向量保存PSW、保存中断屏蔽字、保存各通用寄存器的值，并提供与中断信号对应的中断服务，中断服务程序属于操作系统内核</li>
<li>能在内核态下执行。常见的特权指令有：
<ul>
<li>有关对IO设备操作的指令</li>
<li>有关访问程序状态的指令</li>
<li>存取特殊寄存器的指令</li>
</ul></li>
<li>通道技术和中断技术结合起来就可实现CPU与I/O设备并行工作，即CPU启动通道传输数据后便进行其他程序的计算工作，而通道则进行输入输出操作；通道工作结束后，通过中断让cpu进行处理，处理完再各自进行对应的工作</li>
</ul>
</div>
<h2 id="结构">结构</h2>
<ol type="1">
<li>分层法<br />
最底层为硬件，最高层为用户接口，每个高层只能调用它向下单层的功能和服务<br />
优点：
<ol type="1">
<li>便于调试和验证，由于每层都相对独立，可以隔绝问题，在单层定位问题</li>
<li>易于扩充维护，只要确保层间接口不便，就可以随意修改单层内的模块</li>
</ol></li>
</ol>
<p>问题：1，难于定义各层。2，由于有时需要跨多层调用，额外开销较大，效率较低</p>
<ol start="2" type="1">
<li>模块化 将操作系统定义成各种有自己接口的模块，各模块通过接口进行组合和通信 <img src="/assets/苏大linux_ppt/Pasted%20image%2020231205144922.png" /> 这样的结构需要保证模块之间的独立性，即：</li>
</ol>
<ul>
<li>内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。</li>
<li>耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。 模块化的优点：①提高了操作系统设计的正确性、可理解性和可维护性：②增强了操作系统 的可适应性：③加速了操作系统的开发过程。 模块化的缺点：①模块间的接口规定很难满足对接口的实际需求。②各模块设计者齐头并进 每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。</li>
</ul>
<ol start="3" type="1">
<li><p>宏内核<br />
宏内核，指将系统的主要功能模块作为整体运行在核心态，从而为用户程序提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。<br />
主流操作系统都使用了宏内核，但事实上也在逐渐引进微内核技术，成为一种混合结构</p></li>
<li><p>微内核<br />
微内核构架，是指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。 一般可以分为两个部分：</p></li>
</ol>
<ul>
<li>微内核,实现操作系统最基本核心功能的小型内核
<ul>
<li>与硬件紧密相关的功能</li>
<li>基本功能</li>
<li>客户和服务器的通信</li>
</ul></li>
<li>多个服务器</li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231205151119.png" /> 为了实现高可靠性，只有微内核运行在内核态，其余模块都运行在用户态，一个模块的错误不会影响整个系统<br />
微内核的功能：</p>
<ul>
<li>进程（线程）管理：进程的通信，切换，调度，多处理器的同步等都应该放入微内核，但进程分类，优先级确定等不涉及机制的功能可以放入进程管理服务器</li>
<li>低级存储器管理：比如页表机制和地址变换机制，而虚拟存储器的管理，页面置换算法等则有存储器管理服务器管理</li>
<li>中断和陷入处理，捕获相关事件，进行中断响应处理，然后发送给相关服务器来处理</li>
</ul>
<p>优点：</p>
<ul>
<li>拓展性和灵活性</li>
<li>可靠性和安全性</li>
<li>可移植性（和硬件有关的都在微内核中，其他服务器和硬件无关）</li>
<li>分布式计算，通信采用消息传递机制，很好的支持分布式系统和网络系统</li>
</ul>
<p>微内核结构的主要问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作 系统的执行开销偏大。</p>
<ol start="5" type="1">
<li>外核<br />
不同于虚拟机克隆真实机器，另一种策略是对机器进行分区，给每个用户整个资源的一个子集。在底层中，一种称为外核（exokernel）的程序在内核态中运行。它的任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机有自己的操作系统，但资源是受限制的<br />
外核机制的优点是减少了映射层。在其他的设计中，每个虚拟机都认为它有自己的磁盘，这样虚拟机监控程序就必须维护一张表格以重映像磁盘地址，有外核就不需要维护这个表格了，并且实现了各个虚拟机之间的安全划分，没有冲突</li>
</ol>
<h2 id="引导">引导</h2>
<p>操作系统引导是指计算机利用CPU运行定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统一环扣一一环地完成上述过程。</p>
<ol type="1">
<li>激活CPU。激活的CPU读取ROM中的boot程序，将指令寄存器置为BIOS（基本输入/输出系统）的第一条指令，即开始执行BIOS的指令。</li>
<li>硬件自检。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止：如果没有故障，屏幕会显示CPU、内存、硬盘等信息。</li>
<li>加载带有操作系统的硬盘。硬件自检后，BIOS开始读取BootSequence（通过CMOS里保存的启动顺序，或者通过与用户交互的方式），把控制权交给启动顺序排在第一位的存储设备，然后CPU将该存储设备引导扇区的内容加载到内存中。</li>
<li>加载主引导记录MBR。硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统。</li>
<li>扫描硬盘分区表，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。</li>
<li>加载分区引导记录PBR。读取活动分区的第一个扇区，这个扇区称为分区引导记录（PBR），其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）</li>
<li>加载启动管理器。分区引导记录搜索活动分区中的启动管理器，加载启动管理器</li>
<li>加裁操作系统</li>
</ol>
<h2 id="虚拟机">虚拟机</h2>
<p>虚拟机是一台逻辑计算机，是指利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。有两类虚拟化方法。<br />
1. 唯一运行在最高特权的程序，它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机、这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。</p>
<div class="note info"><p>虚拟机作为用户态的一个进程运行，不充许执行敏感指令。然而，虚拟机上的操作系统认为自已运行在内核态（实际上不是），称为虚拟内核态。虚拟机中的用户进程认为自已运行在用户态（实际上确实是）。当虚拟机操作系统执行了一条CPU处于内核态才充许执行的指令时，会陷入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。</p>
</div>
<ol start="2" type="1">
<li>类似一个依赖宿主机的普通进程，操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）。客户操作系统安装完成后，就能启动并运行。 此时，虚拟机管理程序伪装成一台计算机（比如vmware）</li>
</ol>
<p>有的教材将第一类虚拟化技术称为裸金属架构，将第二类虚拟化技术称为寄居架构</p>
<hr />
<h1 id="进程和线程">进程和线程</h1>
<div class="note info">
</div>
]]></content>
      <categories>
        <category>考研笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>考研笔记——数据结构部分</title>
    <url>/2023/11/29/%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="序论">序论</h1>
<h2 id="数据">数据</h2>
<ul>
<li><code>数据</code>：信息的载体，在计算机中是符号的集合</li>
<li><code>数据元素</code>：数据的基本单位，一个整体，有一些不可分割的数据项组成，例如一个学生档案</li>
<li><code>数据对象</code>：有相同性质的数据元素集合，是数据的子集</li>
<li><code>数据类型</code>：数据值的类型，和对这个类型特定操作的集合</li>
<li><code>数据结构</code>：相互之间存在特殊关系的数据元素的集合，这种特殊关系就是所谓的结构。</li>
</ul>
<p>数据结构包括三个方面</p>
<ul>
<li><code>逻辑结构</code>（数据的逻辑关系，和怎么存储在计算机中无关） <img src="/assets/苏大linux_ppt/Pasted%20image%2020231129144215.png" /></li>
<li><code>存储结构</code>（数据在计算机中的表示）
<ul>
<li><code>顺序存储</code>：元素存储在相邻的地址间，不需要额外索引，可以随机读写，但容易产生外部碎片</li>
<li><code>链式存储</code>：每个元素不仅存储值，还存储指向下一个元素的指针，不会产生碎片，但占用空间较大</li>
<li><code>索引存储</code>：建立一个外部索引表，，利用索引表对数据进行读写，需要额外空间和对索引表增删的消耗</li>
<li><code>散列存储</code>：对每个元素用一个哈希函数计算其存储的地址，需要恰当的哈希函数</li>
</ul></li>
<li><code>数据的运算</code></li>
</ul>
<p><code>ADT</code>(抽象数据类型)构成一个完整的数据结构定义</p>
<span id="more"></span>
<h2 id="算法">算法</h2>
<p>算法是对指定输入的一系列指令 特性：</p>
<ul>
<li><code>有穷性</code>，执行时间和指令次数有穷</li>
<li><code>确定性</code>，指令有确定的含义，相同输入输出一定相同</li>
<li><code>可行性</code>，指令都是以及明确实现有定义的</li>
<li><code>输入</code>：有零个或者多个输入</li>
<li><code>输出</code>：有一个或以上的输出</li>
</ul>
<p>需要实现的目标：正确，可读，健壮（对于非法数据，也输出可控），效率</p>
<p><code>复杂度</code>：略</p>
<h1 id="线性表">线性表</h1>
<p><code>定义</code>：有相同数据类型的n个数据元素的有限序列,元素直接存在前后关系，且只能线性前后排列,其中的元素都是数据元素，类型相同 <code>类别</code>：逻辑结构，而非顺序表链表等存储结构 <code>基本操作</code>：</p>
<ul>
<li>初始化</li>
<li>按值查找</li>
<li>按位查找</li>
<li>删除元素</li>
<li>输出(print)</li>
<li>求表长</li>
<li>销毁</li>
<li>判空</li>
</ul>
<h2 id="顺序表">顺序表</h2>
<p><code>定义</code>:线性表的顺序存储是顺序表，用连续的地址存储表内元素，让逻辑顺序和物理顺序相同 <img src="/assets/苏大linux_ppt/Pasted%20image%2020231130102600.png" /> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50     <span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType* data[Maxsize]; <span class="comment">//顺序表的元素</span></span><br><span class="line">	<span class="type">int</span> Maxsize,length;      <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;        <span class="comment">//顺序表的类型定义</span></span><br><span class="line">L.data=<span class="keyword">new</span> ElemType[InitSize]; <span class="comment">//动态分配</span></span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>插入操作</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(sqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) &#123;<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(L.length &gt;= Maxsize) &#123;</span><br><span class="line">    <span class="comment">//当前存储空间已满,不能插入  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--) &#123;</span><br><span class="line">    <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">    L.data[j] = L.data[j<span class="number">-1</span>]; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.data[i<span class="number">-1</span>] = e; <span class="comment">//在位置i处放入e</span></span><br><span class="line"></span><br><span class="line">  L.length++; <span class="comment">//线性表长度加1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均时间分析：</p>
<p><span class="math inline">\(\sum_{i=1}^{n+1}p_{i}(n-i+1)=\sum_{i=1}^{n+1}{\frac{1}{n+1}}(n-i+1)={\frac{1}{n+1}}\sum_{i=1}^{n+1}(n-i+1)={\frac{1}{n+1}}{\frac{n(n+1)}{2}}={\frac{n}{2}}\)</span></p>
<ol start="2" type="1">
<li>删除操作</li>
</ol>
<p>平均时间分析：</p>
<p><span class="math inline">\(\sum_{i=1}^{n}p_{i}(n-i)=\sum_{i=1}^{n}{\frac{1}{n}}(n-i)={\frac{1}{n}}\sum_{i=1}^{n}(n-i)={\frac{1}{n}}{\frac{n(n-1)}{2}}={\frac{n-1}{2}}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.+<span class="number">34</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e = L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;L.length; j++) &#123;</span><br><span class="line">    <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">    L.data[j<span class="number">-1</span>] = L.data[j];  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>按值查找</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;L.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>/L.data[i] == e) &#123;</span><br><span class="line">    ;/[<span class="string">&#x27;return i+1; //下标为i的元素值等于e,返回其位序i+1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return 0; //退出循环,说明查找失败</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>平均情况：假设pi是（pi=1/n）是查找的元素在第i（1&lt;=i&lt;=L.length）个位置上的概率，</p>
<p><span class="math inline">\(\sum_{i=1}^{n}p_{i}\times i=\sum_{i=1}^{n}{\frac{1}{n}}\times i={\frac{1}{n}}{\frac{n(n+1)}{2}}={\frac{n+1}{2}}\)</span></p>
<div class="note info"><p>Q:线性表的顺序存储结构是一种（）。 A随机存取的存储结构 B顺序存取的存储结构 C索引存取的存储结构 D 散列存取的存储结构</p>
<p>A: (A)此处的顺序存取指的是只能线性遍历的数据结构，而顺序表可以随机存取</p>
<p>Q:若长度为n的非空线性表采用顺序存储结构，在表的第i个位置插入一个数据元素，则 的合法值应该是（）。 A.1&lt;=i&lt;=n B.1≤i≤n+ 1 C.0≤i&lt;=n-1 D.0≤i≤n</p>
<p>A: (B)顺序表的索引从1开始</p>
<p>Q:写一个时间O(n),空间O(1)的删除表内一个值的算法 A: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(SqList&amp; L, ElemType x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>;<span class="comment">//k记录值等于x的元素个数</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt; L.length) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L.data[i] == x) &#123;</span><br><span class="line">      k++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      L.data[i-k] = L.data[i];<span class="comment">//当前元素前移k个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.length = L.length - k;<span class="comment">//顺序表长度递减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div>
<div class="note warning"><p>本书中的时间复杂度默认指渐进时间复杂度，即n默认趋近正无穷，而不是常数</p>
</div>
<h2 id="链式表示">链式表示</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNodef</span> &#123; <span class="comment">//定义单链表结点类型</span></span><br><span class="line">	ElemType data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next; <span class="comment">//指针域</span></span><br><span class="line">&#125; ILNode,*LinkList;</span><br><span class="line"><span class="comment">//node是一个节点，Linklist是它的指针（即数组）</span></span><br></pre></td></tr></table></figure>
<p>一般会用一个<code>头结点</code>指向单链表，<code>头结点</code>的数据没有意义，空链表时指针是一个空指针</p>
<p><code>头指针</code>指向单链表的第一个节点，对有头指针的链表就是指向<code>头结点</code></p>
<p><code>头结点</code>的`优点：</p>
<ol type="1">
<li>所有数据节点都可以用相同的办法处理</li>
<li>由于有<code>头节点</code>，<code>头指针</code>不会是一个空指针，空表和非空表也可以统一处理</li>
</ol>
<h3 id="基本操作">基本操作</h3>
<ol type="1">
<li>头插法建立单链表,该方法把新节点一个个插入到头结点后</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Linklist <span class="title">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span></span>&#123;</span><br><span class="line">	LNode* s;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化为空链表</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">	    s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">	    s-&gt;data = x;</span><br><span class="line">	    s-&gt;next = L-&gt;next;</span><br><span class="line">	    L-&gt;next = s;<span class="comment">//将新结点插入表中,L为头指针</span></span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>尾插法建立单链表，与头插法相反</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">ListTailInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">  LNode* s, *r = L;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  <span class="keyword">while</span>(x != <span class="number">9999</span>) &#123;</span><br><span class="line">    s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    r-&gt;next = s;</span><br><span class="line">    r = s; <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//尾结点指针置空</span></span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考研笔记</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>对加州房地产数据集的数据分析</title>
    <url>/2023/12/03/myproj3/</url>
    <content><![CDATA[<h1 id="加利福尼亚房价数据集">加利福尼亚房价数据集</h1>
<h2 id="内容">内容</h2>
<p>这些数据涉及在加州某个地区的街区以及基于 1990 年人口普查数据的一些汇总统计数据：</p>
<ol type="1">
<li>房屋中位价值：一个街区内家庭的房屋中位价值（以美元计算）</li>
<li>收入中位数：一栋房屋内的家庭收入中位数（以万美元衡量）</li>
<li>中位年龄：街区内房屋的中位年龄； 数字较小的是较新的建筑</li>
<li>房间总数：一个街区内的房间总数</li>
<li>卧室总数：一个街区内的卧室总数</li>
<li>人口：居住在一个街区内的总人数</li>
<li>家庭：一个街区的家庭总数</li>
<li>纬度：衡量房屋向北有多远的指标； 值越高越北 [°]</li>
<li>经度：衡量房屋向西有多远的量度； 数值越高，越西 [°]</li>
<li>距离海岸：到最近海岸点的距离[m]</li>
<li>到洛杉矶的距离：到洛杉矶市中心的距离[m]</li>
<li>到圣地亚哥的距离：到圣地亚哥中心的距离[m]</li>
<li>到圣何塞的距离: 到圣何塞中心的距离 [m]</li>
<li>到旧金山的距离：到旧金山市中心的距离[m] <span id="more"></span></li>
</ol>
<ol type="1">
<li>Median House Value: Median house value for households within a block (measured in US Dollars)</li>
<li>Median Income: Median income for households within a block of houses (measured in tens of thousands of US Dollars)</li>
<li>Median Age: Median age of a house within a block; a lower number is a newer building [years]</li>
<li>Total Rooms: Total number of rooms within a block</li>
<li>Total Bedrooms: Total number of bedrooms within a block</li>
<li>Population: Total number of people residing within a block</li>
<li>Households: Total number of households, a group of people residing within a home unit, for a block</li>
<li>Latitude: A measure of how far north a house is; a higher value is farther north [°]</li>
<li>Longitude: A measure of how far west a house is; a higher value is farther west [°]</li>
<li>Distance to coast: Distance to the nearest coast point [m]</li>
<li>Distance to Los Angeles: Distance to the centre of Los Angeles [m]</li>
<li>Distance to San Diego: Distance to the centre of San Diego [m]</li>
<li>Distance to San Jose: Distance to the centre of San Jose [m]</li>
<li>Distance to San Francisco: Distance to the centre of San Francisco [m]</li>
</ol>
<h2 id="导入python库">导入python库</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#引入python库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data = pd.read_csv(<span class="string">&#x27;California_Houses.csv&#x27;</span>)</span><br><span class="line">training_data.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Median_House_Value
</th>
<th>
Median_Income
</th>
<th>
Median_Age
</th>
<th>
Tot_Rooms
</th>
<th>
Tot_Bedrooms
</th>
<th>
Population
</th>
<th>
Households
</th>
<th>
Latitude
</th>
<th>
Longitude
</th>
<th>
Distance_to_coast
</th>
<th>
Distance_to_LA
</th>
<th>
Distance_to_SanDiego
</th>
<th>
Distance_to_SanJose
</th>
<th>
Distance_to_SanFrancisco
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
452600.0
</td>
<td>
8.3252
</td>
<td>
41
</td>
<td>
880
</td>
<td>
129
</td>
<td>
322
</td>
<td>
126
</td>
<td>
37.88
</td>
<td>
-122.23
</td>
<td>
9263.040773
</td>
<td>
556529.158342
</td>
<td>
735501.806984
</td>
<td>
67432.517001
</td>
<td>
21250.213767
</td>
</tr>
<tr>
<th>
1
</th>
<td>
358500.0
</td>
<td>
8.3014
</td>
<td>
21
</td>
<td>
7099
</td>
<td>
1106
</td>
<td>
2401
</td>
<td>
1138
</td>
<td>
37.86
</td>
<td>
-122.22
</td>
<td>
10225.733072
</td>
<td>
554279.850069
</td>
<td>
733236.884360
</td>
<td>
65049.908574
</td>
<td>
20880.600400
</td>
</tr>
<tr>
<th>
2
</th>
<td>
352100.0
</td>
<td>
7.2574
</td>
<td>
52
</td>
<td>
1467
</td>
<td>
190
</td>
<td>
496
</td>
<td>
177
</td>
<td>
37.85
</td>
<td>
-122.24
</td>
<td>
8259.085109
</td>
<td>
554610.717069
</td>
<td>
733525.682937
</td>
<td>
64867.289833
</td>
<td>
18811.487450
</td>
</tr>
<tr>
<th>
3
</th>
<td>
341300.0
</td>
<td>
5.6431
</td>
<td>
52
</td>
<td>
1274
</td>
<td>
235
</td>
<td>
558
</td>
<td>
219
</td>
<td>
37.85
</td>
<td>
-122.25
</td>
<td>
7768.086571
</td>
<td>
555194.266086
</td>
<td>
734095.290744
</td>
<td>
65287.138412
</td>
<td>
18031.047568
</td>
</tr>
<tr>
<th>
4
</th>
<td>
342200.0
</td>
<td>
3.8462
</td>
<td>
52
</td>
<td>
1627
</td>
<td>
280
</td>
<td>
565
</td>
<td>
259
</td>
<td>
37.85
</td>
<td>
-122.25
</td>
<td>
7768.086571
</td>
<td>
555194.266086
</td>
<td>
734095.290744
</td>
<td>
65287.138412
</td>
<td>
18031.047568
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data.columns.values</span><br></pre></td></tr></table></figure>
<pre><code>array([&#39;Median_House_Value&#39;, &#39;Median_Income&#39;, &#39;Median_Age&#39;, &#39;Tot_Rooms&#39;,
       &#39;Tot_Bedrooms&#39;, &#39;Population&#39;, &#39;Households&#39;, &#39;Latitude&#39;,
       &#39;Longitude&#39;, &#39;Distance_to_coast&#39;, &#39;Distance_to_LA&#39;,
       &#39;Distance_to_SanDiego&#39;, &#39;Distance_to_SanJose&#39;,
       &#39;Distance_to_SanFrancisco&#39;], dtype=object)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data.describe()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Median_House_Value
</th>
<th>
Median_Income
</th>
<th>
Median_Age
</th>
<th>
Tot_Rooms
</th>
<th>
Tot_Bedrooms
</th>
<th>
Population
</th>
<th>
Households
</th>
<th>
Latitude
</th>
<th>
Longitude
</th>
<th>
Distance_to_coast
</th>
<th>
Distance_to_LA
</th>
<th>
Distance_to_SanDiego
</th>
<th>
Distance_to_SanJose
</th>
<th>
Distance_to_SanFrancisco
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
2.064000e+04
</td>
<td>
2.064000e+04
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
206855.816909
</td>
<td>
3.870671
</td>
<td>
28.639486
</td>
<td>
2635.763081
</td>
<td>
537.898014
</td>
<td>
1425.476744
</td>
<td>
499.539680
</td>
<td>
35.631861
</td>
<td>
-119.569704
</td>
<td>
40509.264883
</td>
<td>
2.694220e+05
</td>
<td>
3.981649e+05
</td>
<td>
349187.551219
</td>
<td>
386688.422291
</td>
</tr>
<tr>
<th>
std
</th>
<td>
115395.615874
</td>
<td>
1.899822
</td>
<td>
12.585558
</td>
<td>
2181.615252
</td>
<td>
421.247906
</td>
<td>
1132.462122
</td>
<td>
382.329753
</td>
<td>
2.135952
</td>
<td>
2.003532
</td>
<td>
49140.039160
</td>
<td>
2.477324e+05
</td>
<td>
2.894006e+05
</td>
<td>
217149.875026
</td>
<td>
250122.192316
</td>
</tr>
<tr>
<th>
min
</th>
<td>
14999.000000
</td>
<td>
0.499900
</td>
<td>
1.000000
</td>
<td>
2.000000
</td>
<td>
1.000000
</td>
<td>
3.000000
</td>
<td>
1.000000
</td>
<td>
32.540000
</td>
<td>
-124.350000
</td>
<td>
120.676447
</td>
<td>
4.205891e+02
</td>
<td>
4.849180e+02
</td>
<td>
569.448118
</td>
<td>
456.141313
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
119600.000000
</td>
<td>
2.563400
</td>
<td>
18.000000
</td>
<td>
1447.750000
</td>
<td>
295.000000
</td>
<td>
787.000000
</td>
<td>
280.000000
</td>
<td>
33.930000
</td>
<td>
-121.800000
</td>
<td>
9079.756762
</td>
<td>
3.211125e+04
</td>
<td>
1.594264e+05
</td>
<td>
113119.928682
</td>
<td>
117395.477505
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
179700.000000
</td>
<td>
3.534800
</td>
<td>
29.000000
</td>
<td>
2127.000000
</td>
<td>
435.000000
</td>
<td>
1166.000000
</td>
<td>
409.000000
</td>
<td>
34.260000
</td>
<td>
-118.490000
</td>
<td>
20522.019101
</td>
<td>
1.736675e+05
</td>
<td>
2.147398e+05
</td>
<td>
459758.877000
</td>
<td>
526546.661701
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
264725.000000
</td>
<td>
4.743250
</td>
<td>
37.000000
</td>
<td>
3148.000000
</td>
<td>
647.000000
</td>
<td>
1725.000000
</td>
<td>
605.000000
</td>
<td>
37.710000
</td>
<td>
-118.010000
</td>
<td>
49830.414479
</td>
<td>
5.271562e+05
</td>
<td>
7.057954e+05
</td>
<td>
516946.490963
</td>
<td>
584552.007907
</td>
</tr>
<tr>
<th>
max
</th>
<td>
500001.000000
</td>
<td>
15.000100
</td>
<td>
52.000000
</td>
<td>
39320.000000
</td>
<td>
6445.000000
</td>
<td>
35682.000000
</td>
<td>
6082.000000
</td>
<td>
41.950000
</td>
<td>
-114.310000
</td>
<td>
333804.686371
</td>
<td>
1.018260e+06
</td>
<td>
1.196919e+06
</td>
<td>
836762.678210
</td>
<td>
903627.663298
</td>
</tr>
</tbody>
</table>
</div>
<h2 id="封装函数">封装函数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绘制分布图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_distribution</span>(<span class="params">data, label</span>):</span><br><span class="line">    fig, axs = plt.subplots(nrows=<span class="number">2</span>)</span><br><span class="line">    sns.histplot(</span><br><span class="line">        data[label], </span><br><span class="line">        ax=axs[<span class="number">0</span>]</span><br><span class="line">    )</span><br><span class="line">    sns.boxplot(</span><br><span class="line">        x=data[label],</span><br><span class="line">        ax=axs[<span class="number">1</span>],</span><br><span class="line">        showfliers=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    spacer = np.<span class="built_in">max</span>(data[label]) * <span class="number">0.05</span></span><br><span class="line">    xmin = np.<span class="built_in">min</span>(data[label]) - spacer</span><br><span class="line">    xmax = np.<span class="built_in">max</span>(data[label]) + spacer</span><br><span class="line">    axs[<span class="number">0</span>].set_xlim((xmin, xmax))</span><br><span class="line">    axs[<span class="number">1</span>].set_xlim((xmin, xmax))</span><br><span class="line"></span><br><span class="line">    plt.subplots_adjust(hspace=<span class="number">0</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&quot;Distribution of &quot;</span> + label)</span><br><span class="line"><span class="comment">#数据清洗函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_outliers</span>(<span class="params">data, variable, lower=-np.inf, upper=np.inf</span>):</span><br><span class="line">    df = data.copy()</span><br><span class="line">    df = df[df[variable] &gt; lower]</span><br><span class="line">    df = df[df[variable] &lt; upper]</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"><span class="comment">#对数化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_transform</span>(<span class="params">data, col</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Add the log transformation of a column to the data frame&quot;&quot;&quot;</span></span><br><span class="line">    data[<span class="string">&#x27;Log &#x27;</span> + col] = np.log(data[col])</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="comment">#画出根据一列聚合的另一列的平均值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_mean_lineplot</span>(<span class="params">dis,val,df=training_data,thisbins=<span class="number">200</span></span>):</span><br><span class="line">    categories = pd.cut(df[dis], bins=thisbins)</span><br><span class="line">    mids = [c.mid <span class="keyword">for</span> c <span class="keyword">in</span> categories]  </span><br><span class="line">    df[<span class="string">&#x27;distance_bin&#x27;</span>] = mids</span><br><span class="line">    mean_price = df.groupby(<span class="string">&#x27;distance_bin&#x27;</span>)[val].mean()</span><br><span class="line">    newdf=pd.DataFrame()</span><br><span class="line">    newdf[<span class="string">&#x27;mean_price&#x27;</span>]=mean_price</span><br><span class="line">    newdf[<span class="string">&#x27;distance_bin&#x27;</span>]=mean_price.index</span><br><span class="line">    sns.lineplot(x=<span class="string">&#x27;distance_bin&#x27;</span>,y=<span class="string">&#x27;mean_price&#x27;</span>,data=newdf)</span><br><span class="line">    plt.title(<span class="string">&quot;mean house price with the same &quot;</span>+dis)</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="comment">#划分训练集和验证集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_val_split</span>(<span class="params">data, train_pct=<span class="number">0.8</span></span>):</span><br><span class="line">    data_len = data.shape[<span class="number">0</span>]</span><br><span class="line">    shuffled_indices = np.random.permutation(data_len)</span><br><span class="line">    </span><br><span class="line">    split_index = <span class="built_in">int</span>(<span class="number">0.8</span> * data_len)</span><br><span class="line">    train_indices = shuffled_indices[:split_index]</span><br><span class="line">    val_indices = shuffled_indices[split_index:]</span><br><span class="line">    </span><br><span class="line">    train = data.iloc[train_indices]</span><br><span class="line">    validation = data.iloc[val_indices]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train, validation</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据过滤">数据过滤</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#观察数据分布</span></span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Age&#x27;</span>);</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Income&#x27;</span>);</span><br></pre></td></tr></table></figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):</code></pre>
<figure>
<img src="/assets/myproj3/output_9_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_9_2.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_9_3.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看到收入和售价数据的右侧末端比较不合理，应该过滤</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Median_Income&#x27;</span>,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Median_House_Value&#x27;</span>,<span class="number">0</span>,<span class="number">400000</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Distance_to_coast&#x27;</span>,<span class="number">0</span>,<span class="number">70000</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Households&#x27;</span>,<span class="number">0</span>,<span class="number">1500</span>)</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Age&#x27;</span>);</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Income&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_11_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_11_2.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_11_3.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data.describe()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Median_House_Value
</th>
<th>
Median_Income
</th>
<th>
Median_Age
</th>
<th>
Tot_Rooms
</th>
<th>
Tot_Bedrooms
</th>
<th>
Population
</th>
<th>
Households
</th>
<th>
Latitude
</th>
<th>
Longitude
</th>
<th>
Distance_to_coast
</th>
<th>
Distance_to_LA
</th>
<th>
Distance_to_SanDiego
</th>
<th>
Distance_to_SanJose
</th>
<th>
Distance_to_SanFrancisco
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
1.465100e+04
</td>
<td>
1.465100e+04
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
199561.517917
</td>
<td>
3.696580
</td>
<td>
29.953996
</td>
<td>
2356.678657
</td>
<td>
496.034742
</td>
<td>
1367.255341
</td>
<td>
468.929561
</td>
<td>
35.372597
</td>
<td>
-119.555017
</td>
<td>
21259.751408
</td>
<td>
2.490542e+05
</td>
<td>
3.721187e+05
</td>
<td>
359123.874456
</td>
<td>
397236.235539
</td>
</tr>
<tr>
<th>
std
</th>
<td>
79310.711796
</td>
<td>
1.419884
</td>
<td>
12.191439
</td>
<td>
1425.953928
</td>
<td>
287.919292
</td>
<td>
814.994880
</td>
<td>
266.065608
</td>
<td>
2.077014
</td>
<td>
2.063217
</td>
<td>
16562.862059
</td>
<td>
2.475190e+05
</td>
<td>
2.905277e+05
</td>
<td>
226985.441402
</td>
<td>
262135.238533
</td>
</tr>
<tr>
<th>
min
</th>
<td>
14999.000000
</td>
<td>
0.499900
</td>
<td>
1.000000
</td>
<td>
11.000000
</td>
<td>
3.000000
</td>
<td>
3.000000
</td>
<td>
3.000000
</td>
<td>
32.540000
</td>
<td>
-124.350000
</td>
<td>
120.676447
</td>
<td>
4.205891e+02
</td>
<td>
4.849180e+02
</td>
<td>
569.448118
</td>
<td>
456.141313
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
140600.000000
</td>
<td>
2.625000
</td>
<td>
20.000000
</td>
<td>
1410.000000
</td>
<td>
296.000000
</td>
<td>
816.000000
</td>
<td>
286.000000
</td>
<td>
33.880000
</td>
<td>
-121.890000
</td>
<td>
8077.199272
</td>
<td>
2.631262e+04
</td>
<td>
1.550810e+05
</td>
<td>
88700.495102
</td>
<td>
92070.783507
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
187500.000000
</td>
<td>
3.551100
</td>
<td>
31.000000
</td>
<td>
2053.000000
</td>
<td>
431.000000
</td>
<td>
1190.000000
</td>
<td>
412.000000
</td>
<td>
34.140000
</td>
<td>
-118.360000
</td>
<td>
17596.867293
</td>
<td>
1.385490e+05
</td>
<td>
1.872540e+05
</td>
<td>
484362.783196
</td>
<td>
552023.712780
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
252000.000000
</td>
<td>
4.625000
</td>
<td>
38.000000
</td>
<td>
2968.000000
</td>
<td>
631.000000
</td>
<td>
1725.000000
</td>
<td>
595.000000
</td>
<td>
37.690000
</td>
<td>
-117.980000
</td>
<td>
28063.195081
</td>
<td>
5.221622e+05
</td>
<td>
7.009827e+05
</td>
<td>
519935.107297
</td>
<td>
587792.558476
</td>
</tr>
<tr>
<th>
max
</th>
<td>
399400.000000
</td>
<td>
7.988700
</td>
<td>
52.000000
</td>
<td>
12837.000000
</td>
<td>
2219.000000
</td>
<td>
8733.000000
</td>
<td>
1499.000000
</td>
<td>
41.950000
</td>
<td>
-114.550000
</td>
<td>
69995.382339
</td>
<td>
1.018260e+06
</td>
<td>
1.196919e+06
</td>
<td>
836762.678210
</td>
<td>
903627.663298
</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数据分析寻找与房屋价格有线性关系的列">数据分析——寻找与房屋价格有线性关系的列</h2>
<h3 id="可视化房屋价格与距离远近的关系">可视化房屋价格与距离远近的关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">places=[<span class="string">&#x27;Distance_to_coast&#x27;</span>, <span class="string">&#x27;Distance_to_LA&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Distance_to_SanDiego&#x27;</span>, <span class="string">&#x27;Distance_to_SanJose&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Distance_to_SanFrancisco&#x27;</span>]</span><br><span class="line">training_data[places].describe()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Distance_to_coast
</th>
<th>
Distance_to_LA
</th>
<th>
Distance_to_SanDiego
</th>
<th>
Distance_to_SanJose
</th>
<th>
Distance_to_SanFrancisco
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
14651.000000
</td>
<td>
1.465100e+04
</td>
<td>
1.465100e+04
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
21259.751408
</td>
<td>
2.490542e+05
</td>
<td>
3.721187e+05
</td>
<td>
359123.874456
</td>
<td>
397236.235539
</td>
</tr>
<tr>
<th>
std
</th>
<td>
16562.862059
</td>
<td>
2.475190e+05
</td>
<td>
2.905277e+05
</td>
<td>
226985.441402
</td>
<td>
262135.238533
</td>
</tr>
<tr>
<th>
min
</th>
<td>
120.676447
</td>
<td>
4.205891e+02
</td>
<td>
4.849180e+02
</td>
<td>
569.448118
</td>
<td>
456.141313
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
8077.199272
</td>
<td>
2.631262e+04
</td>
<td>
1.550810e+05
</td>
<td>
88700.495102
</td>
<td>
92070.783507
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
17596.867293
</td>
<td>
1.385490e+05
</td>
<td>
1.872540e+05
</td>
<td>
484362.783196
</td>
<td>
552023.712780
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
28063.195081
</td>
<td>
5.221622e+05
</td>
<td>
7.009827e+05
</td>
<td>
519935.107297
</td>
<td>
587792.558476
</td>
</tr>
<tr>
<th>
max
</th>
<td>
69995.382339
</td>
<td>
1.018260e+06
</td>
<td>
1.196919e+06
</td>
<td>
836762.678210
</td>
<td>
903627.663298
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.jointplot(data = training_data, x = <span class="string">&quot;Distance_to_coast&quot;</span>, \</span><br><span class="line">              y = <span class="string">&quot;Median_House_Value&quot;</span>, \</span><br><span class="line">              kind = <span class="string">&quot;hex&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.suptitle allows us to shift the title up so it does not overlap with the histogram</span></span><br><span class="line">plt.suptitle(<span class="string">&quot;coast distance agginst value&quot;</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.9</span>);</span><br></pre></td></tr></table></figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_16_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看出距海岸线距离似乎与房价有关系</p>
<h3 id="用折线图表示平均房价与海岸线与城市距离关系">用折线图表示平均房价与海岸线与城市距离关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pla <span class="keyword">in</span> places:</span><br><span class="line">    draw_mean_lineplot(dis=pla,val=<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_19_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_19_3.png" alt="" /><figcaption>png</figcaption>
</figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_19_5.png" alt="" /><figcaption>png</figcaption>
</figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_19_7.png" alt="" /><figcaption>png</figcaption>
</figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_19_9.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>根据可视化发现，只有海岸线距离与房价有类似线性关系</p>
<h3 id="房屋数和卧室数与房价是否相关">房屋数和卧室数与房价是否相关</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Tot_Rooms&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">50</span>)</span><br><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Tot_Bedrooms&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_22_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_22_3.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看出单独两列和房价都无明显关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;bedroom_proportion&#x27;</span>] =training_data[<span class="string">&#x27;Tot_Bedrooms&#x27;</span>] / training_data[<span class="string">&#x27;Tot_Rooms&#x27;</span>]</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;bedroom_proportion&#x27;</span>,<span class="number">0</span>,<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">sns.lmplot(data = training_data, x = <span class="string">&quot;bedroom_proportion&quot;</span>, \</span><br><span class="line">           y = <span class="string">&quot;Median_House_Value&quot;</span>,x_bins=<span class="number">100</span>,x_ci=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&quot;proportion of bedroom against house value&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_24_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>两者比例和房价近似线性有关</p>
<h3 id="和房屋年龄关系">和房屋年龄关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Median_Age&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):</code></pre>
<figure>
<img src="/assets/myproj3/output_27_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看出和年龄没有明显关系</p>
<h3 id="和家庭平均人口数的关系">和家庭平均人口数的关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;people_house_proportion&#x27;</span>] =training_data[<span class="string">&#x27;Population&#x27;</span>] / training_data[<span class="string">&#x27;Households&#x27;</span>]</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;people_house_proportion&#x27;</span>,<span class="number">0</span>,<span class="number">3.5</span>)</span><br><span class="line">sns.lmplot(data = training_data, x = <span class="string">&quot;people_house_proportion&quot;</span>, \</span><br><span class="line">           y = <span class="string">&quot;Median_House_Value&quot;</span>,x_bins=<span class="number">50</span>,x_ci=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&quot;proportion of people in house against house value&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_30_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;people_house_proportion&#x27;</span>].describe()</span><br></pre></td></tr></table></figure>
<pre><code>count    9213.000000
mean        2.722022
std         0.422372
min         1.060606
25%         2.432647
50%         2.740845
75%         3.044444
max         3.499266
Name: people_house_proportion, dtype: float64</code></pre>
<p>可以看出和家庭平均人数有近似线性关系</p>
<h3 id="与中位数收入的关系">与中位数收入的关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.lmplot(data = training_data, x = <span class="string">&quot;Median_Income&quot;</span>, \</span><br><span class="line">           y = <span class="string">&quot;Median_House_Value&quot;</span>,x_bins=<span class="number">50</span>)</span><br><span class="line">plt.title(<span class="string">&quot;median income against house value&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_34_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看出和中位数收入线性有关</p>
<h3 id="验证相关性可视化">验证——相关性可视化</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correlation = training_data.corr()[<span class="string">&#x27;Median_House_Value&#x27;</span>].sort_values(ascending = <span class="literal">False</span>).to_frame()</span><br><span class="line">sns.heatmap(correlation, annot = <span class="literal">True</span>, cmap = <span class="string">&#x27;Blues&#x27;</span>, fmt = <span class="string">&#x27;.2f&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>&lt;Axes: &gt;</code></pre>
<figure>
<img src="/assets/myproj3/output_37_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<h2 id="建立模型">建立模型</h2>
<h3 id="拆分数据">拆分数据</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_m1, valid_m1 = train_val_split(training_data)</span><br><span class="line">train_m2, valid_m2 = train_val_split(training_data)</span><br><span class="line">features=[<span class="string">&#x27;Median_Income&#x27;</span>,<span class="string">&#x27;Distance_to_coast&#x27;</span>,<span class="string">&#x27;bedroom_proportion&#x27;</span>,<span class="string">&#x27;people_house_proportion&#x27;</span>]</span><br><span class="line"><span class="comment">#模型1</span></span><br><span class="line">X_train_m1 = train_m1[[<span class="string">&#x27;Median_Income&#x27;</span>]]</span><br><span class="line">y_train_m1 = train_m1[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line">X_valid_m1 = valid_m1[[<span class="string">&#x27;Median_Income&#x27;</span>]]</span><br><span class="line">y_valid_m1 = valid_m1[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line"><span class="comment">#模型2</span></span><br><span class="line">X_train_m2 = train_m2[features]</span><br><span class="line">y_train_m2 = train_m2[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line">X_valid_m2 = valid_m2[features]</span><br><span class="line">y_valid_m2 = valid_m2[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="建立线性模型">建立线性模型</h3>
<p><span class="math display">\[
\hat{y}_i = \theta_0 + \theta_1 x_i
\]</span></p>
<p>建立线性回归模型，并可视化预测值的分布与实际分布比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model <span class="keyword">as</span> lm</span><br><span class="line">linear_model_m1 = lm.LinearRegression()</span><br><span class="line">linear_model_m2 = lm.LinearRegression()</span><br><span class="line"><span class="comment"># Fit the 1st model</span></span><br><span class="line">linear_model_m1.fit(X_train_m1, y_train_m1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the fitted and predicted values for 1st model</span></span><br><span class="line">y_fitted_m1 = linear_model_m1.predict(X_train_m1)</span><br><span class="line">y_predicted_m1 = linear_model_m1.predict(X_valid_m1)</span><br><span class="line">predictions_series = pd.Series(y_predicted_m1[:,<span class="number">0</span>])</span><br><span class="line">predictions_df = predictions_series.to_frame()</span><br><span class="line">predictions_df=predictions_df.rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;house value&#x27;</span>&#125;)</span><br><span class="line">plot_distribution(predictions_df,<span class="string">&#x27;house value&#x27;</span>)</span><br><span class="line">plot_distribution(valid_m1,<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):</code></pre>
<figure>
<img src="/assets/myproj3/output_42_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_42_2.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m2.fit(X_train_m2, y_train_m2)</span><br><span class="line">y_fitted_m2 = linear_model_m2.predict(X_train_m2)</span><br><span class="line">y_predicted_m2 = linear_model_m2.predict(X_valid_m2)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m1.score(X_train_m1, y_train_m1)</span><br></pre></td></tr></table></figure>
<pre><code>0.4057888580747748</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m2.score(X_train_m2, y_train_m2)</span><br></pre></td></tr></table></figure>
<pre><code>0.5231028654608809</code></pre>
<p>可以看出使用更多特征列的模型二有更好的性能</p>
<h3 id="主成分分析pca">主成分分析（PCA）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">linear_model_m3 = lm.LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the 1st model</span></span><br><span class="line">train_m3, valid_m3 = train_val_split(training_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型3</span></span><br><span class="line">X_train_m3 = train_m3[features]</span><br><span class="line">y_train_m3 = train_m3[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line">X_valid_m3 = valid_m3[features]</span><br><span class="line">y_valid_m3 = valid_m3[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line"><span class="comment">#对特征数据进行奇异值分解</span></span><br><span class="line">pca = PCA(n_components=<span class="number">4</span>)</span><br><span class="line">pca.fit(X_train_m3)</span><br><span class="line">principal_components = pca.transform(X_train_m3)</span><br><span class="line"></span><br><span class="line">pca.fit(X_valid_m3)</span><br><span class="line">principal_components_valid = pca.transform(X_valid_m3)</span><br><span class="line"><span class="comment">#用PCA处理后的数据来训练模型</span></span><br><span class="line">linear_model_m3.fit(principal_components, y_train_m3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算模型预测的数据</span></span><br><span class="line">y_fitted_m3 = linear_model_m3.predict(principal_components)</span><br><span class="line">y_predicted_m3 = linear_model_m3.predict(principal_components_valid)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m3.score(principal_components, y_train_m3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>0.5247130722554483</code></pre>
<h3 id="误差评估">误差评估</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = <span class="built_in">abs</span>(y_valid_m1 - y_predicted_m1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m1, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Log Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for Model 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_51_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = <span class="built_in">abs</span>(y_valid_m2 - y_predicted_m2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m2, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Log Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for Model 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_52_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = <span class="built_in">abs</span>(y_valid_m3 - y_predicted_m3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m2, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for Model 3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_53_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#误差分析</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rmse</span>(<span class="params">predicted, actual</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.mean((actual - predicted)**<span class="number">2</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mae</span>(<span class="params">predicted,actual</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(np.mean(actual-predicted))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">preditcted,actual,num=<span class="number">500</span></span>):</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">abs</span>(preditcted - actual&lt;=num)).mean().mean()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_model</span>(<span class="params">predicted,valid,num=<span class="number">500</span></span>):</span><br><span class="line">    rmse_val = rmse(predicted, valid)</span><br><span class="line">    mae_val = mae(predicted,valid)</span><br><span class="line">    accuracy_val = accuracy(predicted,valid,num)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;rmse&#x27;</span>: rmse_val, <span class="string">&#x27;mae&#x27;</span>: mae_val, <span class="string">&#x27;accuracy&#x27;</span> : accuracy_val&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results = pd.DataFrame(columns=[<span class="string">&#x27;rmse&#x27;</span>, <span class="string">&#x27;mae&#x27;</span>, <span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_m1, y_valid_m1,<span class="number">10000</span>)</span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_m2, y_valid_m2,<span class="number">10000</span>)</span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_m3, y_valid_m3,<span class="number">10000</span>)</span><br><span class="line">results.index=[<span class="string">&#x27;model1&#x27;</span>,<span class="string">&#x27;model2&#x27;</span>,<span class="string">&#x27;model3&#x27;</span>]</span><br><span class="line">results</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rmse
</th>
<th>
mae
</th>
<th>
accuracy
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
model1
</th>
<td>
62688.831902
</td>
<td>
2055.973040
</td>
<td>
0.515464
</td>
</tr>
<tr>
<th>
model2
</th>
<td>
55469.213802
</td>
<td>
1812.274563
</td>
<td>
0.514921
</td>
</tr>
<tr>
<th>
model3
</th>
<td>
57169.970382
</td>
<td>
124.863855
</td>
<td>
0.543136
</td>
</tr>
</tbody>
</table>
</div>
<p>使用更多特征列的模型2性能更好，在模型2基础上使用奇异值分解后的数据得到的模型3则有更好的准确度</p>
<h3 id="正则化">正则化</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#l1正则化模型</span></span><br><span class="line">lasso_model = lm.Lasso(alpha=<span class="number">2</span>)</span><br><span class="line">lasso_model.fit(X_train_m3, y_train_m3)</span><br><span class="line">y_predicted_lasso = lasso_model.predict(X_valid_m3)</span><br><span class="line">s = pd.Series(y_predicted_lasso)</span><br><span class="line">df = s.to_frame()</span><br><span class="line">y_predicted_lasso=df.values</span><br></pre></td></tr></table></figure>
<html>
<head>
<!-- Load require.js. Delete this if your page already loads require.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>
<script type="application/vnd.jupyter.widget-state+json">
{
    "version_major": 2,
    "version_minor": 0,
    "state": {}
}
</script>
</head>
<body>
</body>
</html>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#l2正则化模型</span></span><br><span class="line">ridge_model = lm.Ridge(alpha=<span class="number">2</span>)</span><br><span class="line">ridge_model.fit(X_train_m3, y_train_m3)</span><br><span class="line">y_predicted_ridge = ridge_model.predict(X_valid_m3)</span><br><span class="line">predictions_series = pd.Series(y_predicted_ridge[:,<span class="number">0</span>])</span><br><span class="line">predictions_df = predictions_series.to_frame()</span><br><span class="line">predictions_df=predictions_df.rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;house value&#x27;</span>&#125;)</span><br><span class="line">plot_distribution(predictions_df,<span class="string">&#x27;house value&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.
  with pd.option_context(&#39;mode.use_inf_as_na&#39;, True):
C:\Users\thive\anaconda3\envs\KernelForJupyter\lib\site-packages\seaborn\_oldcore.py:1498: FutureWarning: is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, CategoricalDtype) instead
  if pd.api.types.is_categorical_dtype(vector):</code></pre>
<figure>
<img src="/assets/myproj3/output_60_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ridge_model.score(X_train_m3, y_train_m3)</span><br></pre></td></tr></table></figure>
<pre><code>0.5240110865767933</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lasso_model.score(X_train_m3, y_train_m3)</span><br></pre></td></tr></table></figure>
<pre><code>0.5247114165711584</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = <span class="built_in">abs</span>(y_valid_m3 - y_predicted_lasso)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m3, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for lasso&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_63_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = <span class="built_in">abs</span>(y_valid_m3 - y_predicted_ridge)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m3, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for ridge&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_64_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results = pd.DataFrame(columns=[<span class="string">&#x27;rmse&#x27;</span>, <span class="string">&#x27;mae&#x27;</span>, <span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_lasso, y_valid_m3,<span class="number">10000</span>)</span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_ridge, y_valid_m3,<span class="number">10000</span>)</span><br><span class="line">results.index=[<span class="string">&#x27;lasso&#x27;</span>,<span class="string">&#x27;ridge&#x27;</span>]</span><br><span class="line">results</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rmse
</th>
<th>
mae
</th>
<th>
accuracy
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
lasso
</th>
<td>
56539.366725
</td>
<td>
1064.977332
</td>
<td>
0.542051
</td>
</tr>
<tr>
<th>
ridge
</th>
<td>
56530.892304
</td>
<td>
1033.519284
</td>
<td>
0.542594
</td>
</tr>
</tbody>
</table>
</div>
<h3 id="随机森林模型">随机森林模型</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分类模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line">decision_tree_model = tree.DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>,min_samples_split=<span class="number">5</span>,min_samples_leaf =<span class="number">3</span>,max_depth=<span class="number">10</span>)</span><br><span class="line">decision_tree_model = decision_tree_model.fit(principal_components, y_train_m3)</span><br><span class="line">y_predicted_tree=decision_tree_model.predict(principal_components_valid)</span><br><span class="line">s = pd.Series(y_predicted_tree)</span><br><span class="line">df = s.to_frame()</span><br><span class="line">y_predicted_tree=df.values</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = <span class="built_in">abs</span>(y_valid_m3 - y_predicted_tree)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m3, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for ridge&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_68_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#回归模型</span></span><br><span class="line">decision_tree_model_regression = tree.DecisionTreeRegressor(criterion=<span class="string">&#x27;friedman_mse&#x27;</span>,min_samples_split=<span class="number">5</span>,min_samples_leaf =<span class="number">3</span>)</span><br><span class="line">decision_tree_model_regression = decision_tree_model_regression.fit(X_train_m3, y_train_m3)</span><br><span class="line">y_predicted_tree_regression=decision_tree_model_regression.predict(X_valid_m3)</span><br><span class="line">s = pd.Series(y_predicted_tree_regression)</span><br><span class="line">df = s.to_frame()</span><br><span class="line">y_predicted_tree_regression=df.values</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = <span class="built_in">abs</span>(y_valid_m3 - y_predicted_tree_regression)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m3, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for ridge&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_70_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>to_do:交叉验证，支持向量机</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> graphviz </span><br><span class="line">dot_data = tree.export_graphviz(decision_tree_model, out_file=<span class="literal">None</span>) </span><br><span class="line">graph = graphviz.Source(dot_data) </span><br><span class="line">graph</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_72_0.svg" alt="" /><figcaption>svg</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results = pd.DataFrame(columns=[<span class="string">&#x27;rmse&#x27;</span>, <span class="string">&#x27;mae&#x27;</span>, <span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_tree, y_valid_m3,<span class="number">10000</span>)</span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_tree_regression, y_valid_m3,<span class="number">10000</span>)</span><br><span class="line">results.index=[<span class="string">&#x27;classify&#x27;</span>,<span class="string">&#x27;regression&#x27;</span>]</span><br><span class="line">results</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rmse
</th>
<th>
mae
</th>
<th>
accuracy
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
classify
</th>
<td>
92779.070688
</td>
<td>
53530.927835
</td>
<td>
0.822572
</td>
</tr>
<tr>
<th>
regression
</th>
<td>
69771.185279
</td>
<td>
489.023332
</td>
<td>
0.571351
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>基于mit6.006的作业解析</title>
    <url>/2023/11/20/mit6.006%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="hw1">hw1</h1>
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<p>对这种形式的函数可以这样比较</p>
<p><span class="math display">\[f_1=n^{\sqrt{n}}=(2^{lgn})^{\sqrt{n}}\]</span> <span class="math display">\[f_2=n^{10}.2^{n/2}=2^{lg(10n)+n/2}\]</span></p>
<h2 id="复杂度计算">复杂度计算</h2>
<p>对于T(n,n): T (x, y) = Θ(x + y) + T (x/2, y/2). 化成</p>
<p><img src="/assets/mit6.006作业解析/image-20231120213425020.png" /></p>
<p>得到θ(n) <span id="more"></span></p>
<p>T (x, y) = Θ(x) + T (x, y/2). 等于lgy个θ(x) 即，θ(nlgn)</p>
<p>T (x, y) = Θ(x) + S(x, y/2), S(x, y) = Θ(y) + T (x/2, y).</p>
<p>化成T (x, y) = Θ(x) + Θ(y/2) + T (x/2, y/2). 与第一个例子相似，θ(n)</p>
<h2 id="寻峰算法">寻峰算法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm1</span>(<span class="params">problem, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># the recursive subproblem will involve half the number of columns</span></span><br><span class="line">    mid = problem.numCol // <span class="number">2</span></span><br><span class="line">    <span class="comment"># information about the two subproblems</span></span><br><span class="line">    (subStartR, subNumR) = (<span class="number">0</span>, problem.numRow)</span><br><span class="line">    (subStartC1, subNumC1) = (<span class="number">0</span>, mid)</span><br><span class="line">    (subStartC2, subNumC2) = (mid + <span class="number">1</span>, problem.numCol - (mid + <span class="number">1</span>))</span><br><span class="line">    subproblems = []</span><br><span class="line">    subproblems.append((subStartR, subStartC1, subNumR, subNumC1))</span><br><span class="line">    subproblems.append((subStartR, subStartC2, subNumR, subNumC2))</span><br><span class="line">    <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">    divider = crossProduct(<span class="built_in">range</span>(problem.numRow), [mid])</span><br><span class="line">    <span class="comment"># find the maximum in the dividing column</span></span><br><span class="line">    bestLoc = problem.getMaximum(divider, trace)</span><br><span class="line">    <span class="comment"># see if the maximum value we found on the dividing line has a better</span></span><br><span class="line">    <span class="comment"># neighbor (which cannot be on the dividing line, because we know that</span></span><br><span class="line">    <span class="comment"># this location is the best on the dividing line)</span></span><br><span class="line">    neighbor = problem.getBetterNeighbor(bestLoc, trace)</span><br><span class="line">    <span class="comment"># this is a peak, so return it</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == bestLoc:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(bestLoc)</span><br><span class="line">        <span class="keyword">return</span> bestLoc</span><br><span class="line">    <span class="comment"># otherwise, figure out which subproblem contains the neighbor, and</span></span><br><span class="line">    <span class="comment"># recurse in that half</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, neighbor)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm1(sub, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm2</span>(<span class="params">problem, location = (<span class="params"><span class="number">0</span>, <span class="number">0</span></span>), trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    nextLocation = problem.getBetterNeighbor(location, trace)</span><br><span class="line">    <span class="keyword">if</span> nextLocation == location:</span><br><span class="line">        <span class="comment"># there is no better neighbor, so return this peak</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(location)</span><br><span class="line">        <span class="keyword">return</span> location</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># there is a better neighbor, so move to the neighbor and recurse</span></span><br><span class="line">        <span class="keyword">return</span> algorithm2(problem, nextLocation, trace)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm3</span>(<span class="params">problem, bestSeen = <span class="literal">None</span>, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    midRow = problem.numRow // <span class="number">2</span></span><br><span class="line">    midCol = problem.numCol // <span class="number">2</span></span><br><span class="line">    <span class="comment"># first, get the list of all subproblems</span></span><br><span class="line">    subproblems = []</span><br><span class="line">    (subStartR1, subNumR1) = (<span class="number">0</span>, midRow)</span><br><span class="line">    (subStartR2, subNumR2) = (midRow + <span class="number">1</span>, problem.numRow - (midRow + <span class="number">1</span>))</span><br><span class="line">    (subStartC1, subNumC1) = (<span class="number">0</span>, midCol)</span><br><span class="line">    (subStartC2, subNumC2) = (midCol + <span class="number">1</span>, problem.numCol - (midCol + <span class="number">1</span>))</span><br><span class="line">    subproblems.append((subStartR1, subStartC1, subNumR1, subNumC1))</span><br><span class="line">    subproblems.append((subStartR1, subStartC2, subNumR1, subNumC2))</span><br><span class="line">    subproblems.append((subStartR2, subStartC1, subNumR2, subNumC1))</span><br><span class="line">    subproblems.append((subStartR2, subStartC2, subNumR2, subNumC2))</span><br><span class="line">    <span class="comment"># find the best location on the cross (the middle row combined with the</span></span><br><span class="line">    <span class="comment"># middle column)</span></span><br><span class="line">    cross = []</span><br><span class="line">    cross.extend(crossProduct([midRow], <span class="built_in">range</span>(problem.numCol)))</span><br><span class="line">    cross.extend(crossProduct(<span class="built_in">range</span>(problem.numRow), [midCol]))</span><br><span class="line">    crossLoc = problem.getMaximum(cross, trace)</span><br><span class="line">    neighbor = problem.getBetterNeighbor(crossLoc, trace)</span><br><span class="line">    <span class="comment"># update the best we&#x27;ve seen so far based on this new maximum</span></span><br><span class="line">    <span class="keyword">if</span> bestSeen <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> problem.get(neighbor) &gt; problem.get(bestSeen):</span><br><span class="line">        bestSeen = neighbor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setBestSeen(bestSeen)</span><br><span class="line">    <span class="comment"># return if we can&#x27;t see any better neighbors</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == crossLoc:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(crossLoc)</span><br><span class="line">        <span class="keyword">return</span> crossLoc</span><br><span class="line">    <span class="comment"># figure out which subproblem contains the largest number we&#x27;ve seen so</span></span><br><span class="line">    <span class="comment"># far, and recurse</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, bestSeen)</span><br><span class="line">    newBest = sub.getLocationInSelf(problem, bestSeen)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm3(sub, newBest, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm4</span>(<span class="params">problem, bestSeen = <span class="literal">None</span>, rowSplit = <span class="literal">True</span>, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    subproblems = []</span><br><span class="line">    divider = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> rowSplit:</span><br><span class="line">        <span class="comment"># the recursive subproblem will involve half the number of rows</span></span><br><span class="line">        mid = problem.numRow // <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># information about the two subproblems</span></span><br><span class="line">        (subStartR1, subNumR1) = (<span class="number">0</span>, mid)</span><br><span class="line">        (subStartR2, subNumR2) = (mid + <span class="number">1</span>, problem.numRow - (mid + <span class="number">1</span>))</span><br><span class="line">        (subStartC, subNumC) = (<span class="number">0</span>, problem.numCol)</span><br><span class="line">  </span><br><span class="line">        subproblems.append((subStartR1, subStartC, subNumR1, subNumC))</span><br><span class="line">        subproblems.append((subStartR2, subStartC, subNumR2, subNumC))</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">        divider = crossProduct([mid], <span class="built_in">range</span>(problem.numCol))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># the recursive subproblem will involve half the number of columns</span></span><br><span class="line">        mid = problem.numCol // <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># information about the two subproblems</span></span><br><span class="line">        (subStartR, subNumR) = (<span class="number">0</span>, problem.numRow)</span><br><span class="line">        (subStartC1, subNumC1) = (<span class="number">0</span>, mid)</span><br><span class="line">        (subStartC2, subNumC2) = (mid + <span class="number">1</span>, problem.numCol - (mid + <span class="number">1</span>))</span><br><span class="line">  </span><br><span class="line">        subproblems.append((subStartR, subStartC1, subNumR, subNumC1))</span><br><span class="line">        subproblems.append((subStartR, subStartC2, subNumR, subNumC2))</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">        divider = crossProduct(<span class="built_in">range</span>(problem.numRow), [mid])</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># find the maximum in the dividing row or column</span></span><br><span class="line">    bestLoc = problem.getMaximum(divider, trace)</span><br><span class="line">    neighbor = problem.getBetterNeighbor(bestLoc, trace)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># update the best we&#x27;ve seen so far based on this new maximum</span></span><br><span class="line">    <span class="keyword">if</span> bestSeen <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> problem.get(neighbor) &gt; problem.get(bestSeen):</span><br><span class="line">        bestSeen = neighbor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setBestSeen(bestSeen)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># return when we know we&#x27;ve found a peak</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == bestLoc <span class="keyword">and</span> problem.get(bestLoc) &gt;= problem.get(bestSeen):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(bestLoc)</span><br><span class="line">        <span class="keyword">return</span> bestLoc</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># figure out which subproblem contains the largest number we&#x27;ve seen so</span></span><br><span class="line">    <span class="comment"># far, and recurse, alternating between splitting on rows and splitting</span></span><br><span class="line">    <span class="comment"># on columns</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, bestSeen)</span><br><span class="line">    newBest = sub.getLocationInSelf(problem, bestSeen)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm4(sub, newBest, <span class="keyword">not</span> rowSplit, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br></pre></td></tr></table></figure>
<p>算法一二如课程笔记所述，均是正确的，以下是证明</p>
<ul>
<li>algo1</li>
</ul>
<ol type="1">
<li>证明算法不可能返回一个空值，首先算法不可能得到一个负索引的子数组（在只有一列的时候必然会得到结果而不是继续划分），在最小问题的情况下，如果此时子问题有一列，那么必然返回一个峰值，如果有两列，不管目前讨论的列是不是最大值，都会递归成最小为1为列的子问题，不会返回空值</li>
<li>证明返回的位置确实是峰值位置，如果算法1返回一个位置（r1，c1），则该位置必须具有列c1中的最大值，并且必须是某个递归子问题中的峰值。为了推导矛盾，假设（r1，c1）不是原始问题中的峰值。在某个子问题中，位置（r1，c1）与列c2相邻（|c1 - c2| = 1），并且值必须满足不等式val（r1，c1）&lt; val（r1，c2）。<br />
让（r2，c2）是算法1在c2列中找到的最大值的位置。因此，必定有val（r1，c2）≤ val（r2，c2）。因为c2是分割线，且算法选择在包含（r1，c1）的一半上进行递归，所以我们知道val（r2，c2）&lt; val（r2，c1）。因此，我们有以下不等式链：<br />
val（r1，c1）&lt; val（r1，c2）≤ val（r2，c2）&lt; val（r2，c1）<br />
但是，为了使算法1将（r1，c1）作为峰值返回，（r1，c1）处的值必须是其列中的最大值，即val（r1，c1）≥ val（r2，c1）。因此，我们得到了一个矛盾。</li>
</ol>
<ul>
<li>algo3是错误的</li>
</ul>
<p>时间复杂度是θ(n)，情况类似复杂度题目的第一个情况，1+1/2+1/4……</p>
<p><strong>反例</strong></p>
<p>如图所示的反例会选择返回一个在当前子问题中看起来像一个峰值，但是与子问题外部的某个更大值相邻的位置</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>0</th>
<th>9</th>
<th>8</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>对算法四的证明</p>
<ul>
<li>algo4</li>
</ul>
<p>时间复杂度是θ(n),类似算法3</p>
<p>算法四交叉进行行和列的最大值寻找</p>
<ol type="1">
<li>如果峰值问题不为空，则算法将始终返回一个位置。在算法中，根据是在行还是列上分割，递归子问题的维度会相应地减少。所以算法要么在某个时刻停止并返回一个位置，要么最终检查一个行数或列数为非正的子问题。但是，问题的行数或列数变为严格负数的唯一方式是在某个时刻m=0或n=0。因此，如果算法没有返回位置，它必定最终检查一个空的子问题。然而，证明假设该情况不会发生。</li>
<li>如果算法返回一个位置，则该位置将是原始问题中的一个峰值。如果算法返回一个位置(r1, c1)，那么该位置必定是某个递归子问题中的峰值。另外，如果(r2, c2)是算法执行过程中的最佳位置（存储在bestSeen变量中的位置），那么必定满足val(r1, c1) ≥ val(r2, c2)。证明假设(r1, c1)不是原始问题的峰值。那么当位置(r1, c1)通过递归调用链向上传递时，它必定在某个级别停止是不是峰值。因此，必定存在一个包含位置(r1, c1)的子问题，在该级别中，该子问题的某个邻居(r3, c3)的值满足val(r1, c1) &lt; val(r3, c3)。对于(r3, c3)既是递归子问题的邻居又不包含在子问题中，它必定在算法的执行过程中被检查过。因此，必定满足val(r3, c3) ≤ val(r2, c2)。因此，我们得到以下不等式链：val(r1, c1) &lt; val(r3, c3) ≤ val(r2, c2) ≤ val(r1, c1)。这导致了矛盾。</li>
</ol>
<h1 id="hw2">hw2</h1>
<h2 id="科赫雪花">科赫雪花</h2>
<figure>
<embed src="/game/fractal.html" /><figcaption>简单的演示</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SNOWFLAKE(n)</span><br><span class="line"> e1, e2, e3 = edges of an equilateral triangle with side length 1</span><br><span class="line"> SNOWFLAKE-EDGE(e1, n)</span><br><span class="line"> SNOWFLAKE-EDGE(e2, n)</span><br><span class="line"> SNOWFLAKE-EDGE(e3, n)</span><br><span class="line">SNOWFLAKE-EDGE(edge, n)</span><br><span class="line"> if n = = 0</span><br><span class="line">  edge is an edge on the snowflake</span><br><span class="line"> else</span><br><span class="line">  e1, e2, e3 = split edge in 3 equal parts</span><br><span class="line"> SNOWFLAKE-EDGE(e1, n − 1)</span><br><span class="line"> f2, g2 = edges of an equilateral triangle whose 3rd edge is e2, pointing outside the snowflake</span><br><span class="line"> ∆(f2, g2, e2) is a triangle on the snowflake’s surface</span><br><span class="line"> SNOWFLAKE-EDGE(f2, n − 1)</span><br><span class="line"> SNOWFLAKE-EDGE(g2, n − 1)</span><br><span class="line"> SNOWFLAKE-EDGE(e3, n − 1)</span><br></pre></td></tr></table></figure>
<p>从主函数（层数视为-1)开始对每条边进行处理，这一层有三个节点。 而对边处理的函数则遵从这样的流程</p>
<ol type="1">
<li>把边等分成三个部分e1,e2,e3</li>
<li>对e1进行递归</li>
<li>以e2为一条边向外侧生成一个等边三角形，f2,g2是这个三角形的另外两条边</li>
<li>以此对f2,g2,e3进行递归 函数实际上把一条边拓展出了一个三角形 因此第i层的节点数是:<span class="math display">\[3*4^i\]</span> <img src="/assets/mit6.006作业解析/image-20231122203735331.png" /></li>
</ol>
<h3 id="d-硬件加速渲染">3D 硬件加速渲染</h3>
<p>在这种渲染方式中，cpu计算分解出的三角形顶点的集合，发给gpu进行绘制，因此cpu的执行时间只取决于分解出的三角形数量，也就是θ(4^n)</p>
<h3 id="d-硬件加速渲染-1">2D 硬件加速渲染</h3>
<p>在这种渲染方式中，cpu实际上只计算不断分割出的线段集合，在本题中就是计算最外侧的轮廓的顶点的集合，计算结束后发给gpu绘制 时间复杂度依旧是θ(4^n)，但需要注意的是由于计算完了才开始渲染，因此递归树的中间节点不会对渲染产生时间消耗</p>
<h3 id="软件渲染">软件渲染</h3>
<p>在没有硬件加速器的2D渲染（也称为软件渲染）中，CPU 像上一部分一样，为每个路径编译一个线段列表，但它也负责 用于“光栅化”每个线段。 光栅化获取线段端点的坐标 并计算位于线段上的所有像素的坐标。 用这些像素在显示器上绘制线段。光栅化算法在时间上的消耗与线段的长度成正比，线段上的像素数量与线段的长度成正比。 在整个问题中，假设所有线段的长度至少为一个像素，因此 光栅化的成本大于编译线段的成本。 需要注意的是：</p>
<ol type="1">
<li>中间节点依旧对渲染无影响</li>
<li>由于每次对边处理实际上增加了该边1/3的像素点，所以最后一层产生的代价是<span class="math display">\[θ({(1/3)}^n)\]</span></li>
<li>同理，总渲染代价和cpu处理（只处理像素点）的时间复杂度都是<span class="math display">\[θ({(4/3)}^n)\]</span></li>
</ol>
<h3 id="没有硬件加速的-3d-渲染">没有硬件加速的 3D 渲染</h3>
<p>在这种情况下， CPU 编译三角形列表，然后光栅化每个三角形。 我们知道一种算法 栅格化一个三角形，其运行时间与三角形的表面积成正比。三角形内的像素数量与三角形的面积成正比。可以假设边长为 l 的三角形的面积为 θ(l^2)。 顺着递归树进行分析，首层只增加了三个节点，每个新节点对应一个边长是原边长1/3的新三角形，增加了1/3的面积，之后的每一层都有4^i个节点，对应4/9的面积增长，即每层的增长是 <span class="math display">\[\frac{1}{3}.\frac{4}{9}^i\]</span> 可以用等比数列的求和算出答案，但时间复杂度必然是θ(1)</p>
<h2 id="电路模拟">电路模拟</h2>
<p><img src="/assets/mit6.006作业解析/image-20231124185516359.png" /> 如图是对一个异或门的模拟，两个输入端AB产生的信号会在2ns的延迟后在输出端产生一个结果，除此以外没有延迟 按照题意运行<code>python -m cProfile -s time circuit.py &lt; tests/5devadas13.in</code> 得到如下结果（不完全），可以看到消耗最多时间的是lt(lower than)和find_min两个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">625762426  319.980    0.000  319.980    0.000 circuit.py:286(__lt__)</span><br><span class="line">   259964  315.431    0.001  635.431    0.002 circuit.py:381(_find_min)</span><br><span class="line">    64400    1.371    0.000  639.636    0.010 circuit.py:423(step)</span><br><span class="line">828793/634381    0.463    0.000    0.612    0.000 &#123;built-in method builtins.len&#125;</span><br><span class="line">   194381    0.421    0.000  635.865    0.003 circuit.py:361(min)</span><br><span class="line">    32768    0.352    0.000    0.352    0.000 &#123;method &#x27;write&#x27; of &#x27;_io.TextIOWrapper&#x27; objects&#125;</span><br><span class="line">    65554    0.309    0.000    0.723    0.000 circuit.py:163(transition_output)</span><br><span class="line">        1    0.290    0.290  640.116  640.116 circuit.py:456(run)</span><br></pre></td></tr></table></figure>
<p>随后题意要求基于原来的api实现一个优先队列(最小堆)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Array-based priority queue implementation.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initially empty priority queue.&quot;&quot;&quot;</span></span><br><span class="line">        self.queue = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leftchid</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*key+<span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightchild</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*key+<span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> (key-<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">self,key1,key2</span>):</span><br><span class="line">        temp=self.queue[key2]</span><br><span class="line">        self.queue[key2]=self.queue[key1]</span><br><span class="line">        self.queue[key1]=temp</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Number of elements in the queue.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sift_up</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            p=self.parent(key)</span><br><span class="line">            <span class="keyword">if</span> (p&lt;<span class="number">0</span> <span class="keyword">or</span> self.queue[p]&lt;=self.queue[key]):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.swap(p,key)</span><br><span class="line">                key=p</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Inserts an element in the priority queue.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Cannot insert None in the queue&#x27;</span>)</span><br><span class="line">        self.queue.append(key)</span><br><span class="line">        self.sift_up(self.__len__()-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;The smallest element in the queue.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            lft,rht = self.leftchid(key),self.rightchild(key)</span><br><span class="line">            min_key=key</span><br><span class="line">            <span class="keyword">if</span> (lft&lt;self.__len__() <span class="keyword">and</span> self.queue[lft]&lt;self.queue[key]):</span><br><span class="line">                min_key=lft</span><br><span class="line">            <span class="keyword">if</span> (rht&lt;self.__len__() <span class="keyword">and</span> self.queue[rht]&lt;self.queue[min_key]):</span><br><span class="line">                min_key=rht</span><br><span class="line">            <span class="keyword">if</span> (min_key==key): <span class="keyword">break</span></span><br><span class="line">            self.swap(min_key,key)</span><br><span class="line">            key =min_key</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Removes the minimum element in the queue.</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            The value of the removed element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.swap(<span class="number">0</span>,self.__len__()-<span class="number">1</span>)</span><br><span class="line">        min_val=self.queue.pop(self.__len__()-<span class="number">1</span>)</span><br><span class="line">        self.sift_down(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> min_val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_find_min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Computes the index of the minimum element in the queue.</span></span><br><span class="line">        <span class="comment"># This method may crash if called when the queue is empty.</span></span><br><span class="line">        <span class="keyword">if</span> self.__len__==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;cannot find min of empty queue&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>python3可以运行所有测试，但无法运行可视化程序，不过也无所谓了，优化后再次运行一开始的输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">    65583    2.826    0.000    5.321    0.000 circuit.py:389(sift_down)</span><br><span class="line">    65583    1.006    0.000    1.901    0.000 circuit.py:366(sift_up)</span><br><span class="line">  1930321    0.807    0.000    1.109    0.000 circuit.py:362(__len__)</span><br><span class="line">  1349048    0.772    0.000    0.772    0.000 circuit.py:357(swap)</span><br><span class="line">  1432334    0.719    0.000    0.719    0.000 circuit.py:286(__lt__)</span><br><span class="line">    64400    0.698    0.000    9.608    0.000 circuit.py:451(step)</span><br><span class="line">2450781/2256369    0.473    0.000    0.567    0.000 &#123;built-in method builtins.len&#125;</span><br></pre></td></tr></table></figure>
<p>问题解决了,amdtel的offer什么时候发？</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据结构与算法</tag>
        <tag>麻省理工</tag>
      </tags>
  </entry>
  <entry>
    <title>基于中科大郑烇老师授课的计算机网络笔记(待续)</title>
    <url>/2023/10/14/%E8%AE%A1%E7%BD%91/</url>
    <content><![CDATA[<h2 id="第一章概论">第一章——概论</h2>
<h3 id="互联网">互联网</h3>
<p><code>链路层</code>相邻节点传输数据 <code>网络层</code>提供源主机到目标主机之间(端到端end to end)的服务(没有保障)</p>
<ol type="1">
<li>传统方式：IP协议，路由协议（路由器交换路由信息，根据算法算出路由表，由ip协议根据目标ip查询路由表确定找到合适端口，进行转发）</li>
<li>SDN(数据平面：交换机，控制平面：网络操作系统)，控制平面中的网络应用根据信息算出有大量字段的流表给交换机，根据字段匹配相应表项 <code>传输层</code>区分进程，为进程中多个应用提供服务 <code>传输协议</code>:tcp提供可靠的数据传输，udp更强调实时性 <code>tcp</code>：往返建立连接得到响应后再传输 <code>udp</code>：不会先建立连接再传输 <code>应用层协议</code>：客户端，服务器等应用之间如何交互来实现功能 <code>网络</code>：节点和边的形成的拓扑结构 <code>计算机网络</code>：</li>
</ol>
<ul>
<li>节点：主机节点，数据交换节点（转发数据，交换机，路由器等等）</li>
<li>边被称为链路：接入网链路（主机连接到互联网），主干链路（路由器之间）</li>
<li>协议：网络设备的工作标准 <code>互联网</code>：世界上最大的互联计算机网络，网络的网络 <span id="more"></span></li>
<li>节点：数以亿计的互联设备，主机(host/end system),一般方节点是主机，圆节点是交换机</li>
<li>通信链路(link)：光纤，卫星，无线电等，传输速率 = 带宽(bps每秒传输的位)</li>
<li>分组交换设备(packets):路由器和交换机</li>
<li>协议和标准(tcp,ip,udp,)：不同实体之间通讯方式的规定(在RFC官网公布) 协议定义了发送信息的格式，次序，动作等</li>
</ul>
<p>从服务角度：应用层以下是基础设施，为其上的分布式应用提供通讯，两者一起组成了互联网 提供通讯使用操作系统提供的网络api(socket)和其他节点建立连接和通讯</p>
<h3 id="网络边缘">网络边缘</h3>
<p><img src="/assets/计网/image-20231010191525639.png" /> 互联网的三个子系统</p>
<ul>
<li><code>网络边缘</code>：主机和应用程序</li>
<li><code>网络核心</code>：实现大规模的数据交换，互联的路由器（网络的网络）</li>
<li><code>网络的接入</code>:把边缘接入到核心</li>
</ul>
<p>边缘的模式</p>
<ol type="1">
<li>C/S模式(主从模式)，客户端-服务器(客户端发送请求，服务器响应请求，并把结果发送给客户端) 缺点：可扩展性较差，负载达到一定阈值，响应能力断崖式下降</li>
<li>P2P模式(Peer to Peer)，对等模式，每个节点既是客户端又是服务器，分布式通信 可以在不同的节点上得到分段的资源</li>
</ol>
<p>通信方式</p>
<ol type="1">
<li>面向连接的通讯方式，先建立连接(发送连接请求，响应请求，准备好缓冲区等)，再相互通讯 特点：连接状态仅仅是端系统维持 eg. tcp协议（流量控制）</li>
<li>无连接通信，不建立连接 eg. udp协议（无流量控制）</li>
</ol>
<h3 id="网络核心">网络核心</h3>
<p>路由器的网状网络 <img src="/assets/计网/image-20231013084440297.png" /> 网络资源可以被分成片，给每个呼叫分配片，如果没有数据交换，则可以不占用资源片（频分，波分等） 资源交换除了时间还有电磁波的传播延迟 <img src="/assets/计网/image-20231013103915204.png" /> 电路交换不适合计算机通信（计算机通信有突发性）</p>
<p>分组交换(共享性)：交换节点存储数据包，并分组转发，从而实现通信，按需使用网络资源 由于中间节点的存在，延迟比线路交换更高 可能出现分组的排队，甚至丢失 路由：决定源主机到目标主机的路径 转发：把输入链路转移到输出链路 <code>复用方式</code>：时分复用（时间片），统计多路复用(不固定) 问题：流媒体等需要速度保证的场景有更高的性能需求</p>
<p>分组交换网络：</p>
<ul>
<li>数据报网络：两主机不需要建立连接，不需要维护通信状态，每个主机都有目标主机的地址，可以独立路由地运作，路由器根据分组的目标地址进行路由</li>
<li>虚电路网络：两个主机通信前建立连接，每个分组有一个虚电路表，按照虚电路号标识进行存储转发，过程中虚电路号可能变化</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>中科大</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利ds100的数据科学笔记pandas部分</title>
    <url>/2023/09/29/jupyter%20notebook/</url>
    <content><![CDATA[<h2 id="notebook">notebook</h2>
<ol type="1">
<li><code>Ctrl</code> + <code>Return</code>（或者 <code>Cmd</code> + <code>Return</code>在 Mac 上）： <em>评估当前单元格</em></li>
<li><code>Shift</code> + <code>Return</code>： <em>评估当前单元格并移至下一个单元格</em></li>
<li><code>ESC</code>： <em>命令模式</em> （在使用以下任何命令之前可能需要按）</li>
<li><code>a</code>: <em>在上面创建一个单元格</em></li>
<li><code>b</code>： <em>在下面创建一个单元格</em></li>
<li><code>dd</code>: <em>删除一个单元格</em></li>
<li><code>z</code>： <em>撤消上一次单元格操作</em></li>
<li><code>m</code>： <em>将单元格转换为 Markdown</em></li>
<li><code>y</code>： <em>将单元格转换为代码</em> <span id="more"></span></li>
</ol>
<h2 id="pandas">pandas</h2>
<h3 id="创建表格dataframe">创建表格DataFrame</h3>
<p>按列创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info = pd.DataFrame(</span><br><span class="line">    data = &#123;&#x27;fruit&#x27;: [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;raspberry&#x27;],</span><br><span class="line">          &#x27;color&#x27;: [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;],</span><br><span class="line">          &#x27;price&#x27;: [1.0, 0.75, 0.35, 0.05]</span><br><span class="line">          &#125;)</span><br><span class="line">fruit_info</span><br></pre></td></tr></table></figure>
<p>按行创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info2 = pd.DataFrame(</span><br><span class="line">    [(&quot;red&quot;, &quot;apple&quot;, 1.0), (&quot;orange&quot;, &quot;orange&quot;, 0.75), (&quot;yellow&quot;, &quot;banana&quot;, 0.35),</span><br><span class="line">     (&quot;pink&quot;, &quot;raspberry&quot;, 0.05)], </span><br><span class="line">    columns = [&quot;color&quot;, &quot;fruit&quot;, &quot;price&quot;])</span><br></pre></td></tr></table></figure>
<h3 id="选择行和列">选择行和列</h3>
<ul>
<li>loc 两个详细运算符中的第一个是 <code>loc</code>，它需要两个参数。 第一个是一个或多个行 <strong>标签</strong> ，第二个是一个或多个列 <strong>标签</strong> 。</li>
</ul>
<p>所需的行或列可以单独提供、以切片表示法或作为列表提供。 单独提供会返回series 单独切片参数默认返回行</p>
<p><img src="/assets/jupyter%20notbook/image-20230924084033386.png" /> <img src="/assets/jupyter%20notbook/image-20230924084006924.png" /> <img src="/assets/jupyter%20notbook/image-20230924084050655.png" /> ● loc selects items by label. First argument is rows, second argument is columns. ● iloc selects items by number. First argument is rows, second argument is columns. ● [] only takes one argument, which may be: ○ A slice of row numbers. ○ A list of column labels. ○ A single column label. That is,[] is context sensitive.</p>
<ul>
<li>列名一般唯一，可以强制重复</li>
<li>行名可以重复 pandas支持裸操作,但此时无法使用切片</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Here we&#x27;re providing a list of fruits as single argument to []</span><br><span class="line">fruit_info[[&quot;fruit&quot;, &quot;color&quot;, &quot;price&quot;]]</span><br></pre></td></tr></table></figure>
<h3 id="其他行列操作">其他行列操作</h3>
<p>添加行和列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info[&#x27;rank1&#x27;] = [1,2,3,4]</span><br><span class="line">fruit_info.loc[:,&#x27;rank2&#x27;] = [1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>使用 <code>.drop()</code>方法来 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html">删除</a> 这两个 <code>rank1</code>和 <code>rank2</code>您创建的列。 确保使用 <code>axis</code>参数正确。 注意 <code>drop</code>不会更改表，而是返回一个具有较少列或行的新表，除非您设置可选 <code>inplace</code>范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info</span><br><span class="line">fruit_info_original = fruit_info.drop([&#x27;rank1&#x27;,&#x27;rank2&#x27;],axis=1)</span><br><span class="line">fruit_info_original</span><br></pre></td></tr></table></figure>
<p>重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info_caps=fruit_info_original.rename(columns=&#123;&#x27;fruit&#x27;:&#x27;F&#x27;,&#x27;color&#x27;:&#x27;C&#x27;,&#x27;price&#x27;:&#x27;P&#x27;&#125;)</span><br><span class="line">fruit_info_caps</span><br></pre></td></tr></table></figure>
<h3 id="布尔数组筛选和查询">布尔数组筛选和查询</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = baby_names[(baby_names[&#x27;Year&#x27;]==2000) &amp; (baby_names[&#x27;Count&#x27;]&gt;3000)]</span><br><span class="line">result_using_query = baby_names.query(&#x27;Year==2000 &amp; Count&gt;3000&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="slides实例">slides实例</h3>
<p>提取列数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections[&quot;Candidate&quot;].tail(5).to_frame()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提取目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For row labels, use DataFrame.index:</span><br><span class="line">For column labels, use DataFrame.columns:</span><br></pre></td></tr></table></figure>
<p>支持布尔数组检索 <img src="/assets/jupyter%20notbook/image-20230924090511103.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections[elections[&quot;Party&quot;] == &quot;Independent&quot;]</span><br><span class="line">elections[(elections[&quot;Result&quot;] == &quot;win&quot;) &amp; (elections[&quot;%&quot;] &lt; 47)]</span><br></pre></td></tr></table></figure>
<p>支持用其他数组检索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a_parties = [&quot;Anti-Masonic&quot;, &quot;American&quot;, &quot;Anti-Monopoly&quot;, &quot;American Independent&quot;]</span><br><span class="line">elections[elections[&quot;Party&quot;].isin(a_parties)]</span><br></pre></td></tr></table></figure>
<p>查询类似sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections.query(&#x27;Result == &quot;win&quot; and Party not in @parties&#x27;)</span><br></pre></td></tr></table></figure>
<p>匿名函数辅助查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What if we wanted to find the longest names in California?</span><br><span class="line">babynames.query(&#x27;Sex == &quot;M&quot; and Year == 2020&#x27;)</span><br><span class="line">.sort_values(&quot;Name&quot;, key = lambda x: x.str.len(),</span><br><span class="line">ascending = False)</span><br></pre></td></tr></table></figure>
<p>创建删除列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">babyname_lengths = babynames[&quot;Name&quot;].str.len()</span><br><span class="line">#add that series to the dataframe as a column</span><br><span class="line">babynames[&quot;name_lengths&quot;] = babyname_lengths</span><br><span class="line">babynames = babynames.sort_values(by = &quot;name_lengths&quot;, ascending=False)</span><br><span class="line">babynames = babynames.drop(&quot;name_lengths&quot;, axis = &#x27;columns&#x27;)//删除列(默认为行)</span><br></pre></td></tr></table></figure>
<p>map方法使用函数统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def dr_ea_count(string):</span><br><span class="line">return string.count(&#x27;dr&#x27;) + string.count(&#x27;ea&#x27;)</span><br><span class="line">babynames[&quot;dr_ea_count&quot;] = babynames[&quot;Name&quot;].map(dr_ea_count)</span><br><span class="line">babynames = babynames.sort_values(by = &quot;dr_ea_count&quot;, ascending=False)</span><br></pre></td></tr></table></figure>
<p>字典创建表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#build dictionary where each entry is the rtp for a given name</span><br><span class="line">#e.g. rtps[&quot;jennifer&quot;] should be 0.0231</span><br><span class="line">rtps = &#123;&#125;</span><br><span class="line">for name in babynames[&quot;Name&quot;].unique():</span><br><span class="line">counts_of_current_name = female_babynames[female_babynames[&quot;Name&quot;] == name][&quot;Count&quot;]</span><br><span class="line">rtps[name] = ratio_to_peak(counts_of_current_name)</span><br><span class="line">#convert to series</span><br><span class="line">rtps = pd.Series(rtps)</span><br></pre></td></tr></table></figure>
<p>使用group建立新表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">female_babynames.groupby(&quot;Name&quot;).agg(ratio_to_peak)</span><br></pre></td></tr></table></figure>
<p><img src="/assets/jupyter%20notbook/image-20230924092636108.png" /> groupby的其他用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given a DataFrameGroupBy object, can use various functions to generate DataFrames (or</span><br><span class="line">Series). agg is only one choice:</span><br><span class="line">● agg: Creates a new DataFrame with one aggregated row per subframe.</span><br><span class="line">● max: Creates a new DataFrame aggregated using the max function.</span><br><span class="line">● size: Creates a new Series with the size of each subframe.</span><br><span class="line">● filter: Creates a copy of the original DataFrame, but keeping only rows from subframes</span><br><span class="line">that obey the provided condition.</span><br></pre></td></tr></table></figure>
<p>合并表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">merged = pd.merge(left = elections, right = male_2020_babynames,</span><br><span class="line">left_on = &quot;First Name&quot;, right_on = &quot;Name&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>数据科学</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>基于北大前沿计算实践课和missing semester的vim笔记</title>
    <url>/2023/09/29/vim%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="you-are-your-dotfiles">you are your dotfiles</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch1.gif" /></p>
<h2 id="帮助">帮助</h2>
<p>按f1或命令行输入help开启在线帮助 &lt;Cw&gt;切换到另一个窗口q关闭窗口 <span id="more"></span></p>
<h2 id="编辑">编辑</h2>
<p>如之前所述，Vim最主要的编辑模式是Insert模式，想要修改文本，先将光标在Normal模式下移动到对应位置，然后再键入<code>i</code>进入Insert模式，在这个模式下添加或者删除文本。但是当我们需要修改的地方非常多时，每次都需要先移动光标再输入<code>i</code>就是一个相对麻烦的操作，因而Vim提供了一些命令将移动光标和进入Insert模式合成一步：</p>
<ul>
<li><code>i</code>在当前位置输入（光标前），<code>I</code>在行首输入</li>
<li><code>a</code>在光标后输入(append)，<code>A</code>在行尾输入</li>
<li><code>o</code>在当前行下新建一行输入，<code>O</code>在当前行上新建一行输入</li>
<li><code>c</code>+光标移动命令会先删除然后进入Insert模式，比如<code>cl</code>会删除下一个字符，<code>cw</code>会删除到单词尾，<code>c10l</code>会删除10个字符。此外，<code>ciw</code>会删除整个单词，<code>cc</code>会删除整行，<code>ci(</code>(change in)会删除小括号里的内容，<code>ca(</code>(change around)则会删除小括号以及小括号里的内容，这在修改代码里的字符串、修改函数变量之类的工作中极其有用</li>
<li><code>s</code>(substitute)会删除当前字符并进入Insert模式，等同于<code>cl</code></li>
<li><code>r</code>(replace)替换当前字母</li>
<li><code>p</code>把上次删除的行放置在当前位置</li>
</ul>
<p>进入Insert模式之后，Vim也有一些奇奇怪怪的命令，比如<code>&lt;C-h&gt;</code>等同于删除键，会删除前一个字符，<code>&lt;C-j&gt;</code>等同于回车键，将光标后的文本移到下一行，但是否要这样做就全凭个人喜好了。<br />
其实在Normal模式下也能进行一些删除操作，<code>x</code>会删除当前字符，<code>d</code>+光标移动命令会删除对应文本，与<code>s</code>以及<code>c</code>命令的区别仅仅在于<code>x</code>和<code>d</code>操作完之后依然处在Normal模式，所以<code>s</code>也等同于<code>xi</code>。此外，<code>r</code>的作用也是替换当前字符，键入<code>r</code>之后会提示输入一个字符，输入完成之后自动回到Normal模式，想要替换长文本就需要键入<code>R</code>进入Replace模式。因此如果想要替换一个字符成x，最快的方法是<code>r</code>+x，也可以<code>s</code>+x+<code>&lt;ESC&gt;</code>，也可以<code>xi</code>+x+<code>&lt;ESC&gt;</code>，也可以<code>cl</code>+x+<code>&lt;ESC&gt;</code>。<br />
撤销和重做也是非常常用的编辑命令，在Vim中分别对应Normal模式下的<code>u</code>(undo)和<code>U</code>，同时<code>.</code>可以重复之前最后一个命令。 “U”（行撤销）。恢复整行的所有操作 &lt;C-r&gt;重做上一个 被撤销的命令</p>
<h2 id="命令行">命令行</h2>
<p>在Normal模式下键入<code>:</code>就会进入命令行模式，此时光标已经移动到了最下面。命令行中可以输入的命令种类非常多：</p>
<ul>
<li><code>w</code>保存文件，但是不退出</li>
<li><code>w !sudo tee %</code>使用sudo保存文件 w filename保存文件到当前目录</li>
<li><code>wq</code>、<code>x</code>、<code>ZZ</code>保存并退出</li>
<li><code>q!</code>、<code>ZQ</code>退出但不保存</li>
<li><code>!</code>+命令 可以在shell环境下执行命令</li>
<li><code>r !</code>+命令 可以在shell环境下执行命令并插入到当前光标下一行</li>
<li><code>e</code>+文件 可以加载新的文件（当前文件没保存的话会报错）</li>
<li><code>e!</code>+文件 加载新文件并丢弃当前更改</li>
<li><code>f</code>显示当前文件的文件名</li>
<li><code>%s/old/new/g</code>搜索所有<code>old</code>并替代成<code>new</code>，支持正则表达式o 命令行界面输入&lt;Cd&gt;显示可以选择的命令，tab自动补全o</li>
</ul>
<h2 id="搜索">搜索</h2>
<p>除了这些直接跳转命令，Vim也提供了搜索机制。 首先是行内的搜索，<code>f</code>、<code>t</code>、<code>F</code>、<code>T</code>后面加上任意字符x，代表跳转到当前光标下一个x、跳转到下一个x之前、跳转到上一个x、跳转到上一个x之后，搜索到了之后也可以继续按<code>,</code>和<code>;</code>在搜索结果之间前后移动。 然后是文件内的搜索， 直接键入<code>/</code>或者<code>?</code>会进入命令行搜索模式，<code>/</code>是从开头开始搜索，<code>?</code>是从结尾开始搜索，后面可以加上任意长度的字符 然后键入<code>&lt;CR&gt;</code>就可以高亮显示所有的搜索结果，按<code>n</code>和<code>N</code>就可以在搜索结果之间向前和向后移动。 输入:set ic(ignore case)忽略大小写搜索 set noic取消 仅搜索一次忽略大小写:/search_sth\s 输入:set hls is高亮搜索结果 //'ic' 'ignorecase' ignore upper/lower case when searching</p>
<p>'is' 'incsearch' show partial matches for a search phrase</p>
<p>'hls' 'hlsearch' highlight all matching phrases 搜索模式支持正则表达式。最后如果想要关闭搜索结果的高亮，需要借助命令行命令，输入<code>:noh</code>即可关闭高亮。 type :#,#s/old/new/g where #,# are the line numbers of the range</p>
<p>of lines where the substitution is to be done.</p>
<p>Type :%s/old/new/g to change every occurrence in the whole file.</p>
<p>Type :%s/old/new/gc to find every occurrence in the whole file,</p>
<p>with a prompt whether to substitute or not.</p>
<h2 id="选择">选择</h2>
<p>编辑文本和代码难免要复制和粘贴，复制操作涉及到选择需要复制的文本，在Vim中这需要在Visual模式下进行。在Normal模式中键入<code>v</code>进入选择模式，可以跟在Normal模式下一样移动光标，被选择的文本就会高亮。 或者在Normal模式中键入<code>V</code>进入行选择模式，被选择的行会高亮。选择完成后，如果直接按<code>&lt;ESC&gt;</code>就会返回Normal模式，并且选择的内容高亮消失，因此不应该这么做，而应该直接在Visual模式下键入<code>y</code>(yank)复制高亮的文本，如果输入的是<code>d</code>则会删除被选择的文本，此时会自动回到Normal模式。 不管是<code>y</code>还是<code>d</code>操作，被选择的文本都会被操作到Vim的缓存中，在Normal模式下按<code>p</code>就会粘贴其中的文本到当前位置。与之前介绍的<code>cc</code>、<code>dd</code>类似，也可以直接在Normal模式下输入<code>yy</code>，对应复制当前行。<br />
Vim还提供了列选择模式，在Normal模式下键入<code>&lt;C-V&gt;</code>进入，选择完列之后可以跟Normal模式一样进行<code>r</code>、<code>d</code>等操作，这在制表、注释中非常有用。</p>
<h2 id="移动">移动</h2>
<p>Vim中所有键盘输入都可以视为命令，可以被记录下来映射到快捷键。在Normal模式下，最基本的命令是控制光标移动的命令<code>hjkl</code>，其中<code>jk</code>控制上下(大写状态下删除行间空格)，<code>hl</code>控制左右，方向键同样可以控制光标，但是因为方向键盘离打字的范围比较远，所以推荐大家熟悉<code>hjkl</code>这四个键。在没有鼠标的情况下想实现长距离的光标跳转，每次只能移动一个单位显然是低效的，好在Vim为光标跳转提供了多种命令：</p>
<ul>
<li><p>单词间：<code>w</code>可以跳转到下一个单词的开头，<code>b</code>跳转到当前单词的开头，继续按跳转到上一个单词的开头，<code>e</code>跳转到当前单词的结尾，继续按跳转到下一个单词的结尾</p>
<blockquote>
<p>遗憾的是中文很难分词，所以在中文中键入<code>w</code>会跳转到下一个短句</p>
</blockquote></li>
<li><p>括号、引号间：如果光标在括号或者引号中间，<code>%</code>会高亮显示括号或引号，继续按会在头和尾反复横跳</p></li>
<li><p>行内：<code>0</code>跳转到行的开头，<code>^</code>跳转到行的第一个非空格的字符，<code>$</code>跳转到行的结尾</p></li>
<li><p>段落间：<code>&#123;</code>跳转到上一段，<code>&#125;</code>跳转到下一段</p></li>
<li><p>屏幕内：<code>H</code>跳转到屏幕最上面，<code>M</code>跳转到屏幕最中间，<code>L</code>跳转到屏幕最下面</p></li>
<li><p>屏幕滑动：<code>&lt;C-u&gt;</code>向上滑动，<code>&lt;C-d&gt;</code>向下滑动</p></li>
<li><p>文件内：<code>gg</code>跳转到文件开头，<code>G</code>跳转到文件结尾,</p></li>
<li><p>&lt;CG&gt;显示当前行数，数字G跳转到对应行</p></li>
<li><p>其他：<code>zz</code>会将光标置于屏幕中心</p></li>
</ul>
<p>这些基本命令可以和数字进行组合，输入任意数字（默认情况下显示在右下角），然后输入<code>j</code>就会向下移动对应行数，同理，如果是数字+<code>w</code>，就会移动对应单词数。另外，数字+<code>&lt;CR&gt;</code>等同于数字+<code>j</code>，数字+<code>G</code>会跳转到整个文件的第几行。</p>
<h2 id="模式">模式</h2>
<p>Normal模式是最基本的模式，在这个模式下基本只能移动光标，不能直接输入文本，因为此时键入任何字符都会被当成是Vim的命令而非插入到文本中。想要输入文本需要切换到Insert模式，可以直接键入<code>i</code>进入Insert模式，此时输入任何字符都会插入到光标所在位置。想从输入模式中返回Normal模式，只需要键入<code>&lt;ESC&gt;</code>。事实上，在任何模式下键入<code>&lt;ESC&gt;</code>都 能回到Normal模式。Normal模式和Insert模式是Vim中最常用的两种模式，理论上我们只需要这两种模式就能完成修改文本的所有操作，其他 模式和命令都是用来更快地完成一些任务。默认情况下，所处模式会显示在Vim窗口的左下角，Normal模式没有显示，Insert模式会显示<code>--INSERT--</code>，Command-line模式会显示所输入的命令等等。在Normal模式下键入<code>R</code>进入Replace模式，用于替换当前光标处的文本，键入<code>v</code>进入Visual模式，用于选择文本。</p>
<figure>
<img src="/images/obsidian/vim-mode.jpg" title="image" alt="" /><figcaption>图片</figcaption>
</figure>
<h2 id="进阶">进阶</h2>
<p>.命令重复上一次命令，可用于简化操作</p>
<ul>
<li>C=c$</li>
<li>s=cl</li>
<li>S=^C//整行替换</li>
<li>I=^i</li>
<li>A=$a</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>麻省理工</tag>
        <tag>北京大学</tag>
        <tag>编程工具</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉rpg设定集</title>
    <url>/2023/09/29/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89rpg%E8%AE%BE%E5%AE%9A%E9%9B%86/</url>
    <content><![CDATA[<h1 id="队友">队友</h1>
<h2 id="雷克">雷克</h2>
<p>帝国法律系学生，成长于如今兄弟会的前身，幼时被走投无路的父母托付给了盗贼兄弟会，并经受了盗贼训练，随后由于帝国发展进程，盗贼兄弟会决定洗白自己，于是选拔了手下聪明的学徒接受高等教育并改名兄弟会，雷克就是其中的佼佼者。</p>
<span id="more"></span>
<p>然而比起兄弟会肮脏的勾当，接触帝国新兴教育的雷克逐渐有了叛逆之心，比起法律他对医学更有兴趣，一开始是偷一些新鲜死体进行解剖，随后甚至发展成了诛杀一些地痞流氓并进行各种实验和解剖的连环杀人犯，因为这些经历，雷克下手狠辣，反应敏捷，是个优秀的盗贼。</p>
<p>偷挖尸体时被无名氏发现，并且无名氏的强大气息让他不敢敌对，由于无名氏缺少一个熟悉帝国的向导，雷克就这样被要挟着加入了队伍</p>
<p>性格意外地开朗，似乎是个不错的朋友，但很难定论他的内心藏着多少黑暗 阵营守序中立</p>
<h2 id="莉思">莉思</h2>
<p>法师塔的高材生，学徒转正的试炼中，大法师们补下幻象，让她对决所有的同届学生，想让她意识到团结的力量，但聪明的她早就对所有人做了各种应对方案，在随机应变和一些运气下，莉思真的击败了所有对手，并且由于情况危急，她下了死手。</p>
<p>试炼完成后，在场的法师们不约而同地认识到她危险的性格是个定时炸弹，想要剥夺她的法师资格，绝望的莉思却听到了一个神秘的声音，随着声音的指引她发动了不可能成功的传送法术去到了帝国边境。</p>
<p>在那里她隐姓埋名，用几年时间成为了一位名气不小的实战派法师，随后遇到了无名氏。</p>
<p>“你身上有强大法术的气息，让我感到熟悉,我希望能与你同行”</p>
<p>阵营中立邪恶</p>
<h2 id="默克">默克</h2>
<p>因为违反规则，徘徊于主物质界的欲灵</p>
<p>欲灵必须满足驯服他们的人类的三个愿望，但如果另一个欲灵驯服了他呢？结果就是他被规则诅咒只能徘徊于主物质界。</p>
<p>有一个欲灵伪装成人类向他许愿，这个愿望则来自一个驯服他的人类，也就是无名氏，因此才出现了这种错误。</p>
<p>这个愿望是忘记一切过去，但不知为何空间也出现了扭曲，实现愿望后，无名氏和默克被传送到一座古墓，醒来的无名氏逮住了他，思考后默克决定与他行动，寻找那个肆意妄为的欲灵。</p>
<p>为了不引发好奇，设置了一个猫头鹰幻身</p>
<p>阵营混乱中立</p>
<h2 id="欲灵女王">欲灵女王</h2>
<p>传闻中她是一个强大的欲灵，因此能统率大批同类为其所用，但实际上她只是一个人类法师，因为善于倾听欲灵的烦恼并安抚它们，她曾让不少欲灵摆脱了由于灵魂不纯而徘徊物质界与元素界之间的痛苦，作为回报，欲灵们生前的回忆与知识有部分被她所理解，因此论阅历属于当世法师的佼佼者。</p>
<p>其自称自己的天赋一般，并对胜负毫不在意，所以，平常不会显露出多强的实力，但总感觉她留了一手</p>
<p>年龄未知，自称对玩弄无名氏的欲灵感兴趣而与他同行</p>
<p>阵营中立善良</p>
<h1 id="npc">npc</h1>
<h2 id="苦惨女士">苦惨女士</h2>
<p>"去杀戮，去破坏，去抢夺吧，除此以外没有获得救赎的办法了，而我会在此，为您承担所有的罪孽"</p>
<p>对七苦圣母的信仰，由于教规和神迹的苛刻，在几百年间逐渐地消失了，苦惨之女，数百年前经过血祭仪式得到圣母祝福之人，如今以及经过了她第七个，也是最后一个人生，苦恼着如何度过最后时日的她遇到了无名氏，在他身上纠缠着的痛苦命运让她深受感化。</p>
<p>“或许经历这样的痛苦才能有所领悟"</p>
<p>因此她向无名氏提出了请求，再次进行仪式，让她承担无名氏战斗时收到伤害的一半。</p>
<p>在伤害积累到一定程度后，她会死去，并在死后继续赋予无名氏减伤的祝福 如果拒绝她，或者积累的伤害不够，苦惨女士由于没有领悟到七苦之义，在之后的时日度过了平凡而幸福的一生。</p>
<h2 id="笑脸人">笑脸人</h2>
<blockquote>
<p>"只要我想，我可以集中注意力施法一整天，但谁也不边笑边念咒语，是吧？"</p>
</blockquote>
<p>笑脸人的本名未知，他很小的时候就被带进法师塔作为实验品了，那些法师想寻找让法师长时间保持专注的方法，通过勤奋的实验和运气，他们成功了，笑脸人几乎没有感情，可以长时间保持专注，除了他过剩的幽默感，他越是专注，越会不由自主地笑出来，这让他无法念出大部分法术的咒语，不过据他所说还是用了几个小法术逃出了法师塔，法师们也懒得找一个失败的实验品。</p>
<p>于是笑脸人去了剧场，没有比他更敬业且称职的恐怖剧演员了</p>
<p>笑脸人会让无名氏去法师塔寻找那些改造他的法师，不是为了复仇，而是他永久不变的笑声开始让观众厌烦了，他想要控制自己的笑声，如此才能在演艺道路上更上一层楼</p>
<h2 id="死者之王">死者之王</h2>
<p>亡灵，那些对生前抱有强烈执念的人，回忆总会让他们痛苦，但正是回忆构成了他们存在的基石。</p>
<p>起初的亡灵多半是离散地在迪瑞克拉的各处游荡，随着时间发展，人类建立起了秩序，而相应的死者们也逐渐有了秩序的概念，于是亡灵们逐渐组织了起来，虽然成型的时间晚于人类帝国，但死者们在一些阴暗的角落也建立起了自己的国家。</p>
<p>一些暴戾的亡灵们逐渐组织了起来，想要对生者发动战争，似乎又一场战争在酝酿，但就在这时，一个神秘的亡灵异军突起，统一了亡灵的势力，它被称为死者之王，很少有人真正见过它。</p>
<p>出乎意料的是死者之王是个和平主义者，在为亡灵带来秩序的同时，它教导亡灵们思考与智慧，它们有近乎永恒的时间这么做，更何况，思考和学习能让它们暂时忘却痛苦的过往（彻底的忘却也意味着亡灵的死）</p>
<p>死者的国度变得沉默而睿智，甚至一些隐世的学者也慕名而去交流，寻访到死者的国度很难，并且也没有回来的人，至少在帝国的所知范围内没有。 无名氏需要睿智而博学的死者之王的解答，而相应的，死者之王提出了一个要求——到我的回忆中去一趟。</p>
<h1 id="世界观">世界观</h1>
<h2 id="无数之战">无数之战</h2>
<p>这场战争战死了无数人，这样说是因为，大部分识数的人都死在了持续不断的战争和屠杀中，剩下的部队没有能力统计作战数据，这让后续的历史学家和战争学家痛苦不已，并且为很多学者的毕业论文提供了素材。</p>
<p>艰难的胜利后，指挥官，也就是日后王国的统治者决定在十年内把学校的数量增加到战前的十倍，这在日后造成了不少问题。</p>
<h2 id="号研究所">0号研究所</h2>
<p>那场浩劫后如今只剩下废墟，然而，似乎留存下了一些不属于主物质界的魔法气息，这引起了法师塔的关注，无名氏也得知了这个消息</p>
<h2 id="世界局势">世界局势</h2>
<p>北方的蛮人赢得独立后就一直在稳定地壮大，正如帝国的发家史一样，一位杰出的领袖应运而生，事实上统一了各个部落，蛮人们正在厉兵秣马，备战复仇，这在诸国的情报圈里已经不是秘密了</p>
<p>隐没于群山中的矮人和精灵表面上没有什么大动作，尽管越来越多的经济学家指出，矮人对帝国金融的渗透已经达到了急需警惕的程度，矮人们的银行开遍了帝国的主要城市，并且根据地下情报，矮人们储存了大量的黄金以及其他充作等价物的贵金属以及流通货币，还有可怕的工业产能，随时可以对帝国发起一场没有硝烟的金融战争</p>
<p>精灵可能是帝国面临的所有威胁中最隐秘而可怕的，它们一直在有计划地挖角那些不得志的法师还有叛逃的野法师，情报指出，以保守和团结著称的精灵竟然发生了分裂，保守派们留在原来的领地，而改革派们则分离出去，进行一项隐秘的研究，还有什么比不再故步自封的精灵更可怕呢？这引起了帝国的警惕，然而，法师塔对精灵们的态度也颇为暧昧，精灵们是很多高级魔法研究的设备供应商，法师们想要毕业，或者更高的学术成果就必须仰仗他们。</p>
<p>而帝国内部呢，贵族们形成了根深蒂固的旧势力，法师们利用先代皇帝对教育的重视崛起，成为王城的新贵，随着魔法教育的普及，现在他们染指王权的野心愈加明显，据说首席法师想让自己的女儿成为根基不稳的新帝的王后，和旧贵族媾和还是成为法师们的傀儡，对新任皇帝来说这是个难题</p>
<h2 id="法师的野心">法师的野心</h2>
<p>所谓的文明就是坐在餐桌上吃人，迪瑞克拉帝国可谓深谙其中道理，随着帝国对教育业的投入和技术的进步，法师们的势力进一步发展，法师塔在事实上成为了帝国学术界的领头者，并且积极参与进新一轮的首都城建，，一方面这推进了法术的世俗化，但另一方面，原本朦胧的魔法在面纱被揭下后，暴露出的却是血淋淋的事实，随着人们对法师的身份趋之若鹜，入场券也变得愈发昂贵起来，除了少数特权者，法师的头衔需要大量学术成果的支持，而这就意味着大规模的实验需求，地精之类的类人生物尸体堆满了下水道，一到闷热天气就臭气熏天，城建部的部长找上了法师塔，最终法师们保证会定期在荒地焚烧尸体。部分不那么守旧的贵族开始资助法师，培养自己的新势力，又或者被法师塔彻底吃下，一些昂贵且血腥的前沿技术被用在他们身上。当权者们发现法师清高的传言可谓毫无可信度，它们野心勃勃，虽然手段不那么成熟，对权力的贪婪却不输其他的贪官污吏，与外敌暧昧不清的同时，大法师们开始密谋帝国的最高权力</p>
<p>​走投无路的穷人开始暴动，被学阀门压迫的学徒也怨声载道，但这远远不是帝国目前最大的问题……</p>
<h1 id="神话人物">神话人物</h1>
<h2 id="七苦圣母">七苦圣母</h2>
<p>在迪瑞克拉的蛮荒时代，生存是非常痛苦的一件事， 秩序总是难以对抗混乱，混乱的思绪在这个世界游荡，时常会由思绪转化为现实，产生种种不可名状的灾难。</p>
<p>根据现存的神话记载，七苦圣母一开始只是个凡人，尽管我们难以确定当时的住民有没有完全从思维体转换成实体，面对世人的受难，她站了出来，献祭了自己来稳定迪瑞克拉的存在，这才有了现在稳定成现实态的迪瑞克拉 这个故事有很多暧昧不清的地方，但帝国史学界官方采用了这个说法，由于过于简略和缺乏证据，七苦圣母被视作一个不可信的杜撰传说。</p>
<p>然而，出于对'元魔法'的研究，很多法师都在探求隐秘的神话，以及一些执着于真相的史学家也对各种语焉不详的神话有兴趣，对七苦圣母的研究零零散散地进行着。</p>
<p>……</p>
<p>总而言之，可以初步得出这样一个结论，被称为七苦圣母的个体切实存在过，她首个发现，秩序向非秩序的转变是不可逆的过程，因此，想要维护一个秩序的局部系统，必须'献祭'总体其他部分的秩序性，意识到这点后，她使用了被法师们称为'元魔法'的方法，将自己献祭给了混乱，创造出一片秩序之地，部分其他先民也受其感召，用同样的方法扩大这个秩序之地的存在，又或者再创造出一片秩序。长此以往，就形成了一整片稳定的秩序区域。以当时的条件来说，由于世界并不稳定，对'元魔法'的研究和使用远比现在要简单。</p>
<p>此外，在当时，这个个体只是被称为'献祭者'，并没有七苦圣母的说法，也很难确定这个个体真正的性别，年龄，种族等信息。</p>
<p>七苦圣母献祭自我创造出的秩序，正是现在的帝国领土的雏形，这解释了为何外族极少有七苦圣母的类似记载。</p>
<p>并且，根据法师们提供的资料，很可能这些先民的意识仍有部分留存在边界，维持秩序和混乱的界限。</p>
<p>但为何七苦圣母的信仰到现在如此式微呢？以下是我个人结合其他资料的猜测</p>
<p>对当时留在秩序区的民众来说，他们有两个选择，一是铭记圣母等人的牺牲，良心受到痛苦的折磨，二是忘记一切，开始新生活。</p>
<p>一开始，对圣母的信仰非常简单，热忱且纯粹，人民崇敬和感谢圣母，但随着历史的演变，宗教愈加世俗化，人民也不想再被愧疚的痛苦折磨，出现类似教会的组织制造出'七苦圣母'这个称号，并且把教义由纯粹的感恩，变成了献祭和受苦，并且后者的占比更越来越大。</p>
<p>宗教政治化的同时，政治也在宗教化，于是进入了旷日持久的宗教与政治战争时期，歪曲后的教义和大部分宗教并没有什么不同，而在强权面前，记忆也是可以随便更改的，因此，'献祭者'被歪曲成了七苦圣母，而七苦圣母则在某次宗教对抗或者政治对抗中出局了，这就是七苦圣母信仰的始末。</p>
<p>对本资料的处理意见：永久封存 ——帝国大学史学系内部资料</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>基于中科大linux101和苏大ppt的linux笔记</title>
    <url>/2023/10/14/%E8%8B%8F%E5%A4%A7linux_ppt/</url>
    <content><![CDATA[<h1 id="苏大部分">苏大部分</h1>
<h2 id="文件系统">文件系统</h2>
<h3 id="命名">命名</h3>
<p>•除/之外，所有的字符都合法</p>
<p>•大小写敏感</p>
<p>•有些字符最好不用，如空格符、制表符、退格符和字符：？, @ # $ &amp; ()  | ; ‘ ’ “ ” &lt; &gt;</p>
<p>•避免使用＋、－或. 来作为普通文件名的第一个字符</p>
<p>•可以使用长文件名或目录名（255个字符）</p>
<p>包括完整路径的文件名不超过4096字符 <span id="more"></span></p>
<h3 id="目录">目录</h3>
<table>
<tbody>
<tr class="odd">
<td>bin</td>
<td>存放二进制的可执行程序</td>
</tr>
<tr class="even">
<td>boot</td>
<td>存放用于系统引导时使用的各种文件</td>
</tr>
<tr class="odd">
<td>dev</td>
<td>存放设备文件，用户通过这些文件访问外部设备</td>
</tr>
<tr class="even">
<td>etc</td>
<td>存放系统的配置文件</td>
</tr>
<tr class="odd">
<td>home</td>
<td>存放用户文件的目录，每个用户在该目录下有一个与该用户名对应的子目录</td>
</tr>
<tr class="even">
<td>root</td>
<td>超级用户目录</td>
</tr>
<tr class="odd">
<td>sbin</td>
<td>类似于/bin目录，存放二进制文件，只有root才能访问</td>
</tr>
<tr class="even">
<td>tmp</td>
<td>用于放置各种临时文件</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td>var</td>
<td>用于存放需要随时改变的文件，如系统日志、脱机工作目录等</td>
</tr>
<tr class="even">
<td>mnt</td>
<td>系统管理员安装临时文件系统的安装点</td>
</tr>
<tr class="odd">
<td>opt</td>
<td>一般情况下，该目录不属于系统的基本文件系统，是额外安装的应用程序包所放置的地方</td>
</tr>
<tr class="even">
<td>usr</td>
<td>用于存放系统应用程序</td>
</tr>
<tr class="odd">
<td>lib</td>
<td>存放根文件系统中的程序运行所需要的共享库及内核模块</td>
</tr>
<tr class="even">
<td>proc</td>
<td>是一个虚拟文件系统，存放当前内存的映射，主要用于在不重启机器的情况下管理内核</td>
</tr>
<tr class="odd">
<td>lost+ found</td>
<td>存放一些系统检查结果，发现不合法的文件或数据都存放在这里，通常此目录是空的，除非硬盘遭到损坏</td>
</tr>
</tbody>
</table>
<h3 id="链接文件">链接文件</h3>
<ul>
<li><p>硬链接 将两个文件名指向硬盘上同一个存储空间（inode），对任何一个文件的修改都将影响到另一个文件。 特性： 文件有相同的 inode 及 data block； 只能对已存在的文件进行创建； 不能交叉文件系统进行硬链接的创建； 不能对目录进行创建，只可对文件创建； 删除一个硬链接文件并不影响其他有相同 inode 号的文件。</p></li>
<li><p>符号链接 又称软链接，是指将一个文件指向另外一个文件的文件名。 特性： 软链接有自己的文件属性及权限等； 软链接可对文件或目录创建； 可对不存在的文件或目录创建软链接； 软链接可交叉文件系统； 若被指向的原文件被删除，则相关软连接被称为死链接 删除软链接并不影响被指向的文件，若被指向路径文件被重新创建，死链接可恢复为正常的软链接</p></li>
</ul>
<p><code>符号链接可以跨文件系统，即可以跨磁盘分区。硬链接不可以跨文件系统。它只能建立对文件的链接。</code> 链接文件命令  ln</p>
<table>
<tbody>
<tr class="odd">
<td>ln file1 file2</td>
<td>创建源文件file1的硬链接file2</td>
</tr>
<tr class="even">
<td>ln -s file1 file2</td>
<td>创建源文件file1的软链接file2</td>
</tr>
</tbody>
</table>
<p>符号链接可以跨文件系统，即可以跨磁盘分区。 硬链接不可以跨文件系统，只能建立对文件的链接。 硬链接删除只原文件或硬链接不影响文件内容 软连接删除源文件导致链接失效</p>
<h3 id="mbr">MBR</h3>
<p>硬盘的第一个扇区存有主引导记录(Master boot record, MBR)及分区表(partition table)</p>
<ul>
<li>MBR用于引导操作系统， 446 bytes ；</li>
<li>partition table用于记录分区信息， 64 bytes ； 一个MBR分区表类型的硬盘最多存在4个主分区，每个分区项占用16个字节 如果分区超过4个，则需要使用扩展分区，即一个物理硬盘上最多有3个主分区和1个扩展分区。 扩展分区不能直接使用，必须分割成为逻辑分区，一个扩展分区中的逻辑分区可以任意多个。</li>
</ul>
<h3 id="gpt">GPT</h3>
<p>全称全局唯一标识分区表 GUID Partition Table</p>
<ul>
<li>主分区数量任意（Win 128个）</li>
<li>支持最大18EB（NTFS 256TB） 1EB=1024PB=1,048,576TB 可能需要EFI支持（Win、Mac）</li>
</ul>
<h3 id="ext2">ext2</h3>
<p>磁盘分区完毕后还需要进行格式化(format)，不同操作系统默认的文件系统不同，所以需要格式化成不同格式的分区。 EXT2（second extended filesystem）是LINUX内核默认的文件系统。 EXT2中的主要构成： •SuperBlock  记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等； •Block   实际记录文件的内容，若文件较大，则占用多个 block。 •Inode   记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码</p>
<h4 id="inode">inode</h4>
<p>ext2 创建一个目录时，分配1个 inode 与至少1块 block 给目录 •inode 记录目录权限与属性，并记录分配到 block号码 •block 记录目录下文件名与该文件名占用的 inode</p>
<p>inode 数量与大小在格式化时固定 特征：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes；</li>
<li>每个文件仅占用一个 inode；</li>
<li>文件系统能够创建的文件数量与 inode 的数量有关；</li>
<li>系统读取文件时先找到 inode，分析 inode 所记录的权限与用户是否符合，若符合读取 block 的内容。 <img src="/assets/苏大linux_ppt/image-20231014145226727.png" /></li>
</ul>
<h4 id="升级">升级</h4>
<p><code>EXT2</code>文件系统高效稳定，但不提供日志 <code>EXT3</code> 提供日志模式： data=journal模式 对所有的文件数据及metadata（定义文件系统中数据的数据,即数据的数据）进行日志记录 data=ordered或data=writeback模式 只对metadata记录日志，而不对数据进行日志记录</p>
<p><code>EXT4</code> EXT3的扩展升级，可以提供更佳的性能和可靠性，包括支持更大的分区和文件大小，更快的文件操作速度。</p>
<h3 id="实例">实例</h3>
<h4 id="fdisk">fdisk</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           fdisk      [-options]     &lt;disk&gt;</span><br><span class="line">选项：</span><br><span class="line">-l 列出分区信息表</span><br><span class="line">/dev/sda    对sda磁盘进行分区</span><br></pre></td></tr></table></figure>
<p>中科大的xubuntu镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ustc@ustclug-linux101:~/桌面$ sudo fdisk -l</span><br><span class="line">[sudo] ustc 的密码： </span><br><span class="line">Disk /dev/sda：5 GiB，5368709120 字节，10485760 个扇区</span><br><span class="line">Disk model: VMware Virtual S</span><br><span class="line">单元：扇区 / 1 * 512 = 512 字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：gpt</span><br><span class="line">磁盘标识符：12526913-E330-4CA7-A379-90A87EF858B0</span><br><span class="line"></span><br><span class="line">设备         起点     末尾    扇区  大小 类型</span><br><span class="line">/dev/sda1    2048   499711  497664  243M EFI 系统</span><br><span class="line">/dev/sda2  499712 10483711 9984000  4.8G Linux 文件系统</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="mkfs格式化">mkfs格式化</h4>
<p>mkfs      [-t 磁盘格式名]     &lt;partition&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs  -t ext3  /dev/sdb1</span><br></pre></td></tr></table></figure>
<h4 id="mount挂载">mount挂载</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [-t vfstype] [-o options]    device    <span class="built_in">dir</span></span><br><span class="line">mount                         显示所有挂载的信息</span><br><span class="line"></span><br><span class="line">mount –a                   将所有未挂载设备挂载</span><br><span class="line"></span><br><span class="line">mount   /dev/hda2   /mnt/myhd2    将hda2设备挂载到/mnt/myhd2</span><br><span class="line"></span><br><span class="line">mount -t iso9660 /dev/cdrom  /media/cdrom  挂载光驱</span><br><span class="line">umount [选项] <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-f     强制卸载</span><br><span class="line"></span><br><span class="line">-all   卸载所有挂载</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br><span class="line">umount  /media/cdrom     卸载刚才挂载的光驱</span><br></pre></td></tr></table></figure>
<h2 id="shell">shell</h2>
<h3 id="重定向">重定向</h3>
<p>lLinux启动后，默认打开3个文件描述符 •标准输入：standard input   0 •标准输出：standard output  1 •错误输出：error output     2 每条shell命令执行，都会继承父进程的文件描述符。因此，所有运行的shell命令，都会有默认3个文件描述符。 <code>重定向</code> 是指不使用系统的标准输入，标准输出或标准错误端口，而重新指定输入输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入重定向</span><br><span class="line"></span><br><span class="line">&lt;          输入重定向，从普通文件获取</span><br><span class="line"></span><br><span class="line">&lt;&lt;!...!    输入重定向， here文件，即从命令行获取</span><br><span class="line"></span><br><span class="line">输出重定向</span><br><span class="line"></span><br><span class="line">&gt;          输出重定向，覆盖模式</span><br><span class="line"></span><br><span class="line">&gt;&gt;         输出重定向，追加模式</span><br><span class="line"></span><br><span class="line">2&gt;         错误重定向，覆盖模式</span><br><span class="line"></span><br><span class="line">2&gt;&gt;        错误重定向，追加模式</span><br><span class="line"></span><br><span class="line">&amp;&gt;         同时实现输出重定向和错误重定向，覆盖模式</span><br><span class="line"></span><br><span class="line">&amp;&gt;&gt;        同时实现输出重定向和错误重定向，追加模式</span><br></pre></td></tr></table></figure>
<h3 id="管道">管道</h3>
<p>管道是一种两个进程间进行单向通信的机制 每个命令的输出作为下一条命令的输入，管道线中的命令从左到右顺序执行的，管道线是单向的 因为管道传递数据的单向性，管道又称为半双工管道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls –l | wc -l</span><br></pre></td></tr></table></figure>
<h3 id="命令替换">命令替换</h3>
<p>Shell中的命令参数可以由另一个命令执行的结果来替代</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cmd1 `cmd2  arguments`</span><br><span class="line">或</span><br><span class="line">$cmd1 $(cmd2 arguments)</span><br></pre></td></tr></table></figure>
<p>其中cmd2  arguments的输出作为cmd1的参数y</p>
<h3 id="命令聚合">命令聚合</h3>
<p>在一个命令行上使用若干shell元字符将若干命令聚合在一起运行。</p>
<p>执行聚合的几种方式：</p>
<p>•<code>cmd1;cmd2</code>   顺序执行若干命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd;date;ls</span><br></pre></td></tr></table></figure>
<p>•<code>cmd1&amp;&amp;cmd2</code> 当cmd1运行成功时才运行cmd2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip mylargefile&amp;&amp;echo &quot;OK.&quot;</span><br></pre></td></tr></table></figure>
<p>•<code>cmd1||cmd2</code>   当cmd1运行失败时才运行cmd2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip mylargefile||echo &quot;FALSE.&quot;</span><br></pre></td></tr></table></figure>
<p>•<code>(cmdlist)</code>   在子shell中执行命令序列，命令不影响当前shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(date;who|wc -l)&gt;~/login-users.log</span><br></pre></td></tr></table></figure>
<h2 id="用户系统">用户系统</h2>
<ul>
<li><p>普通用户账户：在系统上的任务是进行普通工作</p></li>
<li><p>超级用户账户：在系统上的任务是对普通用户和整个系统进行管理。</p></li>
<li><p>系统用户账户：伪用户，并不能登录，由操作系统自己操作。 每个用户都被分配了一个唯一的用户ID号（UID）</p></li>
<li><p>超级用户：UID=0，GID=0</p></li>
<li><p>普通用户：UID&gt;=500(有的系统是1000)</p></li>
<li><p>系统用户（伪用户，不可登录）：0&lt;UID&lt;500（有的系统是1000）</p></li>
</ul>
<p>用户名和 UID 被保存在 /etc/passwd 这个文件中</p>
<h3 id="组">组</h3>
<ul>
<li>组是用户的集合</li>
<li>每个组都被分配了一个唯一的组ID号（GID）</li>
<li>组和GID 被保存在 /etc/group 文件中</li>
<li>每个用户都有他们自己的私有组</li>
<li>每个用户都可以被添加到其他组中来获得额外的存取权限</li>
<li>组中的所有用户都可以共享属于该组的文件</li>
<li>当一个用户同属于多个组时，将这些组分为：
<ul>
<li>主组（初始组）：用户登录系统时的组</li>
<li>附加组：可切换的其他组</li>
</ul></li>
</ul>
<h3 id="权限管理">权限管理</h3>
<p>被加密后的密码实际上储存在/etc/shadow中 组口令则储存在/etc/gshadow 用户管理相关命令： useradd , userdel, usermod ,passwd ,chage ,su,sudo groupadd, groupdel, groupmod 权限管理相关命令：</p>
<ul>
<li>权限设定命令 chmod</li>
<li>修改文件的属主和/或组命令 chown</li>
<li>修改文件的所属组命令 chgrp</li>
</ul>
<h1 id="linux101">linux101</h1>
<p><img src="/assets/苏大linux_ppt/clitool.png" /></p>
<h2 id="apt">apt</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt search firefox</span><br><span class="line">Sorting... Done</span><br><span class="line">Full Text Search... Done</span><br><span class="line">(Output omitted)</span><br><span class="line"></span><br><span class="line">firefox/bionic-updates,bionic-security,now 72.0.2+build1-0ubuntu0.18.04.1 amd64</span><br><span class="line">  Safe and easy web browser from Mozilla</span><br><span class="line"></span><br><span class="line">(Output omitted)</span><br></pre></td></tr></table></figure>
<p>中间两行每个字段的含义：</p>
<table>
<thead>
<tr class="header">
<th>样例中的字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>firefox</code></td>
<td>即为在软件仓库中的包名</td>
</tr>
<tr class="even">
<td><code>bionic-updates,bionic-security,now</code></td>
<td>为包含这个软件包的仓库源</td>
</tr>
<tr class="odd">
<td><code>72.0.2+build1-0ubuntu0.18.04.1</code></td>
<td>为软件包的版本</td>
</tr>
<tr class="even">
<td><code>amd64</code></td>
<td>软件包的架构；还可能为<code>i386</code>、<code>all</code>等</td>
</tr>
<tr class="odd">
<td><code>Safe and easy web browser from Mozilla</code></td>
<td>在软件仓库中对这个软件包的描述</td>
</tr>
</tbody>
</table>
<div class="note warning"><p>请避免直接使用 <code>dpkg -i</code> 安装 deb 包。 在绝大多数情况下，都应该使用 <code>apt</code> 来安装 deb 文件。 如果不小心执行了 <code>dpkg -i</code> 导致系统出现依赖问题，可以尝试通过如下的方式调用 <code>apt</code> 帮助修复依赖管理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt -f install</span><br></pre></td></tr></table></figure>
</div>
<h2 id="环境变量">环境变量</h2>
<p>我们不能每次在需要编译程序的时候输入如此长的路径找到 <code>clang</code> 和 <code>clang++</code>，而更希望的是能够像 <code>apt</code> 那样在任何地方都可以直接运行。</p>
<p>我们可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将 clang+llvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04 目录下的所有内容复制到 /usr/local/ 下</span><br><span class="line">sudo cp -R * /usr/local/</span><br></pre></td></tr></table></figure>
<p>为什么是 <code>/usr/local</code> 呢？因为 <code>/usr/local/bin</code> 处在 PATH 环境变量下。当我们在终端输入命令时，终端会先判断是否为终端的内建命令，如果不是，则会在 $PATH 环境变量中包含的目录下进行查找。因此，只要我们将一个可执行文件放入了 $PATH 中的目录下面，我们就可以像 <code>apt</code> 一样，在任意地方调用我们的程序。 通过这个命令可以看到当前的 PATH 环境变量有哪些目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>
<p>在上面的复制过程中，源目录和目标目录的两个 <code>bin</code> 目录会相互合并，<code>clang</code> 和 <code>clang++</code> 两个可执行文件也就被复制到了 <code>/usr/local/bin/</code> 目录中。这样子也就达到了我们希望能够在任意地方调用我们的可执行文件的目的。此外，在复制的时候 lib、doc 等文件夹也会和 <code>/usr/local</code> 下的对应目录合并，将 clang 的库和文档加到系统当中。</p>
<h2 id="模式匹配">模式匹配</h2>
<p>许多现代的 shell 都支持一定程度的模式匹配。举个例子，bash 的匹配模式被称为 <a href="https://mywiki.wooledge.org/glob">glob</a>，支持的操作如下：</p>
<table>
<thead>
<tr class="header">
<th>模式</th>
<th>匹配的字串</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*</code></td>
<td>任意字串</td>
</tr>
<tr class="even">
<td><code>foo*</code></td>
<td>匹配 foo 开头的字串</td>
</tr>
<tr class="odd">
<td><code>*x*</code></td>
<td>匹配含 x 的字串</td>
</tr>
<tr class="even">
<td><code>?</code></td>
<td>一个字符</td>
</tr>
<tr class="odd">
<td><code>a?b</code></td>
<td><code>acb</code>、<code>a0b</code> 等，但不包含 <code>a00b</code></td>
</tr>
<tr class="even">
<td><code>*.[ch]</code></td>
<td>以 .c 或 .h 结尾的文件</td>
</tr>
</tbody>
</table>
<div class="note info no-icon"><p>除了上面提到的 glob，bash 还支持 <a href="https://www.linuxjournal.com/content/bash-extended-globbing">extglob</a>，不过需要先用 <code>shopt -s extglob</code> 启用。</p>
</div>
<h2 id="进程">进程</h2>
<h3 id="htop">htop</h3>
<p>Htop 可以简单方便查看当前运行的所有进程，以及系统 CPU、内存占用情况与系统负载等信息。</p>
<p>使用鼠标与键盘都可以操作 htop。Htop 界面的最下方是一些选项，使用鼠标点击或按键盘的 F1 至 F10 功能键可以选择这些功能，常用的功能例如搜索进程（F3, Search）、过滤进程（F4, Filter，使得界面中只有满足条件的进程）、切换树形结构/列表显示（F5, Tree/List）等等。</p>
<p><strong>进程标识符</strong>（PID，Process Identifier（是一个数字，是进程的唯一标识。在 htop 中，最左侧一列即为 PID。当用户想挂起、继续或终止进程时可以使用 PID 作为索引。</p>
<p>在 htop 中，直接单击绿色条内的 PID 栏，可以将进程顺序按照 PID 升序排列，再次点击为降序排列，同理可应用于其他列。</p>
<div class="note info no-icon"><p>按照 PID 排序时，我们可以观察系统启动的过程。Linux 系统内核从引导程序接手控制权后，开始内核初始化，随后变为 <strong>init_task</strong>，初始化自己的 PID 为 0。随后创建出 1 号进程（init 程序，目前一般为 systemd）衍生出用户空间的所有进程，创建 2 号进程 kthreadd 衍生出所有内核线程。随后 0 号进程成为 idle 进程，1 号、2 号并非特意预留，而是产生进程的自然顺序使然。</p>
<p>由于 kthreadd 运行于内核空间，故需按大写 K（Shift + k）键显示内核进程后才能看到。然而无论如何也不可能在 htop 中看到 0 号进程本体，只能发现 1 号和 2 号进程的 PPID 是 0。</p>
</div>
<h4 id="linux对进程的分类">linux对进程的分类</h4>
<p><code>Status: R: running; S: sleeping; T: traced/stopped; Z: zombie; D: disk sleep</code> S 对应的 sleeping 又称 interruptible sleep，字面意思是「可以被中断」；而 D 对应的 disk sleep 又称 uninterruptible sleep，不可被中断，一般是因为阻塞在磁盘读写操作上。 Zombie 是僵尸进程，该状态下进程已经结束，只是仍然占用一个 PID，保存一个返回值。而 traced/stopped 状态正是下文使用 Ctrl + Z 导致的挂起状态（大写 T），或者是在使用 gdb 等调试（Debug）工具进行跟踪时的状态（小写 t）。</p>
<table>
<thead>
<tr class="header">
<th>状态</th>
<th>缩写表示</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Running</td>
<td>R</td>
<td>正在运行/可以立刻运行</td>
</tr>
<tr class="even">
<td>Sleeping</td>
<td>S</td>
<td>可以被中断的睡眠</td>
</tr>
<tr class="odd">
<td>Disk Sleep</td>
<td>D</td>
<td>不可被中断的睡眠</td>
</tr>
<tr class="even">
<td>Traced / Stopped</td>
<td>T</td>
<td>被跟踪/被挂起的进程</td>
</tr>
<tr class="odd">
<td>Zombie</td>
<td>Z</td>
<td>僵尸进程</td>
</tr>
</tbody>
</table>
<h3 id="ps">ps</h3>
<p>ps（<strong>p</strong>rocess <strong>s</strong>tatus）是常用的输出进程状态的工具。直接调用 <code>ps</code> 仅会显示本终端中运行的相关进程。如果需要显示所有进程，对应的命令为 <code>ps aux</code>。</p>
<h3 id="优先级与-nice-值">优先级与 nice 值</h3>
<p>有了进程，谁先运行？谁给一点时间就够了，谁要占用大部分 CPU 时间？这又是如何决定的？这些问题之中体现着优先权的概念。如果说上面所介绍的的那些进程属性描述了进程的控制信息，那么<strong>优先级</strong>则反映操作系统调度进程的手段。在 htop 的显示中有两个与优先级有关的值：Priority（PRI）和 <strong>nice（NI）</strong>。以下主要介绍用户层使用的 nice 值。</p>
<p>Nice 值越高代表一个进程对其它进程越 "nice"（友好），对应的优先级也就更低。Nice 值最高为 19，最低为 -20。通常，我们运行的程序的 nice 值为 0。我们可以打开 htop 观察与调整每个进程的 nice 值。</p>
<p>用户可以使用 <code>nice</code> 命令在运行程序时指定优先级，而 <code>renice</code> 命令则可以重新指定优先级。当然，若想调低 nice 值，还需要 <code>sudo</code>（毕竟不能随便就把自己的优先级设置得更高，不然对其他的用户不公平）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nice -n 10 vim # 以 10 为 nice 值运行 vim</span><br><span class="line">renice -n 10 -p 12345 # 设置 PID 为 12345 的进程的 nice 值为 10</span><br></pre></td></tr></table></figure>
<div class="note info no-icon"><p>如果你在 htop 中测试调整进程的 nice 值，可能会发现一个公式：<code>PRI = nice + 20</code>。这对于普通进程是成立的——普通进程的 PRI 会被映射到一个非负整数。</p>
<p>但在正常运行的 Linux 系统中，我们可能会发现有些进程的 PRI 值是 RT，或者是负数。这表明对应的进程有更高的实时性要求（例如内核进程、音频相关进程等），采用了与普通进程不同的调度策略，优先级也相应更高。</p>
</div>
<h3 id="用户进程控制">用户进程控制</h3>
<p><img src="https://101.lug.ustc.edu.cn/Ch04/images/signal_slide.png" /> 信号是 Unix 系列系统中进程之间相互通信的一种机制。发送信号的 Linux 命令叫作 <code>kill</code>。被称作 "kill" 的原因是：早期信号的作用就是关闭（杀死）进程。</p>
<h3 id="前后台">前后台</h3>
<p><img src="https://101.lug.ustc.edu.cn/Ch04/images/bg.gif" /> 默认情况下，在 shell 中运行的命令都在前台运行，如果需要在后台运行程序，需要在最后加上 <code>&amp;</code> 而如果需要将前台程序切换到后台，则需要按下 Ctrl + Z 发送 SIGTSTP 使进程挂起，控制权还给 shell 我们可以使用 <code>jobs</code> 命令，看到当前 shell 上所有相关的进程 任务前的代号在 fg，bg，乃至 kill 命令中发挥作用。使用时需要在前面加 <code>%</code>，如将 2 号进程放入后台，则使用 <code>bg %2</code> <div class="note info no-icon"><p>然而我们也许会关注一个细节，在图中显示的编号后面跟着的加号和减号是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1]  - running    ./signal handle</span><br><span class="line">[2]  + suspended  ping localhost</span><br></pre></td></tr></table></figure>
<p>这里的加号标记了 fg 和 bg 命令默认作用到的任务为 2，所以这里 <code>bg %2</code> 也可以直接简化为 <code>bg</code>。减号表示如果加号标记的进程退出了，它就会成为加号标记进程。我们也可以用 <code>%+</code> 和 <code>%-</code> 指代这两个任务。</p>
</div></p>
<h3 id="终止进程">终止进程</h3>
<p>标准的终止进程信号是 SIGTERM，意味着一个进程的自然死亡</p>
<ul>
<li>htop 中自带向进程发送信号的功能。按下 K 键，在左侧提示栏中选择需要的信号，按下回车发送。同时可以使用空格对进程进行标记，被标记的进程将改变显示颜色。此时重复上述过程，可对被标记进程批量发送信号。</li>
<li>如果不加任何参数，只有 PID，<code>kill</code> 命令将自动使用 15（SIGTERM）作为信号参数。</li>
<li>在信号中，9 代表 SIGKILL，收到这个信号之后，程序会立刻退出。在使用时，直接 <code>kill -9 PID</code> 即可。</li>
</ul>
<h3 id="其他类-kill-命令">其他类 kill 命令</h3>
<ul>
<li><p><code>pgrep</code> / <code>pkill</code> 后面接模糊名称，实际上类似于对名称进行 <code>grep</code> 命令。<code>pgrep</code> 仅列出搜索到的进程名称符合用户输入的进程标识符，而 <code>pkill</code> 会根据用户的输入向进程发送信号。</p></li>
<li><p><code>killall</code> 与 <code>pkill</code> 有一些类似，会向指定名字的进程发送信号。</p></li>
<li><p><code>xkill</code> <code>xkill</code> 是针对窗口的 kill，运行该命令后，鼠标点击程序对应的窗口，就可以杀死该程序。</p></li>
</ul>
<h3 id="脱离终端">脱离终端</h3>
<p>如果你使用过 SSH 连接到远程服务器执行任务，那么你会发现，你在 shell 中执行的程序在 SSH 断开之后会被关闭。这是因为终端一旦被关闭会向其中每个进程发送 SIGHUP（Signal hangup），而 SIGHUP 的默认动作即退出程序运行。</p>
<h4 id="nohup">nohup</h4>
<p>nohup，字面含义，就是「不要被 SIGHUP 影响」。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nohup ping 101.ustclug.org &amp;</span><br><span class="line">[1] 19258</span><br><span class="line">nohup: ignoring input and appending output to &#x27;/home/ustc/nohup.out&#x27;</span><br></pre></td></tr></table></figure>
<p>在需要屏蔽 SIGHUP 的程序前添加 nohup，则运行时的输出将被<a href="https://101.lug.ustc.edu.cn/Ch06/#redirect">重定向</a>到 nohup.out，也可以通过重定向手段自定义输出的文件。</p>
<h2 id="服务">服务</h2>
<h3 id="服务管理">服务管理</h3>
<p>目前绝大多数 Linux 发行版的 init 方案都是 systemd，其管理系统服务的命令是 <code>systemctl</code>。</p>
<p>若想了解全部服务内容，可以运行 <code>systemctl list-units</code> 来查看。该命令将显示所有 systemd 管理的单元，同时右面还会附上一句注释来表明该服务的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tldr systemctl</span><br><span class="line">systemctl</span><br><span class="line">Control the systemd system and service manager.</span><br><span class="line"></span><br><span class="line">    - List failed units:  # 列出运行失败的服务</span><br><span class="line">    systemctl --failed</span><br><span class="line"></span><br><span class="line">    - Start/Stop/Restart/Reload a service:  # 开启/关闭/重启/重载服务。Reload 代表重载配置文件而不重启进程。</span><br><span class="line">    systemctl start/stop/restart/reload &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Show the status of a unit:  # 显示服务状态</span><br><span class="line">    systemctl status &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Enable/Disable a unit to be started on bootup:  # 设置（Enable）/取消（Disable）服务开机自启</span><br><span class="line">    systemctl enable/disable &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Mask/Unmask a unit, prevent it to be started on bootup:  # 阻止/取消阻止服务被 enable</span><br><span class="line">    systemctl mask/unmask &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Reload systemd, scanning for new or changed units:  # 重载 systemd，需要在创建或修改服务文件后执行</span><br><span class="line">    systemctl daemon-reload</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info no-icon"><p>wsl默认不支持systemctl,可以使用传统的service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tldr service</span><br><span class="line">service</span><br><span class="line">Manage services by running init scripts.</span><br><span class="line">The full script path should be omitted (/etc/init.d/ is assumed).</span><br><span class="line"></span><br><span class="line"> - Start/Stop/Restart/Reload service (start/stop should always be available):</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; &#123;&#123;start|stop|restart|reload&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Do a full restart (runs script twice with start and stop):</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; --full-restart</span><br><span class="line"></span><br><span class="line"> - Show the current status of a service:</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; status</span><br><span class="line"></span><br><span class="line"> - List the status of all services:</span><br><span class="line">   service --status-all</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者手动打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/wsl.conf</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[boot]</span><br><span class="line">systemd=true</span><br></pre></td></tr></table></figure>
<p>然后在windows终端wsl --shutdown再重启</p>
</div>
<div class="note info no-icon"><p><strong>编写 .service 文件并运行（以 Jupyter Notebook 为例）</strong></p>
<p>Jupyter Notebook 是基于浏览器的交互式编程平台，在数据科学领域非常常用。</p>
<p>首先使用文本编辑器在 <code>/etc/systemd/system</code> 目录下创建一个名为 <code>jupyter.service</code> 的文件。并填入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jupyter Notebook    # 该服务的简要描述</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">PIDFile=/run/jupyter.pid        # 用来存放 PID 的文件</span><br><span class="line">ExecStart=/usr/local/bin/jupyter-notebook --allow-root</span><br><span class="line">                                # 使用绝对路径标明的命令及命令行参数</span><br><span class="line">WorkingDirectory=/root          # 服务启动时的工作目录</span><br><span class="line">Restart=always                  # 重启模式，这里是无论因何退出都重启</span><br><span class="line">RestartSec=10                   # 退出后多少秒重启</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target      # 依赖目标，这里指进入多用户模式后再启动该服务</span><br></pre></td></tr></table></figure>
<p>将写好的配置文件保存为 <code>/etc/systemd/system/jupyter.service</code>，然后运行 <code>systemctl daemon-reload</code>，就可以使用 <code>systemctl</code> 命令来管理这个服务了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start jupyter</span><br><span class="line">systemctl stop jupyter</span><br><span class="line">systemctl enable jupyter  # enable 表示标记服务的开机自动启动</span><br><span class="line">systemctl disable jupyter # 取消自启</span><br></pre></td></tr></table></figure>
</div>
<h3 id="例行性任务">例行性任务</h3>
<p>可以用at，crontab等工具创建例行性任务 详见<a href="https://101.lug.ustc.edu.cn/Ch04/#crontab">linux101</a></p>
<div class="note info no-icon">
</div>
<h2 id="用户权限和文件系统">用户权限和文件系统</h2>
<p>可以查看 <code>/etc/passwd</code> 文件，来得到系统中用户的配置信息。 普通用户的文件存储于位于 <code>/home/username/</code>路径</p>
<div class="note info no-icon"><p>你是否常常忘记敲 <code>sudo</code>，结果还要把后面的整条命令重新敲一遍？在发现权限不足之后有一个方便的「补救方案」：<code>sudo !!</code>，效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt update</span><br><span class="line">Reading package lists... Done</span><br><span class="line">E: Could not open lock file /var/lib/apt/lists/lock - open (13: Permission denied)</span><br><span class="line">E: Unable to lock directory /var/lib/apt/lists/</span><br><span class="line">W: Problem unlinking the file /var/cache/apt/pkgcache.bin - RemoveCaches (13: Permission denied)</span><br><span class="line">W: Problem unlinking the file /var/cache/apt/srcpkgcache.bin - RemoveCaches (13: Permission denied)</span><br><span class="line">$ sudo !!</span><br><span class="line">sudo apt update</span><br><span class="line">[sudo] password for ustc:</span><br><span class="line">Hit:1 http://mirrors.ustc.edu.cn/ubuntu bionic InRelease</span><br><span class="line">（以下内容省略）</span><br></pre></td></tr></table></figure>
<p>其实，在 Shell 中，<code>!!</code> 即代表上一条命令，可以和其他的命令结合使用。</p>
</div>
<p>以 <code>root</code> 之外的用户的身份执行命令：加上 <code>-u 用户名</code> 的参数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo -u nobody id</span><br><span class="line">uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)</span><br></pre></td></tr></table></figure>
<h3 id="用户组">用户组</h3>
<p>用户组是用户的集合。通过用户组机制，可以为一批用户设置权限。可以使用 <code>groups</code> 命令，查看自己所属的用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ groups</span><br><span class="line">ustc adm cdrom sudo dip plugdev lxd</span><br></pre></td></tr></table></figure>
<p>用户组和用户一样，也有编号：GID (Group ID)。 <div class="note info no-icon"><p><code>adduser</code> 是 Debian 及其衍生发行版中附带的一个方便的用户管理脚本。它可以用来向系统添加用户、添加组，以及将用户加入组。输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser 用户名</span><br></pre></td></tr></table></figure>
<p>即可添加此用户。而输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser --group 组名</span><br></pre></td></tr></table></figure>
<p>即可添加此用户组。将用户加入指定用户组也非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser 用户名 组名</span><br></pre></td></tr></table></figure>
<p>在通过 <code>adduser</code> 创建了新的用户后，直接使用 <code>sudo</code> 以 <code>root</code> 身份运行程序可能会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">[sudo] password for ustc:</span><br><span class="line">ustc is not in the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure>
<p>除了可以通过 <code>visudo</code> 命令编辑 <code>sudoers</code> 文件外，还可以直接通过将新的用户加入到 <code>sudo</code> 用户组，以能够使用 <code>sudo</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser ustc sudo</span><br></pre></td></tr></table></figure>
<p>再次切换到新的用户即可看到使用 sudo 的提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="line">See &quot;man sudo_root&quot; for details.</span><br></pre></td></tr></table></figure>
</div></p>
<h2 id="文本处理">文本处理</h2>
<h3 id="正则表达式">正则表达式</h3>
<p><a href="https://regex101.com/">在线编辑正则表达式</a> 正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。</p>
<p>特殊字符表：</p>
<table>
<thead>
<tr class="header">
<th>特殊字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[]</code></td>
<td>方括号表达式，表示匹配的字符集合，例如 <code>[0-9]</code>、<code>[abcde]</code></td>
</tr>
<tr class="even">
<td><code>()</code></td>
<td>标记子表达式起止位置</td>
</tr>
<tr class="odd">
<td><code>*</code></td>
<td>匹配前面的子表达式零或多次</td>
</tr>
<tr class="even">
<td><code>+</code></td>
<td>匹配前面的子表达式一或多次</td>
</tr>
<tr class="odd">
<td><code>?</code></td>
<td>匹配前面的子表达式零或一次</td>
</tr>
<tr class="even">
<td><code>\</code></td>
<td>转义字符，除了常用转义外，还有：<code>\b</code> 匹配单词边界；<code>\B</code> 匹配非单词边界等</td>
</tr>
<tr class="odd">
<td><code>.</code></td>
<td>匹配除 <code>\n</code>（换行）外的任意单个字符</td>
</tr>
<tr class="even">
<td><code>&#123;&#125;</code></td>
<td>标记限定符表达式的起止。例如 <code>&#123;n&#125;</code> 表示匹配前一子表达式 n 次；<code>&#123;n,&#125;</code> 匹配至少 n 次；<code>&#123;n,m&#125;</code> 匹配 n 至 m 次</td>
</tr>
<tr class="odd">
<td><code>\|</code></td>
<td>表明前后两项二选一</td>
</tr>
<tr class="even">
<td><code>$</code></td>
<td>匹配字符串的结尾</td>
</tr>
<tr class="odd">
<td><code>^</code></td>
<td>匹配字符串的开头，在方括号表达式中表示不接受该方括号表达式中的字符集合</td>
</tr>
</tbody>
</table>
<p>若是想要匹配特殊字符本身，需要在之前加上转义字符 <code>\</code>。 <div class="note info no-icon"><p>匹配正整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1-9][0-9]*</span><br></pre></td></tr></table></figure>
<p>匹配仅由 26 个英文字母组成的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[A-Za-z]+$</span><br></pre></td></tr></table></figure>
<p>匹配 Chapter 1-99 或 Section 1-99</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(Chapter|Section) [1-9][0-9]&#123;0,1&#125;$</span><br></pre></td></tr></table></figure>
<p>匹配“ter”结尾的单词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ter\b</span><br></pre></td></tr></table></figure>
<p>匹配rgb代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^#([0-9]&#123;6&#125;$|([0-9]|[A-F])&#123;3&#125;$)</span><br></pre></td></tr></table></figure>
</div></p>
<h4 id="基本扩展正则表达式">基本/扩展正则表达式</h4>
<p>基本正则表达式（Basic Regular Expressions, BRE）和扩展正则表达式（Extended Regular Expressions, ERE）是两种 POSIX 正则表达式风格。</p>
<p>BRE 可能是如今最老的正则风格了，对于部分特殊字符（如 <code>+</code>, <code>?</code>, <code>|</code>, <code>&#123;</code>）需要加上转义符 <code>\</code> 才能表达其特殊含义。</p>
<p>ERE 与如今的现代正则风格较为一致，相比 BRE，上述特殊字符默认发挥特殊作用，加上 <code>\</code> 之后表达普通含义。</p>
<h4 id="懒惰和贪婪">懒惰和贪婪</h4>
<p>使用 <code>*</code> <code>+</code> 的时候默认是贪婪模式，即尽可能匹配更多的子表达式。在 <code>*</code> <code>+</code> 之后加上 <code>?</code> 变为懒惰模式，即尽可能匹配更少的子表达式。</p>
<p>例如：<code>123456456</code></p>
<p>贪婪：<code>1.+6</code> -&gt; <code>123456456</code></p>
<p>懒惰：<code>1.+?6</code> -&gt; <code>123456</code> 后向引用可以将之前匹配到的具体内容再次利用。在正则表达式中，<code>()</code> 以及它们包含的内容为一个分组，每个分组默认拥有一个组号。</p>
<p>组号分配规则：</p>
<ul>
<li>0 代表整个表达式</li>
<li>从左至右，按左括号的出现顺序分配，第一个为 1，第二个为 2，以此类推</li>
<li>扫描两遍，第一次只分配未命名的组，第二次只分配命名的组。即任意命名组的组号都大于未命名的组号</li>
</ul>
<h4 id="后向引用">后向引用</h4>
<div class="note info no-icon"><p>示例</p>
<p><code>\b(\w+)\b\s+\1\b</code> 可以用来匹配用空白字符分割的两个重复的单词（例如 <code>linux linux</code>），其中 <code>\1</code> 是对组号为 1 的组 <code>(\w+)</code> 的引用。</p>
<p><code>\b(?'Word'\w+)\b\s+\k'Word'\b</code> 也可以起到同样的效果，其中 <code>?'Word'</code> 用于命名组，<code>\k'Word'</code> 用于引用组。</p>
</div>
<h4 id="零宽断言">零宽断言</h4>
<p>零宽断言用于查找某些内容进行定位，但内容并不放入匹配结果，就像 <code>\b</code> <code>^</code> <code>$</code> 的定位一样。<code>(?=exp)</code> 用于匹配表达式 <code>exp</code> 前面的位置，<code>(?&lt;=exp)</code> 用于匹配后面的位置。</p>
<h4 id="拓展阅读">拓展阅读</h4>
<p><a href="https://zhuanlan.zhihu.com/p/46294360">乱用正则引发的惨案</a></p>
<h3 id="其他的文本处理工具">其他的文本处理工具</h3>
<h4 id="grep">grep</h4>
<p>grep 全称 Global Regular Expression Print，是一个强大的文本搜索工具，可以在一个或多个文件中搜索指定 pattern 并显示相关行。</p>
<p>grep 默认使用 BRE，要使用 ERE 可以使用 <code>grep -E</code> 或 egrep。</p>
<p>命令格式：<code>grep [option] pattern file</code></p>
<p>一些用法：</p>
<ul>
<li><code>-n</code>：显示匹配到内容的行号</li>
<li><code>-v</code>：显示不被匹配到的行</li>
<li><code>-i</code>：忽略字符大小写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /bin | grep -n &quot;^man$&quot;  # 搜索内容仅含 man 的行，并且显示行号</span><br><span class="line">ls /bin | grep -v &quot;[a-z]\|[0-9]&quot;  # 搜索不含小写字母和数字的行</span><br><span class="line">ls /bin | grep -iv &quot;[A-Z]\|[0-9]&quot;  # 搜索不含字母和数字的行</span><br></pre></td></tr></table></figure>
<h4 id="sed">sed</h4>
<p>sed 全称 Stream EDitor，即流编辑器，可以方便地对文件的内容进行逐行处理。</p>
<p>sed 默认使用 BRE，要使用 ERE 可以 sed -E。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [OPTIONS] &#x27;command&#x27; file(s)</span><br><span class="line">sed [OPTIONS] -f scriptfile file(s)</span><br></pre></td></tr></table></figure>
<p>此处的 command 和 scriptfile 中的命令均指的是 sed 命令。</p>
<p>常见 sed 命令：</p>
<ul>
<li>s 替换</li>
<li>d 删除</li>
<li>c 选定行改成新文本</li>
<li>a 当前行下插入文本</li>
<li>i 当前行上插入文本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo -e &quot;seD\nIS\ngOod&quot; &gt; sed_demo</span><br><span class="line">$ cat sed_demo</span><br><span class="line">seD</span><br><span class="line">IS</span><br><span class="line">gOod</span><br><span class="line">$ sed &quot;2d&quot; sed_demo  # 删除第二行</span><br><span class="line">seD</span><br><span class="line">gOod</span><br><span class="line">$ sed &quot;s/[a-z]/~/g&quot; sed_demo  # 替换所有小写字母为 ~</span><br><span class="line">~~D</span><br><span class="line">IS</span><br><span class="line">~O~~</span><br><span class="line">$ sed &quot;3cpErfeCt&quot; sed_demo  # 选定第三行，改成 pErfeCt</span><br><span class="line">seD</span><br><span class="line">IS</span><br><span class="line">pErfeCt</span><br></pre></td></tr></table></figure>
<h4 id="awk">awk</h4>
<p>awk 是一种用于处理文本的编程语言工具，名字来源于三个作者的首字母。相比 sed，awk 可以在逐行处理的基础上，针对列进行处理。默认的列分隔符号是空格，其他分隔符可以自行指定。</p>
<p>awk 使用 ERE。</p>
<p>命令格式：<code>awk [options] 'pattern &#123;action&#125;' [file]</code></p>
<p>awk 逐行处理文本，对符合的 patthern 执行 action。需要注意的是，awk 使用单引号时可以直接用 <code>$</code>，使用双引号则要用 <code>\$</code>。</p>
<p>一些示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat awk_demo</span><br><span class="line">Beth    4.00    0</span><br><span class="line">Dan     3.75    0</span><br><span class="line">kathy   4.00    10</span><br><span class="line">Mark    5.00    20</span><br><span class="line">Mary    5.50    22</span><br><span class="line">Susie   4.25    18</span><br><span class="line">$ # 选择第三列值大于 0 的行，对每一行输出第一列的值和第二第三列的乘积</span><br><span class="line">$ awk &#x27;$3 &gt;0 &#123; print $1, $2 * $3 &#125;&#x27; awk_demo</span><br><span class="line">kathy 40</span><br><span class="line">Mark 100</span><br><span class="line">Mary 121</span><br><span class="line">Susie 76.5</span><br></pre></td></tr></table></figure>
<p>示例中 <code>$1</code>，<code>$2</code>，<code>$3</code> 分别指代本行的第 1、2、3 列。特别地，$0 指代本行。</p>
<p>awk 语言是「图灵完全」的，这意味着理论上它可以做到和其他语言一样的事情。这里我们不仅可以对每行进行操作，还可以定义变量，将前面处理的状态保存下来，以下是一个求和的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; sum = 0 &#125; &#123; sum += $2 * $3 &#125; END &#123; print sum &#125;&#x27; awk_demo</span><br><span class="line">337.5</span><br></pre></td></tr></table></figure>
<h4 id="trsort">tr,sort</h4>
<p>除此之外，tr可用于进行简单的预处理，sort可以用于进行简单的排序、</p>
<h2 id="shell环境">shell环境</h2>
<p>组命令：</p>
<ul>
<li><p>使用 <code>&#123; 命令1; 命令2; … &#125;</code>，组命令在 shell 内执行，不会产生新的进程，注意花括号和命令之间的空格。</p></li>
<li><p>使用 <code>(命令1; 命令2; …)</code>，组命令会建立独立的 shell 子进程来执行组命令，这里的圆括号周围并不需要空格。</p></li>
</ul>
<p>可以在脚本开头加上 <code>set -u</code> 来实现使用未定义变量报错，否则会默认成空值</p>
<h3 id="位置参数">位置参数</h3>
<ul>
<li>Shell 解释用户的命令时，把命令程序名后面的所有字串作为程序的参数。分别对应 <code>$1</code>、<code>$2</code>、<code>$3</code>、……、<code>$9</code>，程序名本身对应 <code>$0</code>。</li>
<li>可用 <code>shift &lt;n&gt;</code> 命令，丢弃开头的 n 个位置变量，改变 <code>$1</code>、<code>$2</code>、<code>$3</code> 等的对应关系。</li>
<li>可用 <code>set</code> 命令，重置整个位置变量列表，从而给 <code>$1</code>、<code>$2</code>、<code>$3</code> 等赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ set one two three</span><br><span class="line">$ echo $1 $2 $3</span><br><span class="line">one two three</span><br><span class="line">$ shift 2</span><br><span class="line">$ echo $1 $2 $3</span><br><span class="line">three</span><br><span class="line">$ # 此时 $2 和 $3 已不存在</span><br></pre></td></tr></table></figure>
<h3 id="特殊变量">特殊变量</h3>
<table>
<thead>
<tr class="header">
<th>特殊变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>$#</code></td>
<td>命令行上的参数个数，不包括 <code>$0</code></td>
</tr>
<tr class="even">
<td><code>$?</code></td>
<td>最后命令的退出代码，0 表示成功，其它值表示失败</td>
</tr>
<tr class="odd">
<td><code>$$</code></td>
<td>当前进程的 PID</td>
</tr>
<tr class="even">
<td><code>$!</code></td>
<td>最近一个后台运行进程的进程号</td>
</tr>
<tr class="odd">
<td><code>$*</code></td>
<td>命令行所有参数构成的一个字符串</td>
</tr>
<tr class="even">
<td><code>$@</code></td>
<td>用双引号括起的命令行各参数拼接构成的一个字符串</td>
</tr>
</tbody>
</table>
<h3 id="特殊字符">特殊字符</h3>
<ul>
<li><p>反斜杠，消除单个字符的特殊含义。</p>
<ul>
<li>包含空白字符（空格和制表符）、反斜杠本身、各种引号，以及 <code>$</code>、<code>!</code> 等。</li>
<li>与其他语言不同，shell 中反斜杠不会将普通字符转义为其他含义（例如 <code>\n</code> 不会被视作换行符）。</li>
</ul></li>
<li><p>使用双引号包裹字符串可以消除空白字符切分参数的特殊含义，但是很多其他特殊字符的特殊含义仍然保留。双引号也被称为「弱引用」。</p></li>
<li><p>单引号，能消除所有特殊字符的特殊含义，包括反斜杠，因此单引号字符串中不能使用反斜杠转义单引号本身。单引号也被称为「强引用」。</p></li>
<li><p>反引号（<code>`</code>）括起的字符串，被 shell 解释为命令，执行时用命令输出结果代替整个反引号对界限部分。</p>
<ul>
<li>与反引号相同的语法是 <code>$(command)</code>，它的好处是界限更明确，且可以嵌套。因此编写新脚本时，更建议使用此语法。</li>
</ul></li>
</ul>
<h3 id="语法">语法</h3>
<p>具体语法可参考<a href="https://101.lug.ustc.edu.cn/Ch06/#bash-arithmetic">linux101</a></p>
<h2 id="拓展阅读-1">拓展阅读</h2>
<h3 id="进程与会话">进程与会话</h3>
<p>Fork 是类 UNIX 中创建进程的基本方法：将当前的进程完整复制一份。新进程和旧进程唯一的区别是 <code>fork()</code> 的返回值不同。程序员可以根据其返回值为新旧进程设置不同的逻辑。</p>
<p>除了最开始的 0 号进程外，绝大多数情况下其他进程是由另一个进程通过 fork 产生的。这里产生进程的一方为<strong>父进程</strong>，被产生的是<strong>子进程</strong>。在 Linux 中，父进程可以等待子进程，接收子进程退出信号以及返回值。 父进程如果先于子进程退出，产生孤儿进程，会被0号进程(init)接管 子进程先退出但父进程没有回应，产生僵尸进程，会被系统定时清理</p>
<p><strong>进程组</strong>大体上是执行同一工作的进程形成的一个团体，通常是由于父进程 fork 出子进程后子进程继承父进程的组 ID 而逐渐形成。</p>
<p><strong>会话</strong> (session) 可以说是面向用户的登录出现的概念。当用户从终端登录进入 shell，就会以该 shell 为会话首进程展开本次会话。一个会话中通常包含着多个进程组，分别完成不同的工作。用户退出时，这个会话会结束，但有些进程仍然以该会话标识符 (session ID) 驻留系统中继续运行。</p>
<table>
<thead>
<tr class="header">
<th>进程属性</th>
<th>意义/目的</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PID</td>
<td>Process ID，标识进程的唯一性。</td>
</tr>
<tr class="even">
<td>PPID</td>
<td>Parent PID，标识进程父子关系。</td>
</tr>
<tr class="odd">
<td>PGID</td>
<td>Process Group ID，标识共同完成一个任务的整体。</td>
</tr>
<tr class="even">
<td>TPGID</td>
<td>标识一组会话中处于前台（与用户交流）的进程（组）。</td>
</tr>
<tr class="odd">
<td>SID</td>
<td>Session ID，标识一组会话，传统意义上标识一次登录所做的任务的集合，如果是与具体登录无关的进程，其 SID 被重置。</td>
</tr>
</tbody>
</table>
<h3 id="终端-terminal-与控制台-console">终端 (Terminal) 与控制台 (Console)</h3>
<p>在上世纪六十年代，个人计算机尚未开始发展，用户使用计算机的一种常见方式就是通过终端，与远程的服务器连接交互。当时键盘和显示器连为一体，称为终端（terminal）。而主机自带的一套键盘与屏幕只能给系统管理员使用，称为控制台 (console)，用来输出启动 debug 信息（现在的 Linux 系统如果因故障而不得不进入单用户修复模式，则只有一个终端 <code>/dev/console</code> 开启）。</p>
<p>然而随着时代的发展，这种模式逐渐被家庭电脑的分布式主机取代，我们不需要，也没有多套终端了，只有显示器、键盘、鼠标。但是为了向前兼容性，我们需要假装这是一个（甚至多个）终端，所以一般发行版 <code>/dev</code> 目录下有 7 个终端 <code>tty1 ~ tty7</code>，通过 <code>Ctrl + Alt + F1 ~ F7</code> 切换键盘与显示器与哪个终端相对应。</p>
<p>再后来，随着时代发展，终端需要出现在图形界面上了，然而承载图形界面的也是终端，所以终端里的终端就需要终端模拟器来实现了。由此，出现在图形界面上的终端才叫终端模拟器。</p>
<p>没有图形界面时，shell 一般为控制台 (tty) 的子进程，在图形界面上 shell 建立在虚拟终端 (pty, pseudo tty) 之上。顺带一提，服务器常用的远程连接工具 <code>ssh</code> 的父进程也是一个 pty。</p>
<p>参考阅读: <a href="https://www.linuxdashen.com/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%88%E7%AB%AF%E5%90%97%EF%BC%9F">你真的知道什么是终端吗？</a></p>
<h3 id="文件系统的特殊权限位">文件系统的特殊权限位</h3>
<p>有三个特殊权限位：setuid, setgid 和 sticky。</p>
<ul>
<li><code>setuid</code>: 以文件所属的用户的身份 (UID) 执行此程序。</li>
<li><code>setgid</code>: 对文件来说，以文件所属的用户组的身份 (GID) 执行此程序；对目录来说，在这个目录下创建的文件的用户组都与此目录本身的用户组一致，而不是创建者的用户组。</li>
<li><code>sticky</code> (restricted deletion flag): 目录中的所有文件只能由文件所有者（除 <code>root</code> 以外）删除或者移动。一个典型的例子是临时文件夹 <code>/tmp</code>，在此文件夹中你可以创建、修改、重命名、移动、删除自己的文件，但是动不了别人的文件。</li>
</ul>
<p><code>/usr/bin/passwd</code> 的文件权限设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 root root 67992 Aug 29  2019 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p>可以看到，本来是执行权限位的地方变成了 <code>s</code>。这代表此文件有 <code>setuid</code> 特殊权限位。在你执行 <code>passwd</code> 的时候，它的实际权限和 <code>root</code> 一样，只是它知道，执行它的人是你（而非 <code>root</code>），所以只提供修改你自己的密码的功能。</p>
<p>此外，passwd需要知道实际执行自己的用户是谁，在 Linux 中，有两个系统调用可以获取当前进程归属的 UID：<code>getuid()</code> 和 <code>geteuid()</code>。前者对应的是「实际用户」(Real user)，是实际运行（拥有）这个进程的用户，后者对应的是「有效用户」(Effective user)，对应进程拥有的权限。在运行 <code>passwd</code> 的时候，有效用户是 <code>root</code>，所以可以修改 <code>/etc/shadow</code>；而实际用户是你，所以它不会让你修改别人的密码。</p>
<p>对用户组来说，也有实际用户组 (GID) 和有效用户组 (EGID) 的区别。</p>
<h3 id="登录-shell和非登录-shell">登录 Shell和非登录 Shell</h3>
<p>「登录 Shell」是属于你的当前会话操作中的第一个进程，一般是在你输入用户名和密码之后打开的 Shell。常见的场景有：</p>
<ul>
<li><code>su -</code> 之后的 Shell。</li>
<li>SSH 登录机器后的 Shell</li>
<li>Ctrl + Alt + F[1-7] 之后 TTY 中的 Shell</li>
</ul>
<p>而「非登录 Shell」的常见场景：</p>
<ul>
<li><code>su</code> 打开的是「非登录 Shell」</li>
<li>在桌面环境中打开的终端（模拟器），启动的也是「非登录 Shell」</li>
</ul>
<p>一般地，「登录 Shell」会额外加载 <code>profile</code> 文件（文件名根据你使用的 Shell 的不同而有区别），且它的 <code>argv[0][0] == '-'</code>（相信你已经学过 C 语言了）。可以用以下方法验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $0  # 查看当前 Shell 的 argv[0] 的值</span><br><span class="line">-bash</span><br><span class="line">$ # 是 Login shell</span><br><span class="line">$ sudo su # 进入 root</span><br><span class="line"># echo $0</span><br><span class="line">bash</span><br><span class="line"># # 是 Non-login shell</span><br></pre></td></tr></table></figure>
<h3 id="fork炸弹">fork炸弹</h3>
<p>Fork 炸弹有如下的这种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:()&#123; :|: &amp; &#125;;:</span><br></pre></td></tr></table></figure>
<p>这是一个函数定义以及对其的调用语句，可以格式化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:()</span><br><span class="line">&#123;</span><br><span class="line">    :|: &amp;</span><br><span class="line">&#125;;</span><br><span class="line">:</span><br></pre></td></tr></table></figure>
<p>在 Bash 中，<code>:</code>、<code>.</code>、<code>/</code> 等一些字符也能够被用于函数命名，因此，上面的代码等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func()</span><br><span class="line">&#123;</span><br><span class="line">    func | func &amp;</span><br><span class="line">&#125;;</span><br><span class="line">func</span><br></pre></td></tr></table></figure>
<p>fork 炸弹的核心是函数内容：<code>func | func &amp;</code></p>
<ul>
<li>第一个 func 代表递归执行这个函数。</li>
<li><div class="line-block">代表要将第一个函数的数据结果通过管道传输给后一个函数。</div></li>
<li>&amp; 代表要在后台执行这一条命令，如果其中一个函数被操作系统回收，其调用产生的子函数并不会被回收。</li>
</ul>
<p>于是运行一次这个函数就会创建两个 func 函数的实例，并不断地反复调用。实例的数量会指数爆炸式地增长，最终耗尽系统的资源。</p>
<h4 id="防范方法">防范方法</h4>
<p>一个有效的方式(https://101.lug.ustc.edu.cn/Ch06/supplement/#fn:1)是通过修改系统配置，限制一个用户能够拥有的进程数量多少。<code>ulimit -u 30</code> 可以限制当前用户能够拥有的进程数量为 30。</p>
<h3 id="动静态链接">动/静态链接</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -o hello hello.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd ./hello</span></span><br><span class="line">    linux-vdso.so.1 (0x00007ffc49703000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f36767d3000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f36769ea000)</span><br><span class="line"></span><br><span class="line">//编译得到程序就依赖于 `linux-vdso.so.1`、`libc.so.6` 和 `/lib64/ld-linux-x86-64.so.2` 三个库文件，如果系统中没有这三个库文件，程序就无法执行。</span><br></pre></td></tr></table></figure>
<p>使用到第三方的库需要加上 <code>-l</code> 参数指定在<strong>链接</strong>时链接到的库。 对于复杂的应用来说，下载后可能会因为没有动态链接库而无法运行。 而静态链接则将依赖的库全部打包到程序文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o hello-static hello.c -static  # 编译一个静态链接的应用</span><br><span class="line">$ ldd ./hello-static  # 没有动态链接库的依赖</span><br><span class="line">    not a dynamic executable</span><br></pre></td></tr></table></figure>
<p>此时编译得到的程序文件没有额外的依赖，在其他机器上一般也能顺利运行。代价则是消耗更多的空间，并且可能产生性能损耗</p>
<h3 id="交叉编译">交叉编译</h3>
<p>有时需要开发另一个系统的程序，此时就需要交叉编译来实现，比如使用mingw编译windows程序 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install gcc-mingw-w64  # 安装 mingw 交叉编译器</span><br><span class="line">$ sudo apt install wine  # 安装 wine Windows 兼容层（默认仅安装 64 位架构支持）</span><br><span class="line">$ x86_64-w64-mingw32-gcc -o hello.exe hello.c  # 编译为 64 位的 Windows 程序</span><br><span class="line">$ file hello.exe  # 确认为 Windows 程序</span><br><span class="line">hello.exe: PE32+ executable (console) x86-64, for MS Windows</span><br><span class="line">$ wine hello.exe  # 使用 wine 运行</span><br><span class="line">it looks like wine32 is missing, you should install it.</span><br><span class="line">as root, please execute &quot;apt-get install wine32&quot;</span><br><span class="line">wine: created the configuration directory &#x27;/home/ubuntu/.wine&#x27;</span><br><span class="line">（忽略首次配置的输出）</span><br><span class="line">wine: configuration in L&quot;/home/ubuntu/.wine&quot; has been updated.</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br></pre></td></tr></table></figure> ### docker Dockerfile 是构建 Docker 镜像的标准格式，下面会举一些例子。我们会基于这些例子简单介绍 Dockerfile 的语法。</p>
<h4 id="构建简单的交叉编译环境">构建简单的交叉编译环境</h4>
<p>这个例子尝试使用 Debian 仓库中的 RISC-V <a href="https://101.lug.ustc.edu.cn/Ch07/supplement/#cross-compile-example">交叉编译</a>工具链与 QEMU 模拟器构建一个简单的用于交叉编译的环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM debian:buster-slim</span><br><span class="line"></span><br><span class="line">RUN sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    apt update &amp;&amp; apt install -y gcc-riscv64-linux-gnu g++-riscv64-linux-gnu libc6-dev-riscv64-cross \</span><br><span class="line">                                 binutils-riscv64-linux-gnu libstdc++-dev-riscv64-cross \</span><br><span class="line">                                 qemu-system-misc qemu-user-static qemu-user binfmt-support \</span><br><span class="line">                                 fish vim --no-install-recommends</span><br><span class="line">RUN mkdir /workspace/</span><br><span class="line"></span><br><span class="line">WORKDIR /workspace/</span><br><span class="line">ENV QEMU_LD_PREFIX=/usr/riscv64-linux-gnu/</span><br><span class="line"></span><br><span class="line">CMD [&quot;fish&quot;]</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>docker build</code>，我们可以构建出镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker build -t riscv-cross:example .</span><br></pre></td></tr></table></figure>
<p>Docker 在根据 Dockerfile 构建时，会从上到下执行这些指令，每条指令对应镜像的一层。Docker 容器镜像的独特之处就在于它的分层设计：在构建镜像时每层的更改会叠加在上一层上（这意味着，上一层的所有数据仍然会保留，即使在新的一层删除了）；如果某一层已经存在，Docker 会直接使用这一层，节约构建的时间和占用的空间。 因此构建镜像应尽量减少层数避免空间浪费</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>linux</tag>
        <tag>苏州大学</tag>
        <tag>中国科学技术大学</tag>
      </tags>
  </entry>
  <entry>
    <title>基于mit6.006和hello-algo的算法笔记</title>
    <url>/2023/10/14/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础">基础</h1>
<figure>
<img src="/assets/mit6.006总和笔记/algo.png" alt="" /><figcaption>算法合订本</figcaption>
</figure>
<h2 id="数据结构">数据结构</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231016191822017.png" /></p>
<h2 id="算法性质">算法性质</h2>
<p><code>循环不变式</code>主要用来帮助我们理解算法的正确性。关千<code>循环不变式</code>，我们必须证明三条<br />
性质：<br />
初始化：循环的第一次迭代之前，它为真。<br />
保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。<br />
终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助千证明算法是正确的。</p>
<span id="more"></span>
<p>f(n) = O(g(n)) 类似于 a&lt;=b</p>
<p>f(n) = Ω (g(n)) 类似于 a&gt;=b</p>
<p>f(n) = θ (g(n)) 类似于 a=b</p>
<p>f(n) = o(g(n)) 类似于 a&lt;b</p>
<p>f(n) = w(g(n)) 类似于 a&gt;b <img src="/images/obsidian/20230519150021.png" title="image" alt="图片" /></p>
<h2 id="分治法递归">分治法（递归）</h2>
<h3 id="选择排序">选择排序</h3>
<ul>
<li>在A[:i+1]内找到最大的元素，和A[i]交换</li>
<li>递归地排序A[:i]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def selection_sort(A, i = None): # T(i)</span><br><span class="line">’’’Sort A[:i + 1]’’’</span><br><span class="line">    if i is None: i = len(A) - 1 # O(1)</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        j = prefix_max(A, i) # S(i)</span><br><span class="line">        A[i], A[j] = A[j], A[i] # O(1)</span><br><span class="line">        selection_sort(A, i - 1) # T(i - 1)</span><br><span class="line"></span><br><span class="line">def prefix_max(A, i): # S(i)找到最大元素的索引值</span><br><span class="line">’’’Return index of maximum in A[:i + 1]’’’</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        j = prefix_max(A, i - 1) # S(i - 1)</span><br><span class="line">        if A[i] &lt; A[j]: # O(1)</span><br><span class="line">            return j # O(1)</span><br><span class="line">    return i # O(1)</span><br></pre></td></tr></table></figure>
<p>python实现(迭代)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        k = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[k]:</span><br><span class="line">                k = j  <span class="comment"># 记录最小元素的索引</span></span><br><span class="line">        <span class="comment"># 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        nums[i], nums[k] = nums[k], nums[i]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• prefix max analysis:</span><br><span class="line">– Base case: for i = 0, array has one element, so index of max is i</span><br><span class="line">– Induction: assume correct for i, maximum is either the maximum of A[:i] or A[i],</span><br><span class="line">returns correct index in either case</span><br><span class="line">• selection sort analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, last number of a sorted output is a largest number of</span><br><span class="line">the array, and the algorithm puts one there; then A[:i] is sorted by inductio</span><br></pre></td></tr></table></figure>
<p>性质：O(n^2)，非稳定原地排序</p>
<h3 id="插入排序">插入排序</h3>
<ul>
<li>类似扑克牌，从右侧选择未排序元素，逐个插入左侧的已排序部分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def insertion_sort(A, i = None): # T(i)</span><br><span class="line">’’’Sort A[:i + 1]’’’</span><br><span class="line">    if i is None: i = len(A) - 1 # O(1)</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        insertion_sort(A, i - 1) # T(i - 1)</span><br><span class="line">        insert_last(A, i) # S(i)</span><br><span class="line"></span><br><span class="line">def insert_last(A, i): # S(i)</span><br><span class="line">’’’Sort A[:i + 1] assuming sorted A[:i]’’’</span><br><span class="line">    if i &gt; 0 and A[i] &lt; A[i - 1]: # O(1)</span><br><span class="line">        A[i], A[i - 1] = A[i - 1], A[i] # O(1)</span><br><span class="line">        insert_last(A, i - 1) # S(i - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• insert last analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, if A[i] &gt;= A[i - 1], array is sorted; otherwise,</span><br><span class="line">swapping last two elements allows us to sort A[:i] by induction</span><br><span class="line"></span><br><span class="line">• insertion sort analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, algorithm sorts A[:i] by induction, and then</span><br><span class="line">insert last correctly sorts the rest as proved above</span><br></pre></td></tr></table></figure>
<p>python实现（迭代）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        base = nums[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; base:</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]  <span class="comment"># 将 nums[j] 向右移动一位</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = base  <span class="comment"># 将 base 赋值到正确位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性：复杂度O(n^2)，原地稳定排序</p>
<h3 id="归并排序">归并排序</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">A, a = <span class="number">0</span>, b = <span class="literal">None</span></span>): <span class="comment"># T(b - a = n)</span></span><br><span class="line">’’’Sort A[a:b]’’’</span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span>: b = <span class="built_in">len</span>(A) <span class="comment"># O(1)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> &lt; b - a: <span class="comment"># O(1)</span></span><br><span class="line">        c = (a + b + <span class="number">1</span>) // <span class="number">2</span> <span class="comment"># O(1)</span></span><br><span class="line">        merge_sort(A, a, c) <span class="comment"># T(n / 2)</span></span><br><span class="line">        merge_sort(A, c, b) <span class="comment"># T(n / 2)</span></span><br><span class="line">        L, R = A[a:c], A[c:b] <span class="comment"># O(n)</span></span><br><span class="line">        merge(L, R, A, <span class="built_in">len</span>(L), <span class="built_in">len</span>(R), a, b) <span class="comment"># S(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">L, R, A, i, j, a, b</span>): <span class="comment"># S(b - a = n)</span></span><br><span class="line">’’’Merge <span class="built_in">sorted</span> L[:i] <span class="keyword">and</span> R[:j] into A[a:b]’’’</span><br><span class="line">    <span class="keyword">if</span> a &lt; b: <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= <span class="number">0</span>) <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] &gt; R[j - <span class="number">1</span>]): <span class="comment"># O(1)</span></span><br><span class="line">            A[b - <span class="number">1</span>] = L[i - <span class="number">1</span>] <span class="comment"># O(1)</span></span><br><span class="line">            i = i - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># O(1)</span></span><br><span class="line">        A[b - <span class="number">1</span>] = R[j - <span class="number">1</span>] <span class="comment"># O(1)</span></span><br><span class="line">        j = j - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line">    merge(L, R, A, i, j, a, b - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• merge analysis:</span><br><span class="line">– Base case: for n = 0, arrays are empty, so vacuously correct</span><br><span class="line">– Induction: assume correct for n, item in A[r] must be a largest number from remaining</span><br><span class="line">prefixes of L and R, and since they are sorted, taking largest of last items suffices;</span><br><span class="line">remainder is merged by induction</span><br><span class="line"> merge sort analysis:</span><br><span class="line">– Base case: for n = 1, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for k &lt; n, algorithm sorts smaller halves by induction, and then merge merges into a sorted array as proved above.</span><br></pre></td></tr></table></figure>
<p>python实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, mid: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并左子数组和右子数组&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 左子数组区间 [left, mid], 右子数组区间 [mid+1, right]</span></span><br><span class="line">    <span class="comment"># 创建一个临时数组 tmp ，用于存放合并后的结果</span></span><br><span class="line">    tmp = [<span class="number">0</span>] * (right - left + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 初始化左子数组和右子数组的起始索引</span></span><br><span class="line">    i, j, k = left, mid + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 当左右子数组都还有元素时，比较并将较小的元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将左子数组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        tmp[k] = nums[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">        tmp[k] = nums[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tmp)):</span><br><span class="line">        nums[left + k] = tmp[k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;归并排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 当子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="comment"># 划分阶段</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span>  <span class="comment"># 计算中点</span></span><br><span class="line">    merge_sort(nums, left, mid)  <span class="comment"># 递归左子数组</span></span><br><span class="line">    merge_sort(nums, mid + <span class="number">1</span>, right)  <span class="comment"># 递归右子数组</span></span><br><span class="line">    <span class="comment"># 合并阶段</span></span><br><span class="line">    merge(nums, left, mid, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性：O(nlgn)，稳定排序</p>
<h3 id="寻峰算法">寻峰算法</h3>
<p>一维情况： 实际上是一种二分查找，先查看中点是不是峰值，如果不是则选取邻居节点较大的一侧递归寻找 复杂度lgn</p>
<p>二维情况下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• Pick middle column j = m/2</span><br><span class="line">• Find global maximum on column j at (i, j)</span><br><span class="line">• Compare (i, j − 1), (i, j), (i, j + 1)</span><br><span class="line">• Pick left columns of (i, j − 1) &gt; (i, j)</span><br><span class="line">• Similarly for right</span><br><span class="line">• (i, j) is a 2D-peak if neither condition holds</span><br><span class="line">• Solve the new problem with half the number of columns.</span><br><span class="line">• When you have a single column, find global maximum and you‘re done.</span><br><span class="line"></span><br><span class="line">T (n, m) = T (n, m/2) + Θ(n) (to find global maximum on a column — (n rows))</span><br><span class="line">T (n, m) = (Θ(n) + . . . + Θ(n))log m= Θ(n log m) = Θ(n log n) if m = n</span><br></pre></td></tr></table></figure>
<p>这种解法思路是：</p>
<ol type="1">
<li><p>对数组的中间一列寻找最大值</p></li>
<li><p>如果最大值是峰值，可以返回</p></li>
<li><p>否则对数组最大的邻居所在的一侧进行递归(即子问题大小为原来的一半)</p></li>
</ol>
<p>除此以外还有一种贪心解法：从(0,0)开始，不断寻找当前节点的最大邻居，并不断迭代，时间复杂度O(n^2) 还有一种θ(n)的解法，详见<a href="https://thinklive1.github.io/2023/11/20/mit6.006%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/">作业解析</a></p>
<h3 id="最大子数组">最大子数组</h3>
<p>算法思路： 元素和最大的子数组有三种情况：在左半数组，右半数组，或者跨越中点，第一和第二种情况可以用递归遍历解决，第三种情况则分为两个半边数组的组合，只要从中点出发寻找最大子数组，然后组合就可以了</p>
<p><code>时间复杂度分析</code>：，其中线性时间为跨越中点的子数组，最终需要时间为O(NlogN) <img src="/images/obsidian/20230522103507.png" title="image" alt="图片" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, low， high)  </span><br><span class="line">    if high== low  </span><br><span class="line">        return (low, high, A[low])  </span><br><span class="line">    else mid=mod((low 十 high)/2) </span><br><span class="line">        (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)  </span><br><span class="line">    </span><br><span class="line">        (right-low, right-high, right-sum) =  FIND-MAXIMUM-SUBARRAY(A, mid+l. high)  </span><br><span class="line">    </span><br><span class="line">        (cross-low, cross-high, cross-sum) =  FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)  </span><br><span class="line">    </span><br><span class="line">    if left-sum&gt;=right-sum and left-sum&gt;=cross-sum  </span><br><span class="line">        return (left-low, left-high, left-sum)  </span><br><span class="line">    </span><br><span class="line">    elseif rightr-sum&gt;= left-sum and right-sum&gt;= cross-sum  </span><br><span class="line">        return (right-low, right-high, right-sum)  </span><br><span class="line">    </span><br><span class="line">    else return (cross-low, cross-high, cross-sum)</span><br><span class="line"></span><br><span class="line">FIND-MAX-CROSSING--SUBARRAY(A, low, mid, high)  </span><br><span class="line">    left-sum = -oo  </span><br><span class="line">    sum=O  </span><br><span class="line">    for i = mid downto low  </span><br><span class="line">        sum=sum+A[i]  </span><br><span class="line">        if sum&gt; left-sum  </span><br><span class="line">            left-sum = sum  </span><br><span class="line">            max-left = i  </span><br><span class="line">    right-sum= -oo  </span><br><span class="line">    sum=O  </span><br><span class="line">    for j = mid + 1 to high</span><br><span class="line">        sum=sum + A[j]  </span><br><span class="line">        if sum &gt; right-sum  </span><br><span class="line">            right-sum = sum  </span><br><span class="line">            max-right = j  </span><br><span class="line">    return (max-left, max-right, left-sum + right-sum)</span><br></pre></td></tr></table></figure>
<h1 id="选择和查找">选择和查找</h1>
<h2 id="二分搜索">二分搜索</h2>
<p>普通的二分查找：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_lcro</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找（左闭右开）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 循环，当搜索区间为空时跳出（当 i = j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            i = m + <span class="number">1</span>  <span class="comment"># 此情况说明 target 在区间 [m+1, j) 中</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">            j = m  <span class="comment"># 此情况说明 target 在区间 [i, m) 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> m  <span class="comment"># 找到目标元素，返回其索引</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标元素，返回 -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样的二分查找只适用于不重复元素，如果有重复元素，需要寻找到左边界作为插入点，则需要进一步处理 即：当找到等于目标的索引值后，进一步在左侧区间运行二分查找，直到找到最左侧的值 循环完成后， i指向最左边的 <code>target</code> ， j指向首个小于 <code>target</code> 的元素，<strong>因此索引</strong> <code>i</code><strong>就是插入点</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_insertion</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找插入点（存在重复元素）&quot;&quot;&quot;</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            i = m + <span class="number">1</span>  <span class="comment"># target 在区间 [m+1, j] 中</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">            j = m - <span class="number">1</span>  <span class="comment"># target 在区间 [i, m-1] 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = m - <span class="number">1</span>  <span class="comment"># 首个小于 target 的元素在区间 [i, m-1] 中</span></span><br><span class="line">    <span class="comment"># 返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查找左边界</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_left_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找最左一个 target&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 等价于查找 target 的插入点</span></span><br><span class="line">    i = binary_search_insertion(nums, target)</span><br><span class="line">    <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[i] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到 target ，返回索引 i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p>我们可以利用查找最左元素的函数来查找最右元素，具体方法为：<strong>将查找最右一个 <code>target</code> 转化为查找最左一个 <code>target + 1</code></strong>。搜索结束后<code>j</code>指向最右一个 <code>target</code> ，<strong>因此返回</strong><code>j</code> <strong>即可</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_right_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找最右一个 target&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 转化为查找最左一个 target + 1</span></span><br><span class="line">    i = binary_search_insertion(nums, target + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># j 指向最右一个 target ，i 指向首个大于 target 的元素</span></span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> nums[j] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到 target ，返回索引 j</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当数组不包含 <code>target</code> 时，最终 <code>i</code>和<code>j</code></p>
<p>会分别指向首个大于、小于 <code>target</code> 的元素。</p>
<p>因此，可以构造一个数组中不存在的元素，用于查找左右边界。</p>
<ul>
<li>查找最左一个 <code>target</code> ：可以转化为查找 <code>target - 0.5</code> ，并返回指针<code>i</code></li>
<li>查找最右一个 <code>target</code> ：可以转化为查找 <code>target + 0.5</code> ，并返回指针<code>j</code></li>
</ul>
<h2 id="哈希查找">哈希查找</h2>
<p>Q:给定一个整数数组 <code>nums</code> 和一个目标元素 <code>target</code> ，请在数组中搜索“和”为 <code>target</code> 的两个元素，并返回它们的数组索引。返回任意一个解即可。</p>
<p>借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组</p>
<ol type="1">
<li>判断数字 <code>target - nums[i]</code> 是否在哈希表中，若是则直接返回这两个元素的索引。</li>
<li>将键值对 <code>nums[i]</code> 和索引 <code>i</code> 添加进哈希表。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_brute_force.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_sum_hash_table</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;方法二：辅助哈希表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 辅助哈希表，空间复杂度 O(n)</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="comment"># 单层循环，时间复杂度 O(n)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> [dic[target - nums[i]], i]</span><br><span class="line">        dic[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n),由于需要维护一个额外的哈希表，因此空间复杂度为O(n)</p>
<h2 id="随机查找">随机查找</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RANDOMIZED-SELECT (A, p, r, i)</span><br><span class="line">    if p==r</span><br><span class="line">        return A[p]</span><br><span class="line">    q = RANDOMlZED-PARTITION(A, p, r)</span><br><span class="line">    k = q-p+I</span><br><span class="line">    if i == k // the pivot value is the answer</span><br><span class="line">        return A[q]</span><br><span class="line">    else if i&lt;k</span><br><span class="line">        return RANOOMIZED-SELECT(A, p, q-1, i)</span><br><span class="line">    else return RANOOMIZED-SELECT(A, q+l, r, i-k</span><br></pre></td></tr></table></figure>
<h2 id="期望线性时间的查找">期望线性时间的查找</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A, p, r, i)  </span><br><span class="line">if p == r  </span><br><span class="line">	return A[p]  </span><br><span class="line">q = RANDOMIZED-PARTITION(A, p, r)  </span><br><span class="line">k = q - p + 1  </span><br><span class="line">if i == k  // the pivot value is the answer  </span><br><span class="line">	return A[q]  </span><br><span class="line">else if i &lt; k  </span><br><span class="line">	return RANDOMIZED-SELECT(A, p, q - 1, i)  </span><br><span class="line">else return RANDOMIZED-SELECT(A, q + 1, r, i - k)</span><br></pre></td></tr></table></figure>
<h2 id="最坏运行时间为线性的中位数查找">最坏运行时间为线性的中位数查找</h2>
<ol type="1">
<li>将输入数组的 n 个元素划分为 ⌊n/5 ⌋组，每组 5 个元素，且至多只有一组由剩下的 nmod5 个元素组成。</li>
<li>寻找这⌈ n/5⌉ 组中每一组的中位数：首先对每组元素进行插入排序，然后确定每组有序元 素的中位数。</li>
<li>对第 2 步中找出的「 n/5 ⌉个中位数，递归调用 SELECT 以找出其中位数 x( 如果有偶数个中 位数，为了方便，约定 x 是较小的中位数）。</li>
<li>利用修改过的 PARTITION 版本，按中位数的中位数 x 对输入数组进行划分。让 K 比划 分的低区中的元素数目多 1, 因此 x 是第 k 小的元素，并且有 n-k 个元素在划分的高区。</li>
<li>如果 i=k, 则返回 x 。如果 i&lt;k, 则在低区递归调用 SELECT 来找出第 i 小的元素。如果 i&gt;k, 则在高区递归查找第 i-k 小的元素。</li>
</ol>
<p>在第 2 步找出的中位数中，至少有一半大千或等于中位数的中位数户。因此，在这「n/5⌉个组中，除了当 n 不能被 5 整除时产生的所含元素少于 5 的那个组和包含 x 的那个组之外，至少有一半的组中有 3 个元素大千 x 。不算这两个组，大于 x 的元素个数至少为： <span class="math inline">\(3\Bigl(\biggl\lceil\frac{1}{2}\biggl\lceil\frac{n}{5}\biggr\vert-2\Bigr)\ge\frac{3n}{10}-6\)</span> 也至少有这个数的元素小于x</p>
<p><span class="math inline">\(T(n)&lt;={T([n/5])+T(7n/10+6)+O(n)}\)</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">A</span>):</span><br><span class="line">    array_num=<span class="built_in">len</span>(A)//<span class="number">5</span></span><br><span class="line">    matrix=[]</span><br><span class="line">    index=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (array_num):</span><br><span class="line">        new_array=[]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            new_array.append(A[index])</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">        matrix.append(new_array)</span><br><span class="line">    <span class="keyword">if</span> index==<span class="built_in">len</span>(A): <span class="keyword">return</span> matrix</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_array=[]</span><br><span class="line">        <span class="keyword">while</span> index&lt;<span class="built_in">len</span>(A):</span><br><span class="line">            new_array.append(A[index])</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">        matrix.append(new_array)</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        base = nums[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; base:</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]  </span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = base  </span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">A,i,j</span>):</span><br><span class="line">    temp=A[i]</span><br><span class="line">    A[i]=A[j]</span><br><span class="line">    A[j]=temp</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, left, right,x</span>):</span><br><span class="line">    i, j = left, right</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; x:</span><br><span class="line">            j -= <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= x:</span><br><span class="line">            i += <span class="number">1</span>  </span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">A,ith</span>):</span><br><span class="line">    matrix = divide(A)<span class="comment">#划分n/5个数组</span></span><br><span class="line">    medium_nums=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):<span class="comment">#产生中位数数组</span></span><br><span class="line">        matrix[i]=insertion_sort(matrix[i])</span><br><span class="line">        medium_nums.append(matrix[i][(<span class="built_in">len</span>(matrix[i])-<span class="number">1</span>)//<span class="number">2</span>])</span><br><span class="line">    medium_nums=insertion_sort(medium_nums)<span class="comment">#对中位数数组排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(medium_nums)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        medium=(<span class="built_in">len</span>(medium_nums)-<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>: medium=<span class="built_in">len</span>(medium_nums)//<span class="number">2</span><span class="comment">#计算出中位数数组的中位数索引并向下取整</span></span><br><span class="line">    x=medium_nums[medium]</span><br><span class="line">    k=partition(A,<span class="number">0</span>,<span class="built_in">len</span>(A)-<span class="number">1</span>,x)+<span class="number">1</span><span class="comment">#划分数组</span></span><br><span class="line">    <span class="keyword">if</span> k==ith: <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">elif</span> ith&lt;k: <span class="keyword">return</span> select(A[<span class="number">0</span>:k],ith)</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> select(A[k:],ith-k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    A=[<span class="number">41</span>,<span class="number">5</span>,<span class="number">46</span>,<span class="number">48</span>,<span class="number">456</span>,<span class="number">1</span>,<span class="number">56</span>,<span class="number">1448</span>,<span class="number">21</span>,<span class="number">84</span>,<span class="number">49</span>,<span class="number">11</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(A)+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;个元素是：&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(select(A,i))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p>
<h1 id="比较排序">比较排序</h1>
<p><img src="/assets/mit6.006总和笔记/image-20231016192215938.png" /></p>
<h2 id="决策树">决策树</h2>
<p>决策树</p>
<ul>
<li>任何算法都可以被视为所执行操作的决策树</li>
<li>内部节点表示二进制比较，分支为 True 或 False</li>
<li>对于比较算法，决策树是二元的</li>
<li>叶子代表算法终止，产生算法输出</li>
<li>根到叶路径表示算法在某些输入上的执行</li>
<li>比较排序的决策树是完全二叉树，因此高度h&gt;=lg(叶节点数)</li>
<li>叶结点数是排列数量，即n!</li>
<li>决策树高度，或者说每条路径的长度就是时间复杂度 <span class="math display">\[n! = \sqrt{2\pi n}\Bigl(\frac{n}{\mathrm{e}}\Bigr)^{n}\Bigl(1 + \frac{1}{12n} + \frac{1}{288n^2} + \cdots\Bigr),\]</span> <span class="math display">\[\ln n! = n\ln n - n +\frac{1}{2}\ln(2\pi n) + \frac{1}{12n} - \frac{1}{360n^3} + \cdots.\]</span> 因此排序下界是nlgn</li>
</ul>
<p>对应的，搜索算法的叶节点数为n个，因此下界是lgn</p>
<h2 id="堆排序">堆排序</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231017150534371.png" /> <strong>本质上是在序列数据结构（数组）之上实现集合数据结构</strong></p>
<p>二叉堆：将数组解释为完全二叉树，深度 i 处最多有 2i 个节点，除了 在最大深度，所有节点均左对齐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left(i) = 2i + 1</span><br><span class="line">right(i) = 2i + 2</span><br><span class="line">parent(i) = mod(i-1/2)</span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231014112423645.png" /></p>
<h3 id="最大堆的生成">最大堆的生成</h3>
<p>本质上是自底向上建堆，从下到上维护最大堆属性，即从倒数第二层由大索引值向顶部进行最大堆性质的维护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Max_Heapify(A,i)</span><br><span class="line">    l = left(i)</span><br><span class="line">    r = right(i)</span><br><span class="line">    if (l &lt;= heap-size(A) and A[l] &gt; A[i])</span><br><span class="line">        then largest = l </span><br><span class="line">    else largest = i</span><br><span class="line">    if (r &lt;= heap-size(A) and A[r] &gt; A[largest])</span><br><span class="line">        then largest = r</span><br><span class="line">    if largest != i</span><br><span class="line">        then exchange A[i] and A[largest]</span><br><span class="line">    Max_Heapify(A, largest)</span><br><span class="line"></span><br><span class="line">//Converts A[1…n] to a max heap</span><br><span class="line">Build_Max_Heap(A):</span><br><span class="line">    for i=n/2 downto 1</span><br><span class="line">        do Max_Heapify(A, i)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Why start at n/2?</span><br><span class="line">Because elements A[n/2 + 1 … n] are all leaves of the tree</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度分析">时间复杂度分析</h3>
<p>每层的时间代价等于节点数乘以节点高度 <img src="https://www.hello-algo.com/chapter_heap/build_heap.assets/heapify_operations_count.png" /> <span class="math display">\[\begin{aligned}
T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \dots + 2^{(h-1)}\times1 \newline
2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \dots + 2^{h-1} + 2^h \newline
\end{aligned}\]</span> <span class="math display">\[\begin{aligned}
T(h) &amp; = 2 \frac{1 - 2^h}{1 - 2} - h \newline
&amp; = 2^{h+1} - h - 2 \newline
&amp; = O(2^h)
\end{aligned}\]</span> 综上得到 <span class="math display">\[O(2^h) = O(n)\]</span></p>
<h3 id="排序策略">排序策略</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorting Strategy:</span><br><span class="line">1. 从未排序数组中构建一个堆</span><br><span class="line">2. 找到最大元素 A[1]并与A[n]交换;</span><br><span class="line">3. n索引处元素出堆，从顶部节点开始维护最大堆属性</span><br><span class="line">4. 顶部节点开始和比它大的最大子节点交换，直到叶节点</span><br></pre></td></tr></table></figure>
<h3 id="top-k问题">top-k问题</h3>
<p>基于堆更加高效地解决 Top-K 问题</p>
<ol type="1">
<li><p>初始化一个最小堆</p></li>
<li><p>前k个元素入堆</p></li>
<li><p>对之后的元素，如果有比堆顶大的元素，则堆顶出堆，该元素入堆</p></li>
<li><p>最后得到top-k元素组成的堆</p></li>
</ol>
<p>时间复杂度是nlgk，不超过nlgn</p>
<h2 id="动态规划和二分搜索树">动态规划和二分搜索树</h2>
<p>实例——机场的动态规划：</p>
<ol type="1">
<li>机场维护一个跑道队列</li>
<li>未来的着陆预定登记到队列</li>
<li>一架飞机着陆后就出队</li>
<li>有新的请求且需要着陆时间t时，如果k时间内没有其他需求，则需求t时间的请求入队(k可以实时改变)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init: R = [ ]</span><br><span class="line">req(t): if t &lt; now: return &quot;error&quot;</span><br><span class="line">for i in range (len(R)):</span><br><span class="line">    if abs(t-R[i]) &lt; k: return &quot;error&quot;</span><br><span class="line">R.append(t)</span><br><span class="line">R = sorted(R)</span><br><span class="line">land: t = R[0]</span><br><span class="line">if (t != now) return error</span><br><span class="line">R = R[1: ] (drop R[0] from R)</span><br></pre></td></tr></table></figure>
<p>Goal: Run this system efficiently in O(lg n) time 常见数据结构运行时间分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">排序链表</span><br><span class="line">- 添加元素并排序需要Θ(nlgn)时间。但是,可以找到插入新时间/航班的位置而不需要添加并排序,但是插入需Θ(n)时间。一旦找到插入位置,k分钟检查可以在O(1)时间内完成。</span><br><span class="line"></span><br><span class="line">排序数组</span><br><span class="line">- 可以使用二分搜索在O(lg n)时间内找到插入位置。使用二分搜索,找到插入索引i,即大于或等于t的最小元素。然后将R[i]和R[i-1]与t进行比较。然而,实际插入需要移位元素,需Θ(n)时间。</span><br><span class="line"></span><br><span class="line">未排序链表/数组</span><br><span class="line">- k分钟检查需要O(n)时间。</span><br><span class="line"></span><br><span class="line">最小堆</span><br><span class="line">- 可以在O(lg n)时间内插入。但是,k分钟检查仍需O(n)时间。</span><br><span class="line"></span><br><span class="line">字典或Python集合</span><br><span class="line">- 插入需要O(1)时间。k分钟检查需要Ω(n)时间</span><br></pre></td></tr></table></figure>
<p>BST的定义： 每个节点都有一个key,左节点的key小于等于父节点，右节点的key大于等于父节点</p>
<p>所有操作都是O(h)即O(lgn)</p>
<p>动态规划中需要找到比一个值大的值中的最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next-larger(x) # x is a node in the BST</span><br><span class="line">if right child not NIL, return minimum(right)</span><br><span class="line">else y = parent(x)</span><br><span class="line">while y not NIL and x = right(y)</span><br><span class="line">    x = y; y = parent(y)</span><br><span class="line">return(y);</span><br></pre></td></tr></table></figure>
<p><code>子问题</code>：如何计算小于等于时间t内着陆的飞机数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历树找到目标时间</span><br><span class="line">2. 从左子树开始遍历，把左侧节点的数量加一则是当前节点的排名，排名则是问题的答案</span><br></pre></td></tr></table></figure>
<p><strong>搜索二叉树可以使用set或者sequence两种数据结构</strong></p>
<p>set:遍历顺序由key的顺序决定</p>
<p>sequence:数组索引就是遍历顺序</p>
<p><img src="/assets/mit6.006总和笔记/image-20231017101953076.png" /> <strong>查找第i大的节点(sequence)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 查找当前节点的排序rank</span><br><span class="line">2. 如果rank &lt; i在右子树寻找排名i-rank的节点</span><br><span class="line">3. 如果rank &gt; i在左子树递归寻找</span><br><span class="line">4. 如果等于，则找到了目标</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以对每个节点维护一个size属性，用左子树的size确认排名</li>
<li>搜索二叉树插入节点很容易实现，但删除节点，如果是有子树的节点，就需要把左子树的最大值或者右子树的最小值与其交换后删除</li>
<li>二叉树的中序遍历正好就是一个排序数组</li>
</ul>
<h2 id="平衡二叉搜索树avl">平衡二叉搜索树AVL</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231017102411122.png" /> • 在动态操作下保持 O(log n) 高度的二叉树称为平衡二叉树 – 有许多平衡方案（红黑树、八字树、2-3 树……） – 第一个提出的平衡方案是 AVL 树 <strong>树的旋转</strong> <img src="/assets/mit6.006总和笔记/image-20231017102819736.png" /> • 定理：O(n) 次旋转可以将二叉树转换为具有相同遍历顺序的任何其他二叉树。 • 证明：按照遍历顺序重复执行最后可能的右旋转； 结果树是 规范链。 每次旋转都会使最后一个节点的深度增加 1。 最后一个节点的深度最多为 n − 1，因此最多执行 n − 1 次旋转，就可以将输入树旋转为目标树。</p>
<p><strong>平衡</strong> AVL 树保持高度平衡（也称为 AVL 属性）</p>
<ul>
<li>如果一个节点的左右子树的高度最多相差 1，则该节点是高度平衡的</li>
<li>节点的倾斜为其右子树的高度减去左子树的高度</li>
<li>如果节点的倾斜度为 −1、0 或 1，则该节点是高度平衡的</li>
</ul>
<p><strong>平衡的维持</strong> 每次对树的修改最多导致左右子树高度相差2，如果相差2，一次旋转就可以重新平衡树 <img src="/assets/mit6.006总和笔记/image-20231017105216748.png" /> <img src="/assets/mit6.006总和笔记/image-20231018222936126.png" /> <img src="/assets/mit6.006总和笔记/image-20231018223015529.png" /> <img src="/assets/mit6.006总和笔记/image-20231018223211763.png" /></p>
<p>AVL 树通过在每个节点存储额外的高度信息,并在每个节点做平衡操作来保持平衡。其平衡调整原则如下:</p>
<ol type="1">
<li>如果左右子树高度相差大于 1,进行旋转操作调整;</li>
<li>进行左旋转的情况:左子树高度 - 右子树高度 &gt; 1,即左子树比右子树高(左重),需要右旋;</li>
<li>进行右旋转的情况:右子树高度 - 左子树高度 &gt; 1,即右子树比左子树高(右重),需要左旋;</li>
<li>旋转后更新节点的高度信息。</li>
<li>每进行一次插入或删除节点后,从该节点开始向上遍历,如果发现任一节点的左右子树高度差大于 1,则在该节点进行旋转操作,调整树的平衡。 由于树的高度最高为lgn，所以logn时间内就可以完成增删节点的操作 <strong>高度属性的维护</strong> 必须确保每个节点的height属性可以通过对height属性的一个O(1)操作完成，这样维护height就不会改变动态操作的复杂度</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">balanceFactor</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>旋转的实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rightRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;left;</span><br><span class="line">    TreeNode *grandChild = child-&gt;right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;right;</span><br><span class="line">    TreeNode *grandChild = child-&gt;left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一共有四种需要平衡的情况 <img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png" /></p>
<table>
<thead>
<tr class="header">
<th>失衡节点的平衡因子</th>
<th>子节点的平衡因子</th>
<th>应采用的旋转方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;1（即左偏树）</td>
<td>&gt;=0</td>
<td>右旋</td>
</tr>
<tr class="even">
<td>&gt;1（即左偏树）</td>
<td>&lt;0</td>
<td>先左旋后右旋</td>
</tr>
<tr class="odd">
<td>&lt;-1（即右偏树）</td>
<td>&lt;=0</td>
<td>左旋</td>
</tr>
<tr class="even">
<td>&lt;-1（即右偏树）</td>
<td>&gt;0</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<p><strong>数据结构的选取</strong> • Set AVL trees achieve O(lg n) time for all set operations, except O(n log n) time for build and O(n) time for iter • Sequence AVL trees achieve O(lg n) time for all sequence operations, except O(n) time for build and iter <strong>插入和删除</strong> 此外，插入节点和删除节点在搜索二叉树基础上，需要分别自底向上和自上向下进行恢复平衡的操作</p>
<h1 id="哈希">哈希</h1>
<p>哈希有可能产生碰撞，需要特定处理或者数据结构，检索元素时间最后会由负载因数(n/m)决定 <img src="/assets/mit6.006总和笔记/image-20231016200400451.png" /> 一般有<strong>链表</strong>和<strong>开放寻址</strong>两种方式解决碰撞</p>
<ul>
<li>链表 期望的查找时间，θ(1+α)，1是哈希函数用时，阿尔法则是查找具体链表需要的时间（链表的期望长度）</li>
<li>开放寻址</li>
</ul>
<h2 id="哈希函数">哈希函数</h2>
<p>常见的哈希函数</p>
<ol type="1">
<li><code>h(k) = k mod m（m是素数，慢)</code></li>
<li><code>h(k) = [(a · k) mod 2w] &gt;&gt; (w − r)</code>(where a is random, k is w bits, and m = 2r.且需要a处于2<sup>(w-1)和2</sup>w之间，且不靠近端点)</li>
<li><code>h(k) = [(ak + b) mod p]</code> mod m where a and b are random ∈ {0, 1, . . . p − 1}, and p is a large prime (&gt; |U|).(了解即可,6.046内容)</li>
</ol>
<h2 id="哈希的优化">哈希的优化</h2>
<p><strong>rehash</strong></p>
<p>Θ(n + m) time = Θ(n) if m = Θ(n)</p>
<p><strong>shrink</strong></p>
<p>当n到达m/4时，收缩到n/2</p>
<h2 id="利用哈希的字符串匹配算法">利用哈希的字符串匹配算法</h2>
<h3 id="karp-rabin-algorithm">Karp-Rabin Algorithm</h3>
<p>Rabin-Karp算法是一种字符串匹配算法,利用滚动哈希技术实现。其基本思想是:</p>
<ol type="1">
<li>对文本和模式分别计算哈希值;</li>
<li>滚动文本,每次比较文本窗口和模式的哈希值;</li>
<li>如果哈希值相同,则进行字符匹配确认;</li>
<li>如果不相同,则可以直接跳到下一位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• Compare h(s) == h(t[i : i + len(s)])</span><br><span class="line">• If hash values match, likely so do strings</span><br><span class="line">– can check s == t[i : i + len(s)] to be sure ∼ cost O(|s|)</span><br><span class="line">– if yes, found match — done</span><br><span class="line">– if no, happened with probability &lt; 1/|s|</span><br><span class="line">= expected cost is O(1) per i.</span><br><span class="line">⇒</span><br><span class="line">• need suitable hash function.</span><br><span class="line">• expected time = O(|s| + |t| · cost(h)).</span><br><span class="line">– naively h(x) costs |x|</span><br><span class="line">– we’ll achieve O(1)!</span><br><span class="line">– idea: t[i : i + len(s)] ≈ t[i + 1 : i + 1 + len(s)]</span><br></pre></td></tr></table></figure>
<p><strong>rolling hash</strong></p>
<p>Rolling Hash ADT</p>
<p>Maintain string x subject to</p>
<ul>
<li>r(): reasonable hash function h(x) on string x</li>
<li>r.append(c): add letter c to end of string x</li>
<li>r.skip(c): remove front letter from string x, assuming it is</li>
</ul>
<p>伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for c in s: rs.append(c)</span><br><span class="line">for c in t[:len(s)]: rt.append(c)</span><br><span class="line">if rs() == rt(): ...</span><br><span class="line">//This first block of code is O( s )</span><br><span class="line">for i in range(len(s), len(t)):</span><br><span class="line">rt.skip(t[i-len(s)])</span><br><span class="line">rt.append(t[i])</span><br><span class="line">if rs() == rt(): ...</span><br><span class="line">//The second block of code is O(|t|) + O(# matches − |s|) to verify.</span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231019194313076.png" /></p>
<h2 id="开放寻址">开放寻址</h2>
<p>哈希时需要引入哈希次数i，持续哈希直到找到空槽 <strong>插入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in xrange(m):</span><br><span class="line">    if T [h(k, i)] is None: #empty slot</span><br><span class="line">        T [h(k, i)] = (k, v) #store item</span><br><span class="line">        return</span><br><span class="line">raise ‘full&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>查找</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in xrange(m):</span><br><span class="line">    if T [h(k, i)] is None: #empty slot?</span><br><span class="line">        return None #end of “chain”</span><br><span class="line">    elif T [h(k, i)][∅] == k: #matching key</span><br><span class="line">        return T [h(k, i)] #return item</span><br><span class="line">    return None ˙ #exhausted table</span><br></pre></td></tr></table></figure>
<p><strong>删除</strong></p>
<p>由于防止查找操作误判，需要特定的删除标志，把待删除函数设置为已删除，让插入视为None,查找视为存在 <img src="/assets/mit6.006总和笔记/image-20231019195835085.png" /></p>
<h3 id="优化">优化</h3>
<p>问题：可能出现<em>簇</em>现象，某些元素连续聚集于一处，导致查找操作耗时较高</p>
<p>eg.线性哈希h(k, i) = (h′(k) +i)</p>
<p>更好的解决方案：<code>h(k, i) =(h1(k) +i·h2(k)) mod m</code> where h1(k) and h2(k) are two ordinary hash func-tions.</p>
<h3 id="性能">性能</h3>
<p>第一次查找成功的概率p=m-n/m</p>
<p>第二次概率为m-n/m-1大于p</p>
<p>由此类推，成功概率至少为p</p>
<p>1/p=1/1-α</p>
<p>所以期望时间为O(1/(1 − α))</p>
<h3 id="与链表的比较">与链表的比较</h3>
<p>优点：更有效地利用空间，不需要储存指针</p>
<p>缺点：链表对哈希函数和负载值的要求更低，开放寻址高负载时性能大降，且无法有大于一的α</p>
<h2 id="安全领域的哈希">安全领域的哈希</h2>
<p>哈希在加密上应用广泛，例如：</p>
<ol type="1">
<li>加密密码，存储密码的哈希码来防止泄露的危害</li>
<li>文件完整性校验，利用哈希来给出文件几乎唯一的哈希值来防止对文件的暗中篡改，也用于git之类的版本控制软件</li>
<li>数字签名，用私钥加密数据，其他人可以用公钥检验，来确保发信者身份正规 <a href="https://thinklive1.github.io/2023/10/12/sysadmin/">详细可见Sysadmin decal笔记</a></li>
</ol>
<h1 id="没涉及的其他排序">6.006没涉及的其他排序</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>「冒泡排序 bubble sort」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。 设数组的长度为n，冒泡排序的步骤</p>
<ol type="1">
<li>首先，对 <code>n</code> 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>，</li>
<li>接下来，对剩余<code>n-1</code>个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li>
<li>以此类推，经过<code>n-</code>轮“冒泡”后，<strong>前</strong><code>n-1</code> <strong>大的元素都被交换至正确位置</strong>。</li>
<li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_sort_overview.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>性能和特性</strong>： - 最差和平均都是O(n^2)，但比较适合数组有一定秩序性的时候 - 原地稳定排序</p>
<h2 id="快速排序">快速排序</h2>
<p>「快速排序 quick sort」是一种基于分治策略的排序算法，核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</p>
<ol type="1">
<li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li>
<li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li>
<li>循环执行步骤 <code>2.</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PARTITION(A, p, r)</span><br><span class="line"> i =RANOOM(p, r)</span><br><span class="line"> exchange A[r] with A[i]</span><br><span class="line"> x = A[r]</span><br><span class="line"> i = p —1</span><br><span class="line"> for j=p to r-1</span><br><span class="line">  if A[j]&lt;=x</span><br><span class="line">  i = i + 1</span><br><span class="line">  exchange A[i] with A[j]</span><br><span class="line"> exchange A[i+ l] with A[r]</span><br><span class="line"> return i + 1</span><br><span class="line"></span><br><span class="line">QUICKSORT(A, p, r)</span><br><span class="line">if p&lt;r</span><br><span class="line"> q = PARTITION(A, p, r)</span><br><span class="line"> QUICKSORT(A, p, q-1)</span><br><span class="line"> QUICKSORT(A, q+ 1, r)</span><br></pre></td></tr></table></figure>
<p>python实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;哨兵划分&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 以 nums[left] 作为基准数</span></span><br><span class="line">    i, j = left, right</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt;= nums[left]:</span><br><span class="line">            j -= <span class="number">1</span>  <span class="comment"># 从右向左找首个小于基准数的元素</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[left]:</span><br><span class="line">            i += <span class="number">1</span>  <span class="comment"># 从左向右找首个大于基准数的元素</span></span><br><span class="line">        <span class="comment"># 元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    <span class="comment"># 将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i  <span class="comment"># 返回基准数的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 哨兵划分</span></span><br><span class="line">    pivot = self.partition(nums, left, right)</span><br><span class="line">    <span class="comment"># 递归左子数组、右子数组</span></span><br><span class="line">    self.quick_sort(nums, left, pivot - <span class="number">1</span>)</span><br><span class="line">    self.quick_sort(nums, pivot + <span class="number">1</span>, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化： - 对主元选取可以用随机数或者取样一些元素选取中位数来实现稳定的nlgn性能 - 对相等元素较多的数组，可以进行三路快排，只需要递归排序不等于主元的两路 - 尾递归优化,在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过n/2 ，因此这种方法能确保递归深度不超过lgn ，从而将最差空间复杂度优化至lgn。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序（尾递归优化）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 子数组长度为 1 时终止</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 哨兵划分操作</span></span><br><span class="line">        pivot = self.partition(nums, left, right)</span><br><span class="line">        <span class="comment"># 对两个子数组中较短的那个执行快排</span></span><br><span class="line">        <span class="keyword">if</span> pivot - left &lt; right - pivot:</span><br><span class="line">            self.quick_sort(nums, left, pivot - <span class="number">1</span>)  <span class="comment"># 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>  <span class="comment"># 剩余未排序区间为 [pivot + 1, right]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.quick_sort(nums, pivot + <span class="number">1</span>, right)  <span class="comment"># 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>  <span class="comment"># 剩余未排序区间为 [left, pivot - 1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="堆排序-1">堆排序</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, i: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;堆的长度为 n ，从节点 i 开始，从顶至底堆化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">        ma = i</span><br><span class="line">        <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> nums[l] &gt; nums[ma]:</span><br><span class="line">            ma = l</span><br><span class="line">        <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> nums[r] &gt; nums[ma]:</span><br><span class="line">            ma = r</span><br><span class="line">        <span class="comment"># 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 交换两节点</span></span><br><span class="line">        nums[i], nums[ma] = nums[ma], nums[i]</span><br><span class="line">        <span class="comment"># 循环向下堆化</span></span><br><span class="line">        i = ma</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;堆排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 建堆操作：堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift_down(nums, <span class="built_in">len</span>(nums), i)</span><br><span class="line">    <span class="comment"># 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 交换根节点与最右叶节点（即交换首元素与尾元素）</span></span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 以根节点为起点，从顶至底进行堆化</span></span><br><span class="line">        sift_down(nums, i, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>性质：nlgn,原地非稳定</p>
<h2 id="计数排序">计数排序</h2>
<ol type="1">
<li>遍历数组，找出数组中的最大数字，记为 ，然后创建一个长度为- 的辅助数组 <code>counter</code> 。</li>
<li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加即可。</li>
<li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经被排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字的出现次数，将它们按从小到大的顺序填入 <code>nums</code> 即可。 <img src="https://www.hello-algo.com/chapter_sorting/counting_sort.assets/counting_sort_overview.png" /></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COUNTlNG-SORT(A, B, k)</span><br><span class="line">let C[O .. k] be a new array</span><br><span class="line">for i=O to k</span><br><span class="line"> C[i] = O</span><br><span class="line">for j = 1 to A. length</span><br><span class="line"> C[A[j]]=C[A[j]J+ 1</span><br><span class="line">//C[i] now contains the number of elements equal to i.</span><br><span class="line">for i=1 to k</span><br><span class="line"> C[i]=C[i]+C[i-1]</span><br><span class="line">//C[i] now contains the number of elements less than or equal to i.</span><br><span class="line">for j = A. length downto 1</span><br><span class="line"> B[C[A[j]J]=A[j]</span><br><span class="line"> C[A[j]]=C[A[j]]-1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计数排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 完整实现，可排序对象，并且是稳定排序</span></span><br><span class="line">    <span class="comment"># 1. 统计数组最大元素 m</span></span><br><span class="line">    m = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="comment"># 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment"># counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter = [<span class="number">0</span>] * (m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        counter[num] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span><br><span class="line">    <span class="comment"># 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        counter[i + <span class="number">1</span>] += counter[i]</span><br><span class="line">    <span class="comment"># 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span><br><span class="line">    <span class="comment"># 初始化数组 res 用于记录结果</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        num = nums[i]</span><br><span class="line">        res[counter[num] - <span class="number">1</span>] = num  <span class="comment"># 将 num 放置到对应索引处</span></span><br><span class="line">        counter[num] -= <span class="number">1</span>  <span class="comment"># 令前缀和自减 1 ，得到下次放置 num 的索引</span></span><br><span class="line">    <span class="comment"># 使用结果数组 res 覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>特性</strong>：虽然是线性时间O(n+m)，实际上时间复杂收到输入数据大小范围的影响,不能直接支持负数，需要将负数数组转换成非负数的排序,非原地稳定排序，空间也是O(n+m)</p>
<h2 id="基数排序">基数排序</h2>
<p>假设数字的最低位是第1位，最高位是第8位，基数排序的流程:</p>
<ol type="1">
<li>初始化位数`k=1</li>
<li>对学号的第<code>k</code>位执行“计数排序”。完成后，数据会根据第<code>k</code> 位从小到大排序。</li>
<li>将<code>k</code>增加 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_sorting/radix_sort.assets/radix_sort_overview.png" /> 获取第k位数的方法： <span class="math display">\[x_k = \lfloor\frac{x}{d^{k-1}}\rfloor \bmod d\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">digit</span>(<span class="params">num: <span class="built_in">int</span>, exp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取元素 num 的第 k 位，其中 exp = 10^(k-1)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num // exp) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort_digit</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], exp: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计数排序（根据 nums 第 k 位排序）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 十进制的位范围为 0~9 ，因此需要长度为 10 的桶</span></span><br><span class="line">    counter = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        d = digit(nums[i], exp)  <span class="comment"># 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d] += <span class="number">1</span>  <span class="comment"># 统计数字 d 的出现次数</span></span><br><span class="line">    <span class="comment"># 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        counter[i] += counter[i - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    res = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        d = digit(nums[i], exp)</span><br><span class="line">        j = counter[d] - <span class="number">1</span>  <span class="comment"># 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i]  <span class="comment"># 将当前元素填入索引 j</span></span><br><span class="line">        counter[d] -= <span class="number">1</span>  <span class="comment"># 将 d 的数量减 1</span></span><br><span class="line">    <span class="comment"># 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基数排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    m = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="comment"># 按照从低位到高位的顺序遍历</span></span><br><span class="line">    exp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> exp &lt;= m:</span><br><span class="line">        <span class="comment"># 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment"># k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment"># k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment"># 即 exp = 10^(k-1)</span></span><br><span class="line">        counting_sort_digit(nums, exp)</span><br><span class="line">        exp *= <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性： - 时间复杂度O(k(n+d))，k是位数，d是进制,d会决定计数排序需要的数组长度，k决定进行几次计数排序 - 空间复杂度O(n+d),稳定排序(从低到高排序)</p>
<h2 id="桶排序">桶排序</h2>
<ol type="1">
<li>初始化 <code>k</code> 个桶，将<code>n</code>个元素分配到<code>k</code>个桶中</li>
<li>对每个桶分别执行排序</li>
<li>按照桶的从小到大的顺序，合并结果 <img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/bucket_sort_overview.png" /></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">float</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;桶排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span><br><span class="line">    k = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    <span class="comment"># 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">        i = <span class="built_in">int</span>(num * k)</span><br><span class="line">        <span class="comment"># 将 num 添加进桶 i</span></span><br><span class="line">        buckets[i].append(num)</span><br><span class="line">    <span class="comment"># 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="comment"># 使用内置排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        bucket.sort()</span><br><span class="line">    <span class="comment"># 3. 遍历桶合并结果</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性：</p>
<ol type="1">
<li><strong>时间复杂度</strong><code>O(n+k)</code> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为<code>n/k</code> 。假设排序单个桶使用<code>(n/k)*lg(n/k)</code>时间，则排序所有桶使用<code>n*lg(n/k)</code>时间。<strong>当桶数量</strong><code>k</code><strong>比较大时，时间复杂度则趋向于<code>O(n)</code></strong> 。合并结果时需要遍历所有桶和元素，花费<code>O(n+k)</code>时间。在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用<code>O(n^2)</code>时间。</li>
<li><strong>空间复杂度</strong>O(n+k)</li>
<li><strong>非原地排序</strong>：需要借助<code>k</code>个桶和总共<code>n</code> 个元素的额外空间。</li>
<li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li>
</ol>
<p>改良： 平均分配可以对较大的桶递归 <img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/scatter_in_buckets_recursively.png" /> 或者根据概率正态分布划分桶</p>
<h2 id="总结">总结</h2>
<p><img src="https://www.hello-algo.com/chapter_sorting/summary.assets/sorting_algorithms_comparison.png" /></p>
<h1 id="数值运算">数值运算</h1>
<h2 id="catalan-numbers">Catalan numbers</h2>
<p>Set P of balanced parentheses strings(平衡括号字符串) are recursively defined as • λ ∈ P (λ is empty string) • If α, β ∈ P , then (α)β ∈ P Cn: number of balanced parentheses strings with exactly n pairs of parentheses 也等于n+1个叶节点构成满二叉树的形状个数 <img src="/assets/mit6.006总和笔记/image-20231020131123959.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印前 n 个卡特兰数</span></span><br><span class="line">ans, n = <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br></pre></td></tr></table></figure>
<h2 id="newtons-method牛顿迭代法">Newton’s Method牛顿迭代法</h2>
<p><span class="math display">\[
x_{i+1} = x_{i} - \frac{f(x_{i})}{f&#39;(x_{i})}
\]</span></p>
<h3 id="高精度乘法">高精度乘法</h3>
<p>Multiplying two n-digit numbers (radix r = 2, 10) 0 ≤ x, y &lt; rn x1 = high half;x0 = low half <span class="math display">\[
x = x_{1} \cdot r^{\frac{n}{2}} + x_{0}
\]</span> <span class="math display">\[
y = y_{1} \cdot r^{\frac{n}{2}} + y_{0}
\]</span> <span class="math display">\[
z = x · y = x_1y_1 · r^n + (x_0 · y_1 + x_1 · y_0)r^{n/2} + x_0 · y_0
\]</span></p>
<p>θ(n^2) time</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Schönhage-Strassen算法是一种快速整数乘法算法,由Arnold Schönhage和Volker Strassen在1971年提出。它比传统的乘法算法要快得多,其时间复杂度为O(n log n log log n)。</span><br><span class="line">Schönhage-Strassen算法的基本思想是:</span><br><span class="line">1. 将两个n位数a和b拆分成大约n/2位数的块。例如,1234 = 12, 34;   2345 = 23, 45。</span><br><span class="line">2. 计算所有块之间的乘积,得到4个结果:a1b1, a1b2, a2b1, a2b2。这可以用递归方式计算。</span><br><span class="line">3. 根据分块的位数 Shift 加上进位,得到a1b1*(10^n), a1b2*10^n/2, a2b1*10^n/2, a2b2。</span><br><span class="line">4. 最后将4个结果相加,得到a*b。</span><br><span class="line">5. 例如,计算12345 * 6789:</span><br><span class="line">6. 分块:12, 34,   67, 892. 计算块间乘积:12 * 67 = 804,   12 * 89 = 1068, 34 * 67 = 2298, 34 * 89 = 3026 </span><br><span class="line">7. Shift并加进位:804 * 10000, 1068 * 5000, 2298 * 5000, 30264. </span><br><span class="line">8. 相加:8040000 + 5340000 + 11490000 + 15130000 = 123456791这种算法通过分块和递归减少每一步的计算量,在计算两个大整数的乘积时有很高的效率,尤其适用于超长整数的相乘。它在一定程度上简化了超长整数运算,是数论和计算机科学中很有价值的一种算法。</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong> <img src="/assets/mit6.006总和笔记/image-20231020135416200.png" /> <strong>误差分析</strong> <img src="/assets/mit6.006总和笔记/image-20231020140715299.png" /> <span class="math display">\[
ε_{n+1} =  \frac{ε_n^2}{2*(1+ε_n)}
\]</span></p>
<h3 id="高精度除法">高精度除法</h3>
<p>a/b -&gt; 1/b*a - &gt; mod(R/b) // R是一个容易除的较大值</p>
<p><img src="/assets/mit6.006总和笔记/image-20231020141331913.png" /> <img src="/assets/mit6.006总和笔记/image-20231020141401286.png" /> 除法的复杂度等于乘法 To understand this, assume that the complexity of multiplication is Θ(nα) for n- digit numbers, with α ≥ 1. Division requires multiplication of different-sized numbers at each iteration. Initially the numbers are small, and then they grow to d digits.</p>
<p>We apply a first level of Newton’s method to solve f (x) = x2 − a. Each iteration of this first level1 requires a division. If we set the precision to d digits right from the beginning, then convergence at the first level will require lg d iterations. This means the complexity of computing a square root will be Θ(dα lg d) if the complexity of multiplication is Θ(dα), given that we have shown that the complexity of division is the same as the complexity of multiplication. However, we can do better, if we recognize that the number of digits of precision we need at beginning of the first level of Newton’s method starts out small and then grows. If the complexity of a d-digit division is Θ(dα), then a similar summation to the one above tells us that the complexity of computing square roots is Θ(dα)</p>
<h1 id="图论">图论</h1>
<h2 id="概念">概念</h2>
<p>图：for each vertex u ∈ V, Adj[u] stores u’s neighbors, i.e., {v ∈ V | (u, v) ∈ E}. Adj 的大小为 θ(|V |)，而每个 Adj(u) 的大小为 θ(deg(u))</p>
<p>表示分为邻接表和邻接矩阵 <img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png" /> <img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png" /> <img src="/assets/mit6.006总和笔记/QQ图片20231121160100.png" /></p>
<h3 id="路径">路径</h3>
<ul>
<li>路径是顶点序列p=(v1,v2,...,vk),其中(vi,vi+1)∈E, 1≤i&lt;k<br />
</li>
<li>如果路径上没有重复顶点,则为简单路径<br />
</li>
<li>路径p的长度为路径上的边数<br />
</li>
<li>u到v的距离δ(u,v)为从u到v的最短路径长度</li>
</ul>
<p><strong>路径问题</strong>:</p>
<ul>
<li>图中的多种路径问题:<br />
  - 单源可达性:s是否可达t<br />
  - 单源最短路径:返回δ(s,t)和s到t的最短路径<br />
  - 单源最短路径:返回从s到所有v的δ(s,v)和最短路径树<br />
</li>
<li>如何对每个顶点返回从源s的最短路径?<br />
</li>
<li>返回所有路径需Ω(|V|^2)时间<br />
</li>
<li>只存储每个v的父节点P(v),s的父节点为空<br />
</li>
<li>父节点构成包含从s可达所有最短路径的最短路径树,大小为O(|V|)</li>
</ul>
<h2 id="bst">BST</h2>
<p><strong>应用</strong></p>
<ul>
<li>网络抓取（Google 如何查找页面）</li>
<li>社交网络（Facebook 好友查找器）</li>
<li>网络广播路由</li>
<li>垃圾收集</li>
<li>模型检查（有限状态机）</li>
<li>检查数学猜想</li>
<li>解决谜题和游戏</li>
</ul>
<p>如何计算图中所有顶点v的δ(s,v)和P(v)?</p>
<ul>
<li>使用集合数据结构来存储每个顶点v对应的δ(s,v)距离和P(v)父节点。<br />
</li>
<li>如果从起点s到v没有路径,则不存储在P中,δ(s,v)设为无穷大。</li>
</ul>
<p><strong>基本思路</strong>: - 按照与起点s的距离依次增大的顺序探索图的节点。</p>
<p><strong>目标</strong>:<br />
- 计算所有与起点s距离为i的顶点的集合Li。结论:<br />
- Li中的任意顶点v必须与L_{i-1}中的某个顶点u相连。<br />
- 不会有任何距离起点距离为j(j&lt;i)的顶点出现在Li中。</p>
<p><strong>循环不变量:</strong><br />
- 在计算到Li之前,δ(s,v)和P(v)对于所有Lj(j&lt;i)中的顶点v都已正确赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BFS (V,Adj,s): See CLRS for queue-based implementation</span><br><span class="line">    level = &#123; s: 0 &#125;</span><br><span class="line">    parent = &#123;s : None &#125;</span><br><span class="line">    i = 1</span><br><span class="line">    frontier = [s] # previous level, i − 1</span><br><span class="line">    while frontier:</span><br><span class="line">        next = [ ] # next level, i</span><br><span class="line">        for u in frontier:</span><br><span class="line">            for v in Adj [u]:</span><br><span class="line">                if v not in level: # not yet seen</span><br><span class="line">                    level[v] = i # = level[u] + 1</span><br><span class="line">                    parent[v] = u</span><br><span class="line">                    next.append(v)</span><br><span class="line">        frontier = next</span><br><span class="line">        i + =1</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">graph_bfs</span>(<span class="params">graph: GraphAdjList, start_vet: Vertex</span>) -&gt; <span class="built_in">list</span>[Vertex]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;广度优先遍历 BFS&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">    <span class="comment"># 顶点遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    visited = <span class="built_in">set</span>[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 队列用于实现 BFS</span></span><br><span class="line">    que = deque[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(que) &gt; <span class="number">0</span>:</span><br><span class="line">        vet = que.popleft()  <span class="comment"># 队首顶点出队</span></span><br><span class="line">        res.append(vet)  <span class="comment"># 记录访问顶点</span></span><br><span class="line">        <span class="comment"># 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> adj_vet <span class="keyword">in</span> graph.adj_list[vet]:</span><br><span class="line">            <span class="keyword">if</span> adj_vet <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 跳过已被访问过的顶点</span></span><br><span class="line">            que.append(adj_vet)  <span class="comment"># 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adj_vet)  <span class="comment"># 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment"># 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本情况(i=1):</p>
<ul>
<li>L0={s},δ(s,s)=0,P(s)=None归纳步骤: (L表示level)</li>
<li>计算Li时:<br />
  - 对Li-1中的每个顶点u:<br />
    - 对于任一不在Lj(j&lt;i)中的相邻顶点v:<br />
      - 将v加入Li,设置δ(s,v)=i,P(v)=u重复计算:</li>
<li>按i递增顺序重复计算Li,直到Li为空集<br />
</li>
<li>对任一不可达顶点v,设置δ(s,v)=∞</li>
<li>因此通过归纳证明,广度优先搜索可以正确计算所有δ(s,v)和P(v)。</li>
</ul>
<p><strong>时间复杂度分析</strong>:</p>
<ul>
<li>用支持快速遍历和插入的数据结构存储Li<br />
</li>
<li>通过检查P来判断一个顶点是否在Lj(j&lt;i)中<br />
</li>
<li>用支持O(1)操作的字典结构存储δ和P<br />
</li>
<li>每个顶点u最多加入一个Li,并对每个邻点v做O(1)操作<br />
</li>
<li>以上这些部分是O(|E|)</li>
<li>最后处理不可达顶点需O(|V|)<br />
</li>
<li>所以总时间复杂度是O(|V|+|E|)</li>
</ul>
<p><span class="math display">\[
level[v] = \begin{cases}
           level &amp; \text{if } v \text{ assigned level} \\\\
           \infty &amp; \text{else (no path)}
\end{cases}
\]</span></p>
<h2 id="dst">DST</h2>
<p>基本思想:</p>
<ul>
<li>递归访问出边邻接顶点,但不重复访问已访问过的顶点。<br />
</li>
<li>尽可能深入探索路径,直到无法继续,然后回溯找到未探索的路径。 执行步骤:</li>
<li>初始化P(s)=None,执行visit(s)过程:<br />
  - 对每个未在P中出现的邻接顶点v:设P(v)=u并递归调用visit(v)<br />
  - 标记访问完顶点u(用于拓扑排序) 不用返回distance,因此时间是O(E)</li>
</ul>
<p>全BFS和全DFS:</p>
<ul>
<li>目标是探索整个图,而不仅仅是一个源点可达的部分。<br />
</li>
<li>重复在任一未访问顶点s上运行BFS或DFS,直到所有顶点都被访问。<br />
</li>
<li>时间复杂度都是O(|V| + |E|)</li>
</ul>
<p>连通分量:</p>
<ul>
<li>将无向图的顶点集分割成子集Vi,使每个Vi内部连通,Vi之间无边。连通性算法:<br />
</li>
<li>任意单源可达性算法A都可以求解连通分量。<br />
</li>
<li>重复运行全A,每次A访问的顶点集就是一个连通分量。</li>
</ul>
<p>连通性算法:</p>
<ul>
<li>任意单源可达性算法A都可以求解连通分量。<br />
</li>
<li>重复运行全A,每次A访问的顶点集就是一个连通分量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parent = &#123;s: None&#125;</span><br><span class="line">DFS-visit (V, Adj, s):</span><br><span class="line">    for v in Adj [s]:</span><br><span class="line">        if v not in parent:</span><br><span class="line">            parent [v] = s</span><br><span class="line">            DFS-visit (V, Adj, v)</span><br><span class="line">DFS (V, Adj):</span><br><span class="line">    parent = &#123; &#125;</span><br><span class="line">    for s in V:</span><br><span class="line">        if s not in parent:</span><br><span class="line">            parent [s] = None</span><br><span class="line">            DFS-visit (V, Adj, s)</span><br></pre></td></tr></table></figure>
<p>O(V + E)</p>
<p><strong>总结</strong>：</p>
<ul>
<li>Single-Source Shortest Paths with BFS in O(|V | + |E|) time (return distance per vertex)</li>
<li>Single-Source Reachability with BFS or DFS in O(|E|) time (return only reachable vertices)</li>
<li>Connected components with Full-BFS or Full-DFS in O(|V | + |E|) time</li>
<li>Topological Sort of a DAG with Full-DFS in O(|V | + |E|) time</li>
</ul>
<h3 id="拓扑排序算法">拓扑排序算法</h3>
<ul>
<li>DFS访问每个顶点v时,记录DFS结束顺序finish[v]<br />
</li>
<li>按finish[v]递减顺序输出顶点具体步骤:</li>
</ul>
<ol type="1">
<li>通过DFS遍历图<br />
</li>
<li>将顶点按finish[v]时间降序插入order<br />
</li>
<li>将order反转 <strong>正确性证明</strong>:<br />
对任意边(u,v)有u在v之前</li>
</ol>
<ul>
<li>如果u先访问:<br />
  - 在访问u结束前会访问v(直接或间接)<br />
  - 因此v结束时间在u之前<br />
</li>
<li>如果v先访问:<br />
  - 图无环<br />
  - 无法从v访问u<br />
  - 因此v结束时间在u之前因此DFS结束时间递减顺序即为拓扑排序顺序。</li>
</ul>
<h3 id="循环检测算法">循环检测算法</h3>
<p><strong>利用全DFS检测环</strong>:</p>
<ul>
<li>如果无向图无环,全DFS的反序order就是拓扑排序。<br />
</li>
<li>对每条边 (u, v)，反序中如果v不在u前，就有环<br />
</li>
<li>可以在O(|E|)时间内检测反序是否有环（哈希或者数组的数据结构）</li>
</ul>
<p><strong>定位环的算法</strong>:</p>
<ul>
<li>在全DFS过程中维护当前顶点的祖先集合</li>
<li>如果DFS遍历到一条从v到其祖先的边,则存在环。</li>
</ul>
<p><strong>正确性证明</strong>:</p>
<ul>
<li>设图包含环(v0,v1,...,vk,v0),假设v0首先被DFS访问。<br />
</li>
<li>对每个vi,在访问vi结束前会访问vi+1并结束。<br />
</li>
<li>最后在访问vk结束前会访问v0,此时v0是vk的祖先。</li>
</ul>
<h2 id="最短路径">最短路径</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231024194703867.png" /></p>
<ul>
<li>路径π的权重w(π)是路径上所有边权重之和<br />
</li>
<li>s到t的最短路径是从s到t权重最小的路径</li>
<li>δ(s,t)表示从s到t的最短路径权重</li>
<li>对一般权图,还不知道O(|V|+|E|)的最短路径算法<br />
</li>
<li>但对DAG可以在O(|V|+|E|)时间内求解</li>
</ul>
<h3 id="简单最短路径">简单最短路径</h3>
<p>简单的最短路径 • 如果图表包含循环和负权重，则可能包含负权重循环 • 如果图形不包含负权环，则最短路径很简单！ • 主张 1：如果 δ(s, v) 是有限的，则存在一条到 v 的最短路径，该路径很简单 • 证明： 通过反证法： – 假设没有简单的最短路径； 设 π 为顶点最少的最短路径 – π 不简单，所以 π 中存在环 C； C 具有非负权重（或者 δ(s, v) = −∞） – 从 π 中删除 C 形成路径 π0，具有更少的顶点和权重 w(π0) ≤ w(π) • 由于简单路径不能重复顶点，因此有限最短路径最多包含 |V | − 1 条边</p>
<h3 id="有权图基础">有权图基础</h3>
<h4 id="最小生成树">最小生成树</h4>
<p>If know δ(s, v) for all vertices v ∈ V , can construct shortest-path tree in O(|V | + |E|) time</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initialize empty parent pointer P and set P(s) = NoneFor each vertex u ∈ V where δ(s, u) is finite:  </span><br><span class="line">  For each outgoing neighbor v ∈ Adj+(u):  </span><br><span class="line">    If P(v) is not assigned and δ(s, v) = δ(s, u) + w(u, v):  </span><br><span class="line">      There exists a shortest path through edge (u, v), so set P(v) = uParent pointers may traverse cycles of zero weight. Mark each vertex in such a cycle.For each unmarked vertex u ∈ V (including vertices later unmarked):  </span><br><span class="line">  For each v ∈ Adj+(u) where v is marked and δ(s, v) = δ(s, u) + w(u, v):  </span><br><span class="line">    Unmark vertices in cycle containing v by traversing parent pointers from v  </span><br><span class="line">    Set P(v) = u, breaking the cycle</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>初始化父节点指针P，设置P(s)为空</li>
<li>对u的每条出边通向的节点v</li>
<li>如果P(v)为空且s-&gt;v最短路径是s-&gt;u-&gt;v,则P(v)=u</li>
<li>父节点可能导致一个权值为0的循环，如果有环则标记出来</li>
<li>对每个没有被标记的u(包括之后会被标记的)</li>
<li>如果有标记的邻居v满足最短路径条件</li>
<li>通过遍历v的父节点清除对它和它的父节点的标记</li>
<li>设置P(v)=u，打破循环</li>
</ol>
<h4 id="dag松弛算法">DAG松弛算法:</h4>
<ol type="1">
<li><p>对每个顶点v维护一个距离估计d(s,v),初始化为无穷大,始终上界真实最短距离δ(s,v)</p></li>
<li><p>当边(u,v)违反三角不等式时,通过松弛操作将d(s,v)降低为d(s,u)+w(u,v)</p></li>
<li><p>松弛操作保证了d(s,v)始终是到v的某条路径的权重(或无穷大)</p></li>
<li><p>算法流程:<br />
  - 初始化d(s,v)=无穷大,d(s,s)=0<br />
   - 按拓扑排序顺序遍历每个顶点u<br />
     - 对每个出边(u,v),如果d(s,v) &gt; d(s,u)+w(u,v),执行松弛操作</p></li>
<li><p>可以证明当算法结束时,d(s,v)=δ(s,v),即正确计算出最短距离</p></li>
<li><p>时间复杂度为O(V+E),是线性时间算法</p></li>
<li><p>主要思想是利用DAG没有环的特点,通过松弛操作逐步收紧距离上界,直到使其等于最短距离</p></li>
<li><p>利用拓扑排序的顺序,保证每次松弛时通过的顶点u的d(s,u)已经是最短距离</p></li>
</ol>
<h3 id="generic-s.p.-algorithm通用最短路径算法">Generic S.P. Algorithm通用最短路径算法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Initialize:            for v in V:</span><br><span class="line">                            d[v] ← ∞</span><br><span class="line">                            Π[v] ← NIL</span><br><span class="line">                        d[s] ← 0</span><br><span class="line"></span><br><span class="line">Main:                  Repeat</span><br><span class="line">                       select edge (u, v)</span><br><span class="line">Relax edge (u, v):         if d[v] &gt; d[u] + w(u, v):</span><br><span class="line">                               d[v] ← d[u] + w(u, v)</span><br><span class="line">                               Π[v] ← u</span><br><span class="line">                        until you can’t relax any more edges or you’re tired or . .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 u 到 v 的最短路径权重是 δ(u, v)。 如果从 u 无法到达 v，则 δ(u, v) 为 Infini， 如果从 u 到 v 的某个路径上存在负循环，则未定义。 <img src="/assets/mit6.006总和笔记/image-20231023103416467.png" /> <img src="/assets/mit6.006总和笔记/image-20231023104514707.png" /> PATHological示例:设置n个节点,前3对节点的边权为2<sup>n/2,第二组节点边权为2</sup>(n/2)-1,以此类推。这样设置权重,从v0到vn-1的距离约为2<sup>n。算法可能每次只将距离减少1,需重复2</sup>n次,时间复杂度为O(2^n)。 因此最短路径算法的性能很大程度上取决于图的结构,存在PATHological情况时算法效率很低。需设计改进的算法,避免指数时间复杂度。</p>
<h3 id="迪杰斯特拉无负数边的图">迪杰斯特拉（无负数边的图）</h3>
<ol type="1">
<li>初始化:对每个顶点v,设置d(s,v)=∞,d(s,s)=0。</li>
<li>构建一个优先队列Q,每个顶点v以(v,d(s,v))为项加入Q。</li>
<li>循环直到Q为空:<br />
   - 出队Q中key最小的顶点u<br />
   - 对每个出边(u,v):<br />
      - 如果d(s,v) &gt; d(s,u) + w(u,v):<br />
         - 进行松弛操作         -  降低Q中v的key值到新的d(s,v)</li>
<li>时间复杂度O(E+VlogV),使用二叉堆可以达到O(E+VlogV)</li>
</ol>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html">演示</a> 1. 对每个边(u,v),假设权重w(u,v)≥0,维护一个集合S,包含已确定最短路径权重的顶点。 2. 重复地从V-S中选择一个离源点最近的顶点u,将u加入S,松弛u的所有出边,即比较点u连通的其他节点，从点u出发的路径是否比距离表内的短 3. 伪代码: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Dijkstra (G, W, s) //uses priority queue Q</span><br><span class="line"> Initialize (G, s)</span><br><span class="line"> S ← φ</span><br><span class="line"> Q ← V [G] //Insert into Q</span><br><span class="line"> while Q != φ</span><br><span class="line">  do u ← EXTRACT-MIN(Q) //deletes u from Q</span><br><span class="line">  S = S ∪ &#123;u&#125;</span><br><span class="line">  for each vertex v ∈ Adj[u]</span><br><span class="line">   do RELAX (u, v, w) ← this is an implicit DECREASE KEY operation</span><br><span class="line"></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RELAX(u, v, w)</span><br><span class="line"> if d[v] &gt; d[u] + w(u, v)</span><br><span class="line">  then d[v] ← d[u] + w(u, v)</span><br><span class="line">  Π[v] ← u</span><br><span class="line">放松是安全的</span><br><span class="line"> 引理：松弛算法对于所有的情况都保持 d[v] ≥ δ(s, v) 的不变量</span><br><span class="line"> v ∈ V 。</span><br><span class="line"> 证明：通过步数归纳。</span><br><span class="line"> 考虑 RELAX(u, v, w)。  通过归纳法 d[u] ≥ δ(s, u)。  通过三角形 -</span><br><span class="line"> 等式，δ(s, v) ≤ δ(s, u) + δ(u, v)。  这意味着 δ(s, v) ≤ d[u] + w(u, v)，因为</span><br><span class="line"> d[u] ≥ δ(s, u) 且 w(u, v) ≥ δ(u, v)。  因此设置 d[v] = d[u] + w(u, v) 是安全的。</span><br><span class="line"></span><br></pre></td></tr></table></figure> 4. 通过重复选择最近顶点,逐步确定最短路径,时间复杂度为O(|E|+|V|log|V|)。 <img src="/assets/mit6.006总和笔记/image-20231024112814756.png" /></p>
<h4 id="证明">证明</h4>
<p>归纳法证明当顶点v从Q中取出时,d(s,v) = δ(s,v)成立: 基础:s第一个取出,d(s,s)=0 = δ(s,s)成立 - 归纳假设:对前k-1个顶点成立 - 考虑第k个顶点v0:    - 取v0到s的最短路径π,w(π)=δ(s,v0)   - 设(x,y)是π中第一个y不在前k-1个顶点的边    - 当x取出时,d(s,x)=δ(s,x)(归纳假设)    - 所以取出x时松弛(x,y),d(s,y) ≤ δ(s,x) + w(x,y) = δ(s,y)   - 由于松弛操作的安全性,d(s,v0) ≤ δ(s,v0)    - 又因为v0是Q中key最小的,d(s,v0) ≥ δ(s,v0)    - 所以d(s,v0) = δ(s,v0)</p>
<h4 id="时间复杂度">时间复杂度</h4>
<div class="line-block">操作 | 时间复杂度 | 在Dijkstra中的出现次数|</div>
<p>|-|-|-| <br />
|Q.build(X) (n = |X|)| Bn | 1 |<br />
|Q.delete min()| Mn | |V| |<br />
|Q.decrease key(id, k)| Dn | |E| | 总计O(B|V | + |V | · M|V | + |E| · D|V |) 对一个对顶点所有节点可达的图（修建过）： <img src="/assets/mit6.006总和笔记/image-20231025202308176.png" /> 对不同稀疏密度的图,使用不同的数据结构实现Dijkstra算法可以得到不同的时间复杂度: - 如果图是密集的,即 |E| = Θ(|V|<sup>2),使用数组实现优先队列Q,时间复杂度为O(|V|</sup>2) - 如果图是稀疏的,即 |E| = Θ(|V|),使用二叉堆实现Q,时间复杂度为 O(|V|log|V|) - Fibonacci堆在理论上对任意图都很好,但是实践中不常用 - 在理论分析中,通常假设Dijkstra算法的时间复杂度为O(|E| + |V|log|V|) 总结 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Dijkstra Complexity</span><br><span class="line"> Θ(v) inserts into priority queue</span><br><span class="line"> Θ(v) EXTRACT MIN operations</span><br><span class="line"> Θ(E) DECREASE KEY operations</span><br><span class="line">Array impl:</span><br><span class="line"> Θ(v) time for extra min</span><br><span class="line"> Θ(1) for decrease key</span><br><span class="line"> Total: Θ(V.V + E.1) = Θ(V 2 + E) = Θ(V 2)</span><br><span class="line">Binary min-heap:</span><br><span class="line"> Θ(lg V ) for extract min</span><br><span class="line"> Θ(lg V ) for decrease key</span><br><span class="line"> Total: Θ(V lg V + E lg V )</span><br><span class="line">Fibonacci heap (not covered in 6.006):</span><br><span class="line"> Θ(lg V ) for extract min</span><br><span class="line"> Θ(1) for decrease key</span><br><span class="line"> amortized cost</span><br><span class="line"> Total: Θ(V lg V + E)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="优化双向搜索">优化——双向搜索</h4>
<p>如果只需要s到t的最短路径，则只需要进行到t出队时结束算法 1. 双向搜索可以加速搜索,但不改变最坏时间复杂度,实际上可以减少访问的节点数。 2. 双向搜索同时进行:     - 从s节点进行正向搜索    - 从t节点进行反向搜索(沿边反向移动) 3. 正向搜索距离标记为df(u),反向为db(u) 4. 当一个节点w同时被两边搜索删除出队列时,搜索终止。 5. 终止后,找到df(x)+db(x)最小的节点x,x不一定是终止节点w。 6. 使用正向predecessor树Πf找到s到x的最短路径,使用反向树Πb找到t到x的最短路径。 7. 节点x一定已经被某一边搜索删除出队列。 <img src="/assets/mit6.006总和笔记/image-20231024193957638.png" /></p>
<h4 id="a算法">A*算法</h4>
<ol type="1">
<li>A*通过势函数修改边权重指引搜索方向:w'(u,v) = w(u,v) - λ(u) + λ(v)</li>
<li>选择势函数使修改后的权重保持最短路径不变,且权重非负,以适用于Dijkstra算法。</li>
<li>设定目标势值为0,源点势值足够大,可以引导搜索方向。</li>
<li>使用landmark技巧:预计算顶点到一些landmark节点的最短距离δ(u,l)。定义势函数λ(u)=δ(u,l)-δ(t,l),可以证明是可行的。</li>
<li>对每个landmark l计算势函数λ,取最大值作为最终势函数,仍可行。</li>
<li>A*相比普通搜索可以显著减少搜索范围,提高效率。但最坏情况时间复杂度未改变。</li>
</ol>
<p>Modify edge weights with potential function over vertices <span class="math display">\[
\overline{w}(u, v) = w(u, v) - λ(u) + λ(v)
\]</span></p>
<p>So shortest paths are maintained in modified graph with w(overline) weights <span class="math display">\[
\overline{w}(p) = w(p) - λ_t(u) + λ_t(t)
\]</span> Small set of landmarks LCV . For all u ∈ V, l ∈ L, pre-compute δ(u, l). Potential <span class="math display">\[
λ_t^{(l)}(u) = δ(u, l) − δ(t, l)
\]</span> <img src="/assets/mit6.006总和笔记/image-20231024193915317.png" /></p>
<h3 id="贝尔曼福特">贝尔曼福特</h3>
<h4 id="负循环检测">负循环检测</h4>
<ol type="1">
<li>定义k边距离δk(s,v):从s到v的路径中最多包含k条边的最小路径权重。</li>
<li>计算出δ|V|-1(s,v)和δ|V|(s,v),如果δ|V|(s,v)&lt;δ|V|-1(s,v),则v是一个负环见证人(witness)。</li>
<li>任意有向图中，对每个v∈V，计算δ(s,v)和δ|V|-1(s,v):<br />
   - 如果δ(s,v)&lt;δ|V|-1(s,v),则δ|V |(s, v) =- ∞，把v视为负循环见证人    - 如果δ(s,v)!=−∞,则δ(s,v)=δ|V|-1(s,v)(简单最短路径原理)    - 如果δ(s,v)=−∞,v可以从某个见证人出发而到达</li>
<li>证明思路:<br />
</li>
</ol>
<ul>
<li>假设某个负环C可达且不包含见证人,则对C中任一顶点v有:<br />
δ|V|(s,v) ≤ δ|V|-1(s,v的前驱)+w(v的前驱,v) &lt; δ|V|-1(s,v)<br />
</li>
<li>矛盾,所以C中必须存在见证人。</li>
<li><img src="/assets/mit6.006总和笔记/image-20231025082230441.png" /></li>
</ul>
<h4 id="定义">定义</h4>
<p><img src="/assets/mit6.006总和笔记/image-20231025092945965.png" /> 正确性： s到vk(k表示层数)的最短路径是每层可能的路径的最短者，贝尔曼福特算法穷举每一种可能，所以最后能得出最短的|V|-1层路径，从|V|-1到|V|则取决于图有没有负循环，如果有负循环，则s到见证人可达的结点路径为负无穷长 运行时间 1. 构建多层图G'需O(|V|(|V|+|E|)) 2. 在G'上运行DAG最短路径算法需O(|V|(|V|+|E|))，即G'大小的线性时间 3. 处理每个负环见证人需O(1),找到一个见证人的所有可达结点是O(|E|)见证人最多V个，找到所有见证人的可达性需O(|V||E|) 4. 如果把G修整成s开始的s可达子图，时间复杂度为O(|V||E|)</p>
<p>扩展思考: <img src="/assets/mit6.006总和笔记/image-20231025093817635.png" /></p>
<p><img src="/assets/mit6.006总和笔记/image-20231025080815803.png" /> • |V | + 1 levels: vertex vk in level k represents reaching vertex v from s using ≤ k edges • If edges only increase in level, resulting graph is a DAG • Construct new DAG G0 = (V 0, E0) from G = (V, E): – G' has |V |(|V | + 1) vertices v_k for all v ∈ V and k ∈ {0, . . . , |V |} – G' has |V |(|V | + |E|) edges: ∗ |V | edges (vk−1, vk) for k ∈ {1, . . . , |V |} of weight zero for each v ∈ V ∗ |V | edges (uk−1, vk) for k ∈ {1, . . . , |V |} of weight w(u, v) for each (u, v) ∈ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Bellman-Ford(G,W,s)</span><br><span class="line"> Initialize ()</span><br><span class="line"> for i = 1 to |V | − 1</span><br><span class="line">  for each edge (u, v) ∈ E:</span><br><span class="line">   Relax(u, v)</span><br><span class="line"> for each edge (u, v) ∈ E</span><br><span class="line">  do if d[v] &gt; d[u] + w(u, v)</span><br><span class="line">   then report a negative-weight cycle exists</span><br><span class="line">//At the end, d[v] = δ(s, v), if no negative-weight cycles</span><br><span class="line"></span><br></pre></td></tr></table></figure> 1. 初始化,进行|V|-1轮松弛操作,每轮对每个边(u,v)做relax操作，非负的图最多需要|V|-I次操作就可以松弛到任意点出发的任意路径都是最短路径 2. 如果第|V|轮还可以relax任意边,说明存在负权环。 3. 如果图中无负权环,Bellman-Ford执行结束后d[v]=δ(s,v)。 4. 推论:如果d[v]在|V|-1轮未收敛,说明存在从s可达的负权环。 5. Bellman-Ford时间复杂度为O(|V||E|),适合稠密图。</p>
<h4 id="最长简单路径和最短简单路径">最长简单路径和最短简单路径</h4>
<p>在具有非负边权重的图中找到最长的简单路径是一个 NP- hard问题，不存在已知的多项式时间算法。 假设一个 只需否定每个边权重并运行 Bellman-Ford 来计算最短 路径。 贝尔曼-福特不一定会计算原始路径中的最长路径 图，因为可能存在可从源到达的负权重循环，并且 算法将中止。 类似地，如果我们有一个具有负循环的图，并且我们希望找到最长的 从源 s 到顶点 v 的简单路径，我们不能使用 Bellman-Ford。 最短的 简单路径问题也是NP- hard问题</p>
<h2 id="johnsons-algorithm">Johnson’s Algorithm</h2>
<h3 id="all-pairs-shortest-paths-apsp">All-Pairs Shortest Paths (APSP)</h3>
<ul>
<li>输入:有向带权图G=(V,E),权值函数w:E→Z</li>
<li>输出:对所有u,v∈V,求出δ(u,v),如果有负权回路则报错</li>
<li>应用:理解整个网络,如交通、电路布线、供应链等</li>
<li>直接运行|V|次单源算法时间复杂度:     - DAG松弛: |V|·O(|V|+|E|),无环<br />
  - BFS: |V|·O(|V|+|E|),非负权值<br />
  - Dijkstra: |V|·O(|V|log|V|+|E|),非负权值<br />
  - Bellman-Ford: |V|·O(|V||E|),一般图</li>
</ul>
<p>思路：重构权值函数,使G变为G',其中G'没有负权边,且G的最短路径在G'上也是最短路径。如果成功,就可以在G'上运行Dijkstra 实现： 对每个顶点v:<br />
- 从v出发的边权加上h<br />
- 进入v的边权减去h<br />
- 这样可以保证最短路径不变<br />
- 证明:<br />
  - 任意从v开始的路径权值改变了h<br />
  - 任意到v结束的路径权值改变了-h<br />
  - 通过v的路径权值局部不变</p>
<p><img src="/assets/mit6.006总和笔记/image-20231025213904004.png" /></p>
<h3 id="算法">算法</h3>
<ul>
<li>构造含新顶点x的图Gx,x到每个顶点v有权值为0的边</li>
<li>对Gx运行Bellman-Ford算法计算δx(x,v)</li>
<li>如果δx(x,v)为无穷大,说明G中有负权回路,报错退出</li>
<li>否则,用δx重新调整每个边的权值构造G'</li>
<li>对G'运行Dijkstra算法|V|次计算每个顶点的最短路径 </li>
<li>从G'的最短路径恢复G的最短路径</li>
</ul>
<h3 id="时间复杂度-1">时间复杂度</h3>
<ul>
<li>构造Gx需O(|V|+|E|)</li>
<li>Bellman-Ford需O(|V||E|)</li>
<li>构造G'需O(|V|+|E|)</li>
<li>|V|次Dijkstra需O(|V|(|V|log|V| + |E|))</li>
<li>用G'恢复G的距离需O(|V|^2)</li>
<li>总计O({|V|^2}log|V| + |V||E|)</li>
</ul>
<h1 id="概率">概率</h1>
<p>雇佣问题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">best = 0</span><br><span class="line">hired = null</span><br><span class="line">for i = 1 to n</span><br><span class="line">if candidates[i] &gt; best</span><br><span class="line"> best = candidates[i]</span><br><span class="line"> hired = i</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="指示器随机变量">指示器随机变量</h2>
<p>指示器随机变量可以用于对随机输入的算法分析 <span class="math display">\[I(A) = \begin{cases}  
           1 &amp; \text{event A occurs} \\  
           0 &amp; \text{otherwise}  
\end{cases}\]</span> 把期望转化成指示器期望的相加</p>
<h2 id="随机算法">随机算法</h2>
<p>在此基础上可以在算法中进行随机数处理，排除输入的影响 比如在雇佣问题中，对输入的候选者数组进行随机排序 随机排序： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">n = A.length</span><br><span class="line">let P[1-n] be a new array</span><br><span class="line">for i=1 to n</span><br><span class="line"> P[i] = RANDOM(1,n^3)</span><br><span class="line">sort A,use P</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="递归和动态规划">递归和动态规划</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># recursive solution (top down)</span><br><span class="line">def fib(n):</span><br><span class="line"> memo = &#123;&#125;</span><br><span class="line"> def F(i):</span><br><span class="line">  if i &lt; 2: return i # base cases</span><br><span class="line">  if i not in memo: # check memo</span><br><span class="line">   memo[i] = F(i - 1) + F(i - 2) # relation</span><br><span class="line">  return memo[i]</span><br><span class="line"> return F(n) # original</span><br><span class="line"># iterative solution (bottom up)</span><br><span class="line">def fib(n):</span><br><span class="line"> F = &#123;&#125;</span><br><span class="line"> F[0], F[1] = 0, 1 # base cases</span><br><span class="line"> for i in range(2, n + 1): # topological order</span><br><span class="line">  F[i] = F[i - 1] + F[i - 2] # relation</span><br><span class="line"> return F[n] # original</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231027103835269.png" /> <img src="/assets/mit6.006总和笔记/image-20231027112657842.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># recursive solution (top down)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bowl</span>(<span class="params">v</span>):</span><br><span class="line"> memo = &#123;&#125;</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">B</span>(<span class="params">i</span>):</span><br><span class="line">  <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(v): <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># base cases</span></span><br><span class="line">  <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> memo: <span class="comment"># check memo</span></span><br><span class="line">  memo[i] = <span class="built_in">max</span>(B(i+<span class="number">1</span>), <span class="comment"># relation: skip pin i</span></span><br><span class="line">   v[i] + B(i+<span class="number">1</span>), <span class="comment"># OR bowl pin i separately</span></span><br><span class="line">   v[i] * v[i+<span class="number">1</span>] + B(i+<span class="number">2</span>)) <span class="comment"># OR bowl pins i and i+1 together</span></span><br><span class="line">   <span class="keyword">return</span> memo[i]</span><br><span class="line">  <span class="keyword">return</span> B(<span class="number">0</span>) <span class="comment"># original</span></span><br><span class="line"><span class="comment"># iterative solution (bottom up)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bowl</span>(<span class="params">v</span>):</span><br><span class="line"> B = &#123;&#125;</span><br><span class="line"> B[<span class="built_in">len</span>(v)] = <span class="number">0</span> <span class="comment"># base cases</span></span><br><span class="line"> B[<span class="built_in">len</span>(v)+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(v))): <span class="comment"># topological order</span></span><br><span class="line">  B[i] = <span class="built_in">max</span>(B[i+<span class="number">1</span>], <span class="comment"># relation: skip pin i</span></span><br><span class="line">   v[i] + B(i+<span class="number">1</span>), <span class="comment"># OR bowl pin i separately</span></span><br><span class="line">   v[i] * v[i+<span class="number">1</span>] + B(i+<span class="number">2</span>)) <span class="comment"># OR bowl pins i and i+1 together</span></span><br><span class="line"> <span class="keyword">return</span> B[<span class="number">0</span>] <span class="comment"># original</span></span><br></pre></td></tr></table></figure>
<p>如何关联子问题解决方案 • 我们遵循的一般方法来定义子问题解决方案的关系： - 确定一个有关子问题解决方案的问题，如果知道答案，则该问题将减少到“更小的”子问题 - 在打保龄球的情况下，问题是“我们如何打第一对球瓶？” - 然后通过尝试所有可能的答案并采取最好的答案来本地暴力解决问题 - 在保龄球的情况下，我们取最大值，因为问题要求最大化 - 或者，我们可以考虑正确猜测问题的答案，然后 直接递归； 但随后我们实际上检查所有可能的猜测，并返回“最佳” • 效率的关键是问题有少量（多项式）可能的可能性。答案，所以暴力破解并不太昂贵 • 通常（但并非总是）计算关系的非递归工作等于数字 我们正在尝试的答案</p>
<h2 id="动态规划">动态规划</h2>
<h3 id="lcs">LCS</h3>
<p>• x(i, j) = A[i :] 和 B[j :]的最大公共子序列 • For 0 &lt;= i &lt;= |A| and 0 &lt;=0 j &lt;= |B| 最长公共子序列问题(LCS): 1. 定义了子问题x(i,j),表示 A[i:]和B[j:]的最长公共子序列长度。 2. 列出了递归关系 - 如果A[i]==B[j],那么x(i,j)等于x(i+1,j+1)+1,否则等于x(i+1,j)和x(i,j+1)的最大值。 3. 指出了拓扑顺序,子问题依赖更大的i或j。 4. 给出了 base cases —— 当一个字符串为空时,LCS长度为0。x(i, |B|) = x(|A|, j) = 0 5. 原问题可以通过x(0,0)求解,同时需要parent pointers构建最长子序列。 6. 时间复杂度分析也正确,子问题数为O(|A|*|B|),每件工作为O(1),所以总时间为O(|A|*|B|)。 <span class="math display">\[
x(i,j) =
\begin{cases}
   x(i+1,j+1)+1, &amp; \text{if }A[i]=B[j] \\
   max(x(i + 1, j), x(i, j + 1)) , &amp; otherwise
\end{cases}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">A, B</span>):</span><br><span class="line"> a, b = <span class="built_in">len</span>(A), <span class="built_in">len</span>(B)</span><br><span class="line"> x = [[<span class="number">0</span>] * (b + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a + <span class="number">1</span>)]<span class="comment">#x 的最终形状是一个 (a + 1) x (b + 1) 的二维列表,每个元素初始化为 0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(b)):</span><br><span class="line">   <span class="keyword">if</span> A[i] == B[j]:</span><br><span class="line">    x[i][j] = x[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">    x[i][j] = <span class="built_in">max</span>(x[i + <span class="number">1</span>][j], x[i][j + <span class="number">1</span>])</span><br><span class="line"> <span class="keyword">return</span> x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment">#如果A[i] == B[j],那么最长公共子序列可以在A[i+1:]和B[j+1:]的基础上再加上A[i]这个字符,所以x[i][j] = x[i+1][j+1] + 1。</span></span><br><span class="line"><span class="comment">#如果A[i] != B[j],那么A[i]和B[j]不可能同时在最长公共子序列中,需要舍弃一个字符。所以x[i][j]取x[i+1][j]和x[i][j+1]中的最大值。</span></span><br><span class="line"><span class="comment">#依次遍历,直到i或j变为-1,即遍历完两个字符串。</span></span><br></pre></td></tr></table></figure>
<h3 id="lis">LIS</h3>
<p><code>Longest Increasing Subsequence (LIS)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lis</span>(<span class="params">A</span>):</span><br><span class="line"> a = <span class="built_in">len</span>(A)</span><br><span class="line"> x = [<span class="number">1</span>] * a</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, a):</span><br><span class="line">   <span class="keyword">if</span> A[j] &gt; A[i]:</span><br><span class="line">    x[i] = <span class="built_in">max</span>(x[i], <span class="number">1</span> + x[j])</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">max</span>(x)</span><br></pre></td></tr></table></figure>
<p>x(i)是A[i:]的最长递增子数组 O(|A|^2) running time - 外层循环i是在寻找以每个元素结尾的LIS长度。 - 内层循环j是在寻找可以接在A[i]后面的最大LIS长度。 - x数组缓存了每个位置的LIS长度,避免重复计算。 - 通过从后向前遍历,可以保证每个x[i]都是最新的最大LIS长度。</p>
<h3 id="alternating-coin-game">Alternating Coin Game</h3>
<ul>
<li>两名玩家（“我”和“你”）轮流</li>
<li>轮流取出剩余硬币中的第一个或最后一个硬币</li>
<li>我的目标是最大化我所拿走的硬币的总价值，这是我首先要做的 x(i, j) =我可以从 vi, . . . , vj中拿走的最大硬币总价值 <img src="/assets/mit6.006总和笔记/image-20231027200057225.png" /> 子问题: O(n^2) • 每个子问题相加: O(n) to compute sums • O(n^3) running time</li>
</ul>
<h4 id="优化-1">优化</h4>
<ol type="1">
<li>扩展定义子问题x(i,j,p),添加了一个表示下一步该谁走的状态p。</li>
<li>列出了四个递归关系式,区分我方走与对方走的不同情况。</li>
<li>拓扑顺序及base case与第一种解法相同。</li>
<li>计算原问题时,状态为我方走。</li>
</ol>
<p>x(i, j, p) = maximum total value I can take when player p ∈ {me, you} starts from coins of values vi, . . . , vj</p>
<p>Player p must choose either coin i or coin j • If p = me, then I get the value; otherwise, I get nothing • Then it’s the other player’s turn • x(i, j, me) = max{vi + x(i + 1, j, you), vj + x(i, j + 1, you)} • x(i, j, you) = min{x(i + 1, j, me), x(i, j + 1, me)} <img src="/assets/mit6.006总和笔记/image-20231027200227456.png" /> <strong>时间</strong> • subproblems: ⇥(n2) • work per subproblem: ⇥(1) • ⇥(n2) running time 扩展子问题可以提供递归所需信息,但代价是子问题数目增加,计算复杂度上升。需要权衡取舍。</p>
<h3 id="rod-cutting">Rod Cutting</h3>
<p>切一根棍子，切割长度产生的收益如表</p>
<table>
<thead>
<tr class="header">
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>0</td>
<td>1</td>
<td>10</td>
<td>13</td>
<td>18</td>
<td>20</td>
<td>31</td>
<td>32</td>
</tr>
</tbody>
</table>
<p>x(l): maximum value obtainable by cutting rod of length x(l) = max{v(p) + x(l-p) | p 2 {1, . . . ,l }} time: - subproblems: L + 1 - work per subproblem: O(l) = O(L) - O(L^2) running time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># recursive</span></span><br><span class="line">x = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">l, v</span>):</span><br><span class="line"> <span class="keyword">if</span> l &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># base case</span></span><br><span class="line"> <span class="keyword">if</span> l <span class="keyword">not</span> <span class="keyword">in</span> x: <span class="comment"># check memo</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + cut_rod(l - piece, v) <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> (l <span class="keyword">not</span> <span class="keyword">in</span> x) <span class="keyword">or</span> (x[l] &lt; x_): <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line"> <span class="keyword">return</span> x[l]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterative</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">L, v</span>):</span><br><span class="line"> x = [<span class="number">0</span>] * (L + <span class="number">1</span>) <span class="comment"># base case</span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>): <span class="comment"># topological order</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + x[l - piece] <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> x[l] &lt; x_: <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line"> <span class="keyword">return</span> x[L]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterative with parent pointers</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod_pieces</span>(<span class="params">L, v</span>):</span><br><span class="line"> x = [<span class="number">0</span>] * (L + <span class="number">1</span>) <span class="comment"># base case</span></span><br><span class="line"> parent = [<span class="literal">None</span>] * (L + <span class="number">1</span>) <span class="comment"># parent pointers</span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>): <span class="comment"># topological order</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + x[l - piece] <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> x[l] &lt; x_: <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line">    parent[l] = l - piece <span class="comment"># update parent</span></span><br><span class="line"> l, pieces = L, []</span><br><span class="line"> <span class="keyword">while</span> parent[l] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># walk back through parents</span></span><br><span class="line">  piece = l - parent[l]</span><br><span class="line">  pieces.append(piece)</span><br><span class="line">  l = parent[l]</span><br><span class="line"> <span class="keyword">return</span> piece</span><br></pre></td></tr></table></figure>
<h3 id="subset-sum">Subset Sum</h3>
<p><a href="https://www.jianshu.com/p/0322014dc357?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes">相关博客</a> A = {a0, a1, . . . , an} 是否存在A的子集A'，A'的元素总和为T x(i, j): True if can make sum j using items 1 to i, False otherwis <span class="math display">\[
x(i,j) =
\begin{cases}
   x(i - 1, j - A[i]), &amp; \text{if j &gt;= A[i] } \\
   x(i - 1, j), &amp; always
\end{cases}
\]</span> - x(i, 0) = True for i ∈ {0, . . . , n} (trivial to make zero sum!) - x(0, j) = False for j ∈ {1, . . . , T} (impossible to make positive sum from empty set - for i ∈ {0, . . . , n}, j ∈ {0, . . . , T}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp_subset</span>(<span class="params">arr,S</span>):</span><br><span class="line">    </span><br><span class="line">    subset = np.zeros((<span class="built_in">len</span>(arr),S+<span class="number">1</span>),dtype=<span class="built_in">bool</span>) <span class="comment">#构造二维数组</span></span><br><span class="line">    subset[:,<span class="number">0</span>] = <span class="literal">True</span> <span class="comment"># 第一列 设为True</span></span><br><span class="line">    subset[<span class="number">0</span>,: ] = <span class="literal">False</span> <span class="comment">#第一列 设为 False</span></span><br><span class="line">    subset[<span class="number">0</span>,arr[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, S+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; s:</span><br><span class="line">                subset[i , s] = subset[i-<span class="number">1</span> , s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = subset[i-<span class="number">1</span> , s ]</span><br><span class="line">                B = subset[i-<span class="number">1</span> , s - arr[i]]</span><br><span class="line">                subset[i,s] = A <span class="keyword">or</span> B</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    row ,cell = subset.shape</span><br><span class="line">    <span class="keyword">return</span> subset[row-<span class="number">1</span>,cell-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">arr  = [<span class="number">1</span>,<span class="number">2</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]            </span><br><span class="line">dp_subset(arr,<span class="number">7</span>) </span><br><span class="line">out:<span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231028110550677.png" /></p>
<p>subproblems: O(nT ), O(1) work per subproblem, O(nT ) time</p>
<h1 id="其他">其他</h1>
<h2 id="多项式时间的判定">多项式时间的判定</h2>
<p>只有在算法时间复杂度仅与问题规模有多项式关系时，才可称为多项式时间复杂度算法。 存在如基数排序之类时间复杂度依赖于输入数据的算法，称为伪多项式时间复杂度，此时算法的时间复杂度是输入数据大小的多项式时间表达，但却是输入数据长度（输入规模）的指数时间表达</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">冒泡排序：给定 n 个64位的数字，进行 n-1 次扫描交换，将数字从小到大排序。</span><br><span class="line">素数测试：给定数字 n，通过从 2 到根号 n 的整数遍历，判断 n 是否为素数。</span><br><span class="line">字面上看，两者复杂度都是 O(n^k) ( k 为整数) 。但区别在于，前者的 n 是数字个数的多少，后者的 n 是数字的大小。</span><br><span class="line">因此，前者输入总规模 s1 增长与数字大小无关，s1 = 64n；后者增长规模与数字大小紧密相关，输入总规模为 s2 = logn 。</span><br><span class="line">所以可知冒泡排序中复杂度 O(n^2) = O(s1^2/64^2) 为多项式算法，后者素数测试O(n) = O(2^(s2)) 为伪多项式算法</span><br></pre></td></tr></table></figure>
<h2 id="复杂度">复杂度</h2>
<ul>
<li>决策问题:将输入归类为YES或NO的问题。</li>
<li>算法/程序:能够在一定时间内解决问题的常量长度代码。</li>
<li>如果问题有算法可以在有限时间内解决,则该问题是可判定的。</li>
<li>程序是有限的,问题是无限的,因此大多数决策问题是不可判定的。</li>
<li>即使可判定,也以不同的时间复杂度分类:</li>
</ul>
<ol type="1">
<li>R类:有限时间可判定</li>
<li>EXP类:指数时间可判定</li>
<li>P类:多项式时间可判定(我们关注的)</li>
</ol>
<ul>
<li>这些类满足 P⊆EXP⊆R 的包含关系。 NP与P问题参考<a href="https://thinklive1.github.io/2023/10/06/61b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/">61b笔记</a></li>
</ul>
<p>mit的后续课程 <img src="/assets/mit6.006总和笔记/image-20231027201108930.png" /> <img src="/assets/mit6.006总和笔记/image-20231027201117355.png" /></p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据结构与算法</tag>
        <tag>麻省理工</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利ds100和cs231n的numpy笔记</title>
    <url>/2023/10/09/numpy/</url>
    <content><![CDATA[<p><a href="http://www.numpy.org/">Numpy</a> 是 Python 中科学计算的核心库。 它提供了高性能的多维数组对象以及使用这些对象的工具 数组。</p>
<h2 id="数组">数组</h2>
<p>numpy 数组是一个值网格，所有值都具有相同的类型，并由非负整数组成的元组索引。 它的维度就是数组的秩 ；它的shape就是每个维度的大小组成的元组 <span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array</span><br><span class="line">print(b.shape)                     # Prints &quot;(2, 3)&quot;</span><br><span class="line">print(b[0, 0], b[0, 1], b[1, 0])   # Prints &quot;1 2 4&quot;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://numpy.org/doc/stable/user/basics.creation.html#arrays-creation">官方数组创建教程</a> <a href="http://ds100.org/fa17/assets/notebooks/numpy/Numpy_Review.html">ds100的numpy教程</a> <a href="https://cs231n.github.io/python-numpy-tutorial/#numpy">cs231n的python numpy教程</a></p>
<h3 id="创建数组的方法">创建数组的方法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;np.array([[1.,2.], [3.,4.]])</span><br><span class="line"></span><br><span class="line">array([[ 1.,  2.],</span><br><span class="line">       [ 3.,  4.]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([x for x in range(5)])</span><br><span class="line"></span><br><span class="line">array([0, 1, 2, 3, 4])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([[&quot;A&quot;, &quot;matrix&quot;], [&quot;of&quot;, &quot;words.&quot;]])</span><br><span class="line"></span><br><span class="line">array([[&#x27;A&#x27;, &#x27;matrix&#x27;],</span><br><span class="line">       [&#x27;of&#x27;, &#x27;words.&#x27;]], </span><br><span class="line">      dtype=&#x27;&lt;U6&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.ones([3,2])</span><br><span class="line"></span><br><span class="line">array([[ 1.,  1.],</span><br><span class="line">       [ 1.,  1.],</span><br><span class="line">       [ 1.,  1.]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.random.randn(3,2)</span><br><span class="line"></span><br><span class="line">array([[ 0.3601399 ,  1.31206686],</span><br><span class="line">       [-0.95112397,  0.62475726],</span><br><span class="line">       [-1.24179768,  1.63392069]])</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;c = np.full((2,2), 7)  # Create a constant array</span><br><span class="line">print(c)               # Prints &quot;[[ 7.  7.]</span><br><span class="line">                       #          [ 7.  7.]]&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;d = np.eye(2)         # Create a 2x2 identity matrix</span><br><span class="line">print(d)              # Prints &quot;[[ 1.  0.]</span><br><span class="line">                      #          [ 0.  1.]]&quot;</span><br></pre></td></tr></table></figure>
<h3 id="数组属性">数组属性</h3>
<ul>
<li>dtype</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;np.arange(1,5).dtype</span><br><span class="line"></span><br><span class="line">dtype(&#x27;int64&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([&quot;Hello&quot;, &quot;Worlddddd!&quot;]).dtype</span><br><span class="line"></span><br><span class="line">dtype(&#x27;&lt;U10&#x27;)</span><br><span class="line">/*</span><br><span class="line">What does `&lt;U6` mean?</span><br><span class="line">- `&lt;` Little Endian</span><br><span class="line">- `U` Unicode</span><br><span class="line">- `6` length of longest string</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.array([1,2,3]).astype(float)</span><br><span class="line"></span><br><span class="line">array([ 1.,  2.,  3.])</span><br></pre></td></tr></table></figure>
<p>数组的类型与其包含的数据类型相对应,可以用.astype改变类型</p>
<h3 id="数组编辑">数组编辑</h3>
<h4 id="重组和展开">重组和展开</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;np.arange(1,13).reshape(4,3)</span><br><span class="line"></span><br><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [ 4,  5,  6],</span><br><span class="line">       [ 7,  8,  9],</span><br><span class="line">       [10, 11, 12]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;A.flatten()</span><br><span class="line">array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])</span><br></pre></td></tr></table></figure>
<h4 id="切片索引和整数索引">切片索引和整数索引</h4>
<p>切片时，第一个参数是行，第二个是列，切片形成的是对原来数组的引用，修改子数组也会影响原数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Use slicing to pull out the subarray consisting of the first 2 rows</span><br><span class="line"># and columns 1 and 2; b is the following array of shape (2, 2):</span><br><span class="line"># [[2 3]</span><br><span class="line">#  [6 7]]</span><br><span class="line">b = a[:2, 1:3]</span><br><span class="line"></span><br><span class="line"># A slice of an array is a view into the same data, so modifying it</span><br><span class="line"># will modify the original array.</span><br><span class="line">print(a[0, 1])   # Prints &quot;2&quot;</span><br><span class="line">b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]</span><br><span class="line">print(a[0, 1])   # Prints &quot;77&quot;</span><br></pre></td></tr></table></figure>
<p>可以混合整数索引和切片索引，这样做会产生一个比原始数组的秩更低的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Two ways of accessing the data in the middle row of the array.</span><br><span class="line"># Mixing integer indexing with slices yields an array of lower rank,</span><br><span class="line"># while using only slices yields an array of the same rank as the</span><br><span class="line"># original array:</span><br><span class="line">row_r1 = a[1, :]    # Rank 1 view of the second row of a</span><br><span class="line">row_r2 = a[1:2, :]  # Rank 2 view of the second row of a</span><br><span class="line">print(row_r1, row_r1.shape)  # Prints &quot;[5 6 7 8] (4,)&quot;</span><br><span class="line">print(row_r2, row_r2.shape)  # Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span><br><span class="line"></span><br><span class="line"># We can make the same distinction when accessing columns of an array:</span><br><span class="line">col_r1 = a[:, 1]</span><br><span class="line">col_r2 = a[:, 1:2]</span><br><span class="line">print(col_r1, col_r1.shape)  # Prints &quot;[ 2  6 10] (3,)&quot;</span><br><span class="line">print(col_r2, col_r2.shape)  # Prints &quot;[[ 2]</span><br><span class="line">                             #          [ 6]</span><br><span class="line">                             #          [10]] (3, 1)&quot;</span><br></pre></td></tr></table></figure>
<p>整数数组 索引允许你使用另一个数组的数据构造任意数组 大批。 这是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1,2], [3, 4], [5, 6]])</span><br><span class="line"></span><br><span class="line"># An example of integer array indexing.</span><br><span class="line"># The returned array will have shape (3,) and</span><br><span class="line">print(a[[0, 1, 2], [0, 1, 0]])  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># The above example of integer array indexing is equivalent to this:</span><br><span class="line">print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># When using integer array indexing, you can reuse the same</span><br><span class="line"># element from the source array:</span><br><span class="line">print(a[[0, 0], [1, 1]])  # Prints &quot;[2 2]&quot;</span><br><span class="line"></span><br><span class="line"># Equivalent to the previous integer array indexing example</span><br><span class="line">print(np.array([a[0, 1], a[0, 1]]))  # Prints &quot;[2 2]&quot;</span><br></pre></td></tr></table></figure>
<p>可以用整数数组索引修改数组部分值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create a new array from which we will select elements</span><br><span class="line">a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[ 1,  2,  3],</span><br><span class="line">          #                [ 4,  5,  6],</span><br><span class="line">          #                [ 7,  8,  9],</span><br><span class="line">          #                [10, 11, 12]])&quot;</span><br><span class="line"></span><br><span class="line"># Create an array of indices</span><br><span class="line">b = np.array([0, 2, 0, 1])</span><br><span class="line"></span><br><span class="line"># Select one element from each row of a using the indices in b</span><br><span class="line">print(a[np.arange(4), b])  # Prints &quot;[ 1  6  7 11]&quot;</span><br><span class="line"></span><br><span class="line"># Mutate one element from each row of a using the indices in b</span><br><span class="line">a[np.arange(4), b] += 10</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[11,  2,  3],</span><br><span class="line">          #                [ 4,  5, 16],</span><br><span class="line">          #                [17,  8,  9],</span><br><span class="line">          #                [10, 21, 12]])</span><br></pre></td></tr></table></figure>
<h4 id="数组的数学运算">数组的数学运算</h4>
<p>numpy 提供的数学函数的完整列表 <a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">文档</a> Numpy 提供了更多用于操作数组的函数； 完整的列表 <a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">文档</a></p>
<p>Numpy 提供了许多有用的函数来执行计算 数组； 最有用的之一是 <code>sum</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]])</span><br><span class="line"></span><br><span class="line">print(np.sum(x))  # Compute sum of all elements; prints &quot;10&quot;</span><br><span class="line">print(np.sum(x, axis=0))  # Compute sum of each column; prints &quot;[4 6]&quot;</span><br><span class="line">print(np.sum(x, axis=1))  # Compute sum of each row; prints &quot;[3 7]&quot;</span><br></pre></td></tr></table></figure>
<p>转置矩阵， 只需使用 <code>T</code>数组对象的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2], [3,4]])</span><br><span class="line">print(x)    # Prints &quot;[[1 2]</span><br><span class="line">            #          [3 4]]&quot;</span><br><span class="line">print(x.T)  # Prints &quot;[[1 3]</span><br><span class="line">            #          [2 4]]&quot;</span><br><span class="line"></span><br><span class="line"># Note that taking the transpose of a rank 1 array does nothing:</span><br><span class="line">v = np.array([1,2,3])</span><br><span class="line">print(v)    # Prints &quot;[1 2 3]&quot;</span><br><span class="line">print(v.T)  # Prints &quot;[1 2 3]&quot;</span><br></pre></td></tr></table></figure>
<h3 id="广播">广播</h3>
<p>我们有一个较小的数组和一个 较大的数组，并且我们想多次使用较小的数组来执行某些操作 在更大的阵列上。</p>
<p>例如，假设我们要向每个添加一个常数向量 矩阵的行。 我们可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = np.empty_like(x)   # Create an empty matrix with the same shape as x</span><br><span class="line"></span><br><span class="line"># Add the vector v to each row of the matrix x with an explicit loop</span><br><span class="line">for i in range(4):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"># Now y is the following</span><br><span class="line"># [[ 2  2  4]</span><br><span class="line">#  [ 5  5  7]</span><br><span class="line">#  [ 8  8 10]</span><br><span class="line">#  [11 11 13]]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<p>Numpy 广播允许我们执行此计算，而无需实际执行 创建多个副本 <code>v</code>。 考虑这个版本，使用广播：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = x + v  # Add v to each row of x using broadcasting</span><br><span class="line">print(y)  # Prints &quot;[[ 2  2  4]</span><br><span class="line">          #          [ 5  5  7]</span><br><span class="line">          #          [ 8  8 10]</span><br><span class="line">          #          [11 11 13]]&quot;</span><br></pre></td></tr></table></figure>
<p>线路 <code>y = x + v</code>尽管有效 <code>x</code>有形状 <code>(4, 3)</code>和 <code>v</code>有形状 <code>(3,)</code>由于广播； 这条线的工作原理就像 <code>v</code>实际上有形状 <code>(4, 3)</code>, 其中每一行都是一个副本 <code>v</code>，并且按元素求和。</p>
<p>一起广播两个数组遵循以下规则：</p>
<ol type="1">
<li>如果数组没有相同的秩，则在前面添加较低秩数组的形状 1s 直到两个形状具有相同的长度。</li>
<li>如果两个数组具有相同的维度，则称 <em>兼容</em> 它们在维度上 维度中的大小，或者如果其中一个数组在该维度中的大小为 1。</li>
<li>如果数组在所有维度上都兼容，则可以一起广播。</li>
<li>广播后，每个数组的行为就好像它的形状等于元素方向 两个输入数组的形状的最大值。</li>
<li>在一个数组的大小为 1 而另一个数组的大小大于 1 的任何维度中， 第一个数组的行为就好像它是沿着该维度复制的</li>
</ol>
<p>一些应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Compute outer product of vectors</span><br><span class="line">v = np.array([1,2,3])  # v has shape (3,)</span><br><span class="line">w = np.array([4,5])    # w has shape (2,)</span><br><span class="line"># To compute an outer product, we first reshape v to be a column</span><br><span class="line"># vector of shape (3, 1); we can then broadcast it against w to yield</span><br><span class="line"># an output of shape (3, 2), which is the outer product of v and w:</span><br><span class="line"># [[ 4  5]</span><br><span class="line">#  [ 8 10]</span><br><span class="line">#  [12 15]]</span><br><span class="line">print(np.reshape(v, (3, 1)) * w)</span><br><span class="line"></span><br><span class="line"># Add a vector to each row of a matrix</span><br><span class="line">x = np.array([[1,2,3], [4,5,6]])</span><br><span class="line"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span><br><span class="line"># giving the following matrix:</span><br><span class="line"># [[2 4 6]</span><br><span class="line">#  [5 7 9]]</span><br><span class="line">print(x + v)</span><br><span class="line"></span><br><span class="line"># Add a vector to each column of a matrix</span><br><span class="line"># x has shape (2, 3) and w has shape (2,).</span><br><span class="line"># If we transpose x then it has shape (3, 2) and can be broadcast</span><br><span class="line"># against w to yield a result of shape (3, 2); transposing this result</span><br><span class="line"># yields the final result of shape (2, 3) which is the matrix x with</span><br><span class="line"># the vector w added to each column. Gives the following matrix:</span><br><span class="line"># [[ 5  6  7]</span><br><span class="line">#  [ 9 10 11]]</span><br><span class="line">print((x.T + w).T)</span><br><span class="line"># Another solution is to reshape w to be a column vector of shape (2, 1);</span><br><span class="line"># we can then broadcast it directly against x to produce the same</span><br><span class="line"># output.</span><br><span class="line">print(x + np.reshape(w, (2, 1)))</span><br><span class="line"></span><br><span class="line"># Multiply a matrix by a constant:</span><br><span class="line"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span><br><span class="line"># these can be broadcast together to shape (2, 3), producing the</span><br><span class="line"># following array:</span><br><span class="line"># [[ 2  4  6]</span><br><span class="line">#  [ 8 10 12]]</span><br><span class="line">print(x * 2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>数据科学</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利Sysadmin decal的linux笔记</title>
    <url>/2023/10/12/sysadmin/</url>
    <content><![CDATA[<h1 id="shell脚本">shell脚本</h1>
<p>Shell 脚本通常以 shebang 行开头：#!path/to/interpreter。</p>
<p><code>#!</code>是一个人类可读的 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)#Magic_number">幻数表示</a> <code>0x23 0x21</code>它可以告诉 shell 将文件其余部分的执行传递给 指定翻译。 如果您的脚本作为可执行文件运行（例如 <code>./awesome_shell_script</code>) 加上 shebang 行，那么 shell 将调用 可执行文件（通常是解释器）位于 <code>path/to/interpreter</code>运行你的 脚本。 如果您的脚本作为参数传递给解释器，例如 <code>bash awesome_shell_script</code>，那么 shebang 没有效果并且 <code>bash</code>会处理 脚本的执行。 <span id="more"></span> <strong>为什么这很重要？</strong> shebang 可以被认为是一个有用的部分 执行脚本的关注 <em>如何</em> 元数据传递了用户 给程序的作者。 <code>awesome_shell_script</code>可能是一个 <code>bash</code>脚本，一个 <code>python</code>脚本，一个 <code>ruby</code>脚本等。这个想法是只有脚本的 对于调用的用户来说，行为而不是其实现细节应该重要。</p>
<p>您可能已经看到过一些变体 <code>#!/bin/sh</code>。 虽然最初参考的是 现代系统上的 Bourne shell <code>sh</code>已经提到了 <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html">Shell Command Language</a> ，这是一个具有多种实现的 POSIX 规范。 <code>sh</code>通常符号链接到这些符合 POSIX 标准的 shell 之一 实现 Shell 命令语言。 以 Debian 为例， <code>sh</code>是 符号链接到 shell <code>dash</code>。 重要的是要注意 <code>bash</code>不 **_** 遵守这个标准，虽然运行 <code>bash</code>作为 <code>bash --posix</code>做到了 更合规。</p>
<h3 id="管道"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#piping"></a>管道</h3>
<p>我们可以使用 <code>|</code>字符将多个命令链接在一行中。 例如： <code>command1 | command2</code> 将传递的输出 <code>command1</code>作为输入 <code>command2</code>。 我们可以根据需要多次重复此操作。</p>
<h3 id="循环使用-for"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#looping-with-for"></a>循环使用 <code>for</code></h3>
<p>Bash 可以使用 for 循环对多个对象重复操作。 语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for VARIABLE in LIST; do</span><br><span class="line"></span><br><span class="line">    CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>缩进不是必需的，但使代码更易于阅读。 这 <code>LIST</code>可以是包含多个文件的目录，也可以是包含多行 init 的文件、文件列表（ <code>file1 file2 file3</code>），甚至是一系列数字（ <code>&#123;start..end&#125;</code>).</p>
<h2 id="有用的命令"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#useful-commands"></a>有用的命令</h2>
<p>一些对于完成实验可能有用的命令。 当然，解决问题的方法有很多，并不需要使用这些命令。</p>
<h3 id="cat"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#cat"></a><code>cat</code></h3>
<p><code>cat</code> <a href="https://linux.die.net/man/1/cat">打印</a> 将文件 <a href="https://linuxhint.com/bash_stdin_stderr_stdout/">到标准输出</a> 。 对于打印一些内容以通过管道输入其他命令非常有用！</p>
<h3 id="cut"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#cut"></a><code>cut</code></h3>
<p><code>cut [options] [filename]</code>提取文件的某些部分（或管道输入） <a href="https://linux.die.net/man/1/cut">参数</a> 根据使用的 。 一些可能有用的：</p>
<p><code>-d</code>允许我们更改分隔符，或更改字符 <code>cut</code>寻找将字符串分成块。 如果省略该选项， <code>tab</code>用来。</p>
<p><code>-f</code>允许我们指定与要返回的字段对应的数字，例如 <code>cut -f1 -d" "</code>将返回句子中的第一个单词。 数字后跟一个 <code>-</code>也返回指定字段之后的所有字段，因此 <code>cut -f1- -d" "</code>将返回整个字符串。</p>
<p><code>--complement</code>告诉 <code>cut</code>返回除 <strong>之外的所有内容。</strong> 指定字段</p>
<h3 id="grep"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#grep"></a><code>grep</code></h3>
<p><code>grep [pattern] [filename]</code> <a href="https://linux.die.net/man/1/grep">过滤</a> 并返回文件（或管道输入）中包含指定模式的行。</p>
<h3 id="sed"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#sed"></a><code>sed</code></h3>
<p><code>sed</code>可以做 <a href="https://linux.die.net/man/1/sed">很多事情</a> ，比如编辑字符串和匹配正则表达式。 我们可以用 <code>sed</code>将一种模式替换为另一种模式，如下所示：</p>
<p><code>sed 's/&lt;PATTERN-TO-REPLACE&gt;/&lt;NEW-PATTERN&gt;/g &lt;INPUT&gt;'</code></p>
<p>sed` 还可以从其他东西获取管道输入，而不是显式输入。</p>
<p>这 <code>g</code>最后告诉 <code>sed</code>替换所有出现的模式； 如果我们只想替换模式的第一次出现，则可以省略它，或者用数字替换以仅替换一定次数的出现。</p>
<h3 id="xargs"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#xargs"></a><code>xargs</code></h3>
<p><code>xargs</code>让我们将命令应用于从管道重定向的输出。 例如， <code>output | xargs command</code>会适用 <code>command</code>到 <code>output</code>。 一些有用的 <a href="https://linux.die.net/man/1/xargs">选项</a> ：</p>
<p><code>-n1</code>告诉 <code>xargs</code>将命令应用到中的每个项目 <code>output</code>如果输出中有多个项目（例如多个字符串的列表），则一次</p>
<p><code>-0</code>告诉 <code>xargs</code>用空字符（表示字符串的结尾）分割输出中的项目，而不是使用空格。 搭配 <code>-n1</code>， 这意味着 <code>xargs</code>会将命令应用于每个字符串，而不是将字符串分解为单个单词并将命令应用于每个单词。</p>
<p>与往常一样，有更多方法可以使用这些命令，因此请使用 Google 或 <a href="https://en.wikipedia.org/wiki/Man_page">手册页</a> 来了解更多信息</p>
<h2 id="语法">语法</h2>
<h3 id="shell-变量和类型">Shell 变量和类型</h3>
<p>与大多数其他编程语言一样， <code>bash</code>促进有状态分配 名称到值作为变量。</p>
<p>变量可以被赋值 <code>bash</code>语法如下： <code>NAME=value</code>。 请注意 赋值运算符之间缺少空格 <code>=</code>及其操作数。 任务 对空格敏感。</p>
<p>您可以通过在前面添加一个来检索变量的值 <code>$</code>以它的名字。 获取值 <code>NAME</code>必须完成 <code>$NAME</code>。 这就是所谓的变量 插值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ NAME = &quot;Tux&quot; # Incorrect</span><br><span class="line">-bash: NAME: command not found </span><br><span class="line">$ NAME=&quot;Tux&quot; # Correct</span><br><span class="line">$ echo NAME # Incorrect. We want the value we assigned to NAME, not the text </span><br><span class="line"># NAME itself.</span><br><span class="line">NAME</span><br><span class="line">$ echo $NAME # Correct</span><br><span class="line">Tux</span><br></pre></td></tr></table></figure>
<p><code>$?</code>保存最近执行的命令的退出代码。 在这个 上下文、退出代码 <code>0</code>一般表示程序已经执行 成功地。 其他 <a href="http://tldp.org/LDP/abs/html/exitcodes.html">退出代码</a> 指的是错误的性质 导致程序失败。</p>
<p>特殊 <em>位置参数</em> 允许将参数传递到脚本中。 <code>$0</code>是脚本的名称， <code>$1</code>是传递给的第一个参数 脚本， <code>$2</code>是传递给脚本的第二个参数， <code>$3</code>是第三个 论证等 <code>$#</code>给出传递给脚本的参数数量。</p>
<p>所以 <code>./awesome_shell_script foo bar</code>可以访问 <code>foo</code>从 <code>$1</code>和 <code>bar</code>从 <code>$2</code>.</p>
<p>Bash 变量是 <em>无类型的</em> 。 它们通常被视为文本（字符串），但是 如果变量包含数字和算术运算，则可以将其视为数字 对其应用操作。 请注意，这与大多数编程不同 语言。 <em>变量</em> 本身没有类型，但 <em>运算符</em> 会处理 在不同的环境下他们的价值观也不同。 换句话说， <code>bash</code>变量是文本，没有任何固有的行为或属性 可以操作的文本，但操作员会解释该文本 根据其内容（数字或无数字？）和上下文 表达。</p>
<h3 id="算术"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#arithmetic"></a>算术</h3>
<p>Bash 支持整数算术 <code>let</code>内置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ x=1+1</span><br><span class="line">$ echo $x # Incorrect. We wanted 2, not the text 1+1.</span><br><span class="line">1+1</span><br><span class="line">$ let x=1+1</span><br><span class="line">$ echo $x # Correct</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>注意 <code>let</code>对空格敏感。 操作数和运算符不得 用空格分隔。</p>
<p><code>bash</code>本身不支持浮点运算，所以我们必须依赖 如果我们想处理十进制数字，请使用外部实用程序。 一个常见的选择 这是 <code>bc</code>。 有趣的事实： <code>bc</code>实际上是它自己的完整语言！</p>
<p>我们经常访问 <code>bc</code>通过 <em>管道</em> （表示为 <code>|</code>），这允许 将一个命令的输出用作另一命令的输入。 我们包括 <code>-l</code> 选项 <code>bc</code>为了启用浮点运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo 1/2 | bc -l</span><br><span class="line">.50000000000000000000</span><br></pre></td></tr></table></figure>
<h3 id="test"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#test"></a><code>test</code></h3>
<p>Bash 脚本经常使用 <code>[</code>（同义词为 <code>test</code>) shell 内置的 表达式的条件评估。 <code>test</code>计算一个表达式并 以任一状态代码退出 <code>0</code>(true) 或状态代码 <code>1</code>（错误的）。</p>
<p><code>test</code>支持常见的字符串和数字运算符，以及许多 额外的二元和一元运算符在大多数情况下没有直接类似物 其他编程语言。 您可以看到这些运算符的列表，以及 其他有用的信息，通过输入 <code>help test</code>在你的壳里。 的输出 如下所示。 注意 <code>help</code>类似于 <code>man</code>，除非它用于 bash 函数而不是其他程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ help test</span><br><span class="line">test: test [expr]</span><br><span class="line">    Exits with a status of 0 (true) or 1 (false) depending on</span><br><span class="line">    the evaluation of EXPR.  Expressions may be unary or binary.  Unary</span><br><span class="line">    expressions are often used to examine the status of a file.  There</span><br><span class="line">    are string operators as well, and numeric comparison operators.</span><br><span class="line"></span><br><span class="line">    File operators:</span><br><span class="line"></span><br><span class="line">        -a FILE        True if file exists.</span><br><span class="line">        -b FILE        True if file is block special.</span><br><span class="line">        -c FILE        True if file is character special.</span><br><span class="line">        -d FILE        True if file is a directory.</span><br><span class="line">        -e FILE        True if file exists.</span><br><span class="line">        -f FILE        True if file exists and is a regular file.</span><br><span class="line">        -g FILE        True if file is set-group-id.</span><br><span class="line">        -h FILE        True if file is a symbolic link.</span><br><span class="line">        -L FILE        True if file is a symbolic link.</span><br><span class="line">        -k FILE        True if file has its `sticky&#x27; bit set.</span><br><span class="line">        -p FILE        True if file is a named pipe.</span><br><span class="line">        -r FILE        True if file is readable by you.</span><br><span class="line">        -s FILE        True if file exists and is not empty.</span><br><span class="line">        -S FILE        True if file is a socket.</span><br><span class="line">        -t FD          True if FD is opened on a terminal.</span><br><span class="line">        -u FILE        True if the file is set-user-id.</span><br><span class="line">        -w FILE        True if the file is writable by you.</span><br><span class="line">        -x FILE        True if the file is executable by you.</span><br><span class="line">        -O FILE        True if the file is effectively owned by you.</span><br><span class="line">        -G FILE        True if the file is effectively owned by your group.</span><br><span class="line">        -N FILE        True if the file has been modified since it was last </span><br><span class="line">read.</span><br><span class="line"></span><br><span class="line">      FILE1 -nt FILE2  True if file1 is newer than file2 (according to</span><br><span class="line">                       modification date).</span><br><span class="line"></span><br><span class="line">      FILE1 -ot FILE2  True if file1 is older than file2.</span><br><span class="line"></span><br><span class="line">      FILE1 -ef FILE2  True if file1 is a hard link to file2.</span><br><span class="line"></span><br><span class="line">    String operators:</span><br><span class="line"></span><br><span class="line">        -z STRING      True if string is empty.</span><br><span class="line"></span><br><span class="line">        -n STRING</span><br><span class="line">        STRING         True if string is not empty.</span><br><span class="line"></span><br><span class="line">        STRING1 = STRING2</span><br><span class="line">                       True if the strings are equal.</span><br><span class="line">        STRING1 != STRING2</span><br><span class="line">                       True if the strings are not equal.</span><br><span class="line">        STRING1 &lt; STRING2</span><br><span class="line">                       True if STRING1 sorts before STRING2 lexicographically.</span><br><span class="line">        STRING1 &gt; STRING2</span><br><span class="line">                       True if STRING1 sorts after STRING2 lexicographically.</span><br><span class="line"></span><br><span class="line">    Other operators:</span><br><span class="line"></span><br><span class="line">        -o OPTION      True if the shell option OPTION is enabled.</span><br><span class="line">        ! EXPR         True if expr is false.</span><br><span class="line">        EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.</span><br><span class="line">        EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.</span><br><span class="line"></span><br><span class="line">        arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,</span><br><span class="line">                       -lt, -le, -gt, or -ge.</span><br><span class="line"></span><br><span class="line">    Arithmetic binary operators return true if ARG1 is equal, not-equal,</span><br><span class="line">    less-than, less-than-or-equal, greater-than, or greater-than-or-equal</span><br><span class="line">    than ARG2.</span><br></pre></td></tr></table></figure>
<p>我们可以测试整数相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ [ 0 -eq 0 ]; echo $? # exit code 0 means true</span><br><span class="line">0</span><br><span class="line">$ [ 0 -eq 1 ]; echo $? # exit code 1 means false</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>字符串相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ [ zero = zero ]; echo $? # exit code 0 means true</span><br><span class="line">0</span><br><span class="line">$ [ zero = one ]; echo $? # exit code 1 means false</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>以及您可以自由进行的许多其他字符串和数字运算 探索。</p>
<h3 id="控制结构"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#flow-control"></a>控制结构</h3>
<p><code>bash</code>包括大多数编程语言典型的控制结构 – <code>if-then-elif-else</code>, <code>while</code> <code>for-in</code>等等。您可以阅读更多有关 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_07.html">条件语句</a> 和 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_09.html">迭代</a> 中的 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html">Bash 指南 初学者</a> Linux 文档项目 (LDP) 的 。 我们鼓励您 请阅读这些部分，因为本指南仅提供了一些内容的简短摘要 重要特征。</p>
<h3 id="if-then-elif-else"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#if-then-elif-else"></a>if-then-elif-else</h3>
<p>if 语句的一般形式 <code>bash</code>是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if TEST-COMMANDS; then</span><br><span class="line"></span><br><span class="line">  CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">elif MORE-TEST-COMMANDS; then</span><br><span class="line"></span><br><span class="line">  MORE-CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">else </span><br><span class="line"></span><br><span class="line">  ALTERNATE-CONSEQUENT-COMMANDS;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>缩进是一种很好的做法，但不是必需的。</p>
<p>例如，如果我们写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">if [ $1 -eq $2 ]; then</span><br><span class="line">  echo args are equal</span><br><span class="line">else</span><br><span class="line">  echo args are not equal</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>我们看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./awesome_shell_script 0 0</span><br><span class="line">args are equal</span><br><span class="line">$ ./awesome_shell_script 0 1</span><br><span class="line">args are not equal</span><br></pre></td></tr></table></figure>
<h3 id="尽管"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#while"></a>尽管</h3>
<p>while 循环的一般形式 <code>bash</code>是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while TEST-COMMANDS; do</span><br><span class="line"></span><br><span class="line">  CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>如果 <code>TEST-COMMANDS</code>退出并带有状态码 <code>0</code>, <code>CONSEQUENT-COMMANDS</code>将要 执行。 这些步骤将重复，直到 <code>TEST-COMMANDS</code>退出时带有一些非零值 地位。</p>
<p>例如，如果我们写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">n=$1</span><br><span class="line">while [ $n -gt 0 ]; do</span><br><span class="line">  echo $n</span><br><span class="line">  let n=$n-1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>我们看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./awesome_shell_script 5</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#functions"></a>函数</h3>
<p><code>bash</code> supports functions, albeit in a crippled form relative to many other languages. Some notable differences include:</p>
<ul>
<li>函数不 <em>返回</em> 任何内容，它们只是产生输出流（例如 <code>echo</code>到标准输出）</li>
<li><code>bash</code>严格来说是按值调用。 也就是说，只有原子值（字符串）可以 被传递到函数中。</li>
<li>变量没有词法作用域。 <code>bash</code>使用一个非常简单的本地系统 范围接近动态范围。</li>
<li><code>bash</code>没有一流的函数（即没有将函数传递给 其他函数）、匿名函数或闭包。</li>
</ul>
<p>功能于 <code>bash</code>定义为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name_of_function() &#123;</span><br><span class="line"></span><br><span class="line">  FUNCTION_BODY</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name_of_function $arg1 $arg2 ... $argN</span><br></pre></td></tr></table></figure>
<p>请注意函数签名中缺少参数。 参数在 <code>bash</code> 函数的处理方式与全局位置参数类似，其中 <code>$1</code> 含有 <code>$arg1</code>, <code>$2</code>含有 <code>$arg2</code>， ETC。</p>
<p>例如，如果我们写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  echo hello $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo $1</span><br></pre></td></tr></table></figure>
<p>我们看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./awesome_shell_script world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="实例">实例</h2>
<p><code>斐波那契</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of fibonacci</span><br><span class="line"></span><br><span class="line">if [ $# -eq 0 ]; then</span><br><span class="line">    echo &quot;fibonacci needs an argument&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">fib() &#123;</span><br><span class="line">    N=&quot;$1&quot;</span><br><span class="line">    if [ -z &quot;$&#123;N##*[!0-9]*&#125;&quot; ]; then</span><br><span class="line">        echo &quot;fibonacci only makes sense for nonnegative integers&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ &quot;$N&quot; -eq 0 ]; then</span><br><span class="line">        echo 0</span><br><span class="line">    elif [ &quot;$N&quot; -eq 1 ]; then</span><br><span class="line">        echo 1</span><br><span class="line">    else</span><br><span class="line">        echo $(($(fib $((N-2))) + $(fib $((N-1)))))</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib &quot;$1&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -p “send: ” FOO</span><br><span class="line"># enter “hi”</span><br><span class="line">echo “sent: $FOO”</span><br><span class="line">sent: hi</span><br><span class="line"></span><br><span class="line">FOO=$(expr 1 + 1)</span><br><span class="line">echo “$FOO”</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">-eq ==</span><br><span class="line">-ne !=</span><br><span class="line">-gt &gt;</span><br><span class="line">-ge &gt;=</span><br><span class="line">-lt &lt;</span><br><span class="line">-le &lt;=</span><br><span class="line"></span><br><span class="line">test zero = zero; echo $?</span><br><span class="line">0 # 0 means true</span><br><span class="line">test zero = one; echo $?</span><br><span class="line">1 # 1 means false</span><br><span class="line"></span><br><span class="line">if [ “$1” -eq 69 ];</span><br><span class="line">then</span><br><span class="line">echo “nice”</span><br><span class="line">elif [ “$1” -eq 42 ];</span><br><span class="line">then</span><br><span class="line">echo “the answer!”</span><br><span class="line">else</span><br><span class="line">echo “wat r numbers”</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">read -p &quot;are you 21?&quot; ANSWER</span><br><span class="line">case &quot;$ANSWER&quot; in</span><br><span class="line">“yes”)</span><br><span class="line">echo &quot;i give u cookie&quot;;;</span><br><span class="line">“no”)</span><br><span class="line">echo &quot;thats illegal&quot;;;</span><br><span class="line">“are you?”)</span><br><span class="line">echo “lets not”;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;please answer&quot;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">NAMES=&quot;a b c d&quot;</span><br><span class="line">for NAME in $NAMES</span><br><span class="line">do</span><br><span class="line">echo &quot;Hello $NAME&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">echo &quot;Hello $NAME&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>Bash 支持整数算术 <code>let</code>内置的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ x=1+1</span><br><span class="line">$ echo $x # Incorrect. We wanted 2, not the text 1+1.</span><br><span class="line">1+1</span><br><span class="line">$ let x=1+1</span><br><span class="line">$ echo $x # Correct</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>注意 <code>let</code>对空格敏感。 操作数和运算符不得 用空格分隔。 <code>test</code>计算一个表达式并 以任一状态代码退出 <code>0</code>(true) 或状态代码 <code>1</code>（错误的）</p>
<p><code>bash</code>支持函数，尽管相对于许多其他函数而言，其形式有缺陷 语言。 一些显着的差异包括：</p>
<ul>
<li>函数不 <em>返回</em> 任何内容，它们只是产生输出流（例如 <code>echo</code>到标准输出）</li>
<li><code>bash</code>严格来说是按值调用。 也就是说，只有原子值（字符串）可以 被传递到函数中。</li>
<li>变量没有词法作用域。 <code>bash</code>使用一个非常简单的本地系统 范围接近动态范围。</li>
<li><code>bash</code>没有一流的函数（即没有将函数传递给 其他函数）、匿名函数或闭包</li>
</ul>
<p>请注意函数签名中缺少参数。 参数在 <code>bash</code> 函数的处理方式与全局位置参数类似，其中 <code>$1</code> 含有 <code>$arg1</code>, <code>$2</code>含有 <code>$arg2</code>， ETC。</p>
<p>例如，如果我们写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  echo hello $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo $1</span><br></pre></td></tr></table></figure>
<p>我们看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./awesome_shell_script world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h1 id="shell命令">shell命令</h1>
<h2 id="ssh安全外壳">SSH（安全外壳）</h2>
<p>SSH 允许您通过互联网登录远程计算机。 这相当于在远程计算机上打开 shell。</p>
<p>用法是 <code>ssh [remote username]@[remote host]</code>.</p>
<h3 id="问题"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#question"></a>问题</h3>
<ol type="1">
<li>登录到 <code>tsunami.ocf.berkeley.edu</code>使用您的 OCF 用户名和密码。 有一个文件在 <code>~staff/public_html/decal</code>。 打开它。 文件中到底隐藏着什么秘密？</li>
</ol>
<h2 id="管道和重定向"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#pipes-and-redirection"></a>管道和重定向</h2>
<p>将命令链接在一起对于自动化 shell 操作至关重要。 这是一个快速备忘单：</p>
<p><code>&gt;</code>：将 <a href="https://linux.die.net/man/3/stdout">标准</a> 输出重定向到文件（将覆盖该文件）。</p>
<p><code>&gt;&gt;</code>：将标准输出附加到文件（与 <code>&gt;</code>除非不覆盖）。</p>
<p><code>&lt;</code>：从文件中读取输入。</p>
<p><code>|</code>：将一个程序的输出发送到下一个程序的输入。</p>
<p>下面是一个示例：假设您正在参加一门课程，需要您提交一个包含您的 SID 的文本文件。 您的第一反应可能是打开一个文本编辑器（例如 <code>vim</code>）并简单地输入它，但是有一种更快的方法来创建文件！ 这里是：</p>
<p><code>echo '123456789' &gt; sid.txt</code></p>
<h2 id="tmux">tmux</h2>
<h3 id="为什么是-tmux">为什么是 tmux？</h3>
<ul>
<li>当通过 ssh 连接到一台计算机时，您可以打开多个窗口。</li>
<li>您可以在编辑程序的同时对其进行编译和运行。</li>
<li>您可以注销并通过 ssh 重新登录，而无需重新打开所有文件。</li>
</ul>
<h3 id="入门"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#getting-started"></a>入门</h3>
<ul>
<li>开始会话 <code>tmux</code>.</li>
<li>从会话中分离 <code>Ctrl-b d</code>（释放后按 d <code>Ctrl-b</code>)</li>
<li>分成 2 个窗格 <code>Ctrl-b %</code>（垂直）或 <code>Ctrl-b "</code>（水平的）</li>
<li>交换当前窗格 <code>Ctrl-b o</code></li>
<li>在线查找有关 tmux 的更多信息。 您可能会发现 <a href="https://gist.github.com/MohamedAlaa/2961058">此备忘单</a> 很有帮助！</li>
</ul>
<h1 id="包管理">包管理</h1>
<h2 id="debian简介-apt和-dpkg">Debian：简介 <code>apt</code>和 <code>dpkg</code></h2>
<p>在本课程中，我们将重点关注 Debian 的使用。 正如本周讲座中提到的，Debian 使用 apt/dpkg 作为其包管理器。 其他发行版使用不同的包管理器。</p>
<h3 id="apt"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#apt"></a><code>apt</code></h3>
<p>Debian 的前端包管理器是 <code>apt</code>。 大多数时候，当您需要与包管理器打交道时， <code>apt</code>通常是要走的路。 在做任何事情之前 <code>apt</code>，更新包列表通常是一个好习惯，以便包管理器可以找到并获取各种包的最新版本。 为此，您可以运行：</p>
<p><code>apt update</code></p>
<p>要查找要安装的包：</p>
<p><code>apt search [package|description]</code></p>
<p>要安装包：</p>
<p><code>apt install [package]</code></p>
<p>要删除包：</p>
<p><code>apt remove [package]</code></p>
<p>使用安装的软件包一段时间后，您可能会注意到它们不会自动更新，这一功能可能存在于为其他操作系统编写的程序中。 要更新已安装的软件包，请运行：</p>
<p><code>apt upgrade</code>或有时 <code>apt dist-upgrade</code></p>
<p>使用起来比较普遍 <code>apt upgrade</code>更新你的包，但有时你需要使用 <code>apt dist-upgrade</code>。 阅读有关两者之间差异的更多信息 <a href="https://askubuntu.com/questions/194651/why-use-apt-get-upgrade-instead-of-apt-get-dist-upgrade">您可以在此处</a> 。</p>
<p>在某些情况下，您希望完全确定要安装的软件包的版本。 要列出可以安装的潜在版本，您可以运行：</p>
<p><code>apt policy [package]</code></p>
<p>这根据其引脚优先级列出了要安装的候选版本以及与系统兼容的其他版本。 要安装特定目标版本的 aa 版本，您可以运行：</p>
<p><code>apt -t [targetrelease] install [package]</code></p>
<p>还有其他命令可以删除不需要的依赖项并清除包，但这就是 <code>man</code>页面是为了。 请注意，您将必须使用 <code>sudo</code>对于上述命令，因为您实际上是在修改系统本身。</p>
<h3 id="dpkg"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#dpkg"></a><code>dpkg</code></h3>
<p>后端包管理器是 <code>dpkg</code>。 传统上， <code>dpkg</code>用于安装本地软件包。 使用 <code>dpkg</code>，您还可以检查软件包并修复损坏的安装。 要安装本地软件包，请运行：</p>
<p><code>dpkg -i [packagefilename]</code></p>
<p>删除系统包：</p>
<p><code>dpkg --remove [package]</code></p>
<p>要检查包以获取有关该包的更多信息：</p>
<p><code>dpkg -I [packagefilename]</code></p>
<p>要修复/配置所有已解压但未完成的安装：</p>
<p><code>dpkg --configure -a</code></p>
<h2 id="入门-1"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#getting-started"></a>入门</h2>
<h3 id="创建一个简单的包">创建一个简单的包</h3>
<p>现在，我们将使用您将在接下来的步骤中创建的 hellopenguin 可执行文件创建一个简单的包。 首先，移至您在入门部分克隆的存储库中的 a2 文件夹：</p>
<p><code>cd decal-labs/a2</code></p>
<p>现在我们将创建一个文件夹来进行此练习：</p>
<p><code>mkdir ex1</code></p>
<p>现在进入该文件夹：</p>
<p><code>cd ex1</code></p>
<h3 id="编写和编译程序"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#writing-and-compiling-the-program"></a>编写和编译程序</h3>
<p>现在，我们将用 C 语言制作一个非常简单的应用程序，打印“Hello Penguin！” 名为地狱企鹅。 调用：</p>
<p><code>touch hellopenguin.c</code></p>
<p>这将创建一个名为的空文件 <code>hellopenguin.c</code>。 现在，使用您选择的首选文本编辑器，例如 <code>vim</code>, <code>emacs</code>， 或者 <code>nano</code>，将以下代码插入 <code>hellopenguin.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   printf(&quot;Hello Penguin!\n&quot;);</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在将编译您刚刚编写的源文件：</p>
<p><code>gcc hellopenguin.c -o hellopenguin</code></p>
<p>其作用是获取源文件 <code>hellopenguin.c</code>并将其编译为名为的可执行文件 <code>hellopenguin</code>与 <code>-o</code>输出标志。</p>
<h3 id="打包可执行文件"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#packaging-the-executable"></a>打包可执行文件</h3>
<p>现在，我们将创建可执行文件所在的文件夹结构。在 Debian 中，用户级包通常驻留在该文件夹中 <code>/usr/bin/</code>:</p>
<p><code>mkdir -p packpenguin/usr/bin</code></p>
<p>现在移动你编译的 <code>hellopenguin</code>可执行到 <code>packpenguin/usr/bin/</code>文件夹。</p>
<p><code>mv hellopenguin packpenguin/usr/bin/</code></p>
<p>现在我们将创建一个名为 <code>hellopenguin</code>。 移动到父目录 <code>packpenguin</code>文件夹并调用以下命令：</p>
<p><code>fpm -s dir -t deb -n hellopenguin -v 1.0~ocf1 -C packpenguin</code></p>
<p>这指定您要使用目录 <code>-s</code>标志，并输出 <code>.deb</code>包使用 <code>-t</code>旗帜。 它接受一个名为的目录 <code>packpenguin</code>， 使用 <code>-C</code>标志，并输出 <code>.deb</code>文件名为 <code>hellopenguin</code>， 使用 <code>-n</code>，版本号为 <code>1.0~ocf1</code>， 使用 <code>-v</code>旗帜。</p>
<p>现在通过调用 apt 并安装它来测试它：</p>
<p><code>sudo dpkg -i ./hellopenguin_1.0~ocf1_amd64.deb</code></p>
<p>现在你应该能够运行 <code>hellopenguin</code>通过执行以下操作：</p>
<p><code>hellopenguin</code></p>
<h1 id="计算机网络">计算机网络</h1>
<h2 id="概述">概述</h2>
<p>不可否认，互联网是一个重新定义了我们世界的重要系统。 开发网络和允许设备通信的能力对于现代计算机系统至关重要。 本实验将研究计算机网络的基础知识，然后从系统管理员的角度检查网络。</p>
<p>我们将使用网页浏览作为类比来了解网络的基础知识。 当我上网浏览猫的图片时到底会发生什么？</p>
<p>但首先让我们简要了解一下网络的细节。</p>
<hr />
<h2 id="硬件地址mac"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#mac"></a>硬件地址mac</h2>
<p>媒体访问控制 (MAC) 地址是唯一分配给网络接口的标识符。 <img src="https://upload.wikimedia.org/wikipedia/commons/9/94/MAC-48_Address.svg" title="MAC地址格式" alt="所有文字" /></p>
<p>由于 MAC 地址是唯一的，因此通常称为物理地址。 八位位组通常以十六进制书写并用冒号分隔。 MAC 地址示例是 <code>00:14:22:01:23:45</code>。 请注意，前 3 个八位位组指的是组织唯一标识符 (OUI)，它可以帮助识别制造商。 有趣的事实—— <code>00:14:22</code>以上是 Dell 的 OUI。</p>
<h2 id="ip"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#ip"></a>ip</h2>
<p>IP 地址是识别根据互联网协议连接到网络的设备的方法。 互联网协议有两个版本：IPv4 和 IPv6，它们的地址大小不同。 IPv6 地址示例是 <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>它比 IPv4 地址长得多，例如 <code>127.0.0.1</code>。 由于时间关系，我们只讨论 IPv4，但 IPv6 确实正在取得进展，值得一试！</p>
<p>IPv4 地址为 32 位，即 4 个字节，每个字节由点 (.) 分隔。 IPv4 地址示例是 <code>127.0.0.1</code>。 巧合的是，这个地址被称为环回地址，它映射到您自己机器上的环回接口。 这允许网络应用程序在同一台计算机（在本例中是您的计算机）上运行时相互通信。 但为什么 <code>127.0.0.1</code>并不是 <code>127.0.0.0</code>或者 <code>127.0.0.2</code>?</p>
<p>答案是 <code>127.0.0.1</code>是简单的约定，但从技术上讲，网络块中的任何地址 <code>127.0.0.0/8</code>是一个有效的环回地址。 但网络块到底是什么？</p>
<p>在 IPv4 中，我们可以将地址块划分为子网。 这是以 CIDR 格式编写的。 我们以上面的子网为例 <code>127.0.0.0/8</code>。 斜杠后面的数字 ( <code>/</code>)，在本例中为 8，是子网掩码。 这表示网络地址中有多少位，其余位标识网络内的主机。 在这种情况下，网络地址是 <code>127.0.0.0</code>面具是 <code>255.0.0.0</code>。 所以 <code>127.0.0.1</code>将是第一个主机 <code>127.0.0.0/8</code>网络等等。</p>
<p>该图提供了 CIDR 寻址的可视化细分 <img src="https://i.imgur.com/dEgcX0R.png" title="CIDR 寻址示例由 CS168 提供" alt="所有文字" /></p>
<h2 id="arp"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#arp"></a>ARP</h2>
<p>地址解析协议 (ARP) 是用于将 IP 地址解析为 MAC 地址的协议。 为了理解ARP，我们首先讨论发送帧的两种方式，单播和广播。 在第 2 层上下文中，单播帧意味着将该帧发送到一个 MAC 地址。 另一方面，通过将帧发送到广播地址来广播帧意味着该帧应该发送到网络上的每个设备，从而有效地“淹没”本地网络。</p>
<p>例如，让我们想象一个发送者 A，他有 MAC <code>00:DE:AD:BE:EF:00</code>，广播一条消息，本质上是询问“谁拥有 IP 地址 <code>42.42.42.42</code>请在 00:DE:AD:BE:EF:00 告诉 A”。</p>
<p>如果一台机器B，有MAC <code>12:34:56:78:9a:bc</code>有IP地址 <code>42.42.42.42</code>他们向发件人发送单播回复，其中包含以下信息“ <code>12:34:56:78:9a:bc</code>有 <code>42.42.42.42</code>”。 发送方将此信息存储在 arp 表中，因此每当它收到发往机器 B 的数据包时，即目标 IP 地址为 <code>42.42.42.42</code>它将数据包发送到从 B 收到的 MAC。</p>
<p>为了路由 IP 数据包，设备具有所谓的路由表。 路由条目存储在路由表中，它们本质上是告诉设备应如何基于 IP 转发数据包的规则。 路由条目指定子网以及与该条目对应的接口。 设备选择具有最特定于给定数据包的子网的条目，并将其转发出该条目上的接口。</p>
<p>路由表通常也有一个默认网关。 在没有更具体的匹配条目的情况下，这将用作数据包的默认捕获所有内容。</p>
<p>以此路由表为例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default via 10.0.2.2 dev eth0</span><br><span class="line">10.0.2.0/24 dev eth0  proto kernel  scope link  src 10.0.2.15</span><br><span class="line">10.0.2.128/25 dev eth0  proto kernel  scope link  src 10.0.2.15</span><br><span class="line">192.168.162.0/24 dev eth1  proto kernel  scope link  src 192.168.162.162</span><br></pre></td></tr></table></figure>
<p>一个数据包的目的地是 <code>8.8.8.8</code>将从默认网关 eth0 转发出去。 一个数据包的目的地是 <code>10.0.2.1</code>将根据第二个条目从 eth0 转发。 一个数据包的目的地是 <code>10.0.2.254</code>将根据第三个条目从 eth0 转发。 一个数据包的目的地是 <code>192.168.162.254</code>将根据第四个条目从 eth1 转发。</p>
<h2 id="域名"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#dns"></a>域名</h2>
<p>我们已经讨论了 IP 地址以及它们如何通过 IP 与主机进行通信，但是虽然 IP 地址是机器友好的（计算机喜欢数字），但它们并不完全是人类友好的。 记住电话号码已经够难了，记住 32 位 IP 地址也不会更容易。</p>
<p>但我们更容易记住 &lt;www.google.com、www.facebook.com&gt; 或 Coolmath-games.com 等名称。 因此，在这种冲突中，域名系统 (DNS) 诞生了，它是机器友好的 IP 地址和人类友好的域名之间的折衷方案。</p>
<p>DNS 是一个将 google.com 等域名映射到 <code>172.217.6.78</code>。 当您查询 google.com 时，您的计算机会将 google.com 的 DNS 查询发送到 DNS 服务器。 假设配置正确并且 google.com 有一个有效的对应地址，您将收到来自权威服务器的响应，其实质上是“google.com 有 IP 地址” <code>x.x.x.x</code>”.</p>
<p>现在让我们稍微消除一下这个黑魔法……</p>
<h2 id="dns-记录"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#dns-records"></a>DNS 记录</h2>
<p>DNS 服务器以资源记录 (RR) 的形式存储数据。 资源记录本质上是（名称、值、类型、TTL）的元组。 虽然 DNS 记录的类型多种多样，但我们最关心的是</p>
<ol type="1">
<li><p><strong>一条记录</strong> 名称 = 主机名 值 = IP 地址</p>
<p>该记录非常简单，包含给定主机名的 IP 地址，本质上是我们最终想要得到的信息。</p></li>
<li><p><strong>国民服役记录</strong> 名称=域名 值 = 域的 DNS 服务器名称</p>
<p>该记录指向另一个可以为该域提供权威答案的 DNS 服务器。 将此视为将您重定向到另一个名称服务器。</p></li>
<li><p><strong>CNAME 记录</strong> 名称 = 别名 值=规范名称</p>
<p>这些记录指向给定别名的规范名称，例如 docs.google.com 将是一个仅指向 document.google.com 的别名 尝试 &lt;www.facebook.com&gt;</p></li>
<li><p><strong>MX记录</strong> 邮件服务使用的记录。</p></li>
</ol>
<h2 id="tcp-和-udp"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#tcp-and-udp"></a>TCP 和 UDP</h2>
<p>现在我们将讨论传输层的协议。 这一层最著名的两个协议是传输控制协议（TCP）和用户数据报协议（UDP）。</p>
<p>TCP 是一种面向有状态流的协议，可确保可靠的传输。 可靠的传输本质上保证信息完整且有序地到达目的地。</p>
<p>TCP 是面向连接的协议，这意味着它在发送任何数据之前必须首先建立连接。 此连接交换信息，这是 TCP 用于在其他功能中提供可靠传输的机制。 TCP 连接以 TCP 握手开始。</p>
<p>TCP 握手包括在发送方和接收方之间交换的数据包的 TCP 标头中设置某些标志。 发送方首先发送 SYN（设置了 SYN 标志的数据包）来启动 TCP 连接。 服务器通过发回 SYN-ACK（一个同时设置了 SYN 和 ACK 标志的数据包）来确认此连接请求。 客户端通过向服务器发送一个最终 ACK 来确认这一点，然后建立连接。</p>
<p>TCP 然后开始传输数据，如果数据成功到达连接的另一端，则会发出 ACK。 因此，如果数据丢失、重新排序或损坏，TCP 能够识别这一点并发送重传任何丢失数据的请求。</p>
<p>TCP 也有一个关闭连接的过程。 我们在这里只考虑优雅终止，突然终止有不同的过程，我们不会讨论。 如果您有兴趣，CS168 <a href="https://drive.google.com/file/d/0B4GG2Ks7ZJf5RlpRby1Qbk8zcTg/view">这里</a> 有一些很棒的材料。 假设机器 A 想关闭与机器 B 的连接。</p>
<p>A 首先发送 FIN。 B 必须通过发送 FIN 和 ACK 进行响应。 如果 B 仅发送 ACK，则连接将持续存在，并且可以发送其他数据，直到发送 FIN。 另一方面，如果 B 准备好关闭连接并且不需要发送额外的数据，则 B 也可以只发送一个同时设置了 FIN 和 ACK 标志的数据包，即 FIN+ACK。发送最后一个 ACK​​ 来表示连接终止。</p>
<p>UDP是无状态无连接协议。 UDP 专注于以数据报的形式发送消息。 无连接 UDP 也不会产生 TCP 握手和终止的开销。 UDP 也不保证可靠传输，因此消息可能会损坏、无序到达或根本不到达。 因此，UDP 有时被称为不可靠数据报协议。</p>
<p>虽然 UDP 不保证可靠传输，但它不会像 TCP 那样遭受建立和关闭连接的开销。 因此，UDP 非常适合我们只想快速发送数据包并且丢失一些数据包也不会造成灾难性后果的使用情况。</p>
<p>此外，与 TCP 相比，发送的每个 UDP 数据报都需要单独接收。 而对于 TCP，您传递的数据流被透明地分成一定数量的发送，并且数据流在另一端透明地重建为一个整体。</p>
<h2 id="端口"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#ports-optional"></a>端口</h2>
<p>广义上讲，端口定义了服务端点——端口标记了流量的入口和出口点。 IP 地址连接主机，而端口则连接在此类主机上运行的进程。 一次只能将一个进程绑定到一个端口。 端口由 16 位数字表示，范围从 0 到 65535。从 0 到 1023 的端口是众所周知的端口，即系统端口。 使用这些端口通常有更严格的要求。 1024 到 49151 是注册端口。 官方 <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">列表</a> IANA 维护着知名和注册范围的 。 从 49152 到 65535 的其余端口是临时端口，可以根据每个请求动态分配给通信会话。</p>
<h1 id="systemd-unit">systemd unit</h1>
<p><a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">unit的介绍和写法</a> Linux 发行版越来越多地采用 <code>systemd</code>初始化系统。 这套功能强大的软件可以管理服务器的许多方面，从服务到安装的设备和系统状态。</p>
<p>在 <code>systemd</code>， A <code>unit</code>指系统知道如何操作和管理的任何资源。 这是主要对象 <code>systemd</code>工具知道如何处理。 这些资源是使用称为单元文件的配置文件定义的。</p>
<p>单位是对象 <code>systemd</code>知道如何管理。 这些基本上是系统资源的标准化表示，可以由守护程序套件管理并由提供的实用程序操作。</p>
<p>单元可以说类似于其他 init 系统中的服务或作业。 然而，单元具有更广泛的定义，因为它们可用于抽象服务、网络资源、设备、文件系统挂载和隔离资源池。 系统的单元文件副本一般保存在 <code>/lib/systemd/system</code>目录。 当软件在系统上安装单元文件时，这是它们默认放置的位置。</p>
<p>存储在此处的单元文件可以在会话期间按需启动和停止。 这将是通用的普通单元文件，通常由上游项目的维护人员编写，应该适用于部署的任何系统 <code>systemd</code>在其标准实施中。 您不应编辑此目录中的文件。 相反，如果有必要，您应该使用另一个单元文件位置来覆盖该文件，该位置将取代该位置中的文件。 正确的方法是创建一个以单元文件命名的目录 <code>.d</code>附加在最后。 所以对于一个叫做 <code>example.service</code>，一个名为 <code>example.service.d</code>可以被创建。 在此目录中，有一个以以下结尾的文件 <code>.conf</code>可用于覆盖或扩展系统单元文件的属性。</p>
<p>大多数单元文件中的第一部分是 <code>[Unit]</code>部分。 这通常用于定义单元的元数据并配置单元与其他单元的关系。</p>
<p>尽管部分顺序并不重要 <code>systemd</code>解析文件时，此部分通常放置在顶部，因为它提供了单元的概述。 您可以在以下位置找到一些常见指令 <code>[Unit]</code>部分是：</p>
<ul>
<li><strong><code>Description=</code></strong>：该指令可用于描述单元的名称和基本功能。 它由各种返回 <code>systemd</code>工具，因此最好将其设置为简短、具体且信息丰富的内容。</li>
<li><strong><code>Documentation=</code></strong>：该指令提供了文档 URI 列表的位置。 这些可以是内部可用的 <code>man</code>页面或网络可访问的 URL。 这 <code>systemctl status</code>命令将公开此信息，以便于轻松发现。</li>
<li><strong><code>Requires=</code></strong>：该指令列出了该单元本质上依赖的所有单元。 如果当前单位已激活，则此处列出的单位也必须成功激活，否则该单位将失败。 默认情况下，这些单元与当前单元并行启动。</li>
<li><strong><code>Wants=</code></strong>：该指令类似于 <code>Requires=</code>，但不太严格。 <code>Systemd</code>当此单元被激活时，将尝试启动此处列出的任何单元。 如果未找到这些单元或无法启动，当前单元将继续运行。 这是配置大多数依赖关系的推荐方法。 同样，这意味着并行激活，除非被其他指令修改。</li>
<li><strong><code>BindsTo=</code></strong>：该指令类似于 <code>Requires=</code>，但也会导致当前单元在关联单元终止时停止。</li>
<li><strong><code>Before=</code></strong>：如果同时激活了该指令中列出的单元，则只有当前单元被标记为已启动后，它们才会启动。 这并不意味着依赖关系，并且如果需要的话必须与上述指令之一结合使用。</li>
<li><strong><code>After=</code></strong>：该指令中列出的单元将在启动当前单元之前启动。 这并不意味着依赖关系，如果需要，必须通过上述指令建立依赖关系。</li>
<li><strong><code>Conflicts=</code></strong>：这可用于列出不能与当前单元同时运行的单元。 启动具有这种关系的单元将导致其他单元停止。</li>
<li><strong><code>Condition...=</code></strong>: 有许多指令以 <code>Condition</code>这允许管理员在启动设备之前测试某些条件。 这可用于提供仅在适当的系统上运行的通用单元文件。 如果不满足条件，则会正常跳过该单元。</li>
<li><strong><code>Assert...=</code></strong>：类似于以 <code>Condition</code>，这些指令检查运行环境的不同方面，以决定是否应激活该单元。 然而，与 <code>Condition</code>指令，负结果会导致该指令失败。</li>
</ul>
<h1 id="安全管理">安全管理</h1>
<h2 id="加密与解密">加密与解密</h2>
<h3 id="基础知识">基础知识</h3>
<p>加密采用明文和密钥，返回密文。 解密需要密文和密钥，仅当解密密钥有效时才恢复并返回原始明文。 加密和解密的密钥是由随机位组成的长字符串，这使得攻击者在计算上无法猜测密钥并解密密文。</p>
<p><img src="https://docs.oracle.com/cd/E19424-01/820-4811/images/scrypt.gif" alt="一切" /> 安全性是指在面对攻击时保持系统按预期运行 这可以采取多种形式：</p>
<ol type="1">
<li>保密性</li>
<li>完整性/真实性</li>
<li>可用性</li>
</ol>
<p>模块：</p>
<ol type="1">
<li>认证</li>
<li>加密：防止攻击者读取您的文件，直到它们得到 联邦调查局和他们的密码学家参与其中</li>
<li>哈希：将大数据转化为小数据</li>
<li>签名和证书：确保您就是您所说的人 假设我想使用你的公钥来验证你的身份。 我 可以用它加密一些东西，并要求你解密它并且 显示正确的值。 如果您可以解密该值，那么您必须拥有密钥的私有部分并且可以进行身份​​验证。 假设你想证明你发送的消息实际上是由您发送。 您可以使用您的私钥来“签署”消息通过对其进行加密，您的公钥可用于解密签名以验证您（由您发布的公开信息识别）键）实际上确实发送了消息，因为只有您而不是其他人对手将拥有相应的私钥。 <code>根证书</code>：操作系统包含许多根证书 这是网络信任的基础。 证书是在通向根的链中签名； 如果链有效，则最后的 cert 被认为是可信的。</li>
</ol>
<p>网络攻击： 攻击网络系统的方法有很多： 窃听、中间人、拒绝服务、应用程序 缓冲区/堆溢出、SQL 注入等漏洞 目录遍历、CSRF、SSRF、XSS、蠕虫、rootkit、垃圾邮件、加密挖矿、勒索软件、网络钓鱼等等……</p>
<h3 id="对称密码学"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#symmetric-cryptography"></a>对称密码学</h3>
<p>在对称密码学中，用于加密和解密的密钥是相同的。</p>
<p>尝试一下：</p>
<ol type="1">
<li><code>gpg --symmetric [FILE]</code>在任何文件上输出 <code>[FILE].gpg</code>文件是输入文件的加密版本。 加密文件时需要输入密码。</li>
<li><code>gpg --decrypt [FILE].gpg</code>在原始文件的加密版本上，您需要输入原始密码。</li>
</ol>
<p>在此 GPG 实现中，文件的加密和解密都需要知道单个密码，在本例中该密码充当对称密钥。</p>
<h3 id="非对称密码学"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#asymmetric-cryptography"></a>非对称密码学</h3>
<p>在非对称加密中，两个单独的密钥分别用于加密和解密。 这两个密钥是一对公私密钥。 公钥是公开的并用于加密数据。 而私钥由所有者保密并用于解密数据。 使用公钥加密文件意味着只有拥有相应私钥的人才能解密生成的加密文件。</p>
<h4 id="gpg-钥匙圈抽象"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#gpg-keyring-abstraction"></a>GPG 钥匙圈抽象</h4>
<p>GPG 使用“密钥环”作为集中位置来保存用户的所有密钥。 如果您想使用并保留它，则需要向密钥环添加/导入密钥。 同样，如果您希望与其他人共享密钥，您可以导出您的密钥（这会生成您的密钥的副本）并让他们将其导入到他们的密钥环中。</p>
<p>尝试一下：</p>
<ol type="1">
<li><code>gpg --full-generate-key</code>生成 GPG 公私密钥对。 它会要求输入密码。 <em>如果您的机器需要一段时间才能生成密钥，则可能是由于缺乏长随机密钥所需的熵（随机性）。 <code>sudo apt-get install haveged</code>将安装一个生成熵的守护进程。</em></li>
<li><code>gpg --recipient [RECIPIENT] --encrypt [FILE]</code>这将加密 <code>[FILE]</code>和 <code>[RECIPIENT]</code>的公钥（目前，尝试使用您自己的公钥加密文件）。</li>
<li><code>gpg --decrypt [FILE].gpg</code>将搜索您的密钥环并使用适当的私钥解密文件（当然，如果您拥有正确的私钥）。 <em>您无需指定使用哪个密钥来解密文件，因为 GPG 加密的文件和密钥包含元数据，允许 GPG 从密钥环中选择正确的密钥来解密文件。</em></li>
</ol>
<h3 id="签名"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#signatures"></a>签名</h3>
<p>公钥加密、私钥解密的非对称方案也可以反过来实现数字签名，其作用相当于物理签名。 在这个相反的方案中，私钥用于对文件进行签名，从而在该文件上生成签名。 并使用相应的公钥来验证签名。 因此，只有拥有私钥的人才能生成签名，但拥有相应公钥的任何人都可以验证该签名。 <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Illustration_of_digital_signature.svg/1920px-Illustration_of_digital_signature.svg.png" /></p>
<p>UNIX 权限模型有 3 个组成部分：授予文件的 (1) 所有者用户、(2) 所有者组和 (3) 其他人/其他所有人的权限。 权限本身有 3 个子组件：(1) 读取、(2) 写入和 (3) 执行，强制执行读取、写入或执行文件的能力。</p>
<p><img src="https://www.comentum.com/images/permissions.jpg" /></p>
<h3 id="gpg">gpg</h3>
<ol type="1">
<li>解密b8/file1.txt.gpg:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --decrypt b8/file1.txt.gpg </span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>输入密码ocfdecal后,解密内容为: mYp@sw0rd2. 导入密钥的命令是:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --import &#123;key_file&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>将密钥导出到文件的命令:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --export --armor &#123;key_id&#125; &gt; &#123;output_file&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>查看钥匙圈所有钥匙的命令:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --list-keys</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>使用私钥b8/lab8privkey解密b8/file2.txt.gpg:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --import ./lab8privkey</span><br><span class="line">gpg --decrypt  ./file2.txt.gpg</span><br></pre></td></tr></table></figure>
<h3 id="hash">hash</h3>
<ol type="1">
<li><code>sha1sum [FILE]</code>获取 SHA1 哈希值 <code>[FILE]</code>.</li>
<li><code>md5sum [FILE]</code>获取 MD5 哈希值 <code>[FILE]</code>.</li>
</ol>
<h2 id="安全系统">安全系统</h2>
<h3 id="威胁模型">威胁模型</h3>
<p>设计安全系统时要记住的最重要的事情是 了解您的威胁模型。 没有系统能够保证安全或能够 能够抵挡所有的攻击，甚至在极端的情况下也是不可能的。 对手。 但是，您可以（并且应该）针对威胁采取预防措施 你很可能会面临。 平衡授权用户访问的需求 在将未经授权的用户拒之门外的情况下，很容易出错。 幸运的是，聪明人已经将安全原则提炼为 中得到了很好的 <a href="http://www.icir.org/vern/cs161-sp17/notes/Principles.1.19.pdf">第一个讲义</a> 一些公理，在CS 161 的 介绍 （归功于大卫·瓦格纳教授）。 建议阅读讲义。</p>
<p><strong>构建威胁模型时，请记住以下问题：</strong></p>
<ol type="1">
<li>你在保护什么？</li>
<li>谁是你的对手？</li>
<li>您需要保护它的可能性有多大？</li>
<li>如果不加以保护，会产生什么后果？</li>
<li>您应该投入多少资源来保护它？</li>
</ol>
<h3 id="加密解密">加密解密</h3>
<p><strong>对称密钥加密几乎对所有事物都有用，尤其是属于以下类别的事物：</strong></p>
<ul>
<li>加密传输中的数据（例如 HTTPS）</li>
<li>加密静态数据（例如手机上存储的数据）</li>
</ul>
<p>作为示例，我们来探讨一下 iPhone 如何使用加密来保证数据安全：</p>
<ol type="1">
<li>iPhone 的内部存储使用一组 AES 密钥进行加密，这些密钥存储在手机内部芯片上，并在工厂生成。</li>
<li>这些密钥又使用您的 PIN 进行加密。 您的 PIN 码允许手机解锁密钥，从而解密文件系统的其余部分。</li>
</ol>
<p>与对称密钥加密不同，公钥加密中有 2 个密钥 ，密码系统由<strong>公钥</strong> 和 <strong>私钥</strong>组成 。 顾名思义， 公钥是公开共享的，这是其他人可以使用的方式 加密适合您的数据。 您使用您的私钥来解密此内容 数据。 只要没有人拥有你的私钥，任何人都可以使用你的公钥 加密数据并确保只有您可以解密它。 这是一个强大的 对称密钥范式的扩展，除了加密之外，它还允许 签名和不可否认性 公钥密码学与 <strong><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA 算法</a></strong> 同义， 是最早经过验证的双密钥方案之一。 <strong>RSA 公钥加密工作原理的简要概述</strong>：</p>
<ol type="1">
<li>RSA算法，通过一些高等数学（涉及素数和模数） 算术），返回 3 个数字：一个公共指数（又名密钥），一个私有指数， 和一个模数。 两个密钥的工作方式使得用一个密钥加密的数据只能 可以用另一个密钥解密。</li>
<li>为了加密数据，需要使用指数和模数之一对数据执行模幂运算。</li>
<li>为了解密数据，对加密数据进行模幂运算 与合作伙伴密钥和模数。 常用时，使用较大的指数 作为私钥，用于解密数据和创建签名， 较小的指数作为公钥，用于加密数据 并验证签名。 比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>
<p>该命令将生成两个文件， <code>~/.ssh/id_rsa</code>和 <code>~/.ssh/id_rsa.pub</code>。 正如命令所示，此命令生成 4096 位 RSA 密钥对。 你 应该能够猜测哪个文件代表公钥以及哪个文件必须 因此是私钥。 为了影响安全 SSH 登录，请使用 RSA密钥，用户必须首先将他们想要使用的公钥传输到 提前向服务器表明自己的身份。 然后，一旦会话结束 服务器和客户端之间建立的，服务器会加密一个随机数 号码与用户的公钥并发送给用户。 用户将 然后使用他们的私钥解密该值并返回该值的哈希值 到服务器，然后服务器可以自己散列该值以确定用户是否 能够成功解密随机数，从而表明拥有 匹配的密钥并作为身份验证的证据。</p>
<h3 id="签名和证书">签名和证书</h3>
<p>一开始，您 将发布 Natoshi 的公钥，此后，对于您发布的每个帖子，您 将使用您（Natoshi）的私钥对消息内容进行加密，并且 将其与您的原始消息一起发布。 那么，想验证的人 Natoshi（即公钥对应的私钥的所有者 属于 Natoshi）实际上确实发布了一条特定的消息，可以简单地 使用 Natoshi 的公钥解密加密签名并比较 内容与原始消息相反。</p>
<p>Natoshi 王位的觊觎者将是 无法签署他们的虚假声明，以便可以与他们核实 Natoshi 公开了公钥，因为他们没有 Natoshi 的私钥， 您可以放心，没有人会过度影响您的项目 当你躲避 IRS 和 DEA 时，除非他们碰巧有 仓库里装满了 ASIC 和大量廉价电力。</p>
<p><strong>然而，在这个方案中，如何防止对手发布虚假信息 公钥并声称是您？</strong> （他们可以对此进行有效签名 假公钥）不知何故，你需要“引导”信任：有人需要 验证您的身份并公开确认您的公钥实际上 对应于你。</p>
<p>我们通过 <strong>证书</strong> 来做到这一点：签署的声明 声称特定的公钥实际上属于它所声称的人 属于。</p>
<p>谁签署此证书？ 一个 <strong>证书颁发机构</strong> ，我们的某人 信任负责验证身份和发布签名。</p>
<p>但是我们如何知道要信任哪些 CA，以及我们如何才能信任声称 真正值得信赖的是？ 他们可能还需要证书。 它 听起来好像一路下来都是海龟； 然而，链条确实结束了 某处：所谓的信任根，根 CA。 这些 CA 的 证书是由浏览器和操作系统预安装的，因此 本质上受信任，无需任何进一步的证书。 如果根 CA 签署您的证书，我们假设他们已经完成了必要的尽职调查 愿意冒着声誉风险签署您的证书，并且基本上 相信他们的话。 这种模型被称为“ <strong>信任网络”</strong> ，是网络如何 今天的安全工作正常进行。</p>
<p>不幸的是，它并不像我们希望的那样可靠： 有些 CA 很卑鄙，只要有足够的钱就会签署任何东西，从而导致有效的 为 microsoft.com 和 github.com 等域颁发的证书 显然不是 Microsoft 或 GitHub 的实体。 <a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/#fn:badwosign">1</a> 此外， 任何拥有足够边境控制的实体都可以强制安装自己的 根证书（例如哈萨克斯坦政府 <a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/#fn:badkazakh">2</a> ) 并截取 通过为任何域颁发自己的伪造证书来窃取任何流量。</p>
<p>您可能没有意识到，但 <strong>您使用并依赖证书和签名 每天。</strong> 每当您在网站地址栏附近看到绿色锁时， 访问，您正在通过 TLS 或 HTTPS 连接访问该网站，并且数据 您和网站之间的传输是加密的。 当你的浏览器 连接到网站的服务器，它会按顺序请求服务器的公钥 设置加密连接和服务器证书以便 验证其作为授权为您拥有的域提供服务的服务器的身份 要求。 然后，您的浏览器通过验证公钥来验证公钥 证书上的签名。 如果有人试图执行 对您进行中间人攻击，此证书验证步骤将失败， 因为受信任的 CA 不太可能颁发签名的证书 将您的域名转让给您以外的实体（除非您不幸 居住在哈萨克斯坦）。 您将收到一条非常侵入性的通知 这个事实，忽略证书验证是一个坏主意 失败通知。</p>
<p><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/">怎么为自己的网站设置https加密传输数据</a> 现在您有了一个网站，您决定，作为一个优秀的互联网公民，您 希望保护您的访客免受政府的窥探，通过 设置 HTTPS。 您已经知道您将需要一个公钥和一个 为此，由受信任的根 CA 签署的证书。 你怎么去 关于得到一个？ 在互联网上搜索，你发现了一个很棒的项目，名为 <a href="https://letsencrypt.org">Let's Encrypt</a> 提供免费、签名的服务 证书。</p>
<h3 id="文件安全">文件安全</h3>
<p><img src="https://www.comentum.com/images/permissions.jpg" /> 作为 <code>root</code>用户。 当程序启动时，它会继承其用户 ID 和组 ID 父进程，并保留它们，除非手动删除权限。 如果你 以 root 用户身份启动程序，因为，例如，它需要更深入的 系统访问，程序中的漏洞意味着攻击者可以 以 root 用户身份与您的计算机进行交互。 这是一个常见问题 错误配置的网络服务器，其中服务器以根目录运行 遍历漏洞可能允许攻击者读取秘密凭证 存储在服务器的文件系统上。</p>
<p>这个故事的寓意与最小特权原则紧密相连：无论在哪里 可能的话，只给予尽可能少的许可或特权。 如果 程序不需要 root 凭据，请勿以特权用户身份运行它。 如果 文件包含敏感内容，请勿使其可读。</p>
<p>如何更改权限？ 有两个主要命令可以执行此操作： <code>chmod</code>和 <code>chown</code>. <code>chmod</code>更改文件模式，即权限，以及 其语法示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -la ~/</span><br><span class="line">drwxr-xr-x 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod 644 test</span><br><span class="line">$ ls -la</span><br><span class="line">drw-r--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod u+x test</span><br><span class="line">drwxr--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod 000 test</span><br><span class="line">d--------- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod +r test</span><br><span class="line">dr--r--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br></pre></td></tr></table></figure>
<p><code>chmod</code>接受八进制表示法的文件权限，即 下列的：</p>
<table>
<thead>
<tr class="header">
<th>#</th>
<th>读写</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7</td>
<td>读写</td>
</tr>
<tr class="even">
<td>6</td>
<td>RW-</td>
</tr>
<tr class="odd">
<td>5</td>
<td>接收</td>
</tr>
<tr class="even">
<td>4</td>
<td>r–</td>
</tr>
<tr class="odd">
<td>3</td>
<td>-wx</td>
</tr>
<tr class="even">
<td>2</td>
<td>-在-</td>
</tr>
<tr class="odd">
<td>1</td>
<td>-X</td>
</tr>
<tr class="even">
<td>0</td>
<td>—</td>
</tr>
</tbody>
</table>
<h1 id="pueept">pueept</h1>
<p>● 流行的配置管理软件 ● 用于配置单个机器 ● 声明性哲学，必要时带有一些命令式组件 ● 最初基于 Ruby 构建，现在拥有自己的配置语言 流程： ● 客户端向服务器请求更新 ○ “我想配置为 Minecraft 服务器” ● 服务器向客户端询问事实列表 ○ “好的，请将您的主机名和 RAM 发送给我” ● 客户用事实回应 ○ “我的主机名是僵尸.ocf.berkeley.edu，我有 4GB RAM” ● 服务器响应配置 ○ “确保 Minecraft 服务器正在运行，主机名为僵尸.ocf.berkeley.edu，4GB RAM， 这个配置文件 ● 客户端进行必要的更改以确保其当前配置与 服务器给出的配置 ○ “minecraft服务器当前正在运行，但配置文件已更新，我将获取 更新后的版本 Puppet是一个配置管理工具,通过Puppet可以实现对大量服务器/主机的集中化、自动化的配置管理。Puppet的工作原理是:</p>
<ol type="1">
<li>在Puppet Master服务器上面编写Puppet Manifests(配置文件)。这些文件使用Puppet语言定义了服务器的最终状态。</li>
<li>Puppet Agent安装在被管理的主机上面,它会定期从Puppet Master拉取配置。</li>
<li>Puppet Agent对本地服务器状态进行检查,然后根据Manifests对服务器进行配置,确保服务器状态与预期状态一致。</li>
<li>如果配置发生变化,Puppet会自动应用这些变化,无需手动操作。</li>
<li>Puppet Agent会定期运行,如果配置失效会再次修正。所以Puppet脚本就是编写Puppet Manifests的文件,它定义了需要配置什么,怎么配置。常见的配置包括:- 安装软件</li>
</ol>
<ul>
<li>管理服务<br />
</li>
<li>配置文件内容<br />
</li>
<li>用户和权限<br />
</li>
<li>安全设置<br />
</li>
<li>定时任务 等等通过Puppet脚本可以实现服务器配置的版本控制、自动化部署,大幅减少管理时间成本。它适用于需要管理大量Linux/Unix主机的场景。</li>
</ul>
<h1 id="git">git</h1>
<p>创建一个分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b dice</span><br></pre></td></tr></table></figure>
<p>这使得一个新的本地分支称为 <code>dice</code>基于我们所在的分支机构 目前在（ <code>master</code>）并将您切换到 <code>dice</code>分支。 这个命令是 基本上简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch dice       # Create new branch called &#x27;dice&#x27;</span><br><span class="line">git checkout dice     # Switch to branch called &#x27;dice&#x27;</span><br></pre></td></tr></table></figure>
<p>您可以通过键入来查看您创建的分支 <code>git branch</code>。 你应该看到 此时有两个分支，一个称为 <code>master</code>和一个叫 <code>dice</code>。 一个 星号位于您当前签出的分支旁边。 <code>git log</code>查看历史提交。 每个提交都有一些信息，例如提交的作者、 创建提交的时间戳和提交消息。</p>
<ul>
<li><p>每个提交条目的第一行都有一个长的十六进制字符串。 这是 commit <em>hash</em> ：将其视为可用于引用的唯一 ID 具体提交。</p></li>
<li><p>有些提交在提交哈希旁边的括号中包含分支信息， 表明它们是最近的提交或 <code>HEAD</code>那个分支的。 你的 最近的提交应该有类似的内容 <code>(HEAD -&gt; dice)</code>。 第四个 提交应该有 <code>(origin/master, origin/HEAD)</code>因为我们的分支机构 关闭 <code>master</code>并在其之上添加了三个新的提交。 请注意，如果 有人向本地或远程添加新提交 <code>master</code>， 分支 信息可能会更改或过时。</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit adc45cd5110b59f76cefc2b862d0e4d550ccb183 (HEAD -&gt; dice)</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:32:35 2023 +0800</span><br><span class="line"></span><br><span class="line">    Restrict input range for dice iterations and sides</span><br><span class="line"></span><br><span class="line">commit a79a770157449a9d2fb1595a0b83ecc99070eabf</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:31:56 2023 +0800</span><br><span class="line"></span><br><span class="line">    Add dice rolling logic and output dice sum and sequence</span><br><span class="line"></span><br><span class="line">commit 924d0b1ebf050a043da434114187a290280ec660</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:30:45 2023 +0800</span><br><span class="line"></span><br><span class="line">    Add -s flag for number of sides on a die</span><br><span class="line"></span><br><span class="line">commit 3acb62af3eff4a1dbbe875e81ec1485d9d10c44b (origin/master, origin/HEAD, master)</span><br><span class="line">Merge: 4e2aac7 2aefa6c</span><br><span class="line">Author: Ishaan Dham &lt;56564174+Ishaandham19@users.noreply.github.com&gt;</span><br><span class="line">Date:   Tue Mar 21 21:39:51 2023 -0700</span><br><span class="line"></span><br><span class="line">    Merge pull request #34 from 0xcf/demo</span><br><span class="line"></span><br><span class="line">    Demo</span><br><span class="line"></span><br><span class="line">commit 2aefa6c51449ffcd39d945e3d74ce2b5e50acf7f (origin/demo)</span><br><span class="line">Author: Ishaan Dham &lt;ishaandham01@gmail.com&gt;</span><br></pre></td></tr></table></figure>
<p>除了查看提交历史记录之外，您可能还想查看实际的更改 在代码中。 您可以使用 <code>git diff &lt;old commit&gt; &lt;new commit&gt;</code>查看 两次提交之间的差异。</p>
<p>除了查看提交历史记录之外，您可能还想查看实际的更改 在代码中。 您可以使用 <code>git diff &lt;old commit&gt; &lt;new commit&gt;</code>查看 两次提交之间的差异。 有几种不同的方式可以引用 一次提交。 之前提到的一个是复制提交的哈希值（请注意 您的提交哈希值将与下面的示例不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff 3368313c0afb6e306133d604ca72b0287124e8f2 762053064506810dee895219e5b2c2747a202829</span><br></pre></td></tr></table></figure>
<p>您还可以复制提交哈希开头的一小块，而不是 整个哈希。 由于哈希的工作方式，您不太可能 有两个具有完全相同的起始序列的提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff 3368313 7620530</span><br></pre></td></tr></table></figure>
<p>如果你想尝试 <code>diff</code>两个提交非常接近 日志，一种更简单的方法是通过距提交的距离来引用提交 <code>HEAD</code> （最近）使用以下格式提交 <code>HEAD~&lt;number&gt;</code>。 由于我们添加了三个 提交新的提交 <code>dice</code>，我们可以查看之间的差异 <code>dice</code>和 <code>master</code>使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff HEAD~3 HEAD</span><br></pre></td></tr></table></figure>
<p>有多种方法可以处理合并冲突，但我们将采用的方法 在这个实验室中向您展示正在使用 <code>git rebase</code>。 我们的 <code>dice</code>分支是“基于” 这 <code>master</code>在某个时间点有分支，但是 <code>master</code>分行有 向前离开 <code>dice</code>基于过时的 <code>master</code>。 因此，我们想要 “重新基地” <code>dice</code>就目前的状态而言 <code>master</code>。 当你的 <code>dice</code>分支， 跑步 <code>git rebase master</code>。 Git 将回滚您所做的提交 <code>dice</code>， 复制 任何新的提交 <code>master</code>，并尝试在顶部重放您的提交。 有时 <code>rebase</code>无需您的干预即可运行完成，但是如果 存在合并冲突，您需要解决它。</p>
<p>Git 会告诉你如果遇到合并冲突该怎么办 在变基期间。 在这种情况下，打开 <code>rand.py</code>并找到冲突区域 应具有以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Lines of code from the base branch (in this case master)</span><br><span class="line">=======</span><br><span class="line">Lines of code from the branch you&#x27;re rebasing (in this case dice)</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Commit message of the commit that conflicts with the base branch</span><br></pre></td></tr></table></figure>
<p>要解决冲突，只需保留您想要的行（您的行来自 <code>dice</code>） 和 删除冲突区域中的其他行（</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD`, `=======`, `&gt;&gt;&gt;&gt;&gt;&gt;&gt; dice`</span><br></pre></td></tr></table></figure>
<p>，以及来自 master 的不需要的代码），然后保存并退出 文件。 Git 会将您保存的内容作为文件的确切形式 看起来像在变基结束时，所以你所做的本质上是修复 文件，以便代码正常运行。 这意味着如果您有多个 合并冲突，您决定混合保留基础分支中的一些行 还有一些来自您的功能分支，您需要确保代码确实有效 正确。</p>
<p>现在您已经解决了合并冲突，请按照变基说明进行操作 暂存您的固定文件（ <code>git add rand.py</code>），然后运行 <code>git rebase --continue</code>。 如果 Git 发现其他文件有更多合并冲突，您将遵循相同的操作 程序如上。 然而，我们只有一个有冲突的文件，所以我们的变基是 完成的！ 跑步 <code>git log</code>查看我们 rebase 的结果。 你现在应该看到了 你想象中的队友 <code>"dice rolling WIP"</code>提交您分支的历史记录， 你的提交高于他们的提交。</p>
<h1 id="docker">docker</h1>
<p><a href="https://docs.docker.com/v17.09/engine/installation/linux/docker-ce/ubuntu/">安装 Docker</a> wsl2不支持systemctl命令，而是支持systemed命令 所以需要执行如下命令启动docker</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">service docker <span class="keyword">start</span></span><br></pre></td></tr></table></figure>
<p><code>虚拟机</code> 你的电脑里有一台电脑！ ● 通过软件模拟抽象物理硬件 ● 虚拟机管理程序运行多个虚拟机 ● 隔离应用：更好的安全性、稳定性 ● 一些开销：需要不同的客户操作系统和模拟 每个应用程序的虚拟硬件数量 ● 需要一些时间来启动</p>
<p><code>容器</code> ● 通常与虚拟机进行比较，但更像是捆绑的进程 环境 ● 提供类似的隔离 ○ 然而，比虚拟机要少得多！ 出于这个原因，我们仍然经常在虚拟机内运行容器（但是 每个虚拟机可以运行 &gt;1 个容器） ● 启动速度比虚拟机快得多 ● 目标是通过共享代码提供轻量级隔离环境 ● 轻松打包应用程序以实现一致的部署 ● 常见的容器：Docker、rkt、LXC ● 很确定这是加州大学伯克利分校唯一使用的课程</p>
<table>
<thead>
<tr class="header">
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>docker search</td>
<td>Search Docker Hub for pre-built images</td>
</tr>
<tr class="even">
<td>docker pull</td>
<td>Pull an image or a repository from a registry</td>
</tr>
<tr class="odd">
<td>docker images</td>
<td>List images</td>
</tr>
<tr class="even">
<td>docker build</td>
<td>Build an image from a Dockerfile</td>
</tr>
<tr class="odd">
<td>docker run</td>
<td>Run a command in a new container</td>
</tr>
<tr class="even">
<td>docker ps</td>
<td>List containers</td>
</tr>
<tr class="odd">
<td>docker start/stop/restart</td>
<td>Start/stop/restart a container</td>
</tr>
<tr class="even">
<td>docker exec</td>
<td>Run a command in a running container</td>
</tr>
<tr class="odd">
<td>docker inspect</td>
<td>Return low-level information on Docker objects</td>
</tr>
<tr class="even">
<td>docker rm</td>
<td>Remove one or more containers</td>
</tr>
<tr class="odd">
<td>docker rmi</td>
<td>Remove one or more images</td>
</tr>
</tbody>
</table>
<p><code>docker</code> ● 需要构建镜像 ● 通常使用 Dockerfile 来指定 如何构建快照 ● 快照是分层构建的 ○ 像洋葱一样 ○ 允许基于相同的快照层构建速度更快 ● 保持每一层最少化资源</p>
<p>自动化配置管理工具 ● 声明式：说出你想要什么，而不是如何做 ○ 应用程序弄清楚如何 ● 可以定义要安装的应用程序、要包含的文件等 ● 可以在不同“类别”的机器上安装不同的东西 （桌面与服务器） ● 常用工具：Puppet、Ansible、Chef</p>
<h2 id="docker的使用">docker的使用</h2>
<p><code>docker run hello-world</code></p>
<p>您应该看到一些友好的输出，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete </span><br><span class="line">Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此消息表明您的安装似乎运行正常。 为了生成此消息，Docker 采取了以下步骤：</p>
<ol type="1">
<li>Docker 客户端联系了 Docker 守护进程。</li>
<li>Docker 守护进程从 Docker Hub 中提取“hello-world”镜像。</li>
<li>Docker 守护进程从该映像创建了一个新容器，该容器运行生成您当前正在读取的输出的可执行文件。</li>
<li>Docker 守护进程将该输出传输到 Docker 客户端，然后将其发送到您的终端。 在容器中默认以<code>root</code>用户身份登录。</li>
</ol>
<p>以交互方式运行容器。 如果您需要在裸系统上尝试和安装东西而不弄乱当前系统，那么这非常有用。 尝试运行以下命令：</p>
<p><code>docker run -it ubuntu:latest</code></p>
<p>这 <code>-i</code>flag 告诉 docker 保留 <code>STDIN</code>打开你的容器，然后 <code>-t</code>分配一个 <a href="https://en.wikipedia.org/wiki/Pseudoterminal">伪 TTY</a> flag为您 。 基本上，您需要两者才能在新启动的容器中拥有一个 shell。 尝试安装一些软件包 <code>apt</code>或者只是玩玩。 它看起来应该像一个裸露的 Linux 系统。</p>
<p>使用 CTRL+D 退出容器。 自然的问题是，Docker 镜像是如何构建的？ Dockerfile <strong>。</strong> 就像镜像的源代码 相反，Dockerfile允许您通过指定手动键入创建镜像的所有命令来定义镜像。 然后 Docker 可以从指定Dockerfile 构建镜像。 这些 Dockerfile 可以放入版本控制中，并将镜像上传到在线存储库。</p>
<p>Docker可以通过读取来自<code>Dockerfile</code>的指令来自动构建镜像 。 <code>Dockerfile</code>是一个文本文档，其中包含所有命令 用户可以在命令行上调用来构建镜像。 eg.下面是一个 <strong>Dockerfile</strong> ，通过将 Python 3 和软件包安装到基础 Fedora Linux 映像上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Specify Fedora Linux as base image</span><br><span class="line">FROM fedora:latest</span><br><span class="line"></span><br><span class="line"># Install Python with yum (Fedora&#x27;s Package Manager)</span><br><span class="line"># Install required Python packages</span><br><span class="line">RUN yum update -y &amp;&amp; yum install -y python3 python3-pip &amp;&amp; \</span><br><span class="line">    python3 -m pip install pyfiglet termcolor</span><br><span class="line"> </span><br><span class="line"># Add the missile.py file to the final image</span><br><span class="line">ADD missile.py /</span><br><span class="line"></span><br><span class="line"># Specify the command to be run on container creation</span><br><span class="line">CMD [&quot;/usr/bin/python3&quot;, &quot;missile.py&quot;]</span><br></pre></td></tr></table></figure>
<p><code>docker build -t missile:latest .</code></p>
<p>这告诉 Docker 在当前目录中查找 <code>Dockerfile</code>，并用该文件构建一个镜像。 这 <code>-t</code>flag 告诉 Docker 使用名称标记此构建 <code>missile:latest</code>。</p>
<p>查看系统上正在运行的容器。 使用以下命令：</p>
<p><code>docker ps</code></p>
<p>由于您（可能）没有运行任何容器，因此您可能不会看到任何有趣的东西。 但是，如果您传入 <code>-a</code>标志，您还可以看到已停止的容器：</p>
<p>要获取有关容器的更多信息，您可以使用 <code>docker logs</code>命令 获取容器的日志（无论它仍在运行还是已退出）：</p>
<p><code>docker logs &lt;container_id_or_name&gt;</code></p>
<p>在某些时候，您可能想要清理已退出且不打算再使用的容器：</p>
<p><code>docker rm &lt;container_id_or_name&gt;</code></p>
<p>将移除容器。</p>
<p>查看已经下载的镜像: <code>docker images</code> 图像可能会占用计算机上相当多的空间，因此您可能需要清理不打算使用的图像 使用。 如果您收到有关计算机上没有足够磁盘空间的错误，这一点尤其重要：</p>
<p><code>docker rmi &lt;image_id&gt;</code></p>
<p>镜像文件以及容器的各种文件系统都存储在 <code>/var/lib/docker</code></p>
<h3 id="分离容器">分离容器</h3>
<p>容器可以以后台服务的形式运行，这适用于一些后台服务的场合，Docker 支持这种方式 以 <code>-d</code>标志，见 <a href="https://docs.docker.com/engine/reference/run/#detached--d">分离 方式启动容器 模式</a></p>
<p>Docker 为容器创建一个单独的虚拟网络，因此您需要将主机端口转发到您的 容器的端口（这称为 <a href="https://en.wikipedia.org/wiki/Port_forwarding">端口转发</a> 或端口映射）。 容器正在侦听端口 80，因此让我们尝试将主机的端口 5050 转发到容器的端口 ：</p>
<p><code>docker run -d -p=5050:80 httpd</code></p>
<p><code>-p</code> 接受冒号分隔的一对 <code>HOST_PORT:CONTAINER_PORT</code></p>
<p>您实际上可以“附加”到正在运行的容器并在其中运行更多命令，类似于 <code>docker run</code>作品。 使用 这 <code>docker exec</code>命令：</p>
<p><code>docker exec &lt;container_id_or_name&gt; &lt;command&gt;</code></p>
<p>要停止此容器，请使用 <code>docker stop &lt;container_id_or_name&gt;</code>.</p>
<p>您可以使用以下命令重新启动容器 <code>docker restart &lt;container_id_or_name&gt;</code>.</p>
<h3 id="关于-docker-compose">关于 docker-compose</h3>
<p><code>docker-compose</code>允许您定义需要多个容器才能运行的应用程序。 例如，在网络上 应用程序，您可能希望实际的 Web 应用程序在单个容器内运行，并且数据库在其中运行 一个不同的容器。</p>
<p>通常，您根据 <strong>服务</strong> 来定义应用程序。 同样，以 Web 应用程序为例，有 两个不同的服务：应用程序本身和支持它的数据库。 <code>docker-compose</code>让您定义不同的服务 在 <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> 文件中并相应地运行服务。</p>
<p>其中一件好事是 <code>docker-compose</code>是它会自动为您的容器设置一个网络，其中：</p>
<ul>
<li>服务的每个容器都位于网络上，并且可以从网络上的其他容器访问</li>
<li>每个容器都可以通过其容器名称在网络上发现</li>
</ul>
<p>使用 <a href="https://docs.docker.com/compose/install/">Docker 官方网站上的说明安装 Docker Compose</a></p>
<h1 id="一些小脚本">一些小脚本</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">PHONEBOOK_ENTRIES=&quot;phonelist.txt&quot;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">if [ &quot;$#&quot; -lt 1 ]; then</span><br><span class="line"></span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;new&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    echo $2 $3 &gt;&gt; phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;list&quot; ]; then</span><br><span class="line"></span><br><span class="line">    if [ ! -e $PHONEBOOK_ENTRIES ] || [ ! -s $PHONEBOOK_ENTRIES ]; then</span><br><span class="line"></span><br><span class="line">        echo &quot;phonebook is empty&quot;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">        # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">        cat phonelist.txt</span><br><span class="line"></span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;lookup&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    grep $2 phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;remove&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    sed -i &quot;s/$2//g&quot; phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;clear&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    rm phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">     # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">     echo nothing</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">host=$1</span><br><span class="line"></span><br><span class="line">ping -c 1 $host &gt;&gt; log.txt</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;OK&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">    echo &quot;can&#x27;t access&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1/bin/bash</span><br><span class="line"></span><br><span class="line">ip addr show | grep &quot;link/ether&quot; | head -n 1 | cut -d&#x27; &#x27; -f 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>linux</tag>
        <tag>系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利cs61b的java数据结构笔记</title>
    <url>/2023/10/06/61b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="ppt部分">ppt部分</h1>
<h2 id="java基础">java基础</h2>
<p>类内static方法可以被类名调用，对象定义方法只有对象能调用 当类不独立时，嵌套类很有用,并且显然隶属于另一个类。</p>
<ul>
<li>如果其他类不应该使用嵌套类，则将嵌套类设为私有类 <img src="/assets/61b总和笔记/image-20230920083903996.png" alt="img" /> <span id="more"></span></li>
</ul>
<p>接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface List61B&lt;Item&gt; &#123;</span><br><span class="line">public void addFirst(Item x);</span><br><span class="line">public void addLast(Item y);</span><br><span class="line">public Item getFirst();</span><br><span class="line">public Item getLast();</span><br><span class="line">public Item removeLast();</span><br><span class="line">public Item get(int i);</span><br><span class="line">public void insert(Item x, int position);</span><br><span class="line">public int size();</span><br><span class="line">&#125;</span><br><span class="line">public static String longest(List61B&lt;String&gt; list) &#123;</span><br><span class="line">int maxDex = 0;</span><br><span class="line">for (int i = 0; i &lt; list.size(); i += 1) &#123;</span><br><span class="line">String longestString = list.get(maxDex);</span><br><span class="line">String thisString = list.get(i);</span><br><span class="line">if (thisString.length() &gt; longestString.length()) &#123;</span><br><span class="line">maxDex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list.get(maxDex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>override重写：特征值不变，子类重写父类 overload重载：特征值改变 Java 有 8 种基本类型。 所有其他类型都是引用类型。 对于每个基本类型，都有一个相应的引用类型，称为 包装类。</p>
<ul>
<li>例如，boolean的包装类是Boolean。 基本类型不能用在模板上，包装类可以</li>
<li>如果 Java 代码需要包装类型并获取原语，则会自动装箱。</li>
<li>如果代码需要一个原语并获得一个包装器，则它会被拆箱。</li>
<li>数组永远不会自动装箱/拆箱，例如 Integer[] 不能用于 int[] 的位置（反之亦然）。</li>
<li>自动装箱/拆箱会对性能产生可衡量的影响！</li>
<li>包装类型比原始类型使用更多的内存。 public final ArrayDeque&lt;String&gt; d = new ArrayDeque&lt;String&gt;();</li>
<li>The d variable can never change, but the referenced deque can Arrays are covariant:</li>
<li>A FrenchDog is-a Dog.</li>
<li>An FrenchDog[] is-a Dog[]. Generic types are invariant:</li>
<li>A List&lt;FrenchDog&gt; is NOT a List&lt;Dog&gt;.</li>
</ul>
<h3 id="java实现链表">java实现链表</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">public class LinkedListDeque&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public class Node &#123;</span><br><span class="line"></span><br><span class="line">        Node next,prev=null;</span><br><span class="line"></span><br><span class="line">        T value;</span><br><span class="line"></span><br><span class="line">        public Node(T val) &#123;</span><br><span class="line"></span><br><span class="line">            value=val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size=0;</span><br><span class="line"></span><br><span class="line">    Node firstnode = new Node();</span><br><span class="line"></span><br><span class="line">    public LinkedListDeque() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line"></span><br><span class="line">        return Objects.equals(size,0);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addFirst(T item) &#123;</span><br><span class="line"></span><br><span class="line">        Node new_node=new Node(item);</span><br><span class="line"></span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            firstnode.next=firstnode.prev=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.next=new_node.prev=firstnode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            firstnode.next.prev=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.next=firstnode.next;</span><br><span class="line"></span><br><span class="line">            firstnode.next=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.prev=firstnode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addLast(T item) &#123;</span><br><span class="line"></span><br><span class="line">        Node new_node=new Node(item);</span><br><span class="line"></span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            firstnode.next=firstnode.prev=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.next=new_node.prev=firstnode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            new_node.prev=firstnode.prev;</span><br><span class="line"></span><br><span class="line">            firstnode.prev.next=new_node;</span><br><span class="line"></span><br><span class="line">            firstnode.prev=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.next=firstnode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line"></span><br><span class="line">        return size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printDeque() &#123;</span><br><span class="line"></span><br><span class="line">        Node temp=firstnode.next;</span><br><span class="line"></span><br><span class="line">        while (temp!= firstnode) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(temp.value);</span><br><span class="line"></span><br><span class="line">            temp=temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T removeFirst() &#123;</span><br><span class="line"></span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (size()==1) &#123;</span><br><span class="line"></span><br><span class="line">            T val=firstnode.next.value;</span><br><span class="line"></span><br><span class="line">            firstnode.prev=firstnode.next=null;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            return val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            T val= firstnode.next.value;</span><br><span class="line"></span><br><span class="line">            firstnode.next.next.prev=firstnode;</span><br><span class="line"></span><br><span class="line">            firstnode.next=firstnode.next.next;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            return val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T removeLast() &#123;</span><br><span class="line"></span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        else if (size()==1) &#123;</span><br><span class="line"></span><br><span class="line">            T val;</span><br><span class="line"></span><br><span class="line">            val=firstnode.next.value;</span><br><span class="line"></span><br><span class="line">            firstnode.prev=firstnode.next=null;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            return val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            T val;</span><br><span class="line"></span><br><span class="line">            val=firstnode.prev.value;</span><br><span class="line"></span><br><span class="line">            firstnode.prev.prev.next=firstnode;</span><br><span class="line"></span><br><span class="line">            firstnode.prev=firstnode.prev.prev;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            return val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T get(int index) &#123;</span><br><span class="line"></span><br><span class="line">        if (index&gt;size()-1) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            Node temp = firstnode;</span><br><span class="line"></span><br><span class="line">            for (int i=0;i&lt;index;i++) &#123;</span><br><span class="line"></span><br><span class="line">                temp=temp.next;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return temp.value;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java单元测试">java单元测试</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@test</span><br><span class="line">public void testMethod() &#123;</span><br><span class="line">    assertEquals(&lt;expected&gt;, &lt;actual&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 JUnit 测试文件时，应在每个测试方法前面加上 <code>@Test</code>注解，并且可以有一个或多个 <code>assertEquals</code>或者 <code>assertTrue</code>方法（由 JUnit 库提供）。 <strong>所有测试必须是非静态的。</strong> 这可能看起来很奇怪，因为您的测试不使用实例变量并且您 可能不会实例化该类。 然而，设计师们却是这样的 JUnit 决定应该编写测试，所以我们就这么做。</p>
<h3 id="权限控制">权限控制</h3>
<p><img src="/assets/61b总和笔记/image-20230920090532017.png" /></p>
<h2 id="bst-in-java">BST IN JAVA</h2>
<p><img src="/assets/61b总和笔记/image-20230920081714565.png" /> 表示连接的数组：若数字相同则这些节点互相可达 <img src="/assets/61b总和笔记/image-20230920081830858.png" /> 增加父节点后形成bst</p>
<h2 id="加权bst">加权bst</h2>
<p><img src="/assets/61b总和笔记/image-20230920082840743.png" /> 维护一个size数组，只能将较小的树加到较大的树上 <img src="/assets/61b总和笔记/image-20230920083245937.png" /></p>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WeightedQuickUnionDSWithPathCompression implements DisjointSets &#123;</span><br><span class="line">private int[] parent; private int[] size;</span><br><span class="line">public WeightedQuickUnionDSWithPathCompression(int N) &#123;</span><br><span class="line">parent = new int[N]; size = new int[N];</span><br><span class="line">for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">parent[i] = i;</span><br><span class="line">size[i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private int find(int p) &#123;</span><br><span class="line">if (p == parent[p]) &#123;</span><br><span class="line">return p;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">parent[p] = find(parent[p]);</span><br><span class="line">return parent[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean isConnected(int p, int q) &#123;</span><br><span class="line">return find(p) == find(q);</span><br><span class="line">&#125;</span><br><span class="line">public void connect(int p, int q) &#123;</span><br><span class="line">int i = find(p);</span><br><span class="line">int j = find(q);</span><br><span class="line">if (i == j) return;</span><br><span class="line">if (size[i] &lt; size[j]) &#123;</span><br><span class="line">parent[i] = j; size[j] += size[i];</span><br><span class="line">&#125; </span><br><span class="line">else &#123;</span><br><span class="line">parent[j] = i; size[i] += size[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的旋转">树的旋转</h3>
<p><img src="/assets/61b总和笔记/image-20230920093054610.png" /> 右旋同理</p>
<h3 id="如果叶节点有最大负载限制">如果叶节点有最大负载限制</h3>
<p><img src="/assets/61b总和笔记/image-20230920175806667.png" /> 分裂树(B树)具有完美的平衡。</p>
<ul>
<li>如果我们分裂根，每个节点都会被下推一层。</li>
<li>如果我们分割叶节点或内部节点，高度不会改变 所有操作Θ(log N)</li>
</ul>
<h3 id="红黑树">红黑树</h3>
<p>任何与 2-3 树保持等距的 BST 都具有以下属性：</p>
<ul>
<li>没有节点有两个红色链接（否则它就像一个 4 节点）。</li>
<li>从根到叶子的每条路径都有相同数量的黑色链接。</li>
<li>红色链接向左倾斜。</li>
<li>也称为“左倾红黑二叉搜索树（LLRB） <img src="/assets/61b总和笔记/image-20230920180350334.png" /></li>
</ul>
<h2 id="hash">hash</h2>
<p>如果 N 个项目分布在 M 个桶中，则平均时间取决于 N/M = L，也称为 负载系数 . ○ 平均运行时间为 Θ (L)。 <img src="/assets/61b总和笔记/image-20230920222654955.png" /></p>
<h2 id="最小堆">最小堆</h2>
<p>二叉最小堆：二叉树完整，并服从 最小堆属性 .</p>
<ul>
<li>最小堆：每个节点都小于或等于其两个子节点。</li>
<li>完整：仅在底层（如果有）缺少项目，所有节点都尽可能远 尽可能左。 <img src="/assets/61b总和笔记/image-20230921103325455.png" /></li>
</ul>
<h3 id="遍历">遍历</h3>
<ul>
<li>节点遍历：前中后序</li>
<li>层次遍历 实现指针接口——使用栈 <img src="/assets/61b总和笔记/image-20230921112835278.png" /> 两个类的equals实现，如果是哈希，一般需要同时确保hashcode方法对内容相同的类返回相同的哈希码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object o) &#123;  </span><br><span class="line">    if (o==this) return true;  </span><br><span class="line">    if (o==null) return false;  </span><br><span class="line">    if (o.getClass()!=this.getClass()) return false;  </span><br><span class="line">    SimpleOomage new_o=(SimpleOomage) o;  </span><br><span class="line">    return new_o.blue==this.blue &amp;&amp;new_o.red==this.red &amp;&amp; new_o.green==this.green;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图论">图论</h2>
<h3 id="迪杰斯特拉">迪杰斯特拉</h3>
<p><a href="https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&amp;loop=false&amp;delayms=3000#slide=id.g771336078_0_180">演示</a> <img src="/assets/61b总和笔记/image-20230923101738378.png" /> <img src="/assets/61b总和笔记/image-20230923101849254.png" /> <a href="https://algs4.cs.princeton.edu/44sp/DijkstraSP.java.html">伯克利实现</a></p>
<h3 id="最小生成树mst">最小生成树（MST)</h3>
<p>最短路径树取决于起始顶点：</p>
<ul>
<li>因为它告诉你如何从源头到达一切。 MST 没有来源。 尽管如此，MST 有时恰好是特定顶点的 SPT</li>
</ul>
<h2 id="排序">排序</h2>
<p><code>稳定性</code>：如果保留等价项的顺序，则称排序是稳定的。</p>
<ul>
<li>选择排序：找到最小的项并将其放在前面。</li>
<li>插入排序：找出当前项插入的位置。</li>
<li>归并排序：将两个已排序的半部分合并为一个已排序的整体。</li>
<li>分区（快速）排序：围绕枢轴对项目进行分区。 <img src="/assets/61b总和笔记/image-20231006205748498.png" /></li>
</ul>
<h3 id="快速排序">快速排序</h3>
<p><a href="https://docs.google.com/presentation/d/1DOnWS59PJOa-LaBfttPRseIpwLGefZkn450TMSSUiQY/pub?start=false&amp;loop=false&amp;delayms=3000#slide=id.g12b16fb6b6_0_2">演示</a> 不严谨地证明快排性能 <img src="/assets/61b总和笔记/image-20231006204101527.png" /> <code>Quicksort is BST Sort</code> <img src="/assets/61b总和笔记/image-20231006204242323.png" /></p>
<h3 id="优化">优化</h3>
<ul>
<li>切换到插入排序:- 当子问题大小减小到15或更小时,使用插入排序。</li>
<li>使排序自适应:<strong>利用数组中已有的顺序</strong>(插入排序,平滑排序,TimSort(Python和Java中的排序))。</li>
<li>利用键集的限制。如果键的个数是某个常数,例如[3, 4, 1, 2, 4, 3, ..., 2, 2, 2, 1, 4, 3, 2, 3],可以更快排序(参见三路快速排序,如果你好奇可以看这里:<a href="http://goo.gl/3sYnv3">http://goo.gl/3sYnv3</a>)。</li>
<li>对于快速排序:使算法具有自我检查能力,如果递归太深则切换到不同的排序方法。这只是确定性快速排序的问题。</li>
</ul>
<p>在 Java 中，Arrays.sort(someArray) 使用：</p>
<ul>
<li>合并排序（特别是 TimSort 变体）如果 someArray 包含 对象。</li>
<li>如果 someArray 由基本类型组成，则进行快速排序。</li>
</ul>
<h3 id="证明">证明</h3>
<ol type="1">
<li>We have that N! &gt; (N/2) N/2</li>
</ol>
<ul>
<li>Taking the log of both sides, we have that log(N!) &gt; log((N/2) N/2 ).</li>
<li>Bringing down the exponent we have that log(N!) &gt; N/2 log(N/2).</li>
<li>Discarding the unnecessary constant, we have log(N!) ∈ Ω(N log (N/2)).</li>
<li>From there, we have that log(N!) ∈ Ω(N log N).</li>
</ul>
<ol start="2" type="1">
<li><ul>
<li>log(N!) = log(N) + log(N-1) + log(N-2) + …. + log(1)</li>
</ul></li>
</ol>
<ul>
<li>N log N = log(N) + log(N) + log(N) + … log(N)</li>
<li>Therefore N log N ∈ Ω(log(N!)) 结论：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N log N ∈ Θ(log N!)</span><br><span class="line">log N! ∈ Θ(N log N)</span><br></pre></td></tr></table></figure>
<p>比较排序中：</p>
<ul>
<li>Decision tree needs N! leaves.</li>
<li>So we need lg(N!) rounded up levels, which is Ω(log(N!))</li>
</ul>
<h2 id="数据集">数据集</h2>
<h3 id="digit-by-digit">Digit-by-Digit</h3>
<p><a href="https://www.cs.princeton.edu/courses/archive/spring15/cos226/demo/52DemoTrie.mov">演示</a> Given a Trie with N keys, and a key with L digits. What is the:</p>
<ul>
<li>Worst case insert runtime? Θ(L)</li>
<li>Worst case search runtime? Θ(L)</li>
<li>Best case search runtime? Θ(1)</li>
</ul>
<p><img src="/assets/61b总和笔记/image-20231006215117117.png" /> <img src="/assets/61b总和笔记/image-20231006215302639.png" /> 优化:</p>
<ul>
<li>Data-indexed array: Max speed, max memory.</li>
<li>TreeMap/HashMap: Slower query performance, but less memory wasted. <img src="/assets/61b总和笔记/image-20231006215646467.png" /> <img src="/assets/61b总和笔记/image-20231006215851901.png" /></li>
</ul>
<h4 id="三元搜索">三元搜索</h4>
<p><a href="https://algs4.cs.princeton.edu/52trie/TST.java.html">实现</a></p>
<ul>
<li>为每个节点分配一个字符。</li>
<li>给每个节点 3 个链接： ○ 如果键的下一个字符 &lt; 节点的字符，则左链接。 ○ 如果键的下一个字符 == 节点的字符，则中间链接。 ○ 如果键的下一个字符 &gt; 节点的字符，则右链接。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TST&lt;Value&gt; &#123;</span><br><span class="line">    private int n;              // size</span><br><span class="line">    private Node&lt;Value&gt; root;   // root of TST</span><br><span class="line"></span><br><span class="line">    private static class Node&lt;Value&gt; &#123;</span><br><span class="line">        private char c;                        // character</span><br><span class="line">        private Node&lt;Value&gt; left, mid, right;  // left, middle, and right subtries</span><br><span class="line">        private Value val;                     // value associated with string</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th>平均复杂度</th>
<th>最坏情况</th>
<th>最好情况</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>哈希表</td>
<td>Θ(L)*</td>
<td></td>
<td> </td>
<td>Θ(NL)</td>
</tr>
<tr class="even">
<td>二叉搜索树</td>
<td></td>
<td>Θ(L log N)</td>
<td>Θ(1)</td>
<td>Θ(NL)</td>
</tr>
<tr class="odd">
<td>Trie (数组)</td>
<td></td>
<td>Θ(L)</td>
<td>Θ(1)</td>
<td>Θ(NLR)</td>
</tr>
<tr class="even">
<td>Trie (哈希表)</td>
<td></td>
<td>Θ(L)</td>
<td>Θ(1)</td>
<td>Θ(NL)</td>
</tr>
<tr class="odd">
<td>Trie (树)</td>
<td></td>
<td>Θ(L log R)</td>
<td>Θ(1)</td>
<td>Θ(NL)</td>
</tr>
<tr class="even">
<td>TST</td>
<td></td>
<td>Θ(NL)</td>
<td>Θ(1)</td>
<td>Θ(NL)</td>
</tr>
</tbody>
</table>
<p><strong>N keys, L digits per key, R alphabet size. A miss means the key isn’t present.</strong></p>
<h2 id="编码和压缩">编码和压缩</h2>
<p>A prefix-free code is one in which no codeword is a prefix of any other. Example for English:</p>
<table>
<thead>
<tr class="header">
<th>字符</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>space</td>
<td>111</td>
</tr>
<tr class="even">
<td>E</td>
<td>010</td>
</tr>
<tr class="odd">
<td>T</td>
<td>1101</td>
</tr>
<tr class="even">
<td>A</td>
<td>1011</td>
</tr>
<tr class="odd">
<td>O</td>
<td>1001</td>
</tr>
<tr class="even">
<td>I</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>I ATE: 100011110111101010</p>
<h3 id="shannon-fano编码">Shannon-Fano编码</h3>
<ul>
<li>Count relative frequencies of all characters in a text.</li>
<li>Split into ‘left’ and ‘right halves’ of roughly equal frequency. ○ Left half gets a leading zero. Right half gets a leading one. ○ Repeat.</li>
</ul>
<h3 id="huffman编码">Huffman编码</h3>
<ul>
<li>Assign each symbol to a node with weight = relative frequency.</li>
<li>Take the two smallest nodes and merge them into a super node with weight equal to sum of weights.</li>
<li>Repeat until everything is part of a tree.</li>
<li>将每个符号分配给一个节点，权重=相对频率。</li>
<li>取两个最小的节点，合并成一个带权重的超级节点 等于权重之和。</li>
<li>重复直到所有东西都是树的一部分。</li>
</ul>
<h3 id="霍夫曼压缩">霍夫曼压缩</h3>
<p>使用霍夫曼压缩的两种可能的原理：</p>
<ol type="1">
<li>为每种输入类型构建一个语料库。</li>
<li>对于每个可能的输入文件，仅为该文件创建一个唯一的代码。 发送 代码与压缩文件一起。</li>
</ol>
<p>实例：<a href="https://docs.google.com/presentation/d/1DWuSkE9MxQPUTjbSJCMe54rCim4eAwM4aFRvhqq5_Hs/edit#slide=id.g2159afc5e6_0_1044">演示</a> 编码： 第 1 步：计算频率。 步骤2：构建编码数组和解码树。 步骤3：将解码trie写入output.huf。 步骤4：将每个符号的码字写入output.huf。 解码： 步骤1：读入解码树。 步骤 2：沿着 trie 遍历，每次都输出符号 当到达一片叶子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given a file X.txt that we’d like to compress into X.huf:</span><br><span class="line">- Consider each b-bit symbol (e.g. 8-bit chunks, Unicode characters, etc.) of</span><br><span class="line">X.txt, counting occurrences of each of the 2 b possibilities, where b is the size</span><br><span class="line">of each symbol in bits.</span><br><span class="line">- Use Huffman code construction algorithm to create a decoding trie and</span><br><span class="line">encoding map. Store this trie at the beginning of X.huf.</span><br><span class="line">- Use encoding map to write codeword for each symbol of input into X.huf.</span><br><span class="line">To decompress X.huf:</span><br><span class="line">- Read in the decoding trie.</span><br><span class="line">- Repeatedly use the decoding trie’s longestPrefixOf operation until all bits in</span><br><span class="line">X.hug have been converted back to their uncompressed form.</span><br></pre></td></tr></table></figure>
<h3 id="lzw压缩">LZW压缩</h3>
<p><a href="https://docs.google.com/presentation/d/1U8XO6CWfcU4QgrFOZmGjAgmaKxLc8HXk6qB1JQVlqrg/edit#slide=id.g53705ba95_0259">演示</a> Key idea: Each codeword represents multiple symbols.</p>
<ul>
<li>Start with ‘trivial’ codeword table where each codeword corresponds to one ASCII symbol.</li>
<li>Every time a codeword X is used, record a new codeword Y corresponding to X concatenated with the next symbol</li>
<li>从“简单”码字表开始，其中每个码字对应 一个 ASCII 符号。</li>
<li>每使用一个码字X，记录一个对应的新码字Y 到 X 与下一个符号连接。</li>
</ul>
<h3 id="总结">总结</h3>
<p>霍夫曼编码：</p>
<ul>
<li>将公共符号表示为具有较少位的码字。</li>
<li>使用诸如 Map&lt;Character, BitSeq&gt; 之类的东西进行压缩。</li>
<li>使用 TrieMap&lt;Character&gt; 之类的东西进行解压缩。 LZW:</li>
<li>用单个码字表示多个符号。</li>
<li>使用 TrieMap&lt;Integer&gt; 之类的东西进行压缩。</li>
<li>使用诸如 Map&lt;Character, SymbolSeq&gt; 之类的东西进行解压缩。</li>
</ul>
<h2 id="附加内容">附加内容</h2>
<h3 id="柯尔莫哥洛夫复杂度">柯尔莫哥洛夫复杂度</h3>
<p>Given a target bitstream B, what is the shortest bitstream C B that outputs B.</p>
<ul>
<li>Definition: The Java-Kolmogorov complexity K J (B) is the length of the shortest Java program (in bytes) that generates B. ○ There IS an answer. It just might be very hard to find.</li>
</ul>
<ol type="1">
<li>柯尔莫哥洛夫复杂度实际上与语言无关。</li>
</ol>
<ul>
<li>对于任何比特流，Java-Kolmogorov 复杂度不超过 大于 Python-Kolmogorov 复杂度的常数因子。—— I could just write a Python interpreter in Java and then run Kevin’s program. ○ K J (B) ≤ K P (B) + size(python interpreter)</li>
</ul>
<ol start="2" type="1">
<li>It is impossible to write a program that calculates the Kolmogorov Complexity of any bitstream. Proof available here</li>
</ol>
<h3 id="独立集问题">独立集问题</h3>
<p>独立集是一组顶点，其中没有两个顶点相邻。 独立集问题：</p>
<ul>
<li>是否存在大小为 k 的独立集合？</li>
<li>即，k 个顶点的颜色为红色，这样就没有接触。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Give an algorithm for solving this problem.</span><br><span class="line">- For each of the possible 2 N colorings:</span><br><span class="line">○ Check if number of colored vertices is equal to k: O(N)</span><br><span class="line">○ For every red vertex, check that neighbors are all white: O(k*N)</span><br><span class="line">○ If both checks succeed, return true.</span><br><span class="line">○ If either check fails, go on to next coloring.</span><br><span class="line">- Runtime: O(k*N*2 N ). Since k ≤ N, O(N 2 *2 N )</span><br></pre></td></tr></table></figure>
<h3 id="npp">np=p</h3>
<p>We say that a problem is in the complexity class P if:</p>
<ul>
<li>It is a decision problem.</li>
<li>An answer can be found in O(N k ) time for some k</li>
</ul>
<p>We say that a problem is in the complexity class NP if:</p>
<ul>
<li>It is a decision problem.</li>
<li>A “yes” answer can be verified in O(N k ) time for some k. More precisely, we can verify a specific example of a “yes” answer in O(N k ) time</li>
</ul>
<p>Many (most?) practical problems can be cast as a problem in NP:</p>
<ul>
<li>Is there a way to route my airplanes at a total cost of less than $1B/yr?</li>
<li>Is there a way to route the wires inside this microchip with a total path length of less than 1 micrometer?</li>
<li>Given Z, are there two primes such that X*Y = Z?</li>
<li>Is there a protein configuration for amino acid sequence X whose total energy is less than Y?</li>
</ul>
<p>Nice features of P:</p>
<ul>
<li>O(N k ) is closed under addition and multiplication. ○ Run two P algorithms, overall still in P. ○ Run a P algorithm in N times, still in P <img src="/assets/61b总和笔记/image-20231006223527363.png" /> 共识意见</li>
<li>83%：P ≠ NP（126 名受访者）</li>
<li>9%：P = NP（12 名受访者）</li>
<li>9%：其他（13 名受访者）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“[针对我们现在所说的 NP 完全问题的线性或二次时间过程将会产生]最严重的后果。[对于这样的程序]将 明确表明，尽管Entscheidungs问题无法解决，数学家在回答是或否问题时的脑力劳动可以是完全被机器取代了。”  ——库尔特·哥德尔</span><br></pre></td></tr></table></figure>
<h2 id="总结-1">总结</h2>
<ul>
<li><p>基于对象的编程：围绕对象进行组织。</p></li>
<li><p>面向对象编程： ○ 接口继承。 ○ 实现继承。</p></li>
<li><p>动态类型与静态类型。</p></li>
<li><p>泛型编程，例如ArrayList&lt;Integer&gt;等。</p></li>
<li><p>内存模型是包含位的盒子。</p></li>
<li><p>正整数的位表示。</p></li>
<li><p>java</p></li>
<li><p>一些标准的编程习惯/模式： ○ 作为函数容器的对象（例如比较器、IntUnaryFunctions）。 ○ 接口中的默认方法规范（链接）。 ○ 迭代器和视图（例如keySet）。</p></li>
<li><p>Java 中重要的数据结构 重要数据结构接口：</p></li>
<li><p>java.util.Collection（及其子类型）。 ○ 特别强调 Map（及其子类型）。</p></li>
<li><p>我们自己的集合（例如Map61B、Deque）：实际上并没有扩展集合。</p></li>
<li><p>运行时间分析 时间复杂度表示 渐进分析 数学证明 最好，最坏，平均情况</p></li>
<li><p>数据结构 Array-Based Data Structures:</p></li>
<li><p>ArrayLists and ArrayDeque</p></li>
<li><p>HashSets, HashMaps, MyHashMap: Arrays of ‘buckets’</p></li>
<li><p>ArrayHeap (tree represented as an array) Linked Data Structures</p></li>
<li><p>Linked Lists ○ LinkedList, IntList, LinkedListDeque, SLList, DLList</p></li>
<li><p>Trees: Hierarchical generalization of a linked list. Aim for bushiness. ○ TreeSet, TreeMap, BSTMap, Tries (trie links often stored as arrays)</p></li>
<li><p>Graphs: Generalization of a tree (including many algorithms).</p></li>
<li><p>编程实践</p></li>
<li><p>Java 语法和习惯用法。</p></li>
<li><p>JUnit 测试（及其更极端的形式：测试驱动开发）。</p></li>
<li><p>挖掘网络代码。</p></li>
<li><p>调试： ○ 确定受错误影响的最简单的情况。 ○ 追捕它，让它无处藏身。 ○ 有了正确的方法，即使通过查找bug也能找到bug 手动代码检查是不可能的（参见lab3中的Horrible Steve）。</p></li>
<li><p>真正的工具：IntelliJ、git、命令行、Maven</p></li>
<li><p>数据结构选择（和API设计） ○ 推动整个计划的绩效和实施。</p></li>
<li><p>使用复杂的 API、规范：项目 2 和项目 3 ○ 项目 3 还涉及与现有代码库的交互。</p></li>
<li><p>其他 压缩：</p></li>
<li><p>霍夫曼编码，以及霍夫曼编码的数据结构选择。</p></li>
<li><p>其他方法：LZW 和游程编码（额外的幻灯片）。</p></li>
<li><p>观察：比特流的最佳压缩将提供 该位流的有用模型（例如，hugPlant.bmp -&gt; HugPlant.java）。 不可能且棘手的问题：</p></li>
<li><p>不可能：为任何输入找到最佳压缩的算法。</p></li>
<li><p>棘手问题：3SAT、独立集、NP 完备性。 ○ P = NP 吗？ “是”的答案具有戏剧性的意义。</p></li>
</ul>
<p><img src="/assets/61b总和笔记/image-20231006224146653.png" /></p>
<h1 id="作业中的实现待续">作业中的实现（待续）</h1>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>数据结构与算法</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>【杀手3争议】拟真性与游戏性之争</title>
    <url>/2023/09/30/%E6%9D%80%E6%89%8B47/</url>
    <content><![CDATA[<p>2022年一月份，杀手3将解除一周年的独占，登录steam，而早在21年初，杀手3就成了一款有点话题性的游戏，这是因为游戏的一张重庆的地图，这一地图因为缝合了赛博朋克，老大哥等元素被指责有乳制品嫌疑。 <span id="more"></span> 在仔细讨论这件事前，让我们先来看看这是一个什么样的游戏。平心而论，作为一个系列续作，杀手3可以说还算合格，虽然刺杀方式上有缩水，但看得出制作组在氛围营造上投入了不少努力，有很多截一帧就是壁纸的远景或者特写。杀手系列可以说是一个好游戏，甚至可以说是刺杀游戏这一细分品类的霸主，但ioi是纯纯的懒狗，犯下了版本混乱，高价低质量dlc，违背承诺种种重大错误，ioi并不是一个好开发商，如果你骂ioi，我举双手赞成，但对杀手三3有没有乳，我认为还是要谨慎讨论。 我所好奇的是，杀手是不是一个拟真的游戏？ 我想只要你玩过这个游戏，你就会知道答案是否定的，即便是游戏的核心——刺杀系统，也有很多方案并不具有现实可行性。，如果说起其他设定，就更没有真实性了，杀手三部曲的反派是一个势力遍及全球，由“社会精英”组成的阴谋论组织，我并不认为这样的组织有什么现实可行性，如果我们这种普通人都能知道这样的组织，那只有两个可能，1这样的组织情报保密工作很烂，那它早该被拿下来了2它故意泄露的，实际上我们对它一无所知，那就让我们一切的想法都成了臆测，阴谋论是一些无法质疑的假设，这样的假设我可以提出几百个。 当然，我们没必要对一个游戏上纲上线，即便涉及到阴谋论，也只能说杀手并不是一个拟真的游戏。那么，作为一个涉及到多个国家刺杀目标的游戏，杀手对其中的国家是怎么描写的呢？ 摩洛哥在杀手里被描绘成政府软弱无能被军阀控制，甚至准备发动政变，我们且不论这是不是真的，无论如何这都不是什么很友好的描写，我们提到过的阴谋论组织的一位高层在法国有一个大葡萄酒厂，很符合我们对法国的刻板印象吧，然而这位律师有私人武装，甚至包括一队直接听命的狙击手，我想法国不会放任私人权利到这个地步。孟买的街头扛着步枪的武装士兵到处走，北欧的高端别墅区一栋不算特别大的别墅有十几个全副武装的保镖，这些对我一个中国人来说都觉得不合理，可见杀手这个系列根本没有多少写实性。 我们可以做一个总结了，无论从什么角度看杀手都不是一个贴近现实的游戏，特别是在zz方面，尤其口无遮拦，什么都编的得出来。 那让我们再看看重庆这张图，这张图有什么呢，赛博朋克+老大哥，大量的监控摄像头，华人街一样的街道和餐馆，秘密暗杀组织的不人道实验，改造人类街头的流浪汉，我们之前也说了，杀手的地图里编的成分很大，更何况设定上ICA最重要的实验室就在这里，与其说ioi想还原什么地方，倒不如说估计是他们看到一些关于重庆很赛博朋克的新闻，然后觉得可以蹭一下人设。试问这些元素有多少是真正不合适的呢，脑子正常的人都不会觉得现在有技术能操控人的思想或者改造人类吧，既然你不会觉得这些情节是真的，你为什么会觉得这座城市是真的这样呢？ 当然，事实上这样的论述也是有模糊性的，你可以说不够还原就是不够尊重，也可以说法国，美国的图比中国的还原是歧视，在国际矛盾激化的今天，会在这样的事上比较敏感可以理解，但我想说，我希望并呼吁大家在至少在文娱领域多一些宽容，不要泛政治化，能疑罪从无就不要恶意去揣测。 47的目标有很多罪不至死，为了一己私欲杀死无罪者，这难道不是宣传不良价值观吗？但恐怕没人这么批评，为什么我们会在道德上对文娱作品这么宽容，在政治上却那么草木皆兵呢？ 我很希望大家能多一些宽容，我也希望文娱作品无论何时都应该是一片不被zz过分染指的净土</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>其他游戏</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>hitman</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏互动性的新探索——步行模拟器</title>
    <url>/2023/09/30/%E6%AD%A5%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8/</url>
    <content><![CDATA[<p>步行模拟器，在本视频中取操作只局限于步行和一些简单动作，主要获取信息的途径为阅读和观察的游戏，这是一种颇为先锋，也颇为小众的游戏类型，在其中有一些火到出圈的佳作，也有缺点明细的庸作，但都有着共性在其中，今天，我就用一个业余爱好者的身份来浅析一下这类游戏。 <span id="more"></span> 我们先从步行模拟器的历史说起，由于我不是专业人士，也不是什么老玩家，所以只能大概地说说。 溯及这类游戏的根源是一件很难且没有必要的事情，所以我们只把目光放在本世纪好了，在2007年，一个传奇的年份，当时的游戏界见证了巫师一，质量效应一，刺客信条一等传奇系列首作的诞生，也有一些人注意到一款名为《亲爱的艾斯特》的奇异游戏，对一个原教旨主义者来说它可能算不上游戏，玩家操控着一位失去妻子的男人在孤岛上步行，整部游戏唯一的信息来源就是沿途的风景，壁画，以及男人的自言自语，某种意义上这带来了一种推理小说式的体验，你需要在文本中领略事件的来龙去脉，同时体验它压抑深沉的环境氛围。 亲爱的艾斯特取得了意想不到的小范围成功，本作为免费游戏的它在12年发布了付费版，并取得了80万的销量，可以说，近十年的步行模拟器很大程度上是由它启蒙的。 因此，以12年为分水岭，逐渐涌现出不少的步行模拟器游戏。 13年亮相的是著名的meta游戏史丹利的寓言和较为平庸的到家（gone home） 14年问世的是解密风的伊森卡特的消失 15年艾斯特的工作室发行了同类型的万众狂欢 16年则有看火人与弗吉尼亚出现 而在17年，此类型的集大成者，艾迪芬奇的记忆横空出世，成为了此类型至今为止的最优者 可能不少对此类游戏毫无兴趣的玩家会好奇，步行模拟器的卖点到底在哪? 在这个媒体资源空前丰富的时代，每个人都能输出自己的思想，因此思想的输出变得极为廉价，而接受者的地位却会被拔高，因此，门槛越高的思想输出方式就有着越大的不被接受的风险，导致晦涩隐喻的内容就会不受待见。尽管如此，这些晦涩的思想与表达依旧是存在的，步行模拟器就是一种方式。 事实上，接受他人的思想表达一直都有很大的风险，只要作者多加一点私货，或者在莫名其妙的地方整个活，接受者的思想就会收到极大的冲击，例子我就不举了，懂得都懂。所以很多人都会倾向于不去接受，晦涩的作品他们根本不会碰，也有的人沉迷于此类快感，不顾风险地追寻自己认为好的输出者，这两种选择没有高下之分，但体现在游戏上，我们就会发现后者经常会成为所谓的小众游戏爱好者，这并不意味着他们很优越，相反，他们可能已经踩过不知道多少雷了。 为此前的论述做一个总结，步行模拟器可以作为一个高门槛的思想输出方法，因此能吸引一些喜欢此类体验的玩家。事实上，它和同样强调探索的avg可能存在一些关系，但由于我对此没有足够的知识，就不献丑了。 在此基础上，我们来分析此类游戏的一些特性。 首先，第一个问题是，为什么要用步行模拟器这种形式，毫无疑问这种游戏的互动性基本不是很强，也没有刺激官能的要素，然而，正是因为这种自断一臂式的操作，让它能够把自己的叙事能力提高到大部分游戏所不能及的程度，玩法单一也就意味着玩家的注意力会完全集中于一点，制作者只要专注于此方面，就能高频度地向玩家提供信息，而不会让人一头雾水，因为这样的特点，相比大部分游戏，步行模拟器可以聚焦于很多与众不同的题材，可以选用不同的叙事方式， 另一个优点是，较小的游戏规模与如今相对成熟的游戏工业，让制作者能以较为低廉的成本做出不同的场景，美术效果和环境在步行模拟器中有很大的作用，我之所以这么说，不仅是因为它有着渲染气氛的作用，在很多此类游戏中，环境本身就承担着叙事的任务，尤其以艾迪芬奇的记忆而言，环境在这款游戏中达到了当代游戏的新高度，不同的房间布置在无言中传达了房间主人的个性，甚至在一些细节中暗示了主人的命运。可以这么说，在很多步行模拟器中，环境有着超越装饰的作用 步行模拟器还有一个特点，那就是它是第一人称的，你可能单纯地觉得这是为了提高代入感，但事实上，因为互动性的匮乏，步行模拟器往往更趋向于探索和体验，而不是扮演，更形象的说法是，在步行模拟器中看到的是别人的故事，因此在我看来，第一人称更多的意义是类似侦探小说的叙述主体，也就是说，以这个故事而言，第一人称对应的角色就是最适合展现故事全貌的人，同时，这个主体具体的身份也可以是一个谜题，伊森卡特的消失，艾迪芬奇的记忆都在这方面上做了文章，非常有趣。 上述特点事实上还是很笼统的，实际上的步行模拟器在风格和题材上都是各具特色，特点也不尽相同，但由于到目前为止出名的步行模拟器实在不多，所以我们就用穷举的方法来说说这些步行模拟器。 先从最早的亲爱的艾斯特说起 在所有步行模拟器中，艾斯特应该是互动性最低的一个，你能做的只有控制一个喃喃自语的男人在孤岛上乱走，然而，艾斯特依然是一部很优秀的游戏，优秀的文本质量和环境建模完美地融合在了一起，配合迷雾重重的故事，与四个风格迥异的场景与种种细节，成功营造出了一种哀伤中透着迷幻的气氛。虽然选取了悼念亡妻的题材，但艾斯特并没有直接表现哀伤，叙事主体的男子呈现的态度是思辨的，其文本很有些深度，艾斯特的氛围塑造与文本水平，我个人认为是步行模拟器中最优秀的之一，并没有被后来者超越，甚至也没有被他们自己超越。 史丹利的寓言 这游戏很难归类，它更为众人所熟悉的标签是meta游戏，举个不恰当的例子，meta游戏和游戏的区别就像文学批评和文学的区别，很难说史丹利的目的是对游戏这一创作形式进行批判还是呈现一段故事。 这游戏几乎是靠作者一个人的天才撑起来的，即便在meta游戏中有史丹利寓言这么强烈批判属性的游戏，据我所知也是不存在的，它很有创设性的给予了游戏四个视角两个阵营，呈现者阵营的游戏系统（游戏作者？）与旁白，接受者阵营的史丹利与玩家本人，史丹利的故事几乎都是两个阵营间不同角色的互动，它实现了大部分游戏都做不到的一点，即让玩家直接与游戏的底层逻辑对话。 现代游戏互动性的本质是什么，无非不过是选择而已，拟真度高的游戏也不过是多提供了一些选项，史丹利抓住了这个底层逻辑，因此哪怕是步行模拟器这一形式只要用好“选择”，就不会缺少互动性。 这样的策略让史丹利显得不是那么“步行模拟器”，但实际上这还是一部叙事游戏，只不过它的故事千变万化，且富有批判意味，而且它的叙事有着“选择”的成分，因此它包含了十几个不同的故事。 归家 归家是一部很有实验意义的作品，如果你情商比较高的话，应该就知道我的意思是这游戏有着不少的缺点，归家的故事发生在20世纪末的一个美国家庭，一个暴风雨之夜，家中的姐姐回到家中，发现妹妹离家出走，于是开始寻找原因，归家的核心机制是拾取/查看物体触发回忆，核心谜题则是揭开妹妹的下落，然而这游戏的故事非常简单，简单到什么程度呢？在触发前三个回忆后你基本上就能猜到故事的梗概了——没错，一个俗套的恋爱被父母反对然后私奔的故事，稍微有些不同的是，主角是两位女同性恋，此外，游戏中有一些不怎么明显的机关且缺乏提示的机关，总体感觉实在是索然无味，尽管某种意义上它为有核心谜题的步行模拟器树了一个榜样，但论其素质十分乏善可陈，最大的优点可能是还算有20世纪风格的家居布置。 值得一提的是ign给了归家9.5的超高分，对ign来说这种分数是很少见的，我们之前提到的艾斯特得到了8分，史丹利寓言得到了8.8分，而品质平平的到家则得到了9.5分的超高评价，并且编辑的评论是没有缺点，联系其故事题材，此件原因令人深思，因为涉及敏感话题，我就不多说了 伊森卡特的消失 这是一部很有风格的作品，在场景建模上制作组创作性的采用了结合实景照片的做法，因此画质显得极为真实，配合微恐怖的风格，代入感极强，游戏的内容是一个有着回溯犯罪现场能力的侦探应伊斯卡特的邀请调查一个据说有着不可名状怪物的地区的系列凶杀案，抛开几乎为0的地图指引，游玩过程中你会觉得这似乎就是一个普通的解谜游戏，虽有称道之处，但综合来看质量一般，然而，这款游戏最值得称道的一点是，制作组为了一个有极大反转的结局在流程中埋了不少伏笔，因此伊森卡特的结局在我看来在叙事游戏中算最优秀的一档，当然实际上这也是见仁见智的一件事，或许也有不少人觉得铺垫不足。 在步行模拟器中悬疑风格的作品伊斯卡特应该可以说是最成功的。 万众狂欢 这是一部和亲爱的艾斯特风格迥异的作品，它没有叙事主体，玩家以超然的眼光去回顾一座村庄全员蒸发的惨剧，我认为这是一部失败的作品，为什么呢。作为一个拼凑出故事全貌的游戏，万众狂欢很不幸的选择了把最大的悬念放在开头——凶手是形似光球的不可名状生物，而游戏的过程则是目睹居民怎么一步步迈向死亡，整个过程中的互动，只有不如不做的触发回忆过程有——跟着手柄按QTE。具体到故事，恕我直言是很无聊的，寥寥几语的场景中大部分缺少让人身临其境的氛围营造，整部游戏有着浓郁的宗教风格，因此部分场景会有种神圣感，但也就仅此而已了，没有悬念，没有细腻的情感，没有复杂精彩的故事，更没有氛围的营造，万众狂欢在我看来是一部平庸的游戏 看火人 在众多步行模拟器中，看火人是极其冷门的纯写实题材，它选取了森林看护员这一冷门的职业视角来叙述故事，然而它的美术风格却是抽象的大色块风格，这造就了看火人实中有虚的奇妙质感，不论看火人的故事如何，这样的题材与美术创新是优秀的且值得鼓励的。 主角亨利在爱妻患病后心灰意冷，因为酗酒被妻子家人排挤的他最后来到了荒无人烟的森林公园成为了火情瞭望员，我们可以看到，游戏的主题几乎已经确定为心灵的救赎，但看火人的呈现方式是特别的，因为职业的特殊性，从始至终能与亨利交流的只有一位名为黛利拉的女性，在一片孤独的瞭望塔中这似乎是亨利唯一的情感支柱，事实上，看火人最大的优点就是情感的细腻，整个游戏几乎就是亨利与黛利拉互相的情感激励与救赎，最后这场类似柏拉图之恋的关系随着因为火情观察员撤离而收尾。 值得一提的是，看火人神奇的在游戏中夹杂了不少悬疑的成分，这让看火人的基调显得有些奇怪，由一开始的悠闲巡逻转到紧张的解密，随后又在急转直下后收尾，尽管不算无聊，但前后依旧有割裂感。 尽管如此，凭借细腻的情感描写，看火人依旧是一部优秀的游戏。 弗吉尼亚 这是一款很奇特的游戏，即使在步行模拟器里，它也是交互性最差的一类，它使用了一种极为抽象的风格，整个游戏由很多不明所以，充斥着象征的片段组成，而将这些片段串联到一起不过是一些点触的操作，坦白的说，我只能分离地去欣赏这些场景，单从象征的角度来说这些场景单独拿出来还挺有意思的，但你很难把这些片段连起来，事实上不让你把他们连起来可能正是这游戏的目的，此外，该游戏使用了很罕见的古典风格配乐，配合上本就很魔幻的内容产生了一种难以言喻的奇特的氛围。总的来说，这真的是一个很难评价的游戏，如果你有些猎奇心的话倒可以尝试一下 艾迪芬奇的记忆 艾迪芬奇的记忆是一款很优秀的游戏，但它的意义不仅如此，可以说在对互动性的新尝试方面，艾迪芬奇是游戏界最前沿的一个，游戏在叙事上最大的优势就是互动性，大部分游戏选择了剧情分支，qte之类的通解，而艾迪芬奇的记忆则在此基础上作出了创新，单论最简单的字幕，往往只被放置在屏幕底部用于阐释信息，而艾迪芬奇则将它放置在了场景之中，伴随着主角的前进逐渐浮现在路边，如此一来字幕甚至兼任了指引的作用。 依我看来，艾迪芬奇的主基调可以用魔幻二字来概括。随着艾迪依次探索旧宅，我们进入了一个个家族成员死前的景象中，但我们透过屏幕看到的不仅仅是一个个纪录片式的景象，还有情绪的具象化，例如令人啧啧称奇的操纵漫画中的角色一段，操纵角色在悬疑漫画的分镜中行走，这是一种崭新且绝妙的传递恐惧感的方式，艾迪芬奇的互动形式总是新颖的，角色伴随着开罐头喃喃自语，在切鱼的流水线上展开与工作融为一体的幻想，手柄的两遥感分别控制现实与幻想世界，此类新颖的设想，艾迪芬奇有近十种，可以这是一款极为奢侈的堆砌创意的游戏。 艾迪芬奇的家族大都耽于幻想，他们的幻想往往与现实融为一体，以此呈现出的情景显得分外的魔幻，以游戏的形式来叙述这样的故事，这一模式提供了一种特别的审视真实世界与内心世界的视角，这样类似魔幻现实主义的创作手法可以说极为前卫和有趣。 毫无疑问艾迪芬奇的互动性与创意是它最耀眼的闪光点，在此的映衬下，艾迪芬奇的剧情似乎显得暧昧不清，多个家庭成员的死亡都没有得到明确交代，尽管在一个个情景中我们能在画面中感知到情绪的具象化，尽管艾迪芬奇家族一向有着早死的诅咒，但艾迪芬奇没有，至少没有直接透露任何家庭成员对于死亡的看法，在一部探讨死亡的作品中这点显得很奇怪，似乎它只想将死亡本身呈现出来，却不想对此发表任何议论，我们很难说艾迪芬奇有什么主旨，在死亡这个主题上，制作组显得分外的冷漠，只留下玩家在原地回味。Steam上艾迪芬奇的商店页面有这样一句差评，艾迪芬奇的记忆有着美化死亡的嫌疑，这对那些有自杀倾向的人来说似乎太不友好了。这并不是没有道理。 总结 步行模拟器始终是个小众的品类，它固然有着一些创作上的优点，但成本和受众的因素始终制约着这一类型，导致作品寥寥无几，但在步行模拟器其实不乏对游戏这一创作形式的革新，作为新时代的叙事向avg游戏与独立游戏的一大阵营，步行模拟器的身上其实或多或少蕴含着电子游戏未来的一大方向，即作为有才能的作者表达自己的一种方式，对此我报以极大的期待。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>独立游戏</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>步行模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>基于苏大ppt的计算机硬件笔记</title>
    <url>/2023/09/29/%E7%A1%AC%E4%BB%B6%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>`冯·诺依曼计算机特点<br />
– 计算机由五大部件组成<br />
• 输入数据和程序的“输入设备”<br />
• 记忆程序和数据的“存储器”<br />
• 完成数据加工处理的“运算器”<br />
• 控制程序执行的“控制器”<br />
• 输出处理结果的“输出设备”</p>
<span id="more"></span>
<p>– 指令和数据以同等地位存于存储器，可按地址寻访<br />
– 指令和数据用二进制表示<br />
– 指令由操作码和地址码组成<br />
– 以运算器为中心 基础逻辑电路：与门，非门，或门，异或门，与非门，或非门，同或门 半加器<br />
– 𝑆𝑖当前位， 𝐶𝑖进位符 全加器 （包括之前的进位cn-1） – 𝐹𝑛当前位， 𝐶𝑛进位符 𝐶𝑛 = 𝑋𝑛 ⋅ 𝑌𝑛 + 𝑋𝑛⨁𝑌𝑛 ⋅ 𝐶𝑛−1 <img src="/images/obsidian/20230531113546.png" title="image" alt="图片" /> <img src="/images/obsidian/20230531113559.png" title="image" alt="图片" /> <img src="/images/obsidian/20230531113735.png" title="image" alt="图片" /> CPU与外设之间的数据交换必须通过接口来完成，通常接口有<br />
以下一些功能：<br />
– 设置数据的寄存、缓冲逻辑，以适应CPU与外设之间的速度差异；<br />
– 进行信息格式的转换，例如串行和并行的转换；<br />
– 协调CPU和外设两者在信息的类型和电平的差异，如电平转换驱动器、<br />
数/模或模/数转换器等；<br />
– 协调时序差异；<br />
– 地址译码和设备选择功能；<br />
– 设置中断和DMA（直接存储器存取）控制逻辑，以保证在中断和DMA<br />
允许的情况下产生中断和DMA请求信号，并在接受到中断和DMA应答<br />
之后完成中断处理和DMA传输。 `为何要用二进制表示（冯.诺依曼核心）<br />
– 无法制造多个稳定状态的物理器件<br />
– 编码、计数、运算规则简单<br />
– 和逻辑的真、假对应，通过逻辑门电路可实现算数运算 BCD码<br />
– 机器中用4位二进制对每个十进制数位进行编码方法<br />
– 4位二进制有16种组合，选取其中的十个。<br />
– 常用的方法有：8421码、余3码、格雷码</p>
<p>为什么要用BCD码<br />
– 高精确度的计算<br />
– 耗费更多的存储空间 <code>数的定点与浮点表示   – 十进制的公式表示：𝑁 = 10𝐸 ∗ 𝑆   – 二进制数的公式表示：𝑁 = 2𝐸 ∗ 𝑆   • 定点数：阶码𝐸位置固定，存储时统一忽略阶码   – 定点整数: 𝐸 = 0， 𝑆为纯整数，小数点固定在数值部分的右边   – 定点小数: 𝐸 = 0， 𝑆为纯小数，小数点固定在数值部分的左边</code>浮点数详解<br />
– 浮点数的表示范围<br />
• 阶码E的范围：−128 ≤ 𝑒 &lt; 127<br />
• 最大正数：0.111 ... 1 × 2011...1 = (1 − 2^−23) × 2^127<br />
• 最小正数：0.100 ... 0 × 2100...0 = 1<br />
2 × 2−128 = 2−129<br />
– 浮点数的表示精度<br />
• 总位数不变<br />
– 阶码越大：数值表示范围越大<br />
– 尾数越少：精度变低 <img src="/images/obsidian/20230531114156.png" title="image" alt="图片" /> 机器数的表示形式：原码、反码、补码<br />
– 原码：符号+真值<br />
• +41 原 = 0 0101001， −41 原 = 1 0101001<br />
• +0 原 = 0 0000000， −0 原 = 1 0000000<br />
– 反码：正数不变，负数时符号不变，其他各位取反<br />
• +41 反 = 0 0101001， −41 反 = 1 1010110<br />
• +0 反 = 0 0000000， −0 反 = 1 1111111<br />
– 补码：正数不变，负数为反码+1（计算机表示带符号数的方法）<br />
• +41 补 = 0 0101001， −41 补 = 1 1010111<br />
• +0 补 = 0 0000000， −0 补 = 0 0000000<br />
• +127 补 = 0 1111111， −127 补 = 1 0000001<br />
• −128 补 = 1 0000000 `溢出<br />
– 运算结果超出机器数所能表示的范围时，称为溢出<br />
– 定点数溢出的判断方法<br />
• 两个同符号的数相加，得到的和的符号与相加数的符号不一致。<br />
– 采用双符号位：正数的符号位为00，负数的符号位为11。符号位参加运算。如果<br />
两个符号位不相同，则溢出。（浪费资源）<br />
• 任意两数相加，如果数值最高位的进位不等于符号位的进位，则溢出。<br />
– 浮点数溢出的判断方法<br />
• 看阶码是否溢出！</p>
<p>BCD码：用四位二进制数表达一个十进制数，方便运算和显示 浮点数：尾数S和阶码E 符号+阶码+符号+尾数 反码：正数不变，负数除了符号位取反 补码：正数不变，负数除了符号位加一 +0：00000000 -128:10000000 [x+y]补=[x]补+[y]补 [x-y]补=[x]补+[-y]补</p>
<p>有效地址EA=基址（BX/BP）+变址值(SI/DI)+位移量DISP +段基址=物理地址</p>
<h2 id="cisc和risc是cpu的两种基本架构">CISC和RISC是CPU的两种基本架构</h2>
<p>– CISC：寻址方式多，方便编程<br />
– RISC：寻址方式少，指令短、规整</p>
<h3 id="risc特点">RISC特点</h3>
<p>– 指令系统<br />
• RISC指令长度相同；寻址方式少；指令执行时间相当<br />
– RISC CPU内部寄存器多<br />
– 存储器操作<br />
• 只有取数/存数指令访问存储器，大部分指令都在寄存器之间进行<br />
– 代码量增多，实现特殊功能时程序复杂<br />
– 较少的单元电路，面积小，功耗低<br />
– 结构简单，设计周期短</p>
<h3 id="程序执行过程">程序执行过程</h3>
<p>– PC发起地址查询<br />
– 内存依据地址返回指令/数据<br />
– CPU进行指令解析<br />
– PC增量或PC赋值<br />
• 指令结构<br />
– 操作码+地址码（操作数所在地）</p>
<h3 id="寻址方式">寻址方式</h3>
<ul>
<li>立即数寻址（办理人随身携带）<br />
– 操作数由指令的地址码部分直接给出来<br />
• 操作码+操作数<br />
</li>
<li>寄存器直接寻址（办理人已寄存）<br />
– 指令地址码部分给出某一通用寄存器地址<br />
– 从寄存器存取数据比主存快得多<br />
– 由于寄存器的数量较少，其地址码字段短</li>
<li>直接寻址（办理人在队伍里）<br />
– 指令中地址码字段给出操作数的地址<br />
• PC赋值——取操作数</li>
<li>间接寻址（办理人在哪问家长）<br />
– 指令中给出的地址是存放操作数地址的地址<br />
– 寄存器间接寻址（家长已寄存）<br />
– 存储器间接寻址（家长在队伍里）</li>
<li>偏移寻址（相对寻址）<br />
– 从我往后数A个<br />
– EA：有效地址 – 相对寻址： EA=A+(PC) 相对于当前指令处位移量为A的单元<br />
– 基址寻址： EA=A+(B) 相对于基址(B)处位移量为A的单元<br />
– 变址寻址： EA=A+(I) 相对于首址A处位移量为(I)的单元</li>
</ul>
<h2 id="微处理器">8086/8088微处理器</h2>
<h3 id="指令队列缓冲器">指令队列缓冲器</h3>
<p>– 取指令时，每当指令队列缓冲区满一条指令，EU立即开始执行<br />
– 当指令队列中有2个空字节（8088一个）BIU自动去取指<br />
– EU从指令队列中去取指，然后执行指令，当该指令需要内存或<br />
I/O访问，EU请求BIU进入总线周期完成访问：<br />
• BIU空闲状态：立即响应<br />
• 正在取指：取指完后响应<br />
– 指令队列已满，EU没有对BIU有请求，BIU进入空闲状态<br />
– 执行转移、调用、返回指令：指令队列中的内容（原顺序指令）<br />
被清除，BIU去取EU所指示的新的程序段指令</p>
<h3 id="寻址空间计算">寻址空间计算</h3>
<p>– 8位机寻址：8根地址线<br />
• 地址范围：0~255<br />
• 最大内存空间：28 = 256Byte<br />
– 16位机：216 = 64KB<br />
– 32位机：232 = 4GB<br />
– 64位机：264 = 16EB</p>
<h3 id="编程结构">编程结构</h3>
<p><img src="/images/obsidian/20230603134629.png" title="image" alt="图片" /> – 4个通用寄存器(16位)<br />
• AX、BX、CX、DX（可8位单独使用）<br />
– 4个专用寄存器(16位)<br />
• BP（Base Pointer）基数指针<br />
• SP（Stack Pointer）堆栈指针<br />
• SI（Source Index）源变址<br />
• DI（Destination Index）目的变址<br />
– 4个段寄存器（16位）<br />
• CS（Code Segment）代码段寄存器<br />
• DS（Data Segment）数据段寄存器<br />
• SS（Stack Segment）堆栈段寄存器<br />
• ES（Extra Segment）扩展段寄存器 – CS用来存放程序当前使用的代码段的段地址，CPU执行的指令<br />
将从代码段取得<br />
• CS:IP构成传统意义的PC<br />
– SS用来存放堆栈段的段地址，堆栈操作的数据就在堆栈段中<br />
• 通常SS:SP和SS:BP构成堆栈段的访问<br />
– DS用来存放数据段的段地址，一般地说，程序所用的数据就存<br />
放在数据段中<br />
• 通常DS:XX（通用寄存器）构成对数据段的访问；<br />
– ES用来存放附加段的段地址，也用来存放数据，但典型用法是<br />
存放处理后的数据</p>
<h2 id="主存储器">主存储器</h2>
<h3 id="主存储器处于中心地位的原因">主存储器处于中心地位的原因</h3>
<p>• 当前计算机正在执行的程序和数据均存放在存储器中，<br />
CPU直接从存储器取指令或数据；<br />
• 输入输出设备增多，数据传输速度加快，因此采用了<br />
DMA(直接存储器存取)技术和输入/输出通道技术，<br />
在存储器与输入/输出系统之间直接传送数据；<br />
• 共享存储器的多处理机的出现，利用存储器存放共享<br />
数据，并实现处理机之间的通信。</p>
<h3 id="存储器的分类和指标">存储器的分类和指标</h3>
<p>随机存储器（random access memory，RAM）<br />
• 又称读写存储器，指通过指令可以随机地、个别地对<br />
各个存储单元进行访问（读写）的存储器<br />
• 访问所需时间基本固定，与存储单元地址无关<br />
• 停电会造成信号丢失<br />
非易失性存储器<br />
• 停电仍能保持其内容 <code>容量 • 计算机可寻址的最小单位是一个存储字，一个存储字   所包括的二进制位数称为字长   • 一个字节（Byte）为8个二进制位（bit），一个字可   以由若干字节组成，一个字的字长通常是8的倍数。   • 主存储器的容量：以字或字节为单位来表示主存储器   存储单元的总数   • 单位：B、KB、MB、GB、 TB、PB、EB、ZB...   • 指令中地址码的位数决定了主存储器的可直接寻址的   最大空间   • 32位微型机提供32位物理地址，支持对4G字节的物理主存   空间的访问</code>存储器存取时间(Memory Access Time)<br />
• 又称存储器访问时间<br />
• 启动一次存储器操作到完成该操作所经历的时间。<br />
`存储周期(Memory Cycle Time)<br />
• 连续启动两次独立的存储器操作(例如连续两次读操<br />
作)所需间隔的最小时间 • 主存储器和CPU是由总线连接的。CPU通过使<br />
用AR（地址寄存器）和DR（数据寄存器）个<br />
主存储器进行数据传送。若AR为K位字长，<br />
DR为n位字长，则允许主存包含2^k个可寻址<br />
字节或字。<br />
• 在一个周期内，CPU和主存储器之间进行n位<br />
数据传送。 读操作：存储器→CPU<br />
• CPU把信息字的地址送到<br />
AR,经地址总线送往主存<br />
储器<br />
• CPU通过控制总线发读<br />
(Read)命令<br />
• CPU等待主存储器的<br />
Ready回答信号，Ready<br />
为 1，表示信息已读出经<br />
数据总线,送入DR。<br />
AR：地址寄存器<br />
DR：数码寄存器<br />
主存储器的基本操作</p>
<p>• 写操作：CPU→存储器<br />
• CPU把信息字的地址送<br />
到AR，经地址总线送往<br />
主存储器,并将信息字送<br />
往DR<br />
• CPU通过控制总线发写<br />
(Write)命令<br />
• CPU等待主存储器的<br />
Ready回答信号，Ready<br />
为 1，表示信息已从DR<br />
经数据总线写入主存储<br />
器</p>
<h3 id="读写存储器">读写存储器</h3>
<p>按存储元件在运行中能否长时间保存信息分为静<br />
态存储器SRAM和动态存储器DRAM两种<br />
• 静态存储器：利用双稳态触发器来保存信息，只<br />
要不断电，信息就不会丢失<br />
• 动态存储器：利用MOS电容存储电荷来保存信<br />
息，使用时需不断给电容充电才能使信息保持<br />
• 静态存储器的集成度低，功耗较大；动态存储器<br />
的集成度高，功耗小，主要用于大容量存储器 • DRAM每片容量大，引脚少; 价格低; 功耗低; 但<br />
速度低，须再生。 DRAM一般用作计算机的主<br />
存储器。<br />
• SRAM速度快，价格较高，一般用作容量不大的<br />
高速存储器。 DRAM和SRAM是可任意读写的随机存储器，当发生掉电时，存储的<br />
内容容易立即消失，属于易失性存储器。<br />
非易失性存储器，即使掉电，内容也不会消失：<br />
只读存储器(ROM)<br />
• 掩膜式ROM，由芯片制造商在制造时写入内容，以后只能读不能写<br />
可编程序的只读存储器(PROM)<br />
• 用户根据自己需要确定ROM的内容；<br />
• 有熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元<br />
的熔丝(写入)。<br />
可擦除可编程序的只读存储器(EPROM)<br />
• 产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线<br />
照射后,浮置栅上的电子将逸散,即整体擦除。<br />
可用电擦除的可编程序的只读存储器(E2PROM)<br />
• 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写<br />
入周期要几毫秒,寿命为10万次。<br />
闪速存储器(Flash Memory)<br />
• 用电擦除,但只能整体擦除或分区擦除。</p>
<h2 id="存储器组织">8086/8088存储器组织</h2>
<p>存储器分段<br />
– 为什么分段<br />
• 地址寄存器均为16位： 216 = 64KB<br />
– 分段方便操作系统进行存储管理<br />
– 如何分段<br />
• 8086地址空间为20位=1MB，地址为5位16进制数：00000H~FFFFFH<br />
– 从偏移地址考虑，理论上最多16个不重叠的地址段<br />
– 从段地址考虑，最多可以定义216个不同段<br />
– 段重叠<br />
• 段区分配通常由操作系统完成<br />
– CS、DS、SS、ES存储与程序相关的段基址<br />
– IP、SP、BP、SI、DI存储与程序相关的偏移地址 逻辑地址和物理地址<br />
– 逻辑地址<br />
• 程序和指令表示的一种地址<br />
• 包括两部分：段地址和偏移地址<br />
– 物理地址<br />
• 段地址*\16+偏移地址=物理地址<br />
– 寻址操作根据操作系统默认规则完成 堆栈（段）<br />
– 机制<br />
• 栈顶为唯一出入口<br />
– 地址较小的一端<br />
• 后进先出原则<br />
– 作用<br />
• 数据暂存<br />
• 保留轨迹 段加偏移”寻址机制允许重定位<br />
– 重定位是指一个完整的程序块或数据块可以在存储器所允许的空<br />
间内任意浮动，并定位到一个新的可寻址的区域<br />
– 允许程序和数据不需要做任何修改</p>
<h2 id="小结">小结</h2>
<p>• 微处理器的设计有CISC与RISC两种基本架构。深入理解16位微处理器8086的内部结构<br />
及其工作原理，是掌握微机工作原理的基础和关键。Intel系列高档微处理器内部的复杂<br />
结构及其工作原理，都是在8086CPU的结构基础上逐步分解结构和细化流水线操作而发<br />
展起来的。透彻地掌握8086CPU的基础，将有利于理解高档微处理器的技术发展。<br />
• 8086/8088 CPU的内部结构由总线接口单元BIU和执行单元EU两部分组成。其内部有3<br />
组共14个寄存器，必须了解它们各自的功能，并能掌握它们的使用方法。<br />
• 总线周期是理解CPU按时序工作的重要概念。8086/8088 CPU一个最基本的总线周期由<br />
4个时钟周期组成，简称为4个状态，即T1、T2、T3与T4这4个状态。<br />
• 微处理器的引脚及其功能是其重要的外部特性。由于8086／8088 CPU只有40条引脚，<br />
学习和掌握它们的功能相对于高档微处理器说来就比较简单。</p>
<p>CF - 进位标志(Carry Flag),表示上一条指令的运算是否产生进位。如果产生进位,CF为1,否则为0。OF - 溢出标志(Overflow Flag),表示上一条指令的结果是否越界。如果结果超出目的操作数可以表示的范围,OF为1,否则为0。 SF - 符号标志(Sign Flag),表示上一条指令运算结果的符号。如果结果为负数,SF为1,如果为正数,SF为0。 ZF - 零标志(Zero Flag),表示上一条指令的运算结果是否为0。如果结果为0,ZF为1,否则为0。</p>
<h2 id="指令格式">指令格式</h2>
<p>计算机是通过指令来处理各种数据，为指出数据的来源、<br />
操作结果的去向及执行何操作，一条指令必须包含以下信<br />
息：<br />
– (1) 操作码——位数及位置。<br />
– (2) 操作数的地址——操作数的个数<br />
– (3) 操作结果的存储地址。<br />
– (4) 下一条指令的地址 <code>指令长度   – 可以等于机器字长，也可以大于或小于机器字长。   • 尽可能短   • 等于字节的整数倍。   – 若所有指令的长度都是相等的，称为定长指令字结构   • RISC指令大多采用定长指令结构   – 若各种指令的长度随指令功能而异，</code>操作码<br />
– 操作码的位数取决于计算机指令系统的规模<br />
– 定长编码和变长编码 变长编码：分散地放在指令字的不同字段中，如INTEL 8086/Pentium<br />
– 优点：能表示更多的指令<br />
– 缺点：增加了译码难度，控制器复杂 <code>指令涉及的数据类型   – 地址：无符号数，一般是加减操作（含移位）   • 8、16或32位   – 数值数据   • 定点数（整数）：补码表示   – 16位、32位、64位   • 浮点数（实数）：IEEE754标准   – 位、位串、字符与字符串   • 用来表示文本、声音和图像等   • 字节、字(16位)、双字(32位)、四字(64位)   – 现代32位计算机通常以32位为一个字：字节、半字(16位)、字(32位)、双字(64位)   – 逻辑数据   • 按位操作（0-假/非0-真）</code>数据寻址方式<br />
– 有效地址EA（Effective Address）=基址值（BX或BP）+变址<br />
值（SI或DI）+位移量DISP<br />
• +段基址=物理地址<br />
– 根据命令判断字段长短<br />
• 通常由寄存器长度决定</p>
<h3 id="寻址方式-1">寻址方式</h3>
<ul>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>直接数据寻址</li>
<li>寄存器间接寻址（间接寻址目标为存储器，故不能确定目标位置长度）</li>
<li>基址加变址寻址</li>
<li>寄存器相对寻址</li>
<li>相对基址加变址寻址(带DISP的基址加变址寻址) 程序存储器寻址方式<br />
– 实现程序转移<br />
• 条件转移<br />
– 段内短转移（-128~+127）<br />
• JMP<br />
– 段内/段间，直接/间接寻址<br />
• CALL<br />
– 段内/段间，直接/间接寻址<br />
• 中断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他寻址方式  </span><br><span class="line">– 串操作指令寻址方式  </span><br><span class="line">• 操作类别：清0、复制、比较等  </span><br><span class="line">• 源数据地址：DS:SI  </span><br><span class="line">• 目标数据地址：ES:DI  </span><br><span class="line">– I/O端口寻址方式  </span><br><span class="line">• 直接端口寻址  </span><br><span class="line">– IN AL, n OUT n, AL  </span><br><span class="line">– 端口号：0～255  </span><br><span class="line">• 间接端口寻址  </span><br><span class="line">– IN AL, DX OUT DX, AL  </span><br><span class="line">– 端口号：0～65535</span><br></pre></td></tr></table></figure>
<h2 id="通用数据传送">通用数据传送</h2>
<p>//CS - Code Segment,代码段寄存器。它保存代码段的起始地址,用于查找程序的指令。IP - Instruction Pointer,指令指针寄存器。它保存下条指令的地址,用于告诉CPU去哪里找到下一条要执行的指令。 1、基本传送指令 MOV（Move）：传送<br />
– 一般形式：MOV dest, src<br />
• dest  src，将源操作数src复制到目的操作数dest，src不变 2、堆栈操作<br />
– PUSH src<br />
– POP dest<br />
– LIFO后进先出<br />
– 堆栈操作按字进行<br />
– 不能POP CS 3、XCHG（Exchange）：交换<br />
– 一般形式：<br />
• XCHG oprd1, oprd2 ;交换oprd1与oprd2的内容<br />
– 语法格式：<br />
• XCHG reg/mem, reg/mem 4.字节翻译指令XLAT（代码转换或查表指令）<br />
– BX 基址：代码转换表首地址（表大小：0~255）<br />
– AL 偏移（码值） MOV BX,0030H<br />
MOV AL,5<br />
XLAT</p>
<h2 id="目标地址传送类指令">目标地址传送类指令</h2>
<p><code>LEA（Load Effective Address）装入有效地址   – 语法格式：LEA reg16, mem ;reg16 = mem的有效地址   – 通常用于建立串操作   – 对标志位的影响：无。   – 【例】设BX = 5678H   • LEA SI, 2\[BX]   ;执行后，SI = 567AH 将计算结果放入BX寄存器,而不会访问那个地址的值</code>LDS reg16, mem<br />
– 定位串操作源地址<br />
– LDS SI, [DI+100AH]<br />
– 低16位存入reg16，高16位存入DS<br />
<code>LES reg16, mem   – 定位串操作目标地址   – 同上，高16位存入ES</code>LAHF、SAHF（保存和设置标志位）<br />
– 与AH寄存器交互<br />
– SF：符号标志：运算结果符号位<br />
– ZF：零标志：运算结果是否为0<br />
– AF：辅助进位标志：低四位是否向高四位进位<br />
– PF：奇偶标志：是否有偶数个1<br />
– CF：进位标志：是否进位/借位</p>
<h2 id="算术运算类指令">算术运算类指令</h2>
<p>加法<br />
– 一般形式：<br />
• ADD dest, src ; dest  dest + src<br />
• ADC dest, src ; dest  dest + src + CF<br />
• INC oprd ;oprd  oprd + 1<br />
– 语法格式：<br />
• ADD reg/mem, reg/mem/imm<br />
• ADC reg/mem, reg/mem/imm<br />
• INC reg/mem<br />
– 对标志位的影响：<br />
• ADD、ADC：按一般规则影响CF、OF、SF和ZF<br />
• INC：不影响CF，其它同ADD<br />
• ADD与ADC的2个操作数必须类型匹配，且不能同时是内存操作数 减法<br />
– 一般形式：<br />
• SUB dest, src ; dest  dest - src<br />
• SBB dest, src ; dest  dest - src - CF<br />
• CMP oprd1, oprd2 ; oprd1 - oprd2<br />
– 与SUB的区别在于，不将减法结果存入dest，只影响标志位<br />
• DEC oprd ; oprd  oprd - 1<br />
• NEG oprd ; oprd  0 – oprd = oprd + 1<br />
– 语法格式：<br />
• SUB reg/mem, reg/mem/imm<br />
• SBB reg/mem, reg/mem/imm<br />
• CMP reg/mem, reg/mem/imm<br />
• DEC reg/mem<br />
• NEG reg/mem SUB、SBB、CMP：影响CF、OF、SF、ZF、AF和PF<br />
• DEC：不影响CF，其它同SUB<br />
• SUB与SBB的2个操作数必须类型匹配，且不能同时是内存操作数 乘法<br />
<code>– MUL（Unsigned Multiplication）：无符号乘法   – 一般形式：   • MUL src   – 语法格式：   • MUL reg8/mem8 ; AX = AL × src   • MUL reg16/mem16 ; DX:AX = AX × src   • 对标志位的影响：若8位×8位、16位×16位的结果分别能由8、16位容   纳（即结果的高一半为0），则CF = OF = 0，否则，CF = OF = 1；其   余标志无定义。   • 由于2个n位数的乘积可能需要2n位，因此，若操作数是8位，则结果为   16位；同样，16位操作数相乘结果为32位（80386中32位数相乘结果   为64位）。</code>IMUL（Integer Multiplication）：带符号乘法<br />
– 一般形式：<br />
• IMUL src<br />
– 语法格式：<br />
• IMUL reg8/mem8 ; AX = AL × src<br />
• IMUL reg16/mem16 ; DX:AX = AX × src<br />
• 对标志位的影响：若结果的高一半为低一半的符号扩展，则CF = OF =<br />
0，否则，CF = OF = 1；其余标志无定义<br />
– 【例】对于同一个二进制数，采用 MUL与IMUL执行的结果可能<br />
不同。设AL = 0FFH，BL = 1，分别执行下列指令，会得出不同<br />
结果。<br />
• MUL BL ; AX = 00ffh（255D）<br />
• IMUL BL ; AX = 0ffffh（-1D） 除法<br />
– 一般形式：<br />
• DIV src ; 无符号数除法<br />
• IDIV src ; 带符号数除法<br />
– 语法格式：<br />
• DIV reg/mem<br />
• IDIV reg/mem<br />
– 功能描述：<br />
• src是8位：AX÷src，结果商在AL、余数在AH<br />
• src是16位：DX:AX÷src，结果商在AX、余数在DX<br />
– 对标志位的影响：无定义<br />
– 若是8位÷8位或16位÷16位怎么解决？</p>
<p>符号扩展<br />
– 对标志位的影响：无<br />
– CBW、CWD（Convert Byte/Word to Word/Double word）<br />
– 语法格式：<br />
• CBW ; AL符号扩展为AX<br />
– (若AL为正数,则零扩展,若AL为负数,则扩展部分全1)<br />
• CWD ; AX符号扩展为32位数DX:AX<br />
– 【例】设AL = 0FEH，给出依次执行下列指令后的结果。<br />
• CBW ; ax = fffeh<br />
• CWD ; dx = ffffh, ax不变，即dx:ax = -2<br />
• 十进制调整指令（不要求）<br />
– BCD码的加减乘除</p>
<h2 id="逻辑运算类指令">逻辑运算类指令</h2>
<p>AND reg/mem, reg/mem/imm<br />
– OR reg/mem, reg/mem/imm<br />
– XOR reg/mem, reg/mem/imm<br />
– NOT reg/mem<br />
– TEST reg/mem, reg/mem/imm；执行AND操作但不存储<br />
结果<br />
• 对标志位的影响：<br />
– NOT：无。<br />
– 其它指令：CF = OF = 0，按一般规则影响SF和ZF `使某位变反，其余位保持不变：对应位异或1，其余位为0<br />
• 例： XOR AL, 60H ; 使第5、6两位为原来码的反码<br />
• 特例： XOR AL, 0FFH = NOT AL</p>
<h2 id="移位指令和循环移位指令">移位指令和循环移位指令</h2>
<p>一般形式：<br />
– SHL dest, count ; dest逻辑左移，count为移位次数<br />
– SAL dest, count ; dest算术左移<br />
– SHR dest, count ; dest逻辑右移<br />
– SAR dest, count ; dest算术右移<br />
– ROL, ROR循环左/右移；RCL, RCR带进位标志循环左/右移 对标志位的影响：<br />
– 移位次数为1时，若移位后符号位发生了变化，则OF = 1，否则<br />
OF = 0；若移位次数 &gt; 1，则OF无定义<br />
– 按一般规则影响ZF与SF。然而，若移位次数为0，则不影响标志<br />
位；CF为最后移入位<br />
• 参数规范：当count = 1时，可以立即数输入，否则需先<br />
存入CL中；count取值范围0~255<br />
• 【例】设AX的值为一个2字节非压缩BCD码，将其转换为<br />
1字节压缩BCD码存入AL。<br />
MOV CL, 4<br />
SHL AH, CL ; ah低4位移到高4位<br />
AND AL , 0FH ; al高4位清0<br />
OR AL , AH</p>
<h2 id="串操作指令">串操作指令</h2>
<p>目标和源都是存储器 (字、字节)<br />
– DS:SI 提供源，ES:DI提供目的，CX提供长度<br />
• 种类<br />
– MOVS（Move）传送<br />
– CMPS（Compare）比较<br />
– SCAS（Scan）搜索<br />
– LODS（Load）读<br />
– STOS（Store）写<br />
• 方向（DF标志位）<br />
• 重复前缀<br />
– REP（Repeat）<br />
– REPE/REPZ<br />
– REPNE/REPNZ</p>
<h2 id="程序控制类指令">程序控制类指令</h2>
<p>无条件转移JMP（Jump）<br />
• 一般形式：<br />
– JMP target ; 转移到target指定的目标地址处<br />
– 根据转移的距离，JMP指令可分为下列两类：<br />
• 段内转移：在同一代码段内进行，又称近（Near）转移，只要修改IP的<br />
值即可实现<br />
• 段间转移：可在不同代码段之间进行，又称远（Far）转移，需要同时<br />
修改CS和IP的值<br />
– 根据目标地址的指定方式，JMP指令又可分为直接转移和间接转<br />
移<br />
• 直接转移：是指转移的目标地址直接出现在指令中，在程序执行前就已<br />
确定<br />
• 间接转移：指转移的目标地址是寄存器或内存操作数的值，只有执行到<br />
该条指令时才能确定 – 直接转移<br />
• JMP [NEAR PTR] label ; 段内转移<br />
– 目标地址 = IP + label（2字节） ; ±32KB<br />
例：JMP ADDR1 ; ADDR1代表一个段内目标地址<br />
ADDR1与当前IP位移量1235H, CS=1500H, IP=2400H<br />
目的地址：18638H JMP SHORT label<br />
– 目标地址 = IP + label（1字节） ; -128~127<br />
• JMP FAR PTR label ; 段间转移<br />
– 间接转移<br />
• JMP reg16/WORD PTR mem<br />
; IP = reg16/mem16 段内间接转移<br />
例：JMP FAR PTR ADDR2 ; ADDR2代表一个段间目标地址<br />
ADDR2所在CS=6500H，IP=020CH<br />
目的地址：6520CH<br />
例：JMP BX ；BX→IP，CS不变<br />
JMP WORD PTR [DI] ；[DS:DI] →IP，CS不变 JMP DWORD PTR mem<br />
– ; CS = [mem+2]，IP = [mem]<br />
例：当前CS=1000H, IP=026AH<br />
DS=2000H, BX=1400H, ADDR3=020AH<br />
JMP DWORD PTR [BX+ADDR3]<br />
CS=4000H, IP=320EH • CALL过程名<br />
– CALL NEAR PROC 段内直接寻址（修改IP, CS不变）<br />
– CALL BX 段内间接转移（BX → IP）<br />
– CALL FAR PROC 段间直接调用<br />
• IP、CS都改变，例如：CALL 2000H:5600H<br />
• 返回地址入栈包括CS和IP<br />
– CALL DWORD PTR [reg16] 段间间接调用<br />
• 低字 → IP，高字 → CS<br />
– CALL与JMP区别<br />
• CALL调用时会将修改前IP（或IP与CS）入栈，且完成后会返回当前位置<br />
• RET<br />
– 要和CALL调用类型对应：RET（段内）与RETF（段间）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例】求AX累加器和BX累加器中两个无符号数之差的绝  </span><br><span class="line">对值，结果放在2800H单元中  </span><br><span class="line">CMP AX, BX  </span><br><span class="line">JB AA  </span><br><span class="line">SUB AX, BX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], AX  </span><br><span class="line">JMP STOP ;该句缺少怎样？  </span><br><span class="line">AA: SUB BX, AX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], BX  </span><br><span class="line">STOP： HLT</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例】从外设71H中取一个数M,判断其值是否在10和20之  </span><br><span class="line">间，如果M≥20，则送0FFH给外设73H;如果M&lt;10,则送  </span><br><span class="line">00H给外设73H;如果10≤M&lt;20,则送88H给外设73H  </span><br><span class="line">IN AL, 71H  </span><br><span class="line">CMP AL, 10  </span><br><span class="line">JNC LP1  </span><br><span class="line">MOV AL, 00H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP1: CMP AL, 20  </span><br><span class="line">JNC LP2  </span><br><span class="line">MOV AL, 88H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP2: MOV AL, 0FFH  </span><br><span class="line">LP3: OUT 73H, AL  </span><br><span class="line">HLT</span><br></pre></td></tr></table></figure>
<p>循环控制（短地址区间）<br />
– LOOP 目标地址<br />
• CX-1,如CX≠0,转移到目标地址（负值）<br />
– LOOPE/LOOPZ 目标地址<br />
• CX-1,如ZF=1且CX≠0循环（LOOPNE/LOOPNZ时ZF=0）</p>
<figure class="highlight plaintext"><figcaption><span>【例】求2个数组之和，每个数组长度为N。如遇到2个组</span></figcaption><table><tr><td class="code"><pre><span class="line">数元素都为0，则停止求和  </span><br><span class="line">MOV SI, -1  </span><br><span class="line">MOV CX, N  </span><br><span class="line">NEXT: INC SI  </span><br><span class="line">MOV AL, [ADDR1 + SI]  </span><br><span class="line">ADD AL, [SI + ADDR2]  </span><br><span class="line">MOV [SI + ADDR3], AL  </span><br><span class="line">LOOPNZ NEXT</span><br></pre></td></tr></table></figure>
<p>中断指令<br />
– INT 中断类型<br />
• 0-255<br />
• 中断向量表<br />
– 每种中断占4个字节<br />
» 前两个为偏移地址，后两个为段地址<br />
– 和CALL的区别<br />
• 相同点：断点入栈<br />
• 不同点<br />
– 清除中断标志IF<br />
– 清除单步标志TF<br />
– 标志寄存器入栈<br />
• 【例】 INT 20H<br />
– IRET<br />
– INTO 溢出中断（中断号04H）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">延时一秒</span><br><span class="line">START: MOV CX, 1000  </span><br><span class="line">DELAY1S: CALL DELAY1MS  </span><br><span class="line">LOOP DELAY1S  </span><br><span class="line">HLT  </span><br><span class="line">DELAY1MS: PUSH CX  </span><br><span class="line">MOV CX, 374  </span><br><span class="line">LP1: PUSHF  </span><br><span class="line">POPF  </span><br><span class="line">LOOP LP1  </span><br><span class="line">POP CX  </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<h2 id="类型">类型</h2>
<p><code>汇编流程   – 汇编源程序：用助记符指令、变量名和标号编写的程序。   • 文件名：\*\*\*.ASM   – 目标程序：机器能识别的二进制代码程序。   • 文件名：\*\*\*.OBJ   – 执行程序：为PC系统所接受的应用程序。   • 文件名：\*\*\*.EXE   • 工具程序   –</code> 汇编程序：把汇编源程序翻译成机器能识别的机器指令程序的工<br />
<code>具程序。   • 文件名：MASM.EXE   – 连接程序：把目标文件与库文件以及其他目标文件连接在一起。   • 文件名：LINK.EXE</code>汇编语言语句类型<br />
– 指令性语句——真指令<br />
• 实际的CPU指令<br />
• 汇编程序将其翻译成机器目标代码<br />
• 由四部分组成：<br />
[标号:] 指令助记符 [操作数] [; 注释]<br />
– 指示性语句——伪指令[伪操作指令]<br />
• 方便编制程序<br />
• 不产生代码<br />
[名字] 伪操作命令 [操作数表] [; 注释]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSEG SEGMENT PARA STACK ; 堆栈段定义  </span><br><span class="line">DW 256 DUP (?)  </span><br><span class="line">SSEG ENDS  </span><br><span class="line">DSEG SEGMENT ; 数据段定义  </span><br><span class="line">MESS DB &#x27;HELLO&#x27;, 0DH, 0AH, &#x27;$&#x27;  </span><br><span class="line">DSEG ENDS  </span><br><span class="line">CSEG SEGMENT ; 代码段(指令区)  </span><br><span class="line">ASSUME CS:CSEG, DS:DSEG ; 规定段的性质  </span><br><span class="line">START: MOV AX, DSEG ; 设置数据段基值  </span><br><span class="line">MOV DS, AX  </span><br><span class="line">MOV DX, OFFSET MESS ; 显示字符串信息  </span><br><span class="line">MOV AH, 09  </span><br><span class="line">INT 21H  </span><br><span class="line">MOV AH,4CH ; 结束本程序运行，返回DOS  </span><br><span class="line">INT 21H  </span><br><span class="line">CSEG ENDS  </span><br><span class="line">END START  </span><br><span class="line">汇编语言有若干个段  </span><br><span class="line">段名、开始、结束  </span><br><span class="line">唯一的END结束  </span><br><span class="line">定义起始执行地址</span><br></pre></td></tr></table></figure>
<p>表达式和运算符<br />
– 由汇编程序计算<br />
• 值<br />
• 地址<br />
– 算术运算符（7种）<br />
• +、-、*、/<br />
• MOD<br />
• SHL、SHR 逻辑运算符（4种）<br />
• AND、OR、XOR、NOT<br />
• 和指令助记符的区别<br />
• MOV AL, 0ADH AND 0EAH → MOV AL, 0A8H<br />
– 关系运算符（6种）<br />
• EQ、NE、LT、GT、LE、GE<br />
• 关系成立时返回0FFFFH，不成立时返回0<br />
– 数值返回运算符<br />
• SEG<br />
• OFFSET<br />
• TYPE • SIZE<br />
• LENGTH 属性运算符<br />
• PTR 修改操作数类型<br />
• THIS</p>
<h2 id="伪指令">伪指令</h2>
<p>数据定义伪指令（变量定义）<br />
– 数据定义伪指令用来为数据分配内存空间(规定变量的类型），<br />
并设置相应内存单元的初始值。<br />
– 形式：<br />
变量名 变量定义符 操作数, 操作数, ..., 操作数<br />
• 其中，变量名是一个符号地址，表示其后操作数的首地址，变量名为可<br />
选项，给出变量名只是为了按名存取其对应的内存单元。 变量定义符主要包括下列几种<br />
– DB（Define Byte）：定义字节，后面的每个操作数占1个字节。<br />
– DW（Define Word）：定义字，后面的每个操作数占1个字。<br />
– DD（Define Dword）：定义双字，后面的每个操作数占2个字。<br />
– 操作数可以是<br />
• 常数 例：DATA DB 10, 4, 10H<br />
• 表达式 例：DATA DW 2*3, 8/4<br />
• 字符串 例：DATA DB 'ABCD'<br />
– ？表示只保留内存空间，未定义初始值。<br />
• 例：DATA DD ？, 1, ？<br />
• 重复次数 DUP （操作数，．．．，操作数）<br />
– 例：DATA DB 3 DUP（？，9）</p>
<h2 id="存储器的分类与组成">存储器的分类与组成</h2>
<p><code>存储器分类   – 程序的执行是从主存中自动的取指令到控制器进行解释执行，需   要的数据也放在主存中根据指令需要存取。   – 按存储介质分类   • 半导体存储器：双极型，静态MOS型，动态MOS型   • 磁表面存储器：磁盘（Disk）、磁带 （Tape）   • 光存储器：CD、CD-ROM、DVD   – 按断电后信息的可保存性分类   • 非易失性存储器   – 信息可一直保留，不需电源维持（如 ：ROM、磁表面存储器、光存储器等）   • 易失性存储器   – 电源关闭时信息自动丢失。（如：RAM、Cache等） – 按存储器功能分类   • 读写存储器（Read/Write Memory)：可读可写   • 只读存储器（Read Only Memory)：只能读不能写   – 按工作方式/存取方式分类   • 随机存取存储器Random Access Memory (RAM)   – 每个单元读写时间一样，且与各单元所在位置无关，如：内存。   • 顺序存取存储器Sequential Access Memory (SAM)   – 数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置   有关，例如：磁带。   • 直接存取存储器Direct Access Memory (DAM)   – 直接定位到要读写的数据块，在读写某个数据块时按顺序进行。例如：磁盘。   • 相联存储器Associate Memory/Content Addressed Memory (CAM）   – 按内容存储与检索，根据内容访问存储位置并进行读写。例如：快表。 – 按容量/速度   • 寄存器   • 高速缓存   • 主存   • 外存储器</code>参数 – 存取速度：<br />
• 存取时间𝑇𝑎：指的是CPU从启动一次存储器操作到完成所需要的时间。<br />
• 存取周期𝑇𝑚：是指连续启动两次独立的存储器操作所需最小时间间隔。<br />
• 带宽（数据传输速度）</p>
<h3 id="读写过程">读写过程</h3>
<p>– 读<br />
• CPU先把读单元地址送到AR，经过地址总线送往主存，同时CPU通过控<br />
制总线发一个读请求，然后CPU等待从主存储器发来的信号，通知CPU<br />
读操作已经完成。<br />
• 存储器通过ready线回答，如果ready信号为1，说明存储字的内容已经<br />
读出，并放在数据总线上，送往DR。<br />
– 写<br />
• CPU先将写单元地址经AR送往地址总线，并把写内容字送DR，同时通<br />
过控制总线发出写命令，然后CPU等待写操作完成信号。<br />
• 主存把收到的信息字写入CPU指定的地址后通过ready线发出完成信号。</p>
<h3 id="只读存储器">只读存储器</h3>
<p>分类<br />
– ROM<br />
• 芯片的内容在制造时已经输入，只能读，不能修改。<br />
• 存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。存储<br />
元件：二极管或晶体管。<br />
– PROM（Programmable ROM, PROM）<br />
• 用户可根据自己的需要来确定ROM里的内容，常见的是熔丝式PROM<br />
是以熔丝的接通来表示1、断开表示0。常用于工业控制机。<br />
– EPROM（Erasable PROM, EPROM）<br />
• 紫外线擦除，只能对芯片进行整体擦除，而不能对芯片中个别需要改写<br />
的存储单元单独擦除。编程次数不受限制。 E2PROM（Electrically EPROM）<br />
• 电擦除，可以用字擦除方式擦除，也可以用数据块擦除方式擦除。以字<br />
擦除方式操作时，能够只擦除被选中的那个存储单元的内容；在数据块<br />
擦除方式操作时，可擦除数据块内所有单元的内容。编程次数受限制。<br />
– 闪速存储器（Flash Memory）<br />
• 一种快擦写型存储器，它的主要特点是：既可在不加电的情况下长期保<br />
存信息，又能进行快速擦除（整体擦除或分区擦除）与重写，兼备了E2<br />
PROM和RAM的优点。<br />
• 闪存的读取速度与DRAM相近，是磁盘的100倍左右；写数据（快擦－<br />
编程）则与硬盘相近。</p>
<h3 id="拓展">拓展</h3>
<ul>
<li>字扩展（位数不变、扩充容量）</li>
<li>位扩展（字数不变，位数扩展）</li>
<li>字位同时扩展（字和位同时扩展）</li>
</ul>
<h3 id="内存">内存</h3>
<p>解决内存访问速度慢的措施有三个：<br />
• 提高主存芯片本身的速度<br />
• 采用多模块存储器技术<br />
• 在主存和CPU之间加入Cache</p>
<h3 id="外部存储器辅助存储器">外部存储器（辅助存储器</h3>
<p>磁表面存储器<br />
– 两类：数字磁记录和模拟磁记录。<br />
– 原理：磁性材料沉积在基体上形成记录介质，通过磁头与记录介<br />
质的相对运动来读写信息。<br />
– 优点：<br />
①容量大，位价低<br />
②记录介质可重复使用<br />
③信息可长期保存甚至可脱机保存<br />
④非破坏性读出<br />
– 缺点：<br />
①速度慢<br />
②对工作环境要求高 光存储器<br />
– 记录原理：用激光在具有感光特性的介质上非接触地记录高密度<br />
信息，以介质材料的光学性质的变化来表示0或1。<br />
– 优点：容量大、可替换（便携带）<br />
– 缺点：速度慢。</p>
<p>寻址时间<br />
– 寻址时间包括两部分：磁头寻找目标磁道所需的寻道时间和找到<br />
磁道后磁头等待所需要读写的区段旋转到磁头下方的等待时间。<br />
– 平均寻址时间=平均寻道时间+平均等待时间<br />
– 平均等待时间与磁盘转速有关，用磁盘旋转一周所需时间的一半<br />
来表示。 数据传输率<br />
– 外部：磁表面存储器的缓存在单位时间内与主机之间传送数据的<br />
位数或字节数。<br />
• 单位bps。<br />
• 取决于总线的类型和标准<br />
– ATA、SCSI、SATA、SAS<br />
– 内部：磁头与硬盘内存之间的数据传输率。<br />
• 传输率=记录密度D x 运动速度V<br />
• 误码率<br />
– 衡量磁表面存储器的出错概率，等于出错信息的位数和读出的总<br />
信息位数比。 磁盘cache<br />
– 基本情况：硬盘内存速度差 (ms-ns)<br />
• 可采用增加磁盘主轴转速<br />
• 提高I/O总线速度<br />
• 改进读写算法<br />
• 采用磁盘cache等方法<br />
– 缓存的大小与速度是直接关系到硬盘的传输速度的重要因素。<br />
– 主流硬盘的缓存8M以上（有些甚至1G）。<br />
– 类型一般是DRAM或SDRAM。<br />
– 采用预读策略（局部性规则）：对顺序数据特别有效<br />
• 视频数据<br />
• 图像文件 磁盘阵列存储器（RAID）<br />
• 廉价冗余磁盘阵列（RAID）是用多台磁盘储存器组成的大<br />
容量外存储子系统。（Redundant Arrays of<br />
Inexpensive Disk）由美国加州大学伯克利分校提出。<br />
• 目的<br />
– 组合小的廉价磁盘来代替大的昂贵的磁盘，降低大批量数据存储<br />
的费用；<br />
– 希望采用冗余信息的方式，使得磁盘失效时不会使对数据的访问<br />
受损失；<br />
– 能适当的提升数据传输速度。<br />
– 保证数据的可靠性和高可用性 RAID的实现<br />
– 专门的控制芯片来完成<br />
– 用软件的方法来实现， RAID 0级（无冗余和无校验的数据分块）<br />
– 将连续的数据块分别存放在不同的磁盘上。具有最高的I/O性能<br />
和磁盘空间利用率，无数据冗余，无容错能力，不能应用于数据<br />
安全性要求高的场合。<br />
• RAID 1级（镜像磁盘阵列）<br />
– 由磁盘对组成，每一个工作盘都有对应的镜像盘，上面保存着与<br />
工作盘完全相同的数据，安全性高，但磁盘空间的利用率只有<br />
50% RAID 2级（具有纠错海明码的磁盘阵列）<br />
– 采用海明码纠错技术和位交叉技术，用户需增加足够的校验盘来<br />
提供单纠错和双验错功能。当阵列内有G个数据盘时，则所需的<br />
校验盘数C要满足公式： 2𝐶 ≥ 𝐺 + 𝐶 + 1，如果有4个数据盘，<br />
则需要3个校验盘。对数据的访问涉及到磁盘阵列中的每一个盘，<br />
对大数据量传送有较高性能，但不利于小数据量的传送。RAID<br />
2很少使用。 位交叉存取<br />
– 将一个数据段中的各位分别存储在不同的磁盘上，以同步方式进<br />
行读写，最小访问数据单位是每个磁盘的最小读写单位（例如扇<br />
区）X磁盘数。<br />
– 适合传送批量数据<br />
• 块交叉存取<br />
– 以数据块为单位，将连续的数据块分别存放在不同的磁盘上，最<br />
小访问数据单位是每个磁盘的最小读写单位（例如扇区）<br />
– 适合传送少量数据 RAID 5级（无专用校验盘的奇偶校验磁盘阵列）<br />
– 无专用的校验盘，将校验信息分布到组内所有盘上，对大、小数<br />
据量的读写都有很好的性能，因而是一种较好的方案。<br />
• RAID 10级（RAID 0级+RAID 1级）<br />
– 由分块和镜像组成，是所有RAID中性能最好的磁盘阵列，但每<br />
次写入时要写两个互为镜像的盘， CPU占用率高，磁盘的利用<br />
率低 磁盘存储器与光盘存储器的比较<br />
– 两种存储器的记录原理、组成部分等方面都是相同的。在计算机<br />
中它们各有自己的特点与功能。<br />
– 硬盘驱动器<br />
• 容量大、数据传输率高、等待时间短。<br />
– 光盘驱动器<br />
• 存储密度高、容量大、价格低。但是光盘与主机的速度不匹配所以不能<br />
作为中间存储器，即不能替代硬盘 <img src="/images/obsidian/20230610145852.png" title="image" alt="图片" /> 为什么这种层次化结构是有效的？<br />
– 时间局部性（Temporal Locality）<br />
• 含义：刚被访问过的单元很可能不久又被访问<br />
• 做法：让最近被访问过的信息保留在靠近CPU的存储器中<br />
– 空间局部性 （Spatial Locality）<br />
• 含义：刚被访问过的单元的邻近单元很可能不久被访问<br />
• 做法：将刚被访问过的单元的邻近单元调到靠近CPU的存储器中<br />
– 大量典型程序的运行情况分析结果表明：程序具有访问局部性特<br />
征<br />
• 指令：指令按序存放，地址连续，循环程序段或子程序段重复执行<br />
• 数据：连续存放，数组元素重复、按序访问</p>
<p>• 键盘<br />
– 键盘是一组排列成阵列形式的按键开关，按下一个键就产生一个<br />
相应的字符，然后转换成ASCII或其他码送往主机<br />
– 键盘输入信号处理可分为三个步骤：<br />
• (1) 按下一个键；<br />
• (2) 查出按下的是哪一个键；<br />
• (3) 将该键翻译成能被计算机接收的代码<br />
• 键盘的种类<br />
– 机械式键盘<br />
• 触点的导通或断开<br />
• 每个键由底座、轴帽、轴帽固定卡、弹簧、金属支脚、触点金属片 导电橡胶式键盘<br />
• 通过导电的橡胶实现触点的连接<br />
– 电容式键盘<br />
• 当人体（手指）接触金属感应片的时候，由于人体相当于一个接大地的<br />
电容，因此会在感应片和大地之间形成一个电容 薄膜式键盘<br />
• 无机械磨损<br />
• 低价格<br />
• 低噪音<br />
• 低成本<br />
• 市场占有相当份额 • 鼠标<br />
– 一种坐标定位部件，只能用来输入相对坐标。 • CMOS传感器将每一幅图像都发送给数字信号处理器（DSP）进行分析。<br />
• DSP检测各图像中的图案，并分析图像中图案的位置如何变动。<br />
• 根据一系列图像中图案位置的变化，DSP确定鼠标的移动距离并将相应<br />
坐标发送给计算机。<br />
• 计算机根据从鼠标接收到的坐标信息，移动屏幕上的光标。<br />
– 与轨迹球鼠标相比，光电鼠标具有下列优势：<br />
• 没有可移动的零部件，这意味着磨损更少、故障率更低。<br />
• 灰尘无法进入鼠标内部并干扰跟踪传感器。<br />
• 增加的跟踪分辨率意味着响应更顺畅。<br />
• 不需要鼠标垫等专用表面。 触摸屏<br />
– 电阻式：利用压力感应进行控制电阻<br />
– 电容式：利用人体的电流感应进行工作<br />
– 红外式：在显示器上加上光点距架框，在屏幕表面形成一个红外<br />
线网<br />
– 表面声波触摸屏：玻璃屏的左上角和右下角各固定了竖直和水平<br />
方向的超声波发射换能器，右上角则固定了两个相应的超声波接<br />
收换能器。玻璃屏的四个周边则刻有45°角由疏到密间隔非常精<br />
密的反射条纹 条形码（Bar Code）<br />
– 由一组宽度和反射率不同的平行相邻条和空按预先规定的编码规<br />
则组合起来，用来表示一组数据的符号 主要类型<br />
• 堆叠式/行排式<br />
– 建立在一维条码基础之上，按需要堆积成二行或多行<br />
– 继承了一维条码的一些特点<br />
– 需要对行进行判定，其译码算法与软件也不完全相同于一维条码<br />
• 矩阵式二维码<br />
– 它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码<br />
– 用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制<br />
的“0”，点的排列组合确定了矩阵式二维条码所代表的意义 显示器显色原理<br />
– 像素点：颜色显示的最小单元<br />
• 一个像素点包含三原色<br />
• 通过调整三原色的显示强弱来控制颜色 CRT<br />
– 可用于字符、图形和图像显示器。<br />
– CRT是一个真空器件，由电子枪、偏转装置和荧光屏组成。<br />
– 玻璃屏内壁涂有荧光粉，它将电子束的动能转换成光能，显示出<br />
光点。不同的荧光粉在电子束的轰击下发出不同的颜色。<br />
– 对电子束的要求<br />
• （1）电子束要有足够的强度和速度。<br />
• （2）电子束要足够细。<br />
• （3）电子束的运动方向要高度可控 有机发光二极管（OLED）<br />
– 自发光的二极管，无需背光<br />
• 等离子显示器（PDP）<br />
– 利用惰性气体在一定电压下产生气体放电现象而实现的发光技术。<br />
• 显示技术的重要技术指标<br />
– 分辨率<br />
• 字符显示方式<br />
– 一屏可显示的最多字符数称为分辨率，例如80列×25行，表示每屏最多可显示25<br />
行，每行可有80个字符。<br />
• 在图形显示方式<br />
– 一屏可显示的像点数称为分辨率，例如800×600，表示一屏可包含600条水平扫<br />
描线，每线可分为800点。<br />
• 分辨率越高，显示的信息越多 颜色数（位深）：每个像素点可显示的颜色数（灰度级）<br />
• 每种原色由8位表示灰度，三原色共计224种颜色<br />
• 实际传输过程中采用32位表示一种颜色，而高端显示器每种原色用10位<br />
表示，总共可表示230，约10.7亿色 按打字原理分：击打式打印机（点阵针式打印机）和非击<br />
打式打印机（喷墨打印机、激光打印机）。<br />
• 按工作方式分：串行打印机和行式打印机。串行打印机一<br />
次只能打一个字，行式打印机一次可以打印一行<br />
• 常见打印机类型<br />
– 点阵针式打印机<br />
– 激光打印机<br />
– 喷墨打印机<br />
– 热转印和热敏打字机<br />
• 发展趋势<br />
– 击打式和非击打式并存<br />
– 击打式的多样化、特殊化：银行、铁路、超市、酒店</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>计组</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>苏州大学</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏简评</title>
    <url>/2023/09/30/%E6%B8%B8%E6%88%8F%E7%AE%80%E8%AF%84/</url>
    <content><![CDATA[<h1 id="被封锁的涩谷">428被封锁的涩谷</h1>
<p>希腊神话将命运女神履行职能的过程写作织网，这无疑是一种极为贴切的比喻，对网状结构来说，在中心处的轻轻一拨，边缘处就是极大的震动，越是深入核心，就越是复杂，但所有分支无论看上去多么没有规律，最后都会收束到中心网点，我想这就是428的编剧想实现的叙事结构。 <span id="more"></span> 这样的结构需要极致的严谨和巨大的工作量，正如正统的本格派推理一样丝丝入扣，同时还要维持各个部分的信息量尽量均布，各个网点处都有关键悬念留待读者，但，他们做到了，7位主角的命运与城市里大大小小配角的命运，就这样纠缠在一起，并收束到了一个巨大的阴谋上，更令人称奇的是，尽管使用了这样的结构，制作组仍然做到了悬念的均布，几乎没有出现信息量失衡的情况。 于是，玩家得以在4月28日的涩谷当一天的命运女神，只要在一个个节点上轻轻拨正些许紊乱的蛛丝，蛛丝就会自然而然地化为网状，事实上没有我说的这么轻松，因为这些命运的线条起初似乎是绕成一团，理清它们的过程也少不了误解和错误。 为了确保这个过程的顺畅，85个bad end大部分都有提示，以每一小时为节点，只有理清一小时内的所有事件，命运才能向前推进，起初似乎是一些不成规律的线，但逐渐就开始交错，纠缠，而作为有着神力的玩家，只需要制造一些偶然，改变一两个小小的决定就能够造成一连串的蝴蝶效应。 对这种操控命运的讨论很容易回到一些宿命论的思潮上来，幸运的是428的编剧在这个方面却有着很积极的态度，于是在结局，命运的线条汇聚在一起，无数偶然交错下，产生的必然却孕育着希望，尽管多少有些日式的大团圆味道，但流露出的价值观确实积极的。 如果说这样精巧的叙事结构有没有问题，那么当然也是有的，叙事必须依靠逻辑的支撑，如此庞大的网状结构，逻辑当然不可能天衣无缝，事实上依然有很多巧合和偶然，为了配合结构的需要，甚至部分主角也免不了当工具人，但你很难对此苛责什么，通过有限的角色实现如此复杂的剧本，不免要让一些角色承担过多的推进剧情的作用，相对来说编剧已经做得很不错了。 此外的问题是大部分日式游戏难免的幼稚气，叙事结构是精巧且充满悬念的，但一些抒情节点，以及一些过度夸张以至于模板化的人物性格，依然为其减色不少。不过我也能理解编剧，毕竟这种精密的结构确实很难填补完全恰如其分的内容 总的来说428在叙事结构方面可以说是当今电子游戏的最高峰水平，尽管它的其他部分可能只是优秀或者不错的程度，依旧是一款剧情类的神作</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>其他游戏</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>爱丽丝的回忆</title>
    <url>/2023/09/28/%E7%A7%98%E5%AF%861/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励" data-whm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励">
  <script id="hbeData" type="hbeData" data-hmacdigest="543fd046137c8fa1c8b07df68a2d3e4996dc13f1f06543c0a85a8c2d979be9fb">13aef8e3a4d2474cb9cd233c644c735c7ce62820bf86f805363ad09d940c013f15e271153cdb8f8975b916cf9d1be65d1dfd56bed1f75e0cce9bc945d854b7df8b1c35b68bed377064d0601e6bfe625ae7d8cd2d3736700c00508d2a6a645e1fe125eef8e2f3bb6e5e8dd040b3807272144439ea1b98d0662ba7d17b1d51b57b45bc4137781e59a0b0a63914ea0d85fc7833fc370356cf12132dc520ace76a00a3708e886451d4cf00eddb280dc9aec3b0387f05c42217a6a20147657c6c490310d479384dfc83571b3c46d5c54ca1cd6a00f36b4696ad48a35d03b23bebbd04c64087855bdc7744308770d82e7cd5edb9de0b92eb25bce1a53f4df417ec79d3c8310a88a04574986dcb2484596d5cd0fc89d22dfc95bd5a5add453edd098362f7ef79b135fe0d1b6bd38ab6a21a97c164f7113dce2e86146681550f7897d39779664588967f71287a755297d00061e098572eafcc3305825b27a83a959f71231d8d50268e3a4ba19f418ae502f72553b06af133618a0df82afecbb08f7f9330c84ed3701266cf82bb4fe298b6fb1f1014b4b72b4c9a8562c108eaa8524ad87daab1d90435b2530f5457a881ccac1177e2492f1481c13f400b89544d1fcdb077da7870d89112cd0c7ada9893a0d111e0a84c7b0710ac269a6410556d1ed0c4fe7cb73d2d948df72adad33d70eb1fcb11df29db5a7d31a604181586212f1deb4524761fa3f2da7a8b9a988088b20de28cdceb1759247f421ea5a190910eb1e4208f03fcc01a55ff418a24a7b3c716bb752e1f04ba63766309dd7c56be1bd3c483f49b643d3285c017292fabef71a394f2883add4d8cfeadb05b0fe164eeb3c13242b397162a0f75e142d79f2169e199bb48f8f018789ca402b8c513b395b9f96ce8da364b792a9d68e22ad09b245b564547f1bacf3bf09f6e7a5fcfff9ef9534a9d6b283a65e9ee1689ffe8a528c48f4154f5ade68f755dae38be49c96889ec92712ec3967dfa9e3c03bf838ecbba5f696863b4331e1c3a8b3b527909eb65814292b0a14d7d39ab880524800beb88d573abbd380c644c3d537c0d30a621b2f2ed7199a507b2063d11abf4bb2102644321d8b446df028990b961f66d5056f5a56126c3a9a0986ef86f0475103e696a2444a65c7472409150c610dc82c90db2d5e55706f9236e37a8241b01233b7ff6caad0e44e6581497927676df920f468c83046e53cc402b14d8f53067955f8e3a1aa03996fa4cfb05136669439b388f988d91b37c77e1f1d45df960bf533c49d6afb9775e769039a649fe4c74ddc7089c04fc4a390fb690548585e3c8c23275fbc898b4c5b76b6d94cfd59d34d7a3fa83622e285f93fe5f3580b9becf16be588db16c6718a800a7d2873886f7f7b5efeabbde77a8595afdb9967e490376d3855be3fead1aeef75510179f131e3c3ba05f64ed43bf8a3488ccb59211d5815ab80fd75fa42ab8b49e7fe817222926c50c24706e40a98f49af88489b61c7eff618f94a10263ab98aefa3657f2f4a3d88d046dbfff536b5fea6371bf6938f8ed2e0c9ad00a0805761c36794579a92088a5b39d2bc08425a75f06840e4589772fa1877c6b834658735ce0ad02ea83662b189ba5157449b867d3fb77d97ce16ba7a392798b90b7711353d8037c5d0b76844fae99c476b145c90f4e77319cdc1788455777890c68ce930779f02602169f067e1f370586cb783a9bb5664dafec9c2d84cb8a3e817a07689bc2d4c25cb4718fb72e0858d85419bafac9bc8324681d299ad4ff9c80bd3be62eb163ca386bee0de34c6d1bca7761c8a4ed367ea4d775521c38243a7bcdc8c0775ecc217656aeebc79e0fa6d03fb268af6cc8d2b503b841f28f4389fa86f3b641650da6f3b85a6cb0c0976a99d920557527e1d2fbdbc5aeb75149a6130ade4672215792efbfcdd411524ceaa3077ab95a002b797508db009f3a5fbc60d39f3a25681cd2f51590e5a762f7c9a314333d8cc479da2c1c02c3f79cecd397f589491c01c302b35a4ddd5d1b4e50d393ab633756498e8ebd939bd6821965bda730f8f9a60ad42e68957e879a11104bfceb6ad2584534ddd8273dc29a5b7eb4f8d736775b8038db6880dce1431a620c766f338cad75751c40ad37f6cf3f4c15d8cd95577f8e2fa998975323c229ec44d9943a89d07016ccb666301e763f5b609ba469c1c0ef470c746c53bb27fae87a5eaef33e59e16d37cef076052f40a779661a0970ac93650b62c822fe8297c1be4658736e2c5b54388d61322934a651091953b39e581599baac297a24cb5b90bd022e5c608d4ec955c180d39ffe949b5b4eab51e05533921ffdbbd2d7c2ef410f68a431ae8c3f710329eb3abc97bfa24aaca2112216e6749acf4cfe1148c4cabc184871b625ffa93dc1fd83aa08fc4fa851b6886a431a37b7b55a8629bd2627b1e9c0daa32771657b36122a1d2d2481e2607979f69ae46d2b68793a0e0750be9c940de1688671c18734b7f5e5037b3351f78151d7f449ef0a6438bf1684e2c683c6898ad8ea946cd1d45a724036c6c032fd3c7edd7df36023154f2f03cf2d7947a1bd2c4d97c651f5b152906a8749389a6c2768c7ce393abdb686426f9d5d92b01ccad9624c8e450e97fd23037c9aee3d4afa6fac8ea2f6768c7d2183d1fe641584cd91b4a034b49224b82bf7b29b2d00f8016c47adc24bb5fddbed7421749aa6b8e6750cd4976b539b400af772172cb345cdd09a2c6404704d8402eddadee667656e51aa3875032ac413b24845356f13c2620d870a00bf64882c0a04c8993775c93c1a02c33cc86843ccab646ff37af4ef8d502aa41077b3960140178db22f22940ac05ce84f758358a58f5aaf84b48fd5b0bc61068cc09f3a16715cc78d2d3850389828e7736590dca50fec0a8007bfb9af2baf2efd6fc1eb25a3e3772c5d48acf7f8fe5acfd9ef6228a04c425df481f0b03e67a326d0565acf49609a40a107e33b67ea1637726d1bd1e15dab8292c917ca990c4040511da6740cc44851b1124ff1f1624f79b9eecd40d2ce1c44f1b5d8db3ad95b666dd3a9ec8851b03b464100b44e6d4fbab61bbbb5531bcf38f920280c6fd7b0c1a37dc3ee591f9a93971b455017ad23ca2386506d3b2f323b2e2f6670a29754abe5abe11d8ca6eeb2624a31cece65c6efc9b56c8621ff6bb705915415ce405105aeb3aa2757bda8a7862d182dbf2174212581c53afb09c7c030a28f23d84630b31e91140734ba46ad42ed8b1f19d25626c720d74a84a5f79d89ad74d7b45c8a14a8383e6243fbfa2b248949ec758251e913a07aaafe02b214caeb76c56a0c2805e85a0a1317199ea987724d26268221f7aa925f387b42e6b1246b2ca730c362fd695a94fa5dc6ef6335c0985b8e3fd8501cb6f099b6211b2336e119821f12957f428af23105a41d714a0db02d93aa6d07f23f3df80771c883f99244f5d3e256bd089a98c5bee66f7ddc84151f0e22edec42a98bf6fd899bbffce85c9d5810ff82d560d0ae4191a04f30f7671659f77f706ce44f6bb3589e447d71fd7bd63d8947e23337f96c11f3cc35116e5261086c1de2aa67ecfa761b980b20edc78e7b824b42de65a69350b1e22c8a0b30c7d0f43fec0c5de7d24da964acd70c83762fa67d7cc27c3fa6f354a3a8f678c6c425a0387fb80762397ca636f6d5432812c40c63466acddcb0cb877673b953a2c01de9365d266293d760afa23fcf4406fb29390b810b25d9ac7b7c16b5212a62d8c7f7881a7227b1ba3d1d1dddef6e36535b89f3bf0de7793c78c39b0181e8eb8cc82eaa8bced6dc94faa9309f50043530b0de4c6d194b17e0c20ea026abbc4fbf82d91c9631c3cbbc64ce94b0a72220578d0f7416978c6abcaff121879086bff3611199174ae66286623c722c3f2eea6b74b2cd0db95afd732fd179d3afff7ef1df7ff64573a1dbc397032ed619e4621afac52ca43637c0dcd5a4b53a6232dcce3401475dd93190205e546e8227ecdd7c4a7ba5db04729d22153f53f92d117f60501c8cec81c280d61346967028136e43f1651f695554b9093b73951310a73ce9ea21b2679fc977c9f6b51a57b89f68e5f0998bffedc73cb61134b3e011ad174996dcd5f056efc8f2d73015f9d6ff6cf416e732edb19fca5bdcc1cc57002f52add83dde639ea9a5d07e2f0f9ffc76332c80782607f0cc28ba90d92844cac1c96a2c128abb602bd774778e781d10559b7fd6fbd3d585f41bb70897d932b7097465ddfa38bc95342db7087b80ef494b4bf805c0bd023726ab53e095eef1b9fb35db62bdabc05d6801c7b2819261b6c6417db85527dbd33157833d30047c54a12d7f629727f82e5bf227da3a613c4030193e684397bca2a2c349ac834f30f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">摇曳着苦闷光辉的火焰在跳动着……心爱的少女，她诞生的时日是？</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>秘密</category>
      </categories>
      <tags>
        <tag>秘密</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉世界观设定集</title>
    <url>/2023/09/29/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E4%B8%96%E7%95%8C%E8%A7%82/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生……</span><br></pre></td></tr></table></figure>
<p>这是邪神辛克莱温教徒传颂的创世神话，也是目前为止我们所知最早的创世神话，可以说后世诸多关于创世的传说都有它的影子。 <span id="more"></span></p>
<p>邪神辛克莱温的信徒有着自己的语言，这种符号文字晦涩难懂，虽然给传播教义造成了困难，却成为维系着邪神教绵延几千年信仰的纽带。 邪神辛克莱温是……</p>
<p>——选自帝国学者载丝莉《邪神起源探究》</p>
<h2 id="克雷多斯族">克雷多斯族</h2>
<pre><code>      平庸是进化论所给我们最后的仁慈——帝国医学教科书扉页</code></pre>
<p>奥诺斯是社会达尔文主义者的神，他的教义就是物竞天择，适者生存，让优秀的种族淘汰低劣的种族。放到现在他肯定会被当做邪神。奥诺斯创造过很多种族，大部分在穷兵黩武中走向了灭亡，然而其中有一个民族最为他所垂青——克雷多斯族。这一种族刚出现时平平无奇，但他们的眼中只有强者，尊严的力量促使着他们不断发挥着潜力，追逐着比自己强大无数倍的敌人。他们逐渐走向强盛，但后来因为自相残杀导致族人寥寥无几。这时，一位天才创造出了一种把他们一分为二的方法，以此来把自己当做对手，起初，克雷多斯族凭借这一方法几乎成为世界上最令人恐惧的种族，深深地让奥诺斯感到自豪。然而，在与自己的斗争中，有的族人学会了“阴谋”，将另一个自己与其他敌人算计致死，有的人学会了“隐忍”，进而学会了妥协与认输，最终，他们都选择了“平庸”。为了心爱的子民惋惜不止的奥诺斯神来到了最后一个保持着绝对尊严的战士面前：</p>
<p>“我也给予你选择平庸的权利。”</p>
<p>“你要我变得和他们一样吗?绝不！！！”</p>
<p>战士怒吼着冲向了最后一个对手。从此，奥诺斯和他的战士消失于迪瑞克拉世界。</p>
<h2 id="沉默峡谷">沉默峡谷</h2>
<p>沉默不是逃避，而是一种选择——沉默沼泽路牌上的涂鸦</p>
<p>沉默峡谷被命名并正式标在官方地图上是帝国历387年的事了，在此之前它只是个普通的荒凉之处而已，当然，还是偶尔进入的旅客发现这里——但他们有的没能走出来，有的在出来后被别人或自己当成了疯子。</p>
<p>沉默峡谷的土壤和两侧的山岩有种特殊的性质，能几乎把所有的声音消除，巴比伦塔的学者曾对此展开研究，然而他们一无所获。除此以外，沉默峡谷就是个普通的荒凉峡谷，稀疏的杂草养不出大型动物，对一个经验丰富的旅行者而言，找到水源，辨别方向和驱散毒虫都不算难 ——只要他能忍受无尽的沉默</p>
<p>在被载入地图后，这里逐渐成了修士的圣地，当然，也有人进去后再也没有出来</p>
<h2 id="幻影沼泽">幻影沼泽</h2>
<p>警告！魔术师慎入！</p>
<p>这是沉默峡谷一处著名的景点，和峡谷本身一样，这里也几乎没什么异常，对有防备的旅行者而言并没什么危险。传说中一位善于擅长表演幻影魔术的魔术师来到这里时，将自己当做了幻影，而把幻影当成了真实。于是他迷失在这里，将此处化成了一片沼泽，如果一位有真才实学的魔术师来到这里，那么他绝对无法精神正常地离开，尽管对其他人而言，这里能看到的异象仅仅是偶尔出现魔术师忧郁的身影而已。</p>
<h2 id="沉默王国">沉默王国</h2>
<p>………………………………</p>
<p>沉默王国一直是个传说，一开始只是有少数人怀疑那些进了峡谷再没有出来的人到底去了哪里？这些怀疑逐渐被时间埋葬，直到帝国标记了沉默峡谷的存在导致一批旅行者来此游览，，有些旅行家发现了沉默王国的存在，很难想象一个王国会存在于荒野，事实上，那里只是寥寥几个人的聚居处。住民们给了旅行家一些食物和饮水，并为他指明了道路，从始至终，他们都带着沉默，从未试图张开嘴唇过。</p>
<p>此后又陆陆续续地出现了类似住民目击报告，但都被帝国封锁，最终，这一切成为了传说或是怪谈，奇怪的是，帝国似乎对此颇为忌惮，从此以后沉默峡谷再也没有出现在官方文件上过。</p>
<p>我们认为那些住民的存在涉及了达瑞克拉世界的源论，可以肯定那是一些向往沉默的人，不知何时他们聚集起来，用各自的思虑创造了一个无声的世界——或许跟0号研究所揭示的结果一致，这十分危险，一旦被人们知道，达瑞克拉世界或许会因此毁灭。</p>
<pre><code>                                 ——《关于沉默王国的报告》</code></pre>
<h2 id="号研究所">0号研究所</h2>
<p>我思故我在，我在故我思。——帝国哲学家卡尔迪</p>
<p>0号研究是科学组织浮士德所进行的一场实验，没错，与大多数我同事的想法相反，它并不是个邪教组织，从同行的角度来说，我很佩服他们的开创性。</p>
<p>0号研究所本是个普通的小镇，如果不是那件事的发生，我们永远不会知道这里曾发生过这样的实验。</p>
<p>帝国的审讯所抓到过一个浮士德的高层，今天他们终于设法让他开口了，由此我们终于知道他们是怎么进行实验的。首先，小镇只是出现了一些以屠戮人民，掠夺财物为乐的人，他们穿着迥异的衣服，却意外有着纯正的当地口音，经过一番协力，这些人不久就被送上了断头台。</p>
<p>奇怪的是，他们面对死亡毫无畏惧，自称“玩家”的他们发出了下次进犯的预告，然后在断头台上化成白光消失了。</p>
<p>当天，一切有关他们的消息被政府封锁，几乎同时不少“智者”跳了，要求让民众得知真相，惴惴不安中，很多小册子在民众中传阅——上面说这个世界只是虚构，完全为了让那些玩家取乐而存在（至于为何能让民众了解虚幻的概念，或许浮士德的教育机制还是挺有成效的）</p>
<p>第二天，更多所谓的“玩家从天而降”，所有住民都陷入了绝望与怀疑，就在这时我们所知的异变发生了，没人知道这是怎么做到的，但整个克罗利安镇就这么化为一片混沌之地，我们的不少调查员在第一眼看到它的遗址时就发疯了——我们没人知道为什么。</p>
<p>现在那里应该已经封闭了，我的建议是，永远封闭下去，或许邪神辛克莱温是对的，这个世界确实由我们的思想决定。我希望所有人都能对此提高警惕，永远不要让类似的事故重演</p>
<h2 id="帕斯卡王国">帕斯卡王国</h2>
<p>世上哪有不建立在剥削上的幸福？</p>
<p>帝国前36年，在正片大陆一个名不见经传的角落有一个小国，这个国家物资贫瘠，人口稀疏，尽管气候不算恶劣，但人民常常处于食不果腹的状态。</p>
<p>国王帕列斯是位平庸的君主，他的儿子——王子恩西斯却是位有想法的年轻人，尽管刚刚成年，他已经开始思索如何壮大自己的国家，这位王子曾经游学诸国，每次看到国民因营养不良而矮小纤弱的身材，他都会在心中发誓一定要找到让子民过上幸福快乐生活的方法</p>
<p>有一天，他带着这个愿望，带着几位侍从出门远行，在一番艰难跋涉后，王子在荒野中迷路了，他仿徨了几天，终于有一天他发现了一个村落</p>
<p>这个村落贫瘠弱小，王子注意到他们大量以烤制生肉，野菜，甚至昆虫而食，他们没有国王或者地位高于其他居民的人，尽管如此，他们的脸上却常常洋溢着笑容</p>
<p>王子作为外来人并没有对这些野人产生太多影响，于是他也学着野人的样子，用茅草和树枝搭起简易的居所，尝试融入野人的生活</p>
<p>一个月后，当国王派出的宫廷军顺着王子迷路时留下的标记找到他时，王子正喃喃自语道：我要找到的道路，就在这里啊</p>
<p>归国后几月，王子继位成为了国王，他实现了自己的诺言，在他的治理下，他的子民过上了物质丰富，精神充足的生活——凭借着王子制定并实现的驯养土著成为奴隶的方法。建立帕索斯帝国后五年，王子临终，面对伏在病榻前痛苦的子孙，他淡淡地说：他们以前就没有国王，以后也不会有吧。随后他保持着沉默，任凭御医记录他由有到无的脉搏直至最后</p>
<p>帝国历364年，历经三百年的不懈斗争，萨曼人杰出的领袖终于为族人争取到了自由，帝国，这一最先实现奴隶制的国家，最终成为了民主共和的起源…… ——《帝国通史》</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉世界观轶事集</title>
    <url>/2023/09/29/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E8%BD%B6%E4%BA%8B%E9%9B%86/</url>
    <content><![CDATA[<h2 id="泰特斯">泰特斯</h2>
<p>正如童话故事常见的开头一样，泰特斯是个贫穷而有志气的青年，有一天当他在王国的大街上闲逛时，他遇到了公主的轿子，年轻的泰特斯对美丽淑慧的公主一见钟情，他下定决心一定要当上王国的驸马爷。 <span id="more"></span> 当时开国皇帝恩西斯去世没有多久，年轻的皇帝卡奥斯也是为年轻气盛的青年，泰特斯认为这是成为皇帝亲信的好机会。</p>
<p>当时无权无势的人想要上位有两种办法，一是参军博得战功，二是进入帝国大学谋求文官职位，泰特斯身体虚弱，而且厌恶战争，但却有个不错的头脑，于是在他刻苦攻读下终于进入了帝国的最高学府学习数学，十年后，泰特斯已经是位小有名气的数学家了。</p>
<p>新帝卡奥斯是个奇怪的皇帝，他不甚喜欢锦衣玉食,也不爱美人或者诗琴书赋，唯独对数学很感兴趣，帝国的数学家往往是些老古董，唯有泰特斯名声卓著，血气方刚，二人一见如故，泰特斯如愿以偿成为皇帝的亲信。</p>
<p>卡奥斯将各项赋税与各种工程的设计实施交给了泰特斯，结果无不让他满意，为了表示对泰特斯的欣赏，皇帝决定将自己的妹妹嫁给他。</p>
<p>当公主府的使臣带着婚书拜访泰特斯时，他礼貌而不失坚决地回绝了，此时在他看来任何不懂数学之美的人都是庸俗的，除了数学女神的青睐，他对任何女人不屑一顾。</p>
<p>当然，这件事传到了皇帝的耳朵里，同时传导的还有群臣的议论，皇帝敏感地察觉到在大部分人眼中泰特斯才是帝国最聪明的人，心怀不满的皇帝半强迫地让公主嫁给了泰特斯。当然，皇帝并不无情，否则如果他将所有比他强的数学家都杀了，那么帝国早就没几个大数学家了——要知道他的水平只是二流的</p>
<p>为了自己与泰特斯的安危，贤惠的公主规劝丈夫，聪明的泰特斯恍然大悟，从此以后他收敛锋芒，沉迷于公主府奢华的生活，最终，他与公主幸福地生活到了最后。</p>
<p>泰特斯关于数学研究的遗著于共和历11年首次出现在公众面前，最后屡经辗转进入了共和国首都博物馆的展馆</p>
<h2 id="黎明">黎明</h2>
<p>外交官是位三十出头的年轻人（就他的职位而言），一个月前，他被尊贵的皇帝陛下召见，并被赋予和葛雷氏族谈判的任务。他精于谈判之道，自从帝国决定用经济而不是武力的手段来征服那些遮布隆（帝国语，未开化的人）他变成了谈判桌上最可怕的对手，有人说他的鹰眼能轻易看穿对手的心理底线，有人说他的眼线分布各地，实际上，在外交官的心中，他的才能无关轻重，仅仅是帝国的威亚所致罢了，在早先的黑暗岁月中，遮布隆大多被帝国的屠杀，谎言与掠夺打败。</p>
<p>葛雷族有着一支装备精良的武装，他们背靠大陆大方最大的矿系，然而在帝国面前，这一切毫无意义，诚然，他们完全可以炸毁矿道，但那并不能躲避他们沦为帝国仆从的命运。</p>
<p>当我走进葛雷族的营地时，几乎所有人都对我怒目而视，其中大多是野性，却也带着几份文明，族长是位很硬朗的老人。</p>
<p>“知道吗，按我们的习俗，只要学到知识，就是师徒，你毕业于帝国大学，而我读过帝国大学出版的书，所以我们应该是师兄弟”</p>
<p>我对这老人不合时宜的幽默搞得一点摸不清头脑，“过来，我想让你看个东西”老人领着我向营地的深处走去，在巨大的仓库群前停了下来。</p>
<p>当他打开大门的时候我就知道了——金子，宝石，帝国经济体系中不可或缺的存在，自此帝国历234年定下贵金属和帝国货币的兑换关系后，它们就成了帝国最坚实的支柱。</p>
<p>“这是祖先为我们留下的，留着我们营地的大约只有十分之一””</p>
<p>“你们没有告诉我们这里的矿脉有黄金和宝石？”</p>
<p>“我现在不是告诉你们了吗？”</p>
<p>“……”</p>
<p>“你们帝国的经济命脉就是流通在市场上的黄金吧，如果这种规模的黄金瞬间涌入你们的市场，会发生什么？”</p>
<p>“……”</p>
<p>“好了，开始谈判吧”</p>
<p>历时3天的谈判后，帝国开出了有史以来最宽松的条件，葛雷族的所有自治权予以保留，唯一的条件是，必须与帝国展开全方面的贸易</p>
<h2 id="度量">度量</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只是两个小人物的故事</span><br></pre></td></tr></table></figure>
<p>一般来说，这年头很难遇到算命的，至于在酒吧里看到算命的就更少见了，用算命来骗酒喝已经是不知多少年前的老故事了，然而，在此时此刻，却有两个中年男人在酒吧里对饮。</p>
<p>“你是刚来这座城市吗？”</p>
<p>“恰恰相反，我在这待了很多年了”</p>
<p>发问者并没有追问</p>
<p>“你活过3000帝国币吗？”</p>
<p>莫名其妙的问题，乡巴佬的叫法，发问者心想，一时间他不知对方是什么意思</p>
<p>“我的父亲在活到566布朗时咽了气，他本指望着活到700布朗的，呵呵，然后我就到这里来了”</p>
<p>和一个不知从哪个穷乡僻壤来的家伙聊天或许能让自己以后酒场吹牛添一些料，中年人想，于是他决定听下去。</p>
<p>“来到这里后，一时间我很不适应，你们似乎总喜欢用在时间和空间上均匀分布的事物当做度量的标准，真是奇怪”</p>
<p>提问者忍不住做出了回答“你是说你们甚至没有时空的概念？”</p>
<p>“用你们的话说，我们的时间是经济学，空间则是社会学。当然，你们的语言和概念是无法完全解释的，300克朗昭示着步入成年，数不过来的人意味着一个国家，扎在一定的一堆人意味着一个省，这只是比喻。”</p>
<p>他自嘲般地说“我来的时候觉得在那地方我始终是客子，来到这里后又感觉并非家乡”</p>
<p>窗外一只先前飞走的蝴蝶盘旋一圈后又回到了树梢。</p>
<p>“知道吗？你会活过394杯酒。”他没头没脑地说了一句。</p>
<p>另一位中年人沉默着，他每周的同一时间都会来这里点一杯酒。</p>
<p>“而我，会活过自己度量过的第1944位客户”</p>
<p>“你指望我为你的疯话付钱吗？”</p>
<p>”我不适应你们的语言，我也不适应你们的思维……每一秒，每一厘米对你们而言都是无法更改的，你为什么觉得作为我故乡度量——金钱是能更改的呢？对你来说这是一天，对我而言这是6帝国币，二者都是神圣不可更改的。”</p>
<p>中年人有些可悲地看着他“你需要去补补数学和物理的课”</p>
<p>“我只想知道自己该用什么来度量”他显得有些颓废。</p>
<p>“结账，他那杯也算我的”占卜师指着中年男人桌上的酒，向服务员喊道。</p>
<p>占卜师离开酒吧的背影显得并不年轻，“我是他的第几个客户？”中年男人想到。</p>
<p>中年人从此再也没有喝过酒，一年后，一种以果汁为主成分的硬饮料在帝国风靡一时，中年人在一次应酬中举起了一杯苹果汁，当他察觉到一丝酒味后已经晚了，作为一个厌恶半途而废的男人，他选择一饮而尽，随后咽了气。</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>龙腾世纪三部曲</title>
    <url>/2023/09/30/%E9%BE%99%E8%85%BE%E4%B8%96%E7%BA%AA/</url>
    <content><![CDATA[<h1 id="dao">dao</h1>
<p>本世纪的欧美rpg里最出名的应该是巫师三了，你可能曾因为好奇去搜过cdpr的发家史，也就是从卖盗版游戏到引进游戏并本土化赚到了第一桶金，这个引进的游戏是博德之门，博德之门的开发商是生软。 <span id="more"></span> 这里插一句，波兰人的首秀巫师一在开发阶段几乎遇到了一个新游戏能想到的所有问题，这时生软仗义地扶了波兰人一把，才有了巫师一的面世，遂成rpg界一段佳话，不过后来二者先后拉了（ 龙腾世纪本来在定位上是博德之门的替代品，因为版权问题生软不能继续开发博德之门，于是便做出了龙腾世纪起源，这一项目立项在02年，但直到07年得到了EA的支持才在09年把这一“神作”做了出来，直到这时EA还是带善人的形象，并没有露出狰狞的獠牙，而在生软的黄金时代打磨了7年的起源，我可以毫不夸张地说，哪怕今年推出这款游戏，它依然是年度最佳候选级别的神作。 我先说说，我为什么要做这个视频，其实在一开始，dao在我的心中的地位还没有要我做一个视频出来的程度，但在玩了龙腾世纪的后两作后，DAO在我心中地位飙升，可见对比的力量，这个杂谈系列会讲完我对龙腾世纪整个系列的感受，当然是纯个人感受，我不 是什么rpg遗老，只是一个当代rpg爱好者而已，如有不同意之处，反正我也不会改的。</p>
<p>当你打开dao建立存档时，你可以选择三个种族，三个职业，在种族内甚至有平民和贵族的区别，根据职业和种族的不同，光开头剧情就有六种，由此开始，玩家就能感受到dao的超高自由度。 当然，对于rpg来说，自由度并不是什么稀奇的东西，但dao的自由度是有其独特之处的，以自由度出名的上古卷轴五，它的自由度体现于扮演的角色的多样性，龙裔，战友团成员，冬堡法师等等，这几种身份并没有交集，是独立的，而起源的自由度体现在行为的自由，自由度再高的游戏也不能完全模拟现实，但高自由度的游戏只需要模拟到玩家一时间能想到或者能让他们觉得有趣的所有选项就够了，DAO做到了这点，举例来说，当你接到了调查黑恶势力的任务，你可以当个正义的使者把邪恶势力端了，也可以接受贿赂，甚至可以献祭奴隶来提高自己的力量，你可以与邪教合作玷污圣物，也可以屠杀邪教，杀死恶龙，扮演被选召的勇士，很多时候当你背叛道德时得到的奖励反而更好，高道德的行为除了增加部分队友的好感度并没有太多作用，与巫师类似，起源遵循着成人的价值观，尽管选择大部分时候不像巫师那么残酷，而且起源中后悔也是很容易的一件事，相对削弱了选择的分量。</p>
<p>我们再来说说提高起源代入感的另一个设计——队友系统，独身在一个苍茫浩瀚的魔幻世界冒险难免会感到孤独，巫师的解决方式是让杰洛特和爱人与亲友保持时不时的联系，上古卷轴的解决方式，嗯，我没感到有什么解决方式，至少本体没有，当然如果装了随从mod肯定就完全不一样了。在龙腾世纪起源中你绝不会感到孤独，相比其他知名rpg，生软最显著的优点应该就是队友塑造了，dao的队友大部分有着讨喜且有深度的人设，这是由海量的工作量撑起来的，在冒险时会随机出现队友间的闲聊，几乎所有队友两两组合都有为数不少的对话，或八卦，或正经或取笑，这让人感到队友都是活生生的人，同时也可想而知其中的工作量，单个角色的对话文字量往往都要以万为单位，此外，在营地和队友闲聊也能通过一些选项增减好感度，所有队友都有为数不少的对话树，并且随着好感度的增减还会解锁额外选项。 队友间除了友情也能发展出爱情，这就不得不提我认为在魔幻rpg中最有魅力的女角色——莫瑞甘，她是个荒野女巫的女儿，，价值观完全是混乱中立甚至偏邪恶的，你做好事她嫌你磨叽，做坏事说不定夸你有魄力，好感度低时会邀请你滚床单并声明只是玩玩，好感度高起来了反而不愿继续亲近——“明明说了只是玩玩，怎么你当真了呢”在游戏的结局莫瑞甘会不可避免地离去，而在一个（拿感情骗钱的）的dlc里沃顿却能不远万里追踪到正欲逃走的她，最终让莫瑞甘也承认了爱情的存在，不得不说我真被这段爱情所感动了，这种细腻的感情戏其实不输我们以感情线为特色的双剑系列（当然续作就没这么顶了） 代入感之外，起源的战斗系统也是极有意思的，多有意思呢，大概比巫师三好几十个上古卷轴五吧（不是）起源的系统在今天看也不算过时，采用一种可以随时暂停的即时战斗系统，同时可以为队友ai设置战术，选项极为详细，大佬光靠设置ai应该就可以全自动战斗，我这种咸鱼打boss还是要几步一暂停，很明显这是一种重策略轻即时的系统，不设技能栏上限让法师成为了团队灵魂，控制，辅助，aoe，单体爆发应有尽有，可以说带够蓝药，法师就是无敌的（大部分Boss远程攻击弱于近战），即便职业平衡不是那么好，但队友是可以随意搭配的，丰富的技能树，转职，加点策略，装备系统让起源的战斗和养成充满乐趣，当然大型迷宫各种怪潮难免会腻烦，不过比起后面两作真的是让我体验最好的战斗系统了。 最后我们来说说起源的剧情和任务设计，大恶魔苏醒，黑潮突起，作为临危受命的灰袍守护者，沃顿利用古老盟约集结联军，手刃大恶魔，可以说是一个很俗套的故事，怎么把这种看起来很俗的故事讲好呢，答案是独立的小故事相加辅以大量填充细节和设定，起源的几条线，法师，矮人，精灵，伯爵都是相对独立的故事，套路很简单：求援——当地陷入危机——解决危机——得到援助，期间夹杂背叛者洛根使绊的故事线，每个地方引出了一部分的世界观设定，起源有着极其繁杂的文本，尽管套路类似，但每条线提供的信息量都是复杂且独特的，同时也有着世界观内各个势力特有的风貌，安教的圣洁，矮人的森严都得到了体现，即使很想比较，龙腾世纪的世界观也是独特且复杂的，当然，相比起源的主线，支线反而比较一般，不乏收集的填充式支线，当然，队友的支线还是很有趣的，也有一些补充世界观的有趣支线。 说了这么多，应该基本说完了起源的特点，当然也有很多具体内容我并没有提及，事实上起源并不是没有缺点，比如优化太差，自带防沉迷，玩几个小时就会卡顿到没完继续，只能重启，此外，敌人种类稀缺，也存在强行推动剧情而忽略合理性的情节，甚至有手刃大恶魔实力的主角有的时候莫名其妙就当垫脚石了，但起源仍然是神作，作为一个玩惯了10年后游戏的人，我玩起源没有感到任何系统在恶心我，可见制作组对玩家体验的重视，这是龙腾世纪的续作都未能做到的，，这也是我为龙腾世纪和生软感到可惜的原因，下一期我会叙述我对两部续作的看法，当然批评为主，，， 出道即巅峰的起源全平台销量不过470w，或许正是这样的销量驱使着生软不惜与老玩家对立也要向着主机倾斜，只可惜了龙腾世纪成为了开幕即巅峰，出场即绝唱的一个悲剧……</p>
<h1 id="da2">da2</h1>
<p>今天我们来说说龙腾世纪二，，龙腾世纪二是系列中一部很，额，很独特的作品，他刚发售时的风评，作为后来人我不是很清楚，不过就现在来看，da2的风评呈现一种两极分化的形势。 这里插一句奥，我个人感觉rpg游戏的受众是个很宽容的群体，我这种认为2077是款好游戏的人放一些地方可能被叫孝子了，但对现在龙腾世纪的粉丝来说这可能都不算事，举个例子吧，写文案的这天龙腾世纪吧有个直接辱骂起源人气角色的，甚至没什么人骂回去，这放在其他单机游戏圈子里是难以想象的，所以对于龙腾世纪二这样极其赶工的，大部分玩家评价起来基本没什么戾气，当然事实上我很喜欢这一点，也是这点造成了da2并没有招致较为深入的批评，今天我会详细地阐述这部作品的缺点，当然是以我的角度，同时我也不会带有什么负面情绪，我个人其实很喜欢这个系列，二代我也不是那么讨厌，但它的问题确实是露骨的，毕竟太温和往往就意味着圈子的自净能力不够，对一些问题往往就不能看的那么透彻。 我之前说了da2是一部赶工明显的作品，有多赶工呢，2077和它相比那都不算事，生软甚至没有给二代一个后缀名…… 我们先从系统性的问题说起 首先作为一个rpg游戏，da2从头到尾（一共三章）几乎一直在重复利用十几个地图，一样的别墅，一样的山洞（还Tm贼亮）等等，这也是所有玩家都承认的一个问题，考虑到14个月的工期，这点可能也是难以避免的，不过这个问题实际上并不止这么简单，因为地图的数量太少，各种任务线又要在不停阶段换来换去，这就给玩家造成了一个两难的问题——如果按任务线推不得不忍受一个又一个重复度极高的地图，如果以最高效率的原则一个地点一个地点地清，又会错失现状的任务叙事，这种矛盾是稀缺的地图造成的，也是da2在叙事上的一个根本性的缺点 然后，整个战斗系统可以说在da2迎来了史诗性的大改，或许是制作组没有力气做大规模的技能，所以被官方钦定为法师的霍克技能远远没有一代多，对一个技能你要投至少两个点数进去才能强化到底，更别提一个系的被动build需要投入更多，法师的技能树相比战士盗贼完全没有优势，还有那个攻击动作，法师舞得和金箍棒似的，搞act化不能这么搞啊，怕不是设计师想起自己做《翡翠帝国》（生软以前的东方题材rpg）曾经看过的西游记，把法杖当金箍棒设计……然后是二代的刷兵机制，科克沃是个小城市，但在本作中你可以看到如同下饺子一样天降的敌人杂兵——分批次有顺序地入场，先不说不集结优势兵力在战术上有多不明智，二代的aoe法术是大削过的，我基本上要带两个输出法师才能确保范围伤害足够…… 然后是Boss战的秘之设计，堆血加流程化战斗，什么意思呢，举个例子，在最后一章有个杀龙的支线，Boss血贼厚，而且打一会它就会飞走留一堆小杂兵，自己在打不到的高台上放冷箭，有一说一，不难打，但确实恶心，我记得贴吧有个最高难度的老哥打了一小时，我估计啊，制作组对赶工做的boss没信心，所以用这种机制来给玩家提供“紧张感” 本作队友的战术槽给得更多了，这是个好事，但相应的队友的装备系统反而被砍了（武器能换）也就是当霍克捡到非自己职业的装备时，这就是垃圾，还有本作的dlc装备，又多又杂……steam上的全dlc装备过了100件，而且大多是毕业装备的水平，当然本来装备系统也没什么收集的乐趣，dlc出了应该也是破罐子破摔…… 当然成功的革新也不是没有，队友的感情线是得到了深化的，高对立和高友好都能得到buff和对应技能树，这有利于玩家不顾及队友好感度地遵循本心去做选择，也增加了build的多样性以及跨职业的连击，不过相应的礼物系统和营地闲聊也砍了……（但我个人还是更喜欢起源的策略性战斗）…… 随后的一大麻烦就是剧情，da的小格局剧情在魔幻rpg中应该算少见，虽然这种选择多半也是因为无奈，很多玩家或许是因为新奇而觉得这样的叙事很有意思，确实，不能说da2的故事无聊，但是缺点和漏洞也很明显，我们先把剧情大纲给复习一遍。 枯潮来袭，叛教法师之子霍克与家人逃难到科克沃，在一次矮人矿坑冒险中发家致富，几年后解决了库纳利人的叛乱成为捍卫者，最终面临圣法矛盾的激烈化，并在安德斯的一次恐怖袭击后解决了发布灭法师环令的圣殿骑士领导者梅疯子，圣法大战的时代就此拉开序幕。 只看大纲其实生软的编剧还是有点东西的，有转折，有历史大势，有多方势力的牵扯，看起来很好，是吧，但如果你抛开糟糕的跑任务体验去仔细审视这个故事，你就会发现很难立得住脚。 我猜想啊，14个月的工期一给，编剧拍脑子一想，咱做个小格局故事，矛盾层层激化，来点刺激的，然后开始考虑怎么让角色对号入座，为什么这么说呢，因为da2的故事是典型的情节推动型，霍克从始至终跟着情节走，不是说这么不好，不过da2处理得相对不太行，同年的巫师二也是分三章的小格局叙事，但他们着眼点是主角，杰洛特的立场很明确，找老婆顺便寻回过去记忆，政治那是附带的，他被牵着走，被逼着站队，很合理，互相利用嘛；da2有所不同，霍克从始至终都是城里有排面的人物，就是第一章也是和城里卫队小队长有裙带关系的王牌佣兵，他不能一直被动吧，你da招牌式的自由度呢？ 我们来按顺序捋一下故事线，第一章用一些小任务引出了血法师与激进派圣殿骑士两大毒瘤作为引子其实还行，不过霍克听了瓦里克几句忽悠就要下坑道了略显仓促，当然瓦叔是一代口才点满那种人物，系列里忽悠谁谁信，不过下坑道不带安德斯霍克的弟弟就会死着实是个离谱的安排，奥尔加过后大家应当都知道对一个重要人物的出退场不能那么仓促，但奥尔加死的仓促是因为不这么做编不下去，da2是图什么？沃顿和队友杀了不知道多少暗裔，就没受过伤？怎么就你卡沃毒抗负数，你要说是为了霍克成长也不现实，da这种强调主角就是自己的游戏是不会有主角成长的需要的，只能说这段是真的迷惑，除了让卡沃有机会当沃顿没有任何意义 然后进入第二章，这一章的主线是库纳利人线，这段剧情其实写得不错，库纳利人的塑造很有趣，但问题在于二代本就是个内容不足的游戏，着力想展现的圣法之争和库纳利人一点关系也没有，这段想抬升霍克地位的意图实在是明显过头了，再加上一大段剧情给了库纳利人，分散了玩家注意力不说，让圣法大战本就不足的铺垫和描写雪上加霜，当然第二章也有支线，支线讲了什么呢，全讲了血法师是怎么毒害大众的，事实上本作除了第一章有几个法师卖惨，其他的戏份几乎全给了血法师以及安德斯这种激进派，这就导致了一个很搞笑的问题，你说法师不能迫害，但梅疯子一开始也没杀人，你这城市逢一个法师十有八九练血魔法不管你管谁呢？其实圣法之争的核心问题很简单——法师到底多容易堕落，在一代中一个法师用血魔法能屠大半个法环，很危险，但召唤恶魔者本来就是个危险分子，血魔法对他来说只是工具，你要说恶魔诱惑法师有多容易就很难说，同是老血法师的莫姐不就啥事没有，这个问题不挑明，法师的存废很难有定论。 我们再来说说全游戏的高潮——第三章，da2的剧情呈现一个很神奇的现象，你要说层层递进那确实是这样，但递进的未免比较太快了，纵观全游戏你基本看不到什么温和派——无论圣法，对编剧来说激进派确实好用啊，超快节奏推剧情，但对玩家就会感到憋屈。全游戏最激进的梅疯子，她疯吧，但面对霍克这个叛教法师之子，公然的血魔法使用者她一点也不刁难你，霍克还有个顶着精灵和血法师双重debuff的梅丽尔，她也不管，霍克既然这么有面子，那联合一下城里的势力反对她不难吧，结果没给选项，更神奇的是圣殿和法师还有有识之士站出来想把梅疯子杀了，这时候编剧又觉得梅疯子真被保守派刀了结局没得放了，于是让这些人绑架了霍克的家人，这也算了，真密会了还有血法师跳出来把温和派圣殿杀了，你们搞秘密集会成员审查就这水平？放进来个血法师不说还在关键时刻内讧，真的可以，事实上你在游戏里遇到的法师不是莫名其妙疯了就是几乎没有塑造，情节推着所有角色在走，再举一个例子，蕾莉安娜这种间谍头子怎么着也是雷厉风行的实战派了吧，科城的局势像在火上烤，教皇把蕾莉安娜这种重量级角色派来，你猜派来做什么，派来劝现任主教快走，那科克沃怎么办呢，蕾妹连句懂得都懂都没和霍克说 几边都这么随波逐流，主线怎么推进呢，于是安德斯直接开始搞起来恐怖袭击，不得不说这段真的是异常生硬，安德斯前几章还一副弱受的样子没一点铺垫直接搞恐怖主义了，而且搞完还一副为大义牺牲的样子，问题的根源不解决，法师永远会被歧视，这样的情节有什么意义呢，要在魔幻世界观谈政治本就是件很难圆的事情，更别提生软还处理得这么生硬 可能有人会说这样神转折也很震撼啊，但正如我之前说的，奥尔加之死也是神转折，但没有足够铺垫的生硬转折在剧本创作里肯定是要避免的，可以说二代编剧本来应该想写出霍克身为科克沃捍卫者也对历史大势卷携着无能为力的剧本，但实际效果呢，是各路代表不了大势的牛鬼蛇神作死，而我们的霍日天在一边看着准备收拾残局。 我一直坚持在文艺创作领域风格和水平要分开看，就比如我知道二代有很多拥护者，但他们可能大部分是喜欢这种以小见大的叙事风格，而不是充满漏洞的叙事水平，da2虽然我说了他的很多缺点，但生软的剧本虽然很难跻身一流，但保持二流水平还是可以的，剧情演出的信息量能淹没很多人对不合理处的关注便是明证。 Da2故事上的失败很大部分要归因于赶工和工期的匮乏，这一游戏的大部分问题皆来自于此，至于一个世界观宏大的rpg讲小格局故事是否明智，从后见之明的角度看，da2在作为da3的引子方面还算是成功的，但无可否认da2在设定上根本没什么进展，我们要知道dao在世界观构建上只是刚刚展开，还没到成熟的地步，直接在这种半成品框架下讲故事对完善世界观有所期待的玩家肯定不会满意 大部分da2的玩家应该都为这款游戏感到可惜，如果再有一年的时间可能以上的问题能解决个大半，但奈何生软摊上ea这么一个急功近利的老板，而在下一作，生软带给我的就更多是愤怒，而不是惋惜了……to be continued 以下是个人的碎碎念 一代赶路神技加速术居然砍成限时Buff了,而且这游戏强调同性恋是不是有点过了，安德斯动不动一脸弱受的样子，而且那啥院居然还有不问你性取向直接调情的男妓……这算性骚扰了吧，伊莎贝拉一代可没那么黑啊，这是在海上漂了几十年人种都换了？生软搞zzzq真的由来已久</p>
<h1 id="dai">dai</h1>
<p>今天我们要介绍的这款游戏，于2014年以压倒性优势赢得了tga年度最佳，没有任何一个竞争者是与它同一个量级的，gta5，最后生还者为了避其锋芒不得不选择在13年发售，巫师三被吓得跳票到15年，在得知14年有这款游戏后，宫崎英高慌得只得把黑魂三继续打磨到16年，它就是古往今来最强的rpg游戏——龙腾世纪审判！！！ 对审判的评价有个很神奇的现象，刚推出的年份似乎风评尚可，但随着时间推移，评价越来越差，这似乎意味着这是一款开创先河的游戏，无论是填充式的开放世界，还是泛滥的政治正确，都在这款14年的游戏中得到了体现，当然我不怀疑生软的目的，毕竟制作组高层就有同性恋，甚至现在看来惨不忍睹的开放世界当初的生软可能真的觉得很好（虽然被第二年的巫师三干碎了） 审判在我心中一直是一部很独特的作品，如果你让我说明da系列的优点，一代的优点不胜枚举，二代我至少可以说风格很独特，三代就比较神奇，它的优点，额，藏得比较深 那我们不妨就先说说它的优点，审判在世界观和时间上的推进上有巨大的建树，我的意思是，填了几个坑的同时挖了更多的坑，生软在下一盘很大的棋，无论是揭开奥莱斯的帷幕，教会的黑暗过去，亦或是把古代精灵的设定全部推倒，都能让我们感受到生软在剧本上的用心，确实，理论上讲，dai的剧情是很有看头的，但生软把自己的缺点推向台前，把优点深藏幕后，让我在玩的时候频频破防，也是真的厉害 我们还是先从系统问题说起，不知道是什么给了制作组勇气，本作的引擎换成了做战地的寒霜，这个引擎对rpg的适配性极差，为了实现存档生软就不得不对其做了大量魔改，乃至系列核心功能的存档继承还要通过一个网站实现（没有中文支持哦），不知道是不是为了照顾主机，即时演算cg还是锁30帧的，配合僵硬的人物动作，让我感觉在看ppt，审判还有一种极为奇妙的油腻效果，你要用在植被景物上我就当做油画风格了，但奈何人物也是这个样子，个个都像青春期几个月不洗脸一样满脸反光，在这里我澄清一下啊，有黑子造谣叫索拉斯“蛋头”，索拉斯什么时候配碰瓷我们鸡蛋了，你家鸡蛋反光到这种程度？ 审判主打一个开放世界，什么叫开放世界呢，每个地图给你一堆无聊的收集式支线，跑断腿去吧，此外，除了某些装备词条，审判官没有任何提高那慢的像残废一样的移速的手段，偏偏生软还恶趣味地把地图做的很大，收集式支线的收集品路线拉得很长，如果不修改游戏速度，或者有什么特殊癖好我觉得是撑不下去的，顺便一提也基本没有什么像样的奖励，生软不会真的觉得这种任务能留得住玩家吧，就算14年大家还没有被育碧的填充式开放世界搞得审美疲劳，也不会对这种设计甘之若饴吧 当然了，也有人反驳，又没有强迫你做，不喜欢大可不做，首先呢，为了推主线总归是要做支线积攒势力点的，其次，这也涉及到游戏设计的一个问题，一个叙事向游戏，最根本的是什么，我认为就是像玩家提供信息，一个优秀的的叙事游戏必须在游玩过程中高密度同时高质量的提供给玩家信息，同时这个过程必须是有导向性的，要将玩家的注意力导向最能给予他们信息的方向，因此任务日志里主线永远要在c位，即使是巫师三这种支线质量领先业界的作品，也有粗制滥造纯跑腿的任务，但这些任务流程不会长，也就是，虽然提供不了什么和世界观塑造或者叙事相关的信息，但由于时间短，这段时间的信息密度并没有低到无法忍受，我们看看dai是怎么处理的，首先支线在基本没有信息量的同时，极度磨叽，当然这也就算了，毕竟不喜欢可以不玩嘛，但制作组自作聪明地把这些制作水平极度粗糙的支线，给塞在了日志里，一打开日志界面就是密密麻麻的0/X，我相信但凡是个正常人都会感到烦躁，这就是很失败的一点，它将玩家的注意力导向了最错误的方向，是个极度离谱的设计 同样是为了照顾主机，本作的技能栏进一步精简到了8个技能，8个技能，战士和盗贼都没有过这么吃紧的技能栏，你让法师玩什么？虽然是个人喜好问题，但这种革新是不是有点太过分了一点呢？说实话dai我是一点玩法师的欲望也没有，不是说强度有多少削弱，而是策略选择的灵活性没有了，说到策略，本作更迷惑的一点是取消了战术设定，可以说是向即时act全面转进，da系列每代都有极大的革新，我也不知道是图个什么，我们就当是因为商业利益不得不妥协了吧。 再说剧情和人设的问题，只看大纲，审判的剧情和一代很像，都是主角临危受命杀死大魔王拯救世界的故事，区别也是有点，审判的格局宏大的多，看得出编剧很有野心，一代的费罗登和仅仅提及过的奥莱斯都是本作的舞台，但问题在于呈现的方式，极度草率，我之前说dai是开放世界，其实这不完全准确，因为只有地图和任务是开放的，能去的地方其实就几个，而且大多是荒郊野外，根本不足以展示末日将临下两国的反应，当然生软也想了个办法，就是决策桌系统，说实话这就是个挂机文字游戏，而且频繁进出还很浪费时间，尽管事件很丰富，但寥寥几语文字提供不了多少信息量，一代通过支线我起码看出了点费罗登人应对枯潮的绝望与恐惧，审判恕我直言，完全没什么感觉，当然我不否认主线的几个大事件做的不错，但相应的小格局叙事的空缺让我感觉到这场灾难的苍白，试想一下，审判团之外判官直接接触过什么组织什么人，没几个，是吧。 再说人物，本作的大反派，考爷，不得不说异常苍白，一代的反派洛根虽然傲慢愚蠢但至少性格是有几个侧面的，考爷有什么呢，纯粹的邪恶与野心，其实这样也行，我一向认为刻画人物有两条路，一条是通过各种细节展示其多面性或者成长与突变，一种就是把一个性格特质发挥到极致，比如jojo福音的田最环，就是个坏人，但他诡计多端会演戏，文能严刑逼供心理施压，武能压着吉良和仗助打，这就是把恶这一性格写到极致，但考爷两边都不沾，风头全被我们男判官的好兄弟，女判官的好情人索光头抢走了，真的是惨。 反观入侵者dlc可以说才是真的点睛之笔，回过头来想想，几乎整个审判本体都在给这个dlc作铺垫，不得不说这个dlc确实让我感受到了生软最后的实力 再说队友，其实dai的队友一直给我一种神奇的疏离感，但本着科学严谨的态度，我思考了好一阵为什么会有这种感觉，在这里和大家分享一下 首先是身份上的疏离，一二代的队友都各有各的不同，但总归是人类，精灵，矮人三个基本分类，而且归属上都是费罗登的人，审判就比较神奇，铁牛是库纳利人，科尔是个灵体，其他队友从费罗登奥莱斯两对头，到遥不可及的德凡特，都有，当然这只是最浅显的一点，但身份的疏离明显加大了队友间的隔阂 其次，考虑一下一二代与三代主角的不同，一二代都是有所谓初始剧情的，因此他们都有自己的死忠与初始势力，一代的沃顿初始有同事A哥和受了母亲命令的莫姐两大死忠才开始招募队友的旅程，二代的霍克不仅有弟弟/妹妹还有艾芙琳的支持，更重要的是，加入的队友大部分是孤家寡人，都是孤身投奔梁山的类型，而审判就不同了，初始就有自己势力的卡姐，率部投奔的萨拉，间谍铁牛，法师领袖薇薇安，瓦里克还是霍克的死忠（十年老交情不可能完全站在判官这边）导致判官严格来说甚至没有可以信任的亲信，相反，还要应付各怀异心的队友 最后，对于角色的塑造来说，一共有三个过程，不成熟，成熟，升华，举例来说，一代鲜有不成熟的角色，成熟的利己人格莫姐最后接纳了爱情这是对其人设的升华，成熟的温奶最后决定牺牲自己造福世人，这也是一种升华，一代是不缺少有自己成熟价值观的人物的，看着傻白甜的蕾妹实际上早就身经百战了，而三代不成熟人格就多起来了，卡姐看着霸气，实际上被瓦里克骗了很久，而且天真的没有意识到圣殿骑士膨胀的权力必然导致的对法师的压迫，科尔更不必说，黑墙直到赎罪后才形成了成熟的人格 再说一些其他方面的问题，我是指，政治正确，不知何时起gayware的游戏已经成了同性恋人群的狂欢处了，在尊重同性恋的同时我能请生软尊重一下异性恋吗，队友里能推的只有卡姐？生软塑造女性角色的功底可以说在倒退了，相反的，光头倒颇有一代莫姐的风采，然后是黑人姐姐薇薇安，据我所知龙腾世纪并没有任何关于人种肤色的设定，但我们的薇薇安姐姐就这么不羁地出现在我们眼前，似乎不认为自己在满世界的白皮人中有任何特殊之处，更神奇的是这位姐姐的人设还是交际高手，我很好奇奥莱死的权贵们难道真能把薇薇安当同族看待？据我所知一个明显与交际圈所有人都不同的人，被排挤才是正常操作吧，而我们的薇薇安姐，不仅顶着异于常人的肤色，还有着其貌不扬的一张脸，能成为帝国圈内炙手可热的交际花也是相当励志了。顺便一提，有人说叠buff拿年度最佳是美末二首创，其实是dai玩剩下的，从这点看可以说是非常有创造性的一作了 总的来说，虽然定位上dai是一部中兴之作，但这部作品在最底层的设计逻辑上存在很大的问题，整个路都走错了，如果生软把做开放地图和低质量支线的精力拿来做出一代那种不乏少数有趣支线的线性地图，把决策桌换成各种小任务，那么呈现出的效果必然会好很多，同时，恼人的政治正确，油光满面的建模，浮夸的网游式特效，让审判在外观上都显得不讨喜，我由衷的希望da4里生软能认清自己，摆脱这些乱七八糟的问题。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>wrpg</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>龙腾世纪</tag>
      </tags>
  </entry>
  <entry>
    <title>不予播出——极端意识形态大乱斗</title>
    <url>/2023/09/30/%E4%B8%8D%E4%BA%88%E6%92%AD%E5%87%BA/</url>
    <content><![CDATA[<p>吉姆哈克：当一个国家走在下坡路上，必须有一个给它踩一脚油门。 你生活在一个贫富差距分化严重，外部国家敌意渐升的民主国家，而在此危难关头，一个名为先进党的政党，凭借集体主义的价值观，以及消灭富人扶持穷人的竞选纲领上了台，时代变换的帷幕在你面前缓缓拉开，这时，你能做什么呢？ <span id="more"></span> 这大概就是不予播出想呈现的故事，这个游戏是我认为近年zz题材最出彩的一部独立游戏。 我们先从游戏的形式说起 它选取了一个很少见的视角——电视台导播，也就是在电视内容被播放前负责镜头切换与简单后期音效处理的一个职位，这是一个虽然默默无名却十分重要的职位，制作组对此的选择非常高明，在这个位置上你能接收到一切媒体信息，同时决定哪些内容会被最后播出。 游戏的背景设定是魔改版的80年代英国，想想就知道在这个电视台的黄金时代这个职位意味着什么。 在我们这个娱乐至死的年代，恐怕我们的印象中很难会有什么凭良心的办事的媒体人，但在游戏中，随着举足轻重的影响力而来的同样还有巨大的责任，我们可以看到游戏的封面是一个被操控的提线木偶端坐于导播台前，这似乎预示着你不过是政党口中的喉舌，事实上，面对zz大势，大部分时候你确实是无力的，但总有一些事是你可以做的。游戏中，你能做的包括切换各种机位设置，添加后期音效这些普通的工作，你也可以转而接收反对党的信号，甚至在暗中支持他们。 可以说这样的玩法绝对算不上丰富，但是，为了这些内容制作组拍摄了极为大量的采访，节目，等等实景拍摄，这些作品的文案，演出水平都极为突出，也就是说，让你去观看这些节目，决定他们如何被呈现于观众面前，才是它的核心玩法。 于是，我们可以说说它的剧情了。 我为不予播出的剧情概括了一些特点，首先是荒谬性 国家晚间新闻，是一家有不少zz性的电台，在游戏的一开始，作为新上任的导播，我们的第一次工作就见证了前文提到的先进党的上台，在游戏的一开始我们能感受到强烈的荒谬感，就拿先进党举例，该党的带头人是一对夫妇，丈夫粗俗不堪，而妻子却圆滑世故，这样一对其貌不扬的夫妇在自己上任的第一天就大声向“富人”宣战，我们知道，如果对这些拥有大量资产的人过于苛刻就会造成大量资产外流，对此这对夫妇甚至采用强制手法禁止他们出境，这对一个“民主”国家而言恐怕很难想象，更为魔幻的是这样的举措确实赢得了大众为他们叫好，收归民有资产为国有，强制推行福利政策，提倡集体主义，一副宏伟的蓝图就这样在我们面前展开，即使对民粹主义者来说，这样狂野的改革恐怕也有些吓人，而这些种种举措以极快的速度在游戏中发生了，并且让你切实的体会到厉害之处——也就是游戏中各种惊慌失措的小资产阶级。如果你问大资产阶级咋样了，就有限的情报来说，似乎他们在与国家合作后过得很好。 这是一家很有煽动性的政党，但如果你细细去看他们做了什么，建立国家养老机构（把老人送进去就可以不管了）成立青少年队伍（洗脑从娃娃抓起）半强制推行政党性而不是国家性的身份卡（很明显，只是后续动作的开始）甚至把反对的国家的个别城市用特工安置的核弹统统炸上天。 很荒谬，不是吗？但这些事情确实如此发生了。</p>
<p>如果你很好奇对此的政治评论是怎样的，那么我们很快就会见识到该游戏另一个厉害之处——现实性的缺席。 在游戏的一开始国家晚间新闻是一家较为严肃的新闻频道，但随着游戏的进程，娱乐性的报道和节目越来越多（而且不乏先进党资助的无聊作品），这次过程中有着不少精妙的讽刺，例如领着先进党资助大搞政治正确的校园舞台剧组合，光明正大搞热水器的女明星等等，此时在早期的一些政治性节目中，也有不少让人啼笑皆非的人物，例如奉行白人至上主义，热爱sm的警察局局长，似乎几个小丑粉墨登场就能谈起国家大事。作为理应为公众揭露真相的媒体，自己就陷入了娱乐至死的泥潭 不过他们又能怎么办呢？对于一个奉行强权政治的政党，让一个电视台说不了真话简直太容易了。所以我们在游戏中看到的趋势是，节目变得越来越无聊，又臭又长，当批评声变得刺耳，那么连赞扬得不够卖力也成了罪责。 但游戏中依然有着保存着良心的媒体人，杰里米的爆发大概处于游戏中期，他挟持了摄像头，指责所有人都失去了说话的勇气，随后自绝于心爱的镜头前。这段的演出可以说全游戏最大的一个亮点，荒诞的现实与理想的缺席构成了极大的对比，将游戏荒谬而现实的矛盾感体现得极为突出。 然后，我们要说到极端意识形态题材作品的一体两面——压迫与反抗 哪里有压迫，哪里就有反抗，对于极端意识形态题材而言，对其的呈现与对反抗的呈现是一枚硬币的两面，与其他反乌托邦作品伟光正的反抗者不同，不予播出的反对者仅仅是走向了另一个极端。在游戏中有一个明确的反对者——打断组织，这个组织是什么样的呢？很大程度上可能由一些小资产阶级与无产阶级组成，面对集权，他们选择了暴力，游行，破坏，暴动甚至军事政变，我们很难说打断是一个多好的选择，事实上他们根本没有提出什么解决方案，似乎只是因为自己的利益受到了侵犯而已，在游戏的结局我们可以看到打断组织不过是军方扶持的傀儡，用完即扔。 再说回先进党，这一党派在游戏的中期收到全世界的敌视与孤立，不得不进行完全的内循环经济，究其原因，或许是对有产阶级的镇压并不符合经济全球化的要求，从而招致了其他国家的敌视，随后，他们向全世界部分国家的城市引爆核弹，建立起核威慑。 试问，如果你是一位普通人，你能做出什么样的选择呢？ 说到这里，就不得不说不予播出另一个有趣的机制——在导播工作的间隙你将以视觉小说的形式看到作为普通人的自己如何在政治的漩涡中生活。与电视上光鲜亮丽的报道不同，即使作为被济的穷人，你也不过是从一贫如洗走向负债累累而已。 恐怕根本没有什么更好的选择。 最后，我们应该回归这部游戏贯穿始终的特点——讽刺性和娱乐性 可以说，这部游戏最终呈现的是一个荒谬的世界，在政治领域极端，疯狂，暴力构成了它的底色，这也是我称其为极端意识形态大乱斗的原因 你要问这样的构建是否过于疯狂而丢失了真实性，而且想要展现这样的世界观一个导播的视角也远远不够，可能的确是这样，但我认为这样极端之间的碰撞反而能增加不少的戏剧性。 可能根本不会有这么极端的政党，可能如此极端的政党根本得不到如此多的武力支持，或许吧，但说到底，这不过是个讽刺性游戏而已，用夸张的手法实属正常。 而在政治以外的社会领域呢？滑稽，疯癫，娱乐才是它的主题，你可以看到收藏大粪为乐的清洁工，无法控制肠道蠕动放出气体的“病患”等等极为魔幻的人物登上荧幕，可以说，游戏中所有的人物都是经过夸张化和娱乐化的，即使抛开政治性，你也可以当笑话看。这是我很欣赏不予播出的一点，它并不完全正经，但绝对有趣。</p>
<p>最后，做一个总结吧，根据关键节点的选择不同，游戏一共有14种结局，有一家独大，有天下大乱，也有非极端派兴起，这些结局有的因你而起，有的不过是大势所趋。不予播出从一个导播的小人物视角出发，呈现了一个极端意识形态偏向的荒谬社会的百态，有戏剧性的加工，也有对真实世界的化用与讽刺。 说实话，政治讽刺题材的乐趣不正是在此吗？</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>独立游戏</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>not for broadcast</tag>
      </tags>
  </entry>
  <entry>
    <title>被所有人遗忘的故事，巫师二之殇</title>
    <url>/2023/09/30/%E5%B7%AB%E5%B8%88%E4%BA%8C/</url>
    <content><![CDATA[<p>熟悉我的朋友都知道，我本人是巫师系列的死忠，如果让我给rpg游戏做一个排行，我会把巫师放在第一位，有的人可能会说，巫师固然是rpg佳作，但在浩如烟海，名作辈出的rpg里可未必排的上号，又有的人可能会说，说这么多不过是“情怀党”的矫情而已。 <span id="more"></span> 不错，巫师系列对我来说不只是一个游戏，如果说每个人最大的爱好都有一个启蒙物，那么可以说正是巫师，将我带进了那些着重于叙事的游戏的坑。不过与大部分人不同的是，我初次接触巫师系列是巫师的二代。 那是一个普通的暑假，我费力地思考着，家里残破的笔记本电脑到底能玩点什么游戏，这时我突然想到，听说有个叫巫师三的游戏挺有名，我不如试试它的前作好了。就这样我搜到了巫师一二，巫师一画面陈旧，操作蹩脚，我毫不犹豫地排除了它，但二代却有着在那个年代来说不错的画质，于是我找到了它的资源，试着玩了起来。 听到这里可能大家觉得我无非在说一些陈词滥调，但我想说的是，巫师二即使以我现在不知道涨了多少的阅历来看，依旧是一款特立独行的游戏。在此之前我也玩过不少游戏，但我从来没有见过一个没有政治诉求纯粹为了自己的利益行动的主角，我从来没有见过一个每个人都栩栩如生，有自己行事逻辑的世界，我从来都没有见过，一个以阴暗的政治冲突，种族歧视为背景的游戏，即使以rpg来说，巫师二也是个很有勇气的游戏，在巫师二不长的序章过后，就会面临两个截然不同的分歧，并且这两条分支路线的重复内容并不多，如此大的分支毫无疑问是不多见的。现在回想起来，巫师二可能是我唯一一个一点也没有碰支线的rpg游戏，固然因为当时我懵懂无知，但其波澜壮阔的主线确实无比吸引我， 是的，这是一个非常有突破性的游戏，可谓是cdpr写政治戏码的巅峰，但是，很神奇的是，这又是一个被遗忘的游戏，不仅是被引流来的巫师三玩家遗忘，就连cdpr好像也忘了它，巫师三和二代基本没有什么关系，可能有人会反驳我，巫师三的开头就要模拟二代抉择，但事实上，对一个强调选择的rpg游戏来说，重要的不仅是选择，更是选择带来的后果，而巫师二那些惊心动魄的选择，在三代中几乎都成了定局，无论上亚甸是否赢得了独立，最后的区别不过是沦陷在亨赛特的军队下还是尼弗嘉德军队下而已。无论是否救回泰莫利亚最后的王室血脉，罗契都只能带着他的兄弟们再度流亡。更神奇的是二代最成功的女性角色，龙女居然不知所踪，事实上龙女和伊欧菲斯在巫师三曾有过一个现在沦为废案的任务，但因为赶工期被砍掉了。我们对比一下同样三部曲的龙腾世纪，一代的诸多队友都会在二代亮相，甚至还能在三代中当重要角色。而巫师三部间的关联则少得可怜，一代的女主角夏妮在石之心才出场，也就雷索与罗契在三代的戏份多一点，这无疑大大削弱了巫师中选择的分量。当然，我也能理解cdpr，三代是系列中唯一重启主线的一部，与更像外传的一二部有着极大的区别，并且这一作有着不小的制作规模，必须放弃前作壁垒，放低身段吸引新玩家，种种考量下，三代注定是相对独立的一作，更何况在二代一番精心算计下，事线固然优秀，但已经形成了逻辑闭环，也很难找到延续的办法。而三代为了种种考量，强行让南北形成均势，更破坏了延续巫师二剧情的可能性，尽管可惜，但巫师二作为一个完整的故事，也可以称得上优秀。 接下来我们就来讨论一下一款游戏。 首先，依照惯例，巫师二的系统，巫师二的画面在当年算得上不错，但毕竟此时的cdpr并没有太大经验，因此整部游戏的一些地方仍然显得很生涩，比如说，巫师二是没有跳跃功能的，只能让玩家去寻找攀爬点才能上下移动，而这些攀爬点则都做的很隐蔽，配合拙劣的导路功能，跑图体验难言理想，随后巫师二的战斗相比巫师三繁琐不少，同样分为三种流派，近战，炼金和法印，法印有单独的储备槽，能随着时间恢复，这点有点像dnd，近战则有和三代近似华丽但破绽很大的剑术，并且翻滚是没有无敌帧的，也就是说翻滚途中被攻击打断是常用的事。药剂和炸弹都是一次性用品，众所周知，rpg游戏的一次性用品就是不打最终boss能不用就不用的东西，因此虽然炼金流算得上强力，但由于合成的琐碎以及造价昂贵，走这条线的并不算多。总的来说巫师的战斗系统基本都是在及格线上徘徊的水平，实在没有多少意思。 而论起剧情，就很有的说了 巫师二的叙事有什么特点呢？ 第一，选择 巫师二依旧采取了巫师系列道德困境式的抉择，有不少人批评说这种列车难题式的道德抉择千篇一律，然而，我很好奇的是，他们指望在一个商业游戏里看到怎么样的抉择设定呢？巫师的抉择可能算不上精巧，但在rpg可以说是独树一帜的有分量，重要人物的生死，一个王国的命运，巫师二充斥着各种意义上的抉择，甚至包括第二章两个截然不同的路线。放眼整个rpg史，我敢说有如此大主线分歧的也是寥寥无几，而这样独特的设计，其实与巫师二的剧情结构有不少关系。 第二，双线叙事 我们的杰洛特一向对政治敬而远之，而巫师二构思巧妙之处在于，让一个对政治最没有兴趣的人成了北境局势的关键人物，在游戏中，双线并进的结构被广泛的运用。杰洛特的态度是模糊的，归根到底他不过是想洗脱罪名并寻回自己的记忆，这两大主线目标，前者为主线后者为暗线，都被牵扯到了同一个人身上——雷索。而对于雷索的刺杀行动而言，女术士集会所的阴谋浮现在明处，而隐藏最深的则是尼弗伽德入侵的阴谋。对于游戏中涉及的北境势力而言，两大对抗者，上亚甸和科德温，杰洛特在游戏中任选其一作为明线，另一方便会成为暗线穿插其中。几条剧情路线互相交叉，且彼此间都有说不清道不明的关系，可以说巫师二颇有些戏剧的风格，重要人物算不上多，但却有着极为复杂的人物关系，整个故事都十分耐人寻味。 第三，演出水平 巫师在剧情演出上向来不遗余力，这点倒是颇有生软的师传，巫师二增强版的开场cg对一个11年的游戏来说可以说无比华丽，而在随后的剧情中，也有不少制作不错的cg的即时演出，更有趣的是，不知道是不是为了赶时髦，巫师二还做了两个系列中少有的巨型boss战，在11年来说，这样的演出效果可以说相当不错了，说到这里不得不佩服cdpr的勇气，只做过一部巫师一就敢砸这么多钱到一个前景不明的项目去。 第四，政治阴谋 大部分宫廷政治故事都是肮脏的，巫师二也不例外，开篇我们就能看到为了自己和妹妹的私生子发动王国内战的妹控王，要说这妹控王也是个有勇有谋之辈，但把自己荒淫无度的行径公开到整个国家民众面前的行为，着实是让人叹为观止。如果你觉得这已经很毁三观了，那么我可以负责任地告诉你说，福尔泰斯特在北境执政者里是道德楷模级别的存在，整部游戏里你碰到的政治家，浮港的总督是个没有下限的人渣，亨赛特是个粗暴蛮横的野心家，此时看上去正常的拉多维德对待自己的恩师也是“无微不至”，就连浓眉大眼的斯坦尼斯王子，都能为了上位一脸坦荡地毒害龙女。 当然了，也有萨奇亚这种浑身坦荡的完美领袖，上亚甸是巫师中难得直接描写非人种族抗争的一段剧情，十分正能量和主旋律，算是难得地调剂了巫师阴暗冷酷的风格，巫师对“义军”的描写并没有落入俗套，龙女一身正气但是并不迂腐，伊欧菲斯虽然仇恨人类，但并不是不择手段之辈，他会对萨奇亚动心，会对救了他的命的杰洛特予以回报，矮人往往看上去豪放，却不失狡诈和算计，而义军中也有斯坦尼斯王子和菲丽芭这种野心家。Cdpr对上亚甸线是很上了些功夫的，多种族混杂的特点被个性迥异的npc完美地体现了出来。可以说，在有政治戏码的rpg中，巫师二绝对是一部水准上的作品。 稍微扯开一点话题，巫师二的最终boss雷索，我个人认为是rpg游戏设计得最成功的反派人物之一，雷索的人物志在b站就有，在此不做赘述，纵观其生平，不得不说无论是公事还是私德上，雷索都是一个近乎完美的角色，公事上为了复兴自己的学派，雷索完美执行了恩希尔大帝的命令，他的刺杀行动无不是计划周详，下手果断，善后的处理的也无可挑剔，甚至面对女术士集会所的谋划，将计就计把北境的大部分术士架上了火刑架，要知道，让术士吃这种大亏，这恐怕是猎魔人历史上都没几个人能做的壮举，更可贵的是雷索在做这些事的时候完全秉持公事公办，各为其主的态度，他没有因为杰洛特是福尔泰斯特的护卫就下手迟疑，也没有把自己兄弟的死记在杰洛特头上，他始终清楚地认识到自己不过是尼弗伽德的一把刀这个事实，即使三代中被恩希尔背刺了一刀，也很难说他会有多么吃惊，而在私德方面，为了答谢杰洛特的救命之恩，他跟着杰洛特去迎战几乎没有胜机的狂猎大军，保护叶奈法，甚至在最后把特莉丝从大屠杀中救了出来，而在整场游戏中，他一次也没有对杰洛特下死手。这种文能算计整个北境的术士，武能压制失忆期杰洛特的全能型人才，实在是比工具人白狼不知道高到哪里去了。可能每个巫师系列的粉丝都对巫师四有自己的想法，不过如果是我的话，我是很希望能有以雷索为主角的一部游戏，这个人设实在是太强了。 上述是我个人认为巫师二的优点，不过如果你要问我有没有缺点，那我也可以很明确的说，有的，而且还很明显，并且这个缺点贯穿了整个巫师系列。 我们知道，rpg的意思就是角色扮演游戏，意思就是可以让玩家扮演一个虚拟角色在一个虚拟世界中做出种种行为，巫师系列是21世纪rpg的一大系列，但巫师却并不是一个完全标准的rpg，为什么呢？因为杰洛特是有性格的，杰洛特大体的性格是，外冷内热，自尊心强，外表冷酷无情，内心深处其实是一个傲娇老好人，这样问题就来了，你杰洛特都有性格了，那玩家怎么做选择，cdpr的回答是，尽量把所有选择都做成两难式的，即使是杰洛特本人来选也会犹豫的那种，这也是为什么cdpr总是喜欢这种两难抉择的原因，但还有问题，总有一些真正的杰洛特不会犹豫的选择，比如说真正的杰洛特必然是椰奶的舔狗，而面对这种选择，玩家只能扮演自己，这就让巫师的剧情流程也有了一种割裂感，你是要扮演杰洛特还是扮演自己，这是在你打开巫师游戏前要先做出的选择。当然，两种选择都无可厚非，但这也必然会造成一些矛盾性的情况，像巫师二里，无论哪条线路，不去救特莉丝都会都会对游戏的重要角色大有益处，作为玩家，如果你查了攻略，你就会知道好兄弟雷索会帮你把萌特救出来，然而如果真让杰洛特选他绝对不会放弃自己的情人，也就意味着，要么玩家放弃选择权，要么就要忍受杰洛特的ooc（人设崩塌）。 我个人觉得这是个不大不小的问题，只要做好心理准备还是能忍受的，毕竟一个小说改游戏，碰到这种问题也是难免的，cdpr其实已经把平衡性做的挺好了，没必要太苛求。额，如果这也算孝子那就算吧，不狡辩。 回过头去看，巫师二确实是一部难得的rpg佳作，但它未必是一个合格的承上启下之作，巫师二讲了一个太过精彩的故事，导致接下来不怎么好编了，尼国平推北方顺理成章却很无趣，北方反攻又是天方夜谭，导致巫师三的政治形势显得十分强行，迪胖和拉多维德其实都像开了挂一样，要知道，历史是没有个人英雄主义的，区区一个统治者就能逆转尼弗伽德和北方天堑一般的差距吗？这多少有点机械降神了。这么说来巫师二某种意义上近乎把故事讲死了，不过如果我是cdpr估计也会很无奈，小说基本已经写到恩希尔大帝快一统天下的地步了，巫师由于以杰洛特这种政治无关人士作为主角，搞点宫廷刺杀已经是政治戏的极限了，还能怎么编呢？ 写到这突然想到，巫师三里曾经对雷索喊打喊杀的杰洛特也成了“国王刺客”，这可真是，人终将活成自己最讨厌的样子。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>wrpg</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>巫师二</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo建立个人博客指北</title>
    <url>/2023/10/05/%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<h1 id="概要">概要</h1>
<p>本文用于简要阐释我个人关于使用hexo建个人博客的经验，和解释hexo的各种自定义功能，也可以说是我个人的备忘录。网上很多教程都是直接告诉你怎么做，这在建站时很方便，但如果你要自定义就要知道hexo是怎么自定义的，本文可以帮你对此有一些了解 <span id="more"></span> 在进入正文前，我需要补充一些其他东西</p>
<h2 id="hexo的原理">hexo的原理</h2>
<p>网站分为静态和动态，简单地说，静态网站就是写好了不会改变的页面，可以利用js实现一些小的动态效果，但不会有后台服务，动态网站就是用户发送请求，后台处理后更新网站给用户反馈，大部分商业网站都是此类。 hexo搭建的博客属于典型的静态网站，因此很容易搭建和自定义。可以说，hexo就是根据你的设置和写作，用一定规则渲染出静态页面的一个工具</p>
<h2 id="如何网上访问你的页面">如何网上访问你的页面</h2>
<p>一般来说网站搭建在服务器上，但对静态页面来说，如Github之类的网站后提供免费的托管功能，只要你建一个github账号名.github.io的公共仓库，把静态页面放进去，就可以托管页面，用这个域名访问它(由于众所周知的原因，墙内有时候访问不太稳定)</p>
<h2 id="涉及的工具">涉及的工具</h2>
<h3 id="linux">linux</h3>
<p>我个人推荐你用linux虚拟机来做这件事，一是linux的包管理工具让装各种框架和插件很方便，二是linux的轻量级可以让你如果要切换生产环境，直接导出一个最多10gb左右的镜像拷贝走，就能换到另一台电脑，保留所有装好的环境,三是如果你是cs学生或者有编程需要,linux都是你几乎必学的系统。 这个博客就搭在微软提供的wsl(windows上的linux子系统)上 <a href="https://dowww.spencerwoo.com/">wsl的教程看这个</a> <a href="https://101.lug.ustc.edu.cn/">linux的教程看这个</a></p>
<h3 id="git">git</h3>
<p>git和linux是同一个作者，是当下最流行的版本控制工具，如果我们要用github托管页面，也需要用git来推送页面 git也可以帮我们很方便地给你的博客做备份，推送到github的仓库，切换生产环境后把备份拉过来就能继续维护博客</p>
<h3 id="markdown">markdown</h3>
<p>markdown是一门轻量级标记性语言，很容易学习，被用于hexo渲染出html页面 网上教程很多，比如 <a href="https://www.zhihu.com/question/276209281/answer/3045412944">如何优雅地使用 Markdown？</a></p>
<h1 id="建站和自定义">建站和自定义</h1>
<h2 id="建站">建站</h2>
<p>假设你有了一个linux系统，并且掌握了一些基本操作，那么建站教程看这个 <a href="https://zhuanlan.zhihu.com/p/552639819">【保姆级教程】含泪搭建hexo博客</a></p>
<h3 id="主题选择">主题选择</h3>
<p>hexo的大部分页面渲染工作由主题决定，直观地说，主题决定你的博客外观 <a href="https://hexo.io/themes/">hexo主题列表</a> 我建议新手选择一些比较流行的主题，比如next,butterfly，一般这些主题自定义比较方便，文档易读并且出了问题网上有解决方案</p>
<h3 id="以next为例讲讲主题的自定义">以next为例讲讲主题的自定义</h3>
<p><a href="https://brian-zzz.github.io/2022/05/02/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/">next的简单设置这篇博客有教程</a> <a href="https://theme-next.js.org/docs/getting-started/">next的官方文档</a> hexo的大部分设置有两个yml文件控制，一个是根目录下的_config.yml，可以设置语言，作者名，网站名，网站链接等，还有一个是主题目录的_config.yml，设置主题自己的功能，next的评论，访问统计等等功能都在这里设置 主题的目录一般是根目录/node_modules/hexo-theme-主题名/，但也有主题的配置文件放在根目录的命名成_config.主题名.yml的 关于部分主题功能的详解我会放在下文的主题使用说明</p>
<h2 id="hexo的工作流程">hexo的工作流程</h2>
<p>如果想进一步的自定义，就需要了解hexo的大致原理</p>
<h3 id="前端三件套">前端三件套</h3>
<ul>
<li>HTML（超文本标记语言）是一种用来描述网页内容的语言，它使用一系列的标签（tag）来定义网页中的元素，如标题，段落，图片，链接等。</li>
<li>CSS（层叠样式表）是一种用来控制网页外观的语言，它可以定义网页中元素的颜色，大小，位置，边框等属性。</li>
<li>JavaScript（简称JS）是一种用来实现网页交互的脚本语言，它可以在浏览器中运行，响应用户的操作，修改网页内容，发送和接收数据等。 hexo目录内的public文件夹就放着最后生成的页面，其中，你看到的页面就是一个个html文件，样式和动态效果则引用js和css文件夹中的文件，hexo g生成和你在github托管的也就是这个文件夹下的文件</li>
</ul>
<h3 id="源文件">源文件</h3>
<p>那么是什么文件会被推送到public文件夹呢？</p>
<ol type="1">
<li>根目录下的source文件夹，有下划线_打头的文件夹一般有特殊性质，如根目录下的_data存放一些自定义样式文件，_post则存放具体文章，这些文件夹不会直接放进public，除此以外的文件夹都会被放进public，但如果文件可以被渲染的话，会经过解析然后储存到 <code>public</code> 文件夹，否则会直接拷贝到 <code>public</code> 文件夹。</li>
<li>主题目录下的source文件夹，一般来说这些文件夹用来放js,css和主题自定义的一些图片,同样，有下划线开头的不会被直接放进public，其他文件夹下会被放进去</li>
</ol>
<h4 id="如何跳过渲染">如何跳过渲染</h4>
<p>在根目录下设置skip_render，以下设置让source的webstack目录全部跳过渲染</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">- webstack/**</span><br></pre></td></tr></table></figure>
<h2 id="写作">写作</h2>
<h3 id="文章布局">文章布局</h3>
<p>hexo有三种文章布局，其中post是普通的博文，page是带文件夹的新页面，比如tags,categories，如果主题支持的话，你可以设置page被特别渲染成目录，标签之类的特色页面并放进菜单，draft是草稿，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，默认不会被显示在页面中 你也可以禁用布局，根据 <code>_config.yml</code> 中 <a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>default_layout</code></a> 的设置，默认布局是 <code>post</code> 。当文章中的布局被禁用(<code>layout: false</code>)，它将不会使用主题处理。然而，它仍然会被任何可用的渲染引擎渲染：如果一篇文章是用 Markdown 写的，并且安装了 Markdown 渲染引擎（比如默认的 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>)，它将被渲染成HTML。</p>
<table>
<thead>
<tr class="header">
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>post</code></td>
<td><code>source/_posts</code></td>
</tr>
<tr class="even">
<td><code>page</code></td>
<td><code>source</code></td>
</tr>
<tr class="odd">
<td><code>draft</code></td>
<td><code>source/_drafts</code></td>
</tr>
</tbody>
</table>
<h3 id="文章标头">文章标头</h3>
<p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说： hexo用文章标头来识别文章，因此你可以不用命令行创建文章，把有标头的md文件放进_post就能发布博文了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于斯坦福cs106b的c++数据结构笔记</span><br><span class="line">tags:</span><br><span class="line">- 课程笔记</span><br><span class="line">- c++</span><br><span class="line">categories: 课程笔记</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>layout</code></td>
<td>布局</td>
<td><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td>
</tr>
<tr class="even">
<td><code>title</code></td>
<td>标题</td>
<td>文章的文件名</td>
</tr>
<tr class="odd">
<td><code>date</code></td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr class="even">
<td><code>updated</code></td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr class="odd">
<td><code>comments</code></td>
<td>开启文章的评论功能</td>
<td><code>true</code></td>
</tr>
<tr class="even">
<td><code>tags</code></td>
<td>标签（不适用于分页）</td>
<td></td>
</tr>
<tr class="odd">
<td><code>categories</code></td>
<td>分类（不适用于分页）</td>
<td></td>
</tr>
<tr class="even">
<td><code>permalink</code></td>
<td>覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td>
<td><code>null</code></td>
</tr>
<tr class="odd">
<td><code>excerpt</code></td>
<td>纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td>
<td></td>
</tr>
<tr class="even">
<td><code>disableNunjucks</code></td>
<td>启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>/ <code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td>
<td>错误的</td>
</tr>
<tr class="odd">
<td><code>lang</code></td>
<td>设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td>
<td>继承自 <code>_config.yml</code></td>
</tr>
<tr class="even">
<td><code>published</code></td>
<td>文章是否发布</td>
<td>对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td>
</tr>
</tbody>
</table>
<h4 id="目录和标签">目录和标签</h4>
<p>只有文章支持分类和标签，可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。 eg.如下的标头形成目录是（课程笔记/操作系统）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于恐龙书和苏大ppt的操作系统笔记</span><br><span class="line">tags:</span><br><span class="line">- 课程笔记</span><br><span class="line">- 操作系统</span><br><span class="line">categories:</span><br><span class="line">- 课程笔记</span><br><span class="line">- 操作系统</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>也可以并列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并列分类 </span><br><span class="line">类别：  </span><br><span class="line">- [Linux]  </span><br><span class="line">- [工具]</span><br><span class="line"></span><br><span class="line">并列+子分类</span><br><span class="line">类别：  </span><br><span class="line">- [Linux, Hexo]  </span><br><span class="line">- [工具，PHP]</span><br></pre></td></tr></table></figure>
<h3 id="文章缩略">文章缩略</h3>
<p>一般来说我们不会希望首页显示全文，而是开头的一小部分或者是摘要，摘要可以在标头加上取代缩略，而文章的缩略可以由主题决定，也可以用hexo自己的方式，比如next现在就不支持自动缩进，你只能自己在觉得差不多的地方加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<p>每个主题怎么决定缩略或者摘要基本也会在文档里写</p>
<h2 id="主题说明">主题说明</h2>
<p>既然大部分渲染由主题决定，那么自定义往往也会取决于主题，以下是我本人用过的主题的一些经验</p>
<h3 id="next">next</h3>
<p><code>next</code>是一款典型的黑白简约风主题，并且提供了丰富的自定义性，因此迪瑞克拉的主站就使用了自定义非常方便的next next的文档比较易读，全部看一遍就知道设置里那些选项怎么用了 这里说说next的自定义 next的渲染由主题文件夹下"layout"目录中的njk文件控制（一些老版本是swig)，你也可以使用next提供的自定义文件，去掉注释符号就可以去_data文件新建自定义文件来控制渲染 比如说你想在所有页面加个js特效，就可以在主题文件夹下的layout/_layout.njk文件新增一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;/js/jsname.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下是next提供的自定义文件接口，可以对网站各个位置自定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  #postBodyStart: source/_data/post-body-start.njk</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>
<h3 id="webstack">webstack</h3>
<p>webstack主题基于github的一个开源项目，用来做一个导航页面，作为子站非常合适，自定义虽然没有next那么丰富，但作者慷慨地提供了一个随便插入html的head或者body的接口，可以使用html标签进行自定义，就在webstack的配置文件末尾 怎么做子站看下文的多主题 <a href="https://github.com/HCLonely/hexo-theme-webstack/blob/master/README_CN.md">使用方法看github主页的文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom:</span><br><span class="line">  head: |- # 以下内容插入到&lt;head&gt;&lt;/head&gt;标签内，可设置多行，注意每行开头至少四个空格</span><br><span class="line">    &lt;!-- 直接添加html内容即可 --&gt;</span><br><span class="line">    &lt;!-- 可设置多行 --&gt;</span><br><span class="line">  body: |- # 以下内容插入到&lt;/body&gt;标签之前，可设置多行，注意每行开头至少四个空格</span><br><span class="line">    &lt;!-- 直接添加html内容即可 --&gt;</span><br><span class="line">    &lt;!-- 可设置多行 --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="icarus">icarus</h3>
<p>伊卡洛斯也是个简约风的主题，特色是两列或者三列式的美观布局，但最让我中意的是它的赛博朋克风格，伊卡洛斯使用jsx定义渲染，因此自定义比较麻烦，可以自己导入js和css，但没有直接插入html标签的接口 <a href="https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/">使用文档</a> 文档没说那些七七八八的窗口怎么关，但我亲测你不想要的直接在配置文件里删掉就行了 <a href="https://blog.mchook.cn/2021/07/22/icarus%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89/">自定义js和css</a> 顺便一提大部分主题渲染md会直接把正文放进Html,所以直接在文章里放html标签基本也能用，如果你想要一个效果只在文章页面出现可以试试，迪瑞克拉神龛的骇入文字特效就是此类</p>
<h3 id="多主题">多主题</h3>
<p>理论上讲，既然主题只是决定了渲染的方法，你自己可以调用主题的各种样式渲染实现 一个主题下渲染出另一个主题效果的页面，但这样做很麻烦，那么有没有更容易实现多主题的方法呢？ 前文说了，source文件夹所有目录都会推送到public，我们可以利用这点把其他主题的网站推送到主站的source文件夹，然后在主站开一个菜单跳转到该子站对应目录的index实现子站用不同主题的功能 具体步骤如下</p>
<ol type="1">
<li>如之前的教程一样再建一个站，设置好想要的主题</li>
<li>根目录的设置这么改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: 主站目录/子站目录名</span><br><span class="line">index_generator:</span><br><span class="line"> path: &#x27;/子站目录名/&#x27;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>主站子站各自加一个跳转子站，返回主站的菜单 比如next这么改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resourcemap: /webstack/ || fa fa-sitemap</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>如果你会写脚本，就写个子站生成网站后自动推送的练练手，不会或者嫌麻烦就拿我的改改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">rm -rf /home/thinkliving/hexoblog/source/webstack/*</span><br><span class="line"></span><br><span class="line">cp -r /home/thinkliving/hexochild/public/* /home/thinkliving/hexoblog/source/webstack/</span><br><span class="line"></span><br><span class="line">cp -r /home/thinkliving/hexochild/public/webstack/* /home/thinkliving/hexoblog/source/webstack/</span><br></pre></td></tr></table></figure>
<h2 id="其他自定义">其他自定义</h2>
<h3 id="图标">图标</h3>
<p>大部分hexo主题使用fontawesome的图标，类似这种格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fas fa-tools//s指solid图标</span><br></pre></td></tr></table></figure>
<p>想自定义可以在css文件里定义图标再使用，比如next中是这样在styl里定义,不过不是所有主题都支持这种自定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.thanks &#123;</span><br><span class="line">  background-image: url(&#x27;/images/thanks.svg&#x27;);</span><br><span class="line">  background-size: 1em 1em;</span><br><span class="line">  background-position: 0.05rem 0.2rem;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  height: 1rem;</span><br><span class="line">  width: 1rem; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thanks: /thanks/ || fa custom thanks</span><br></pre></td></tr></table></figure>
<h3 id="hexo-s时自动刷新">hexo s时自动刷新</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g browser-sync</span><br><span class="line">npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure>
<h3 id="加密博客">加密博客</h3>
<p><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">[hexo-blog-encrypt](https://github.com/D0n9X1n/hexo-blog-encrypt/tree/master)</a></p>
<h3 id="js动效">js动效</h3>
<p><a href="https://blog.csdn.net/qq_44036990/article/details/104932173">鼠标移动特效</a> 这种js小特效很多，好奇的话自己去探索吧</p>
]]></content>
      <categories>
        <category>建站经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>webstack</tag>
        <tag>icarus</tag>
      </tags>
  </entry>
  <entry>
    <title>影子工厂</title>
    <url>/2023/09/30/%E5%BD%B1%E5%AD%90%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<p>我本以为影子工厂会如简介说的一样，会是杂糅诸多风格的悬疑风，故事的一开始也的确如此，时间穿越配合豪宅血腥谋杀的经典模式别有一番风味，不过结合前传一贯的发展，不难想象出而在这之后又回到了我们熟悉的时间轴环节，比较特殊的是，这次高瞰老师罕见地采用了正叙的方式，而且此次的故事出奇的平淡，尽管感情上依旧无比细腻，但几乎没有什么出乎意料地发展。 <span id="more"></span> 而事实上，高瞰老师擅长的叙事诡计只是换了一种方式呈现在我们面前，这是一个一位身患绝症的女性在生活和事业中苦苦挣扎，在经历了孩子的夭折后，最后选择了事业的故事，尽管这个故事占了整部游戏大半的流程，但其实它本身并不是重点，因为在开头，影子工厂的主线就被堂而皇之地摆在了我们的面前，豪宅层出不穷的死亡案件，于是，在历览了女主的人生后，真相的追寻才真正开始，当然了，故事如何这里就不赘述了。 当然，相比前两作选材的独特，和层出不穷的叙事诡计，影子工厂显得平淡的多，正如lynri所说，昆西相比两位博士不过是一个观察者而已，他对于挚爱的lynri无能为力，面对自己不过是模拟的数据也无能为力，他的一生没有什么狂乱幻想，也没有多么丰富的内心世界，尽管他的内心是强大的，不过依旧没有什么意思。当昆西历览lynri的记忆时，我们会发现相比博士的聒噪，大部分时候他不过沉默地接受着，评价这一环节是在这段记忆中缺少的。而让这段记忆，一个不是最重要的故事占据叙事的大部分是可以的，但问题在于这一部分必须要穿插主线，否则会产生严重的割裂感，而就影子工厂来说，很难说这一部分和主线有着多大的关系，是否手术的分歧导致了之后的一切，但要拼凑出真相，我们需要知道的除了这个世界不是真实的以外，还有分歧点在于保大还是保小，以及lynri的姓氏，而这两点都没有结合进这个过程。抛开叙事结构，如果我们只看这个故事本身，昆西的爱情故事虽然不能说不好，但比起前作的惊艳未免显得俗套。可以说，如果把这个故事大刀阔斧地砍几笔，也不会有多大的差别，当然，就故事的首尾而言依旧是很有趣的。 不过即便如此，我也要说影子工厂是一部水准上的作品，它有着层层递归的脑洞，优秀的人物塑造，最重要的是，它还展示了高瞰老师填坑的一点点意愿，虽然到最后我们也不会知道两位博士之后到底会怎么发展。而对于系列中虽然重要但没有认真探讨过的记忆编辑技术，影子工厂也表明了一种态度，就是尽管这可能看上去虚无的，但就我们个人所及的知识与眼见来看，只有有过美好的时刻，它就是有意义的，这是一种积极向上的态度，尽管这只是一种态度，但对于虚无与否的讨论大部分时候都只能取决于我们的态度。能以合适的形式传达出这样的观点，就是一部很好的作品了。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>独立游戏</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>影子工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>基于恐龙书和苏大ppt的操作系统笔记</title>
    <url>/2023/09/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机系统可以分为四个部分</span><br><span class="line">硬件(Hardware) – 提供基本的计算资源</span><br><span class="line">CPU, memory, I/O devices</span><br><span class="line">操作系统(Operating System)</span><br><span class="line">控制和协调各用户的应用程序对硬件的使用</span><br><span class="line">应用程序(Application programs) – 规定了用户按何种方式使用系统资源</span><br><span class="line">字处理程序, 编译器, 网络浏览器, 数据库系统, 视频游戏</span><br><span class="line">用户(Users)</span><br><span class="line">人, 机器, 其他计算机</span><br><span class="line">操作系统的目标:</span><br><span class="line">运行用户程序  ---核心目标</span><br><span class="line">更方便使用计算机 ---面向用户</span><br><span class="line">更高效使用计算机 ---面向系统</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>计算机启动时，会启动引导程序，来初始化系统的各个组件，加载操作系统并开始执行 操作系统加载到内存后，开始为系统和用户提供服务，成为系统进程或者后台程序该阶段完成后系统完全启动并且等待事件发生。 事件发生通过”中断“机制来通知，cpu被中断时，停止正在做的事，并立即转到固定位置继续执行中断服务程序，执行完后继续执行被中断的计算</p>
<ul>
<li>中断：指当出现需要时，CPU暂时停止当前程序的执行，转而执行处理新情况的程序和执行过程</li>
<li>中断号：外部设备进行I/O操作时产生的中断信号，发送给CPU</li>
<li>中断向量：中断服务程序的入口地址</li>
<li>中断服务程序：执行中断处理的代码</li>
<li>陷阱(trap):是由于出错或用户请求引起的软件生成的中断 操作系统是中断驱动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在冯·诺依曼体系结构( von Neumann architecture)上执行时，一个典型的指令执行周期是，首先从内存中获取指令，并存到指令寄存器( instruction register)。接着，该指令被解码，也可能会从内存中获取操作数据并且存到内部寄存器。在指令完成对操作数据的执行后，结果也可存到内存。注意:内存单元只能看到内存地址的流，而并不知道它们如何产生(通过指令计数器、索引、间接、常量地址或其他方式)或它们是什么样（指令或数据）的地址。相应地，我们可以忽略程序如何产生内存地址，而只关注由程序运行所生成的地址序列。</span><br></pre></td></tr></table></figure>
<h2 id="集群系统">集群系统</h2>
<p>由两个或多个独立的系统耦合起来 共享数据 storage-area network (SAN)。 提供高可用性。 一定的冗余 非对称集群(Asymmetric Clustering)：一台机器运行应用程序，而其他机器处于热备份模式。 对称集群(Symmetric Clustering)：多个主机都运行应用程序 提供high-performance computing (HPC) 用专门的应用程序利用集群，并行计算parallelization</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多道程序设计：在内存中同时存在多道作业，在管理程序控制下相互穿插运行</span><br><span class="line">通过作业调度(Job Scheduling)选中一个作业并运行</span><br><span class="line">当该作业必须等待时 (如等待I/O), 切换到另一个作业</span><br><span class="line">目的:提高CPU的利用率，充分发挥计算机系统部件的并行性</span><br></pre></td></tr></table></figure>
<p>分时系统：控制响应时间较短，使计算机可交互，一般采用时间片轮转方式使一台计算机为多个用户服务 并行：两个或者多个作业在同一时刻运行 并发：两个或多个作业在同一时间间隔内依次运行 双重模式：允许OS保护自身和其他系统部件 用户模式(user mode)和内核模式(kernel mode)，由硬件提供模式位 特权指令：可能引起系统崩溃的指令，只能运行在内核模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果操作系统不能获得CPU控制权，就无法管理系统</span><br><span class="line">eg.用户程序死循环，用户程序不调用系统调用</span><br><span class="line">解决方法：定时器</span><br><span class="line">在一段时间后发生中断，CPU控制权返回操作系统</span><br><span class="line">固定时间和可变时间定时器</span><br><span class="line">利用时钟和计数器实现</span><br></pre></td></tr></table></figure>
<p>I/O保护 防止用户程序执行非法I/O 解决方法：所有I/O指令都是特权指令 用户程序通过系统调用进行I/O操作 内存保护 防止内存非法访问 解决方法：存储保护机制 硬件支持 程序运行必须的存储设备 CPU只能直接访问寄存器、高速缓存和内存 处理前和处理后的所有数据都在内存 执行的指令都在内存 内存管理：提供内存的分配、回收、地址转换、共享和保护等功能 提高内存利用率 提高内存访问速度 从而提高计算机运行效率</p>
<p>操作系统服务提供对用户很有用的函数:</p>
<ul>
<li><p>用户界面 – 所有的操作系统都有用户界面(UI) 形式有命令行界面(CLI)、图形用户界面(GUI)、批界面</p></li>
<li><p>程序执行 – 系统必须能将程序转入内存并运行程序。程序必须能结束执行，包括正常或不正常结束（指明错误）</p></li>
<li><p>I/O 操作 -  运行程序可能需要I/O,这些I/O可能涉及文件或设备.</p></li>
<li><p>文件系统操作 -  文件系统特别重要。很明显，程序需要读写文件和目录，创建和删除文件，搜索文件，列出文件信息，访问管理</p></li>
<li><p>通信 – 进程间可能需要交换信息，发生同一台计算机运行的进程间或由网络连接的不同计算机上的进程间(消息传递和共享内存) 通信可以通过共享内存或消息交换技术来实现 (消息包由OS移动)</p></li>
<li><p>错误检测 – OS 需要知道可能出现的错误 错误可能发生在CPU 或内存硬件、I/O设备和用户程序中 对于每种类型的错误，OS 应该采取适当的动作以确保正确和一致的计算 调试工具可以在很大程度上加强用户和程序员有效使用系统的能力</p></li>
</ul>
<p><code>层次结构</code>：操作系统划分为若干层，在低层上构建高层，底层（0层）为硬件，最高层（ N层）为用户层，每层只使用低层次的功能和服务 优点 简化了系统设计和实现，便于调试和升级维护 缺点 层定义困难，效率差 <code>微内核</code>： 问题：内核越来越大，越来越难管理 内核微型化：核内移出尽可能多功能到用户空间 好处: 便于扩充，便于移植操作系统到新架构系统上，更稳定 (更少的代码运行在核心态)，更安全 坏处: 用户空间和内核空间通信的系统开销增加 解决方法：提出消息传递机制 <code>模块化</code>： 大部分现代操作系统采用模块结构(Linux, Solaris) 使用面向对象方法 每个核心部件分开 每个与其他模块的会话被称为接口 每个模块在需要时被加载到内核 总体而言，类似于分层方法，但更灵活</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个程序可对应一个或多个进程，同样一个进程可对应一个或多个程序</span><br><span class="line">程序是进程的代码部分</span><br><span class="line">进程是活动(active)实体，程序静止（被动passive）实体</span><br><span class="line">进程在内存，程序在外存</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>Control Block)</span></figcaption><table><tr><td class="code"><pre><span class="line">PCB包含同进程有关的信息，包括：</span><br><span class="line">进程状态</span><br><span class="line">程序计数器</span><br><span class="line">CPU寄存器</span><br><span class="line">CPU调度信息</span><br><span class="line">内存管理信息</span><br><span class="line">计账信息</span><br><span class="line">I/O状态信息</span><br></pre></td></tr></table></figure>
<p><img src="/images/obsidian/20230529221113.png" title="image" alt="图片" /> <code>进程调度队列</code>： 作业队列 - 在系统中的所有进程的集合 就绪队列 - 在主内存中的，就绪并等待执行的所有进程的集合 设备队列 - 等待某一I/O设备的进程队列 在各种队列之间进程的迁移 <code>进程终止</code>：</p>
<ul>
<li>进程执行最后一项并退出（exit） 从子进程向父进程输出数据（通过wait） 操作系统收回进程的资源 父进程可中止子进程的执行（ abort）</li>
<li>子进程超量分配资源 赋予子进程的任务不再需要 若父进程终止，一些系统不允许子进程继续存在 所有子进程终止-- 级联终止</li>
<li>父进程可以等子进程结束 调用wait()系统调用 <code>进程通信</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息传递在微内核中的应用</span><br><span class="line">远程通信无法采用共享内存</span><br><span class="line"></span><br><span class="line">发送send(message) - 固定或可变大小消息</span><br><span class="line">接收receive(message)</span><br><span class="line">若P与Q要通信，需要:</span><br><span class="line">建立通信连接</span><br><span class="line">通过send/receive交换消息</span><br><span class="line">通信连接的实现</span><br><span class="line">物理的（如，共享存储，硬件总线）</span><br><span class="line">逻辑的（如，逻辑特性）</span><br><span class="line">消息传递可阻塞（blocking）或非阻塞（non-blocking）</span><br><span class="line">阻塞-同步</span><br><span class="line">阻塞send：发送进程阻塞，直到消息被接收</span><br><span class="line">阻塞receive：接受者进程阻塞，直到有消息可用</span><br><span class="line">非阻塞-异步</span><br><span class="line">非阻塞send：发送进程发送消息并继续操作</span><br><span class="line">非阻塞receive: 接收者收到一个有效消息或空消息</span><br><span class="line">如果通过信箱，则可分为直接和间接通信</span><br></pre></td></tr></table></figure>
<p><code>线程</code>（轻型进程lightweight process, LWP ）是CPU使用的一个基本单元，包括</p>
<ul>
<li>线程ID</li>
<li>程序计数器</li>
<li>寄存器集 <code>栈空间</code> 一个线程与它的对等线程共享：</li>
<li>代码段</li>
<li>数据段</li>
<li>操作系统资源 总体作为一个任务 多线程的优点：</li>
<li>响应性</li>
<li>资源共享</li>
<li>经济</li>
<li>可伸缩性：可在多处理核上并行运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调度</span><br><span class="line">线程是调度的基本单位，同一进程中的线程切换不会引起进程切换。</span><br><span class="line">并发</span><br><span class="line">线程可以提高系统的并发性。</span><br><span class="line">资源</span><br><span class="line">进程拥有资源，是资源分配的基本单位，而线程则不拥有资源，但它可以访问创建它的进程所拥有的资源</span><br><span class="line">上下文切换</span><br><span class="line">线程的上下文切换的代价比进程小。</span><br></pre></td></tr></table></figure>
<p>可分为数据并行和任务并行 <img src="/images/obsidian/20230530184144.png" title="图片" alt="图片" /> <img src="/images/obsidian/20230530184243.png" title="图片" alt="图片" /> <img src="/images/obsidian/20230530185433.png" title="图片" alt="图片" /> //S是应用程序的一部分，N是它在N个处理器上串行运行 <code>线程的分类</code>：</p>
<ul>
<li>用户线程：由用户线程库进行管理的线程 内核看不到用户线程 用户线程的创建和调度在用户空间中，不需要内核的干预 应用于传统的只支持进程的操作系统</li>
<li>内核线程：内核进行管理的线程 需要内核支持 由内核完成线程调度 由内核进行创建和撤销 <code>多线程模型的分类</code>：</li>
<li>多对一模型： 不支持内核线程的操作系统 内核只有进程 内核只看到一个进程 多个线程不能并行运行在多个处理器上 进程中的用户线程由进程自己管理 进程内线程切换不会导致进程切换 一个线程的系统调用会导致整个进程阻塞</li>
<li>一对一模型 用于支持线程的操作系统 用户线程一对一映射到内核线程 操作系统管理这些线程 并发性好：多个线程可并行运行在多个处理器上 内核开销大</li>
<li>多对多模型： 多个用户线程映射为相等或更小数目的内核线程 并发性和效率兼顾 增加复杂度 <code>线程库</code> 为程序员提供API来创建和管理线程 两种模式：</li>
<li>用户库（用户线程） 存在于用户空间 没有内核支持 调用线程库不会产生系统调用</li>
<li>内核库（内核线程） 存在于内核 操作系统支持 调用线程库会产生系统调用 <code>隐式线程</code>：在编译或者运行的时候由编译器或者运行库决定而不是编程者 <code>线程池</code>：在池中创建一批线程，等待任务 优点： 利用线程池中的线程来响应请求比创建一个线程更加快速 允许一个应用程序中的线程数量达到线程池的上限 <code>大中央调度</code>: Apple 技术用于Mac OS X 和 iOS 扩展C, C++ languages, API, 和 run-time library 允许辨认可并行区段 管理线程的大多数细节 块格式“^{ }” -   ˆ{ printf("I am a block"); } 块放置在调度队列中 在线程池中有可用的线程的时候离开队列 <code>线程撤销</code>在完成前终止线程 要取消的线程称为目标线程 target thread 大体两种方法: 异步取消Asynchronous cancellation 立刻终止目标线程 延迟取消Deferred cancellation 允许目标线程周期性检查它是否应该被终止 <code>调度程序激活</code></li>
<li>通常用一种中间数据结构在用户和内核线程间 – 轻量级进程 lightweight process (LWP) 类似虚拟处理器 每个 LWP 和内核进行相连 一定数量的LWP</li>
<li>调度器激活提供 upcalls – 一种线程库中内核使用upcall处理句柄 upcall handler 来告知特定事件 <img src="/images/obsidian/20230530200404.png" title="image" alt="图片" /> 这种通讯允许一个应用程序保持正确数目的内核线程</li>
</ul>
<h1 id="概念">概念</h1>
<p>`需要调度的四种情况</p>
<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程从运行切换到就绪状态（eg.出现中断）</li>
<li>进程从等待状态切换到就绪状态(eg.IO完成)</li>
<li>进程终止时 调度只发生在1，4情况下是非抢占调度 <code>非抢占调度 一旦把CPU分配给某进程后，系统不可以抢占已分配的CPU并分配该其它进程 只有进程自愿释放CPU，才可把CPU分配给其他进程 优点：易实现，调度开销小，适合批处理系统 缺点：响应时间长，不适合交互式系统</code>抢占调度 调度程序可根据某种原则暂停某个正在执行的进程，将已分配给它的CPU重新分配给另一进程 可防止单一进程长时间独占CPU 系统开销大 抢占式与非抢占式的区分 运行进程是否是自愿放弃CPU <code>长程调度 又称作业调度、高级调度 “新建”状态转换到“就绪”状态 由调度程序选择 控制多道程序的“道/度”（Degree）</code>短程调度 又称CPU调度、低级调度 调度程序选择下一个执行进程</li>
<li>切换频率 短程调度切换频率高 长程调度切换频率低</li>
<li>切换开销 短程调度开销小(milliseconds，切换快) 长程调度开销大(seconds/minutes，切换慢)</li>
<li>操作系统中应用 短程调度：必需 长程调度：可选 <code>中程调度 又称交换 将进程在内存和外存间换进换出 目的：节省内存空间</code>就绪队列` - 在主内存中处于就绪状态并等待执行的所有进程集合 <code>设备队列</code> - 等待某一I/O设备的进程队列 进程的执行过程实际上就是进程在各种队列之间的迁移 `基本指标</li>
<li>CPU利用率 – 固定时间内CPU运行时间的比例</li>
<li>吞吐量 – 单位时间内运行完的进程数</li>
<li>周转时间 – 进程从提交到运行结束的全部时间</li>
<li>等待时间 – 进程等待调度（不运行）的时间片总和</li>
<li>响应时间 – 从进程提交到首次运行[而不是输出结果]的时间段，也就是第一段的等待时间</li>
</ul>
<h1 id="进程调度">进程调度</h1>
<p><code>等待时间</code>=开始处理时间-到达时间 <code>周转时间</code>=等待时间+处理时间</p>
<h2 id="先来先服务-fcfs">先来先服务-FCFS</h2>
<p>优点：实现简单 缺点：长进程在前会使多个短进程等待过久，增加平均等待时间</p>
<h2 id="短作业优先-sjf">短作业优先-SJF</h2>
<p>SJF是最优的 – 对一组指定的进程而言，它给出了最短的平均等待时间</p>
<h3 id="抢占式调度">抢占式调度</h3>
<p>有比当前进程所需时间更短进程到达时，更换目前进行进程 常用于长进程调度，缺点在于进程的cpu区间难以估计 通常用指数平均估计</p>
<h3 id="非抢占式调度">非抢占式调度</h3>
<p>进程只在结束后让出cpu</p>
<h2 id="优先级调度">优先级调度</h2>
<p>基于进程紧迫程度赋予优先级，cpu分配给最高优先级进程 优点 实现简单，考虑了进程的紧迫程度 灵活，可模拟其它算法</p>
<ul>
<li>静态优先级 进程创建时确定，运行期间不变</li>
<li>动态优先级 优先级随着进程推进或者等待时间增加而改变</li>
</ul>
<p>`问题</p>
<ul>
<li>饥饿：低优先级进程可能永远无法运行</li>
<li>老化：视进程等待时间延长提高优先级</li>
</ul>
<h3 id="响应比高者优先调度">响应比高者优先调度</h3>
<p>响应比=（开始时间-到达时间）/运行时间</p>
<ul>
<li>如等待时间相同，运行时间越短，优先级越高，类似于SJF</li>
<li>如运行时间相同，优先级取决于其等待时间，类似于FCFS</li>
<li>长进程的优先级可随等待时间的增加而提高，最终可得到服务</li>
<li>缺点：每次调度之前，都需要计算响应比，增加系统开销</li>
</ul>
<h2 id="轮转调度-rr">轮转调度-RR</h2>
<p>将较小的时间单元定义为时间片，就绪队列为循环队列，调度程序循环整个队列，为每个进程分配不超过一个时间片的cpu</p>
<h2 id="多级队列调度">多级队列调度</h2>
<p>进程分为前台进程（交互进程）和后台进程（批处理进程） 不同类型的进程需要不同策略 交互进程需要短的响应时间 批处理进程需要短的等待时间 <code>多级队列梯度</code>系统中存在多个就绪队列，每个队列有自己的调度算法</p>
<h3 id="多级反馈序列-mlfq">多级反馈序列-MLFQ</h3>
<p><em>(MultiLevel Feedback Queue Scheduling)</em> 多级队列的延伸 不同：</p>
<ul>
<li>多级队列：进程不能在不同队列间移动</li>
<li>多级反馈队列：进程能在不同队列间移动</li>
<li>多级反馈队列调度需要考虑以下问题： 队列数 每一队列的调度算法 决定进程升级（低级队列到高级队列）的方法 决定进程降级（高级队列到低级队列）的方法 决定新进程将进入哪个队列的方法 `最常用的调度算法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">Q0-RR时间片8ms</span><br><span class="line">Q1-RR时间片16ms</span><br><span class="line">Q2-FCFS</span><br></pre></td></tr></table></figure>
<p>缺点：优先级一开始确定，无法调整</p>
<h1 id="线程调度">线程调度</h1>
<p>区别用户层和内核层 调度线程而不是进程 多对多和多对一模型，线程库在可用的LWP上调度用户层线程 process-contention scope (PCS) 在进程中进行调度竞争 通常由程序员通过优先级设置 内核线程通过system-contention scope (SCS) 在CPU上调度– 系统中统一竞争 一对一模型仅使用SCS，如Windows， Linux</p>
<h2 id="局部调度">局部调度</h2>
<p>[[线程库]]决定哪个线程列入轻量级进程LWP</p>
<h2 id="全局调度">全局调度</h2>
<p>内核决定下一个运行的内核线程</p>
<h1 id="多处理器调度">多处理器调度</h1>
<p>调度类似单处理器，但需要将任务平均分配</p>
<h2 id="对称多处理器-smp">对称多处理器-SMP</h2>
<h3 id="单队列多核调度方法sqmp">单队列多核调度方法(SQMP)</h3>
<p>系统有一个就绪队列。当任意一个CPU空闲时，就从就绪队列中选择一个进程到该CPU上运行 优点： 容易从单核调度算法推广到多核/多处理器、 实现简单，负载均衡 缺点： 不具有亲和性 加锁问题</p>
<h3 id="多队列调度方法mqmp">多队列调度方法(MQMP)</h3>
<p>系统有多个就绪队列，一般每个CPU一个。每个就绪队列有自己的调度算法，并且每个就绪队列的调度相对独立 优点： 亲和性好 不需要加锁 缺点： 负载不均衡 策略：“偷”进程 <code>每个处理器决定自己调度方式 定期检测每个cpu负载，分配任务给空闲处理器</code>亲和性：进程倾向于在给定cpu上运行</p>
<ul>
<li>软亲和性：不强制禁止迁移</li>
<li>硬亲和性：禁止迁移</li>
</ul>
<h3 id="单队列调度">单队列调度</h3>
<p>共享队列，分配给不同cpu 不具有亲和性</p>
<h3 id="多队列调度">多队列调度</h3>
<p>不同cpu有各自队列 <code>优点</code>：亲和性较好，不需要加锁 <code>缺点</code>：负载不均匀</p>
<h2 id="非对称处理器-asmp">非对称处理器-ASMP</h2>
<p>仅一个处理器处理系统数据结构，减轻共享需求</p>
<h1 id="实时cpu调度">实时cpu调度</h1>
<ul>
<li>软实时系统：不保证调度关键实时进程</li>
<li>硬实时系统：任务必须在截止期限前完成 对实时调度，必须支持抢占式、优先级调度 但仅仅支持软实时 对硬实时必须提供满足截止时间的能力 需要调度进程的新特性： 周期性 periodic 定期需要CPU 有进程时间 t, 截止时间 d, 周期 p 0 ≤ t ≤ d ≤ p 周期任务的速率Rate 1/p</li>
</ul>
<h2 id="单速速度调度">单速速度调度</h2>
<p>依照周期倒数分配一个优先级 <code>优点</code>：最大化cpu利用率 <code>缺点</code>：不保证每个进程都赶上截止期限(周期内执行不完)</p>
<h2 id="最早截止期限优先调度-edf">最早截止期限优先调度-EDF</h2>
<p>根据截止时间分配优先级 越早截止期限，优先级越高</p>
<h2 id="比例分享调度">比例分享调度</h2>
<p>所有应用中分配T股，确保所有进程有固定的cpu时间，如果新加入进程大于T股剩余量，则不允许进入</p>
<h1 id="实例">实例</h1>
<h2 id="linux">linux</h2>
<ul>
<li>实时任务有静态优先级（友好值）</li>
<li>抢占式 没有真正的线程</li>
</ul>
<h2 id="windows">windows</h2>
<ul>
<li>抢占调度</li>
<li>优先级</li>
</ul>
<p>对共享数据的并发访问可能导致数据的不一致性，需要保证并发进程正确执行顺序的机制 <code>竞争条件</code>：多个进程并发访问同一共享数据</p>
<ul>
<li><code>同步</code>：协调执行次序</li>
<li><code>互斥</code>：进程排他性运行，可以独占资源 <code>临界资源</code>：一次只允许一个进程使用的资源，又称互斥资源、独占资源或共享变量 <code>共享资源</code>：一次允许多个进程使用的资源</li>
</ul>
<h2 id="临界区">临界区</h2>
<ul>
<li><code>互斥</code>：临界区执行的进程排斥其他进程（有相同临界资源）</li>
<li><code>进步</code>:临界区无进程执行，不能无限期延长下一个需要临界区进程的等待时间</li>
<li><code>优先等待</code>：一个进程进入临界区时，其他进程进入<code>临界区</code>有次数限制</li>
<li>进入区：互斥</li>
<li>退出区：有空让进</li>
<li>每个临界区不能过大：有限等待 空闲则入：其他进程均不处于临界区； 忙则等待：已有进程处于其临界区； 有限等待：等待进入临界区的进程不能"死等"； 让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peterson算法</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">  flag [i]:= true;  </span><br><span class="line">  turn = j;  </span><br><span class="line">  while (flag [j] and turn == j) ;</span><br><span class="line"></span><br><span class="line">  critical section</span><br><span class="line"></span><br><span class="line">  flag [i] = false;</span><br><span class="line"></span><br><span class="line">  remainder section</span><br><span class="line"></span><br><span class="line">  &#125; while (1);</span><br></pre></td></tr></table></figure>
<h2 id="锁">锁</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acquire() &#123;  </span><br><span class="line">       while (!available)</span><br><span class="line">          ; /* busy wait */</span><br><span class="line">       available = false;;</span><br><span class="line">    &#125;</span><br><span class="line">   release() &#123;</span><br><span class="line">       available = true;</span><br><span class="line">    &#125;</span><br><span class="line">   do &#123;</span><br><span class="line"></span><br><span class="line">    acquire lock</span><br><span class="line"></span><br><span class="line">       critical section</span><br><span class="line"></span><br><span class="line">    release lock</span><br><span class="line"></span><br><span class="line">      remainder section</span><br><span class="line"></span><br><span class="line"> &#125; while (true);</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁自旋锁">互斥锁（自旋锁）</h3>
<p>原子执行acquire(),release() acquire：while(!available) waiting; available=false release:available=false</p>
<h3 id="面包店算法">面包店算法</h3>
<ul>
<li>在进入临界区前，每个进程接收一个号码。具有最小号码的进程进入临界区。</li>
<li>如果进程Pi和Pj接收到同样的号码，如果i &lt; j ，则Pi先得到服务，否则Pj先得到服务。</li>
<li>这种号码方案总是以递增序列产生号码；如： 1,2,3,3,3,3,4,5...</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  choosing[i] = true;</span><br><span class="line">  number[i] = max(number[0], number[1], …, number [n – 1])+1;</span><br><span class="line">  choosing[i] = false;</span><br><span class="line">  for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">  while (choosing[j]) ;</span><br><span class="line">  while ((number[j] != 0) &amp;&amp; (number[j,j] &lt; number[i,i])) ;</span><br><span class="line">  &#125;</span><br><span class="line">  critical section</span><br><span class="line">  number[i] = 0;</span><br><span class="line">  remainder section</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>
<h2 id="信号量软件解决方案">信号量（软件解决方案）</h2>
<ul>
<li>保证多个代码段不被并发调用</li>
<li>进入关键代码段前，进程必须获取信号量，否则不能运行</li>
<li>执行完关键代码段，必须释放信号量</li>
<li>信号量有值，说明空闲，为负说明忙碌</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信号量S – 整型变量</span><br><span class="line">提供两个不可分割的[原子操作]访问信号量</span><br><span class="line">wait (S):</span><br><span class="line">     while S&lt;= 0 do no-op;  </span><br><span class="line">     S--;  </span><br><span class="line">signal(S):</span><br><span class="line">     S++;</span><br><span class="line">wait (S)又称为P(S)</span><br><span class="line">signal(S)又称为V(S)</span><br></pre></td></tr></table></figure>
<p>`分类</p>
<ul>
<li>计数信号量：没有限制的整型值计数信号量=同步信号量</li>
<li>二值信号量：0 || 1 二值信号量=互斥信号量 `使用 必须取一次且仅有一次初值 初值不为负 除了初始化，只能通过执行P、V操作来访问S</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：P1  和 P2 需要 C1 比C2先运行</span><br><span class="line">       semaphore s=0</span><br><span class="line">P1:</span><br><span class="line">   C1;</span><br><span class="line">   signal(s);</span><br><span class="line"></span><br><span class="line">P2:</span><br><span class="line">   wait(s);</span><br><span class="line">   C2;</span><br></pre></td></tr></table></figure>
<p>死锁 – 两个或多个进程无限期地等待一个事件的发生，而该事件正是由其中的一个等待进程引起的. P0  P1   P(S);  P(Q);   P(Q);  P(S);   V(S);  V(Q);   V(Q)  V(S); 饥饿 – 无限期地阻塞。进程可能永远无法从它等待的信号量队列中移去.</p>
<h3 id="实例-1">实例</h3>
<h4 id="生产者消费者问题">生产者消费者问题</h4>
<p><code>生产者 把产品放入指定缓冲区 in:所有的生产者对in指针需要互斥 counter：所有生产者消费者进程对counter互斥</code>消费者 从指定缓冲区取出产品 out:所有的消费者对out指针需要互斥 counter：所有生产者消费者进程对counter互斥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer[in] = nextProduced;</span><br><span class="line">in = (in + 1) % BUFFER_SIZE;</span><br><span class="line">counter++;</span><br><span class="line"></span><br><span class="line">nextConsumed = buffer[out];</span><br><span class="line">out = (out + 1) % BUFFER_SIZE;</span><br><span class="line">counter--;</span><br><span class="line"></span><br><span class="line">生产者：</span><br><span class="line"> &#123;</span><br><span class="line">  …</span><br><span class="line">  生产一个产品</span><br><span class="line">  …</span><br><span class="line">  wait(empty);</span><br><span class="line">  wait(m);</span><br><span class="line">   …</span><br><span class="line">  C1：把产品放入指定缓冲区</span><br><span class="line">   …</span><br><span class="line">  signal(m);</span><br><span class="line">  signal(full);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">消费者：</span><br><span class="line"> &#123;</span><br><span class="line">  …</span><br><span class="line">  wait(full)；</span><br><span class="line">  wait(m);</span><br><span class="line">   …</span><br><span class="line">  C2：从指定缓冲区取出产品</span><br><span class="line">   …</span><br><span class="line">  signal(m);</span><br><span class="line">  signal(empty);</span><br><span class="line">   …</span><br><span class="line">  消费取出的产品</span><br><span class="line">   …</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>`同步分析</p>
<ul>
<li>找出需要同步的代码段</li>
<li>分析片段执行顺序</li>
<li>增加同步信号量并赋初始值</li>
<li>关键代码前后加wait和signal操作 `生产者</li>
<li>判断是否能获得空缓冲区，否则阻塞</li>
<li>满缓冲区数量++，如果有消费者由于等待阻塞，唤醒该消费者 `消费者</li>
<li>判断能否获得满缓冲区，否则阻塞</li>
<li>空缓冲区数量++，如果有生产者等待，唤醒该生产者</li>
</ul>
<h4 id="读者写者问题">读者写者问题</h4>
<p>两组并发进程读者和写者,共享一组数据区进行读写 `要求</p>
<ul>
<li>允许多个读者同时读</li>
<li>不允许读者、写者同时读写</li>
<li>不允许多个写者同时写 `读者</li>
<li>无读者写者，新读者可读</li>
<li>有写者等，其他读者读，新读者可读</li>
<li>有写者写，新读者等 `写者</li>
<li>无读者写者，新写者可写</li>
<li>有读者读，写者等</li>
<li>有其他写者，写者等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个读者计数器rc，设置初始值为0；</span><br><span class="line">读者：Repeat</span><br><span class="line">P(mutex);</span><br><span class="line">readcount:=readcount+1;</span><br><span class="line">if readcount=1</span><br><span class="line">then P (w);</span><br><span class="line">V(mutex);//mutex为互斥信号量，初始值为1</span><br><span class="line">读</span><br><span class="line">P(mutex);</span><br><span class="line">readcount:=readcount-1;</span><br><span class="line">if readcount=0</span><br><span class="line">then V(w);</span><br><span class="line">V(mutex);</span><br><span class="line">Until false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Writers</span><br><span class="line">……</span><br><span class="line">P(W);</span><br><span class="line">写</span><br><span class="line">V(W);</span><br><span class="line">…...</span><br></pre></td></tr></table></figure>
<p>`问题：写者可能饥饿</p>
<ul>
<li>读者写者互斥，写者直到读者count为0才进入进程</li>
</ul>
<h4 id="哲学家就餐问题">哲学家就餐问题</h4>
<p>5个哲学家、5根筷子，每个哲学家左右各有一根筷子，每个哲学家只有拿起左右两个筷子才能吃饭 五个元素数组储存筷子，对每个哲学家有拿起左右筷子，放下左右筷子的函数 `防止死锁</p>
<h5 id="方法1">方法1</h5>
<p>最多允许四个哲学家同时坐在桌子周围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semephore *chopstick[5];   //初始值为1</span><br><span class="line">semaphore *seat;  //初始值为4</span><br><span class="line">哲学家 i:</span><br><span class="line">  ……</span><br><span class="line">  P(seat);  //看看4个座位是否有空</span><br><span class="line">  P(chopStick[i]);  //拿左边筷子</span><br><span class="line">  P(chopStick[(i + 1) % 5]);  //拿右边筷子</span><br><span class="line">   吃饭</span><br><span class="line">   V(chopStick[i]);  //放下左边筷子</span><br><span class="line">   V(chopStick[(i + 1) % 5]);  //放下右边筷子</span><br><span class="line">   V(seat);  //释放占据的位置</span><br></pre></td></tr></table></figure>
<ul>
<li>左右筷子都可用时才拿起筷子</li>
<li>非对称解决，单号哲学家优先拿左边筷子，双号优先拿右边</li>
</ul>
<h5 id="方法2">方法2</h5>
<p>仅当一个哲学家左右两边筷子都可用时，才允许他拿筷子 哲学家分为三个状态thinking,hungry,eating 设置5个信号量代表所有哲学家，仅当自身hungry且左右都不在吃饭时才开始eating</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(int i);</span><br><span class="line">    &#123;</span><br><span class="line">        if (state[i] == hungry) &amp;&amp;  //是否饿了</span><br><span class="line">          (state[(i+4)%5]!=eating) &amp;&amp; //左边哲学家是否在吃饭</span><br><span class="line">          (state[(i+1)%5]!=eating)  //右边哲学家是否在吃饭</span><br><span class="line">          &#123;</span><br><span class="line">                 state[i]=eating;  //设置哲学家状态为eating</span><br><span class="line">                 V(ph[i]);  //ph[i]设置为1</span><br><span class="line">           &#125;     </span><br><span class="line">     &#125;</span><br><span class="line">     state[i]=hungry；</span><br><span class="line">            P(m);</span><br><span class="line">            test(i);</span><br><span class="line">            V(m);</span><br><span class="line">            P(ph[i]);</span><br></pre></td></tr></table></figure>
<h5 id="方法3">方法3</h5>
<p>给所有哲学家编号，奇数号哲学家必须首先拿左边筷子，偶数号哲学家则反之</p>
<h3 id="信号量总结">信号量总结</h3>
<p>S&gt;0：有S个资源可用 S=0：无资源可用 S&lt;0：则|S|表示S等待队列中的进程个数 P(S)：申请一个资源 V(S)：释放一个资源 互斥信号量初始值：一般为1 同步信号量初始值：0-N `P、V操作成对出现 互斥操作：P、V操作处于同一进程内 同步操作：P、V操作在不同进程内 两个一起的P操作的顺序至关重要 同步与互斥P操作一起时，同步P操作要在互斥P操作前 两个V操作的次序无关紧要</p>
<p><code>缺点</code>：同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如P、V操作的次序错误、重复或遗漏） 易读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序； 不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局； 正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误；</p>
<h2 id="管程">管程</h2>
<p>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据 封装数据以及对数据的操作 确保每次只要一个进程在管程内活动 <code>互斥 管程中的变量只能被管程中的操作访问 任何时候只有一个进程在管程中操作 类似临界区 由编译器完成</code>同步 条件变量 唤醒和阻塞操作 x.wait(): 进程阻塞直到另外一个进程调用x.signal() x.signal()：唤醒另外一个进程</p>
<h3 id="问题">问题</h3>
<p>管程内可能存在不止1个进程 如：进程P调用signal操作唤醒进程Q后 存在的可能 P等待直到Q离开管程 （Hoare） Q等待直到P离开管程（Lampson &amp; Redll，MESA语言） P的signal操作是P在管程内的最后一个语句 (Hansen，并行Pascal)</p>
<h2 id="内存概念">内存概念</h2>
<ul>
<li>程序必须装入内存才能被执行</li>
<li>CPU可以直接访问的存储器只有主存和寄存器</li>
<li>寄存器通常可以在一个（或少于一个）CPU时钟周期内完成访问</li>
<li>完成主存访问可能需要多个CPU时钟周期</li>
<li>CPU暂停（Stall）：在读取内存数据时，CPU空闲</li>
<li>Cache 位于主存和CPU寄存器之间，协调速度差异</li>
<li>内存保护需要保证正确的操作</li>
<li>基址寄存器（ Base）：进程最小的合法物理内存地址</li>
<li>界限寄存器（Limit）：进程地址的长度</li>
<li>CPU在执行指令时，需要进行地址合法性验证 <code>给进程提供一段地址</code>：基地址寄存器（最小地址）和界限地址寄存器（地址范围） 物理地址对进程是隐藏的 <code>地址绑定（程序加载地址）</code>：可以静态绑定也可以动态绑定，动态绑定生成可重定位代码 <code>动态加载</code>，所有程序以可重定位格式存储在磁盘，只有在调用时才被加载 <code>动态链接和共享库</code>:每个库程序都有一个存根，指出如何定位内存驻留库程序，或者程序不在内存时如何家在程序，执行存根时检查程序是否在内存，若不是，则加载程序到内存</li>
</ul>
<h3 id="地址绑定">地址绑定</h3>
<p>地址绑定（重定位）：把程序中的相对地址转换为内存中的绝对地址的过程 指令和数据绑定到内存地址可在三个不同阶段： <code>编译时期（ Compile time） 如果内存位置已知，可生成绝对代码 如果开始位置改变，需要重新编译代码</code>加载时期（ Load time） 如果存储位置在编译时不知，则必须生成可重定位（ relocatable ）代码 `执行时期（ Execution time） 如果进程执行时可在内存移动，则地址绑定可延迟到运行时 需要硬件对地址映射的支持（例如基址和限长寄存器） 大部分操作系统用这个方法</p>
<h3 id="逻辑地址和物理地址">逻辑地址和物理地址</h3>
<p>逻辑地址空间的概念同物理地址空间相关联，它是正确内存管理的中心 逻辑地址Logical address 由CPU产生 在进程内的相对地址 也称：虚拟地址、程序地址 物理地址Physical address 内存地址 所有内存统一编址 也称：绝对地址、实地址</p>
<h3 id="内存管理单元">内存管理单元</h3>
<p>把虚拟地址映射到物理地址的硬件 是CPU用来管理内存的控制线路 在MMU策略中，基址寄存器中的值在其送入内存的时候被加入到由一个用户进程所产生的每个地址中 用户程序所对应到的是逻辑地址，物理地址对它从来都不可见</p>
<h3 id="动态加载和链接">动态加载和链接</h3>
<p><code>加载 例程在调用之前并不加载 更好的内存空间利用率 没有被使用的例程不被载入 当需大量代码来处理不经常使用的功能时非常有用</code>链接 和各种库文件的链接被推迟到执行时期 需要动态装载技术支持 一小段代码 - 存根，用来定位合适的保留在内存中的库程序 存根用例程地址来替换自己，并开始执行例程 操作系统需要检查例程是否在进程的内存空间，所以需要操作系统支持</p>
<h3 id="交换">交换</h3>
<p>一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行。 <code>备份区</code>—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">滚入，滚出(Roll out, roll in )—交换由于基于优先级的算法而不同，低优先级的进程被换出，这样高优先级的进程可以被装入和执行。</span><br><span class="line">交换时间的主要部分是转移时间，总的转移时间直接同交换的内存的数量成比例。</span><br><span class="line">在许多系统如：UNIX，Linux，Windows中，可以找到一些被修正过的交换措施。</span><br><span class="line">系统维持一个就绪队列，它包括在备份存储或在内存中准备运行的所有进程</span><br></pre></td></tr></table></figure>
<h2 id="连续内存分配">连续内存分配</h2>
<p>为一个用户程序分配一个连续的内存空间</p>
<ul>
<li>单一连续分配：单道程序环境下，仅装有一道用户程序，即整个内存的用户空间由该程序独占</li>
<li>固定分区分配 固定分配多个区域，用于放置单个进程 预先把可分配的主存空间分割成若干个连续区域，称为一个分区。 每个分区的大小可以相同也可以不同。但分区大小固定不变，每个分区装一个且只能装一个程序 内存分配：如果有一个空闲分区, 则分配给进程</li>
<li>可变分区分配： 用表格记录内存使用情况，根据内存块和孔调度进程 当一个进程到来的时候，它将从一个足够容纳它分区中分配内存。 操作系统包含以下信息:</li>
</ul>
<ol type="a">
<li>已分配的分区-已分配分区表   b) 空的分区-空闲分区表</li>
</ol>
<h3 id="选择孔">选择孔</h3>
<ul>
<li>首次适应（First-fit）: 分配最先找到的合适的分区</li>
<li>最佳适应（Best-fit）: 搜索整个列表，找到适合条件的最小的分区进行分配</li>
<li>最差适应（Worst-fit）: 搜索整个列表，寻找最大的分区进行分配</li>
</ul>
<p><code>碎片</code>：</p>
<ul>
<li>外部碎片：存储被分为大量小孔</li>
<li>内部碎片：分配给进程的孔，进程不需要使用的部分则成为内部碎片 外碎片 –整个可用内存空间可以用来满足一个请求，但它不是连续的 内碎片 –分配的内存可能比申请的内存大一点，这两者之间的差别是在分区内部，但又不被使用 `可通过紧缩来减少外碎片 把一些小的空闲内存结合成一个大的块。 只有重定位是动态的时候，才有可能进行紧缩，紧缩在执行时期进行</li>
</ul>
<h2 id="分段">分段</h2>
<p>一个程序是一些段的集合，一个段是一个逻辑单位 每个段用段名称和段偏移指定位置 一个逻辑地址是两个向量的集合: &lt;segment-number, offset&gt;</p>
<p>段表 - 映射二维用户地址，每个表项包括: 基址 - 包含内存中段物理地址的起始地址 限长 - 指定段的长度 段表基址寄存器(STBR)指向段表在内存中的地址 段表限长寄存器(STLR)表明被一个程序所使用的段的数目 如果 s &lt; STLR，段号s 是合法的</p>
<p>由于段的长度各不相同，内存分配是一个动态存储-分配问题</p>
<p>`内存分配 首先/最佳适应法 外碎片问题</p>
<p>`重定位 动态 由段表来执行</p>
<p>`共享 共享的段 同样的段号</p>
<h2 id="分页">分页</h2>
<p>允许进程的物理地址不连续 <code>基本方法</code>：将物理内存分为固定大小的块，称为帧或页帧，逻辑内存分为同样大小的块，称为页或页面 进程物理地址空间可能不连续 如果有可用的物理内存，它将分给进程 把物理内存分成大小固定的块，称为帧（Frame） 大小为2的幂 早期：512字节至8192字节 现在：4K-64K 把逻辑内存也分为同样大小的块，称为页（Page） 系统保留所有空闲帧的记录 运行一个有N页大小程序，需要找到N个空帧来装入程序 建立一个页表，把逻辑地址转换为物理地址 存在内碎片 <code>内存保护 内存的保护由与每个帧相连的保护位来实现 有效-无效位附在页表的每个表项中: “有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页 “无效”表示页不在进程的逻辑地址空间中</code>共享代码 如果代码是可重入代码（只读），可以在进程间共享 (如文本编辑器, 编译器, 数据库系统) 共享代码必须出现在所有进程的逻辑地址空间的相同位置<br />
`私有代码和数据 每个进程保留一个代码和数据副本 存有私有数据和代码的页能够出现在逻辑地址空间的任意位置</p>
<h3 id="页表的层次结构">页表的层次结构</h3>
<h4 id="二层页表">二层页表</h4>
<p>内存的保护由与每个帧相连的保护位来实现 有效-无效位附在页表的每个表项中: “有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页 “无效”表示页不在进程的逻辑地址空间中 <img src="/images/obsidian/20230605104632.png" title="image" alt="图片" /></p>
<h4 id="哈希页表">哈希页表</h4>
<p>虚拟页号被散列到一个页表中。这种页表的每一个条目都包括了一个链表元素，这些元素哈希成同一 虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。 虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。</p>
<h4 id="反向页表">反向页表</h4>
<p>对于每个真正的内存页或帧有一个条目。 每个条目保存在真正内存位置的页的虚拟地址，以及包括拥有这个页的进程的信息。 `优缺点 减少了需要储存每个页表的内存，但是当访问一个页时，增加了寻找页表需要的时间。 使用哈希表来将查找限制在一个或少数几个页表条目。 实现共享内存困难</p>
<h4 id="段页式原理">段页式原理</h4>
<p>分段和分页原理的结合 先将用户程序分成若干个段，再把每个段分成若干个页，并为每个段赋予一个段号 逻辑地址：&lt;段号，页号，页内偏移&gt; 存在内碎片 无外碎片</p>
<h3 id="内存扩充技术">内存扩充技术</h3>
<ol type="1">
<li>紧缩Compaction（可变分区）</li>
<li>覆盖技术Overlaying</li>
<li>交换技术Swapping</li>
<li>虚拟内存Virtual Memory</li>
</ol>
<h4 id="覆盖">覆盖</h4>
<p>解决问题à程序大小超过物理内存总和 程序执行时 只在内存中保留那些在任何时间都需要的指令和数据 程序的不同部分在内存中相互替换 由程序员声明覆盖结构，不需要操作系统的特别支持 覆盖结构的程序设计很复杂 应用于早期的操作系统</p>
<h4 id="交换-1">交换</h4>
<p>在多道程序环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况 另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况 浪费资源，降低系统吞吐量。 一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行 备份区—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问 交换（备份区）：系统指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问</p>
<h2 id="系统模型">系统模型</h2>
<p>资源类型 R1, R2, . . ., Rm CPU周期，内存空间，I/O设备 每一种资源Ri 有Wi  种实例 每一个进程通过如下方法来使用资源 申请，使用，释放 资源动态申请-常用方法 在进程运行过程中申请资源 资源静态申请 在进程运行前一次申请所有资源</p>
<h2 id="必要条件">必要条件</h2>
<p>死锁指一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组中其他进程所持有的资源</p>
<ul>
<li>互斥：一次只有一个进程可以使用一个资源</li>
<li>占用并等待：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源</li>
<li>非抢占：一个资源只有当持有它的进程完成任务后，自由的释放</li>
<li>循环等待：等待资源的进程之间存在环 {P0, P1, …, P0}</li>
</ul>
<h2 id="资源分配图">资源分配图</h2>
<p>被分为两个部分 P = {P1, P2, …, Pn}, 含有系统中全部的进程 R = {R1, R2, …, Rm}, 含有系统中全部的资源 请求边：有向边Pi-&gt;Rj 分配边：有向边Ri-&gt;P</p>
<ul>
<li>如果图没有环，那么不会有死锁</li>
<li>如果图有环 如果每一种资源类型只有一个实例，那么死锁发生 如果一种资源类型有多个实例，可能死锁 <img src="/images/obsidian/20230604203017.png" title="image" alt="图片" /></li>
</ul>
<h2 id="死锁处理的分类">死锁处理的分类</h2>
<ul>
<li>确保系统永远不会进入死锁状态 死锁预防 死锁避免</li>
<li>允许系统进入死锁状态，然后检测它，并加以恢复 死锁检测 死锁恢复</li>
<li>忽略这个问题，假装系统中从未出现过死锁。 这个方法被大部分的操作系统采用，包括UNIX、Windows 由开发人员自行处理死锁</li>
</ul>
<h3 id="预防">预防</h3>
<p>`抑制死锁发生的必要条件</p>
<ul>
<li>互斥：可共享资源不涉及死锁，互斥资源必须强制互斥</li>
<li>持有并等待：保证进程申请资源时不占有其他资源，要求进程在执行前一次性申请全部资源，或者只有不占有资源时才可以分配资源，`可能出现饥饿</li>
<li>抢占：</li>
</ul>
<ol type="1">
<li>如果一个进程的申请没有实现，它要释放所有占有的资源</li>
<li>先占的资源放入进程等待资源列表中</li>
<li>进程在重新得到旧的资源的时候可以重新开始</li>
<li>进程申请资源时，如果资源可用则分配，如果不可用，检查资源是否被分配给等待额外资源的其他进程，如果是，抢占资源，否则，申请进程等待</li>
</ol>
<ul>
<li>循环等待:对所有资源完全排序，进程按顺序申请资源 银行家算法</li>
</ul>
<h3 id="避免">避免</h3>
<ul>
<li>一个简单而有效的模型要求每一个进程声明它所需要的资源的最大数</li>
<li>死锁避免算法动态检查资源分配状态以确保循环等待条件不可能成立</li>
<li>资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量所决定</li>
</ul>
<h4 id="安全状态">安全状态</h4>
<p>当进程申请一个有效的资源的时候，系统必须确定分配后是安全的 如果存在一个安全序列，系统处于安全态 进程序列&lt;P1, P2, …, Pn&gt;是安全的，如果每一个进程Pi所申请的可以被满足的资源数加上其他进程所持有的该资源数小于系统总数 如果 Pi 需要的资源不能马上获得，那么Pi 等待直到所有的Pi-1进程结束。 当Pi-1 结束后， Pi获得所需的资源，执行、返回资源、结束。 当Pi结束后， Pi+1获得所需的资源执行，依此类推。 `定理 如果一个系统在安全状态，就没有死锁 如果一个系统不是处于安全状态，就有可能死锁 避免=&gt;确保系统永远不会进入不安全状态</p>
<h4 id="银行家算法">银行家算法</h4>
<ul>
<li>多个实例</li>
<li>每一个进程必须事先声明使用的最大量</li>
<li>当一个进程请求资源，它可能要等待</li>
<li>当一个进程得到所有的资源，它必须在有限的时间释放它们</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Available:  长度为 m的向量。 如果available[j]=k,那么资源Rj有k个实例有效</span><br><span class="line">Max: n x m 矩阵。 如果Max[i,j]=k,那么进程Pi最多可以请求k个资源Rj的实例</span><br><span class="line">Allocation:  n x m 矩阵。 如果Allocation[i,j]=k,那么进程Pj当前分配了k个资源Rj的实例</span><br><span class="line">Need:  n x m 矩阵。如果Need[,j]=k,那么进程Pj还需要k个资源Rj的实例</span><br><span class="line">Need [i,j] = Max[i,j] – Allocation [i,j].</span><br><span class="line">1.让Work和Finish作为长度为m和n的向量初始化：</span><br><span class="line">Work := Available</span><br><span class="line">Finish [i] = false for i - 1,2,3, …, n.</span><br><span class="line">2.  查找i</span><br><span class="line">(a) Finish [i] = false</span><br><span class="line">(b) Needi £ Work</span><br><span class="line">If no such i exists, go to step 4.</span><br><span class="line">3.  Work := Work + Allocationi  </span><br><span class="line">Finish[i] := true  </span><br><span class="line">go to step 2.</span><br><span class="line">4.  如果对所有i的 Finish [i] = true, 则系统处在安全状态。</span><br></pre></td></tr></table></figure>
<p>   Requesti =进程 Pi 的资源请求向量.  如果Requesti [m] = k 则进程 Pi 想要资源类型为Rjm的k个实例 1.  如果 Requesti £ Needi 转 step 2.  否则报错, 因为进程请求超出了其声明的最大值 2.  如果 Requesti £ Available, 转 step 3.  否则 Pi  必须等待, 因为资源不可用. 3.  假设通过修改下列状态来分配请求的资源给进程Pi :   Available := Available - Requesti;   Allocationi := Allocationi + Requesti;   Needi := Needi – Requesti;;   •如果系统安全 Þ 将资源分配给 Pi. •如果系统不安全 Þ Pi 必须等待，恢复原有的资源分配状态</p>
<h3 id="死锁检测和恢复">死锁检测和恢复</h3>
<p><code>每个资源类型有一个实例</code>：维护进程等待图 <code>每个资源类型有多个实例</code>：用available和finished数组探查是否死锁 允许进入死锁状态并加以恢复 维护等待图 节点是进程 Pi-&gt;Pj表明Pi在等待Pj 定期调用算法来检查是否有环 一个检查图中是否有环的算法需要n^2的操作来进行，n为图中的节点数 Available ：一个长度为m的向量，表示每一种资源类型可用的实例数目 Allocation:  一个n x m 的矩阵，定义了当前分配的每一种资源类型的实例数目 Request: 一个n x m 的矩阵，表明了当前的进程请求。如果Request[i，j]=k，那么进程Pi请求k个资源Rj的实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  让Work和Finish作为长度为m和n的向量初始化</span><br><span class="line">(a) Work = Available</span><br><span class="line">(b)  For i = 0,2, …, n-1, if Allocationi ¹ 0, thenFinish[i] = false;otherwise, Finish[i] = true.</span><br><span class="line"></span><br><span class="line">2.  找到满足下列条件的下标i</span><br><span class="line">(a)  Finish[i] = false</span><br><span class="line">(b)  Requesti &lt;= Work</span><br><span class="line">如果没有这样的i存在，转4</span><br><span class="line"></span><br><span class="line">3.  Work = Work + Allocationi  </span><br><span class="line">Finish[i] = true  </span><br><span class="line">转 2.</span><br><span class="line"></span><br><span class="line">4.如果有一些i (0 £ i &lt; n) , Finish[i] = false, 则系统处在死锁状态。而且， 如果 Finish[i] = false, 则进程 Pi 是死锁的。</span><br></pre></td></tr></table></figure>
<p>`算法需要m x n^2 次操作来判断是否系统处于死锁状态</p>
<h4 id="恢复">恢复</h4>
<p>可以一次中断所有进程排查，也可以一个一个终结进程 选择牺牲进程：最小化代价 回滚：返回到安全的状态，然后重新开始进程 饥饿：同样进程的可能总是被选中。在代价因素中加入回滚次数</p>
<h2 id="虚拟内存概念">虚拟内存概念</h2>
<p><code>局部性原理</code>：在一较短的时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域 一个程序只要部分装入内存就可以运行 整个程序不是同一时间都要运行 `程序部分装入技术优点 进程大小不再受到物理内存大小限制 每个进程需要的内存更小 更多进程可以并发运行 I/O更少</p>
<ul>
<li>虚拟存储技术：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存执行。</li>
<li>虚拟地址空间：分配给进程的虚拟内存</li>
<li>虚拟地址：在虚拟内存中指令或数据的位置</li>
<li>虚拟内存：把内存和磁盘有机结合起来使用，得到一个容量很大的“内存”，即虚存 <code>特点 只有部分运行的程序需要在内存中 逻辑地址空间能够比物理地址空间大 允许多个进程享同一地址空间 允许更有效的进程创建</code>虚拟内存能够通过以下手段来执行实现: 虚拟页式（虚拟存储技术+页式存储管理） 虚拟段式（虚拟存储技术+段式存储管理） `虚拟页式有两种方式 按需调页（ Demand paging ） 预调页（Prepaging）</li>
</ul>
<h2 id="虚拟页式存储管理">虚拟页式存储管理</h2>
<p><code>基本思想 进程开始运行之前，不是装入全部页面，而是装入一个或零个页面 运行之后，根据进程运行需要，动态装入其他页面 当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面</code>请求分页（按需调页） 只有在一个页需要的时候才把它换入内存 需要很少的I/O 需要很少的内存 快速响应 多用户 <code>懒惰交换</code>:只有在需要页时，才将它调入内存 交换程序(swapper)对整个进程进行操作 调页程序(pager)只是对进程的单个页进行操作</p>
<h3 id="有效无效位">有效无效位</h3>
<p>每一个页表的表项有一个有效- 无效位相关联： 1表示在内存，0表示不在内存 在所有的表项中，这个位被初始化为0 一个页表映象的例子</p>
<h3 id="缺页中断的处理">缺页中断的处理</h3>
<p>1.访问指令或数据 2.查看另一个表来决定: 无效引用 Þ 终止 仅仅不在内存 3.找到页在后备存储上的位置 4.得到空的页框，把页换入页框 5.重新设置页表，把有效位设为v 6.重启指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">极端情况：进程执行第一行代码时，内存内没有任何代码和数据</span><br><span class="line">进程创建时，没有为进程分配内存，仅建立PCB</span><br><span class="line">导致缺页中断</span><br><span class="line">纯请求分页（纯粹按需调页）</span><br><span class="line"></span><br><span class="line">一条指令可能导致多次缺页（涉及多个页面）</span><br><span class="line">幸运的是，程序具有局部性（locality of reference）</span><br><span class="line"></span><br><span class="line">请求调页需要硬件支持</span><br><span class="line">带有效无效位的页表</span><br><span class="line">交换空间</span><br><span class="line">指令重启</span><br><span class="line"></span><br><span class="line">缺页率（缺页的概率）：0 &lt;= p &lt;= 1.0</span><br><span class="line">如果 p = 0 ，没有缺页</span><br><span class="line">如果 p = 1， 每次访问都缺页</span><br><span class="line"></span><br><span class="line">有效访问时间（ EAT ）</span><br><span class="line">    EAT = (1 – p) x 内存访问时间+ p x 页错误时间</span><br><span class="line"></span><br><span class="line">页错误时间=处理缺页中断</span><br><span class="line">  + [页交换出去时间 ]</span><br><span class="line">  + 读入页时间</span><br><span class="line">  + 重启进程开销</span><br></pre></td></tr></table></figure>
<p><code>性能优化</code>： 页面转换时采用交换空间，而不是文件系统 交换区的块大，比文件系统服务快速</p>
<p>在进程装载时，把整个进程拷贝到交换区 基于交换区调页 早期的 BSD Unix</p>
<p>利用文件系统进行交换 Solaris和当前的BSD 部分内容仍旧需要交换区（堆栈等） <code>写时复制</code>:允许父进程和子进程在初始化时共享页面 如果其中一个进程修改了一个共享页面，会产生副本 更加高效 应用在Windows，Linux，macOS等系统</p>
<h3 id="需要页置换的情况">需要页置换的情况</h3>
<p>页置换—找到内存中当前没有使用的一些页，换出 同一个页可能会被装入内存多次 基本页置换方法</p>
<ol type="1">
<li>查找所需页在磁盘上的位置</li>
<li>查找一空闲帧 如果有空闲帧，就使用它 如果没有空闲帧，使用页置换算法选择一个“牺牲”页框 将“牺牲”帧的内容写到磁盘上，更新页表和帧表</li>
<li>将所需页读入（新）空闲帧，更新页表和帧表</li>
<li>重启用户进程</li>
</ol>
<p>如果发生页置换，则缺页处理时间加倍 使用修改位modify bit或脏 (dirty bit) 来防止页面转移过多—只有被修改的页面才写入磁盘 页置换完善了逻辑内存和物理内存的划分—在一个较小的物理内存基础之上可以提供一个大的虚拟内存</p>
<h2 id="页面置换算法">页面置换算法</h2>
<h3 id="先进先出fifo算法">先进先出(FIFO)算法</h3>
<p>置换在内存中驻留时间最长的页面 容易理解和实现、但性能不总是很好 实现：使用FIFO队列管理内存中的所有页 FIFO算法可能会产生Belady异常 更多的页框 =&gt;更多的缺页</p>
<h3 id="最优置换算法opt">最优置换算法OPT</h3>
<p>被置换的页是将来不再需要的或最远的将来才会被使用的页 实现？ 作用：作为一种标准来衡量其它算法的性能</p>
<h3 id="最近最少使用算法lru">最近最少使用算法(LRU)</h3>
<p>置换最长时间没有使用的页 性能接近OPT 实现：计数器（时间戳）或栈 开销大、需要硬件支持 栈实现—在一个双链表中保留一个记录页数目的栈: 被访问的页: 移到栈顶 需要改变6个指针 没有为置换进行查找</p>
<p>在没有硬件支持的系统中，可使用LRU近似算法访问位 每个页都与一个位相关联，初始值为0 当页访问时设位1</p>
<ul>
<li>附加引用位算法</li>
<li>二次机会算法</li>
<li>增强型二次机会算法</li>
</ul>
<h3 id="二次机会算法">二次机会算法</h3>
<p>需要访问位 如果访问位为0，直接置换 如果将要交换的页访问位是1，则: 把访问位设位0 把页留在内存中 以同样的规则，替换下一个页</p>
<p>实现：时钟置换（顺时针方式）</p>
<h3 id="基于计数的页面置换">基于计数的页面置换</h3>
<p>用一个计数器记录对每一个页的访问次数 LFU 以最小的计数置换一个页</p>
<h3 id="页面缓冲算法">页面缓冲算法</h3>
<ol type="1">
<li>总是保留一个空闲帧缓冲池</li>
</ol>
<ul>
<li>在缺页错误时有帧可用</li>
<li>读页面到空闲帧，无需等待写出牺牲帧</li>
<li>牺牲帧以后被写出后，添加到缓冲池</li>
</ul>
<ol start="2" type="1">
<li>扩展之一，维护一个修改页面的列表</li>
</ol>
<ul>
<li>当设备空闲时选择一个修改页面写到磁盘上，然后重置它的修改位</li>
</ul>
<ol start="3" type="1">
<li></li>
<li>另一种修改,保留一个空闲帧池，并且记着哪些页面在哪些帧内</li>
</ol>
<ul>
<li>如果在重用之前被再次需要，就不需要从磁盘上重新装载了</li>
<li>降低因错误选择牺牲页面而引起的开销</li>
</ul>
<h2 id="帧分配">帧分配</h2>
<p>两种主要分配策略</p>
<ul>
<li>固定分配</li>
<li>优先分配</li>
</ul>
<h3 id="固定分配">固定分配</h3>
<p>平均分配 Equal allocation– 例如，如果有100帧和5个进程，给每个进程20帧 在缓冲池里保存空闲帧 比例分配 Proportional allocation – 根据进程大小分配内存 按照多道程度而动态分配，进程分得的数量变化</p>
<h3 id="优先级分配">优先级分配</h3>
<p>优先级分配:用优先级而不是大小来进行比例分配<br />
如果进程 Pi 跑出页面错误, 从自己的帧里选择一个替代 从优先级较低的进程里选择一个替代</p>
<h3 id="全局-vs.-局部分配">全局 vs. 局部分配</h3>
<p>全局置换 Global replacement – 允许进程从所有帧的集合中选择一个置换帧；一个进程可以从另一个进程那里获取帧 但是进程执行时间可能变化很大，不能控制缺页错误率 有更好的系统吞吐量，更常用 局部置换 Local replacement – 每个进程只从它自己分配的帧中进行选择 对每个进程的表现更一致 但是可能内存低利用</p>
<h4 id="非均匀内存访问numa">非均匀内存访问（NUMA）</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v以上假设所有内存可以被平等访问</span><br><span class="line"></span><br><span class="line">v很多系统如 NUMA – 内存访问速度变化的</span><br><span class="line"></span><br><span class="line">考虑CPU和内存在系统中通过总线互连</span><br><span class="line"></span><br><span class="line">v让分配的内存帧‘尽可能地靠近’运行进程的CPU</span><br><span class="line"></span><br><span class="line">通常意味着位于同一系统扳</span><br><span class="line"></span><br><span class="line">Solaris通过在内核中创建延迟组 lgroups</span><br><span class="line"></span><br><span class="line">v将相近的CPU和内存聚集在一起</span><br><span class="line"></span><br><span class="line">v在组内调度进程的所有线程，并分配它的所有内存</span><br><span class="line"></span><br><span class="line">v最大限度减少总体内存延迟，最大化CPU缓存命中率</span><br></pre></td></tr></table></figure>
<h2 id="抖动">抖动</h2>
<p>如果一个进程没有足够的页，那么缺页率将很高，这将导致: CPU利用率低下. 操作系统认为需要增加多道程序的道数 系统中将加入一个新的进程 颠簸（抖动）=一个进程的页面经常换入换出 原因：分配的帧数 &lt; 局部大小之和</p>
<h3 id="工作集模型">工作集模型</h3>
<p>工作集窗口 º 固定数目的页的引用 WSSi (进程Pi的工作集) = 最近D中所有页的引用 (随时间变化) <img src="/images/obsidian/20230605190700.png" title="image" alt="图片" /> vExample: D = 10,000</p>
<p>每5000个时钟单位时钟中断</p>
<p>为每个页在内存中保留两个位</p>
<p>任何时候一个时钟中断拷贝，把所有访问位设为0</p>
<p>如果一个在内存中的位是0，说明页在工作集</p>
<h3 id="内存映射文件">内存映射文件</h3>
<p>通过映射一个磁盘块成内存的一页，内存映象文件I/O 允许文件I/O 作为普通内存访问。 开始的文件访问按普通请求分页来进行，一页大小的部分文件从文件系统读入物理页。以后文件的读、写操作就按通常的内存访问来处理。 由于通过内存的文件操作而不是使用系统调用read() write() ，简化了文件访问和使用。 多个进程可以允许将同一文件映射到各自的虚拟内存中，以允许数据共享</p>
<h2 id="内核内存分配">内核内存分配</h2>
<p>通常从空闲内存池中获取 内核需要为不同大小的数据结构分配内存 一些内核内存需要连续的物理页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v内核在使用内存块时有如下特点：</span><br><span class="line"></span><br><span class="line">    (1)内存块的尺寸比较小；</span><br><span class="line"></span><br><span class="line">    (2)占用内存块的时间比较短；</span><br><span class="line"></span><br><span class="line">    (3)要求快速完成分配和回收；</span><br><span class="line"></span><br><span class="line">    (4)不参与交换。</span><br><span class="line"></span><br><span class="line">    (5)频繁使用尺寸相同的内存块，存放同一结构的数据；</span><br><span class="line"></span><br><span class="line">    (6)要求动态分配和回收。</span><br></pre></td></tr></table></figure>
<h3 id="伙伴buddy系统">伙伴(Buddy)系统</h3>
<p>v主要用于Linux早期版本中内核底层内存管理 v一种经典的内存分配方案 v从物理上连续的大小固定的段上分配内存 v主要思想：内存按2的幂的大小进行划分，即4KB、8KB等，组成若干空闲块链表；查找链表找到满足进程需求的最佳匹配块 满足要求是以2的幂为单位的 如果请求不为2的幂，则需要调整到下一个更大的2的幂 当分配需求小于现在可用内存时，当前段就分为两个更小的2的幂段，继续上述操作直到合适的段大小 `算法 首先将整个可用空间看作一块: 2^n 假设进程申请的空间大小为s，如果满足 2<sup>(n-1)&lt;s&lt;=2</sup>n，则分配整个块    否则，将块划分为两个大小相等的伙伴，大小为2^(n-1) 一直划分下去直到产生大于或等于s的最小块</p>
<h3 id="slab-分配">Slab 分配</h3>
<p>v内核分配的另一方案 vSlab 是由一个或多个物理上连续的页组成 vCache 含有一个或多个 slab v每个内核数据结构都有一个cache 每个 cache 含有内核数据结构的对象实例</p>
<p>v当创建 cache 时, 包括若干个标记为空闲的对象 v当内核对象时，从cache上直接获取，并标识对象为使用 v当一个slab充满了已使用的对象时，下一个对象的分配从空的slab开始分配 如果没有空的slab, 则从物理连续页上分配新的slab v优点 ①没有因碎片而引起的内存浪费</p>
<p>②内存请求可以快速满足</p>
<h2 id="杂项">杂项</h2>
<p><code>预调页面 v在进程启动初期，减少大量的缺页中断 v在引用前，调入进程的所有或一些需要的页面 v如果预调入的页面没有被使用，则内存被浪费</code>页面尺寸大小 v碎片 – 需要小的页 v表大小 – 需要大的页 vI/O 开销 – 需要大的页 v程序局部 – 需要小的页 v缺页次数 – 需要大的页 v其他因素 没有最佳答案，总的来说，趋向更大的页 <code>TLB 范围 vTLB 范围 – 通过TLB所访问的内存量 vTLB 范围 = (TLB 大小) X (页大小) v理想情况下，一个进程的工作集应存放在 TLB中 否则会有大量的缺页中断 v增加页的大小 对于不需要大页的应用程序而言，这将导致碎片的增加 v提供多种页的大小 这允许需要大页的应用程序有机会使用大页而不增加碎片的大小</code>倒置页表 v倒置页表降低了保存的物理内存 v不再包括进程逻辑地址空间的完整信息 v为了提供这种信息，进程必须保留一个外部页表 v外部页表可根据需要换进或换出内存 `I/O 联锁与页面锁定 v允许某些页在内存中被锁住</p>
<p>vI/O时，正在进行I/O的页面不允许被置换算法置换出内存 <code>linux vSLAB vDemand paging vGlobal page replacement(LRU) v两个帧列：active_list和inactive_list vKswapd daemon 定期检查</code>windows10 vBoth IA-32 and x86-64 v32bit支持4GB，64bit支持128TB内存 vShared memory, demand paging, copy-on-write, paging和memory compression v按需调页-clustering，预调入3-7页 vWorking-Set 管理（最少50-最多345页）</p>
<h2 id="文件概念">文件概念</h2>
<p><code>文件 计算机中信息存储的基本组织形式 相关信息结合 具有文件名</code>文件名 按名存取：文件名     存储位置 文件名由一串ASCII码或(和)汉字构成 名字长度 v8.3规则：文件名8个字符，类型3个字符，之间有“.”分割 v长文件名：可以最多输入255多个字符作为文件名 文件名可能大小写敏感 <code>文件的打开 v需要数据结构 打开文件表：跟踪打开文件 文件指针:指向最后一次读写的位置，每个进程1个 打开文件计数器：打开文件次数（调用open次数） 文件存储位置：文件存放在存储设备上的位置信息 访问权限：每个进程的访问权限 v优点 方便文件共享 提高文件存取效率</code>文件锁 共享锁 Shared lock 类似于读者锁– 多个进程可以并发获取它。 独占锁 Exclusive lock 类似于写者锁 `文件结构 v目的：便于程序理解文件内容 无结构：文字流、字节流等 简单记录结构：线性、固定长度、可变长度等 复杂结构：格式化文档、多媒体文件等 v谁决定了文件结构 操作系统 程序</p>
<h2 id="文件访问">文件访问</h2>
<h3 id="逻辑文件">逻辑文件</h3>
<p>v文件呈现在用户面前的组织结构 v又称为文件逻辑结构 v逻辑文件决定了文件访问方法 `文件访问方式 - 顺序访问 最简单的访问方式 文件信息按照存放顺序，一个记录一个记录地依次访问 顺序文件 典型存储设备：磁带 - 直接（随机）访问 可以直接定位到文件的某条记录进行访问 直接文件 典型设备：磁盘 v访问方式：直接（随机）访问 v直接通过计算得到需要读写记录的位置，直接跳转进行文件读写 - 索引文件 v基本方法：为顺序文件建立索引表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">记录平均长度：40B   索引表项大小：4B   1M条记录长度：44MB</span><br><span class="line"></span><br><span class="line">访问第1万条记录：</span><br><span class="line"></span><br><span class="line">       1）计算得到第1万条记录的索引项在索引表中首址：10000*4=40000</span><br><span class="line"></span><br><span class="line">       2）从索引表地址40000处读入4个字节，内容为第1万条记录在顺序文件中的首址P</span><br><span class="line"></span><br><span class="line">       3）从顺序文件地址P处读入40个字节（假如第1万条记录长度为40B）</span><br><span class="line"></span><br><span class="line">合计读入：4+40=44B</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="目录结构">目录结构</h2>
<h3 id="文件控制块fcb">文件控制块（FCB）</h3>
<p>存放操控文件所需的各类文件属性信息 文件名 长度 创建时间 存放位置 访问控制权限 类似一个索引项 v目录项 存放一个文件的各类属性 有的系统等同于文件控制块 v目录 包含着所有文件信息的节点集合 根据文件名检索文件的桥梁 目录项的有序集合 v目录文件 目录组织形式 目录作为一个文件存在于文件系统 v每个目录项中存放了文件在存储设备的存放地址 v目录和文件都驻留在存储设备（如磁盘）</p>
<h3 id="文件检索">文件检索</h3>
<p>v文件检索是一个遍历目录项的过程 1.打开目录文件 2.从磁盘读入该目录文件的1个(物理)块，该块包含若干个目录项 3.根据文件名遍历内存中的该块，如找到则结束 4.判断该目录文件是否还有物理块没有读入，如果是转2；否则，结束。表示该目录中没有此文件名的文件 v目录项由于经常变化，一般不排序 v平均遍历目录项数：       （1+n）/2   不包括文件查不到的情况      目录项大小= ds bytes 目录中最多文件数 = n 物理块大小 = b v那么 目录文件大小 = ds*n bytes 目录文件需要的物理块数目 = ds*n/b 检索一个文件需要平均读入的块数=(ds*n/b+1)/2</p>
<h3 id="目录结构-1">目录结构</h3>
<p><code>设计目标 v效率 快速定位文件位置 提高文件访问效率 v命名 方便用户使用 同名的不同文件 不同名的相同文件 v分组 文件分组（子目录） 兼顾效率和方便性</code>单层目录 v所有文件在同一目录中，只有一级目录：根目录 v根目录（/）：一个文件系统最顶层的目录 v优点：结构简单 v缺点 检索效率差（目录下文件过多） 不能有同名文件，一个文件只能有一个名称 不能分组 <code>双层目录 v每个用户有自己的目录结构 v目录下的目录 v缺点：1）无法分组；2）同一用户不能有相同文件名的文件 v优点：1）不同用户可有相同文件名的文件；2）比单层目录提高检索效率（文件分布在多个用户目录中）</code>树形目录 v特点 检索高效（子目录增多导致每个目录下文件减少） 可以分组 允许重名 v当前目录：工作目录 cd /spell/mail/prog type list v绝对路径 从根开始的路径名 v相对路径 从当前目录开始的路径名 提高检索效率 <code>（有向）无环图目录 v文件共享：不同目录中的文件指向同一个物理文件，也就是它们内容相同 v树型目录不能实现文件共享 v解决方法：图型目录 无环图目录 通用图目录（有环图） v无环图：有向边无环</code>如何保证无环？ 仅允许指向文件的链接，不允许指向子目录的链接 垃圾回收 每当加入新链接时，使用环路检测算法判断是否正确 优化遍历目录算法，避免对环的重复搜索</p>
<h2 id="杂项-1">杂项</h2>
<p>v要访问一个文件系统，必须先安装它。 一个未安装的文件系统将被安装在一个安装点(mount point)上。</p>
<h3 id="远程文件系统">远程文件系统</h3>
<p>v用网络使得远程计算机之间的联系成为可能 手动传输文件如 FTP 自动，直接访问文件用分布文件系统 distributed file systems 半自动用万维网 world wide web vClient-server 客户机-服务器模型允许客户机登录远程服务器的文件系统 服务器可以服务多台客户机 识别客户可能是不安全和复杂的 NFS 是标准 UNIX 下客户机-服务器的文件共享协议 CIFS 是Windows下标准协议 标准操作系统文件调用翻译为远程调用 v分布式信息系统 (分布式命名服务 distributed naming services) 如LDAP, DNS, NIS。</p>
<h3 id="故障">故障</h3>
<p>v所有文件系统都有故障模式 例如目录结构或者其他磁盘管理信息（元数据 metadata 损坏。 v远程文件系统加入新的故障模式，来自网络故障或者服务器故障 v从故障中恢复包含维护状态信息 state information vStateless 无状态协议如NFC在每个请求里包含所有信息，允许较为容易的故障恢复但是不够安全</p>
<h3 id="共享">共享</h3>
<p>v规定系统的多个用户如何访问共享文件 类似于第六章的进程同步算法 v由于磁盘和网络的巨大延迟和很慢的传输速率，倾向于没这么复杂 Andrew File System (AFS) 实现了复杂共享语义 Unix file system (UFS) 使用: v一个用户对已打开文件的写入，对于打开同一文件的其他用户立即可见。 v一种共享模式允许用户共享文件的当前位置指针。 AFS 有会话语义 v一旦文件关闭，对其所作的更改只能被后来打开的会话可见。</p>
<h3 id="访问控制权限和分组">访问控制权限和分组</h3>
<p>v访问模式：读/写/执行 v三种类型的用户   RWX   a) 所有者  7  =&gt;1 1 1    RWX   b) 组用户  6  =&gt;  1 1 0 RWX   c) 公共用户  1  =&gt;  0 0 1 v建立一个组，加入一些用户 v对特定的文件或目录(game) ，定义适当的访问权限</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>苏州大学</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利cs61a的python笔记</title>
    <url>/2023/09/29/61a%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="python语言特性">python语言特性</h2>
<h3 id="函数">函数</h3>
<p>名称也可以与函数绑定。例如，名称 <code>max</code> 就和我们之前使用的 <code>max</code> 函数进行了绑定。与数字不同，函数很难以文本呈现，因此当询问一个函数时，Python 会打印一个标识来描述： <span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; max</span><br><span class="line">&lt;built-in function max&gt;</span><br></pre></td></tr></table></figure></p>
<p>赋值语句可以为现有函数赋予新名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f = max</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;built-in function max&gt;</span><br><span class="line">&gt;&gt;&gt; f(2, 3, 4)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>以下指南改编自 <a href="http://www.python.org/dev/peps/pep-0008">Python 代码风格指南</a>, 它可以作为所有（非叛逆的）Python 程序员的指南。这些共享的约定使开发者社区的成员之间的沟通能够顺利进行。作为遵循这些约定的副作用，你会发现你的代码在内部变得更加一致。</p>
<ol type="1">
<li>函数名是小写的，单词之间用下划线分隔。鼓励使用描述性名称。</li>
<li>函数名称通常反映解释器应用于参数的操作（例如， <code>print, add, square</code> ）或结果（例如， <code>max, abs, sum</code> ）。</li>
<li>参数名称是小写的，单词之间用下划线分隔。首选单个词的名称。</li>
<li>参数名称应该反映参数在函数中的作用，而不仅仅是允许的参数类型。</li>
<li>当作用明确时，单字参数名称可以接受，但应避免使用 l（小写的 L）和 O（大写的 o）或 I（大写的 i）以避免与数字混淆。</li>
</ol>
<h3 id="函数设计原则">函数设计原则</h3>
<ul>
<li>每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。</li>
<li>不要重复自己（Don't repeat yourself）是软件工程的核心原则。这个所谓的 DRY 原则指出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。如果你发现自己正在复制粘贴一段代码，那么你可能已经找到了进行函数抽象的机会。</li>
<li>定义通用的函数。比如作为 <code>pow</code> 函数的一个特例的平方函数就不在 Python 库中，因为 <code>pow</code> 函数可以将数字计算为任意次方。 当你使用函数名称作为参数调用 <code>help</code> 时，你会看到它的文档字符串（键入 q 以退出 Python help）。 Python 中的注释可以附加到 <code>#</code> 号后的行尾。例如，上面代码中的注释 <code>玻尔兹曼常数</code> 描述了 <code>k</code> 变量的含义。这些注释不会出现在 Python 的 <code>help</code> 中，而且会被解释器忽略，它们只为人类而存在。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help(pressure)</span><br></pre></td></tr></table></figure>
<h2 id="数据结构">数据结构</h2>
<h3 id="链表">链表</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Link:</span><br><span class="line">        &quot;&quot;&quot;A linked list with a first element and the rest.&quot;&quot;&quot;</span><br><span class="line">        empty = ()</span><br><span class="line">        def __init__(self, first, rest=empty):</span><br><span class="line">            assert rest is Link.empty or isinstance(rest, Link)</span><br><span class="line">            self.first = first</span><br><span class="line">            self.rest = rest</span><br><span class="line">        def __getitem__(self, i):</span><br><span class="line">            if i == 0:</span><br><span class="line">                return self.first</span><br><span class="line">            else:</span><br><span class="line">                return self.rest[i-1]</span><br><span class="line">        def __len__(self):</span><br><span class="line">            return 1 + len(self.rest)</span><br></pre></td></tr></table></figure>
<h3 id="抽象障碍">抽象障碍</h3>
<p>每当程序的一部分可以使用更高级别的函数而不是使用较低级别的函数时，就会违反抽象障碍。例如，计算有理数平方的函数最好用 <code>mul_rational</code> 实现，它不对有理数的实现做任何假设。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_rational(x):</span><br><span class="line">        return mul_rational(x, x)</span><br></pre></td></tr></table></figure>
<h3 id="序列">序列</h3>
<p>范围通常出现在 for 语句 header 中的表达式，以指定 <code>&lt;suite&gt;</code> 应执行的次数。如果 <code>&lt;name&gt;</code> 没有被用在 <code>&lt;suite&gt;</code>，一个惯用的使用方式是，使用下划线表示 <code>&lt;name&gt;</code>。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for _ in range(3):</span><br><span class="line">        print(&#x27;Go Bears!&#x27;)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure>
<p>对解释器而言，下划线只是环境中的另一个名称，但对程序员具有约定俗成的含义，表示该名称不会出现在任何未来的表达式中。 列表推导式的一般形式是：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;</span><br></pre></td></tr></table></figure>
<p>为了运算列表推导式，Python 首先评估 <code>&lt;sequence expression&gt;</code>，它必须返回一个 iterable 值。然后，每个元素依次绑定到 <code>&lt;name&gt;</code>，再运算 <code>&lt;filter expression&gt;</code>；如果产生一个真值，运算 <code>&lt;map expression&gt;</code>。最后 <code>&lt;map expression&gt;</code> 的值被收集到一个列表中</p>
<p><code>reduce</code> 可用于将序列的所有元素相乘。使用 <code>mul</code> 作为 <code>reduce_fn</code>， 1 作为 <code>initial</code> 值， <code>reduce</code> 可用于将各数字相乘。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(mul, [2, 4, 8], 1)</span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p><strong>多行文字 (Multiline Literals)</strong>。字符串不限于一行。跨越多行的字符串文字可以用三重引号括起。我们已经在文档字符串中广泛使用了这种三重引号。</p>
<h3 id="迭代器">迭代器</h3>
<p>迭代器的用处源自以下事实： 迭代器的一系列数据可能不会在内存中显式表示。 迭代器提供了一种考虑一系列值中的每一个的机制 轮，但所有这些元素不需要同时存储。 相反，当迭代器请求下一个元素时，该元素可能会 按需计算，而不是从现有内存中检索 来源。</p>
<p>范围能够惰性地计算序列的元素，因为 表示的序列是统一的，并且任何元素都很容易从 范围的开始和结束边界。 迭代器允许延迟生成 更广泛的底层序列数据集类别，因为它们不需要 提供对底层系列的任意元素的访问。 反而， 迭代器只需要按顺序计算该系列的下一个元素， 每次请求另一个元素时。 虽然不像访问那样灵活 序列的任意元素（称为 <em>随机访问</em> ）、 <em>顺序访问</em> 顺序数据通常足以满足数据处理应用程序的需要。 函数 map 是惰性的：调用它并不执行计算 需要计算其结果的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def double_and_print(x):</span><br><span class="line">        print(&#x27;***&#x27;, x, &#x27;=&gt;&#x27;, 2*x, &#x27;***&#x27;)</span><br><span class="line">        return 2*x</span><br><span class="line">&gt;&gt;&gt; s = range(3, 7)</span><br><span class="line">&gt;&gt;&gt; doubled = map(double_and_print, s)  # double_and_print not yet called</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called once</span><br><span class="line">*** 3 =&gt; 6 ***</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called again</span><br><span class="line">*** 4 =&gt; 8 ***</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; list(doubled)                       # double_and_print called twice more</span><br><span class="line">*** 5 =&gt; 10 ***</span><br><span class="line">*** 6 =&gt; 12 ***</span><br><span class="line">[10, 12]</span><br></pre></td></tr></table></figure>
<h2 id="迭代器-1">迭代器</h2>
<p>可迭代的 Letters 实例 b_to_k 和 LetterIter 迭代器 实例 first_iterator 和 second_iterator的 不同之处在于 字母 实例不会改变，而迭代器实例会改变 每次调用 next （或等效地，每次调用 <strong>next</strong> ）。 迭代器通过顺序数据跟踪进度，而可迭代器 代表数据本身。</p>
<p>Python 中的许多内置函数都采用可迭代参数并返回迭代器。 函数 map 例如， 接受一个函数和一个可迭代对象。 它返回 将函数参数应用于每个元素的结果的迭代器 在可迭代的参数中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;  caps   =   map  (  lambda   x  :   x  .  upper  (),   b_to_k ) </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;B&#x27; </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;C&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="生成器">生成器</h2>
<p>生成器函数是生成值而不是返回值的函数 普通函数返回一次； 一个生成器函数可以产生多次 生成器是通过调用生成器函数自动创建的迭代器 当调用生成器函数时，它返回一个迭代其产量的生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def plus_minus(x):</span><br><span class="line">... yield x</span><br><span class="line">... yield -x</span><br><span class="line">&gt;&gt;&gt; t = plus_minus(3)</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">-3</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">&lt;generator object plus_minus ...&gt;</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数">高阶函数</h2>
<h3 id="嵌套定义">嵌套定义</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def sqrt(a):</span><br><span class="line">        def sqrt_update(x):</span><br><span class="line">            return average(x, a/x)</span><br><span class="line">        def sqrt_close(x):</span><br><span class="line">            return approx_eq(x * x, a)</span><br><span class="line">        return improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure>
<p>与局部赋值一样，局部 <code>def</code> 语句只影响当前局部帧。这些函数仅在求解 <code>sqrt</code> 时在作用域内。与求解过程一致，这些局部 <code>def</code> 语句在调用 <code>sqrt</code> 之前都不会被求解。</p>
<p>词法作用域（Lexical scope）：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， <code>sqrt_update</code> 引用名称 <code>a</code>，它是其封闭函数 <code>sqrt</code> 的形式参数。这种在嵌套定义之间共享名称的规则称为词法作用域。最重要的是，内部函数可以访问定义它们的环境中的名称（而不是它们被调用的位置）。</p>
<p>我们需要对我们的环境模型实现两个扩展来启用词法作用域。</p>
<ol type="1">
<li>每个用户定义的函数都有一个父环境：定义它的环境。</li>
<li>调用用户定义的函数时，其局部帧会继承其父环境。 Python 中词法作用域的两个关键优势。</li>
</ol>
<ul>
<li>局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。</li>
<li>局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。</li>
</ul>
<h3 id="lambda">lambda</h3>
<p>不像 定义 语句、lambda 表达式可以用作运算符或 调用表达式的操作数。 这是因为它们只是一行 计算结果为函数的表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; what = lambda x : x + 5</span><br><span class="line">&gt;&gt;&gt; what</span><br><span class="line">&lt;function &lt;lambda&gt; at 0xf3f490&gt;</span><br><span class="line">&gt;&gt;&gt; (lambda y: y + 5)(4)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="类">类</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">     def __init__(self, account_holder):</span><br><span class="line">            self.balance = 0</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<p>内置函数 <code>getattr</code> 还按名称返回对象的属性。它是点表示法的函数等效物。使用 <code>getattr</code> ，我们可以使用字符串查找属性，就像我们对调度字典所做的那样。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(spock_account, &#x27;balance&#x27;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>我们还可以测试应该对象是否具有 <code>hassattr</code> 的名命属性。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(spock_account, &#x27;deposit&#x27;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>我们可以通过对点表达式的返回值调用 <code>type</code> 来查看交互式解释器的差异。作为类的属性，方法只是一个函数，但作为实例的属性，它是一个绑定方法：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(Account.deposit)</span><br><span class="line">&lt;class &#x27;Function&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(spock_account.deposit)</span><br><span class="line">&lt;class &#x27;method&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>这两个结果的区别仅在于第一个是参数为 <code>self</code> 和 <code>amount</code> 的标准双参数函数。第二种是单参数方法，调用方法时，名称 <code>self</code> 将自动绑定到名为 <code>spock_account</code> 的对象，而参数 <code>amount</code> 将绑定到传递给方法的参数。这两个值（无论是函数值还是绑定方法值）都与相同的 <code>deposit</code> 函数体相关联。 在某些情况下，有一些实例变量和方法与对象的维护和一致性相关，我们不希望对象的用户看到或使用。它们不是类定义的抽象的一部分，而是实现的一部分。Python 的约定规定，如果属性名称以下划线开头，则只能在类本身的方法中访问它，而不是用户访问。</p>
<p>计算点表达式：</p>
<ol type="1">
<li>点表达式左侧的 <code>&lt;expression&gt;</code> ，生成点表达式的对象。</li>
<li><code>&lt;name&gt;</code> 与该对象的实例属性匹配；如果存在具有该名称的属性，则返回属性值。</li>
<li>如果实例属性中没有 <code>&lt;name&gt;</code> ，则在类中查找 <code>&lt;name&gt;</code>，生成类属性。</li>
<li>除非它是函数，否则返回属性值。如果是函数，则返回该名称绑定的方法。</li>
</ol>
<h2 id="约束传递-propagating-constraints">约束传递 (Propagating Constraints)</h2>
<p>可变数据允许我们模拟具有变化的系统，也允许我们构建新的抽象类型。在这个扩展示例中，我们结合了非局部赋值、列表和字典来构建一个支持多方向计算的基于约束系统。将程序表示为约束是一种声明式编程，在这种编程中，程序员声明要解决的问题的结构，而不是抽象出问题解决方案的具体计算方式的细节。</p>
<p>计算机程序传统上被组织为单向计算，它对预先指定的参数执行操作以产生所需的输出。另一方面，我们通常希望根据数量之间的关系对系统进行建模。例如，我们之前考虑过理想气体定律，它通过玻尔兹曼常数 (k) 将理想气体的压力 (p)、体积 (v)、数量 (n) 和温度 (t) 联系起来：</p>
<p><code>p * v = n * k * t</code></p>
<p>这样的方程不是单向的。给定任何四个量，我们可以使用这个方程来计算第五个。然而，将方程式翻译成传统的计算机语言会迫使我们选择一个量来根据其他四个量进行计算。因此，计算压力的函数不能用于计算温度，即使这两个量的计算来自同一个方程。</p>
<p>在本节中，我们概述了线性关系的一般模型的设计。我们定义了在数量之间保持的原始约束，例如强制数学关系 a + b = c 的 adder(a, b, c) 约束。</p>
<p>我们还定义了一种组合方式，以便可以组合原始约束来表达更复杂的关系。这样，我们的程序就类似于一种编程语言。我们通过构建一个网络来组合约束，在该网络中约束由连接器 (connector) 连接。连接器是一个对象，它“持有”一个值并且可以参与一个或多个约束。</p>
<p>例如，我们知道华氏温度和摄氏温度之间的关系是：</p>
<p><code>9 * c = 5 * (f - 32)</code></p>
<p>该等式是 c 和 f 之间的复杂约束。这样的约束可以被认为是一个由原始加法器 (adder) 、乘法器 (multiplier) 和常量 (constant) 约束组成的网络。</p>
<figure>
<img src="https://composingprograms.netlify.app/sicp/celsius_fahrenheit_constraint.png" alt="" /><figcaption>celsius_fahrenheit_constraint</figcaption>
</figure>
<p>在此图中，我们在左侧看到一个乘数框，其中包含三个端子，标记为 a 、b 和 c。这些将乘数连接到网络的其余部分，如下所示：终端连接到连接器 celsius，该连接器将保持摄氏温度。b 端子连接到连接器 w，该连接器链接到常量 9。乘数盒约束为 a 和 b 乘积的 c 端链接到另一个乘法盒的 c 端，其 b 连接到常量 5，其 a 连接到和约束中的项之一。</p>
<p>这种网络的计算过程如下：当一个连接器被赋予一个值时（由用户或由它链接到的约束框），它会唤醒所有相关的约束（除了刚刚唤醒它的约束） 以告诉他们它有值。每个被唤醒的约束框之后轮流询问其连接器，以查看是否有足够的信息来确定连接器的值。如果有，该框设置该连接器，然后唤醒所有关联的约束，依此类推。例如，在摄氏度和华氏度之间的转换中， w、 x 和 y 立即被常量框分别设置为 9、 5 和 32。连接器唤醒乘法器和加法器，它们确定没有足够的信息继续进行。如果用户（或网络的其他部分）将摄氏连接器设置为一个值（比如 25），最左边的乘法器将被唤醒，它将 u 设置为 25 * 9 = 225。然后你唤醒第二个乘法器，将 v 设置为 45，v 唤醒加法器，将 fahrenheit 连接器设置为 77。</p>
<p><strong>使用约束系统 (Using the Constraint System)</strong>。要使用约束系统执行上述温度计算，我们首先通过调用连接器构造函数创建两个命名连接器，摄氏度 celsius 和华氏度 fahrenheit。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius = connector(&#x27;Celsius&#x27;)</span><br><span class="line">&gt;&gt;&gt; fahrenheit = connector(&#x27;Fahrenheit&#x27;)</span><br></pre></td></tr></table></figure>
<p>然后，我们将这些连接器链接到一个反映上图的网络中。函数转换器 (converter) 组装网络中的各种连接器和约束。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def converter(c, f):</span><br><span class="line">        &quot;&quot;&quot;用约束条件连接 c 到 f ，将摄氏度转换为华氏度.&quot;&quot;&quot;</span><br><span class="line">        u, v, w, x, y = [connector() for _ in range(5)]</span><br><span class="line">        multiplier(c, w, u)</span><br><span class="line">        multiplier(v, x, u)</span><br><span class="line">        adder(v, y, f)</span><br><span class="line">        constant(w, 9)</span><br><span class="line">        constant(x, 5)</span><br><span class="line">        constant(y, 32)</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; converter(celsius, fahrenheit)</span><br></pre></td></tr></table></figure>
<p>我们将使用消息传递系统来协调约束和连接器。约束是不包含局部状态本身的字典。它们对消息的响应是非纯函数，会更改它们约束的连接器。</p>
<p>连接器是保存当前值并响应操纵该值的消息的字典。约束不会直接更改连接器的值，而是通过发送消息来更改，以便连接器可以通知其他约束以响应更改。这样，一个连接器既代表了一个数字，同时也封装了连接器的行为。</p>
<p>我们可以发送给连接器的一条消息是设置它的值。在这里，我们（ “ user ” ）将 celsius 的值设置为 25。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;set_val&#x27;](&#x27;user&#x27;, 25)</span><br><span class="line">Celsius = 25</span><br><span class="line">Fahrenheit = 77.0</span><br></pre></td></tr></table></figure>
<p>不仅 celsius 的值变为 25，而且它的值通过网络传播，因此 fahrenheit 的值也发生变化。打印这些更改是因为我们在构造它们时命名了这两个连接器。</p>
<p>现在我们可以尝试将 fahrenheit 度设置为一个新值，比如 212。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Contradiction detected: 77.0 vs 212</span><br></pre></td></tr></table></figure>
<p>连接器抱怨说它感觉到了一个矛盾：它的值为 77.0，而有人试图将它设置为 212。如果我们真的想用新值应用到网络，我们可以告诉 celsius 忘记它的旧值：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;forget&#x27;](&#x27;user&#x27;)</span><br><span class="line">Celsius is forgotten</span><br><span class="line">Fahrenheit is forgotten</span><br></pre></td></tr></table></figure>
<p>连接器 celsius 发现最初设置其值的用户现在收回该值，因此 celsius 同意失去其值，并将这一事实通知网络的其余部分。这个信息最终传播到 fahrenheit，它现在发现它没有理由继续相信它自己的值是 77。因此，它也放弃了它的值。</p>
<p>现在 fahrenheit 没有值，我们可以将其设置为 212：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Fahrenheit = 212</span><br><span class="line">Celsius = 100.0</span><br></pre></td></tr></table></figure>
<p>这个新值在通过网络传播时会迫使 celsius 的值变为 100。我们使用了完全相同的网络来计算给定 celsius 的 fahrenheit 和给定 fahrenheit 的 celsius。这种计算的非方向性是基于约束的系统的显着特征。</p>
<p><strong>实施约束系统 (Implementing the Constraint System)</strong>。正如我们所见，连接器是将消息名称映射到函数和数据值的字典。我们将实施响应以下消息的连接器：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; connector [&#x27;set_val&#x27;](source, value)  &quot;&quot;&quot;表示 source 在请求连接器将当前值设为 value&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;has_val&#x27;]()  &quot;&quot;&quot;返回连接器是否已经具有值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;val&#x27;]  &quot;&quot;&quot;是连接器的当前值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;forget&#x27;](source)  &quot;&quot;&quot;告诉连接器 source 请求遗忘它的值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;connect&#x27;](source)  &quot;&quot;&quot;告诉连接器参与新的约束，即 source&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>约束也是字典，它通过两条消息从连接器接收信息：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; constraint[\&#x27;new_val&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器具有新的值。&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; constraint[\&#x27;forget&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器遗忘了值。&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>当约束收到这些消息时，它们会将消息传播到其他连接器。</p>
<p>adder 函数在三个连接器上构造一个加法器约束，其中前两个必须与第三个相加：a + b = c。为了支持多向约束传播，加法器还必须指定它从 c 中减去 a 得到 b，同样地从 c 中减去 b 得到 a。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import add, sub</span><br><span class="line">&gt;&gt;&gt; def adder(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a+b=c&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, add, sub, sub)</span><br></pre></td></tr></table></figure>
<p>我们想实现一个通用的三元（三向）约束，它使用来自 adder 的三个连接器和三个函数来创建一个接受 new_val 和 forget 消息的约束。对消息的响应是局部函数，它们被放置在称为约束的字典中。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_ternary_constraint(a, b, c, ab, ca, cb):</span><br><span class="line">        &quot;&quot;&quot;约束ab(a,b)=c，ca(c,a)=b，cb(c,b)=a。&quot;&quot;&quot;</span><br><span class="line">        def new_value():</span><br><span class="line">            av, bv, cv = [connector[&#x27;has_val&#x27;]() for connector in (a, b, c)]</span><br><span class="line">            if av and bv:</span><br><span class="line">                c[&#x27;set_val&#x27;](constraint, ab(a[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">            elif av and cv:</span><br><span class="line">                b[&#x27;set_val&#x27;](constraint, ca(c[&#x27;val&#x27;], a[&#x27;val&#x27;]))</span><br><span class="line">            elif bv and cv:</span><br><span class="line">                a[&#x27;set_val&#x27;](constraint, cb(c[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">        def forget_value():</span><br><span class="line">            for connector in (a, b, c):</span><br><span class="line">                connector[&#x27;forget&#x27;](constraint)</span><br><span class="line">        constraint = &#123;&#x27;new_val&#x27;: new_value, &#x27;forget&#x27;: forget_value&#125;</span><br><span class="line">        for connector in (a, b, c):</span><br><span class="line">            connector[&#x27;connect&#x27;](constraint)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>
<p>称为约束的字典是一个调度字典，也是约束对象本身。它响应约束接收到的两条消息，但也作为调用其连接器的 source 参数传递。</p>
<p>每当约束被告知其连接器之一具有值时，就会调用约束的局部函数 new_value。该函数首先检查 a 和 b 是否都有值。如果是，它告诉 c 将其值设置为函数 ab 的返回值，在加法器的情况下为 add。约束将自身（约束）作为连接器的 source 参数传递，该连接器是加法器对象。如果 a 和 b 不同时都有值，则约束检查 a 和 c，依此类推。</p>
<p>如果约束被告知它的一个连接器遗忘了它的值，它会请求它的所有连接器遗忘它们的值。（实际上只有那些由此约束设置的值会丢失。）</p>
<p>乘法器与加法器非常相似。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import mul, truediv</span><br><span class="line">&gt;&gt;&gt; def multiplier(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a*b=c.&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, mul, truediv, truediv)</span><br></pre></td></tr></table></figure>
<p>常量也是一种约束，但它永远不会发送任何消息，因为它只涉及它在构造时设置的单个连接器。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def constant(connector, value):</span><br><span class="line">        &quot;&quot;&quot;常量赋值.&quot;&quot;&quot;</span><br><span class="line">        constraint = &#123;&#125;</span><br><span class="line">        connector[&#x27;set_val&#x27;](constraint, value)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>
<p>这三个约束足以实现我们的温度转换网络。</p>
<p><strong>连接器表示 (Representing connectors)</strong>。连接器表示为包含值的字典，也有具备局部状态的响应函数。连接器必须跟踪为其提供当前值的信息提供者，以及它参与的约束列表。</p>
<p>构造函数连接器具有用于设置和遗忘值的局部函数，这些值是对来自约束的消息的响应。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def connector(name=None):</span><br><span class="line">        &quot;&quot;&quot;限制条件之间的连接器.&quot;&quot;&quot;</span><br><span class="line">        informant = None</span><br><span class="line">        constraints = []</span><br><span class="line">        def set_value(source, value):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            val = connector[&#x27;val&#x27;]</span><br><span class="line">            if val is None:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = source, value</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;=&#x27;, value)</span><br><span class="line">                inform_all_except(source, &#x27;new_val&#x27;, constraints)</span><br><span class="line">            else:</span><br><span class="line">                if val != value:</span><br><span class="line">                    print(&#x27;Contradiction detected:&#x27;, val, &#x27;vs&#x27;, value)</span><br><span class="line">        def forget_value(source):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            if informant == source:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = None, None</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;is forgotten&#x27;)</span><br><span class="line">                inform_all_except(source, &#x27;forget&#x27;, constraints)</span><br><span class="line">        connector = &#123;&#x27;val&#x27;: None,</span><br><span class="line">                     &#x27;set_val&#x27;: set_value,</span><br><span class="line">                     &#x27;forget&#x27;: forget_value,</span><br><span class="line">                     &#x27;has_val&#x27;: lambda: connector[&#x27;val&#x27;] is not None,</span><br><span class="line">                     &#x27;connect&#x27;: lambda source: constraints.append(source)&#125;</span><br><span class="line">        return connector</span><br></pre></td></tr></table></figure>
<p>连接器也是约束用于与连接器通信的五个消息的调度字典。四个响应是函数，最后的响应是值本身。</p>
<p>当有设置连接器值的请求时调用局部函数 set_value。如果连接器当前没有值，它将设置它的值并记住请求设置值的源约束作为信息提供者。然后连接器将通知它的所有参与约束，除了请求设置值的约束。这是使用以下迭代函数完成的。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def inform_all_except(source, message, constraints):</span><br><span class="line">        &quot;&quot;&quot;告知信息除了source外的所有约束条件，。&quot;&quot;&quot;</span><br><span class="line">        for c in constraints:</span><br><span class="line">            if c != source:</span><br><span class="line">                c[message]()</span><br></pre></td></tr></table></figure>
<p>如果要求连接器遗忘其值，它会调用局部函数 forget-value，该函数首先检查以确保请求来自与最初设置值相同的约束。如果是这样，连接器会通知其关联的约束有关值的丢失。</p>
<p>对消息 has_val 的响应表明连接器是否有值。 对消息连接的响应将源约束添加到约束列表中。</p>
<p>我们设计的约束程序引入了许多将在面向对象编程中再次出现的思想。约束和连接器都是通过消息操作的抽象。当连接器的值发生变化时，它会通过一条消息进行更改，该消息不仅会更改值，还会验证它（检查源）并传播其效果（通知其他约束）。事实上，我们将在本章后面使用具有字符串值键和函数值的字典的类似架构来实现面向对象的系统</p>
<h2 id="debug">debug</h2>
<p>请注意，回溯中的行似乎是配对在一起的。 该对中的第一行具有以下格式： 文件“<文件名>”，第 <编号> 行，<函数></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;&lt;file name&gt;&quot;, line &lt;number&gt;, in &lt;function&gt;</span><br></pre></td></tr></table></figure>
<p>该行为您提供以下信息： 文件名：包含问题的文件的名称。 Number：文件中引起问题的行号，或包含下一个函数调用的行号 函数：可以在其中找到该行的函数的名称。 回溯消息中的最后一行是错误语句。 错误语句具有以下格式： <错误类型>：<错误消息> 这一行为您提供了两条信息： 错误类型：引起的错误类型（例如SyntaxError，TypeError）。 这些通常具有足够的描述性，可以帮助您缩小错误原因的搜索范围。 错误消息：更详细地描述导致错误的原因。 不同的错误类型会产生不同的错误消息。</p>
<h2 id="running-doctests">Running doctests</h2>
<p>Python has a great way to quickly write tests for your code. These are called doctests, and look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    &quot;&quot;&quot;A random function.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; foo(4)</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; foo(5)</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>The lines in the docstring that look like interpreter outputs are the <strong>doctests</strong>. To run them, go to your terminal and type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m doctest file.py</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m doctest file.py -v</span><br><span class="line">除了告诉你哪些文档测试失败之外，它还会 告诉您哪些文档测试通过了。</span><br></pre></td></tr></table></figure>
<p>许多程序员喜欢研究他们的代码的一种方法是使用交互式 REPL。 也就是说，您可以在其中直接运行函数并检查其输出的终端。 通常，要完成此操作，您可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -i file.py</span><br></pre></td></tr></table></figure>
<h3 id="使用-assert声明">使用 <code>assert</code>声明</h3>
<p>Python 有一个特性称为 <code>assert</code>语句，它可以让您测试条件是否为真，并打印错误 否则在一行中消息。 如果您知道某些条件在某些点需要为真，这会很有用 在你的程序中。 例如，如果您正在编写一个接受整数并将其加倍的函数，那么它可能会很有用 确保您的输入实际上是一个整数。 然后你可以编写以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def double(x):</span><br><span class="line">    assert isinstance(x, int), &quot;The input to double(x) must be an integer&quot;</span><br><span class="line">    return 2 * x</span><br></pre></td></tr></table></figure>
<p>请注意，我们并没有真正调试 <code>double</code>在这里，我们正在做的是确保任何拨打电话的人 <code>double</code>正在以正确的论点这样做。 例如，如果我们有一个函数 <code>g</code>接受一个字符串和一个数字 并将字符串的长度添加到数字的两倍，其实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def g(x, y):</span><br><span class="line">    return double(x) + y # should be double(y) + len(x)</span><br></pre></td></tr></table></figure>
<h3 id="syntaxerror"><code>SyntaxError</code></h3>
<ul>
<li><p><strong>原因</strong> ：代码语法错误</p></li>
<li><p><strong>示例</strong> ：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    def incorrect(f)</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>解决办法</strong> ： <code>^</code>符号指向包含的代码 无效的语法。 错误消息没有告诉你 <em>什么</em> 是 错了，但它确实告诉你 <em>在哪里</em> 。</p></li>
<li><p><strong>注意</strong> ：Python 将检查 <code>SyntaxErrors</code>执行之前 任何代码。 这与其他错误不同，其他错误仅 在运行时引发。</p></li>
</ul>
<h3 id="indentationerror"><code>IndentationError</code></h3>
<ul>
<li><p><strong>原因</strong> ：缩进不当</p></li>
<li><p><strong>示例</strong> ：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    print(&#x27;improper indentation&#x27;)</span><br><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>解决方案</strong> ：显示缩进不正确的行。 只需重新缩进即可。</p></li>
<li><p><strong>注意</strong> ：如果制表符和空格不一致，Python 将提出其中之一。 确保使用空格！ （只是少了点 在 Python 中使用空格和所有 cs61a 内容通常令人头痛 使用空格）。</p></li>
</ul>
<h3 id="typeerror"><code>TypeError</code></h3>
<ul>
<li><p><strong>原因一</strong> ：</p>
<ul>
<li><p>原始运算符的操作数类型无效。 你是 可能尝试加/减/乘/除不兼容 类型。</p></li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError: unsupported operand type(s) for +: &#x27;function&#x27; and &#x27;int&#x27;</span><br></pre></td></tr></table></figure></code></pre></li>
</ul></li>
<li><p><strong>原因2</strong> ：</p>
<ul>
<li><p>在函数调用中使用非函数对象。</p></li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; square = 3</span><br><span class="line">&gt;&gt;&gt; square(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &#x27;int&#x27; object is not callable</span><br></pre></td></tr></table></figure></code></pre></li>
</ul></li>
<li><p><strong>原因3</strong> ：</p>
<ul>
<li><p>向函数传递错误数量的参数。</p></li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: add expected 2 arguments, got 1</span><br></pre></td></tr></table></figure></code></pre></li>
</ul></li>
</ul>
<h3 id="nameerror"><code>NameError</code></h3>
<ul>
<li><p><strong>原因</strong> ：变量没有分配给任何东西或者没有分配 存在。 这包括函数名称。</p></li>
<li><p><strong>示例</strong> ：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  y = x + 3</span><br><span class="line">NameError: global name &#x27;x&#x27; is not defined</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>解决方案</strong> ：确保您正在初始化变量（即 在使用之前为变量分配一个值）。</p></li>
<li><p><strong>注意</strong> ：错误消息显示“全局名称”的原因是 因为Python将从a开始搜索变量 函数的本地框架。 如果在那里找不到该变量， Python将继续搜索父框架，直到到达 全球框架。 如果仍然找不到变量，Python 引发错误。</p></li>
</ul>
<h3 id="indexerror"><code>IndexError</code></h3>
<ul>
<li><p><strong>原因</strong> ：尝试索引序列（例如元组、列表、 string）的数字超过了序列的大小。</p></li>
<li><p><strong>示例</strong> ：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  x[100]</span><br><span class="line">IndexError: tuple index out of range</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>解决方案</strong> ：确保索引在范围内 顺序。 如果您使用变量作为索引（例如 <code>seq[x]</code>, 确保变量被分配给正确的索引。</p></li>
</ul>
<h2 id="object">object</h2>
<p>因为两个列表可能内容相同，但实际上是不同的列表，所以我们需要一种方法来测试两个对象是否是同一个。Python 包括两个比较运算符，称为 is 和 is not，它们测试两个表达式实际上是否计算为相同的对象。如果两个对象的当前值相等，则它们是相同的，并且对一个对象的任何更改都将始终反映在另一个对象中。身份是比相等更强大的条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suits is [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; suits == [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>字典也确实有一些限制：</p>
<ul>
<li>字典的键不能是或包含可变值。</li>
<li>对于给定的键，最多只能有一个对应的值。 非局部语句 (nonlocal statement)。当我们调用 make_withdraw 时，我们将 balance 绑定到初始金额。然后我们定义并返回一个局部函数 withdraw，它会在调用时更新并返回 balance 的值。</li>
</ul>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_withdraw(balance):</span><br><span class="line">        &quot;&quot;&quot;返回一个每次调用都会减少余额的 withdraw 函数&quot;&quot;&quot;</span><br><span class="line">        def withdraw(amount):</span><br><span class="line">            nonlocal balance                 # 声明 balance 是非局部的</span><br><span class="line">            if amount &gt; balance:</span><br><span class="line">                return &#x27;Insufficient funds&#x27;</span><br><span class="line">            balance = balance - amount       # 重新绑定</span><br><span class="line">            return balance</span><br><span class="line">        return withdraw</span><br></pre></td></tr></table></figure>
<p>非局部语句声明：每当我们更改 balance 的绑定时，绑定关系都会在已经绑定 balance 的第一帧中更改。回想一下，如果没有非局部语句，赋值语句将始终在当前环境的第一帧中绑定。非局部语句指示名称不会出现在第一个（局部）帧或最后一个（全局）帧，而是其他地方。</p>
<h2 id="错题集">错题集</h2>
<h3 id="递增子序列">递增子序列</h3>
<figure class="highlight plaintext"><figcaption><span>inc_subseqs(s):</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Assuming that S is a list, return a nested list of all subsequences</span><br><span class="line"></span><br><span class="line">    of S (a list of lists) for which the elements of the subsequence</span><br><span class="line"></span><br><span class="line">    are strictly nondecreasing. The subsequences can appear in any order.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs = inc_subseqs([1, 3, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1, 2], [1, 3], [2], [3]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; inc_subseqs([])</span><br><span class="line"></span><br><span class="line">    [[]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs2 = inc_subseqs([1, 1, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs2)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1], [1, 1], [1, 1, 2], [1, 2], [1, 2], [2]]</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def subseq_helper(s, prev):</span><br><span class="line"></span><br><span class="line">        if not s:</span><br><span class="line"></span><br><span class="line">            return [[]]</span><br><span class="line"></span><br><span class="line">        elif s[0] &lt; prev:</span><br><span class="line"></span><br><span class="line">            return subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            a = subseq_helper(s[1::],s[0])</span><br><span class="line"></span><br><span class="line">            b = subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">            return insert_into_all(s[0], a) + b</span><br><span class="line"></span><br><span class="line">    return subseq_helper(s,0)</span><br><span class="line"></span><br><span class="line">seqs = inc_subseqs([1, 3, 2])</span><br></pre></td></tr></table></figure>
<h3 id="反转奇数深度树的标签">反转奇数深度树的标签</h3>
<figure class="highlight plaintext"><figcaption><span>t.is_leaf():</span></figcaption><table><tr><td class="code"><pre><span class="line">        return </span><br><span class="line">    label_list = []</span><br><span class="line">    for b in t.branches:</span><br><span class="line">        label_list.append(b.label)</span><br><span class="line">    for b, new_label in zip(t.branches, reversed(label_list)):</span><br><span class="line">        b.label = new_label</span><br><span class="line">        for bb in b.branches:</span><br><span class="line">            reverse_other(bb)</span><br><span class="line"></span><br><span class="line">我的解法：</span><br><span class="line">def helper(t,depth):</span><br><span class="line"></span><br><span class="line">        if depth%2==0:</span><br><span class="line"></span><br><span class="line">            if t.is_leaf():</span><br><span class="line"></span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            else:</span><br><span class="line"></span><br><span class="line">                for branch in t.branches:</span><br><span class="line"></span><br><span class="line">                    helper(branch,depth+1)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            labels=[]</span><br><span class="line"></span><br><span class="line">            brans=t.branches</span><br><span class="line"></span><br><span class="line">            for branch in brans:</span><br><span class="line"></span><br><span class="line">                labels.insert(0,branch.label)</span><br><span class="line"></span><br><span class="line">            for new_label,new_branch in zip(labels,brans):</span><br><span class="line"></span><br><span class="line">                new_branch.label=new_label</span><br><span class="line"></span><br><span class="line">            for bran in brans:</span><br><span class="line"></span><br><span class="line">                helper(bran,depth+1)</span><br><span class="line"></span><br><span class="line">    helper(t,1)</span><br></pre></td></tr></table></figure>
<h3 id="生成器的生成器">生成器的生成器</h3>
<figure class="highlight plaintext"><figcaption><span>make_generators_generator(g):</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Generates all the &quot;sub&quot;-generators of the generator returned by</span><br><span class="line"></span><br><span class="line">    the generator function g.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_m_ints_to(n, m):</span><br><span class="line"></span><br><span class="line">    ...     i = 0</span><br><span class="line"></span><br><span class="line">    ...     while (i &lt;= n):</span><br><span class="line"></span><br><span class="line">    ...         yield i</span><br><span class="line"></span><br><span class="line">    ...         i += m</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_3_ints_to_10():</span><br><span class="line"></span><br><span class="line">    ...     for item in every_m_ints_to(10, 3):</span><br><span class="line"></span><br><span class="line">    ...         yield item</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; for gen in make_generators_generator(every_3_ints_to_10):</span><br><span class="line"></span><br><span class="line">    ...     print(&quot;Next Generator:&quot;)</span><br><span class="line"></span><br><span class="line">    ...     for item in gen:</span><br><span class="line"></span><br><span class="line">    ...         print(item)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    9</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">    def gen_helper(lst):</span><br><span class="line"></span><br><span class="line">        yield from lst</span><br><span class="line"></span><br><span class="line">    yield_sofar = []</span><br><span class="line"></span><br><span class="line">    gg = g()</span><br><span class="line"></span><br><span class="line">    for x in gg:</span><br><span class="line"></span><br><span class="line">        yield_sofar.append(x)</span><br><span class="line"></span><br><span class="line">        yield gen_helper(yield_sofar.copy())</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h3 id="生成器生成树的搜索路径">生成器生成树的搜索路径</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if t.label == value:</span><br><span class="line">        yield [value]</span><br><span class="line">    for b in t.branches:</span><br><span class="line">        for path in path_yielder(b, value):</span><br><span class="line">            yield [t.label] + path</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls剧情解析</title>
    <url>/2023/09/29/black%20souls%E5%89%A7%E6%83%85%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="冬之钟">冬之钟</h1>
<p>由于black souls的故事远远没有完结，因此现阶段我们很难对<code>红白女王</code>与<code>梅贝尔</code>这些与格林牵扯极深的支配者们进行什么定论，只能就已有的剧情和文本进行一些归纳，本期视频我将就bs2比较难懂的一处地方，冬之钟的主线事件，进行一些个人向的分析。 <span id="more"></span> 在冬之钟最后一章地图能遇到5个白熊，白熊的身份迄今为止依然是谜团，但他们提供了整整五段发生在支配者之间的重要对话，我将概括一下这五段对话提供的主要信息以便进一步的分析 我们按解包后的地图顺序开始， 第一段对话发生于<code>梅贝尔</code>和妹妹爱丽丝之间，可以猜测妹妹爱丽丝属于支配者之一，数量众多的支配者都在奈亚的箱庭占据一个角色以便和格林繁殖，但随着时间推移，支配者们发现扮演角色的同时，他们也在被角色同化（<code>梅贝尔</code>所言），因此纷纷退场，妹妹爱丽丝也逐渐被角色影响对格林产生好感，此外，姐姐爱丽丝不知何故地退场。 第二场对话发生于<code>梅贝尔</code>和白之女王之间，对话中提及冬之钟正是白女王的箱庭，而白之女王由于爱上了格林自愿放弃女王的身份去守护他，而<code>梅贝尔</code>则对这场追寻爱的闹剧，以及陪着胡闹的其他支配者感到无聊，向白女王提出一个让格林摆脱循环，并且能够独占他的计划。 第三第四场对话都发生于红白女王之间，<code>红女王</code>为陷入痛苦轮回的格林而痛苦，不断进行自残，白女王制止了她，两人由于同样爱上格林而心意相通 第四场对话则告诉我们，<code>红女王</code>接过了白女王的权王冠（推测为箱庭权限），并以此创造出库因兰德，并使其能排除奈亚的监视，两人密谋让格林挣脱循环的方法，<code>红女王</code>恳请白女王放弃对格林的独占欲，白女王同意了，此外，<code>梅贝尔</code>也知晓这一计划，并根据后面的行动来看，她不知为何也参与了这个计划 第五场对话发生于白女王和玛丽苏之间，白女王夺走了玛丽苏的改变能力，并且根据混沌迷宫的情报，将其赋予了古兰剧场，玛丽苏察觉白女王爱上了格林，并且等待着格林的到来，结尾，玛丽苏等到了一个神秘人（黑山羊？） 总结这些信息，我们可以推测出针对格林，一共提出了两个计划，一个是<code>梅贝尔</code>怂恿的独占计划，一个是红偶像策划的拯救计划，这两个计划都必须有<code>诺登</code>的参与，但此时我们并不知道<code>诺登</code>的真正想法是哪个 在推进h结局的过程后，格林会有两个选择，1是和暗黑舞台合二为一2是打败舞台，夺取舞台的改变能力， “此时”的冬之钟虽然沉睡，但相信<code>诺登</code>依旧有一定的控制能力，然而不同于G结局的阻拦，此时的<code>诺登</code>选择了旁观，并在最后支持格林任意一个选择 总结一下大致发生的事件（以下事件的时间顺序难以具体确定） 1<code>诺登</code>作为支配者之一管理着自己的箱庭冬之钟，和奈亚创造自己箱庭的时间关系未知 2奈亚将格林带到箱庭，邀请支配者们参加繁殖游戏，根据牛津学院人偶爱丽丝的说法，是舞台装置创造出了让格林在舞台上登场的皮套（格林的灵魂出自玛丽苏的手笔，因此推测只能创造皮套），并且在创造格林时两者间确立了深远的联系，白女王也参加了这个游戏，可以肯定白女王为了心爱的格林才舍弃了王冠（王冠可能指代管理箱庭的权能），因此推测白女王在爱上格林后可能以放弃王冠为代价，得到了管理奈亚箱庭的权限和陪伴在格林身边的权力 3红偶像被奈亚切割，由于茶会时期她曾经打倒初代红之女王，因此此刻可以说她的身份是第二任红之女王，为格林自责的她不断紫餐，得到了白女王的同情，白女王将自己原来的王冠权能移交给被奈亚切割的<code>红女王</code>，让她在原冬之钟的地盘上创造出自己的箱庭。 4红白女王合谋，或者其中之一从奈亚手中夺走了玛丽苏并囚禁起来，为了避免红白女王相互猜疑，二者将从玛丽苏手上得到的改变能力赋予舞台装置古兰，创造出一个新的支配者暗黑舞台，藏于处于过去时间线的冬之钟，同时由于处于过去的时间线，冬之钟几乎没有被发现的风险，通过dlc3经常出现的齿轮与其他信息可以推测，舞台装置拥有着影响整个箱庭以及舞台上大部分“演员”的能力，即在部分地图的bg和格林脑中的“齿轮声”，是不思议之国这场戏的核心，此外，由于<code>诺登</code>为了管理这个箱庭必须借助舞台的力量，而红白女王理论上权能接近，因此本视频中猜测红白女王都有部分操控舞台的权限 4由于支配者们发现扮演箱庭的角色会改变自己的本质，因此纷纷退出，白女王被迫用自己和格林的子嗣填补空缺 5<code>梅贝尔</code>认为这场游戏无聊透顶，一场剧本烂透的戏剧重复多少遍也只会让人厌倦（她自己是这么说的），因此她怂恿白女王让格林脱出循环，并抢先独占他 6<code>红女王</code>努力让自己的领域能排除奈亚的监视，并在此向白女王提出了拯救格林的计划，这个计划<code>梅贝尔</code>也知情，白女王同意了拯救计划，我们不知道白女王听到这两个计划的顺序，但他们明显是冲突的 7可能是人为，可能是自发，舞台觉醒了自我意识呼唤着格林的爱，同时在<code>梅贝尔</code>的指引下格林也朝着舞台进发，一场死斗在所难免，可以推测，在夺取舞台能力的结局中，<code>诺登</code>执行了<code>红女王</code>的拯救计划，舍身为格林断后，使其在爱丽丝01，即现在的红偶像的帮助下回到现实。在舞台与格林合一的bad end中，<code>诺登</code>执行了<code>梅贝尔</code>提出的独占计划，该结局中<code>诺登</code>辅佐着通过合体得到创作能力的格林与奈亚进行斗争，并且前往世界尽头来逃避一切纷争和毁灭，顺便一提，我觉得这结局也不算坏，白女王很可能会确保格林在融合中占据主导，此时格林成为了名副其实的支配者，和白女王的结合甚至能和奈亚势均力敌，不过寿司在采访中提到执着于爱丽丝身份的奈亚无法发挥全力就是了，毫无疑问这时的格林是目前为止的（格林）战力巅峰。 这就是冬之钟里发生的主要事件了，下面我将对事件的主要参与者，红白女王和虚无的少女进行分析。 首先是参与程度较低的<code>梅贝尔</code>，<code>梅贝尔</code>虽然入局较浅，但却是格林的引导者，并帮助拖延了一下奈亚，也是她告诉我们打破这一循环只能正面和舞台装置对决，那么她的目的是什么呢？ 首先，<code>梅贝尔</code>在混沌迷宫中会直接提及支配者间不可避免将爆发战争，并且导致阿撒托斯的苏醒毁灭一切，而身份不是支配者却可能得到支配者之器的格林，才能发动不会惊醒阿撒托斯的箱庭战争，这可能是她帮助格林的首要目的 其次，<code>梅贝尔</code>是个不可救药的收藏狂，她的箱庭是个巨大的垃圾场，什么都有，因此她也想把格林培养成一个完美收藏品或者棋子 最后，在个人感情上，很难定论<code>梅贝尔</code>到底产生了多少感情，她自称对永无止境的劣质戏剧循环感到厌倦，才会帮助格林创造自己的故事，但又在背叛剧情中声称想要让格林得到更高的器随后利用他，最后如果试图救她又会说自己涌现出了一些对格林的爱，由于信息过少，很难知道她到底觉醒了多少感情。 不过可以肯定的是，如果是<code>梅贝尔</code>真有意背叛动机是不充分的，如果她只需要格林成为拥有支配者之器的棋子，那么独占和拯救计划都能实现这个目的，并且由于白女王看着，融合后大概率是格林占主导地位，无非是好不好操控的问题，因此猜测<code>梅贝尔</code>实际上是真心帮助格林，只是在用激将法，或者习惯性毒舌。 冬之钟的棋局不管怎么走<code>梅贝尔</code>都不是输家，如果独占计划成功，白女王和格林则会成为一股对抗奈亚甚至其他支配者的强大力量，如果拯救计划成功，格林则会成为一个有着支配者的器，却对大部分支配者恨之入骨的棋子或潜在盟友，不论哪个结果都对<code>梅贝尔</code>阻止阿撒托斯苏醒的目的有利，而她的损失不过是万千分身中的一个而已 随后则是红之女王，尽管游戏中没有直接说<code>红女王</code>就是一代的爱丽丝01，以及茶会中的爱丽丝，但大量证据表明她和爱丽丝01有着千丝万缕的关系，爱丽丝01也极有可能就是茶会爱丽丝，所以本视频采纳这一说法，可以说最早钻进人类皮套的她是人性化最深的支配者，她人类的一面深爱格林，但又恐惧支配者的一面暴露，因此自觉配不上格林，甚至认为是自己导致了格林的一切悲剧，顺便一提关于茶会以及更早时期的资料实在太少，所以我们现在对这段剧情的讨论很可能是不完整甚至有较大误解的，因此在此我只能尽可能保守地做一些推测，由于支配者本性难以剥离，在她身上有着强烈的自毁倾向，想爱，却又自觉没有资格去爱，因此她只能用紫餐的方式填补内心的负罪感，H结局中，她以几乎自杀的方式当着奈亚的面帮助格林逃离了奈亚的掌控，可以说为了格林，<code>红女王</code>自降身份把自己变成了棋子，而且是必死的棋子，只为了能在后续将奈亚一军。 等待着这个叛徒的是什么结局，我们只能发挥一下想象力了 最后则是冬之钟的核心人物，白之女王<code>诺登</code>，<code>诺登</code>的原型之一是爱丽丝梦游仙境的白兔先生，白兔最明显的元素就是他永远匆忙的样子和怀表，这点也在<code>诺登</code>身上得以体现，白女王作为这场繁殖游戏事实上的管理者，为了协调任性的演员们可谓操碎了心，在轮回的最后，台上的演员几乎全部是她的子嗣（兔子可是繁殖力非常强的生物），可以猜测在制定剧本和排练上她也得下不少功夫，而dlc3的核心意象，齿轮，其实可以说既指着暗黑舞台的齿轮带动了戏码的上演，也指着<code>诺登</code>怀表的齿轮，<code>诺登</code>就是那个负责在指针快点到达终点前让齿轮倒转，重新开始计时的人，这也是为何她会在结局中说为齿轮停止感到害怕，让齿轮转动是她的职责，在她的内心深处或许也有着对无尽循环中格林真正爱上自己并一起逃到世界尽头的希望，但最后她选择成全格林真正的爱，而放弃管理齿轮的职责则意味着她与自己支配者的身份完全决裂，将一切奉献给人类的爱。此外，<code>诺登</code>的支配者原型则是所谓的幻梦境之主，这或许解释了为何是她在实际上管理着二代这个巨大的梦境 我在尸龙的人物解析说，类似尸龙的独占欲在红白女王身上也出现过，但<code>红女王</code>由于害怕自己的支配者本性选择放手，那么白女王呢？在h结局中，<code>梅贝尔</code>被古兰（推测，也可能是奈亚）针对性的陷阱解决，但拥有舞台权限的红白女王应该不受影响，<code>红女王</code>为了最后拯救格林必须蛰伏，因此辅助格林对抗古兰以及奈亚的任务只能交给白女王，但即使在此时此刻，白女王依旧有着独占格林的选项，如果她控制或者协助舞台装置强迫和格林融合，就可以抢先一步独占所有支配者都垂涎的格林，但如果把舞台的改变能力给予格林，那么失去王冠和舞台的<code>诺登</code>则会失去自己在棋局上的几乎所有棋子，面对这种选择，<code>诺登</code>将选择权给了格林，不能说她是完全无私的，但面对这样的诱惑，她也会尊重格林的选择，这不得不说是非常伟大的爱 可以说白女王是一个有着两面性的角色，她支配者的一面始终对格林有着独占欲，但她人性的一面始终压抑着这些黑暗的感情，她是一个徘徊于人与神界限的存在，但无论如何，她都尊重并支持着格林的选择，所以她闪耀着人性光辉的一面始终是压过支配者的黑暗一面的。 让我们给这幕疯狂剧场的落幕做一个总结吧，这局棋是红白女王和<code>梅贝尔</code>设下的，目的是为了让格林得到古兰的改变能力并逃离奈亚的箱庭，其中没有舞台权限的<code>梅贝尔</code>负责引导格林，<code>红女王</code>则在最后帮助得到改变能力的格林摆脱奈亚掌控，而白女王则有着最关键的决策权，即是否利用舞台独占格林，但她最后将决定权给了格林，而格林真正的选择应该是夺取舞台的改变能力，因此最后白女王舍弃了一切帮助格林逃离崩坏的舞台。 这场棋局中，<code>梅贝尔</code>横竖不亏，<code>红女王</code>陷入必死之局，最关键的棋手就是白女王，只要她愿意，随时可以下出必赢的一着，但最后她依旧选择了放弃自己的棋子，把终结棋局的希望留给了格林 在经历如此多的牺牲之后，格林终于从棋子升为了棋手，只是不知道他又会下出怎样的一着</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls原著梗解析</title>
    <url>/2023/09/29/blacksouls%E5%8E%9F%E8%91%97%E6%A2%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="section">01</h1>
<p>众所周知，black souls的原型，或者说最重要的灵感来源就是爱丽丝梦游仙境以及它衍生的爱丽丝镜中奇遇，我本人一直对游戏和原著的对应关系感到很好奇，但由于工作量很大，一直没下定决心做这件事，但最近突然想到，如果分期做一些整理会不会就没那么麻烦了呢，于是决定开启这个系列。 <span id="more"></span> 由于是第一期，我就扯一些闲话，爱丽丝的原著可谓有着非常深远的影响，首先，他就是最著名的童话之一，在儿童里的传播极为广泛，在我小时候就听说并读过这个作品，但说实话爱丽丝的原著对孩童来说实在太过思维跳脱，导致我虽然通读了几遍但完全没看进去，考虑到当时的儿童文学相比现在的完善可以说几乎不存在，这本书可谓有着相当的意义，不过我毕竟没有研究过相关文学史所以不多评价了，对于爱丽丝的原著，我最深刻的印象就是其无比丰富的想象力以及跳脱的情节（由于卡罗尔是数学家，他还塞了不少数学梗进去），可能这就是莉耶芙喜欢这本书的初衷吧。 此外，爱丽丝这一形象与整个不思议之国以无数的二次创作形象疯狂地在各种娱乐作品里传播，关于这点，我认为是爱丽丝原著符号性强烈的特点导致的，永无止境的茶会，跳进兔子洞等元素非常具有符号性，它们奇怪到引人注目，但谁也不知道到底指的什么，可能有意义，可能没有意义，二次创作者可以非常自由地阐释这些元素，因此导致了在二次元文化里，爱丽丝近乎成了最常见的一个人名或者说符号 最后则是它的现实作者，金属冶炼在欧美文化里是个很敏感的话题，关于原作者此方面的谣言可以说满天飞，但对此我只能说疑罪从无，没有直接证据表明这一点，就连一些间接证据在我看来也很明显是牵强附会，基于道德的角度，我们不该用一些间接证据指责两个世纪前人物的私事，此外，black souls是毋庸置疑的架空世界观作品，不管怎么编故事也和现实中的卡罗尔毫无关系。 当然black souls设定下的卡罗尔也是个经常被讨论的问题，由于冬之钟那个崩坏的adv，很多人认为black souls的卡罗尔是个炼金术师，但是很明显小剧场不过是哪个支配者的大作，而且是个很有虫虫风格的作品，没有任何证据表明black souls设定下现实的卡罗尔干了相同的事，总的来说我认为black souls世界观的卡罗尔，除了他一直深爱爱丽丝以外和爱丽丝一家的关系是没有确切信息的，而且这种爱也可能不是男女之爱，只是柏拉图之恋罢了。 好吧，关于原著以外的讨论就说到这里，接下来我们开始具体情节的对照分析。 第一章的开头，小爱丽丝和姐姐一起坐在河边，姐姐在看一本没有插图没有对话的书，让小爱丽丝感到无聊。 书在black souls中是个很常见的意象，没有插图的书只在牛津学院的回忆中提到过一次，读书的倒是有几个，一代的爱丽丝02一直看着书，书上的内容似乎是格林被玛丽苏毁灭时的遗言，此外，一代的尸龙也在读着书，而且二代时她也在河边，根据她念出来的部分，其实就是我们这个世界的卡罗尔描写邪龙贾巴沃克被打倒的那首诗，个人猜测有可能black souls中卡罗尔没有给爱丽丝送出去的礼物其实是他的作品集，后来卡罗尔被玛丽苏捉走，这本书则被尸龙拿走，最后，二代的白女王诺登也是个看书人,这本书格林无法阅读，但0sen下能看到轮回次数 由于02不是任何人的姐姐，白女王虽然很御姐，但原型明显是白兔先生，所以对应度最高的其实是贾巴沃克，此外尸龙摸鱼的时候摘花，而此时的爱丽丝也有摘花的意图，可能暗指温柔的尸龙姐姐摘花编成花环想送给爱丽丝（迫真） 随后就是经典的爱丽丝跟着匆忙的白兔先生进了兔子洞的环节，此时的白兔先生声称自己是急着去找公爵夫人 兔子洞在一二代都有对应，一代追寻着原著顺序，跟着白兔，从兔子洞跳下就能到达不思议之国，二代却是相反的，格林先到坠落之间，然后才到兔子洞 此外，原著对坠落的描述是，途中有很多书架以及各种柜子，这点在坠落之间和兔子洞都有体现，爱丽丝在坠落后第二次见到了匆忙的白兔先生，而按通常的流程，也是格林过了兔子洞后进行度为1才能见到白兔诺登，此外原著中爱丽丝第一次来到的门厅顶上有一排灯，这可能是图书馆的进行度灯的灵感来源，原著中爱丽丝用钥匙打开一扇门后来到了放有变大变小药的房间，游戏可以直接到达，喝了我和吃了我是非常经典的原作梗。 以上是爱丽丝原著第一章和游戏的对应关系，那么今天就到此为止了</p>
<h1 id="section-1">02</h1>
<p>接下来开始第二章的分析 吃下蛋糕后的爱丽丝身形变得非常巨大，也因此挤不进她想去的花园，此时她哭泣的眼泪形成了泪水池，对应bs的血泪之池，有种说法是红偶像紫餐产生的血泪形成了血泪之池，如果从致敬原著看的角度倒是不无可能 这时白兔先生经过，被爱丽丝吓跑，留下了手套和扇子，扇子有着让人变小的能力，但此时不知情的爱丽丝一边扇扇子一边开始自我怀疑，正是这时她提到了梅贝尔这个名字。 根据爱丽丝的说法，梅贝尔什么都不知道，住在又破又小的房子，没有玩具还要天天念书，对应bs中的梅贝尔，某种程度上讲还挺还原的 随后被扇子变小的爱丽丝掉进了泪水池，并在池子里遇到了一只耗子以及其他动物，她们一起游上了岸。 接下来就是第三章了 此时耗子开始上起了历史课，这段剧情在bs有两个对应点，一个就在酒馆里耗子直接出场给我们上课，而则是牛津学院的回忆提到爱丽丝讨厌历史课。 随后为了让湿透的衣服变干，渡渡鸟为她的动物朋友们召开了一场赛跑会，跑完宣布大家都赢了，但奖品让爱丽丝颁发，甚至包括爱丽丝自己的奖品，于是爱丽丝给所有人每人一颗糖，给自己发了一只丁真，很对应游戏血泪之池的渡渡赛跑会，但游戏中只有杀害渡渡会得到一颗糖果,杀害其它动物没有奖品（私藏奖品的屑），附近可以捡到糖果，此外，游戏和原著中的赛跑参与者是不完全对应的，赛跑中白鹅会提到鹦鹉和鹰缺席了，原因吗，因为涉及一些书本以外的东西我们以后再说 此后螃蟹母子的对话会提到好脾气的牡蛎，可能对应bs的dlc1嚣张的牡蛎 第四章中爱丽丝被白兔错认为了玛丽.安，白兔家的女仆，这就是为什么被白兔诺登剥夺神力的虫虫改名成玛丽.安并且穿着女仆装。 爱丽丝喝了让自己再次变大的药水，然后被挤进了房子里无法动弹，此时她吐露了自己不想长大的愿望，随后，蜥蜴比尔被派去搬来梯子，爬进烟囱里查探情况，被爱丽丝一脚踢飞出去，这段对应bs大圣堂里比尔搭梯子的剧情，顺便一提，比尔除了倒霉蛋属性外在bs里几乎全被魔改了，合理怀疑是莉耶芙加了什么私货进去。 随后爱丽丝吃下了被扔进来的蛋糕，再次变小，并逃进了一个长着高大蘑菇的森林，并在蘑菇上遇到了抽烟的青虫，对应游戏中的孢子之森，第四章结束 也就是说原作爱丽丝的路线就是兔子洞-血泪之池-孢子之森，这也是为什么进行度0时会在森林遇到爱丽丝的幻象，虽然这一路线并不一定遇到比尔 格林和希夏的对话基本对应原作爱丽丝和它的见面，一开始不理不睬，但离去时希夏开口挽留，原著毛虫让爱丽丝背了首威廉老爹的诗，对应孢子之森的boss，游戏与原作不同的是，原作的虫子告诉爱丽丝吃下蘑菇可以变大变小，游戏中直接让格林去找公爵夫人 爱丽丝见过青虫后有段剧情，爱丽丝吃下蘑菇后脖子变得很长，被一只孵蛋的鸽子认作来吃蛋的长虫，这里译本的长虫其实就是大蛇的意思，这段剧情在游戏也有两个对应，一是游戏中的物品鸽子蛋，孢子之森能捡到鸽子蛋，杀害希夏会掉落鸽子蛋，正好符合原作顺序，对其的描述是少女不吃生蛋，蛇却很喜欢吃，也符合原作，bs中的蛇只有蛇神，而0sen下看到他的脖子很长，也对应原著情节；第二个疑似的对应点则是卡罗尔川的矮胖子，可以孵化出雏鸟，但除此以外和原著没什么对应</p>
<h1 id="section-2">03</h1>
<p>接下来我们开始第六章，公爵夫人的章节 公爵夫人馆外能遇到名为幼犬的怪物，这应该对应书中第四章，遇到青虫前爱丽丝遇到的小狗，馆内可以遇到鱼和蛙之听差，原作中他们分别是女王派来邀请打縋球和公爵夫人处接受邀请信的佣人。 公爵夫人是比较还原原著的一个角色，基本上所有行为举止都有对应。爱丽丝初见她的场景和游戏中几乎完全对得上，婴儿和猪的转化则用sen值来实现（顺便一提屠宰场也有类似的转换），只有柴郡猫没有出现，但馆内一张挂画上则会出现柴郡猫，这张挂画上随着sen值不同也会出现猪和婴儿的转变，此外，由于公爵夫人还原度很高，我把台词中的对应点用图整理如下 公爵夫人另一个原型，也是她名字和贪食属性的由来则是一幅画作，这幅画作（比较哈人就不放了）可能的历史原型是一位贵族女性，她在历史上有大嘴的外号，并且和丈夫并不恩爱（甚至没同过房？），这解释了里线中她的台词 游戏中柴郡猫瞬忽隐忽现，还有标志性的微笑都出自此章，不过对她来说似乎更认同爱丽丝家的猫的身份，然而她又部分否定了戴娜的身份 值得一提的是，此前我们提到的原作路线都是有着某种程度上的认证的，到森林的路线有爱丽丝幻影，随后有希夏的指引，但从公爵夫人开始跳脱出了梦游仙境，让我们去了镜中奇遇，并且地图到了这里也确实是死路，如果继续按公爵夫人的指引，到达库因兰德这条死路后也确实找到了爱丽丝，虽然格林并不知情。 而如果我们想要继续原著路线，就要踏上不同的路，经过牛津学院到达永不终焉的茶会，为什么呢？ 关于茶会我很有些个人想法，但我们先从原著的角度说起 虽然一二代都有茶会，但比较对应原著茶会一段的是二代的茶会，原著中帽匠和三月兔被柴郡猫钦定为疯子，可以说是整部作品里最荒诞的一段，在bs中也不遑多让，我们先从三人的现实原型说起，帽子屋的原型是中世纪的帽匠，由于工艺会用到水银，所以有着疯疯癫癫的形象（游戏也提到这点），三月兔的原型是一句俗语，这句俗语的由来据说是兔子三月处于繁殖期而狂躁不安，所以会有这种人设，睡鼠原型则是一种常见的宠物，非常嗜睡，当时人们喜欢把它养在茶壶里。 我们分人物说起，首先是帽匠 原著一见到爱丽丝，帽匠就大喊没位置了，并且抛出了乌鸦桌子的谜语，和游戏一样，这段谜语若干年后卡罗尔才公布答案，所以游戏的帽子屋说不知道答案。 随后，爱丽丝说自己说的和想的一样，三人一人一句地反驳了她，其中除了三月兔抛出的两句话，都是主语宾语单项包含关系，但游戏中爱丽丝的话由帽子屋说出，并只有睡鼠保留着这种逻辑关系。 面包黄油的对话几乎完全致敬原著。 原著爱丽丝与柴郡猫对话提及此刻是五月，和帽子屋对话提及今天是4号，游戏中时计塔的密码1852正是爱丽丝的生年，所以游戏中帽子屋会说擅长happy birthday 帽匠会提及，自己和时间闹翻了（红心女王的说法是谋杀时间），所以茶会被永远定格到这个时间，餐盘只能越积越多，这可能是游戏中帽子屋不死能力的来源，监禁后她离开了茶会，所以又可以杀死了，此外，游戏中狂鸟一定程度上和时间有着关系，并且帽子屋很讨厌她，或许和原著这段情节有关（但帽子屋又称呼时间为先生） 随后是三月兔，原著中三月兔头顶缠着稻草，卡罗尔说这表示她疯了，游戏致敬了这点。 原著的三月兔打翻了牛奶，游戏中是红茶 最后是睡鼠，睡鼠在原著中唱歌和讲故事都和游戏里对应，故事中三个小姑娘的名字对应利德尔三姐妹，讲故事时，三人责怪爱丽丝打岔，在游戏中里线战斗对话有体现。 好了，以上是和游戏原著比较对应的地方，接下来我就说说对茶会的个人理解，再强调一下，都是个人理解。 茶会可以说是bs2中一个很重要的地图，它和牛津学院直接相连，并且两张地图连续有一个回忆，而进入牛津学院主流的路线就是从精神病院开始通过路德维希市街，见证伊迪斯和杰克的悲剧，顺便一提关于利德尔三姐妹，我之后会出个特辑，这里先不谈，漫布迷雾的街道明显是在neta伦敦，并且卡罗尔是英国人，曾在牛津学院任职，这条路线可以说是最贴近现实的一条路。 此外，如果要防止狂鸟唱歌，就必须先来到茶会去往时计塔，并且时计和箱庭的运转息息相关，而狂鸟唱歌的目的应该就是让格林别乱跑了去找爱丽丝，此外，不思议之国的大部分地方都很有着阴森的氛围，而且弯弯绕绕，只有茶会非常狭小却坐拥一个篝火而且阳光明媚氛围悠闲，几乎可以磨灭格林的斗志了，茶会的三个参与者就更有意思了 如果我们给三人归纳一个关键词，一个是疯狂，一个是爱欲，一个是睡梦，三者加在一起几乎概括出了整个二代的特点，这恐怕是奈亚不想让格林意识到的，此外，来到茶会必然会遇到伊迪斯，按原作顺序之后就是红心女王罗丽娜，两人是乱入者，且都曾和卡罗尔关系亲密，奈亚不希望她们引发卡罗尔的回忆，所以才会让夫人把我们支开。 对这三人和她们的象征意义，疯狂和爱欲其实不必多说，但睡梦其实是一条相对的暗线，我一直认为寿司是一个很喜欢前后对照的作者，所以就让我们来分析一下，不少npc会提及此处是个梦境，但最早是在op，游戏的开头是格林苏醒，看到爱丽丝，然后不知道为什么再次睡去，因此我们如果认真看开头就会知道不思议之国是个梦境，那么为什么设定成梦境呢，首先是由于协助创造箱庭的诺登的原型是所谓的幻梦境之主，其次呢就是因为原著的结局会发现爱丽丝的奇遇是一场梦，光是这点就很有意思，两者揭露梦境的时间点完全相反。 那么问题来了，已经在梦境了，如果再次做梦不就有了梦中梦？而如果是梦境是虚假，梦中梦则是虚假的虚假，会不会是真实呢？格林做过几次梦中梦呢，第一次是精神病院看到师匠，第二次是孢子之森的幻觉爱丽丝，第三次是海底的旅社，第四次是冬之钟adv，牛津学院的月面比较特殊就不论了，这几次梦中梦，虽然未必都是真实，但都揭示了部分真相或者现实。 既然如此，有一个人就很奇怪了，睡鼠，她是格林外唯一一个能在梦境中沉睡的人，如果是格林自己的梦还可以做梦中梦，但睡鼠一个梦境中的角色怎么还能入梦呢？除非她只是装睡，对话中睡鼠会说她没有睡，所有人的对话她都没有听漏，这很有可能就是真相（虽然里线又说真在睡），并且她随后说了一句要杀了所有人，然后辩解说是梦话，结果全监禁后她真的这么做了。 因此个人猜测睡鼠表面虽然入梦，但其实是最清醒敏锐的，她有着监视格林的任务，一旦格林不照着剧本做梦，滞留在一次轮回中，就会把风险清除掉，逼迫他进入下个轮回。 而h结局中在冬之钟我们能看到三月兔和帽子屋，她们的对话反过来看就是冬之钟的本质，为什么只有这两个人呢？一是三人的对话提到除了睡鼠两人都想来冬之钟，二则是根据我的想法，此时格林意识上已经从梦里醒来，剩下的问题就是奈亚的爱欲，以及舞台带来的疯狂，也就是茶会的这两个人的象征。 当然，以上不过是个人解读，大家看个乐就行。 可能有人问，那么一代的茶会呢？这个由于时间线的原因我们以后再讲。</p>
<h1 id="section-3">04</h1>
<p>让我们开始第八章的分析 七章末尾，爱丽丝被疯疯癫癫的三人惹恼，离开了茶会，进入了一片森林，在她迷路时出现了一道门，让她回到了最初的兔子洞大厅，随后她利用变大变小的能力走进了最初看到的庭院。 这段路线，如果我们忽略茶会怎么回到兔子洞这个问题，可能对应利德尔墓地到心脏庭院，墓地这块确实是森林，并且进入庭院的入口确实是一道门，虽然顺序颇有些问题。 原著中，入口旁的三个扑克园丁忙着把种错的白玫瑰刷成红心王后喜欢的红色，随后被王后发现要杀头，游戏中只有一个庭师在干活，而且不是上漆而是上血，另外两个则在说格里芬的闲话。可能是rpgmaker的素材问题，原著和游戏的扑克种类对不上 原著中红心王后杀头的表达翻译过来大概是这样的：他们的头没了吗？士兵的回答是：“他们的头不见了”由此王后认为确实杀头了，这里是个文字游戏，原著中这三个园丁藏了起来，头确实看不见了，但没有杀头，这可能是游戏中红心女王不看处刑场面的由来。 杀头后王后邀请爱丽丝打追球，但是球棍是火烈鸟，球是刺猬，两者都会在游戏出现，区别是火烈鸟0sen变成弯曲的球棍，球则在0sen才出现 打球的时候公爵夫人来向爱丽丝搭话送了她几句教训，对应游戏中公爵夫人出现在追球场并且满口教训，随后王后再次出现在爱丽丝面前，带她回去打球，这次过程中王后把除了国王的所有人判了死刑，随后国王赦免了他们。 可能是由于实际上外来者的缘故，红心王后也被魔改得很厉害，基本上只有性格和杀头的口头禅是还原原著的，此外，原著的红心王后虽然没杀过一个人的头（狮鹫的说法），但被所有身边人畏惧，这点也沿用到了游戏中，红心王后可能的原型是当时的英国女王，这也是为什么游戏中红城bgm是掷弹兵进行曲。公爵夫人会说红女王和红心女王一样残暴，这段可能来自于卡罗尔自己对两位皇后的解释。原著的红心国王直接删掉了，是梦游仙境唯二个游戏里没有对应的主要人物（还有个是红桃杰克），当然也有可能对应格林（笑）。 之后，王后让狮鹫带爱丽丝去听假海龟的故事，对应游戏里罗丽娜发布布告让部下去讨伐食尸鬼，因为会在那里见到假海龟。原著中在女王走远后，狮鹫说到女王从来没有成功杀过一个人的头，对应游戏中格里芬说女王不敢看处刑场面 这里顺便一提，狮鹫是卡罗尔任职的牛津学院的三一学院的院徽，假海龟出自当时用牛肉汤代替昂贵海龟汤的习惯，原著中狮鹫懒散，假海龟则惶恐不安，和游戏对应，假海龟哭哭啼啼地讲起了自己的故事，它曾在深海的学校上课云云，这里是非常典型卡罗尔造生词环节，游戏中有原台词化用 说完上课的事后，狮鹫提出跳龙虾方块舞，游戏中则是龙虾舞，为什么呢，我给大家三秒钟猜一下，因为格里芬是方块骑士，所以已经有方块了，这很可能是方块骑士身份的来源，因为除此以外原著只有一些方块廷臣，其中的歌是假海龟唱的，游戏中也有体现，格里芬说自己不记得歌词 随后狮鹫让爱丽丝背了几首诗，最后假海龟唱了一首海龟汤，对应游戏中让假海龟做料理的台词 关于爱丽丝的线索，女王和格里菲会引导格林去市街，市街的卡面来打会引导格林去墓地方向，随后线索就断了。 这之后就是梦游仙境最后一个场景，审判庭，关于审判这件事的信息，翻遍二代也只能找到狮鹫去邀请比尔当陪审员这件事，其中，他们会说审判已经发生过一遍，那么是在哪呢？ 很有可能是在一代的不思议之国。已然终结的茶会，最明显的是守门的班达斯奈奇，他提出的问题和答案部分和原著的审判相对应，茶会中的一只兔子会提到疯帽子三人以及爱丽丝的消失，这正是原著剧情，收集童话出现的里门，爱丽丝排列成类似法庭陪审团的形式面朝格林，这很有可能也是表示审判。 此外，我也有些个人想法，杀害02得到的缎带物品描述是追寻梦中的爱丽丝，这几乎可以肯定指的二代，而爱丽丝原著正是在最后的审判后告诉我们一切都是梦，然后见到了姐姐，而这和一代也在读书的尸龙姐姐勉强对得上，审判后的爱丽丝消失了，奈亚丽丝用格林取代了她的位置一直梦游到了审判剧情前，这样一来就构成了一个循环，爱丽丝梦游仙境结束后开始格林梦游仙境，这是很有寿司风格的前后对照。 此外，还有一种可能的解读是，审判其实是奈亚丽丝内部召开的，最后判决结果是把爱丽丝01驱逐出去，产生了红偶像 总之，审判这段原著情节在bs有没有对应大家就见仁见智吧 好了，这样一来对梦游仙境的解析就结束了，下一期作为拾遗篇，我会说说卡罗尔和利德尔三姐妹在游戏中的暗线。</p>
<h1 id="拾遗篇">拾遗篇</h1>
<p>查尔斯·道奇森，一个天赋型的数学家，笔名刘易斯.卡罗尔，最知名的作品是两本以知名幻想角色爱丽丝为主角的作品，与同时代知名的柯南道尔（福尔摩斯系列的作者）同是一个灵异研究学会的成员，还有一个较晚出生的知名的同时代人是克苏鲁体系的作者洛夫克拉夫特 有意思的是以上提到的三人分别是三种文学流派的奠基人，并且这三种衍生文化不同程度地影响了bs系列 1855年，卡罗尔23岁，结识了自己任职学院的院长一家，一年后认识了三姐妹，随后的时间他时常和这家的三姐妹一起聚会，1962年7月4日，一个黄金的午后，当时三姐妹的长女罗丽娜13岁，次女10岁，三女8岁，与卡罗尔一起泛舟湖上，卡罗尔讲了一个日后成为梦游仙境原稿的故事，两年后整理成了一部名为地底冒险的手稿送给次女。 1863 年 6 月，利德尔一家和卡罗尔之间的关系突然破裂，没有直接证据能说明原因，几个月后有所缓和，但已经无法还原如初的美好了。 再之后，长女没有在历史上留下痕迹，次女和三女都和一位王子有过绯闻，但可能因为身份原因没有成，可怜的三女在即将结婚时22岁因病早逝（精神病院的开门次数），似乎最受上天关爱的次女于28岁结婚，成为哈格里夫斯夫人。 这是我们这个世界历史上的卡罗尔和三姐妹的故事。那么bs世界里这四人发生了什么呢？</p>
<p>最直接的证据是六段苦涩的回忆，虽然对他们的来龙去脉或是真假完全没有确论，但它们提供了大部分相关信息，我们按现实时间顺序一个一个说起。 卡罗尔川的回忆直接用了梦游仙境的卷首诗，描述了这个故事的原初，并且由于卡罗尔生活时期正是英国盛世，泰晤士河污染严重，黄金午后的那条河流从属于泰晤士河，和游戏中污染的描述也对得上 按现实顺序随后的应该是牛津学院的回忆，卡罗尔和利德尔一家的交恶 随后则是槌球场，这里应该对应现实中黄金午后的两年后，卡罗尔送给了爱丽丝地底冒险手稿，这部手稿有卡罗尔自己的插画，但并非圣诞礼物，卡罗尔曾和爱丽丝一家打槌球玩，因此会出现在槌球场，但游戏中此时二家似乎没有交恶，因此bs中可能存在顺序调换。 之后就是纯粹的架空时间线了 之后是叹息的海边，回忆中摄影的阁楼有现实对应，正是牛津大学的建筑，回忆描述了两人的再次重逢，至于为什么是海边，可能是因为卡罗尔在1876年出版的《猎蛇鲨记》，这是他最后一部知名作品，次女和卡罗尔的重逢历史上没有什么资料，事实上，即使卡罗尔逝世时，次女也就46岁，不可能是老婆婆，但梦游仙境的改编的戏剧于1886年圣诞节期间上映，卡罗尔也去看了，顺便一提，演睡鼠的是一位叫多萝西的女士。这是有记载的卡罗尔最后一次见到次女，而有记载的次女最后一次与卡罗尔有交集，是在1932年卡罗尔逝后的100年诞辰，这时她已经80岁了 再后面是库因兰德的回忆，库因兰德的女王原型是镜中奇遇的红女王，而镜中奇遇出版于1871年。这段回忆似乎提到卡罗尔把另一个人当做代餐，可能是bs世界观的罗丽娜？ 最后是完全架空的茶会回忆，和现实基本没有关系了。 其次还有若干原著彩蛋在游戏中使用，如卷首诗，也就是第一段回忆的little和利德尔同音，血泪之池的鹦鹉和小鹰分别是长女和三女的书中化身，睡鼠的故事也化用了三姐妹的名字等</p>
<p>卡罗尔在bs中和现实基本对应得上，但还有的问题是，猎蛇鲨记，贾巴沃克等作品的来源没有交代，其中贾巴沃克这首诗尸龙基本给我们念了一遍，有可能原稿在她手上，此外卡罗尔虽然终身未婚，但依然有很多朋友，如猎蛇鲨记就受一位忘年交的启发，可能是冬之钟小剧场那张照片中的女人 顺便一提，现实中的弗朗西斯.利德尔1965年出生，自他记事起卡罗尔和利德尔一家应该都不怎么来往了，现实中的三姐妹和当时的大部分贵族女性一样在家中由私教授课，不可能叫卡罗尔老师</p>
<p>之后我们来分别探讨一下三姐妹在bs的暗线 现实中的长女资料最少，但书中的鹦鹉有卖弄自己年纪大的特点，并且有一种说法是，当年的长女对卡罗尔非常依恋，这些特点沿用到了游戏中，有可能bs中的卡罗尔倾吐虚假爱意的对象就是她。根据其自述，罗丽娜向邪神献祭灵魂才会来到不思议之国，但时间点未知，如果是在次女后，那么游戏中的罗丽娜是完全的少女心性就很奇怪了。还有一种说法是，罗丽娜和她的母亲名字一样，所以小剧场那张照片的真身有可能是……不过我觉得这可能很小就是了 心脏女王也是个谜点重重的角色，如果我们给有梦游仙境原型的誓约角色所需魂数量排序，那么由小到大依次是白兔，渡渡，比尔，希夏，公爵夫人与假海龟，帽子屋，心脏女王 其中除了假海龟都参照原作出场顺序，她虽然是乱入者，但不思议之国大部分住民都会提到并认同女王是名义上的统治者，她不知为何能指挥魔兽化的手下，让唯一有理智的格里菲去全国巡逻，每天用审判来控制人口，还给大工批了大把建筑费用来上达天听，不知道是奈亚的命令还是什么其他原因，她确实做了很多管理不思议之国的事，此外，还是唯一一个非格林子女却有里线战斗的 三女伊迪丝在游戏中是精神病院的boss，对于她怎么来到箱庭，仅有的线索是混沌迷宫和电影院的两段没头没尾的故事，游戏里和三女私奔的王子，很可能也是杰克，这位角色现实原型之一很可能是利奥波德王子，正如前文所说，据传他曾与伊迪丝相爱，伊迪丝22岁早夭后，王子为她抬棺，王子和伊迪丝一样病弱，患有血友病，三女辞世的8年后，王子以30岁的年龄逝世，这或许是游戏中他也住院的原因，另外两个明显原型是开膛手杰克和福尔摩斯，或许是因为卡罗尔曾被看做开膛手杰克的嫌疑人，而同时代柯南道尔也曾经研究过这个案件，顺便一提上文王子的一个侄子也是一大嫌疑人 伊迪丝在冬之钟小剧场里头戴着枯萎的花圈，可能暗示着她的早逝，并且多次有小鹰的元素出现，但罗丽娜除了大姐作风却没有明显的鹦鹉元素，这点也有些让人在意 最后是次女，这里的次女指的是观星引来奈亚的人类个体，关于这个个体的信息反而是最少的，只知道她和卡罗尔心心相惜却被拆散，她和现实次女的履历是否一样未知，她的最终去向未知，牛津学院的学寮长是否就是她父亲的灵魂所化也未知。 关于现实中的对应，现实的次女并非常见的金发形象而是黑发，并且和梦游仙境的爱丽丝有很多差异，游戏中似乎没怎么提到过发色，不知道如何设定，次女和南丁格尔是同时代的人，因此院长认识爱丽丝可能是认识人类状态的次女，此外，小剧场的次女会有很多致敬原著的台词，出示如下 在群星之夜后，似乎她的名字成为了禁忌，也是里线剧情的关键，关于次女我还有一个，， 等等，次女的名字，为什么，我想不起来次女的名字，对了，她的名字，她的名字不就是 爱丽丝.利德尔 勿呼其名，唤则得知，蠕动前行而来 縺ｩ縺?＠縺ｦ遘√＇谤｢縺辅↑縺代ｌ縺ｰ縺ｪ繧峨↑縺??縺ｧ縺呐° 繧｢繝ｪ繧ｹ繧呈尔縺励※缧ゅい繝ｪ繧ｹ繧呈?縺励※缧ゅい繝ｪ繧ｹ繧贞ｿ倥ｌ縺ｪ縺?〒缧 诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ 诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ</p>
<h1 id="ex01">ex01</h1>
<p>相较梦游仙境，镜中奇遇在bs中的对应情节明显变少，但依旧有分析的价值 首先是镜中奇遇的卷首诗，这首诗提到了卡罗尔此时和现实的爱丽丝年龄相差一倍，语气中某种程度上可能透露了卡罗尔对无法回到往日时光的惋惜，不管怎么说，此时爱丽丝已经长大了，看童话故事的美好时光已经不会回来了 开篇剧情中爱丽丝在和戴娜生下的小猫玩，对应普通结局少女的房间中柴郡猫说自己产下小猫后死去，虽然我们不知道现实的戴娜是怎么死的。 随后爱丽丝会提到镜子屋，也就是镜子里的相反的房间，这在之后成为整本书的主题，在bs中镜子屋对应公爵夫人提到了通过血泪之池镜子才能到达的镜之国，但同样和镜子有莫大关系的还有一位小红帽，值得一提的是，镜之国库因兰德是为数不多没有柴郡猫出现的篝火。 随后爱丽丝在镜子屋看到了一些会说话的棋子，并随意摆布它们，这段有点像bs奈亚的作风 她翻到了一首叫贾巴沃克的诗，当然这里其实是卡罗尔引用之前的作品，贾巴沃克这首诗非常晦涩难懂，以后有机会我会谈谈在它在bs里的对应。 之后爱丽丝飞跃滑下楼梯，想跑去屋外的花园，这里的下楼梯法在冬之钟小剧场有对应</p>
<p>爱丽丝想走到一座小山丘俯视花园上，但怎么走都会回到原点，这 里可能对应精神病院的走法，也可能对应库因兰德的迷宫，于是她只能转而去往一个小花园，遇到了一群会说话的花，这些花对应一代圣森和不思议之国的会说话的花，以及在bs2中，红女王的房间里的花，一些花很吵闹，爱丽丝威胁把它们拔下来，对应道具咒骂之花， 随后爱丽丝遇到了红王后，原著中的红王后被卡罗尔描述为典型的家庭教师，原型可能就是爱丽丝的家教，bs中红女王的名字直接用了这位家教的名字，有一种说法是卡罗尔利用三姐妹来追求她造成两家决裂 爱丽丝羡慕地说想成为王后，红王后告诉她需要前进八格，然后拉着她全力奔跑，贡献了一句经典台词，前进八格成后这是国际象棋的规则，而红王后的台词在bs中对应库因兰德的一个留言和冬之钟柴郡猫的台词 值得一提的是在原著中有重要意义的棋盘在bs中也有同样的重要性，红女王的库因兰德遍布着棋子，梅贝尔在自己的箱庭部下棋局，而白女王则把王冠，也就是走了八步后成王的关键放在了冬之钟，可以推测原著中想要成后的爱丽丝其实对应着bs中想要得到改变权能而成王的格林。 红王后指引爱丽丝成后的走法，提到了需要乘火车，对应去库因兰德的火车 火车上爱丽丝遇到了一只会说话的虫子，在一阵颠簸后她们发现自己安静地坐在树下，爱丽丝和它讨论了一下命名学，虫子告诉爱丽丝前方有着无名之森，对应bs里的那张地图，这只虫子可能也对应无名之森的一只虫形怪物 无名之森里爱丽丝遇到了一只小鹿，对应bs中无名之森的小鹿，但bs中通过无名之森才能坐火车，与原著相反 本章的末尾，爱丽丝遇到了双子</p>
<h1 id="ex02">ex02</h1>
<p>爱丽丝接下来遇到的是崔德尔双子，二者一开始站立不动，让爱丽丝觉得他们是蜡人偶，也就是蜡像，游戏中反了过来，游戏中双子提到了站立不动的格林是蜡像的可能 两兄弟的原型是一首英国童谣，童谣提到了丢失的拨浪鼓和飞来筑巢的乌鸦，在游戏双子的台词有体现，筑巢的大鸟应该就是伊迪丝 随后两兄弟给爱丽丝背了首海象和木匠的诗，大意是海象和木匠偏小牡蛎来做客，然后把它们吃完了，游戏中很明显海象对应希伏契，木匠对应大工，吃牡蛎的剧情也在希伏契对话中有体现，且，双子誓约对话会提到两人 之后，爱丽丝发现了附近正在做梦的红王，在双子对话中有原意复用 双子中的蒂看到了他弄坏的拨浪鼓，让两兄弟起了矛盾，对应游戏中的台词，随后两人约定决斗，可能对应游戏里的双子相残，就在这时乌鸦飞了过来，打断了决斗 书中的两兄弟按棋谱来说是白方，这解释了她们为何与dlc3的克里米亚有一定关系</p>
<p>为了躲避大鸟，爱丽丝逃进树林遇到了白王后，与严肃的红王后不同，白王后非常随和友好，并且她声称自己是倒着过日子的，这解释了白女王诺登管理重启轮回的职能 交谈一会后，爱丽丝突然转移到了一间商店里，店主是一只绵羊，发生了很多怪事后爱丽丝又闪现到了小船上和绵羊一起划船，对应游戏里老羊的台词 书中这段空间转换非常频繁，可能因此寿司在老羊商店里放了一堆来源不明的谏言</p>
<p>一连串的转换后爱丽丝看到了矮胖子，这位角色也来自于一首英国民谣，矮胖子很多台词台词在游戏里有直接对应，整理如下 值得一提的是矮胖子解释了一些贾巴沃克诗的生造词，为后世的译者提供了不少信息。 在爱丽丝和它不欢而散后，听到了蛋壳碎裂的声音，暗示它的跌落，但游戏中矮胖子是因为孵化而裂开</p>
<p>爱丽丝再次前进，遇到了白国王和他的部下，信差告诉了他独角兽和狮子为了王冠争斗，这里的两只动物对应苏格兰和英格兰，并且依旧来源于一首民谣，游戏中冬之钟小剧场长女会引用，并且冬之钟也有很多争斗的对应情节，整理如下 独角兽傲慢，狮子凶恶，游戏中有一定程度上的体现，两者对应的棋子走法一个诡异难测，一个横冲直撞，也在游戏中对应</p>
<p>随后，爱丽丝遇到了前来将她军的红骑士，但埋伏在旁的白骑士反吃了红骑士，护送爱丽丝成王前的最后一段路，这段几乎没有在游戏里的直接对应，除了冬之钟小剧场he中卡罗尔让三姐妹为他挥手帕用了原台词，并且也有说法是白骑士是作者的投影。 但我个人对此有一些猜测，这段很可能对应整个冬之钟剧场，根据一些主流猜测，这段其实是梅贝尔和古兰合谋困住了追击的奈亚，如果我们认为红方是敌方，那么就对应奈亚，指引爱丽丝成王的红王后对应反水的红女王，红骑士表示前来追击的奈亚，白骑士就可能是白女王方的梅贝尔，那么这段剧情就成了，奈亚前来将住格林，梅贝尔前来解围，护送格林到了成王之路</p>
<p>终于，爱丽丝戴上了王冠，格林成了“王”，在此之后的剧情对应很少，青蛙佣人招待爱丽丝去了晚宴，对应游戏中去往古兰晚宴前向海因里希托付女儿，爱丽丝梦醒后红白王后成了黑白两只小猫，对应红女王的台词，可能会在续作有进一步的阐释</p>
<p>至此，对卡罗尔爱丽丝系列的作品就完全结束了，之后有机会可以说说贾巴沃克和猎蛇鲨记</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls人物解析</title>
    <url>/2023/09/29/black%20souls%E4%BA%BA%E7%89%A9%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="尸龙贾巴沃克">尸龙贾巴沃克</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在天之繁星哟！命数已定之众哟！尽管去为爱所煎熬吧，为嫉妒之苦吧！呜呼！感激涕零吧！为这幸灾乐祸暗黑舞台点缀色彩就好！！！</span><br></pre></td></tr></table></figure>
<p>象征着腐败与神秘的紫黑色，遍布全身的缝合痕迹与绷带，恶魔一样的卷曲角，晦暗如死尸的肤色，以及左眼燃烧着的灵魂之火（致敬黑岩射手可能性微存），<code>尸龙</code>姐姐的人物形象无时无刻不在传达着神秘强大而阴暗的气氛，本视频将对<code>尸龙</code>的整个人物进行解析 <span id="more"></span> <code>尸龙</code>在爱丽丝镜中奇遇的原型是一首小诗，这首诗的大意是勇者手提沃伯尔之剑斩杀邪龙<code>贾巴沃克</code>，游戏中也承袭了这一设定，<code>贾巴沃克</code>一直都以死尸的形象登场 要解析这一角色，我们首先从最直接的行为说起，按游戏的时间线，<code>尸龙</code>姐姐大概做了以下这些事 1把童话（具体哪本未知，根据混沌迷宫的狼外婆信息推测可能是小红帽）给了渴望母爱的玛丽.苏，从而激发了虫虫的创作能力，导致她创造出一代的箱庭。顺便一提，关于<code>尸龙</code>和<code>玛丽苏</code>的关系，游戏里没有直接证据支持姐妹说，混沌迷宫提到黑山羊有两个子嗣，米兰达认为<code>尸龙</code>有黑山羊的气息，且明显<code>尸龙</code>和<code>玛丽苏</code>有一定关系，这些是确定的，但并未明说姐妹，有人从克苏鲁的设定中寻找论据，但本人对克系了解不多在此不评价。 2红偶像约会中电影《三人的茶会》提及茶会时期的三人曾经打倒过贾巴沃奇，不知是否和<code>尸龙</code>有关，此外<code>尸龙</code>也曾被昔日的勇者，如今的猎头兔打倒，自称在之后洗心革面，但相关资料太少，我们不知道是不是她放水或另有隐情 3格林被引导进<code>玛丽苏</code>的箱庭开始一代的故事，此时<code>尸龙</code>（不知道<code>玛丽苏</code>是否知情）已经乱入到一代的不思议之国，为格林一行人提供帮助，通关d结局后找她对话，她会直接把二代给剧透了，不过由于时间线上d结局应该直接接上二代，所以“正史”上可能没有这件事，顺便一提，一代的不思议之国是爱丽丝的箱庭，或者说<code>玛丽苏</code>的仿造品，也没有定论，所以很难推测<code>尸龙</code>是入侵还是本来就在那里 4来到二代时间线，由于不思议之国是奈亚的箱庭，而黑山羊则是奈亚的“配偶”，所以<code>尸龙</code>出现在这倒是理所应当，此时的<code>尸龙</code>以四噩梦之一的身份登场，，但工作内容则是在卡罗尔川上堆雪人，以及在格林面前装出温柔大姐姐的形象，十足的关系户做派。 里路线中，格林和米兰达等人可以先后对战三噩梦，以及杀死其余两个噩梦后现出真身的<code>尸龙</code>，值得一提的是这似乎是她全系列中唯一一次全力出手，并且在此战中死亡，但考虑到支配者的特性，是否死透了依旧存疑 以上就是<code>尸龙</code>在系列中的行动，接下来我将对这些行动的目的与<code>尸龙</code>的性格进行归纳。 <code>尸龙</code>首先是一个安静的观察者，一代中她只是在一棵树下扮尸体，二代则在河边堆雪人，如果格林不找她，在里线之前不会和她有任何交集，然而，隐藏和善表面下的真相是<code>尸龙</code>其实是个性格扭曲唯恐天下不乱的乐子人，是她启发了<code>玛丽苏</code>创造自己的黑童话箱庭，间接引发之后所有的故事，而一开始的目的可能只是以<code>玛丽苏</code>面对求而不得的母爱痛苦挣扎的样子为乐，也是她诅咒了狩猎邪龙的英雄，使兔子一族成为贪食尸体的魔兽，其中被沃波尔斩下头颅可能是她行事风格的分界线，其自述死前曾是无恶不作的邪龙，在复活后变得收敛，但其实依旧不改邪龙本质，只是变得只在关键时刻推波助澜 而将这两种性格统一起来的则是她的创作欲，没错，和<code>玛丽苏</code>一样，<code>尸龙</code>对创作也有自己的执念，在<code>玛丽苏</code>涌现起黑暗的创作力之后，<code>尸龙</code>意识到，<code>玛丽苏</code>那邪恶的灵魂一定程度其实是自己的作品，如果说<code>玛丽苏</code>是支配者中第一个创造故事的人，<code>尸龙</code>就是第一个“创作者”，这激发出她内心最深层的欲望，那就是创作出足够黑暗污秽的灵魂，方法则是让一个灵魂在无尽的痛苦与求而不得中循环。 可以说在这点上<code>尸龙</code>和奈亚有一定的共同点，就是让格林经历无数次的痛苦循环，但二者还是有着分歧，奈亚想要的是格林求而不得的爱，<code>尸龙</code>则想要格林本就污秽的灵魂更加黑暗。 这时我们就可以理解<code>尸龙</code>的行为了，由于里线实际上也处于轮回之中，所以对<code>尸龙</code>来说，告诉格林一些真相只会让他的反抗更加激烈，也会在反抗之后更加绝望，这样才符合她的目的。 而以上依旧是<code>贾巴沃克</code>的表层性格，而她隐藏最深的性格则是扭曲的独占欲，在卡罗尔川的地牢中有个四个雪人，分别是<code>玛丽苏</code>，小红帽，爱丽丝和格林，此外，班达斯奈奇的住处也有着一个写着想将其变为收藏品的雪人（sen0才能看到真相），可见<code>尸龙</code>内心最深的欲望其实是独占欲，培育最污秽的灵魂，随后将其收藏起来，这才是<code>尸龙</code>的愿景，但她为何要隐藏这一欲望呢，在qf<code>尸龙</code>失败的逆监禁剧情里，由于<code>尸龙</code>发现格林的灵魂已经黑暗到想要独占自己，<code>尸龙</code>就会唯一一次直接暴露自己的独占欲来收割这个丰硕的成果，然而，奈亚或者其他支配者绝不会容忍这种行为，所以一旦<code>尸龙</code>试图独占格林就会立刻被排除出世界，这就是<code>尸龙</code>一直压抑着独占欲的原因。 此外，根据dlc3入口处的对话以及数量庞大的雪人，或许可以猜测<code>尸龙</code>曾经一边观察一边玩弄过很多灵魂，但这些灵魂最后都因为经历过多的痛苦和绝望后变得麻木，因此才会对有着无穷成长性的格林视若珍宝 一切温柔的言语都不过是为了将格林引导向更绝望的结局，独占污秽的黑之魂，玩到腻后就扔掉，对<code>贾巴沃克</code>之魂的描述为包藏在虚伪的母性之下的独占欲之影可谓恰如其分。 值得一提的是，独占欲这种感情不止在<code>尸龙</code>一人上出现，大部分支配者都有着这种感情，如白之女王诺登就承认自己多次有独占格林的想法，爱丽丝01也曾吐露自己害怕不可控制地想要独占格林，但她们与<code>尸龙</code>的区别则是，她们能够理解人类的爱，并为了人类的幸福选择放手，与红白女王的对比或许也是<code>尸龙</code>人物形象设计的一个目的 现在可以做一个总结了，<code>尸龙</code>姐姐是一个对格林有着强烈爱意的角色，她的母性是虚伪的，但这种爱意却不是，尽管她扭曲，残酷，自私，虚伪，但是她始终知道自己要做什么并理性地付出行动，即使失败了也不失风度从容自若，相较于虫虫几乎写在脸上的扭曲性格，直截了当的作恶行径，以及一有挫败就大呼小叫的行径，<code>尸龙</code>的感情更加内敛，行事也更加隐秘，但可谓是个很有恶人魅力的反派角色 同时，由于bs的碎片化叙事并且尚未完结，关于<code>尸龙</code>依旧有很多谜团，例如她和<code>玛丽苏</code>以及其他支配者的具体关系，里线中她是不是仍然在演戏，她究竟为何会给<code>玛丽苏</code>童话书，<code>尸龙</code>等三噩梦和三个爱丽丝的关系等等，就期待续作的解答了 大家都来和<code>尸龙</code>姐姐做朋友吧，尸门</p>
<h1 id="玛丽苏">玛丽苏</h1>
<p><code>玛丽苏</code>，作为bs中自称的女主角，是bs唯二个三代都有出场（包括红森）的支配者，还有一个是<code>贾巴沃克</code>），在此过程中做过的好事可谓数不胜数，罄竹难书，我们来按着时间线整理一下 1一开始的<code>玛丽苏</code>是个渴望母爱的孩子，尽管我们不知道bs设定下一开始的支配者到底会不会有类似人类的亲情，她掌管自己的世界，倾听子民的祈祷，开始感到厌烦，这时<code>贾巴沃克</code>不知出于什么目的，送了她一本童话书，这本书，我们不知道是哪个童话，但本人猜测很可能这本书的作者是<code>玛丽苏</code>第一个抓住的，并在黑之魂的融合中有重要地位，根据青鸟的文本，卡罗尔并不是第一个抓住的素材，所以基本可以排除梦游仙境，结合男主角格林的名字和混沌迷宫的狼外婆，我个人猜测是小红帽，她开始渴望创作自己的故事来打动母亲，至少一开始是这样，她派遣属下四处收集童话作者的灵魂作为素材，同时肆意进行同人创作。 2<code>玛丽苏</code>的处女作是小红帽，也是她第二得意的作品，根据一些信息，小红帽的灵魂可能以现实世界的一个女学生为素材，在魔改剧情的同时，她还给了小红帽注定20岁早逝的设定，并可能赋予了小红帽通过镜子穿梭位面之类的特殊能力来担任女主角，但不知道为什么她又不满意，想做一个男主角出来，但她对小红帽的善后却颇有些问题，小红帽不仅杀穿了红森，而且还能意识到她这个黑幕的存在。 3缝合了众多童话作家灵魂的格林诞生了，并被赋予了给周围的女主角带来不幸的设定，格林污秽的黑之魂有成为支配者的潜质，<code>玛丽苏</code>甚至还大胆地保留了他的部分创作能力，因为最关键的改变权能在她手上，为什么叫做格林则未知，可能是最初的童话书就是格林童话的一本，这之后格林不知道为什么，以什么身份在一个叫不思议之国的地方和叫爱丽丝和祈祷主的存在开起了茶会，随后格林与爱丽丝01相恋，嫉妒的祈祷主呼唤了<code>玛丽苏</code>，导致格林被带走了，连同格林不知何时创造出的故事们也被篡改 4基于以上提到的各种童话故事素材，<code>玛丽苏</code>魔改出了失落帝国的箱庭，把格林放进去经历一次次绝望故事的轮回，自己则担任女主角欣赏故事，还设计把母亲叫了进来欣赏自己的大作。不知多少次循环后，这个大好局面被打破了，母亲黑山羊为了逃离这个世界和她战斗，连圣森都磨灭了，战胜母亲后，奈亚丽丝前来捡漏带走格林进行新一轮追寻爱的游戏，本来想顺带着把<code>玛丽苏</code>也灭了，但在诺登的劝阻以及可能的其他考量下放过了她 5奈亚，红女王，白女王中的某位或若干位剥夺了她的改变权能，把她囚禁在库因兰德，失去权能的她改名为玛丽安，但不知何时也不知何人前来探访了她，到格林试图从梦中醒来的里线，玛丽安乘乱逃出，由于正史上不太可能发生f结局，所以此时应该是g结局，也有可能正史上g结局有少许与游戏不同，不管怎么说此时的玛丽安应该被格林小红帽两人打败，但h结局中可以看到她没有死，而且不知道怎么逃了出来 可以说，bs中的一切悲剧，<code>玛丽苏</code>至少有五成功劳，接下来让我们来分析一下<code>玛丽苏</code>的角色特质。 首先，最直接的一点，<code>玛丽苏</code>是个典型的支配者，高高在上地支配着人类这样的低等种族，但<code>玛丽苏</code>特殊之处在于，她可能是最能理解人类感情的支配者之一，首先我们就可以看到她居然渴望所谓的母爱，而根据2代大部分支配者的表现，即使因融入皮套逐渐有了感情，也没有第二个有亲情这种非常类似人类感情的支配者，此外，她还以玩弄人类的灵魂为乐，当然有这种兴趣的支配者恐怕不少，但这股风气可以说是<code>玛丽苏</code>带起来的，也是她最先玩出各种花样。 因此可以引出<code>玛丽苏</code>的第二个特点了，她是很像人类的一个支配者，尽管理解非常片面，但她确实懂得并拥有不少人性，而她为什么这么喜欢玩弄人类呢？这也很容易理解，一般来说越通人性的动物越被人类亲近，逗猫逗狗远远比逗蚂蚁有意思，因为这些宠物的智力和人类更接近，人类可以很容易地理解它们在想什么，然后在逗弄它们的过程中获得一种智力上的优越感，以及一种“支配感”，这恐怕就是<code>玛丽苏</code>看到自己编排的好戏上演的感觉。 这点可以说是我们对<code>玛丽苏</code>进行解析的基石，毕竟任何角色首先都是人的投影，而人性越丰富，就有越多的性格侧面。 <code>玛丽苏</code>第三个特点就是由此衍生的纯粹性，当然，此处并不是说纯洁善良云云，而是某种意义上的纯粹之恶，很多支配者在扮演人类后都会被皮套影响而恐慌或纠结，但<code>玛丽苏</code>却没有这种烦恼，她以融入人类扮演人类为乐（小精灵也算类人种族），她作为支配者的漆黑本性和人性之恶完美地兼容了，不会有徘徊二者之间的身份认同问题，而她大部分所作所为也就是为了践行人性之恶，什么是恶呢，比较狭隘的解释就是为了为了自己的利益或者取乐而伤害他人，而<code>玛丽苏</code>的邪恶就很纯粹，就是为了取乐，甚至有损自己利益也要作恶，如果解救了被囚禁的<code>玛丽苏</code>，此时她会自认为东山再起，但她想的不是第一时间抹杀已经成长了的格林或者藏起来，而是想再让格林经历一次悲惨的故事，可以说她作恶的动机相当纯粹，也相当执着。 在此之上的第四个特点，就是她的创作者身份，很多支配者都会赞扬她的创作能力，连奈亚构建的不思议之国都有不少<code>玛丽苏</code>箱庭的影子，但这种创造力也只是对于支配者来说了，如果我们用人类的视角看如何呢？寿司在访谈时轻蔑地说到“她说到底也只是<code>玛丽苏</code>，也只能整点二次创作了”可以说道出了<code>玛丽苏</code>所谓创作的本质，说到底，<code>玛丽苏</code>就是那种典型的黑深残小鬼，把一个可能有很多种解释的作品曲解为单一的猎奇世界观，当然不是说这样不行，如果原创一个黑深残世界观自娱自乐当然是可以接受的，但<code>玛丽苏</code>的行为就是最恶劣的一种同人女行为，魔改原来的作品，把自己做成角色代入进去搞cp，还要把所有其他角色踩一遍，情节和人物关系只要对自己代入的角色有利就行，然后把这部除了自己看谁也不会喜欢的同人拿给原作者看，我就不详细说这种行为的恶劣程度了，但这种作品折射出来的创作观我必须要辩驳一下。 当然，本视频所有讨论只局限于二次元文化内， 荒木飞吕彦认为漫画有四要素，角色、剧情、世界观、主题，我们就用这四个维度来剖析<code>玛丽苏</code>的所谓创作。 首先是角色，直接创作一个鲜活的灵魂对强大的支配者来说也是一件难事，所以对于角色的选取，<code>玛丽苏</code>很可能都是使用现实存在的灵魂然后再魔改来适配进童话或者传说的人物，因此她笔下所谓角色虽然很多但其实并不是她自己的功劳，而她为了把这些灵魂塞进角色对设定随意删改，把小红帽的外婆和母亲缝成了一笔烂账，人物关系更是一团乱麻，怎么方便怎么来，角色设定连基本的自洽也做不到，水平着实不敢恭维 随后是世界观，失落帝国这个箱庭本质上来说就是个童话故事的缝合体，没有历史演化，没有详细设定，这并不是一个鲜活的世界观，只不过是一个临时搭建的舞台而已，当然，很多线性的故事并不需要一个多详尽的世界观，在这点上<code>玛丽苏</code>只能说无功无过 最后是剧情和主题，<code>玛丽苏</code>的主题是简单粗暴的黑深残，剧情则是当常规的rpg剧本演到最后的happy end时毫无铺垫伏笔地急转直下变成bad end，当然，能设置这么大规模的箱庭，还写了不少支线剧情，证明<code>玛丽苏</code>确实是有一些笔力的，但首先，她的角色基本靠抓人，故事则都有童话原型，故事演变她只需要把握大方向，其他可以让角色自己来，而最后没有任何铺垫的bad end依旧表明了她创作的失败，如果一个设定没有任何铺垫和暗示，直到使用时才抛出，那只能证明这部作品情节编排的失败，因为一部作品的生命周期不是作者创作出来就结束了的，而要等到读者看完理解了故事才会结束，这个过程作者读者应该处于相对公平的地位，根据故事的设定，人物有充分的理由这样行动，这样才能让读者认同这个故事，而<code>玛丽苏</code>却完全相反，滥用作者的权能让故事不仅没有逻辑，还自相矛盾，很明显，对<code>玛丽苏</code>来说她是作者也自认为是唯一的读者，那些被抓走被改造的灵魂不过是用完即扔的工具罢了，不需要自圆其说，只要自己看得高兴就行了，或许就支配者的立场来说她不过是自娱自乐罢了，但对人类（至少灵魂上是人类），以及同样作为创作者的格林来说，首先就绝不可能认同这种恶行，更不可能认同自己的作品被改成这样的烂作 说到这里，就可以讨论一下<code>玛丽苏</code>对于格林的看法了，直观地说，是<code>玛丽苏</code>创造了名为格林的污秽黑之魂，但其实在最初，是格林等童话作家激发了<code>玛丽苏</code>的创作欲，因此，事实上，两者是相互创造的关系，<code>玛丽苏</code>创造格林的目的，首先是为了成为她作品的男主角，让她能够代入女主角的位置欣赏这个故事，这样说来似乎格林除了男主角的身份和其他角色也没什么本质的不同。但格林还有一点对<code>玛丽苏</code>有着重大意义，就是他童话作家灵魂集合体的身份，即使自我中心如<code>玛丽苏</code>这种存在，也会有对别人欣赏自己作品的渴望，因此<code>玛丽苏</code>特地设置了一个c结局，用演戏的形式让格林得以了解她的整个创作生涯，至于目的，除了单纯的表现欲和欣赏格林的痛苦以外，恐怕也有一丝希望作为原作者的格林认同自己的心情，哪怕是厌恶，<code>玛丽苏</code>也想得到一些对创作的反馈，而格林是唯一能在创作这个领域和她有一些共鸣的人，作者，读者，男主角，格林三位一体的身份对<code>玛丽苏</code>来说，可以说是难得的知己，尽管这种关系非常扭曲，但不能否认，在这点上<code>玛丽苏</code>作为创作者的心情是有些真心的。而<code>玛丽苏</code>会渴望认同这点，一开始是希望得到母爱，但在得到格林这个玩具之后，<code>玛丽苏</code>就一点也不在意黑山羊的死活了，这也是佐证。 最后不得不提的是，<code>玛丽苏</code>的特殊性质，很大程度上她是寿司这个作者的投影，我个人觉得<code>玛丽苏</code>这个角色有不少表达寿司自己创作观的成分，这也解释了寿司为何这么偏爱她当然，一部好的作品，任何角色都是基于自己的设定和世界观行动，不可能因为是作者的投影就有特别待遇，所以可以说，<code>玛丽苏</code>虽然很大程度上是寿司的投影，但投影的目的其实是对比，<code>玛丽苏</code>的创作肤浅，笔下的故事只是无聊的黑深残，但寿司却喜欢在绝望时写一些希望，在希望中铺设绝望，最后的反转再怎么说都是有因可循，单论创作的层次来说就高出绿虫子太多了，当然，我也不是在吹寿司笔力多高，因为高出<code>玛丽苏</code>这个水平的创作者多如牛毛。 寿司设置<code>玛丽苏</code>这个角色，其实是使用了一种嵌套的结构来讲故事，首层是童话的原作，这些是毋庸置疑的好故事，随后是虫子和奈亚魔改出的箱庭，是烂故事的典型，最后一层寿司想讲的重点其实是格林怎么察觉真相，挣脱出烂故事的循环，书写自己的结局的故事，在这三层中，第一层<code>玛丽苏</code>是读者，格林等人是作者，只出现在设定层面，第二层<code>玛丽苏</code>是一半作者一半角色，格林是一半读者一半角色，体现在abc结局，最后一层中寿司是唯一的作者，<code>玛丽苏</code>和格林就都是角色了，体现在d结局以及之后的二代，这种层层演变虽然有些炫技，但确实非常有意思。 就<code>玛丽苏</code>这个角色而言，整个泛二次元文化里她这样的反派也不常见，究其原因，则是因为一个有能力玩弄主角取乐的boss必然会导致战力失衡，冲突不起来，让读者感到憋屈，因此想要打败这种boss要么机械降神唯心爆发，比如一代c结局（虽然是演的），要么引入新的boss和同伴体系取代她如d结局，也因此，虽然我个人很喜欢一代，但一代的真结局d结局远没有2代h结局震撼 来做个总结吧，<code>玛丽苏</code>无疑是个纯粹邪恶的支配者，一个烂到骨子里的创作者，她作为创作者无疑是失败的，但作为bs这个故事里的角色反而是很成功的，不仅纯粹有特点，还有很多角色侧面可以挖掘，寿司巧妙地利用她读者，创作者和角色的三重身份来塑造她的多面性，颇有荒木在漫画术中写的“在作恶道路上高歌猛进”的成功反派角色风格。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>基于c++ primer plus的读书笔记</title>
    <url>/2023/10/05/cpp%20primer%20plus%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="c语言部分">c语言部分</h1>
<h2 id="基本函数构成">基本函数构成</h2>
<p>将数组传递为函数参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fcname(int arg[],int n)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="基本输入输出">基本输入输出</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- cin及其衍生函数返回一个iostream函数的引用，即支持</span><br><span class="line">cin,get().get()</span><br><span class="line">iostream的其他成员</span><br><span class="line">- cout.put()显示字符</span><br><span class="line">- cout.write()显示字符串</span><br><span class="line">- cout&lt;&lt;flush刷新缓冲区</span><br><span class="line">- cout&lt;&lt;endl刷新缓冲区并提供换行符</span><br><span class="line">- dec,hex,oct控制输出数制</span><br><span class="line">hex(cout)控制cout为16进制</span><br><span class="line">- int width()返回字段宽度当前设置</span><br><span class="line"> int width(int i)设置字段宽度，返回以前字段宽度 </span><br><span class="line"> 只影响下一次输出</span><br><span class="line"> - fill()设置填充用字符</span><br><span class="line"> - precision()设置精度，即保留几位小数</span><br><span class="line"> - setf()设置各种输出格式</span><br><span class="line"> - 流状态stream_state(eof,fail,bad)</span><br><span class="line"> - cin.get(ch)读取下一个字符，跳过换行符和空白</span><br><span class="line"> - cin.get()读取空白和换行符</span><br><span class="line"> - cin.get()get的基础上读取到换行符并丢弃</span><br><span class="line"> - cin.read()读取内容，但不会在末尾加空字符</span><br><span class="line"> - cin.peek()读取输入流下一个字符但不抽取</span><br><span class="line"> - cin.putback(ch)把一个字符放到输入流最前</span><br></pre></td></tr></table></figure>
<h3 id="文件输入输出">文件输入输出</h3>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写入文件</span><br><span class="line">ofstream fout;//ofstream继承ostream</span><br><span class="line">fout.open(&quot;hello.txt&quot;);</span><br><span class="line">fout &lt;&lt; &quot;i&#x27;m adding sth&quot;</span><br><span class="line">|| ofstream fout(&quot;hello.txt&quot;);</span><br><span class="line">读取文件也类似</span><br><span class="line">fin &gt;&gt; ch||string</span><br><span class="line">关闭流</span><br><span class="line">fout.close()</span><br><span class="line">fin.close()</span><br><span class="line">检测文件是否打开</span><br><span class="line">if (!fin.is_open())</span><br><span class="line">设置文件输入输出格式</span><br><span class="line">ios_base::</span><br></pre></td></tr></table></figure></p>
<h2 id="基本逻辑运算符">基本逻辑运算符</h2>
<p>break打断循环 continue，跳到更新表达式前开始执行 非const引用的函数不接受const参数</p>
<h2 id="基本数据类型">基本数据类型</h2>
<p>结构数组</p>
<figure class="highlight plaintext"><figcaption><span>stname;</span></figcaption><table><tr><td class="code"><pre><span class="line">stname stobj\[int x] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">union(类似结构，但相同数据类型只存一种)</span><br><span class="line">每个指针需要一个*用于初始化</span><br><span class="line">int * intlist=new int [10]</span><br><span class="line">delete-new</span><br><span class="line">delete []-new []</span><br><span class="line">typedef typename aliasname</span><br></pre></td></tr></table></figure>
<h2 id="名称空间">名称空间</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef HNAME_H</span><br><span class="line">#define HNAME_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>如果在遇到另一个定义HNAME_H的头文件时，将他忽略</p>
<p>作用域： 1默认情况下，函数中声明的变量作用域位于代码块内，如果函数内外都声明一个同名变量，运行至内部代码块使用内部，离开代码块使用外部 2静态变量存在于整个程序运行周期，脱离作用域后只是无法使用并不消失 代码块外声明且不带static关键字：链接性外部，可以在其他程序使用 代码块外声明，且使用static：链接性内部，可以在整个程序使用 代码块内声明，且使用static：作用域于代码块内，但始终存在//由于静态变量只可以定义一次，所以即使离开代码块后变量依旧存在，且值不变，直到下一次修改 3运算符::放置于变量前时，使用同名变量（如果有）的全局版本 4namespace{</p>
<p>} 无法放置于代码块内，因此默认为全局名称，可以囊括声明和定义，可以随时添加 定义于类声明的函数自动成为内联函数</p>
<h1 id="c特性">c++特性</h1>
<h2 id="class">class</h2>
<p>1声明构造函数时，尽量使用explicit(显性转换)前缀，防止隐性转换带来的问题 mutable(摆动的)前缀声明变量，表示这些变量可能在const成员函数内被更改 用const_cast&lt;&gt;和static_cast&lt;&gt;与this指针可以实现const成员函数向非const的转变，反之则是错误的</p>
<p>2class初始化成员时，按构造函数声明变量的顺序，因此初始化成员时最好也以此顺序初始化 如果不希望class有copy和赋值(=)操作，则应该在private里定义copy和=运算符</p>
<p>3基类引用可以指向派生类对象，无需进行强制类型转换</p>
<p>4定义于类声明的函数自动成为内联函数</p>
<p>5类的函数对所有对象共用，但数据则各自私有</p>
<p>6要创造类对象数组，该类必须有默认构造函数</p>
<p>7只有一个构造函数参数的构造函数可以用于类的自动转换 classname t; t=20; 如果想禁止这种转换，可以声明explicit给构造函数</p>
<p>8类声明中可定义对于某种基本类型的转换函数 operator int();//可声明为显式转换，尽量避免过多的转换造成二义性</p>
<p>9如果定义类成员参数为static，则它在程序中只有一个地址，可以被所有类成员共享 但通过static实现共享成员时，需要重新定义复制和赋值函数来避免问题</p>
<h3 id="动态类的注意事项">动态类的注意事项</h3>
<p>*构造函数中如果用new初始化指针成员，则应该在析构函数中使用delete new对应delete,new[]对应delete[] 对多个构造函数，应用和析构函数兼容的new来初始化成员 重构复制和赋值运算符来实现深复制</p>
<p>10对于使用new创建的类，使用delete时其析构函数才会被调用 如果在使用new时，将对象地址赋予一个指针时，如果删除指针，则对应的对象会调用自己的析构函数 对与使用定位new创建的类对象，需要显式调用析构函数 object-&gt;~classname(); 且应该以创建顺序的相反顺序调用，因为后创建的对象可能依赖于前者</p>
<h3 id="类继承">类继承</h3>
<h4 id="公有继承">公有继承</h4>
<p>class sonclassname: public fatherclassname 派生类继承了基类的公有接口和数据 但只能用基类public和protected函数访问基类私有数据 派生类可添加函数和数据成员 派生类需要自己的构造函数，并由于权限问题，其构造函数必须包括基类构造函数，并且同样可以使用成员初始化列表 <code>指针</code> 基类指针和引用可以在不显式转化的情况下指向派生类对象反过来却不行 <code>虚函数</code></p>
<ul>
<li>对于基类和派生类的同名函数： 如果函数通过引用或指针调用，将确定使用哪种方法 ￥如果没有使用关键字virual，将根据引用类型或指针类型选择方法。 如果使用了关键字virtual，将根据引用或指针指向对象的类型选择方法</li>
<li>构造函数不能为虚函数</li>
<li>析构函数应当为虚函数</li>
<li>友元函数并非类成员，但可以使用虚函数</li>
<li>**重新定义继承方式（虚实）并非重载，会覆盖掉原先的虚函数定义，如果必须重新定义，则需要重新定义使用基类虚函数</li>
</ul>
<p><code>纯虚函数</code> virual typename func() const=0; 含有虚函数的类不能创建实例，只能用作基类</p>
<p><code>访问控制（protected）</code> 派生类成员函数可以访问protected成员，不能访问private成员</p>
<h4 id="私有继承">私有继承</h4>
<p>使用私有继承，基类的公有成员和保护成员都成为派生类的私有成员，只可以在派生类的成员函数中使用，可以实现has_a关系 私有继承访问基类方法时需要调动基类的命名空间 <code>访问基类对象</code> 如果要直接访问基类对象，则需要调用强制类型转化将派生类转化为基类</p>
<h4 id="保护继承">保护继承</h4>
<p>保护继承时，基类的公有和保护成员都成为派生类的保护成员，基类接口在派生类中可用</p>
<p>通过using指令可以让私有函数被当前作用域可用</p>
<h2 id="命令行参数">命令行参数</h2>
<p>int main(int argc,char* argv[]) argc为参数个数 argv为参数组成的字符串</p>
<h2 id="字符输入">字符输入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; ***(读取输入中的结束字符为结束标志，会将换行符留在输入流)</span><br><span class="line">getline(stringname,length)通过换行符确定输入结束点</span><br><span class="line">cin.get()读取到换行符之前，不带参数则读取下一个字符(用于清除换行符)</span><br><span class="line">cin.clear()清空输入流</span><br><span class="line">&lt;string&gt;</span><br><span class="line">重载符号+实现拼接</span><br><span class="line">str.size()</span><br><span class="line">输入字符串使用getline(cin,str)</span><br><span class="line">结构数组</span><br><span class="line">struct stname;</span><br><span class="line">stname stobj[int x] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">字符函数库&lt;cctype&gt;</span><br><span class="line">isspace(ch)测试是否空白</span><br><span class="line">isalpha(ch)是否字符</span><br><span class="line">isdigit()是否数字</span><br><span class="line">ispunct()是否标点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; ***(读取输入中的结束字符为结束标志，会将换行符留在输入流)</span><br><span class="line">getline(stringname,length)通过换行符确定输入结束点</span><br><span class="line">cin.get()读取到换行符之前，不带参数则读取下一个字符(用于清除换行符)</span><br><span class="line">cin.clear()清空输入流</span><br></pre></td></tr></table></figure>
<p>&lt;string&gt; 重载符号+实现拼接 str.size() 输入字符串使用getline(cin,str) 结构数组 struct stname; stname stobj[int x] = { {} {} } 字符函数库&lt;cctype&gt; isspace(ch)测试是否空白 isalpha(ch)是否字符 isdigit()是否数字 ispunct()是否标点</p>
<h2 id="指针">指针</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，c++没有溢出检测机制，</span><br><span class="line">char name[]=&quot;hello&quot;;</span><br><span class="line">char c =name[10]导致未定义行为</span><br><span class="line">2，用一个常量指针指向常量需要两次const</span><br><span class="line">const char* const name=&quot;hhh&quot;</span><br><span class="line">如果需要一个class专属常量，则使用</span><br><span class="line">static const ***</span><br><span class="line">实现文件中，const int classname:: ***</span><br><span class="line">对于宏：</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline functionname</span><br><span class="line">3,const 出现在*左侧表示被指物为常量，右侧表示指针为常量指针</span><br><span class="line">4,函数名就是函数的地址</span><br><span class="line">double pam(int);</span><br><span class="line">double(*pt)(int);</span><br><span class="line">pt即为函数指针</span><br><span class="line">如果需要一个函数以相同相同返回值和参数的函数为一个参数，则可以考虑函数指针</span><br><span class="line">5，内联函数不能递归</span><br><span class="line">6,引用容器时，如果迭代器不引用，仍然传递临时副本o</span><br><span class="line">7,函数传递指针时按值传递，当向函数传递指针时，指针是按值传递的！这意味着你可以改变被指向的数组内容，因为在调用函数时，这些元素不会被复制！这意味着你可以改变被指向的数组的内容，因为这些元素在函数被调用时并没有被复制。另一方面，如果你改变了所指向的数组，这种改变在函数之外不会持续，因为你只改变了指针的拷贝，而不是原来的指针本身。</span><br></pre></td></tr></table></figure>
<h3 id="智能指针">智能指针</h3>
<p>auto_ptr&lt;string&gt; 和&lt;unique_ptr&gt;指针采用所有权模型，对特定对象只有一个智能指针可以拥有它，只有拥有它的指针可以删除它 shared_ptr&lt;string&gt;追踪引用对象的智能指针数量，最后一个指针过期时才会调用delete 使用new分配内存才能使用auto_ptr,unique_ptr</p>
<h2 id="异常">异常</h2>
<h3 id="try_catch">try_catch</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"> func();</span><br><span class="line">&#125;</span><br><span class="line">catch(errortype e1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line">&#123;</span><br><span class="line"> do sth;</span><br><span class="line"> throw(error_type e1);8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>栈解退</code> 假设try块没有直接调用引发异常的函数，而是调用对引发异常的函数进行调用的函数，则程序从引发异常的函数跳到包含try块和处理程序的函数（追踪到一个地址位于try块的返回地址） <code>其他异常特性</code></p>
<ul>
<li>throw-catch类似函数参数和返回，但函数返回语句将控制器交给调用函数的函数，但throw语句将控制权向上返回到第一个这样的函数，包含能捕获相应异常的try-catch组合</li>
<li>throw语句总是生成副本，但catch参数使用基类引用能捕获所有派生类的异常对象</li>
</ul>
<h4 id="exception类">exception类</h4>
<p>exception类可作为其他异常类的基类，用what的虚函数（返回一个字符串）重载来指示错误类型 <code>失败时返回空指针的语法</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * pi= new (std::nothrow) int;</span><br></pre></td></tr></table></figure>
<h3 id="未捕获异常">未捕获异常</h3>
<p>未捕获的异常会使程序调用函数terminate(),默认情况下，terminate()调用abort()函数，可以指定terminate()调用的函数来修改其行为</p>
<h2 id="一些新特性">一些新特性</h2>
<h3 id="关键字">关键字</h3>
<p>关键字nullptr表示空指针</p>
<h3 id="rtti运行阶段类型识别">RTTI(运行阶段类型识别)</h3>
<h4 id="dynamiccast">dynamic——cast</h4>
<p>danamic_cast&lt;type *&gt; (pt) 如果可以安全将pt转化为type*指针，返回对象地址，否则返回空指针 如果对引用使用，错误时返回bad_cast异常</p>
<h4 id="typeid和type_info">typeid和type_info</h4>
<p>typeid返回对type_info对象的引用，type_ifo是定义在typeinfo的类，重载==和!=预算符，例如 typeid(obj1)==typeid(obj2)</p>
<h3 id="类型转换运算符">类型转换运算符</h3>
<ul>
<li>dynamic_cast</li>
<li>const_cast</li>
<li>static_cast</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用于执行各种类型的数值转换static_cast &lt;typename&gt; (expression)</span><br><span class="line">//转换是允许隐式转换时才能通过（派生类和基类可以互相转换）</span><br></pre></td></tr></table></figure>
<ul>
<li>reinterpret_cast /执行危险的转换</li>
</ul>
<p>移动语义 通过指针转移右值的地址给新对象 或通过std::move()将左值转化为右值</p>
<p>someclass()=default default关键字显式声明编译器创建默认构造函数，复制构造函数 delete用于禁止类中的函数</p>
<p>关键字override可用于覆盖虚函数定义</p>
<h3 id="匿名函数">匿名函数</h3>
<p>返回类型编译器自动确定，可直接作为函数指针使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[] (double x) &#123;return x%3==0;&#125; </span><br></pre></td></tr></table></figure>
<p>可以返回类型后置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[] (double x)-&gt; double&#123;int y = x;return y-x;&#125;</span><br></pre></td></tr></table></figure>
<p>可以给匿名函数命名</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于斯坦福cs106b的c++数据结构笔记</title>
    <url>/2023/09/29/cs106b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一些查找和排序算法">一些查找和排序算法</h2>
<p>二分查找法 <img src="/images/obsidian/20230226101843.png" title="image" alt="图片" /> 最坏情况：log2n <span id="more"></span> 寻找最小排序 <img src="/images/obsidian/20230224172126.png" title="image" alt="图片" /> 向前插入算法 <img src="/images/obsidian/20230226090109.png" title="image" alt="图片" /></p>
<p>合并算法接受两个排序的 列出并将它们组合成一个 排序列表。 ● 虽然两个列表都是非空的，但比较它们的 第一要素。 删除较小的元素 并将其附加到输出。 ● 一旦一个列表为空，添加所有元素 另一个列表输出。 ● 它运行时间为 O(n)，其中 n 是总数 合并的元素数量。 <img src="/images/obsidian/20230226090958.png" title="image" alt="图片" /> 无限递归后的合并算法 <img src="/images/obsidian/20230226093232.png" title="image" alt="图片" /> 复杂度：nlog2n</p>
<h2 id="容器类">容器类</h2>
<p><code>set（集合）：无序不允许重复的容器类，可以添加删除元素 You can add a value to a Set by writing   set += value;  s. ● You can remove a value from a Set by writing   set -= value;   ● You can check if a value exists in a Set by writing   set.contains(value)</code>map(键值对的集合) 如果没有对应key的value，返回默认值（见定义文件） `vector vector的remove根据移除元素的索引有1-n的复杂度，移除尾部为O(1)，如果不在意索引，可以交换要移除元素和尾部元素再移除</p>
<h1 id="哈希表">哈希表</h1>
<p>哈希表的负载因子α表示元素和表格键数量的比，决定了查找速度</p>
<h2 id="检查表中是否存在元素">检查表中是否存在元素</h2>
<p>● 计算元素的散列码。 ● 跳转到表格中的那个位置。 ● 向前扫描——必要时环绕——直到项目或一个 发现空插槽。</p>
<h2 id="将元素插入表中">将元素插入表中</h2>
<p>● 如果项目已经存在，什么也不做。 ● 否则，跳转到元素哈希码给定的槽。 向前走——必要时环绕——直到一个空白点或 找到墓碑插槽。 然后，将项目放在那里。</p>
<h2 id="从表中删除一个元素">从表中删除一个元素</h2>
<p>● 跳转到由元素的散列码给定的槽。 ● 向前走——必要时环绕——直到物品或 发现空插槽。 如果找到该项目，请将其替换为 墓碑。</p>
<h2 id="罗宾汉哈希表">“罗宾汉哈希表”</h2>
<ul>
<li>如果插入的值比其将插入的位置的值距离索引更远，则替换插入值和当前值</li>
<li>删除值时，将后其离原键远的元素前移</li>
<li>★ 罗宾汉哈希一览 ★</li>
<li>检查表中是否存在元素：</li>
<li>● 跳转到表中由元素的散列码给出的位置。</li>
<li>● 向前扫描——如有必要环绕——记录有多少步 你拿走了。 当您找到该项目、找到一个空白槽或找到一个 离家更近的空位比你走的步数还多。</li>
<li>将元素插入表中：</li>
<li>● 如果该元素已在表中，则什么也不做。</li>
<li>● 跳转到由元素的散列码给出的表槽。 向前扫描 - 换行 如有必要，四处走走——记录所走的步数。 如果你找到一个 空插槽，将元素放在那里。 否则，如果当前插槽已满并且 比您插入的元素更靠近家，将要插入的项目放在那里， 替换那个位置的元素，然后继续插入，就好像你 正在插入被置换的元素。</li>
<li>从表中删除一个元素：</li>
<li>● 跳转到由元素的散列码给定的槽。</li>
<li>● 向前走——如有必要，环绕——直到物品或空槽被放置 成立。 如果找到该项目，请将其删除。 然后，继续前进——包裹 around as necessary – 将表中的元素向后移动一个槽位，直到 找到空插槽或位于其原始位置的项目</li>
</ul>
<h2 id="string类">string类</h2>
<p>str::npos表示容器的最后一个成员位置 if (s.find("e") != string::npos) //find函数找不到时返回npos if s in str: string obj; obj.substr(int pos) //pos为要包含的第一个字符串的位置 <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> a = "0123456789abcdefghij";</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    // count is npos, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub1 = a.substr(10);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub1 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // both pos and pos+count are within bounds, returns [pos, pos+count)</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub2 = a.substr(5, 3);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub2 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // pos is within bounds, pos+count is not, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub4 = a.substr(a.size()-3, 50);</span><br><span class="line">    // this is effectively equivalent to</span><br><span class="line">    // std::string sub4 = a.substr(17, 3);</span><br><span class="line">    // since a.size() == 20, pos == a.size()-3 == 17, and a.size()-pos == 3</span><br><span class="line"></span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub4 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // pos is out of bounds, throws</span><br><span class="line">        [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub5 = a.substr(a.size()+3, 50);</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub5 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125; catch(const [std::out_of_range](http://en.cppreference.com/w/cpp/error/out_of_range)&amp; e) &#123;</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; &quot;pos exceeds string size\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">abcdefghij</span><br><span class="line">567</span><br><span class="line">hij</span><br><span class="line">pos exceeds string size</span><br></pre></td></tr></table></figure>
<p>`replace和insert str1.insert(start, str2) str1.replace(start, length, str2)</p>
<h2 id="一些实现">一些实现</h2>
<h3 id="优先队列">优先队列</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &quot;HeapPQueue.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">HeapPQueue::HeapPQueue() &#123;</span><br><span class="line">    elems = new DataPoint[INITIAL_SIZE] &#123;&#125;;</span><br><span class="line">    for (int i=0;i&lt;INITIAL_SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[i].weight=0;</span><br><span class="line">    &#125;</span><br><span class="line">    allocatedSize=INITIAL_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapPQueue::~HeapPQueue() &#123;</span><br><span class="line">    delete [] elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int HeapPQueue::size() const &#123;</span><br><span class="line">    return logicalSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool HeapPQueue::isEmpty() const &#123;</span><br><span class="line">    return logicalSize==0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapPQueue::enqueue(const DataPoint&amp; data) &#123;</span><br><span class="line">    if (logicalSize+1&lt;allocatedSize)</span><br><span class="line">    &#123;</span><br><span class="line">        if (logicalSize==0)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[1]=data;</span><br><span class="line">            logicalSize++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            logicalSize++;</span><br><span class="line">            int i=1;</span><br><span class="line">            while (data.weight&gt;elems[i].weight &amp;&amp; i&lt;=logicalSize &amp;&amp; elems[i].weight!=0)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i&lt;logicalSize)</span><br><span class="line">            &#123;</span><br><span class="line">                DataPoint temp=elems[i];</span><br><span class="line">                elems[i]=data;</span><br><span class="line">                for(i;i&lt;logicalSize;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    DataPoint temp_plus=elems[i+1];</span><br><span class="line">                    elems[i+1]=temp;</span><br><span class="line">                    temp=temp_plus;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                elems[i]=data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::peek() const &#123;</span><br><span class="line">    return elems[logicalSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::dequeue() &#123;</span><br><span class="line">    DataPoint to_return=elems[1];</span><br><span class="line">    if(!isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (int i=1;i&lt;logicalSize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[i]=elems[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        elems[logicalSize]=&#123;&#125;;</span><br><span class="line">        logicalSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    return to_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计数排序">计数排序</h3>
<p>首先算出最大值，然后用一个数组的索引存储待排序数组的成员，其索引对应值存储出现次数，然后用两个同步的for循环和递增的next参数表示排序中的索引值来进行排序（也就是重新赋值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Given a Vector&lt;int&gt;, returns the largest number in that Vector. */</span><br><span class="line">int maxOf(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Bounds-check inputs. */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        error(&quot;Can&#x27;t find the maximum of no values.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = values[0];</span><br><span class="line">    for (int i = 1; i &lt; values.size(); i++) &#123;</span><br><span class="line">        result = max(result, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a list of numbers, creates a histogram from those numbers. */</span><br><span class="line">Vector&lt;int&gt; histogramFor(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Create a histogram with the right number of slots. Initially, all values</span><br><span class="line">     * in the histogram will be zero.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; histogram(maxOf(values) + 1);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the input vector, incrementing the histogram values. */</span><br><span class="line">    for (int value: values) &#123;</span><br><span class="line">        histogram[value]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return histogram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void countingSort(Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Edge Case: If the array is empty, then it&#x27;s already sorted. This is</span><br><span class="line">     * needed because we can&#x27;t take the maximum value of an empty vector.</span><br><span class="line">     */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Form the histogram. */</span><br><span class="line">    auto histogram = histogramFor(values);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the histogram writing out the appropriate number of copies</span><br><span class="line">     * of each value. We track the index of the next free spot to write to,</span><br><span class="line">     * as it varies based on how many items we&#x27;ve written out so far.</span><br><span class="line">     */</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (int value = 0; value &lt; histogram.size(); value++) &#123;</span><br><span class="line">        /* Write out the right number of copies. */</span><br><span class="line">        for (int copy = 0; copy &lt; histogram[value]; copy++) &#123;</span><br><span class="line">            values[next] = value;</span><br><span class="line">            next++;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="错题集">错题集</h2>
<h3 id="递归的效率优化">递归的效率优化</h3>
<p>每次递归都会创造所有变量的临时复制 基于递归的这种性质，它会需要巨大的时间和空间来完成任务，并且会造成算力上的浪费。 通过记忆表机制能部分解决这个问题，方法是每次递归的返回值都会按索引存入一个表格，并且每次递归前查询表格中是否有结果，这样可以让每个临时副本的运算结果能被所有函数共享。</p>
<h3 id="递归计算给定元素的不同结构哈夫曼树的数量">递归计算给定元素的不同结构哈夫曼树的数量</h3>
<p>对每个给定元素集来说，首先要做到是确定根节点元素是第几个大的元素，确定之后，左子树和右子树的元素数也随之确定，在此之后分别对左节点和右节点作为根节点做同样的递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int numBSTsOfSize(int n) &#123;</span><br><span class="line"></span><br><span class="line">  /* Base case: There’s only one tree of size 0, namely, the empty BST. */</span><br><span class="line">  if (n == 0) return 1;</span><br><span class="line">  </span><br><span class="line">  /* Recursive case: Imagine all possible ways to choose a root and build the</span><br><span class="line">   * left and right subtrees.</span><br><span class="line">  */</span><br><span class="line">  int result = 0;</span><br><span class="line">  </span><br><span class="line">  /* Put the the nodes at indices 0, 1, 2, ..., n-1 up at the root. */</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    /* Each combination of a BST of i elements and a BST of n - 1 - i elements</span><br><span class="line">     * can be used to build one BST of n elements. The number of pairs of</span><br><span class="line">     * trees we can make this way is given by the product of the number of</span><br><span class="line">     * trees of each type.</span><br><span class="line">     */</span><br><span class="line">     result += numBSTsOfSize(i) * numBSTsOfSize(n - 1 - i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决吃巧克力问题">递归解决吃巧克力问题</h3>
<h1 id="求出吃法数量">求出吃法数量</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (numSquares&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">    error(&quot;输入数据不能为负数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (numSquares&lt;=1)</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    return numWaysToEat(numSquares-1)+numWaysToEat(numSquares-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打印每种吃法">打印每种吃法</h1>
<p>`需要一个辅助向量储存历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Print all ways to eat numSquares more squares, given that we&#x27;ve</span><br><span class="line"> * already taken the bites given in soFar.</span><br><span class="line"> */</span><br><span class="line">void printWaysToEatRec(int numSquares, const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /* Base Case: If there are no squares left, the only option is to use</span><br><span class="line">     * the bites we&#x27;ve taken already in soFar.</span><br><span class="line">     */</span><br><span class="line">    if (numSquares == 0) &#123;</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If there is one square lfet, the only option is to eat</span><br><span class="line">     * that square.</span><br><span class="line">     */</span><br><span class="line">    else if (numSquares == 1) &#123;</span><br><span class="line">        cout &lt;&lt; soFar + 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Otherwise, we take take bites of size one or of size two. */</span><br><span class="line">    else &#123;</span><br><span class="line">        printWaysToEatRec(numSquares - 1, soFar + 1);</span><br><span class="line">        printWaysToEatRec(numSquares - 2, soFar + 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printWaysToEat(int numSquares) &#123;</span><br><span class="line">    if (numSquares &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me some chocolate!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We begin without having made any bites. */</span><br><span class="line">    printWaysToEatRec(numSquares, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决翻煎饼问题">递归解决翻煎饼问题</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isSorted(Stack&lt;double&gt; pancakes) &#123;</span><br><span class="line">    double last = -1; // No pancakes have negative size;</span><br><span class="line"></span><br><span class="line">    while (!pancakes.isEmpty()) &#123;</span><br><span class="line">        /* Check the next pancake. */</span><br><span class="line">        double next = pancakes.pop();</span><br><span class="line">        if (next &lt; last) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Pancakes are in increasing order! */</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a stack of pancakes and a flip size, flips that many pancakes</span><br><span class="line"> * on the top of the stack.</span><br><span class="line"> */</span><br><span class="line">Stack&lt;double&gt; flip(Stack&lt;double&gt; pancakes, int numToFlip) &#123;</span><br><span class="line">    /* Take the top pancakes off the stack and run them into a queue.</span><br><span class="line">     * This preserves the order in which they were removed.</span><br><span class="line">     */</span><br><span class="line">    Queue&lt;double&gt; buffer;</span><br><span class="line">    for (int i = 0; i &lt; numToFlip; i++) &#123;</span><br><span class="line">        buffer.enqueue(pancakes.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Move the pancakes back. */</span><br><span class="line">    while (!buffer.isEmpty()) &#123;</span><br><span class="line">        pancakes.push(buffer.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pancakes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; sortStack(Stack&lt;double&gt; pancakes, int numFlips) &#123;</span><br><span class="line">    /* Base Case: If the stack is sorted, great! We&#x27;re done, and no flips</span><br><span class="line">     * were needed.</span><br><span class="line">     */</span><br><span class="line">    if (isSorted(pancakes)) &#123;</span><br><span class="line">        return &#123; &#125;; // No flips</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If the stack isn&#x27;t sorted and we&#x27;re out of flips, then</span><br><span class="line">     * there is no way to sort things.</span><br><span class="line">     */</span><br><span class="line">    else if (numFlips == 0) &#123;</span><br><span class="line">        return Nothing;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive Case: The stack isn&#x27;t sorted and we still have flips left.</span><br><span class="line">     * The next flip could flip 1, 2, 3, ..., or all N of the pancakes.</span><br><span class="line">     * Try each option and see whether any of them work.</span><br><span class="line">     */</span><br><span class="line">    for (int numToFlip = 1; numToFlip &lt;= pancakes.size(); numToFlip++) &#123;</span><br><span class="line">        /* Make the flip and see if it works. */</span><br><span class="line">        auto result = sortStack(flip(pancakes, numToFlip), numFlips - 1);</span><br><span class="line">        if (result != Nothing) &#123;</span><br><span class="line">            /* The result holds all the remaining flips but doesn&#x27;t know about</span><br><span class="line">             * the flip we just did. Insert that flip at the beginning.</span><br><span class="line">             */</span><br><span class="line">            result.value().insert(0, numToFlip);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we&#x27;re here, then no matter which flip we make first, we cannot</span><br><span class="line">     * get the pancakes sorted. Give up.</span><br><span class="line">     */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决天平问题">递归解决天平问题</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isMeasurableRec(int amount, const Vector&lt;int&gt;&amp; weights, int index) &#123;</span><br><span class="line">  if (index == weights.size()) &#123;</span><br><span class="line">      return amount == 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      return isMeasurableRec(amount,                  weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount + weights[index], weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount - weights[index], weights, index + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMeasurable(int amount, const Vector&lt;int&gt;&amp; weights) &#123;</span><br><span class="line">    return isMeasurableRec(amount, weights, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象一下，我们首先将要测量的数量（称为 <em>n</em> ）放在天平的左侧。 这使得规模上的不平衡等于 <em>n</em> 。 想象一下，有某种方法可以测量 <em>n</em> 。 如果我们一次将一个重量放在秤上，我们可以查看第一个重量的放置位置（假设它的重量为 <em>w</em> ）。 它必须：</p>
<ul>
<li>向左走，使规模上的净不平衡 <em>n + w</em> ，或</li>
<li>向右走，使规模上的净不平衡 <em>n – w</em> ，或</li>
<li>根本不习惯，留下净不平衡 <em>n</em> 。</li>
</ul>
<p>如果确实有可能测量 <em>n</em> ，那么这三个选项之一必须是实现它的方法，即使我们不知道它是哪一个。 然后我们要问的问题是，是否有可能使用剩余的权重来衡量新的净失衡——我们可以递归地确定！ 另一方面，如果无法测量 <em>n</em> ，那么无论我们选择哪个选项，我们都会发现没有办法使用剩余的权重来使一切平衡！</p>
<p>如果我们递归地进行，我们在这里，我们需要考虑我们的基本情况。 我们可以选择的选项有很多。 一个简单的方法如下：假设我们根本没有任何重量，我们被要求查看是否可以不使用重量来测量某些重量。 在什么情况下我们可以这样做？ 好吧，如果我们称重的东西有一个非零重量，我们就不可能测量它——把它放在秤上会使它倾斜到某一边，但这并不能告诉我们它有多少重量。 另一方面，如果我们称量的东西是完全失重的，那么把它放在秤上也不会导致它倾斜，让我们相信它确实是失重的！ 因此，作为我们的基本情况，我们会说当我们减少到没有剩余权重时， <em>，我们可以精确测量n</em> 如果 <em>n = 0</em> 。 考虑到这一点，这是我们的代码：</p>
<h3 id="递归解决找零问题">递归解决找零问题</h3>
<h1 id="不使用记忆的情况">不使用记忆的情况</h1>
<p>`从第一个硬币开始遍历，并穷举它的所有枚数，将其作为下一枚硬币的参数传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    else if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (coins.isEmpty()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins.first();</span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsFor(cents - copies * coin,</span><br><span class="line">                                                     coins - coin);</span><br><span class="line">          /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用记忆进行优化">使用记忆进行优化</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* How few coins are needed to make the total, given that we can only use</span><br><span class="line"> * coins from index startIndex and onward?</span><br><span class="line"> */</span><br><span class="line">int fewestCoinsRec(int cents, const Vector&lt;int&gt;&amp; coins, int startIndex,Grid&lt;int&gt;&amp; memo) &#123;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (startIndex == coins.size()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: We already know the answer. */</span><br><span class="line">    else if (memo[cents][startIndex] != -1) &#123;</span><br><span class="line">        return memo[cents][startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line"></span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins[startIndex];</span><br><span class="line"></span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsRec(cents - copies * coin,</span><br><span class="line">                                                     coins, startIndex + 1,</span><br><span class="line">                                                     memo);</span><br><span class="line"></span><br><span class="line">            /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        memo[cents][startIndex] = bestSoFar;</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Convert from a Set&lt;int&gt; to a Vector&lt;int&gt; so we have a nice ordering</span><br><span class="line">     * on things.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; coinVec;</span><br><span class="line">    for (int coin: coins) &#123;</span><br><span class="line">        coinVec += coin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build our memoization table. Since the number of cents left ranges from</span><br><span class="line">     * 0 to cents, we need cents+1 rows. Since the start index of the coin</span><br><span class="line">     * ranges from 0 to coins.size(), we make coins.size() + 1 columns.</span><br><span class="line">     *</span><br><span class="line">     * -1 is used as a sentinel to indicate &quot;nothing has been computed here</span><br><span class="line">     * yet.&quot;</span><br><span class="line">     */</span><br><span class="line">    Grid&lt;int&gt; memo(cents + 1, coins.size() + 1, -1);</span><br><span class="line"></span><br><span class="line">    /* Now ask how many coins are needed to make the total, using any coins</span><br><span class="line">     * from index 0 onward.</span><br><span class="line">     */</span><br><span class="line">    return fewestCoinsRec(cents, coinVec, 0, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归穷举付账单">递归穷举付账单</h3>
<p>递归机制：对第一个人来说，0-total所有金额都会付一遍，随后传递给下一个人，当只有一人时，付清所有余额并打印账单 传递参数：string,int的映射存储目前为止的账单，string集合存储所有付账者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void listPossiblePaymentsRec(int total, const Set&lt;string&gt;&amp; people,const Map&lt;string, int&gt;&amp; payments) &#123;</span><br><span class="line">    /* Base case: if there&#x27;s one person left, they have to pay the whole bill. */</span><br><span class="line">    if (people.size() == 1) &#123;</span><br><span class="line">        Map&lt;string, int&gt; finalPayments = payments;</span><br><span class="line">        finalPayments[people.first()] = total;</span><br><span class="line">        cout &lt;&lt; finalPayments &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: The first person has to pay some amount between 0 and the</span><br><span class="line">     * total amount. Try all of those possibilities.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int payment = 0; payment &lt;= total; payment++) &#123;</span><br><span class="line">            /* Create a new assignment of people to payments in which this first</span><br><span class="line">             * person pays this amount.</span><br><span class="line">             */</span><br><span class="line">            Map&lt;string, int&gt; updatedPayments = payments;</span><br><span class="line">            updatedPayments[people.first()] = payment;</span><br><span class="line">            listPossiblePaymentsRec(total - payment, people - people.first(),updatedPayments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void listPossiblePayments(int total, const Set&lt;string&gt;&amp; people) &#123;</span><br><span class="line">    /* Edge cases: we can&#x27;t pay a negative total, and there must be at least one</span><br><span class="line">     * person.</span><br><span class="line">     */</span><br><span class="line">    if (total &lt; 0) error(&quot;Guess you&#x27;re an employee?&quot;);</span><br><span class="line">    if (people.isEmpty()) error(&quot;Dine and dash?&quot;);</span><br><span class="line"> listPossiblePaymentsRec(total, people, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归寻找完全平方数列">递归寻找完全平方数列</h3>
<p>主要参数为sofar——用于存储目前的序列和一个set用于存储还没放入数列的数字，`确保这两者同时被传递，且其并集为所有数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSquareSequence(int n) &#123;</span><br><span class="line">    /*Validate input.*/</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        error(&quot;Don&#x27;t be so negative!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build a set of the numbers 1, 2, 3, ..., n. */</span><br><span class="line">    Set&lt;int&gt; options;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        options += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return findSequenceRec(options, &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSequenceRec(const Set&lt;int&gt;&amp; unused,</span><br><span class="line">                                      const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /*Base Case: If all numbers are used, we have our sequence!*/</span><br><span class="line">    if (unused.isEmpty()) &#123;</span><br><span class="line">        return soFar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Recursive Case: Some number comes next. Try each of them and see which</span><br><span class="line">     * one we should pick.</span><br><span class="line">     */</span><br><span class="line">    for (int next: unused) &#123;</span><br><span class="line">        /* We can use this if either</span><br><span class="line">         *</span><br><span class="line">         * 1. the sequence is empty, so we&#x27;re first in line, or</span><br><span class="line">         * 2. the sequence is not empty, but we sum to a perfect square</span><br><span class="line">         *    with the previous term.</span><br><span class="line">         */</span><br><span class="line">        if (soFar.isEmpty() ||</span><br><span class="line">            isPerfectSquare(next + soFar[soFar.size() - 1])) &#123;</span><br><span class="line">            /* See what happens if we extend with this number. */</span><br><span class="line">            auto result = findSequenceRec(unused - next, soFar + next);</span><br><span class="line">            if (result != Nothing) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Tried all options and none of them worked. Oh well! */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="汉诺塔递归">汉诺塔递归</h3>
<p>假设有三座汉诺塔，<code>start ,temp ,finish</code> 对n层的汉诺塔问题，先考虑n-1层的，随后考虑n-2层，到最后只需要考虑两层问题，两层的汉诺塔非常容易解决，起点为start,终点是temp,临时塔为finish，最后我们得到temp上的两层汉诺塔 这时将start的3移动到finish塔，这时只要将两层汉诺塔转移到finish则完成了三层汉诺塔，这个过程中的起点为temp,终点是finish,临时塔是start 以此类推，四层塔基于三层塔，<code>n</code>层塔基于<code>n-1</code>塔，汉诺塔问题解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int moveTower(int numDisks, char start, char finish, char temp) &#123;</span><br><span class="line">    if (numDisks == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int movesOne = moveTower(numDisks - 1, start, temp, finish);</span><br><span class="line">        moveSingleDisk(start, finish);</span><br><span class="line">        int movesTwo = moveTower(numDisks - 1, temp, finish, start);</span><br><span class="line"></span><br><span class="line">        return 1 + movesOne + movesTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据结构与算法</tag>
        <tag>c++</tag>
        <tag>斯坦福</tag>
      </tags>
  </entry>
  <entry>
    <title>基于斯坦福cs106l的c++编程规范笔记</title>
    <url>/2023/09/29/cs106l%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="c特性">c++特性</h2>
<ul>
<li>更好的C C++支持<code>命令式编程</code>，一种编程风格，其中程序按顺序执行的命令序列。从这个意义上讲，C++ 可以看作是对C 编程语言，使日常命令式编程更加直观和更容易使用。课程阅读器的这一部分介绍了一些 C++ 最常用的库,包括标准模板库，并展示了如何使用这些库来构建命令程式。 此外，它探索了最初出现在 C++ 语言中的新原语。C 编程语言，即指针、C 字符串和预处理器。 <span id="more"></span></li>
<li>数据抽象</li>
</ul>
<p>C++与其兄弟C的最大区别在于_数据抽象_,程序执行的方式可以与程序执行的方式分开 程序员谈论那个程序。</p>
<ul>
<li>面向对象编程</li>
</ul>
<p>. 面向对象编程是一种完全不同的方式考虑程序设计，可以极大地简化复杂的软件系统。 钥匙 面向对象背后的概念很简单，但要真正体会到面向对象的力量 编程，您将需要一次又一次地看到它的运行情况。 这部分课程 读者探索了面向对象编程中的主要概念以及如何在 C++ 中实现它继承和多态。</p>
<ul>
<li>泛型编程</li>
</ul>
<p>泛型编程是一种编程风格，旨在构建可以解决一系列远远超出最初设想的问题的软件<br />
履行。 虽然泛型编程的完整处理远远超出了介绍性的范围C++ 编程课，泛型编程的许多思想都可以访问并且可以从根本上改变了您对 C++ 编程的看法。</p>
<h2 id="const">const</h2>
<p>Can’t declare non-const reference to const variable Can’t declare non-const reference to const vari</p>
<p><img src="/images/obsidian/20230215213916.png" title="image" alt="图片" /> <img src="/images/obsidian/20230215214023.png" title="image" alt="图片" /></p>
<h2 id="模板">模板</h2>
<p><img src="/images/obsidian/20230215215043.png" title="image" alt="图片" /> 函数指针：将函数作为对象传递</p>
<h2 id="stl">stl</h2>
<p>sequence:线性，有顺序 associative:不一定线性，有索引机制(map)</p>
<p>vector:有顺序的相同类型的数据集合，大小可控制 ---子属性：<em>size:元素数量 ---capacity</em>:单个元素大小 <img src="/images/obsidian/20230214194657.png" title="image" alt="图片" /> vector最常用，deque用于首部插入场合，list用于多种列表</p>
<p>associative(关联数组):有顺序的需要有比较方法，无序的需要哈希函数（更快） iterators（迭代器）：用于访问容器中的所有数据 --常用函数，begin(),end(),iter++,*(pointer),== !=,=（赋值,复制）, <img src="/images/obsidian/20230214200501.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214200805.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214201819.png" title="image" alt="图片" /></p>
<h2 id="输入输出流">输入输出流</h2>
<p>First call to std::cin &gt;&gt; creates a command line<br />
prompt that allows the user to type until they hit enter</p>
<ul>
<li>Each &gt;&gt; ONLY reads until the next whitespace<br />
</li>
<li>Whitespace = tab, space, newline<br />
</li>
<li>Everything after the first whitespace gets saved and<br />
used the next time std::cin &gt;&gt; is called<br />
</li>
<li>The place its saved is called a buffer <img src="/images/obsidian/20230213213832.png" title="image" alt="图片" /> <img src="/images/obsidian/20230213214430.png" title="image" alt="图片" /> <img src="/images/obsidian/20230213214751.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214102508.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214104421.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214162731.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214162820.png" title="image" alt="图片" /></li>
</ul>
<h2 id="hashmap的c实现">hashmap的c++实现</h2>
<h3 id="相关函数">相关函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数HashMap():</span><br><span class="line">接受参数count(值的个数),hash function(有默认值)</span><br><span class="line"></span><br><span class="line">参数(typename fitst,typename last,bucket_count,H)</span><br><span class="line">//用一个容器首尾指针初始化hashmap</span><br><span class="line">eg.</span><br><span class="line">hashmap&lt;k,m&gt; map&#123;vec.begin(),vec.end()&#125;</span><br><span class="line"></span><br><span class="line">参数(init_list init,bucket_count,H)</span><br><span class="line">//用容器直接初始化hashmap</span><br><span class="line">eg.</span><br><span class="line">HashMap&lt;char, int&gt; map&#123;&#123;&#x27;a&#x27;, 3&#125;, &#123;&#x27;b&#x27;, 5&#125;, &#123;&#x27;c&#x27;, 7&#125;&#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">key-键</span><br><span class="line">mapped-被加密的值(int)</span><br><span class="line">H-哈希函数</span><br><span class="line">bucket_count(存储的键值对数组容量)</span><br><span class="line">load_factor(内联函数，返回size/bucket_count，即实际储存值的键值对)</span><br><span class="line">contains(参数const K&amp; key判断是否存在改键，返回bool值)</span><br><span class="line">at(参数k，返回mapped的引用)</span><br><span class="line">clear(清空键值对)</span><br><span class="line">insert(参数为键值对引用，返回一对pair&lt;iterator,bool&gt;,iter指向改键值对，无论是否已存在，bool表示是否成功添加，如为false则已存在该键值对)</span><br><span class="line">erase(key为参数，返回bool值)</span><br><span class="line">earse(iter为参数，返回该指针下一个位置)</span><br><span class="line">rehash(size_t为参数，重新哈希为给出的新的指针数组大小)</span><br><span class="line">begin(根据hashmap是否为const给出iter或const iter)</span><br><span class="line">end(返回伪指针)</span><br><span class="line">debug(打印所有哈希键值对以及哈希表所有参数，注意，必须基于重载&lt;&lt;运算符的基础)</span><br><span class="line"></span><br><span class="line">符号重载：</span><br><span class="line">M&amp; [](const key&amp; ,返回insert(key)的返回pair的first成员的second成员，即mapped值)</span><br><span class="line">//用于给key对应的value(mapped)赋值</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">node(struct，包含next指针和value)</span><br><span class="line">nodepair(前后node的pair)</span><br><span class="line">findnode(参数key，返回指针对&lt;prev,curr&gt;)</span><br><span class="line">first_not_empty_bucket()</span><br><span class="line">make_iterator(参数node*curr)</span><br><span class="line">_bucket_array(vector&lt;node*&gt;,其中一个node*为ptr,则ptr-&gt;value为&lt;key ,mapped&gt;)</span><br><span class="line"></span><br><span class="line">//指针构造</span><br><span class="line"></span><br><span class="line">_bucket_array：由指针组成的数组,每个成员都是一个指针</span><br><span class="line">储存的值为next指针和一个pair&lt;key,mapped&gt;</span><br><span class="line">operator-&gt; is a bit of an odd-ball. When you write p-&gt;m, it is interpreted as (p.operator-&gt;())-&gt;m.</span><br><span class="line"></span><br><span class="line">- This means operator-&gt; should return a pointer to the object that has the field m.</span><br></pre></td></tr></table></figure>
<h3 id="涉及的c特性">涉及的c++特性</h3>
<p>匿名函数 基本lambda语法 基本形式如下： 【capture】（parameters）-&gt;return-type {body}</p>
<p>typename function() return {x,y,z} 即用{}的参数初始化原函数返回的类型</p>
<p>ptrdiff_t:用于储存两个指针的差</p>
<p>conditional_t&lt;func,x,y&gt;如果func为true则x，为false则y</p>
<p>forward_iterator_tag：单方向迭代器（可读写） ++iter，iter+=1随后返回对自身的引用 iter++，先返回一个对自身的复制，随后iter+=1</p>
<p>std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p>
<p>ate：从文件尾部开始 strsub(start,length) 移动语义(c++11新特性) clss(classname &amp;&amp;) 利用右值引用的部分数据直接初始化新的类，并在初始化之后将右值删除，可以通过std::move()强制转化左值为右值。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>c++</tag>
        <tag>斯坦福</tag>
      </tags>
  </entry>
  <entry>
    <title>基于北大前沿计算实践课和missing semester的linux等编程工具笔记</title>
    <url>/2023/09/29/linux%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p><a href="https://en.wikipedia.org/wiki/Linux">Linux</a>是一群<strong>开源</strong>的、基于<strong>Linux内核</strong>的<strong>类Unix操作系统</strong>集合。</p>
<ul>
<li>操作系统(operating system)：管理计算机硬件和软件资源的程序，为用户程序提供硬件抽象和接口。</li>
<li>操作系统内核(operating system kernel)：操作系统最核心的部分，管理系统的进程、内存、设备驱动程序、文件和网络系统，一直在内存中，不包括图形界面、Shell等功能</li>
<li>Shell：内核的封装，为用户提供更高级的抽象，比如<code>echo</code>、<code>ls</code>、<code>cd</code>等命令，以及进程间通信功能（管道） <span id="more"></span></li>
<li>Unix内核：最早形成规模，被广泛使用的操作系统，由肯•汤普森(Ken Thompson)和丹尼斯•里奇(Dennis Ritchie)发明，使用C编写，现在常用的基于UNIX内核的操作系统有<a href="https://www.oracle.com/solaris/solaris11/">Solaris</a>、<a href="https://www.freebsd.org/">FreeBSD</a></li>
<li>Linux内核：由李纳斯•托瓦兹(Linus Torvalds)在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版UNIX操作系统Minix太难用了，于是决定自己开发一个操作系统。第1版本于1991年9月发布，当时仅有10000行代码。李纳斯•托瓦兹没有保留Linux源代码的版权，公开了代码，并邀请他人一起完善Linux。据估计，现在只有2%的Linux核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有Linux内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权(Benevolent dictator for life, BDFL)。</li>
</ul>
<h2 id="shell的配置">shell的配置</h2>
<p>很多程序的配置都是通过纯文本格式的被称作_点文件_的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p>
<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a> 有非常好的资源</p>
<p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH="$PATH:/path/to/program/bin"</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p>
<p>还有一些其他的工具也可以通过_点文件_进行配置：</p>
<ul>
<li><code>bash</code> - <code>~/.bashrc</code>, <code>~/.bash_profile</code></li>
<li><code>git</code> - <code>~/.gitconfig</code></li>
<li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li>
<li><code>ssh</code> - <code>~/.ssh/config</code></li>
<li><code>tmux</code> - <code>~/.tmux.conf</code></li>
</ul>
<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p>
<ul>
<li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li>
<li><strong>可以执行</strong>: 您的工具在任何地方都以相同的配置工作</li>
<li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li>
<li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li>
<li>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</li>
</ul>
<p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"></span><br><span class="line"># 使用和 shell 相关的配置时先检查当前 shell 类型</span><br><span class="line">if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"></span><br><span class="line"># 您也可以针对特定的设备进行配置</span><br><span class="line">if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then &#123;do_something&#125;; fi</span><br></pre></td></tr></table></figure>
<p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure>
<p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Test if ~/.aliases exists and source it</span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="包管理">包管理</h2>
<p>在Ubuntu下，我们也可以在网站上下载软件包，后缀为<code>.deb</code>，然后调用<code>dpkg</code>进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure>
<p><code>.deb</code>文件后缀是<a href="https://www.debian.org/">Debian</a>系统的 软件包格式，Ubuntu基于Debian开发因此使用相同的软件包格式，里面包含了程序的二进制文件、配置文件、man/info帮助页面等信息。用户 不同的任务依赖大量的软件支撑，不同的软件往往有着复杂的依赖关系，一个软件往往也有很多版本，为了管理这么多的软件，Ubuntu提供了统一的软件管理 机制，也就是<code>dpkg</code>和<code>ap![[download.gif]]t</code>。 <code>dpkg</code>的用法如上所示，<code>dpkg -l</code>可以列出所有的以安装软件，<code>dpkg -r</code>卸载软件，更多命令可以使用<code>dpkg --help</code>或者<code>man dpkg</code>。dpkg安装完成之后，默认文件存放位置如下：</p>
<ul>
<li>二进制文件：<code>/usr/bin</code></li>
<li>库文件：<code>/usr/lib</code></li>
<li>配置文件：<code>/etc</code></li>
<li>使用手册和帮助文档：<code>/usr/share/doc</code></li>
<li>man帮助页面：<code>/usr/share/man</code></li>
</ul>
<p>然而dpkg并不是万能的，当某个软件的依赖项没有安装时dpkg就会报错，需要用户手动安装依赖项。apt很好地解决了这一问题。首先开发者会将 编译后的二进制文件和软件信息存放在Ubuntu的源服务器上，当需要安装软件时，apt会自动从服务器上获取软件依赖信息，然后从服务器上下载依赖并安 装，然后再安装需要的软件。服务器的信息记录在本地的<code>/etc/apt/sources.list</code>中：</p>
<h2 id="shell脚本">shell脚本</h2>
<h3 id="赋值">赋值</h3>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash中的字符串通过<code>'</code> 和 <code>"</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>"</code>定义的字符串会将变量值进行替换</p>
<h3 id="参数">参数</h3>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<h3 id="返回值">返回值</h3>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别</p>
<h2 id="查找">查找</h2>
<h3 id="查找文件">查找文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找所有名称为src的文件夹</span><br><span class="line">find . -name src -type d</span><br><span class="line"># 查找所有文件夹路径中包含test的python文件</span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"># 查找前一天修改的所有文件</span><br><span class="line">find . -mtime -1</span><br><span class="line"># 查找所有大小在500k至10M的tar.gz文件</span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除全部扩展名为.tmp 的文件</span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"># 查找全部的 PNG 文件并将其转换为 JPG</span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure>
<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name '*PATTERN*'</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码">查找代码</h3>
<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。 它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：****</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找所有使用了 requests 库的文件</span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"># 查找所有的foo字符串，并打印其之后的5行</span><br><span class="line">rg foo -A 5</span><br><span class="line"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure>
<h2 id="使用建议">使用建议</h2>
<h3 id="建立别名">建立别名</h3>
<p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias alias_name=&quot;command_to_alias arg1 arg2&quot;</span><br></pre></td></tr></table></figure>
<p>注意， <code>=</code>两边是没有空格的，因为 <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p>
<p>别名有许多很方便的特性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建常用命令的缩写</span><br><span class="line">alias ll=&quot;ls -lh&quot;</span><br><span class="line"></span><br><span class="line"># 能够少输入很多</span><br><span class="line">alias gs=&quot;git status&quot;</span><br><span class="line">alias gc=&quot;git commit&quot;</span><br><span class="line">alias v=&quot;vim&quot;</span><br><span class="line"></span><br><span class="line"># 手误打错命令也没关系</span><br><span class="line">alias sl=ls</span><br><span class="line"></span><br><span class="line"># 重新定义一些命令行的默认行为</span><br><span class="line">alias mv=&quot;mv -i&quot;           # -i prompts before overwrite</span><br><span class="line">alias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed</span><br><span class="line">alias df=&quot;df -h&quot;           # -h prints human readable format</span><br><span class="line"></span><br><span class="line"># 别名可以组合使用</span><br><span class="line">alias la=&quot;ls -A&quot;</span><br><span class="line">alias lla=&quot;la -l&quot;</span><br><span class="line"></span><br><span class="line"># 在忽略某个别名</span><br><span class="line">\ls</span><br><span class="line"># 或者禁用别名</span><br><span class="line">unalias la</span><br><span class="line"></span><br><span class="line"># 获取别名的定义</span><br><span class="line">alias ll</span><br><span class="line"># 会打印 ll=&#x27;ls -lh&#x27;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是<code>.bashrc</code> 或 <code>.zshrc</code>，</p>
<h3 id="tips">tips</h3>
<p>右击边框开启设置菜单 <code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。 <a href="https://github.com/clvv/fasd"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a> 对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<h2 id="命令行环境">命令行环境</h2>
<h3 id="默认环境变量">默认环境变量</h3>
<p>因为Shell中定义的环境变量之后影响子进程，为了避免我们每次都需要在使用前定义环境变量，我们可以将这一设置写进<code>~/.bashrc</code>里，这个配置文件会在每次启动bash时执行。<code>~/.bashrc</code>中已经包含了很多配置，我们要做的就是在最后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HELLO=hello</span><br></pre></td></tr></table></figure>
<p>然后执行<code>source ~/.bashrc</code>，这样就可以在每次打开Shell的时候定义这一环境变量。利用这个机制，假如我们想把自定义的命令加入<code>PATH</code>中时就可以在<code>~/.bashrc</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/path/to/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>这样命令就会添加到Shell的搜索路径中。需要注意的一点是，如果使用的是zsh，需要修改的就不是<code>~/.bashrc</code>，而是<code>~/.zshrc</code></p>
<h3 id="端口转发">端口转发</h3>
<p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>
<p>此时就需要进行 <em>端口转发</em>。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p>
<p><strong>本地端口转发</strong> <img src="https://i.stack.imgur.com/a28N8.png" title="本地端口转发" alt="Local Port Forwarding" /></p>
<p><strong>远程端口转发</strong> <img src="https://i.stack.imgur.com/4iK3b.png" title="远程端口转发" alt="Remote Port Forwarding" /></p>
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>
<h3 id="信号机制">信号机制</h3>
<p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p>
<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> 信号到进程。</p>
<p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code> 信号，通过输入<code>Ctrl-\</code>可以发送该信号。 尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。 信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p>
<p>我们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code> ，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，您可以使用终端多路复用器来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"></span><br><span class="line">$ nohup sleep 2000 &amp;</span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ bg %1</span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -STOP %1</span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %1</span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %2</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill %2</span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>
<h3 id="tmux多路终端复用">tmux多路终端复用</h3>
<p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>
<p>像 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a> 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p>
<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>
<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p>
<p>现在最流行的终端多路器是 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>
<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p>
<ul>
<li><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口
<ul>
<li><code>tmux</code> 开始一个新的会话</li>
<li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li>
<li><code>tmux ls</code> 列出当前所有会话</li>
<li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</li>
<li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li>
</ul></li>
<li><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分
<ul>
<li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code>关闭</li>
<li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的</li>
<li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li>
<li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li>
<li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li>
<li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li>
</ul></li>
<li><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell
<ul>
<li><code>&lt;C-b&gt; "</code> 水平分割</li>
<li><code>&lt;C-b&gt; %</code> 垂直分割</li>
<li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，<方向> 指的是键盘上的方向键</li>
<li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li>
<li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li>
<li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li>
</ul></li>
</ul>
<h3 id="ssh">ssh</h3>
<p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></table></figure>
<p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p>
<h4 id="执行命令">执行命令</h4>
<p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。 <code>ssh foobar@server ls</code> 可以直接在用foobar的命令下执行 <code>ls</code> 命令。 想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p>
<h4 id="ssh-密钥">SSH 密钥</h4>
<p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p>
<h4 id="密钥生成">密钥生成</h4>
<p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>
<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h4 id="基于密钥的认证机制">基于密钥的认证机制</h4>
<p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>
<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h3 id="g-基于密钥的认证机制">G# 基于密钥的认证机制</h3>
<p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat .ssh/id_ed25519 | ssh foobar@remote &#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br></pre></td></tr></table></figure>
<p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></table></figure>
<h2 id="文本匹配">文本匹配</h2>
<ul>
<li>当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>&#123;&#125;</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
<li>[[Pasted image 20230128155221.png]]</li>
</ul>
<h3 id="正则表达式">正则表达式</h3>
<p>正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code> 除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<h3 id="awk">awk</h3>
<p>擅长文本处理的编程语言 <code>&#123;print $2&#125;</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名 让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| awk &#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27; | wc -l</span><br></pre></td></tr></table></figure>
<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是<code>&#123;...&#125;</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN &#123; rows = 0 &#125;</span><br><span class="line">$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; rows += $1 &#125;</span><br><span class="line">END &#123; print rows &#125;</span><br></pre></td></tr></table></figure>
<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。</p>
<h2 id="守护进程">守护进程</h2>
<p>即便守护进程（daemon）这个词看上去有些陌生，你应该已经大约明白它的概念。大部分计算机都有一系列在后台保持运行，不需要用户手动运行或者交互的进程。这些进程就是守护进程。以守护进程运行的程序名一般以 <code>d</code> 结尾，比如 SSH 服务端 <code>sshd</code>，用来监听传入的 SSH 连接请求并对用户进行鉴权。</p>
<p>Linux 中的 <code>systemd</code>（the system daemon）是最常用的配置和运行守护进程的方法。运行 <code>systemctl status</code> 命令可以看到正在运行的所有守护进程。这里面有很多可能你没有见过，但是掌管了系统的核心部分的进程：管理网络、DNS解析、显示系统的图形界面等等。用户使用 <code>systemctl</code> 命令和 <code>systemd</code> 交互来<code>enable</code>（启用）、<code>disable</code>（禁用）、<code>start</code>（启动）、<code>stop</code>（停止）、<code>restart</code>（重启）、或者<code>status</code>（检查）配置好的守护进程及系统服务。</p>
<p><code>systemd</code> 提供了一个很方便的界面用于配置和启用新的守护进程或系统服务。下面的配置文件使用了守护进程来运行一个简单的 Python 程序。文件的内容非常直接所以我们不对它详细阐述。<code>systemd</code> 配置文件的详细指南可参见 <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">freedesktop.org</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/systemd/system/myapp.service</span><br><span class="line">[Unit]</span><br><span class="line"># 配置文件描述</span><br><span class="line">Description=My Custom App</span><br><span class="line"># 在网络服务启动后启动该进程</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"># 运行该进程的用户</span><br><span class="line">User=foo</span><br><span class="line"># 运行该进程的用户组</span><br><span class="line">Group=foo</span><br><span class="line"># 运行该进程的根目录</span><br><span class="line">WorkingDirectory=/home/foo/projects/mydaemon</span><br><span class="line"># 开始该进程的命令</span><br><span class="line">ExecStart=/usr/bin/local/python3.7 app.py</span><br><span class="line"># 在出现错误时重启该进程</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"># 相当于Windows的开机启动。即使GUI没有启动，该进程也会加载并运行</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"># 如果该进程仅需要在GUI活动时运行，这里应写作：</span><br><span class="line"># WantedBy=graphical.target</span><br><span class="line"># graphical.target在multi-user.target的基础上运行和GUI相关的服务</span><br></pre></td></tr></table></figure>
<h2 id="备份">备份</h2>
<p>任何没有备份的数据都可能在一个瞬间永远消失。复制数据很简单，但是可靠地备份数据很难。下面列举了一些关于备份的基础知识，以及一些常见做法容易掉进的陷阱。</p>
<p>首先，复制存储在同一个磁盘上的数据不是备份，因为这个磁盘是一个单点故障（single point of failure）。这个磁盘一旦出现问题，所有的数据都可能丢失。放在家里的外置磁盘因为火灾、抢劫等原因可能会和源数据一起丢失，所以是一个弱备份。推荐的做法是将数据备份到不同的地点存储。</p>
<p>同步方案也不是备份。即使方便如 Dropbox 或者 Google Drive，当数据在本地被抹除或者损坏，同步方案可能会把这些“更改”同步到云端。同理，像 RAID 这样的磁盘镜像方案也不是备份。它不能防止文件被意外删除、损坏、或者被勒索软件加密。</p>
<p>有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。对备份的数据实施版本控制保证了用户可以从任何记录过的历史版本中恢复数据。在备份中检测并删除重复数据，使其仅备份增量变化可以减少存储开销。在安全性方面，作为用户，你应该考虑别人需要有什么信息或者工具才可以访问或者完全删除你的数据及备份。最后一点，不要盲目信任备份方案。用户应该经常检查备份是否可以用来恢复数据。</p>
<p>备份不限制于备份在本地计算机上的文件。云端应用的重大发展使得我们很多的数据只存储在云端。当我们无法登录这些应用，在云端存储的网络邮件，社交网络上的照片，流媒体音乐播放列表，以及在线文档等等都会随之丢失。用户应该有这些数据的离线备份，而且已经有项目可以帮助下载并存储它们。</p>
<h2 id="常见命令行标志参数及模式">常见命令行标志参数及模式</h2>
<p>命令行工具的用法千差万别，阅读 <code>man</code> 页面可以帮助你理解每种工具的用法。即便如此，下面我们将介绍一下命令行工具一些常见的共同功能。</p>
<ul>
<li><p>大部分工具支持 <code>--help</code> 或者类似的标志参数（flag）来显示它们的简略用法。</p></li>
<li><p>会造成不可撤回操作的工具一般会提供“空运行”（dry run）标志参数，这样用户可以确认工具真实运行时会进行的操作。这些工具通常也会有“交互式”（interactive）标志参数，在执行每个不可撤回的操作前提示用户确认。</p></li>
<li><p><code>--version</code> 或者 <code>-V</code> 标志参数可以让工具显示它的版本信息（对于提交软件问题报告非常重要）。</p></li>
<li><p>基本所有的工具支持使用 <code>--verbose</code> 或者 <code>-v</code> 标志参数来输出详细的运行信息。多次使用这个标志参数，比如 <code>-vvv</code>，可以让工具输出更详细的信息（经常用于调试）。同样，很多工具支持 <code>--quiet</code> 标志参数来抑制除错误提示之外的其他输出。</p></li>
<li><p>大多数工具中，使用 <code>-</code> 代替输入或者输出文件名意味着工具将从标准输入（standard input）获取所需内容，或者向标准输出（standard output）输出结果。</p></li>
<li><p>会造成破坏性结果的工具一般默认进行非递归的操作，但是支持使用“递归”（recursive）标志函数（通常是 <code>-r</code>）。</p></li>
<li><p>有的时候你可能需要向工具传入一个 <em>看上去</em> 像标志参数的普通参数，比如：</p>
<ul>
<li><p>使用 <code>rm</code> 删除一个叫 <code>-r</code> 的文件；</p></li>
<li><p>在通过一个程序运行另一个程序的时候（<code>ssh machine foo</code>），向内层的程序（<code>foo</code>）传递一个标志参数。</p>
<p>这时候你可以使用特殊参数 <code>--</code> 让某个程序 <em>停止处理</em> <code>--</code> 后面出现的标志参数以及选项（以 <code>-</code> 开头的内容）：</p></li>
<li><p><code>rm -- -r</code> 会让 <code>rm</code> 将 <code>-r</code> 当作文件名；</p></li>
<li><p><code>ssh machine --for-ssh -- foo --for-foo</code> 的 <code>--</code> 会让 <code>ssh</code> 知道 <code>--for-foo</code> 不是 <code>ssh</code> 的标志参数。</p></li>
</ul></li>
</ul>
<h2 id="代码调试">代码调试</h2>
<h3 id="事件分析">事件分析</h3>
<p>在我们使用<code>strace</code>调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p>
<p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）。下面是关于常见命令的简介：</p>
<ul>
<li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li>
<li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li>
<li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li>
<li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li>
</ul>
<h3 id="资源监控">资源监控</h3>
<p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。</p>
<ul>
<li><strong>通用监控</strong> - 最流行的工具要数 <a href="https://htop.dev/"><code>htop</code></a>,了，它是 <a href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a>的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、 <code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。 还可以留意一下 <a href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等；</li>
<li><strong>I/O 操作</strong> - <a href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li>
<li><strong>磁盘使用</strong> - <a href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的 <code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；</li>
<li><strong>内存使用</strong> - <a href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</li>
<li><strong>打开文件</strong> - <a href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a> 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</li>
<li><strong>网络连接和配置</strong> - <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 <a href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</li>
<li><strong>网络使用</strong> - <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对网络占用进行监控的交互式命令行工具。</li>
</ul>
<p>如果您希望测试一下这些工具，您可以使用 <a href="https://linux.die.net/man/1/stress"><code>stress</code></a> 命令来为系统人为地增加负载。</p>
<h2 id="qa">QA</h2>
<h3 id="source-script.sh-和-.script.sh-有什么区别"><code>source script.sh</code> 和 <code>./script.sh</code> 有什么区别?</h3>
<p>这两种情况 <code>script.sh</code> 都会在bash会话中被读取和执行，不同点在于哪个会话执行这个命令。 对于 <code>source</code> 命令来说，命令是在当前的bash会话中执行的，因此当 <code>source</code> 执行完毕，对当前环境的任何更改（例如更改目录或是定义函数）都会留存在当前会话中。 单独运行 <code>./script.sh</code> 时，当前的bash会话将启动新的bash会话（实例），并在新实例中运行命令 <code>script.sh</code>。 因此，如果 <code>script.sh</code> 更改目录，新的bash会话（实例）会更改目录，但是一旦退出并将控制权返回给父bash会话，父会话仍然留在先前的位置（不会有目录的更改）。 同样，如果 <code>script.sh</code> 定义了要在终端中访问的函数，需要用 <code>source</code> 命令在当前bash会话中定义这个函数。否则，如果你运行 <code>./script.sh</code>，只有新的bash会话（进程）才能执行定义的函数，而当前的shell不能。</p>
<h3 id="各种软件包和工具存储在哪里引用过程是怎样的-bin-或-lib-是什么">各种软件包和工具存储在哪里？引用过程是怎样的? <code>/bin</code> 或 <code>/lib</code> 是什么？</h3>
<p>根据你在命令行中运行的程序，这些包和工具会全部在 <code>PATH</code> 环境变量所列出的目录中查找到， 你可以使用 <code>which</code> 命令(或是 <code>type</code> 命令)来检查你的shell在哪里发现了特定的程序。 一般来说，特定种类的文件存储有一定的规范，<a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">文件系统，层次结构标准（Filesystem, Hierarchy Standard）</a>可以查到我们讨论内容的详细列表。</p>
<ul>
<li><code>/bin</code> - 基本命令二进制文件</li>
<li><code>/sbin</code> - 基本的系统二进制文件，通常是root运行的</li>
<li><code>/dev</code> - 设备文件，通常是硬件设备接口文件</li>
<li><code>/etc</code> - 主机特定的系统配置文件</li>
<li><code>/home</code> - 系统用户的主目录</li>
<li><code>/lib</code> - 系统软件通用库</li>
<li><code>/opt</code> - 可选的应用软件</li>
<li><code>/sys</code> - 包含系统的信息和配置(<a href="https://missing-semester-cn.github.io/2020/course-shell/">第一堂课</a>介绍的)</li>
<li><code>/tmp</code> - 临时文件( <code>/var/tmp</code> ) 通常重启时删除</li>
<li><code>/usr/</code> - 只读的用户数据
<ul>
<li><code>/usr/bin</code> - 非必须的命令二进制文件</li>
<li><code>/usr/sbin</code> - 非必须的系统二进制文件，通常是由root运行的</li>
<li><code>/usr/local/bin</code> - 用户编译程序的二进制文件</li>
</ul></li>
<li><code>/var</code> -变量文件 像日志或缓存</li>
<li><br />
</li>
</ul>
<h3 id="我应该用-apt-get-install-还是-pip-install-去下载软件包呢">我应该用 <code>apt-get install</code> 还是 <code>pip install</code> 去下载软件包呢?</h3>
<p>这个问题没有普遍的答案。这与使用系统程序包管理器还是特定语言的程序包管理器来安装软件这一更笼统的问题相关。需要考虑的几件事：</p>
<ul>
<li><p>常见的软件包都可以通过这两种方法获得，但是小众的软件包或较新的软件包可能不在系统程序包管理器中。在这种情况下，使用特定语言的程序包管理器是更好的选择。</p></li>
<li><p>同样，特定语言的程序包管理器相比系统程序包管理器有更多的最新版本的程序包。</p></li>
<li><p>当使用系统软件包管理器时，将在系统范围内安装库。如果出于开发目的需要不同版本的库，则系统软件包管理器可能不能满足你的需要。对于这种情况，大多数编程语言都提供了隔离或虚拟环境，因此你可以用特定语言的程序包管理器安装不同版本的库而不会发生冲突。对于 Python，可以使用 virtualenv，对于 Ruby，使用 RVM 。</p></li>
<li><p>根据操作系统和硬件架构，其中一些软件包可能会附带二进制文件或者软件包需要被编译。例如，在树莓派（Raspberry Pi）之类的ARM架构计算机中，在软件附带二进制文件和软件包需要被编译的情况下，使用系统包管理器比特定语言包管理器更好。这在很大程度上取决于你的特定设置。 你应该仅使用一种解决方案，而不同时使用两种方法，因为这可能会导致难以解决的冲突。我们的建议是尽可能使用特定语言的程序包管理器，并使用隔离的环境（例如 Python 的 virtualenv）以避免影响全局环境</p></li>
<li><h3 id="docker和虚拟机有什么区别">Docker和虚拟机有什么区别?</h3></li>
</ul>
<p>Docker 基于容器这个更为概括的概念。关于容器和虚拟机之间最大的不同是，虚拟机会执行整个的 OS 栈，包括内核（即使这个内核和主机内核相同）。与虚拟机不同，容器避免运行其他内核实例，而是与主机分享内核。在Linux环境中，有LXC机制来实现，并且这能使一系列分离的主机像是在使用自己的硬件启动程序，而实际上是共享主机的硬件和内核。因此容器的开销小于完整的虚拟机。</p>
<p>另一方面，容器的隔离性较弱而且只有在主机运行相同的内核时才能正常工作。例如，如果你在macOS 上运行 Docker，Docker 需要启动 Linux虚拟机去获取初始的 Linux内核，这样的开销仍然很大。最后，Docker 是容器的特定实现，它是为软件部署而定制的。基于这些，它有一些奇怪之处：例如，默认情况下，Docker 容器在重启之间不会有以任何形式的存储。</p>
<h3 id="还有更多的-vim-小窍门吗">还有更多的 Vim 小窍门吗？</h3>
<p>更多的窍门：</p>
<ul>
<li>插件 - 花时间去探索插件。有很多不错的插件修复了vim的缺陷或者增加了能够与现有vim工作流结合的新功能。关于这部分内容，资源是<a href="https://vimawesome.com/">VimAwesome</a> 和其他程序员的dotfiles。</li>
<li>标记 - 在vim里你可以使用 <code>m&lt;X&gt;</code> 为字母 <code>X</code> 做标记，之后你可以通过 <code>'&lt;X&gt;</code> 回到标记位置。这可以让你快速定位到文件内或文件间的特定位置。</li>
<li>导航 - <code>Ctrl+O</code> 和 <code>Ctrl+I</code> 命令可以使你在最近访问位置前后移动。</li>
<li>撤销树 - vim 有不错的更改跟踪机制，不同于其他的编辑器，vim存储变更树，因此即使你撤销后做了一些修改，你仍然可以通过撤销树的导航回到初始状态。一些插件比如 <a href="https://github.com/sjl/gundo.vim">gundo.vim</a> 和 <a href="https://github.com/mbbill/undotree">undotree</a> 通过图形化来展示撤销树。</li>
<li>时间撤销 - <code>:earlier</code> 和 <code>:later</code> 命令使得你可以用时间而非某一时刻的更改来定位文件。</li>
<li><a href="https://vim.fandom.com/wiki/Using_undo_branches#Persistent_undo">持续撤销</a> - 是一个默认未被开启的vim的内置功能，它在vim启动之间保存撤销历史，需要配置在 <code>.vimrc</code> 目录下的<code>undofile</code> 和 <code>undodir</code>，vim会保存每个文件的修改历史。</li>
<li>热键（Leader Key） - 热键是一个用于用户自定义配置命令的特殊按键。这种模式通常是按下后释放这个按键（通常是空格键）并与其他的按键组合去实现一个特殊的命令。插件也会用这些按键增加它们的功能，例如，插件UndoTree使用 <code>&lt;Leader&gt; U</code> 去打开撤销树。</li>
<li>高级文本对象 - 文本对象比如搜索也可以用vim命令构成。例如，<code>d/&lt;pattern&gt;</code> 会删除下一处匹配 pattern 的字符串，<code>cgn</code> 可以用于更改上次搜索的关键字。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>麻省理工</tag>
        <tag>北京大学</tag>
        <tag>linux</tag>
        <tag>编程工具</tag>
      </tags>
  </entry>
</search>
