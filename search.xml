<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>thinklive的迪瑞克拉图书馆</title>
    <url>/2023/09/17/thinklive%E7%9A%84%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E5%9B%BE%E4%B9%A6%E9%A6%86/</url>
    <content><![CDATA[<video src="/images/thinklive.mp4" autoplay >
</video>

<h1 id="欢迎来到迪瑞克拉"><a href="#欢迎来到迪瑞克拉" class="headerlink" title="欢迎来到迪瑞克拉"></a>欢迎来到迪瑞克拉</h1><p>这里是thinklive的个人博客，不定时地会发一些个人技术学习心得和生活体会<br>使用左侧的分类来定位内容</p>
<h2 id="迪瑞克拉的由来"><a href="#迪瑞克拉的由来" class="headerlink" title="迪瑞克拉的由来"></a>迪瑞克拉的由来</h2><p><code>狄利克雷函数</code>（英语：<code>dirichlet function</code>）是一个定义在实数范围上、值域不连续的函数。<code>狄利克雷函数</code>的图像以Y轴为对称轴，是一个偶函数，它处处不连续，处处极限不存在，不可黎曼积分。这是一个处处不连续的可测函数。<br>在我看来它象征着混沌，不可知与无限的可能性，<code>狄利克雷</code>换一种方式音译就成了迪瑞克拉</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><span id="more"></span>
<p>2023&#x2F;9&#x2F;17<br>迪瑞克拉博客的生日，当天增加了背景音乐，搜索，相册，标签，目录，置顶等基础功能</p>
<p>2023&#x2F;9&#x2F;18<br>新增了评论，预估阅读时间，字数统计，网站访问统计,加载进度条功能,将背景音乐的歌曲改为歌单,为了方便使用，菜单切换成了中英双语</p>
<p>2023&#x2F;9&#x2F;19<br>新增了多级分类的特性，让返回顶部的进步条已读百分比，页面底部能看到阅读进度条了，新增了代码块复制功能，现在可以通过书签功能自动储存阅读进度，使退出后重进仍是当初的进度，也可以手动点击右上角书签图标实现相同效果,新增了彩带背景，并把背景色改成黑色</p>
<p>2023&#x2F;9&#x2F;20<br>替换一些页面ui文本，为一些页面ui文本加入了颜文字</p>
<p>2023&#x2F;9&#x2F;26<br>在guestbook和首页嵌入了好友做的一个赛博朋克logo视频</p>
<p>2023&#x2F;9&#x2F;27<br>开启了一些next的小功能，侧边栏加了一个thinklive的赛博朋克logo</p>
<p>2023&#x2F;9&#x2F;28<br>新增了加密页面，由秘密这个目录名检索，密码不会向任何人透露，部分页面会有提示</p>
]]></content>
  </entry>
  <entry>
    <title>hate</title>
    <url>/2023/09/28/%E7%A7%98%E5%AF%861/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="b880b7d31b2b49c2d1e177670d81885ee25e5fa92eb9653e5cb1ab63ed299a20">5c9f2c161c18225a1213c4fb8eed69605f71b5e706a2596abb349b07a2d0e59d06cd1da79a833bfa6f93404c48a998620110bfb9a1ca59188af69a5ea757606d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好，这里需要密码。</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>秘密</category>
      </categories>
      <tags>
        <tag>秘密</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利ds100的数据科学笔记pandas部分</title>
    <url>/2023/09/24/jupyter%20notebook/</url>
    <content><![CDATA[<h2 id="notebook"><a href="#notebook" class="headerlink" title="notebook"></a>notebook</h2><ol>
<li><code>Ctrl</code> + <code>Return</code>（或者 <code>Cmd</code> + <code>Return</code>在 Mac 上）： <em>评估当前单元格</em></li>
<li><code>Shift</code> + <code>Return</code>： <em>评估当前单元格并移至下一个单元格</em></li>
<li><code>ESC</code>： <em>命令模式</em> （在使用以下任何命令之前可能需要按）</li>
<li><code>a</code>: <em>在上面创建一个单元格</em></li>
<li><code>b</code>： <em>在下面创建一个单元格</em></li>
<li><code>dd</code>: <em>删除一个单元格</em></li>
<li><code>z</code>： <em>撤消上一次单元格操作</em></li>
<li><code>m</code>： <em>将单元格转换为 Markdown</em></li>
<li><code>y</code>： <em>将单元格转换为代码</em><span id="more"></span></li>
</ol>
<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="创建表格DataFrame"><a href="#创建表格DataFrame" class="headerlink" title="创建表格DataFrame"></a>创建表格DataFrame</h3><p>按列创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info = pd.DataFrame(</span><br><span class="line">    data = &#123;&#x27;fruit&#x27;: [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;raspberry&#x27;],</span><br><span class="line">          &#x27;color&#x27;: [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;],</span><br><span class="line">          &#x27;price&#x27;: [1.0, 0.75, 0.35, 0.05]</span><br><span class="line">          &#125;)</span><br><span class="line">fruit_info</span><br></pre></td></tr></table></figure>

<p>按行创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info2 = pd.DataFrame(</span><br><span class="line">    [(&quot;red&quot;, &quot;apple&quot;, 1.0), (&quot;orange&quot;, &quot;orange&quot;, 0.75), (&quot;yellow&quot;, &quot;banana&quot;, 0.35),</span><br><span class="line">     (&quot;pink&quot;, &quot;raspberry&quot;, 0.05)], </span><br><span class="line">    columns = [&quot;color&quot;, &quot;fruit&quot;, &quot;price&quot;])</span><br></pre></td></tr></table></figure>

<h3 id="选择行和列"><a href="#选择行和列" class="headerlink" title="选择行和列"></a>选择行和列</h3><ul>
<li>loc<br>两个详细运算符中的第一个是 <code>loc</code>，它需要两个参数。 第一个是一个或多个行 <strong>标签</strong> ，第二个是一个或多个列 <strong>标签</strong> 。</li>
</ul>
<p>所需的行或列可以单独提供、以切片表示法或作为列表提供。<br>单独提供会返回series<br>单独切片参数默认返回行</p>
<p><img src="/assets/jupyter%20notbook/image-20230924084033386.png"><br><img src="/assets/jupyter%20notbook/image-20230924084006924.png"><br><img src="/assets/jupyter%20notbook/image-20230924084050655.png"><br>● loc selects items by label. First argument is rows, second argument is columns.<br>● iloc selects items by number. First argument is rows, second argument is columns.<br>● [] only takes one argument, which may be:<br>○ A slice of row numbers.<br>○ A list of column labels.<br>○ A single column label.<br>That is,[] is context sensitive.</p>
<ul>
<li>列名一般唯一，可以强制重复</li>
<li>行名可以重复<br>pandas支持裸操作,但此时无法使用切片</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Here we&#x27;re providing a list of fruits as single argument to []</span><br><span class="line">fruit_info[[&quot;fruit&quot;, &quot;color&quot;, &quot;price&quot;]]</span><br></pre></td></tr></table></figure>

<h3 id="其他行列操作"><a href="#其他行列操作" class="headerlink" title="其他行列操作"></a>其他行列操作</h3><p>添加行和列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info[&#x27;rank1&#x27;] = [1,2,3,4]</span><br><span class="line">fruit_info.loc[:,&#x27;rank2&#x27;] = [1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>使用 <code>.drop()</code>方法来 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html">删除</a> 这两个 <code>rank1</code>和 <code>rank2</code>您创建的列。 确保使用 <code>axis</code>参数正确。 注意 <code>drop</code>不会更改表，而是返回一个具有较少列或行的新表，除非您设置可选 <code>inplace</code>范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info</span><br><span class="line">fruit_info_original = fruit_info.drop([&#x27;rank1&#x27;,&#x27;rank2&#x27;],axis=1)</span><br><span class="line">fruit_info_original</span><br></pre></td></tr></table></figure>

<p>重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info_caps=fruit_info_original.rename(columns=&#123;&#x27;fruit&#x27;:&#x27;F&#x27;,&#x27;color&#x27;:&#x27;C&#x27;,&#x27;price&#x27;:&#x27;P&#x27;&#125;)</span><br><span class="line">fruit_info_caps</span><br></pre></td></tr></table></figure>

<h3 id="布尔数组筛选和查询"><a href="#布尔数组筛选和查询" class="headerlink" title="布尔数组筛选和查询"></a>布尔数组筛选和查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = baby_names[(baby_names[&#x27;Year&#x27;]==2000) &amp; (baby_names[&#x27;Count&#x27;]&gt;3000)]</span><br><span class="line">result_using_query = baby_names.query(&#x27;Year==2000 &amp; Count&gt;3000&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="slides实例"><a href="#slides实例" class="headerlink" title="slides实例"></a>slides实例</h3><p>提取列数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections[&quot;Candidate&quot;].tail(5).to_frame()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提取目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For row labels, use DataFrame.index:</span><br><span class="line">For column labels, use DataFrame.columns:</span><br></pre></td></tr></table></figure>

<p>支持布尔数组检索<br><img src="/assets/jupyter%20notbook/image-20230924090511103.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections[elections[&quot;Party&quot;] == &quot;Independent&quot;]</span><br><span class="line">elections[(elections[&quot;Result&quot;] == &quot;win&quot;) &amp; (elections[&quot;%&quot;] &lt; 47)]</span><br></pre></td></tr></table></figure>

<p>支持用其他数组检索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a_parties = [&quot;Anti-Masonic&quot;, &quot;American&quot;, &quot;Anti-Monopoly&quot;, &quot;American Independent&quot;]</span><br><span class="line">elections[elections[&quot;Party&quot;].isin(a_parties)]</span><br></pre></td></tr></table></figure>

<p>查询类似sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections.query(&#x27;Result == &quot;win&quot; and Party not in @parties&#x27;)</span><br></pre></td></tr></table></figure>

<p>匿名函数辅助查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What if we wanted to find the longest names in California?</span><br><span class="line">babynames.query(&#x27;Sex == &quot;M&quot; and Year == 2020&#x27;)</span><br><span class="line">.sort_values(&quot;Name&quot;, key = lambda x: x.str.len(),</span><br><span class="line">ascending = False)</span><br></pre></td></tr></table></figure>

<p>创建删除列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">babyname_lengths = babynames[&quot;Name&quot;].str.len()</span><br><span class="line">#add that series to the dataframe as a column</span><br><span class="line">babynames[&quot;name_lengths&quot;] = babyname_lengths</span><br><span class="line">babynames = babynames.sort_values(by = &quot;name_lengths&quot;, ascending=False)</span><br><span class="line">babynames = babynames.drop(&quot;name_lengths&quot;, axis = &#x27;columns&#x27;)//删除列(默认为行)</span><br></pre></td></tr></table></figure>

<p>map方法使用函数统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def dr_ea_count(string):</span><br><span class="line">return string.count(&#x27;dr&#x27;) + string.count(&#x27;ea&#x27;)</span><br><span class="line">babynames[&quot;dr_ea_count&quot;] = babynames[&quot;Name&quot;].map(dr_ea_count)</span><br><span class="line">babynames = babynames.sort_values(by = &quot;dr_ea_count&quot;, ascending=False)</span><br></pre></td></tr></table></figure>

<p>字典创建表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#build dictionary where each entry is the rtp for a given name</span><br><span class="line">#e.g. rtps[&quot;jennifer&quot;] should be 0.0231</span><br><span class="line">rtps = &#123;&#125;</span><br><span class="line">for name in babynames[&quot;Name&quot;].unique():</span><br><span class="line">counts_of_current_name = female_babynames[female_babynames[&quot;Name&quot;] == name][&quot;Count&quot;]</span><br><span class="line">rtps[name] = ratio_to_peak(counts_of_current_name)</span><br><span class="line">#convert to series</span><br><span class="line">rtps = pd.Series(rtps)</span><br></pre></td></tr></table></figure>

<p>使用group建立新表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">female_babynames.groupby(&quot;Name&quot;).agg(ratio_to_peak)</span><br></pre></td></tr></table></figure>

<p><img src="/assets/jupyter%20notbook/image-20230924092636108.png"><br>groupby的其他用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given a DataFrameGroupBy object, can use various functions to generate DataFrames (or</span><br><span class="line">Series). agg is only one choice:</span><br><span class="line">● agg: Creates a new DataFrame with one aggregated row per subframe.</span><br><span class="line">● max: Creates a new DataFrame aggregated using the max function.</span><br><span class="line">● size: Creates a new Series with the size of each subframe.</span><br><span class="line">● filter: Creates a copy of the original DataFrame, but keeping only rows from subframes</span><br><span class="line">that obey the provided condition.</span><br></pre></td></tr></table></figure>

<p>合并表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">merged = pd.merge(left = elections, right = male_2020_babynames,</span><br><span class="line">left_on = &quot;First Name&quot;, right_on = &quot;Name&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据科学</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>基于北大前沿计算实践课和missing semester的linux等编程工具笔记</title>
    <url>/2023/09/23/linux%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://en.wikipedia.org/wiki/Linux">Linux</a>是一群<strong>开源</strong>的、基于<strong>Linux内核</strong>的<strong>类Unix操作系统</strong>集合。</p>
<ul>
<li>操作系统(operating system)：管理计算机硬件和软件资源的程序，为用户程序提供硬件抽象和接口。</li>
<li>操作系统内核(operating system kernel)：操作系统最核心的部分，管理系统的进程、内存、设备驱动程序、文件和网络系统，一直在内存中，不包括图形界面、Shell等功能</li>
<li>Shell：内核的封装，为用户提供更高级的抽象，比如<code>echo</code>、<code>ls</code>、<code>cd</code>等命令，以及进程间通信功能（管道）<span id="more"></span></li>
<li>Unix内核：最早形成规模，被广泛使用的操作系统，由肯•汤普森(Ken Thompson)和丹尼斯•里奇(Dennis Ritchie)发明，使用C编写，现在常用的基于UNIX内核的操作系统有<a href="https://www.oracle.com/solaris/solaris11/">Solaris</a>、<a href="https://www.freebsd.org/">FreeBSD</a></li>
<li>Linux内核：由李纳斯•托瓦兹(Linus Torvalds)在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版UNIX操作系统Minix太难用了，于是决定自己开发一个操作系统。第1版本于1991年9月发布，当时仅有10000行代码。李纳斯•托瓦兹没有保留Linux源代码的版权，公开了代码，并邀请他人一起完善Linux。据估计，现在只有2%的Linux核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有Linux内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权(Benevolent dictator for life, BDFL)。</li>
</ul>
<h2 id="shell的配置"><a href="#shell的配置" class="headerlink" title="shell的配置"></a>shell的配置</h2><p>很多程序的配置都是通过纯文本格式的被称作_点文件_的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p>
<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a> 有非常好的资源</p>
<p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH=&quot;$PATH:/path/to/program/bin&quot;</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p>
<p>还有一些其他的工具也可以通过_点文件_进行配置：</p>
<ul>
<li><code>bash</code> - <code>~/.bashrc</code>, <code>~/.bash_profile</code></li>
<li><code>git</code> - <code>~/.gitconfig</code></li>
<li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li>
<li><code>ssh</code> - <code>~/.ssh/config</code></li>
<li><code>tmux</code> - <code>~/.tmux.conf</code></li>
</ul>
<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p>
<ul>
<li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li>
<li><strong>可以执行</strong>: 您的工具在任何地方都以相同的配置工作</li>
<li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li>
<li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li>
<li>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</li>
</ul>
<p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"></span><br><span class="line"># 使用和 shell 相关的配置时先检查当前 shell 类型</span><br><span class="line">if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"></span><br><span class="line"># 您也可以针对特定的设备进行配置</span><br><span class="line">if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then &#123;do_something&#125;; fi</span><br></pre></td></tr></table></figure>

<p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure>

<p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Test if ~/.aliases exists and source it</span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>在Ubuntu下，我们也可以在网站上下载软件包，后缀为<code>.deb</code>，然后调用<code>dpkg</code>进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure>

<p><code>.deb</code>文件后缀是<a href="https://www.debian.org/">Debian</a>系统的 软件包格式，Ubuntu基于Debian开发因此使用相同的软件包格式，里面包含了程序的二进制文件、配置文件、man&#x2F;info帮助页面等信息。用户 不同的任务依赖大量的软件支撑，不同的软件往往有着复杂的依赖关系，一个软件往往也有很多版本，为了管理这么多的软件，Ubuntu提供了统一的软件管理 机制，也就是<code>dpkg</code>和<code>ap![[download.gif]]t</code>。 <code>dpkg</code>的用法如上所示，<code>dpkg -l</code>可以列出所有的以安装软件，<code>dpkg -r</code>卸载软件，更多命令可以使用<code>dpkg --help</code>或者<code>man dpkg</code>。dpkg安装完成之后，默认文件存放位置如下：</p>
<ul>
<li>二进制文件：<code>/usr/bin</code></li>
<li>库文件：<code>/usr/lib</code></li>
<li>配置文件：<code>/etc</code></li>
<li>使用手册和帮助文档：<code>/usr/share/doc</code></li>
<li>man帮助页面：<code>/usr/share/man</code></li>
</ul>
<p>然而dpkg并不是万能的，当某个软件的依赖项没有安装时dpkg就会报错，需要用户手动安装依赖项。apt很好地解决了这一问题。首先开发者会将 编译后的二进制文件和软件信息存放在Ubuntu的源服务器上，当需要安装软件时，apt会自动从服务器上获取软件依赖信息，然后从服务器上下载依赖并安 装，然后再安装需要的软件。服务器的信息记录在本地的<code>/etc/apt/sources.list</code>中：</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash中的字符串通过<code>&#39;</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。以<code>&#39;</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 _进程替换_（_process substitution_）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找所有名称为src的文件夹</span><br><span class="line">find . -name src -type d</span><br><span class="line"># 查找所有文件夹路径中包含test的python文件</span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"># 查找前一天修改的所有文件</span><br><span class="line">find . -mtime -1</span><br><span class="line"># 查找所有大小在500k至10M的tar.gz文件</span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除全部扩展名为.tmp 的文件</span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"># 查找全部的 PNG 文件并将其转换为 JPG</span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure>

<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name &#39;*PATTERN*&#39;</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h3><p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。<br>它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：****</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找所有使用了 requests 库的文件</span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"># 查找所有的foo字符串，并打印其之后的5行</span><br><span class="line">rg foo -A 5</span><br><span class="line"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure>

<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><h3 id="建立别名"><a href="#建立别名" class="headerlink" title="建立别名"></a>建立别名</h3><p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias alias_name=&quot;command_to_alias arg1 arg2&quot;</span><br></pre></td></tr></table></figure>

<p>注意， <code>=</code>两边是没有空格的，因为 <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p>
<p>别名有许多很方便的特性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建常用命令的缩写</span><br><span class="line">alias ll=&quot;ls -lh&quot;</span><br><span class="line"></span><br><span class="line"># 能够少输入很多</span><br><span class="line">alias gs=&quot;git status&quot;</span><br><span class="line">alias gc=&quot;git commit&quot;</span><br><span class="line">alias v=&quot;vim&quot;</span><br><span class="line"></span><br><span class="line"># 手误打错命令也没关系</span><br><span class="line">alias sl=ls</span><br><span class="line"></span><br><span class="line"># 重新定义一些命令行的默认行为</span><br><span class="line">alias mv=&quot;mv -i&quot;           # -i prompts before overwrite</span><br><span class="line">alias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed</span><br><span class="line">alias df=&quot;df -h&quot;           # -h prints human readable format</span><br><span class="line"></span><br><span class="line"># 别名可以组合使用</span><br><span class="line">alias la=&quot;ls -A&quot;</span><br><span class="line">alias lla=&quot;la -l&quot;</span><br><span class="line"></span><br><span class="line"># 在忽略某个别名</span><br><span class="line">\ls</span><br><span class="line"># 或者禁用别名</span><br><span class="line">unalias la</span><br><span class="line"></span><br><span class="line"># 获取别名的定义</span><br><span class="line">alias ll</span><br><span class="line"># 会打印 ll=&#x27;ls -lh&#x27;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是<code>.bashrc</code> 或 <code>.zshrc</code>，</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>右击边框开启设置菜单<br><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。<br><a href="https://github.com/clvv/fasd"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a> 对文件和文件排序，也就是说它会同时针对频率（_frequency_）和时效（_recency_）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<h2 id="命令行环境"><a href="#命令行环境" class="headerlink" title="命令行环境"></a>命令行环境</h2><h3 id="默认环境变量"><a href="#默认环境变量" class="headerlink" title="默认环境变量"></a>默认环境变量</h3><p>因为Shell中定义的环境变量之后影响子进程，为了避免我们每次都需要在使用前定义环境变量，我们可以将这一设置写进<code>~/.bashrc</code>里，这个配置文件会在每次启动bash时执行。<code>~/.bashrc</code>中已经包含了很多配置，我们要做的就是在最后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HELLO=hello</span><br></pre></td></tr></table></figure>

<p>然后执行<code>source ~/.bashrc</code>，这样就可以在每次打开Shell的时候定义这一环境变量。利用这个机制，假如我们想把自定义的命令加入<code>PATH</code>中时就可以在<code>~/.bashrc</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/path/to/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>这样命令就会添加到Shell的搜索路径中。需要注意的一点是，如果使用的是zsh，需要修改的就不是<code>~/.bashrc</code>，而是<code>~/.zshrc</code></p>
<h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>
<p>此时就需要进行 _端口转发_。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p>
<p><strong>本地端口转发</strong> <img src="https://i.stack.imgur.com/a28N8.png" alt="Local Port Forwarding" title="本地端口转发"></p>
<p><strong>远程端口转发</strong> <img src="https://i.stack.imgur.com/4iK3b.png" alt="Remote Port Forwarding" title="远程端口转发"></p>
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>
<h3 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h3><p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p>
<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> 信号到进程。</p>
<p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code> 信号，通过输入<code>Ctrl-\</code>可以发送该信号。<br>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。<br>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p>
<p>我们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code> ，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，您可以使用终端多路复用器来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"></span><br><span class="line">$ nohup sleep 2000 &amp;</span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ bg %1</span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -STOP %1</span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %1</span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %2</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill %2</span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>
<h3 id="tmux多路终端复用"><a href="#tmux多路终端复用" class="headerlink" title="tmux多路终端复用"></a>tmux多路终端复用</h3><p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>
<p>像 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a> 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p>
<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>
<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p>
<p>现在最流行的终端多路器是 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>
<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p>
<ul>
<li><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口<ul>
<li><code>tmux</code> 开始一个新的会话</li>
<li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li>
<li><code>tmux ls</code> 列出当前所有会话</li>
<li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</li>
<li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li>
</ul>
</li>
<li><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分<ul>
<li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code>关闭</li>
<li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的</li>
<li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li>
<li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li>
<li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li>
<li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li>
</ul>
</li>
<li><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell<ul>
<li><code>&lt;C-b&gt; &quot;</code> 水平分割</li>
<li><code>&lt;C-b&gt; %</code> 垂直分割</li>
<li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键</li>
<li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li>
<li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li>
<li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li>
</ul>
</li>
</ul>
<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></table></figure>

<p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p>
<h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。 <code>ssh foobar@server ls</code> 可以直接在用foobar的命令下执行 <code>ls</code> 命令。 想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p>
<h4 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h4><p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p>
<h4 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h4><p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>

<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h4 id="基于密钥的认证机制"><a href="#基于密钥的认证机制" class="headerlink" title="基于密钥的认证机制"></a>基于密钥的认证机制</h4><p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>

<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h3 id="G-基于密钥的认证机制"><a href="#G-基于密钥的认证机制" class="headerlink" title="G# 基于密钥的认证机制"></a>G# 基于密钥的认证机制</h3><p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat .ssh/id_ed25519 | ssh foobar@remote &#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br></pre></td></tr></table></figure>

<p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></table></figure>

<h2 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h2><ul>
<li>当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>&#123;&#125;</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
<li>![[Pasted image 20230128155221.png]]</li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code> 除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>擅长文本处理的编程语言<br><code>&#123;print $2&#125;</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名<br>让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| awk &#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27; | wc -l</span><br></pre></td></tr></table></figure>

<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是<code>&#123;...&#125;</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN &#123; rows = 0 &#125;</span><br><span class="line">$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; rows += $1 &#125;</span><br><span class="line">END &#123; print rows &#125;</span><br></pre></td></tr></table></figure>

<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。</p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>即便守护进程（daemon）这个词看上去有些陌生，你应该已经大约明白它的概念。大部分计算机都有一系列在后台保持运行，不需要用户手动运行或者交互的进程。这些进程就是守护进程。以守护进程运行的程序名一般以 <code>d</code> 结尾，比如 SSH 服务端 <code>sshd</code>，用来监听传入的 SSH 连接请求并对用户进行鉴权。</p>
<p>Linux 中的 <code>systemd</code>（the system daemon）是最常用的配置和运行守护进程的方法。运行 <code>systemctl status</code> 命令可以看到正在运行的所有守护进程。这里面有很多可能你没有见过，但是掌管了系统的核心部分的进程：管理网络、DNS解析、显示系统的图形界面等等。用户使用 <code>systemctl</code> 命令和 <code>systemd</code> 交互来<code>enable</code>（启用）、<code>disable</code>（禁用）、<code>start</code>（启动）、<code>stop</code>（停止）、<code>restart</code>（重启）、或者<code>status</code>（检查）配置好的守护进程及系统服务。</p>
<p><code>systemd</code> 提供了一个很方便的界面用于配置和启用新的守护进程或系统服务。下面的配置文件使用了守护进程来运行一个简单的 Python 程序。文件的内容非常直接所以我们不对它详细阐述。<code>systemd</code> 配置文件的详细指南可参见 <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">freedesktop.org</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/systemd/system/myapp.service</span><br><span class="line">[Unit]</span><br><span class="line"># 配置文件描述</span><br><span class="line">Description=My Custom App</span><br><span class="line"># 在网络服务启动后启动该进程</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"># 运行该进程的用户</span><br><span class="line">User=foo</span><br><span class="line"># 运行该进程的用户组</span><br><span class="line">Group=foo</span><br><span class="line"># 运行该进程的根目录</span><br><span class="line">WorkingDirectory=/home/foo/projects/mydaemon</span><br><span class="line"># 开始该进程的命令</span><br><span class="line">ExecStart=/usr/bin/local/python3.7 app.py</span><br><span class="line"># 在出现错误时重启该进程</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"># 相当于Windows的开机启动。即使GUI没有启动，该进程也会加载并运行</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"># 如果该进程仅需要在GUI活动时运行，这里应写作：</span><br><span class="line"># WantedBy=graphical.target</span><br><span class="line"># graphical.target在multi-user.target的基础上运行和GUI相关的服务</span><br></pre></td></tr></table></figure>

<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>任何没有备份的数据都可能在一个瞬间永远消失。复制数据很简单，但是可靠地备份数据很难。下面列举了一些关于备份的基础知识，以及一些常见做法容易掉进的陷阱。</p>
<p>首先，复制存储在同一个磁盘上的数据不是备份，因为这个磁盘是一个单点故障（single point of failure）。这个磁盘一旦出现问题，所有的数据都可能丢失。放在家里的外置磁盘因为火灾、抢劫等原因可能会和源数据一起丢失，所以是一个弱备份。推荐的做法是将数据备份到不同的地点存储。</p>
<p>同步方案也不是备份。即使方便如 Dropbox 或者 Google Drive，当数据在本地被抹除或者损坏，同步方案可能会把这些“更改”同步到云端。同理，像 RAID 这样的磁盘镜像方案也不是备份。它不能防止文件被意外删除、损坏、或者被勒索软件加密。</p>
<p>有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。对备份的数据实施版本控制保证了用户可以从任何记录过的历史版本中恢复数据。在备份中检测并删除重复数据，使其仅备份增量变化可以减少存储开销。在安全性方面，作为用户，你应该考虑别人需要有什么信息或者工具才可以访问或者完全删除你的数据及备份。最后一点，不要盲目信任备份方案。用户应该经常检查备份是否可以用来恢复数据。</p>
<p>备份不限制于备份在本地计算机上的文件。云端应用的重大发展使得我们很多的数据只存储在云端。当我们无法登录这些应用，在云端存储的网络邮件，社交网络上的照片，流媒体音乐播放列表，以及在线文档等等都会随之丢失。用户应该有这些数据的离线备份，而且已经有项目可以帮助下载并存储它们。</p>
<h2 id="常见命令行标志参数及模式"><a href="#常见命令行标志参数及模式" class="headerlink" title="常见命令行标志参数及模式"></a>常见命令行标志参数及模式</h2><p>命令行工具的用法千差万别，阅读 <code>man</code> 页面可以帮助你理解每种工具的用法。即便如此，下面我们将介绍一下命令行工具一些常见的共同功能。</p>
<ul>
<li><p>大部分工具支持 <code>--help</code> 或者类似的标志参数（flag）来显示它们的简略用法。</p>
</li>
<li><p>会造成不可撤回操作的工具一般会提供“空运行”（dry run）标志参数，这样用户可以确认工具真实运行时会进行的操作。这些工具通常也会有“交互式”（interactive）标志参数，在执行每个不可撤回的操作前提示用户确认。</p>
</li>
<li><p><code>--version</code> 或者 <code>-V</code> 标志参数可以让工具显示它的版本信息（对于提交软件问题报告非常重要）。</p>
</li>
<li><p>基本所有的工具支持使用 <code>--verbose</code> 或者 <code>-v</code> 标志参数来输出详细的运行信息。多次使用这个标志参数，比如 <code>-vvv</code>，可以让工具输出更详细的信息（经常用于调试）。同样，很多工具支持 <code>--quiet</code> 标志参数来抑制除错误提示之外的其他输出。</p>
</li>
<li><p>大多数工具中，使用 <code>-</code> 代替输入或者输出文件名意味着工具将从标准输入（standard input）获取所需内容，或者向标准输出（standard output）输出结果。</p>
</li>
<li><p>会造成破坏性结果的工具一般默认进行非递归的操作，但是支持使用“递归”（recursive）标志函数（通常是 <code>-r</code>）。</p>
</li>
<li><p>有的时候你可能需要向工具传入一个 <em>看上去</em> 像标志参数的普通参数，比如：</p>
<ul>
<li><p>使用 <code>rm</code> 删除一个叫 <code>-r</code> 的文件；</p>
</li>
<li><p>在通过一个程序运行另一个程序的时候（<code>ssh machine foo</code>），向内层的程序（<code>foo</code>）传递一个标志参数。</p>
<p>这时候你可以使用特殊参数 <code>--</code> 让某个程序 <em>停止处理</em> <code>--</code> 后面出现的标志参数以及选项（以 <code>-</code> 开头的内容）：</p>
</li>
<li><p><code>rm -- -r</code> 会让 <code>rm</code> 将 <code>-r</code> 当作文件名；</p>
</li>
<li><p><code>ssh machine --for-ssh -- foo --for-foo</code> 的 <code>--</code> 会让 <code>ssh</code> 知道 <code>--for-foo</code> 不是 <code>ssh</code> 的标志参数。</p>
</li>
</ul>
</li>
</ul>
<h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><h3 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h3><p>在我们使用<code>strace</code>调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p>
<p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）。下面是关于常见命令的简介：</p>
<ul>
<li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li>
<li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li>
<li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li>
<li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li>
</ul>
<h3 id="资源监控"><a href="#资源监控" class="headerlink" title="资源监控"></a>资源监控</h3><p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。</p>
<ul>
<li><strong>通用监控</strong> - 最流行的工具要数 <a href="https://htop.dev/"><code>htop</code></a>,了，它是 <a href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a>的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、 <code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。 还可以留意一下 <a href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I&#x2F;O、网络、 CPU 利用率、上下文切换等等；</li>
<li><strong>I&#x2F;O 操作</strong> - <a href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I&#x2F;O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li>
<li><strong>磁盘使用</strong> - <a href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的 <code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；</li>
<li><strong>内存使用</strong> - <a href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</li>
<li><strong>打开文件</strong> - <a href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a> 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</li>
<li><strong>网络连接和配置</strong> - <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 <a href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</li>
<li><strong>网络使用</strong> - <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对网络占用进行监控的交互式命令行工具。</li>
</ul>
<p>如果您希望测试一下这些工具，您可以使用 <a href="https://linux.die.net/man/1/stress"><code>stress</code></a> 命令来为系统人为地增加负载。</p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="source-script-sh-和-script-sh-有什么区别"><a href="#source-script-sh-和-script-sh-有什么区别" class="headerlink" title="source script.sh 和 ./script.sh 有什么区别?"></a><code>source script.sh</code> 和 <code>./script.sh</code> 有什么区别?</h3><p>这两种情况 <code>script.sh</code> 都会在bash会话中被读取和执行，不同点在于哪个会话执行这个命令。 对于 <code>source</code> 命令来说，命令是在当前的bash会话中执行的，因此当 <code>source</code> 执行完毕，对当前环境的任何更改（例如更改目录或是定义函数）都会留存在当前会话中。 单独运行 <code>./script.sh</code> 时，当前的bash会话将启动新的bash会话（实例），并在新实例中运行命令 <code>script.sh</code>。 因此，如果 <code>script.sh</code> 更改目录，新的bash会话（实例）会更改目录，但是一旦退出并将控制权返回给父bash会话，父会话仍然留在先前的位置（不会有目录的更改）。 同样，如果 <code>script.sh</code> 定义了要在终端中访问的函数，需要用 <code>source</code> 命令在当前bash会话中定义这个函数。否则，如果你运行 <code>./script.sh</code>，只有新的bash会话（进程）才能执行定义的函数，而当前的shell不能。</p>
<h3 id="各种软件包和工具存储在哪里？引用过程是怎样的-bin-或-lib-是什么？"><a href="#各种软件包和工具存储在哪里？引用过程是怎样的-bin-或-lib-是什么？" class="headerlink" title="各种软件包和工具存储在哪里？引用过程是怎样的? /bin 或 /lib 是什么？"></a>各种软件包和工具存储在哪里？引用过程是怎样的? <code>/bin</code> 或 <code>/lib</code> 是什么？</h3><p>根据你在命令行中运行的程序，这些包和工具会全部在 <code>PATH</code> 环境变量所列出的目录中查找到， 你可以使用 <code>which</code> 命令(或是 <code>type</code> 命令)来检查你的shell在哪里发现了特定的程序。 一般来说，特定种类的文件存储有一定的规范，<a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">文件系统，层次结构标准（Filesystem, Hierarchy Standard）</a>可以查到我们讨论内容的详细列表。</p>
<ul>
<li><code>/bin</code> - 基本命令二进制文件</li>
<li><code>/sbin</code> - 基本的系统二进制文件，通常是root运行的</li>
<li><code>/dev</code> - 设备文件，通常是硬件设备接口文件</li>
<li><code>/etc</code> - 主机特定的系统配置文件</li>
<li><code>/home</code> - 系统用户的主目录</li>
<li><code>/lib</code> - 系统软件通用库</li>
<li><code>/opt</code> - 可选的应用软件</li>
<li><code>/sys</code> - 包含系统的信息和配置(<a href="https://missing-semester-cn.github.io/2020/course-shell/">第一堂课</a>介绍的)</li>
<li><code>/tmp</code> - 临时文件( <code>/var/tmp</code> ) 通常重启时删除</li>
<li><code>/usr/</code> - 只读的用户数据<ul>
<li><code>/usr/bin</code> - 非必须的命令二进制文件</li>
<li><code>/usr/sbin</code> - 非必须的系统二进制文件，通常是由root运行的</li>
<li><code>/usr/local/bin</code> - 用户编译程序的二进制文件</li>
</ul>
</li>
<li><code>/var</code> -变量文件 像日志或缓存</li>
<li>## 我应该用 <code>apt-get install</code> 还是 <code>pip install</code> 去下载软件包呢?</li>
</ul>
<p>这个问题没有普遍的答案。这与使用系统程序包管理器还是特定语言的程序包管理器来安装软件这一更笼统的问题相关。需要考虑的几件事：</p>
<ul>
<li><p>常见的软件包都可以通过这两种方法获得，但是小众的软件包或较新的软件包可能不在系统程序包管理器中。在这种情况下，使用特定语言的程序包管理器是更好的选择。</p>
</li>
<li><p>同样，特定语言的程序包管理器相比系统程序包管理器有更多的最新版本的程序包。</p>
</li>
<li><p>当使用系统软件包管理器时，将在系统范围内安装库。如果出于开发目的需要不同版本的库，则系统软件包管理器可能不能满足你的需要。对于这种情况，大多数编程语言都提供了隔离或虚拟环境，因此你可以用特定语言的程序包管理器安装不同版本的库而不会发生冲突。对于 Python，可以使用 virtualenv，对于 Ruby，使用 RVM 。</p>
</li>
<li><p>根据操作系统和硬件架构，其中一些软件包可能会附带二进制文件或者软件包需要被编译。例如，在树莓派（Raspberry Pi）之类的ARM架构计算机中，在软件附带二进制文件和软件包需要被编译的情况下，使用系统包管理器比特定语言包管理器更好。这在很大程度上取决于你的特定设置。 你应该仅使用一种解决方案，而不同时使用两种方法，因为这可能会导致难以解决的冲突。我们的建议是尽可能使用特定语言的程序包管理器，并使用隔离的环境（例如 Python 的 virtualenv）以避免影响全局环境</p>
</li>
<li><h3 id="Docker和虚拟机有什么区别"><a href="#Docker和虚拟机有什么区别" class="headerlink" title="Docker和虚拟机有什么区别?"></a>Docker和虚拟机有什么区别?</h3></li>
</ul>
<p>Docker 基于容器这个更为概括的概念。关于容器和虚拟机之间最大的不同是，虚拟机会执行整个的 OS 栈，包括内核（即使这个内核和主机内核相同）。与虚拟机不同，容器避免运行其他内核实例，而是与主机分享内核。在Linux环境中，有LXC机制来实现，并且这能使一系列分离的主机像是在使用自己的硬件启动程序，而实际上是共享主机的硬件和内核。因此容器的开销小于完整的虚拟机。</p>
<p>另一方面，容器的隔离性较弱而且只有在主机运行相同的内核时才能正常工作。例如，如果你在macOS 上运行 Docker，Docker 需要启动 Linux虚拟机去获取初始的 Linux内核，这样的开销仍然很大。最后，Docker 是容器的特定实现，它是为软件部署而定制的。基于这些，它有一些奇怪之处：例如，默认情况下，Docker 容器在重启之间不会有以任何形式的存储。</p>
<h3 id="还有更多的-Vim-小窍门吗？"><a href="#还有更多的-Vim-小窍门吗？" class="headerlink" title="还有更多的 Vim 小窍门吗？"></a>还有更多的 Vim 小窍门吗？</h3><p>更多的窍门：</p>
<ul>
<li>插件 - 花时间去探索插件。有很多不错的插件修复了vim的缺陷或者增加了能够与现有vim工作流结合的新功能。关于这部分内容，资源是<a href="https://vimawesome.com/">VimAwesome</a> 和其他程序员的dotfiles。</li>
<li>标记 - 在vim里你可以使用 <code>m&lt;X&gt;</code> 为字母 <code>X</code> 做标记，之后你可以通过 <code>&#39;&lt;X&gt;</code> 回到标记位置。这可以让你快速定位到文件内或文件间的特定位置。</li>
<li>导航 - <code>Ctrl+O</code> 和 <code>Ctrl+I</code> 命令可以使你在最近访问位置前后移动。</li>
<li>撤销树 - vim 有不错的更改跟踪机制，不同于其他的编辑器，vim存储变更树，因此即使你撤销后做了一些修改，你仍然可以通过撤销树的导航回到初始状态。一些插件比如 <a href="https://github.com/sjl/gundo.vim">gundo.vim</a> 和 <a href="https://github.com/mbbill/undotree">undotree</a> 通过图形化来展示撤销树。</li>
<li>时间撤销 - <code>:earlier</code> 和 <code>:later</code> 命令使得你可以用时间而非某一时刻的更改来定位文件。</li>
<li><a href="https://vim.fandom.com/wiki/Using_undo_branches#Persistent_undo">持续撤销</a> - 是一个默认未被开启的vim的内置功能，它在vim启动之间保存撤销历史，需要配置在 <code>.vimrc</code> 目录下的<code>undofile</code> 和 <code>undodir</code>，vim会保存每个文件的修改历史。</li>
<li>热键（Leader Key） - 热键是一个用于用户自定义配置命令的特殊按键。这种模式通常是按下后释放这个按键（通常是空格键）并与其他的按键组合去实现一个特殊的命令。插件也会用这些按键增加它们的功能，例如，插件UndoTree使用 <code>&lt;Leader&gt; U</code> 去打开撤销树。</li>
<li>高级文本对象 - 文本对象比如搜索也可以用vim命令构成。例如，<code>d/&lt;pattern&gt;</code> 会删除下一处匹配 pattern 的字符串，<code>cgn</code> 可以用于更改上次搜索的关键字。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>编程工具</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>基于斯坦福cs106b的c++数据结构笔记</title>
    <url>/2023/09/23/cs106b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一些查找和排序算法"><a href="#一些查找和排序算法" class="headerlink" title="一些查找和排序算法"></a>一些查找和排序算法</h2><p>二分查找法<br><img src="/images/obsidian/20230226101843.png" alt="图片" title="image"><br>最坏情况：log2n</p>
<span id="more"></span>
<p>寻找最小排序<br><img src="/images/obsidian/20230224172126.png" alt="图片" title="image"><br>向前插入算法<br><img src="/images/obsidian/20230226090109.png" alt="图片" title="image"></p>
<p>合并算法接受两个排序的 列出并将它们组合成一个 排序列表。 ● 虽然两个列表都是非空的，但比较它们的 第一要素。 删除较小的元素 并将其附加到输出。 ● 一旦一个列表为空，添加所有元素 另一个列表输出。 ● 它运行时间为 O(n)，其中 n 是总数 合并的元素数量。<br><img src="/images/obsidian/20230226090958.png" alt="图片" title="image"><br>无限递归后的合并算法<br><img src="/images/obsidian/20230226093232.png" alt="图片" title="image"><br>复杂度：nlog2n</p>
<h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p><code>set（集合）：无序不允许重复的容器类，可以添加删除元素 You can add a value to a Set by writing   set += value;  s. ● You can remove a value from a Set by writing   set -= value;   ● You can check if a value exists in a Set by writing   set.contains(value) </code>map(键值对的集合)<br>如果没有对应key的value，返回默认值（见定义文件）<br>&#96;vector<br>vector的remove根据移除元素的索引有1-n的复杂度，移除尾部为O(1)，如果不在意索引，可以交换要移除元素和尾部元素再移除</p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表的负载因子α表示元素和表格键数量的比，决定了查找速度</p>
<h2 id="检查表中是否存在元素"><a href="#检查表中是否存在元素" class="headerlink" title="检查表中是否存在元素"></a>检查表中是否存在元素</h2><p>● 计算元素的散列码。<br>● 跳转到表格中的那个位置。<br>● 向前扫描——必要时环绕——直到项目或一个 发现空插槽。</p>
<h2 id="将元素插入表中"><a href="#将元素插入表中" class="headerlink" title="将元素插入表中"></a>将元素插入表中</h2><p>● 如果项目已经存在，什么也不做。<br>● 否则，跳转到元素哈希码给定的槽。 向前走——必要时环绕——直到一个空白点或 找到墓碑插槽。 然后，将项目放在那里。</p>
<h2 id="从表中删除一个元素"><a href="#从表中删除一个元素" class="headerlink" title="从表中删除一个元素"></a>从表中删除一个元素</h2><p>● 跳转到由元素的散列码给定的槽。<br>● 向前走——必要时环绕——直到物品或 发现空插槽。 如果找到该项目，请将其替换为 墓碑。</p>
<h2 id="“罗宾汉哈希表”"><a href="#“罗宾汉哈希表”" class="headerlink" title="“罗宾汉哈希表”"></a>“罗宾汉哈希表”</h2><ul>
<li>如果插入的值比其将插入的位置的值距离索引更远，则替换插入值和当前值</li>
<li>删除值时，将后其离原键远的元素前移</li>
<li>★ 罗宾汉哈希一览 ★</li>
<li>检查表中是否存在元素：</li>
<li>● 跳转到表中由元素的散列码给出的位置。</li>
<li>● 向前扫描——如有必要环绕——记录有多少步 你拿走了。 当您找到该项目、找到一个空白槽或找到一个 离家更近的空位比你走的步数还多。</li>
<li>将元素插入表中：</li>
<li>● 如果该元素已在表中，则什么也不做。</li>
<li>● 跳转到由元素的散列码给出的表槽。 向前扫描 - 换行 如有必要，四处走走——记录所走的步数。 如果你找到一个 空插槽，将元素放在那里。 否则，如果当前插槽已满并且 比您插入的元素更靠近家，将要插入的项目放在那里， 替换那个位置的元素，然后继续插入，就好像你 正在插入被置换的元素。</li>
<li>从表中删除一个元素：</li>
<li>● 跳转到由元素的散列码给定的槽。</li>
<li>● 向前走——如有必要，环绕——直到物品或空槽被放置 成立。 如果找到该项目，请将其删除。 然后，继续前进——包裹 around as necessary – 将表中的元素向后移动一个槽位，直到 找到空插槽或位于其原始位置的项目</li>
</ul>
<h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p>str::npos表示容器的最后一个成员位置<br>if (s.find(“e”) !&#x3D; string::npos)<br>&#x2F;&#x2F;find函数找不到时返回npos<br>if s in str:<br>string obj;<br>obj.substr(int pos)   &#x2F;&#x2F;pos为要包含的第一个字符串的位置<br><a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> a &#x3D; “0123456789abcdefghij”;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    // count is npos, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub1 = a.substr(10);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub1 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // both pos and pos+count are within bounds, returns [pos, pos+count)</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub2 = a.substr(5, 3);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub2 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // pos is within bounds, pos+count is not, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub4 = a.substr(a.size()-3, 50);</span><br><span class="line">    // this is effectively equivalent to</span><br><span class="line">    // std::string sub4 = a.substr(17, 3);</span><br><span class="line">    // since a.size() == 20, pos == a.size()-3 == 17, and a.size()-pos == 3</span><br><span class="line"></span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub4 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // pos is out of bounds, throws</span><br><span class="line">        [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub5 = a.substr(a.size()+3, 50);</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub5 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125; catch(const [std::out_of_range](http://en.cppreference.com/w/cpp/error/out_of_range)&amp; e) &#123;</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; &quot;pos exceeds string size\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">abcdefghij</span><br><span class="line">567</span><br><span class="line">hij</span><br><span class="line">pos exceeds string size</span><br></pre></td></tr></table></figure>
<p>&#96;replace和insert<br>str1.insert(start, str2)<br>str1.replace(start, length, str2)</p>
<h2 id="一些实现"><a href="#一些实现" class="headerlink" title="一些实现"></a>一些实现</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &quot;HeapPQueue.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">HeapPQueue::HeapPQueue() &#123;</span><br><span class="line">    elems = new DataPoint[INITIAL_SIZE] &#123;&#125;;</span><br><span class="line">    for (int i=0;i&lt;INITIAL_SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[i].weight=0;</span><br><span class="line">    &#125;</span><br><span class="line">    allocatedSize=INITIAL_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapPQueue::~HeapPQueue() &#123;</span><br><span class="line">    delete [] elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int HeapPQueue::size() const &#123;</span><br><span class="line">    return logicalSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool HeapPQueue::isEmpty() const &#123;</span><br><span class="line">    return logicalSize==0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapPQueue::enqueue(const DataPoint&amp; data) &#123;</span><br><span class="line">    if (logicalSize+1&lt;allocatedSize)</span><br><span class="line">    &#123;</span><br><span class="line">        if (logicalSize==0)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[1]=data;</span><br><span class="line">            logicalSize++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            logicalSize++;</span><br><span class="line">            int i=1;</span><br><span class="line">            while (data.weight&gt;elems[i].weight &amp;&amp; i&lt;=logicalSize &amp;&amp; elems[i].weight!=0)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i&lt;logicalSize)</span><br><span class="line">            &#123;</span><br><span class="line">                DataPoint temp=elems[i];</span><br><span class="line">                elems[i]=data;</span><br><span class="line">                for(i;i&lt;logicalSize;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    DataPoint temp_plus=elems[i+1];</span><br><span class="line">                    elems[i+1]=temp;</span><br><span class="line">                    temp=temp_plus;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                elems[i]=data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::peek() const &#123;</span><br><span class="line">    return elems[logicalSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::dequeue() &#123;</span><br><span class="line">    DataPoint to_return=elems[1];</span><br><span class="line">    if(!isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (int i=1;i&lt;logicalSize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[i]=elems[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        elems[logicalSize]=&#123;&#125;;</span><br><span class="line">        logicalSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    return to_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>首先算出最大值，然后用一个数组的索引存储待排序数组的成员，其索引对应值存储出现次数，然后用两个同步的for循环和递增的next参数表示排序中的索引值来进行排序（也就是重新赋值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Given a Vector&lt;int&gt;, returns the largest number in that Vector. */</span><br><span class="line">int maxOf(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Bounds-check inputs. */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        error(&quot;Can&#x27;t find the maximum of no values.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = values[0];</span><br><span class="line">    for (int i = 1; i &lt; values.size(); i++) &#123;</span><br><span class="line">        result = max(result, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a list of numbers, creates a histogram from those numbers. */</span><br><span class="line">Vector&lt;int&gt; histogramFor(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Create a histogram with the right number of slots. Initially, all values</span><br><span class="line">     * in the histogram will be zero.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; histogram(maxOf(values) + 1);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the input vector, incrementing the histogram values. */</span><br><span class="line">    for (int value: values) &#123;</span><br><span class="line">        histogram[value]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return histogram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void countingSort(Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Edge Case: If the array is empty, then it&#x27;s already sorted. This is</span><br><span class="line">     * needed because we can&#x27;t take the maximum value of an empty vector.</span><br><span class="line">     */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Form the histogram. */</span><br><span class="line">    auto histogram = histogramFor(values);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the histogram writing out the appropriate number of copies</span><br><span class="line">     * of each value. We track the index of the next free spot to write to,</span><br><span class="line">     * as it varies based on how many items we&#x27;ve written out so far.</span><br><span class="line">     */</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (int value = 0; value &lt; histogram.size(); value++) &#123;</span><br><span class="line">        /* Write out the right number of copies. */</span><br><span class="line">        for (int copy = 0; copy &lt; histogram[value]; copy++) &#123;</span><br><span class="line">            values[next] = value;</span><br><span class="line">            next++;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><h3 id="递归的效率优化"><a href="#递归的效率优化" class="headerlink" title="递归的效率优化"></a>递归的效率优化</h3><p>每次递归都会创造所有变量的临时复制<br>基于递归的这种性质，它会需要巨大的时间和空间来完成任务，并且会造成算力上的浪费。<br>通过记忆表机制能部分解决这个问题，方法是每次递归的返回值都会按索引存入一个表格，并且每次递归前查询表格中是否有结果，这样可以让每个临时副本的运算结果能被所有函数共享。</p>
<h3 id="递归计算给定元素的不同结构哈夫曼树的数量"><a href="#递归计算给定元素的不同结构哈夫曼树的数量" class="headerlink" title="递归计算给定元素的不同结构哈夫曼树的数量"></a>递归计算给定元素的不同结构哈夫曼树的数量</h3><p>对每个给定元素集来说，首先要做到是确定根节点元素是第几个大的元素，确定之后，左子树和右子树的元素数也随之确定，在此之后分别对左节点和右节点作为根节点做同样的递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int numBSTsOfSize(int n) &#123;</span><br><span class="line"></span><br><span class="line">  /* Base case: There’s only one tree of size 0, namely, the empty BST. */</span><br><span class="line">  if (n == 0) return 1;</span><br><span class="line">  </span><br><span class="line">  /* Recursive case: Imagine all possible ways to choose a root and build the</span><br><span class="line">   * left and right subtrees.</span><br><span class="line">  */</span><br><span class="line">  int result = 0;</span><br><span class="line">  </span><br><span class="line">  /* Put the the nodes at indices 0, 1, 2, ..., n-1 up at the root. */</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    /* Each combination of a BST of i elements and a BST of n - 1 - i elements</span><br><span class="line">     * can be used to build one BST of n elements. The number of pairs of</span><br><span class="line">     * trees we can make this way is given by the product of the number of</span><br><span class="line">     * trees of each type.</span><br><span class="line">     */</span><br><span class="line">     result += numBSTsOfSize(i) * numBSTsOfSize(n - 1 - i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归解决吃巧克力问题"><a href="#递归解决吃巧克力问题" class="headerlink" title="递归解决吃巧克力问题"></a>递归解决吃巧克力问题</h3><h1 id="求出吃法数量"><a href="#求出吃法数量" class="headerlink" title="求出吃法数量"></a>求出吃法数量</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (numSquares&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">    error(&quot;输入数据不能为负数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (numSquares&lt;=1)</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    return numWaysToEat(numSquares-1)+numWaysToEat(numSquares-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印每种吃法"><a href="#打印每种吃法" class="headerlink" title="打印每种吃法"></a>打印每种吃法</h1><p>&#96;需要一个辅助向量储存历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Print all ways to eat numSquares more squares, given that we&#x27;ve</span><br><span class="line"> * already taken the bites given in soFar.</span><br><span class="line"> */</span><br><span class="line">void printWaysToEatRec(int numSquares, const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /* Base Case: If there are no squares left, the only option is to use</span><br><span class="line">     * the bites we&#x27;ve taken already in soFar.</span><br><span class="line">     */</span><br><span class="line">    if (numSquares == 0) &#123;</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If there is one square lfet, the only option is to eat</span><br><span class="line">     * that square.</span><br><span class="line">     */</span><br><span class="line">    else if (numSquares == 1) &#123;</span><br><span class="line">        cout &lt;&lt; soFar + 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Otherwise, we take take bites of size one or of size two. */</span><br><span class="line">    else &#123;</span><br><span class="line">        printWaysToEatRec(numSquares - 1, soFar + 1);</span><br><span class="line">        printWaysToEatRec(numSquares - 2, soFar + 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printWaysToEat(int numSquares) &#123;</span><br><span class="line">    if (numSquares &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me some chocolate!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We begin without having made any bites. */</span><br><span class="line">    printWaysToEatRec(numSquares, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决翻煎饼问题"><a href="#递归解决翻煎饼问题" class="headerlink" title="递归解决翻煎饼问题"></a>递归解决翻煎饼问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isSorted(Stack&lt;double&gt; pancakes) &#123;</span><br><span class="line">    double last = -1; // No pancakes have negative size;</span><br><span class="line"></span><br><span class="line">    while (!pancakes.isEmpty()) &#123;</span><br><span class="line">        /* Check the next pancake. */</span><br><span class="line">        double next = pancakes.pop();</span><br><span class="line">        if (next &lt; last) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Pancakes are in increasing order! */</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a stack of pancakes and a flip size, flips that many pancakes</span><br><span class="line"> * on the top of the stack.</span><br><span class="line"> */</span><br><span class="line">Stack&lt;double&gt; flip(Stack&lt;double&gt; pancakes, int numToFlip) &#123;</span><br><span class="line">    /* Take the top pancakes off the stack and run them into a queue.</span><br><span class="line">     * This preserves the order in which they were removed.</span><br><span class="line">     */</span><br><span class="line">    Queue&lt;double&gt; buffer;</span><br><span class="line">    for (int i = 0; i &lt; numToFlip; i++) &#123;</span><br><span class="line">        buffer.enqueue(pancakes.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Move the pancakes back. */</span><br><span class="line">    while (!buffer.isEmpty()) &#123;</span><br><span class="line">        pancakes.push(buffer.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pancakes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; sortStack(Stack&lt;double&gt; pancakes, int numFlips) &#123;</span><br><span class="line">    /* Base Case: If the stack is sorted, great! We&#x27;re done, and no flips</span><br><span class="line">     * were needed.</span><br><span class="line">     */</span><br><span class="line">    if (isSorted(pancakes)) &#123;</span><br><span class="line">        return &#123; &#125;; // No flips</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If the stack isn&#x27;t sorted and we&#x27;re out of flips, then</span><br><span class="line">     * there is no way to sort things.</span><br><span class="line">     */</span><br><span class="line">    else if (numFlips == 0) &#123;</span><br><span class="line">        return Nothing;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive Case: The stack isn&#x27;t sorted and we still have flips left.</span><br><span class="line">     * The next flip could flip 1, 2, 3, ..., or all N of the pancakes.</span><br><span class="line">     * Try each option and see whether any of them work.</span><br><span class="line">     */</span><br><span class="line">    for (int numToFlip = 1; numToFlip &lt;= pancakes.size(); numToFlip++) &#123;</span><br><span class="line">        /* Make the flip and see if it works. */</span><br><span class="line">        auto result = sortStack(flip(pancakes, numToFlip), numFlips - 1);</span><br><span class="line">        if (result != Nothing) &#123;</span><br><span class="line">            /* The result holds all the remaining flips but doesn&#x27;t know about</span><br><span class="line">             * the flip we just did. Insert that flip at the beginning.</span><br><span class="line">             */</span><br><span class="line">            result.value().insert(0, numToFlip);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we&#x27;re here, then no matter which flip we make first, we cannot</span><br><span class="line">     * get the pancakes sorted. Give up.</span><br><span class="line">     */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归解决天平问题"><a href="#递归解决天平问题" class="headerlink" title="递归解决天平问题"></a>递归解决天平问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isMeasurableRec(int amount, const Vector&lt;int&gt;&amp; weights, int index) &#123;</span><br><span class="line">  if (index == weights.size()) &#123;</span><br><span class="line">      return amount == 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      return isMeasurableRec(amount,                  weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount + weights[index], weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount - weights[index], weights, index + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMeasurable(int amount, const Vector&lt;int&gt;&amp; weights) &#123;</span><br><span class="line">    return isMeasurableRec(amount, weights, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象一下，我们首先将要测量的数量（称为 <em>n</em> ）放在天平的左侧。 这使得规模上的不平衡等于 <em>n</em> 。 想象一下，有某种方法可以测量 <em>n</em> 。 如果我们一次将一个重量放在秤上，我们可以查看第一个重量的放置位置（假设它的重量为 <em>w</em> ）。 它必须：</p>
<ul>
<li>向左走，使规模上的净不平衡 <em>n + w</em> ，或</li>
<li>向右走，使规模上的净不平衡 <em>n – w</em> ，或</li>
<li>根本不习惯，留下净不平衡 <em>n</em> 。</li>
</ul>
<p>如果确实有可能测量 <em>n</em> ，那么这三个选项之一必须是实现它的方法，即使我们不知道它是哪一个。 然后我们要问的问题是，是否有可能使用剩余的权重来衡量新的净失衡——我们可以递归地确定！ 另一方面，如果无法测量 <em>n</em> ，那么无论我们选择哪个选项，我们都会发现没有办法使用剩余的权重来使一切平衡！</p>
<p>如果我们递归地进行，我们在这里，我们需要考虑我们的基本情况。 我们可以选择的选项有很多。 一个简单的方法如下：假设我们根本没有任何重量，我们被要求查看是否可以不使用重量来测量某些重量。 在什么情况下我们可以这样做？ 好吧，如果我们称重的东西有一个非零重量，我们就不可能测量它——把它放在秤上会使它倾斜到某一边，但这并不能告诉我们它有多少重量。 另一方面，如果我们称量的东西是完全失重的，那么把它放在秤上也不会导致它倾斜，让我们相信它确实是失重的！ 因此，作为我们的基本情况，我们会说当我们减少到没有剩余权重时， <em>，我们可以精确测量n</em> 如果 <em>n &#x3D; 0</em> 。 考虑到这一点，这是我们的代码：</p>
<h3 id="递归解决找零问题"><a href="#递归解决找零问题" class="headerlink" title="递归解决找零问题"></a>递归解决找零问题</h3><h1 id="不使用记忆的情况"><a href="#不使用记忆的情况" class="headerlink" title="不使用记忆的情况"></a>不使用记忆的情况</h1><p>&#96;从第一个硬币开始遍历，并穷举它的所有枚数，将其作为下一枚硬币的参数传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    else if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (coins.isEmpty()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins.first();</span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsFor(cents - copies * coin,</span><br><span class="line">                                                     coins - coin);</span><br><span class="line">          /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用记忆进行优化"><a href="#使用记忆进行优化" class="headerlink" title="使用记忆进行优化"></a>使用记忆进行优化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* How few coins are needed to make the total, given that we can only use</span><br><span class="line"> * coins from index startIndex and onward?</span><br><span class="line"> */</span><br><span class="line">int fewestCoinsRec(int cents, const Vector&lt;int&gt;&amp; coins, int startIndex,Grid&lt;int&gt;&amp; memo) &#123;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (startIndex == coins.size()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: We already know the answer. */</span><br><span class="line">    else if (memo[cents][startIndex] != -1) &#123;</span><br><span class="line">        return memo[cents][startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line"></span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins[startIndex];</span><br><span class="line"></span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsRec(cents - copies * coin,</span><br><span class="line">                                                     coins, startIndex + 1,</span><br><span class="line">                                                     memo);</span><br><span class="line"></span><br><span class="line">            /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        memo[cents][startIndex] = bestSoFar;</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Convert from a Set&lt;int&gt; to a Vector&lt;int&gt; so we have a nice ordering</span><br><span class="line">     * on things.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; coinVec;</span><br><span class="line">    for (int coin: coins) &#123;</span><br><span class="line">        coinVec += coin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build our memoization table. Since the number of cents left ranges from</span><br><span class="line">     * 0 to cents, we need cents+1 rows. Since the start index of the coin</span><br><span class="line">     * ranges from 0 to coins.size(), we make coins.size() + 1 columns.</span><br><span class="line">     *</span><br><span class="line">     * -1 is used as a sentinel to indicate &quot;nothing has been computed here</span><br><span class="line">     * yet.&quot;</span><br><span class="line">     */</span><br><span class="line">    Grid&lt;int&gt; memo(cents + 1, coins.size() + 1, -1);</span><br><span class="line"></span><br><span class="line">    /* Now ask how many coins are needed to make the total, using any coins</span><br><span class="line">     * from index 0 onward.</span><br><span class="line">     */</span><br><span class="line">    return fewestCoinsRec(cents, coinVec, 0, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归穷举付账单"><a href="#递归穷举付账单" class="headerlink" title="递归穷举付账单"></a>递归穷举付账单</h3><p>递归机制：对第一个人来说，0-total所有金额都会付一遍，随后传递给下一个人，当只有一人时，付清所有余额并打印账单<br>传递参数：string,int的映射存储目前为止的账单，string集合存储所有付账者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void listPossiblePaymentsRec(int total, const Set&lt;string&gt;&amp; people,const Map&lt;string, int&gt;&amp; payments) &#123;</span><br><span class="line">    /* Base case: if there&#x27;s one person left, they have to pay the whole bill. */</span><br><span class="line">    if (people.size() == 1) &#123;</span><br><span class="line">        Map&lt;string, int&gt; finalPayments = payments;</span><br><span class="line">        finalPayments[people.first()] = total;</span><br><span class="line">        cout &lt;&lt; finalPayments &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: The first person has to pay some amount between 0 and the</span><br><span class="line">     * total amount. Try all of those possibilities.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int payment = 0; payment &lt;= total; payment++) &#123;</span><br><span class="line">            /* Create a new assignment of people to payments in which this first</span><br><span class="line">             * person pays this amount.</span><br><span class="line">             */</span><br><span class="line">            Map&lt;string, int&gt; updatedPayments = payments;</span><br><span class="line">            updatedPayments[people.first()] = payment;</span><br><span class="line">            listPossiblePaymentsRec(total - payment, people - people.first(),updatedPayments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void listPossiblePayments(int total, const Set&lt;string&gt;&amp; people) &#123;</span><br><span class="line">    /* Edge cases: we can&#x27;t pay a negative total, and there must be at least one</span><br><span class="line">     * person.</span><br><span class="line">     */</span><br><span class="line">    if (total &lt; 0) error(&quot;Guess you&#x27;re an employee?&quot;);</span><br><span class="line">    if (people.isEmpty()) error(&quot;Dine and dash?&quot;);</span><br><span class="line"> listPossiblePaymentsRec(total, people, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归寻找完全平方数列"><a href="#递归寻找完全平方数列" class="headerlink" title="递归寻找完全平方数列"></a>递归寻找完全平方数列</h3><p>主要参数为sofar——用于存储目前的序列和一个set用于存储还没放入数列的数字，&#96;确保这两者同时被传递，且其并集为所有数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSquareSequence(int n) &#123;</span><br><span class="line">    /*Validate input.*/</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        error(&quot;Don&#x27;t be so negative!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build a set of the numbers 1, 2, 3, ..., n. */</span><br><span class="line">    Set&lt;int&gt; options;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        options += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return findSequenceRec(options, &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSequenceRec(const Set&lt;int&gt;&amp; unused,</span><br><span class="line">                                      const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /*Base Case: If all numbers are used, we have our sequence!*/</span><br><span class="line">    if (unused.isEmpty()) &#123;</span><br><span class="line">        return soFar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Recursive Case: Some number comes next. Try each of them and see which</span><br><span class="line">     * one we should pick.</span><br><span class="line">     */</span><br><span class="line">    for (int next: unused) &#123;</span><br><span class="line">        /* We can use this if either</span><br><span class="line">         *</span><br><span class="line">         * 1. the sequence is empty, so we&#x27;re first in line, or</span><br><span class="line">         * 2. the sequence is not empty, but we sum to a perfect square</span><br><span class="line">         *    with the previous term.</span><br><span class="line">         */</span><br><span class="line">        if (soFar.isEmpty() ||</span><br><span class="line">            isPerfectSquare(next + soFar[soFar.size() - 1])) &#123;</span><br><span class="line">            /* See what happens if we extend with this number. */</span><br><span class="line">            auto result = findSequenceRec(unused - next, soFar + next);</span><br><span class="line">            if (result != Nothing) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Tried all options and none of them worked. Oh well! */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="汉诺塔递归"><a href="#汉诺塔递归" class="headerlink" title="汉诺塔递归"></a>汉诺塔递归</h3><p>假设有三座汉诺塔，<code>start ,temp ,finish</code><br>对n层的汉诺塔问题，先考虑n-1层的，随后考虑n-2层，到最后只需要考虑两层问题，两层的汉诺塔非常容易解决，起点为start,终点是temp,临时塔为finish，最后我们得到temp上的两层汉诺塔<br>这时将start的3移动到finish塔，这时只要将两层汉诺塔转移到finish则完成了三层汉诺塔，这个过程中的起点为temp,终点是finish,临时塔是start<br>以此类推，四层塔基于三层塔，<code>n</code>层塔基于<code>n-1</code>塔，汉诺塔问题解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int moveTower(int numDisks, char start, char finish, char temp) &#123;</span><br><span class="line">    if (numDisks == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int movesOne = moveTower(numDisks - 1, start, temp, finish);</span><br><span class="line">        moveSingleDisk(start, finish);</span><br><span class="line">        int movesTwo = moveTower(numDisks - 1, temp, finish, start);</span><br><span class="line"></span><br><span class="line">        return 1 + movesOne + movesTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于斯坦福cs106l的c++编程规范笔记</title>
    <url>/2023/09/21/cs106l%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="c-特性"><a href="#c-特性" class="headerlink" title="c++特性"></a>c++特性</h2><ul>
<li>更好的C<br>C++支持<code>命令式编程</code>，一种编程风格，其中程序按顺序执行的命令序列。从这个意义上讲，C++ 可以看作是对C 编程语言，使日常命令式编程更加直观和更容易使用。课程阅读器的这一部分介绍了一些 C++ 最常用的库,包括标准模板库，并展示了如何使用这些库来构建命令程式。 此外，它探索了最初出现在 C++ 语言中的新原语。C 编程语言，即指针、C 字符串和预处理器。<span id="more"></span></li>
<li>数据抽象</li>
</ul>
<p>C++与其兄弟C的最大区别在于_数据抽象_,程序执行的方式可以与程序执行的方式分开  程序员谈论那个程序。</p>
<ul>
<li>面向对象编程</li>
</ul>
<p>. 面向对象编程是一种完全不同的方式考虑程序设计，可以极大地简化复杂的软件系统。 钥匙  面向对象背后的概念很简单，但要真正体会到面向对象的力量  编程，您将需要一次又一次地看到它的运行情况。 这部分课程  读者探索了面向对象编程中的主要概念以及如何在 C++ 中实现它继承和多态。  </p>
<ul>
<li>泛型编程</li>
</ul>
<p>泛型编程是一种编程风格，旨在构建可以解决一系列远远超出最初设想的问题的软件<br>履行。 虽然泛型编程的完整处理远远超出了介绍性的范围C++ 编程课，泛型编程的许多思想都可以访问并且可以从根本上改变了您对 C++ 编程的看法。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>Can’t declare non-const reference to const variable<br>Can’t declare non-const reference to const vari</p>
<p><img src="/images/obsidian/20230215213916.png" alt="图片" title="image"><br><img src="/images/obsidian/20230215214023.png" alt="图片" title="image"></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><img src="/images/obsidian/20230215215043.png" alt="图片" title="image"><br>函数指针：将函数作为对象传递</p>
<h2 id="stl"><a href="#stl" class="headerlink" title="stl"></a>stl</h2><p>sequence:线性，有顺序<br>associative:不一定线性，有索引机制(map)</p>
<p>vector:有顺序的相同类型的数据集合，大小可控制<br>—子属性：<em>size:元素数量<br>—capacity</em>:单个元素大小<br><img src="/images/obsidian/20230214194657.png" alt="图片" title="image"><br>vector最常用，deque用于首部插入场合，list用于多种列表</p>
<p>associative(关联数组):有顺序的需要有比较方法，无序的需要哈希函数（更快）<br>iterators（迭代器）：用于访问容器中的所有数据<br>–常用函数，begin(),end(),iter++,*(pointer),&#x3D;&#x3D; !&#x3D;,&#x3D;（赋值,复制）,<br><img src="/images/obsidian/20230214200501.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214200805.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214201819.png" alt="图片" title="image"></p>
<h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><p>First call to std::cin &gt;&gt; creates a command line<br>prompt that allows the user to type until they hit enter  </p>
<ul>
<li>Each &gt;&gt; ONLY reads until the next whitespace  </li>
<li>Whitespace &#x3D; tab, space, newline  </li>
<li>Everything after the first whitespace gets saved and<br>used the next time std::cin &gt;&gt; is called  </li>
<li>The place its saved is called a buffer<br><img src="/images/obsidian/20230213213832.png" alt="图片" title="image"><br><img src="/images/obsidian/20230213214430.png" alt="图片" title="image"><br><img src="/images/obsidian/20230213214751.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214102508.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214104421.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214162731.png" alt="图片" title="image"><br><img src="/images/obsidian/20230214162820.png" alt="图片" title="image"></li>
</ul>
<h2 id="hashmap的c-实现"><a href="#hashmap的c-实现" class="headerlink" title="hashmap的c++实现"></a>hashmap的c++实现</h2><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数HashMap():</span><br><span class="line">接受参数count(值的个数),hash function(有默认值)</span><br><span class="line"></span><br><span class="line">参数(typename fitst,typename last,bucket_count,H)</span><br><span class="line">//用一个容器首尾指针初始化hashmap</span><br><span class="line">eg.</span><br><span class="line">hashmap&lt;k,m&gt; map&#123;vec.begin(),vec.end()&#125;</span><br><span class="line"></span><br><span class="line">参数(init_list init,bucket_count,H)</span><br><span class="line">//用容器直接初始化hashmap</span><br><span class="line">eg.</span><br><span class="line">HashMap&lt;char, int&gt; map&#123;&#123;&#x27;a&#x27;, 3&#125;, &#123;&#x27;b&#x27;, 5&#125;, &#123;&#x27;c&#x27;, 7&#125;&#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">key-键</span><br><span class="line">mapped-被加密的值(int)</span><br><span class="line">H-哈希函数</span><br><span class="line">bucket_count(存储的键值对数组容量)</span><br><span class="line">load_factor(内联函数，返回size/bucket_count，即实际储存值的键值对)</span><br><span class="line">contains(参数const K&amp; key判断是否存在改键，返回bool值)</span><br><span class="line">at(参数k，返回mapped的引用)</span><br><span class="line">clear(清空键值对)</span><br><span class="line">insert(参数为键值对引用，返回一对pair&lt;iterator,bool&gt;,iter指向改键值对，无论是否已存在，bool表示是否成功添加，如为false则已存在该键值对)</span><br><span class="line">erase(key为参数，返回bool值)</span><br><span class="line">earse(iter为参数，返回该指针下一个位置)</span><br><span class="line">rehash(size_t为参数，重新哈希为给出的新的指针数组大小)</span><br><span class="line">begin(根据hashmap是否为const给出iter或const iter)</span><br><span class="line">end(返回伪指针)</span><br><span class="line">debug(打印所有哈希键值对以及哈希表所有参数，注意，必须基于重载&lt;&lt;运算符的基础)</span><br><span class="line"></span><br><span class="line">符号重载：</span><br><span class="line">M&amp; [](const key&amp; ,返回insert(key)的返回pair的first成员的second成员，即mapped值)</span><br><span class="line">//用于给key对应的value(mapped)赋值</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">node(struct，包含next指针和value)</span><br><span class="line">nodepair(前后node的pair)</span><br><span class="line">findnode(参数key，返回指针对&lt;prev,curr&gt;)</span><br><span class="line">first_not_empty_bucket()</span><br><span class="line">make_iterator(参数node*curr)</span><br><span class="line">_bucket_array(vector&lt;node*&gt;,其中一个node*为ptr,则ptr-&gt;value为&lt;key ,mapped&gt;)</span><br><span class="line"></span><br><span class="line">//指针构造</span><br><span class="line"></span><br><span class="line">_bucket_array：由指针组成的数组,每个成员都是一个指针</span><br><span class="line">储存的值为next指针和一个pair&lt;key,mapped&gt;</span><br><span class="line">operator-&gt; is a bit of an odd-ball. When you write p-&gt;m, it is interpreted as (p.operator-&gt;())-&gt;m.</span><br><span class="line"></span><br><span class="line">- This means operator-&gt; should return a pointer to the object that has the field m.</span><br></pre></td></tr></table></figure>
<h3 id="涉及的c-特性"><a href="#涉及的c-特性" class="headerlink" title="涉及的c++特性"></a>涉及的c++特性</h3><p>匿名函数<br>基本lambda语法<br>基本形式如下：<br>【capture】（parameters）-&gt;return-type {body}</p>
<p>typename function()<br>return {x,y,z}<br>即用{}的参数初始化原函数返回的类型</p>
<p>ptrdiff_t:用于储存两个指针的差</p>
<p>conditional_t&lt;func,x,y&gt;如果func为true则x，为false则y</p>
<p>forward_iterator_tag：单方向迭代器（可读写）<br>++iter，iter+&#x3D;1随后返回对自身的引用<br>iter++，先返回一个对自身的复制，随后iter+&#x3D;1</p>
<p>std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p>
<p>ate：从文件尾部开始<br>strsub(start,length)<br>移动语义(c++11新特性)<br>clss(classname &amp;&amp;)<br>利用右值引用的部分数据直接初始化新的类，并在初始化之后将右值删除，可以通过std::move()强制转化左值为右值。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利cs61a的python笔记</title>
    <url>/2023/09/20/61a%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="python语言特性"><a href="#python语言特性" class="headerlink" title="python语言特性"></a>python语言特性</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>名称也可以与函数绑定。例如，名称 <code>max</code> 就和我们之前使用的 <code>max</code> 函数进行了绑定。与数字不同，函数很难以文本呈现，因此当询问一个函数时，Python 会打印一个标识来描述：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; max</span><br><span class="line">&lt;built-in function max&gt;</span><br></pre></td></tr></table></figure>

<p>赋值语句可以为现有函数赋予新名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f = max</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;built-in function max&gt;</span><br><span class="line">&gt;&gt;&gt; f(2, 3, 4)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>以下指南改编自 <a href="http://www.python.org/dev/peps/pep-0008">Python 代码风格指南</a>, 它可以作为所有（非叛逆的）Python 程序员的指南。这些共享的约定使开发者社区的成员之间的沟通能够顺利进行。作为遵循这些约定的副作用，你会发现你的代码在内部变得更加一致。</p>
<ol>
<li>函数名是小写的，单词之间用下划线分隔。鼓励使用描述性名称。</li>
<li>函数名称通常反映解释器应用于参数的操作（例如， <code>print, add, square</code> ）或结果（例如， <code>max, abs, sum</code> ）。</li>
<li>参数名称是小写的，单词之间用下划线分隔。首选单个词的名称。</li>
<li>参数名称应该反映参数在函数中的作用，而不仅仅是允许的参数类型。</li>
<li>当作用明确时，单字参数名称可以接受，但应避免使用 l（小写的 L）和 O（大写的 o）或 I（大写的 i）以避免与数字混淆。</li>
</ol>
<h3 id="函数设计原则"><a href="#函数设计原则" class="headerlink" title="函数设计原则"></a>函数设计原则</h3><ul>
<li>每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。</li>
<li>不要重复自己（Don’t repeat yourself）是软件工程的核心原则。这个所谓的 DRY 原则指出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。如果你发现自己正在复制粘贴一段代码，那么你可能已经找到了进行函数抽象的机会。</li>
<li>定义通用的函数。比如作为 <code>pow</code> 函数的一个特例的平方函数就不在 Python 库中，因为 <code>pow</code> 函数可以将数字计算为任意次方。<br>当你使用函数名称作为参数调用 <code>help</code> 时，你会看到它的文档字符串（键入 q 以退出 Python help）。<br>Python 中的注释可以附加到 <code>#</code> 号后的行尾。例如，上面代码中的注释 <code>玻尔兹曼常数</code> 描述了 <code>k</code> 变量的含义。这些注释不会出现在 Python 的 <code>help</code> 中，而且会被解释器忽略，它们只为人类而存在。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help(pressure)</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Link:</span><br><span class="line">        &quot;&quot;&quot;A linked list with a first element and the rest.&quot;&quot;&quot;</span><br><span class="line">        empty = ()</span><br><span class="line">        def __init__(self, first, rest=empty):</span><br><span class="line">            assert rest is Link.empty or isinstance(rest, Link)</span><br><span class="line">            self.first = first</span><br><span class="line">            self.rest = rest</span><br><span class="line">        def __getitem__(self, i):</span><br><span class="line">            if i == 0:</span><br><span class="line">                return self.first</span><br><span class="line">            else:</span><br><span class="line">                return self.rest[i-1]</span><br><span class="line">        def __len__(self):</span><br><span class="line">            return 1 + len(self.rest)</span><br></pre></td></tr></table></figure>

<h3 id="抽象障碍"><a href="#抽象障碍" class="headerlink" title="抽象障碍"></a>抽象障碍</h3><p>每当程序的一部分可以使用更高级别的函数而不是使用较低级别的函数时，就会违反抽象障碍。例如，计算有理数平方的函数最好用 <code>mul_rational</code> 实现，它不对有理数的实现做任何假设。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_rational(x):</span><br><span class="line">        return mul_rational(x, x)</span><br></pre></td></tr></table></figure>

<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><pre><code>范围通常出现在 for 语句 header 中的表达式，以指定 `&lt;suite&gt;` 应执行的次数。如果 `&lt;name&gt;` 没有被用在 `&lt;suite&gt;`，一个惯用的使用方式是，使用下划线表示 `&lt;name&gt;`。
</code></pre>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for _ in range(3):</span><br><span class="line">        print(&#x27;Go Bears!&#x27;)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure>

<p>对解释器而言，下划线只是环境中的另一个名称，但对程序员具有约定俗成的含义，表示该名称不会出现在任何未来的表达式中。<br>列表推导式的一般形式是：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;</span><br></pre></td></tr></table></figure>

<p>为了运算列表推导式，Python 首先评估 <code>&lt;sequence expression&gt;</code>，它必须返回一个 iterable 值。然后，每个元素依次绑定到 <code>&lt;name&gt;</code>，再运算 <code>&lt;filter expression&gt;</code>；如果产生一个真值，运算 <code>&lt;map expression&gt;</code>。最后 <code>&lt;map expression&gt;</code> 的值被收集到一个列表中</p>
<p><code>reduce</code> 可用于将序列的所有元素相乘。使用 <code>mul</code> 作为 <code>reduce_fn</code>， 1 作为 <code>initial</code> 值， <code>reduce</code> 可用于将各数字相乘。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(mul, [2, 4, 8], 1)</span><br><span class="line">64</span><br></pre></td></tr></table></figure>

<p>**多行文字 (Multiline Literals)**。字符串不限于一行。跨越多行的字符串文字可以用三重引号括起。我们已经在文档字符串中广泛使用了这种三重引号。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器的用处源自以下事实： 迭代器的一系列数据可能不会在内存中显式表示。 迭代器提供了一种考虑一系列值中的每一个的机制 轮，但所有这些元素不需要同时存储。 相反，当迭代器请求下一个元素时，该元素可能会 按需计算，而不是从现有内存中检索 来源。</p>
<p>范围能够惰性地计算序列的元素，因为 表示的序列是统一的，并且任何元素都很容易从 范围的开始和结束边界。 迭代器允许延迟生成 更广泛的底层序列数据集类别，因为它们不需要 提供对底层系列的任意元素的访问。 反而， 迭代器只需要按顺序计算该系列的下一个元素， 每次请求另一个元素时。 虽然不像访问那样灵活 序列的任意元素（称为 <em>随机访问</em> ）、 <em>顺序访问</em> 顺序数据通常足以满足数据处理应用程序的需要。<br>函数 map 是惰性的：调用它并不执行计算 需要计算其结果的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def double_and_print(x):</span><br><span class="line">        print(&#x27;***&#x27;, x, &#x27;=&gt;&#x27;, 2*x, &#x27;***&#x27;)</span><br><span class="line">        return 2*x</span><br><span class="line">&gt;&gt;&gt; s = range(3, 7)</span><br><span class="line">&gt;&gt;&gt; doubled = map(double_and_print, s)  # double_and_print not yet called</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called once</span><br><span class="line">*** 3 =&gt; 6 ***</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called again</span><br><span class="line">*** 4 =&gt; 8 ***</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; list(doubled)                       # double_and_print called twice more</span><br><span class="line">*** 5 =&gt; 10 ***</span><br><span class="line">*** 6 =&gt; 12 ***</span><br><span class="line">[10, 12]</span><br></pre></td></tr></table></figure>

<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p>可迭代的 Letters 实例 b_to_k 和 LetterIter 迭代器 实例 first_iterator 和 second_iterator的 不同之处在于 字母 实例不会改变，而迭代器实例会改变 每次调用 next （或等效地，每次调用 <strong>next</strong> ）。 迭代器通过顺序数据跟踪进度，而可迭代器 代表数据本身。</p>
<p>Python 中的许多内置函数都采用可迭代参数并返回迭代器。 函数 map 例如， 接受一个函数和一个可迭代对象。 它返回 将函数参数应用于每个元素的结果的迭代器 在可迭代的参数中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;  caps   =   map  (  lambda   x  :   x  .  upper  (),   b_to_k ) </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;B&#x27; </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;C&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器函数是生成值而不是返回值的函数<br> 普通函数返回一次；  一个生成器函数可以产生多次<br> 生成器是通过调用生成器函数自动创建的迭代器<br> 当调用生成器函数时，它返回一个迭代其产量的生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def plus_minus(x):</span><br><span class="line">... yield x</span><br><span class="line">... yield -x</span><br><span class="line">&gt;&gt;&gt; t = plus_minus(3)</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">-3</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">&lt;generator object plus_minus ...&gt;</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="嵌套定义"><a href="#嵌套定义" class="headerlink" title="嵌套定义"></a>嵌套定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def sqrt(a):</span><br><span class="line">        def sqrt_update(x):</span><br><span class="line">            return average(x, a/x)</span><br><span class="line">        def sqrt_close(x):</span><br><span class="line">            return approx_eq(x * x, a)</span><br><span class="line">        return improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure>

<p>与局部赋值一样，局部 <code>def</code> 语句只影响当前局部帧。这些函数仅在求解 <code>sqrt</code> 时在作用域内。与求解过程一致，这些局部 <code>def</code> 语句在调用 <code>sqrt</code> 之前都不会被求解。</p>
<p>词法作用域（Lexical scope）：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， <code>sqrt_update</code> 引用名称 <code>a</code>，它是其封闭函数 <code>sqrt</code> 的形式参数。这种在嵌套定义之间共享名称的规则称为词法作用域。最重要的是，内部函数可以访问定义它们的环境中的名称（而不是它们被调用的位置）。</p>
<p>我们需要对我们的环境模型实现两个扩展来启用词法作用域。</p>
<ol>
<li>每个用户定义的函数都有一个父环境：定义它的环境。</li>
<li>调用用户定义的函数时，其局部帧会继承其父环境。<br> Python 中词法作用域的两个关键优势。</li>
</ol>
<ul>
<li>局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。</li>
<li>局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。</li>
</ul>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>不像  定义  语句、lambda 表达式可以用作运算符或<br>调用表达式的操作数。  这是因为它们只是一行<br>计算结果为函数的表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; what = lambda x : x + 5</span><br><span class="line">&gt;&gt;&gt; what</span><br><span class="line">&lt;function &lt;lambda&gt; at 0xf3f490&gt;</span><br><span class="line">&gt;&gt;&gt; (lambda y: y + 5)(4)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">     def __init__(self, account_holder):</span><br><span class="line">            self.balance = 0</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<p>内置函数 <code>getattr</code> 还按名称返回对象的属性。它是点表示法的函数等效物。使用 <code>getattr</code> ，我们可以使用字符串查找属性，就像我们对调度字典所做的那样。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(spock_account, &#x27;balance&#x27;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>我们还可以测试应该对象是否具有 <code>hassattr</code> 的名命属性。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(spock_account, &#x27;deposit&#x27;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>我们可以通过对点表达式的返回值调用 <code>type</code> 来查看交互式解释器的差异。作为类的属性，方法只是一个函数，但作为实例的属性，它是一个绑定方法：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(Account.deposit)</span><br><span class="line">&lt;class &#x27;Function&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(spock_account.deposit)</span><br><span class="line">&lt;class &#x27;method&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>这两个结果的区别仅在于第一个是参数为 <code>self</code> 和 <code>amount</code> 的标准双参数函数。第二种是单参数方法，调用方法时，名称 <code>self</code> 将自动绑定到名为 <code>spock_account</code> 的对象，而参数 <code>amount</code> 将绑定到传递给方法的参数。这两个值（无论是函数值还是绑定方法值）都与相同的 <code>deposit</code> 函数体相关联。<br>在某些情况下，有一些实例变量和方法与对象的维护和一致性相关，我们不希望对象的用户看到或使用。它们不是类定义的抽象的一部分，而是实现的一部分。Python 的约定规定，如果属性名称以下划线开头，则只能在类本身的方法中访问它，而不是用户访问。</p>
<p>计算点表达式：</p>
<ol>
<li>点表达式左侧的 <code>&lt;expression&gt;</code> ，生成点表达式的对象。</li>
<li><code>&lt;name&gt;</code> 与该对象的实例属性匹配；如果存在具有该名称的属性，则返回属性值。</li>
<li>如果实例属性中没有 <code>&lt;name&gt;</code> ，则在类中查找 <code>&lt;name&gt;</code>，生成类属性。</li>
<li>除非它是函数，否则返回属性值。如果是函数，则返回该名称绑定的方法。</li>
</ol>
<h2 id="约束传递-Propagating-Constraints"><a href="#约束传递-Propagating-Constraints" class="headerlink" title="约束传递 (Propagating Constraints)"></a>约束传递 (Propagating Constraints)</h2><p>可变数据允许我们模拟具有变化的系统，也允许我们构建新的抽象类型。在这个扩展示例中，我们结合了非局部赋值、列表和字典来构建一个支持多方向计算的基于约束系统。将程序表示为约束是一种声明式编程，在这种编程中，程序员声明要解决的问题的结构，而不是抽象出问题解决方案的具体计算方式的细节。</p>
<p>计算机程序传统上被组织为单向计算，它对预先指定的参数执行操作以产生所需的输出。另一方面，我们通常希望根据数量之间的关系对系统进行建模。例如，我们之前考虑过理想气体定律，它通过玻尔兹曼常数 (k) 将理想气体的压力 (p)、体积 (v)、数量 (n) 和温度 (t) 联系起来：</p>
<p><code>p * v = n * k * t</code></p>
<p>这样的方程不是单向的。给定任何四个量，我们可以使用这个方程来计算第五个。然而，将方程式翻译成传统的计算机语言会迫使我们选择一个量来根据其他四个量进行计算。因此，计算压力的函数不能用于计算温度，即使这两个量的计算来自同一个方程。</p>
<p>在本节中，我们概述了线性关系的一般模型的设计。我们定义了在数量之间保持的原始约束，例如强制数学关系 a + b &#x3D; c 的 adder(a, b, c) 约束。</p>
<p>我们还定义了一种组合方式，以便可以组合原始约束来表达更复杂的关系。这样，我们的程序就类似于一种编程语言。我们通过构建一个网络来组合约束，在该网络中约束由连接器 (connector) 连接。连接器是一个对象，它“持有”一个值并且可以参与一个或多个约束。</p>
<p>例如，我们知道华氏温度和摄氏温度之间的关系是：</p>
<p><code>9 * c = 5 * (f - 32)</code></p>
<p>该等式是 c 和 f 之间的复杂约束。这样的约束可以被认为是一个由原始加法器 (adder) 、乘法器 (multiplier) 和常量 (constant) 约束组成的网络。</p>
<p><img src="https://composingprograms.netlify.app/sicp/celsius_fahrenheit_constraint.png" alt="celsius_fahrenheit_constraint"></p>
<p>在此图中，我们在左侧看到一个乘数框，其中包含三个端子，标记为 a 、b 和 c。这些将乘数连接到网络的其余部分，如下所示：终端连接到连接器 celsius，该连接器将保持摄氏温度。b 端子连接到连接器 w，该连接器链接到常量 9。乘数盒约束为 a 和 b 乘积的 c 端链接到另一个乘法盒的 c 端，其 b 连接到常量 5，其 a 连接到和约束中的项之一。</p>
<p>这种网络的计算过程如下：当一个连接器被赋予一个值时（由用户或由它链接到的约束框），它会唤醒所有相关的约束（除了刚刚唤醒它的约束） 以告诉他们它有值。每个被唤醒的约束框之后轮流询问其连接器，以查看是否有足够的信息来确定连接器的值。如果有，该框设置该连接器，然后唤醒所有关联的约束，依此类推。例如，在摄氏度和华氏度之间的转换中， w、 x 和 y 立即被常量框分别设置为 9、 5 和 32。连接器唤醒乘法器和加法器，它们确定没有足够的信息继续进行。如果用户（或网络的其他部分）将摄氏连接器设置为一个值（比如 25），最左边的乘法器将被唤醒，它将 u 设置为 25 * 9 &#x3D; 225。然后你唤醒第二个乘法器，将 v 设置为 45，v 唤醒加法器，将 fahrenheit 连接器设置为 77。</p>
<p>**使用约束系统 (Using the Constraint System)**。要使用约束系统执行上述温度计算，我们首先通过调用连接器构造函数创建两个命名连接器，摄氏度 celsius 和华氏度 fahrenheit。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius = connector(&#x27;Celsius&#x27;)</span><br><span class="line">&gt;&gt;&gt; fahrenheit = connector(&#x27;Fahrenheit&#x27;)</span><br></pre></td></tr></table></figure>

<p>然后，我们将这些连接器链接到一个反映上图的网络中。函数转换器 (converter) 组装网络中的各种连接器和约束。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def converter(c, f):</span><br><span class="line">        &quot;&quot;&quot;用约束条件连接 c 到 f ，将摄氏度转换为华氏度.&quot;&quot;&quot;</span><br><span class="line">        u, v, w, x, y = [connector() for _ in range(5)]</span><br><span class="line">        multiplier(c, w, u)</span><br><span class="line">        multiplier(v, x, u)</span><br><span class="line">        adder(v, y, f)</span><br><span class="line">        constant(w, 9)</span><br><span class="line">        constant(x, 5)</span><br><span class="line">        constant(y, 32)</span><br></pre></td></tr></table></figure>

<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; converter(celsius, fahrenheit)</span><br></pre></td></tr></table></figure>

<p>我们将使用消息传递系统来协调约束和连接器。约束是不包含局部状态本身的字典。它们对消息的响应是非纯函数，会更改它们约束的连接器。</p>
<p>连接器是保存当前值并响应操纵该值的消息的字典。约束不会直接更改连接器的值，而是通过发送消息来更改，以便连接器可以通知其他约束以响应更改。这样，一个连接器既代表了一个数字，同时也封装了连接器的行为。</p>
<p>我们可以发送给连接器的一条消息是设置它的值。在这里，我们（ “ user ” ）将 celsius 的值设置为 25。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;set_val&#x27;](&#x27;user&#x27;, 25)</span><br><span class="line">Celsius = 25</span><br><span class="line">Fahrenheit = 77.0</span><br></pre></td></tr></table></figure>

<p>不仅 celsius 的值变为 25，而且它的值通过网络传播，因此 fahrenheit 的值也发生变化。打印这些更改是因为我们在构造它们时命名了这两个连接器。</p>
<p>现在我们可以尝试将 fahrenheit 度设置为一个新值，比如 212。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Contradiction detected: 77.0 vs 212</span><br></pre></td></tr></table></figure>

<p>连接器抱怨说它感觉到了一个矛盾：它的值为 77.0，而有人试图将它设置为 212。如果我们真的想用新值应用到网络，我们可以告诉 celsius 忘记它的旧值：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;forget&#x27;](&#x27;user&#x27;)</span><br><span class="line">Celsius is forgotten</span><br><span class="line">Fahrenheit is forgotten</span><br></pre></td></tr></table></figure>

<p>连接器 celsius 发现最初设置其值的用户现在收回该值，因此 celsius 同意失去其值，并将这一事实通知网络的其余部分。这个信息最终传播到 fahrenheit，它现在发现它没有理由继续相信它自己的值是 77。因此，它也放弃了它的值。</p>
<p>现在 fahrenheit 没有值，我们可以将其设置为 212：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Fahrenheit = 212</span><br><span class="line">Celsius = 100.0</span><br></pre></td></tr></table></figure>

<p>这个新值在通过网络传播时会迫使 celsius 的值变为 100。我们使用了完全相同的网络来计算给定 celsius 的 fahrenheit 和给定 fahrenheit 的 celsius。这种计算的非方向性是基于约束的系统的显着特征。</p>
<p>**实施约束系统 (Implementing the Constraint System)**。正如我们所见，连接器是将消息名称映射到函数和数据值的字典。我们将实施响应以下消息的连接器：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; connector [&#x27;set_val&#x27;](source, value)  &quot;&quot;&quot;表示 source 在请求连接器将当前值设为 value&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;has_val&#x27;]()  &quot;&quot;&quot;返回连接器是否已经具有值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;val&#x27;]  &quot;&quot;&quot;是连接器的当前值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;forget&#x27;](source)  &quot;&quot;&quot;告诉连接器 source 请求遗忘它的值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;connect&#x27;](source)  &quot;&quot;&quot;告诉连接器参与新的约束，即 source&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>约束也是字典，它通过两条消息从连接器接收信息：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; constraint[\&#x27;new_val&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器具有新的值。&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; constraint[\&#x27;forget&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器遗忘了值。&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>当约束收到这些消息时，它们会将消息传播到其他连接器。</p>
<p>adder 函数在三个连接器上构造一个加法器约束，其中前两个必须与第三个相加：a + b &#x3D; c。为了支持多向约束传播，加法器还必须指定它从 c 中减去 a 得到 b，同样地从 c 中减去 b 得到 a。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import add, sub</span><br><span class="line">&gt;&gt;&gt; def adder(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a+b=c&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, add, sub, sub)</span><br></pre></td></tr></table></figure>

<p>我们想实现一个通用的三元（三向）约束，它使用来自 adder 的三个连接器和三个函数来创建一个接受 new_val 和 forget 消息的约束。对消息的响应是局部函数，它们被放置在称为约束的字典中。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_ternary_constraint(a, b, c, ab, ca, cb):</span><br><span class="line">        &quot;&quot;&quot;约束ab(a,b)=c，ca(c,a)=b，cb(c,b)=a。&quot;&quot;&quot;</span><br><span class="line">        def new_value():</span><br><span class="line">            av, bv, cv = [connector[&#x27;has_val&#x27;]() for connector in (a, b, c)]</span><br><span class="line">            if av and bv:</span><br><span class="line">                c[&#x27;set_val&#x27;](constraint, ab(a[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">            elif av and cv:</span><br><span class="line">                b[&#x27;set_val&#x27;](constraint, ca(c[&#x27;val&#x27;], a[&#x27;val&#x27;]))</span><br><span class="line">            elif bv and cv:</span><br><span class="line">                a[&#x27;set_val&#x27;](constraint, cb(c[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">        def forget_value():</span><br><span class="line">            for connector in (a, b, c):</span><br><span class="line">                connector[&#x27;forget&#x27;](constraint)</span><br><span class="line">        constraint = &#123;&#x27;new_val&#x27;: new_value, &#x27;forget&#x27;: forget_value&#125;</span><br><span class="line">        for connector in (a, b, c):</span><br><span class="line">            connector[&#x27;connect&#x27;](constraint)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>

<p>称为约束的字典是一个调度字典，也是约束对象本身。它响应约束接收到的两条消息，但也作为调用其连接器的 source 参数传递。</p>
<p>每当约束被告知其连接器之一具有值时，就会调用约束的局部函数 new_value。该函数首先检查 a 和 b 是否都有值。如果是，它告诉 c 将其值设置为函数 ab 的返回值，在加法器的情况下为 add。约束将自身（约束）作为连接器的 source 参数传递，该连接器是加法器对象。如果 a 和 b 不同时都有值，则约束检查 a 和 c，依此类推。</p>
<p>如果约束被告知它的一个连接器遗忘了它的值，它会请求它的所有连接器遗忘它们的值。（实际上只有那些由此约束设置的值会丢失。）</p>
<p>乘法器与加法器非常相似。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import mul, truediv</span><br><span class="line">&gt;&gt;&gt; def multiplier(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a*b=c.&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, mul, truediv, truediv)</span><br></pre></td></tr></table></figure>

<p>常量也是一种约束，但它永远不会发送任何消息，因为它只涉及它在构造时设置的单个连接器。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def constant(connector, value):</span><br><span class="line">        &quot;&quot;&quot;常量赋值.&quot;&quot;&quot;</span><br><span class="line">        constraint = &#123;&#125;</span><br><span class="line">        connector[&#x27;set_val&#x27;](constraint, value)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>

<p>这三个约束足以实现我们的温度转换网络。</p>
<p>**连接器表示 (Representing connectors)**。连接器表示为包含值的字典，也有具备局部状态的响应函数。连接器必须跟踪为其提供当前值的信息提供者，以及它参与的约束列表。</p>
<p>构造函数连接器具有用于设置和遗忘值的局部函数，这些值是对来自约束的消息的响应。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def connector(name=None):</span><br><span class="line">        &quot;&quot;&quot;限制条件之间的连接器.&quot;&quot;&quot;</span><br><span class="line">        informant = None</span><br><span class="line">        constraints = []</span><br><span class="line">        def set_value(source, value):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            val = connector[&#x27;val&#x27;]</span><br><span class="line">            if val is None:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = source, value</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;=&#x27;, value)</span><br><span class="line">                inform_all_except(source, &#x27;new_val&#x27;, constraints)</span><br><span class="line">            else:</span><br><span class="line">                if val != value:</span><br><span class="line">                    print(&#x27;Contradiction detected:&#x27;, val, &#x27;vs&#x27;, value)</span><br><span class="line">        def forget_value(source):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            if informant == source:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = None, None</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;is forgotten&#x27;)</span><br><span class="line">                inform_all_except(source, &#x27;forget&#x27;, constraints)</span><br><span class="line">        connector = &#123;&#x27;val&#x27;: None,</span><br><span class="line">                     &#x27;set_val&#x27;: set_value,</span><br><span class="line">                     &#x27;forget&#x27;: forget_value,</span><br><span class="line">                     &#x27;has_val&#x27;: lambda: connector[&#x27;val&#x27;] is not None,</span><br><span class="line">                     &#x27;connect&#x27;: lambda source: constraints.append(source)&#125;</span><br><span class="line">        return connector</span><br></pre></td></tr></table></figure>

<p>连接器也是约束用于与连接器通信的五个消息的调度字典。四个响应是函数，最后的响应是值本身。</p>
<p>当有设置连接器值的请求时调用局部函数 set_value。如果连接器当前没有值，它将设置它的值并记住请求设置值的源约束作为信息提供者。然后连接器将通知它的所有参与约束，除了请求设置值的约束。这是使用以下迭代函数完成的。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def inform_all_except(source, message, constraints):</span><br><span class="line">        &quot;&quot;&quot;告知信息除了source外的所有约束条件，。&quot;&quot;&quot;</span><br><span class="line">        for c in constraints:</span><br><span class="line">            if c != source:</span><br><span class="line">                c[message]()</span><br></pre></td></tr></table></figure>

<p>如果要求连接器遗忘其值，它会调用局部函数 forget-value，该函数首先检查以确保请求来自与最初设置值相同的约束。如果是这样，连接器会通知其关联的约束有关值的丢失。</p>
<p>对消息 has_val 的响应表明连接器是否有值。 对消息连接的响应将源约束添加到约束列表中。</p>
<p>我们设计的约束程序引入了许多将在面向对象编程中再次出现的思想。约束和连接器都是通过消息操作的抽象。当连接器的值发生变化时，它会通过一条消息进行更改，该消息不仅会更改值，还会验证它（检查源）并传播其效果（通知其他约束）。事实上，我们将在本章后面使用具有字符串值键和函数值的字典的类似架构来实现面向对象的系统</p>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>请注意，回溯中的行似乎是配对在一起的。 该对中的第一行具有以下格式：<br>文件“&lt;文件名&gt;”，第 &lt;编号&gt; 行，&lt;函数&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;&lt;file name&gt;&quot;, line &lt;number&gt;, in &lt;function&gt;</span><br></pre></td></tr></table></figure>

<p>该行为您提供以下信息： 文件名：包含问题的文件的名称。 Number：文件中引起问题的行号，或包含下一个函数调用的行号 函数：可以在其中找到该行的函数的名称。<br>回溯消息中的最后一行是错误语句。 错误语句具有以下格式： &lt;错误类型&gt;：&lt;错误消息&gt; 这一行为您提供了两条信息： 错误类型：引起的错误类型（例如SyntaxError，TypeError）。 这些通常具有足够的描述性，可以帮助您缩小错误原因的搜索范围。 错误消息：更详细地描述导致错误的原因。 不同的错误类型会产生不同的错误消息。</p>
<h2 id="Running-doctests"><a href="#Running-doctests" class="headerlink" title="Running doctests"></a>Running doctests</h2><p>Python has a great way to quickly write tests for your code. These are called doctests, and look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    &quot;&quot;&quot;A random function.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; foo(4)</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; foo(5)</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>The lines in the docstring that look like interpreter outputs are the <strong>doctests</strong>. To run them, go to your terminal and type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m doctest file.py</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m doctest file.py -v</span><br><span class="line">除了告诉你哪些文档测试失败之外，它还会 告诉您哪些文档测试通过了。</span><br></pre></td></tr></table></figure>

<p>许多程序员喜欢研究他们的代码的一种方法是使用交互式 REPL。 也就是说，您可以在其中直接运行函数并检查其输出的终端。<br>通常，要完成此操作，您可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -i file.py</span><br></pre></td></tr></table></figure>

<h3 id="使用-assert声明"><a href="#使用-assert声明" class="headerlink" title="使用 assert声明"></a>使用 <code>assert</code>声明</h3><p>Python 有一个特性称为 <code>assert</code>语句，它可以让您测试条件是否为真，并打印错误 否则在一行中消息。 如果您知道某些条件在某些点需要为真，这会很有用 在你的程序中。 例如，如果您正在编写一个接受整数并将其加倍的函数，那么它可能会很有用 确保您的输入实际上是一个整数。 然后你可以编写以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def double(x):</span><br><span class="line">    assert isinstance(x, int), &quot;The input to double(x) must be an integer&quot;</span><br><span class="line">    return 2 * x</span><br></pre></td></tr></table></figure>

<p>请注意，我们并没有真正调试 <code>double</code>在这里，我们正在做的是确保任何拨打电话的人 <code>double</code>正在以正确的论点这样做。 例如，如果我们有一个函数 <code>g</code>接受一个字符串和一个数字 并将字符串的长度添加到数字的两倍，其实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def g(x, y):</span><br><span class="line">    return double(x) + y # should be double(y) + len(x)</span><br></pre></td></tr></table></figure>

<h3 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a><code>SyntaxError</code></h3><ul>
<li><p><strong>原因</strong> ：代码语法错误</p>
</li>
<li><p><strong>示例</strong> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    def incorrect(f)</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决办法</strong> ： <code>^</code>符号指向包含的代码 无效的语法。 错误消息没有告诉你 <em>什么</em> 是 错了，但它确实告诉你 <em>在哪里</em> 。</p>
</li>
<li><p><strong>注意</strong> ：Python 将检查 <code>SyntaxErrors</code>执行之前 任何代码。 这与其他错误不同，其他错误仅 在运行时引发。</p>
</li>
</ul>
<h3 id="IndentationError"><a href="#IndentationError" class="headerlink" title="IndentationError"></a><code>IndentationError</code></h3><ul>
<li><p><strong>原因</strong> ：缩进不当</p>
</li>
<li><p><strong>示例</strong> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    print(&#x27;improper indentation&#x27;)</span><br><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong> ：显示缩进不正确的行。 只需重新缩进即可。</p>
</li>
<li><p><strong>注意</strong> ：如果制表符和空格不一致，Python 将提出其中之一。 确保使用空格！ （只是少了点 在 Python 中使用空格和所有 cs61a 内容通常令人头痛 使用空格）。</p>
</li>
</ul>
<h3 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a><code>TypeError</code></h3><ul>
<li><p><strong>原因一</strong> ：</p>
<ul>
<li><p>原始运算符的操作数类型无效。 你是 可能尝试加&#x2F;减&#x2F;乘&#x2F;除不兼容 类型。</p>
</li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError: unsupported operand type(s) for +: &#x27;function&#x27; and &#x27;int&#x27;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>原因2</strong> ：</p>
<ul>
<li><p>在函数调用中使用非函数对象。</p>
</li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; square = 3</span><br><span class="line">&gt;&gt;&gt; square(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &#x27;int&#x27; object is not callable</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>原因3</strong> ：</p>
<ul>
<li><p>向函数传递错误数量的参数。</p>
</li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: add expected 2 arguments, got 1</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="NameError"><a href="#NameError" class="headerlink" title="NameError"></a><code>NameError</code></h3><ul>
<li><p><strong>原因</strong> ：变量没有分配给任何东西或者没有分配 存在。 这包括函数名称。</p>
</li>
<li><p><strong>示例</strong> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  y = x + 3</span><br><span class="line">NameError: global name &#x27;x&#x27; is not defined</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong> ：确保您正在初始化变量（即 在使用之前为变量分配一个值）。</p>
</li>
<li><p><strong>注意</strong> ：错误消息显示“全局名称”的原因是 因为Python将从a开始搜索变量 函数的本地框架。 如果在那里找不到该变量， Python将继续搜索父框架，直到到达 全球框架。 如果仍然找不到变量，Python 引发错误。</p>
</li>
</ul>
<h3 id="IndexError"><a href="#IndexError" class="headerlink" title="IndexError"></a><code>IndexError</code></h3><ul>
<li><p><strong>原因</strong> ：尝试索引序列（例如元组、列表、 string）的数字超过了序列的大小。</p>
</li>
<li><p><strong>示例</strong> ：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  x[100]</span><br><span class="line">IndexError: tuple index out of range</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong> ：确保索引在范围内 顺序。 如果您使用变量作为索引（例如 <code>seq[x]</code>, 确保变量被分配给正确的索引。</p>
</li>
</ul>
<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>因为两个列表可能内容相同，但实际上是不同的列表，所以我们需要一种方法来测试两个对象是否是同一个。Python 包括两个比较运算符，称为 is 和 is not，它们测试两个表达式实际上是否计算为相同的对象。如果两个对象的当前值相等，则它们是相同的，并且对一个对象的任何更改都将始终反映在另一个对象中。身份是比相等更强大的条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suits is [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; suits == [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>字典也确实有一些限制：</p>
<ul>
<li>字典的键不能是或包含可变值。</li>
<li>对于给定的键，最多只能有一个对应的值。<br>非局部语句 (nonlocal statement)。当我们调用 make_withdraw 时，我们将 balance 绑定到初始金额。然后我们定义并返回一个局部函数 withdraw，它会在调用时更新并返回 balance 的值。</li>
</ul>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_withdraw(balance):</span><br><span class="line">        &quot;&quot;&quot;返回一个每次调用都会减少余额的 withdraw 函数&quot;&quot;&quot;</span><br><span class="line">        def withdraw(amount):</span><br><span class="line">            nonlocal balance                 # 声明 balance 是非局部的</span><br><span class="line">            if amount &gt; balance:</span><br><span class="line">                return &#x27;Insufficient funds&#x27;</span><br><span class="line">            balance = balance - amount       # 重新绑定</span><br><span class="line">            return balance</span><br><span class="line">        return withdraw</span><br></pre></td></tr></table></figure>
<p>非局部语句声明：每当我们更改 balance 的绑定时，绑定关系都会在已经绑定 balance 的第一帧中更改。回想一下，如果没有非局部语句，赋值语句将始终在当前环境的第一帧中绑定。非局部语句指示名称不会出现在第一个（局部）帧或最后一个（全局）帧，而是其他地方。</p>
<h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><figure class="highlight plaintext"><figcaption><span>inc_subseqs(s):</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Assuming that S is a list, return a nested list of all subsequences</span><br><span class="line"></span><br><span class="line">    of S (a list of lists) for which the elements of the subsequence</span><br><span class="line"></span><br><span class="line">    are strictly nondecreasing. The subsequences can appear in any order.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs = inc_subseqs([1, 3, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1, 2], [1, 3], [2], [3]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; inc_subseqs([])</span><br><span class="line"></span><br><span class="line">    [[]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs2 = inc_subseqs([1, 1, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs2)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1], [1, 1], [1, 1, 2], [1, 2], [1, 2], [2]]</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def subseq_helper(s, prev):</span><br><span class="line"></span><br><span class="line">        if not s:</span><br><span class="line"></span><br><span class="line">            return [[]]</span><br><span class="line"></span><br><span class="line">        elif s[0] &lt; prev:</span><br><span class="line"></span><br><span class="line">            return subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            a = subseq_helper(s[1::],s[0])</span><br><span class="line"></span><br><span class="line">            b = subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">            return insert_into_all(s[0], a) + b</span><br><span class="line"></span><br><span class="line">    return subseq_helper(s,0)</span><br><span class="line"></span><br><span class="line">seqs = inc_subseqs([1, 3, 2])</span><br></pre></td></tr></table></figure>

<h3 id="反转奇数深度树的标签"><a href="#反转奇数深度树的标签" class="headerlink" title="反转奇数深度树的标签"></a>反转奇数深度树的标签</h3><figure class="highlight plaintext"><figcaption><span>t.is_leaf():</span></figcaption><table><tr><td class="code"><pre><span class="line">        return </span><br><span class="line">    label_list = []</span><br><span class="line">    for b in t.branches:</span><br><span class="line">        label_list.append(b.label)</span><br><span class="line">    for b, new_label in zip(t.branches, reversed(label_list)):</span><br><span class="line">        b.label = new_label</span><br><span class="line">        for bb in b.branches:</span><br><span class="line">            reverse_other(bb)</span><br><span class="line"></span><br><span class="line">我的解法：</span><br><span class="line">def helper(t,depth):</span><br><span class="line"></span><br><span class="line">        if depth%2==0:</span><br><span class="line"></span><br><span class="line">            if t.is_leaf():</span><br><span class="line"></span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            else:</span><br><span class="line"></span><br><span class="line">                for branch in t.branches:</span><br><span class="line"></span><br><span class="line">                    helper(branch,depth+1)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            labels=[]</span><br><span class="line"></span><br><span class="line">            brans=t.branches</span><br><span class="line"></span><br><span class="line">            for branch in brans:</span><br><span class="line"></span><br><span class="line">                labels.insert(0,branch.label)</span><br><span class="line"></span><br><span class="line">            for new_label,new_branch in zip(labels,brans):</span><br><span class="line"></span><br><span class="line">                new_branch.label=new_label</span><br><span class="line"></span><br><span class="line">            for bran in brans:</span><br><span class="line"></span><br><span class="line">                helper(bran,depth+1)</span><br><span class="line"></span><br><span class="line">    helper(t,1)</span><br></pre></td></tr></table></figure>

<h3 id="生成器的生成器"><a href="#生成器的生成器" class="headerlink" title="生成器的生成器"></a>生成器的生成器</h3><figure class="highlight plaintext"><figcaption><span>make_generators_generator(g):</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Generates all the &quot;sub&quot;-generators of the generator returned by</span><br><span class="line"></span><br><span class="line">    the generator function g.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_m_ints_to(n, m):</span><br><span class="line"></span><br><span class="line">    ...     i = 0</span><br><span class="line"></span><br><span class="line">    ...     while (i &lt;= n):</span><br><span class="line"></span><br><span class="line">    ...         yield i</span><br><span class="line"></span><br><span class="line">    ...         i += m</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_3_ints_to_10():</span><br><span class="line"></span><br><span class="line">    ...     for item in every_m_ints_to(10, 3):</span><br><span class="line"></span><br><span class="line">    ...         yield item</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; for gen in make_generators_generator(every_3_ints_to_10):</span><br><span class="line"></span><br><span class="line">    ...     print(&quot;Next Generator:&quot;)</span><br><span class="line"></span><br><span class="line">    ...     for item in gen:</span><br><span class="line"></span><br><span class="line">    ...         print(item)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    9</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">    def gen_helper(lst):</span><br><span class="line"></span><br><span class="line">        yield from lst</span><br><span class="line"></span><br><span class="line">    yield_sofar = []</span><br><span class="line"></span><br><span class="line">    gg = g()</span><br><span class="line"></span><br><span class="line">    for x in gg:</span><br><span class="line"></span><br><span class="line">        yield_sofar.append(x)</span><br><span class="line"></span><br><span class="line">        yield gen_helper(yield_sofar.copy())</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="生成器生成树的搜索路径"><a href="#生成器生成树的搜索路径" class="headerlink" title="生成器生成树的搜索路径"></a>生成器生成树的搜索路径</h3><pre><code>if t.label == value:
        yield [value]
    for b in t.branches:
        for path in path_yielder(b, value):
            yield [t.label] + path
</code></pre>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉世界观轶事集</title>
    <url>/2023/09/19/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E8%BD%B6%E4%BA%8B%E9%9B%86/</url>
    <content><![CDATA[<h2 id="泰特斯"><a href="#泰特斯" class="headerlink" title="泰特斯"></a>泰特斯</h2><p>正如童话故事常见的开头一样，泰特斯是个贫穷而有志气的青年，有一天当他在王国的大街上闲逛时，他遇到了公主的轿子，年轻的泰特斯对美丽淑慧的公主一见钟情，他下定决心一定要当上王国的驸马爷。</p>
<span id="more"></span>
<p>当时开国皇帝恩西斯去世没有多久，年轻的皇帝卡奥斯也是为年轻气盛的青年，泰特斯认为这是成为皇帝亲信的好机会。</p>
<p>当时无权无势的人想要上位有两种办法，一是参军博得战功，二是进入帝国大学谋求文官职位，泰特斯身体虚弱，而且厌恶战争，但却有个不错的头脑，于是在他刻苦攻读下终于进入了帝国的最高学府学习数学，十年后，泰特斯已经是位小有名气的数学家了。</p>
<p>新帝卡奥斯是个奇怪的皇帝，他不甚喜欢锦衣玉食,也不爱美人或者诗琴书赋，唯独对数学很感兴趣，帝国的数学家往往是些老古董，唯有泰特斯名声卓著，血气方刚，二人一见如故，泰特斯如愿以偿成为皇帝的亲信。</p>
<p>卡奥斯将各项赋税与各种工程的设计实施交给了泰特斯，结果无不让他满意，为了表示对泰特斯的欣赏，皇帝决定将自己的妹妹嫁给他。</p>
<p>当公主府的使臣带着婚书拜访泰特斯时，他礼貌而不失坚决地回绝了，此时在他看来任何不懂数学之美的人都是庸俗的，除了数学女神的青睐，他对任何女人不屑一顾。</p>
<p>当然，这件事传到了皇帝的耳朵里，同时传导的还有群臣的议论，皇帝敏感地察觉到在大部分人眼中泰特斯才是帝国最聪明的人，心怀不满的皇帝半强迫地让公主嫁给了泰特斯。当然，皇帝并不无情，否则如果他将所有比他强的数学家都杀了，那么帝国早就没几个大数学家了——要知道他的水平只是二流的</p>
<p>为了自己与泰特斯的安危，贤惠的公主规劝丈夫，聪明的泰特斯恍然大悟，从此以后他收敛锋芒，沉迷于公主府奢华的生活，最终，他与公主幸福地生活到了最后。</p>
<p>泰特斯关于数学研究的遗著于共和历11年首次出现在公众面前，最后屡经辗转进入了共和国首都博物馆的展馆 </p>
<h2 id="黎明"><a href="#黎明" class="headerlink" title="黎明"></a>黎明</h2><p>外交官是位三十出头的年轻人（就他的职位而言），一个月前，他被尊贵的皇帝陛下召见，并被赋予和葛雷氏族谈判的任务。他精于谈判之道，自从帝国决定用经济而不是武力的手段来征服那些遮布隆（帝国语，未开化的人）他变成了谈判桌上最可怕的对手，有人说他的鹰眼能轻易看穿对手的心理底线，有人说他的眼线分布各地，实际上，在外交官的心中，他的才能无关轻重，仅仅是帝国的威亚所致罢了，在早先的黑暗岁月中，遮布隆大多被帝国的屠杀，谎言与掠夺打败。</p>
<p>葛雷族有着一支装备精良的武装，他们背靠大陆大方最大的矿系，然而在帝国面前，这一切毫无意义，诚然，他们完全可以炸毁矿道，但那并不能躲避他们沦为帝国仆从的命运。</p>
<p>当我走进葛雷族的营地时，几乎所有人都对我怒目而视，其中大多是野性，却也带着几份文明，族长是位很硬朗的老人。</p>
<p>“知道吗，按我们的习俗，只要学到知识，就是师徒，你毕业于帝国大学，而我读过帝国大学出版的书，所以我们应该是师兄弟”</p>
<p>我对这老人不合时宜的幽默搞得一点摸不清头脑，“过来，我想让你看个东西”老人领着我向营地的深处走去，在巨大的仓库群前停了下来。</p>
<p>当他打开大门的时候我就知道了——金子，宝石，帝国经济体系中不可或缺的存在，自此帝国历234年定下贵金属和帝国货币的兑换关系后，它们就成了帝国最坚实的支柱。</p>
<p>“这是祖先为我们留下的，留着我们营地的大约只有十分之一””</p>
<p>“你们没有告诉我们这里的矿脉有黄金和宝石？”</p>
<p>“我现在不是告诉你们了吗？”</p>
<p>“……”</p>
<p>“你们帝国的经济命脉就是流通在市场上的黄金吧，如果这种规模的黄金瞬间涌入你们的市场，会发生什么？”</p>
<p>“……”</p>
<p>“好了，开始谈判吧”</p>
<p>历时3天的谈判后，帝国开出了有史以来最宽松的条件，葛雷族的所有自治权予以保留，唯一的条件是，必须与帝国展开全方面的贸易</p>
<h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只是两个小人物的故事</span><br></pre></td></tr></table></figure>
<p>一般来说，这年头很难遇到算命的，至于在酒吧里看到算命的就更少见了，用算命来骗酒喝已经是不知多少年前的老故事了，然而，在此时此刻，却有两个中年男人在酒吧里对饮。</p>
<p>“你是刚来这座城市吗？”</p>
<p>“恰恰相反，我在这待了很多年了”</p>
<p>发问者并没有追问</p>
<p>“你活过3000帝国币吗？”</p>
<p>莫名其妙的问题，乡巴佬的叫法，发问者心想，一时间他不知对方是什么意思</p>
<p>“我的父亲在活到566布朗时咽了气，他本指望着活到700布朗的，呵呵，然后我就到这里来了”</p>
<p>和一个不知从哪个穷乡僻壤来的家伙聊天或许能让自己以后酒场吹牛添一些料，中年人想，于是他决定听下去。</p>
<p>“来到这里后，一时间我很不适应，你们似乎总喜欢用在时间和空间上均匀分布的事物当做度量的标准，真是奇怪”</p>
<p>提问者忍不住做出了回答“你是说你们甚至没有时空的概念？”</p>
<p>“用你们的话说，我们的时间是经济学，空间则是社会学。当然，你们的语言和概念是无法完全解释的，300克朗昭示着步入成年，数不过来的人意味着一个国家，扎在一定的一堆人意味着一个省，这只是比喻。”</p>
<p>他自嘲般地说“我来的时候觉得在那地方我始终是客子，来到这里后又感觉并非家乡”</p>
<p>窗外一只先前飞走的蝴蝶盘旋一圈后又回到了树梢。</p>
<p>“知道吗？你会活过394杯酒。”他没头没脑地说了一句。</p>
<p>另一位中年人沉默着，他每周的同一时间都会来这里点一杯酒。</p>
<p>“而我，会活过自己度量过的第1944位客户”</p>
<p>“你指望我为你的疯话付钱吗？”</p>
<p>”我不适应你们的语言，我也不适应你们的思维……每一秒，每一厘米对你们而言都是无法更改的，你为什么觉得作为我故乡度量——金钱是能更改的呢？对你来说这是一天，对我而言这是6帝国币，二者都是神圣不可更改的。”</p>
<p>中年人有些可悲地看着他“你需要去补补数学和物理的课”</p>
<p>“我只想知道自己该用什么来度量”他显得有些颓废。</p>
<p>“结账，他那杯也算我的”占卜师指着中年男人桌上的酒，向服务员喊道。</p>
<p>占卜师离开酒吧的背影显得并不年轻，“我是他的第几个客户？”中年男人想到。</p>
<p>中年人从此再也没有喝过酒，一年后，一种以果汁为主成分的硬饮料在帝国风靡一时，中年人在一次应酬中举起了一杯苹果汁，当他察觉到一丝酒味后已经晚了，作为一个厌恶半途而废的男人，他选择一饮而尽，随后咽了气。 </p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉世界观设定集</title>
    <url>/2023/09/19/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E4%B8%96%E7%95%8C%E8%A7%82/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生……</span><br></pre></td></tr></table></figure>

<p>  这是邪神辛克莱温教徒传颂的创世神话，也是目前为止我们所知最早的创世神话，可以说后世诸多关于创世的传说都有它的影子。</p>
<span id="more"></span>

<p>邪神辛克莱温的信徒有着自己的语言，这种符号文字晦涩难懂，虽然给传播教义造成了困难，却成为维系着邪神教绵延几千年信仰的纽带。<br>邪神辛克莱温是……                                           </p>
<p>——选自帝国学者载丝莉《邪神起源探究》</p>
<h2 id="克雷多斯族"><a href="#克雷多斯族" class="headerlink" title="克雷多斯族"></a>克雷多斯族</h2><pre><code>      平庸是进化论所给我们最后的仁慈——帝国医学教科书扉页
</code></pre>
<p>奥诺斯是社会达尔文主义者的神，他的教义就是物竞天择，适者生存，让优秀的种族淘汰低劣的种族。放到现在他肯定会被当做邪神。奥诺斯创造过很多种族，大部分在穷兵黩武中走向了灭亡，然而其中有一个民族最为他所垂青——克雷多斯族。这一种族刚出现时平平无奇，但他们的眼中只有强者，尊严的力量促使着他们不断发挥着潜力，追逐着比自己强大无数倍的敌人。他们逐渐走向强盛，但后来因为自相残杀导致族人寥寥无几。这时，一位天才创造出了一种把他们一分为二的方法，以此来把自己当做对手，起初，克雷多斯族凭借这一方法几乎成为世界上最令人恐惧的种族，深深地让奥诺斯感到自豪。然而，在与自己的斗争中，有的族人学会了“阴谋”，将另一个自己与其他敌人算计致死，有的人学会了“隐忍”，进而学会了妥协与认输，最终，他们都选择了“平庸”。为了心爱的子民惋惜不止的奥诺斯神来到了最后一个保持着绝对尊严的战士面前：</p>
<p>“我也给予你选择平庸的权利。”</p>
<p>“你要我变得和他们一样吗?绝不！！！”</p>
<p>战士怒吼着冲向了最后一个对手。从此，奥诺斯和他的战士消失于迪瑞克拉世界。</p>
<h2 id="沉默峡谷"><a href="#沉默峡谷" class="headerlink" title="沉默峡谷"></a>沉默峡谷</h2><p>沉默不是逃避，而是一种选择——沉默沼泽路牌上的涂鸦</p>
<p>沉默峡谷被命名并正式标在官方地图上是帝国历387年的事了，在此之前它只是个普通的荒凉之处而已，当然，还是偶尔进入的旅客发现这里——但他们有的没能走出来，有的在出来后被别人或自己当成了疯子。</p>
<p>沉默峡谷的土壤和两侧的山岩有种特殊的性质，能几乎把所有的声音消除，巴比伦塔的学者曾对此展开研究，然而他们一无所获。除此以外，沉默峡谷就是个普通的荒凉峡谷，稀疏的杂草养不出大型动物，对一个经验丰富的旅行者而言，找到水源，辨别方向和驱散毒虫都不算难 ——只要他能忍受无尽的沉默</p>
<p>在被载入地图后，这里逐渐成了修士的圣地，当然，也有人进去后再也没有出来</p>
<h2 id="幻影沼泽"><a href="#幻影沼泽" class="headerlink" title="幻影沼泽"></a>幻影沼泽</h2><p>警告！魔术师慎入！</p>
<p>这是沉默峡谷一处著名的景点，和峡谷本身一样，这里也几乎没什么异常，对有防备的旅行者而言并没什么危险。传说中一位善于擅长表演幻影魔术的魔术师来到这里时，将自己当做了幻影，而把幻影当成了真实。于是他迷失在这里，将此处化成了一片沼泽，如果一位有真才实学的魔术师来到这里，那么他绝对无法精神正常地离开，尽管对其他人而言，这里能看到的异象仅仅是偶尔出现魔术师忧郁的身影而已。</p>
<h2 id="沉默王国"><a href="#沉默王国" class="headerlink" title="沉默王国"></a>沉默王国</h2><p>………………………………</p>
<p>沉默王国一直是个传说，一开始只是有少数人怀疑那些进了峡谷再没有出来的人到底去了哪里？这些怀疑逐渐被时间埋葬，直到帝国标记了沉默峡谷的存在导致一批旅行者来此游览，，有些旅行家发现了沉默王国的存在，很难想象一个王国会存在于荒野，事实上，那里只是寥寥几个人的聚居处。住民们给了旅行家一些食物和饮水，并为他指明了道路，从始至终，他们都带着沉默，从未试图张开嘴唇过。</p>
<p>此后又陆陆续续地出现了类似住民目击报告，但都被帝国封锁，最终，这一切成为了传说或是怪谈，奇怪的是，帝国似乎对此颇为忌惮，从此以后沉默峡谷再也没有出现在官方文件上过。</p>
<p>  我们认为那些住民的存在涉及了达瑞克拉世界的源论，可以肯定那是一些向往沉默的人，不知何时他们聚集起来，用各自的思虑创造了一个无声的世界——或许跟0号研究所揭示的结果一致，这十分危险，一旦被人们知道，达瑞克拉世界或许会因此毁灭。</p>
<pre><code>                                 ——《关于沉默王国的报告》
</code></pre>
<h2 id="0号研究所"><a href="#0号研究所" class="headerlink" title="0号研究所"></a>0号研究所</h2><p>我思故我在，我在故我思。——帝国哲学家卡尔迪</p>
<p>0号研究是科学组织浮士德所进行的一场实验，没错，与大多数我同事的想法相反，它并不是个邪教组织，从同行的角度来说，我很佩服他们的开创性。</p>
<p>0号研究所本是个普通的小镇，如果不是那件事的发生，我们永远不会知道这里曾发生过这样的实验。</p>
<p>帝国的审讯所抓到过一个浮士德的高层，今天他们终于设法让他开口了，由此我们终于知道他们是怎么进行实验的。首先，小镇只是出现了一些以屠戮人民，掠夺财物为乐的人，他们穿着迥异的衣服，却意外有着纯正的当地口音，经过一番协力，这些人不久就被送上了断头台。</p>
<p>奇怪的是，他们面对死亡毫无畏惧，自称“玩家”的他们发出了下次进犯的预告，然后在断头台上化成白光消失了。</p>
<p>当天，一切有关他们的消息被政府封锁，几乎同时不少“智者”跳了，要求让民众得知真相，惴惴不安中，很多小册子在民众中传阅——上面说这个世界只是虚构，完全为了让那些玩家取乐而存在（至于为何能让民众了解虚幻的概念，或许浮士德的教育机制还是挺有成效的）</p>
<p>第二天，更多所谓的“玩家从天而降”，所有住民都陷入了绝望与怀疑，就在这时我们所知的异变发生了，没人知道这是怎么做到的，但整个克罗利安镇就这么化为一片混沌之地，我们的不少调查员在第一眼看到它的遗址时就发疯了——我们没人知道为什么。</p>
<p>现在那里应该已经封闭了，我的建议是，永远封闭下去，或许邪神辛克莱温是对的，这个世界确实由我们的思想决定。我希望所有人都能对此提高警惕，永远不要让类似的事故重演 </p>
<h2 id="帕斯卡王国"><a href="#帕斯卡王国" class="headerlink" title="帕斯卡王国"></a>帕斯卡王国</h2><p>世上哪有不建立在剥削上的幸福？</p>
<p>帝国前36年，在正片大陆一个名不见经传的角落有一个小国，这个国家物资贫瘠，人口稀疏，尽管气候不算恶劣，但人民常常处于食不果腹的状态。</p>
<p>国王帕列斯是位平庸的君主，他的儿子——王子恩西斯却是位有想法的年轻人，尽管刚刚成年，他已经开始思索如何壮大自己的国家，这位王子曾经游学诸国，每次看到国民因营养不良而矮小纤弱的身材，他都会在心中发誓一定要找到让子民过上幸福快乐生活的方法</p>
<p>有一天，他带着这个愿望，带着几位侍从出门远行，在一番艰难跋涉后，王子在荒野中迷路了，他仿徨了几天，终于有一天他发现了一个村落</p>
<p>这个村落贫瘠弱小，王子注意到他们大量以烤制生肉，野菜，甚至昆虫而食，他们没有国王或者地位高于其他居民的人，尽管如此，他们的脸上却常常洋溢着笑容</p>
<p>王子作为外来人并没有对这些野人产生太多影响，于是他也学着野人的样子，用茅草和树枝搭起简易的居所，尝试融入野人的生活</p>
<p>一个月后，当国王派出的宫廷军顺着王子迷路时留下的标记找到他时，王子正喃喃自语道：我要找到的道路，就在这里啊</p>
<p>归国后几月，王子继位成为了国王，他实现了自己的诺言，在他的治理下，他的子民过上了物质丰富，精神充足的生活——凭借着王子制定并实现的驯养土著成为奴隶的方法。建立帕索斯帝国后五年，王子临终，面对伏在病榻前痛苦的子孙，他淡淡地说：他们以前就没有国王，以后也不会有吧。随后他保持着沉默，任凭御医记录他由有到无的脉搏直至最后</p>
<p>帝国历364年，历经三百年的不懈斗争，萨曼人杰出的领袖终于为族人争取到了自由，帝国，这一最先实现奴隶制的国家，最终成为了民主共和的起源……              ——《帝国通史》</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>基于北大前沿计算实践课和missing semester的vim笔记</title>
    <url>/2023/09/19/vim%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="you-are-your-dotfiles"><a href="#you-are-your-dotfiles" class="headerlink" title="you are your dotfiles"></a>you are your dotfiles</h1><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>按f1或命令行输入help开启在线帮助<br>&lt;Cw&gt;切换到另一个窗口q关闭窗口</p>
<span id="more"></span>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>如之前所述，Vim最主要的编辑模式是Insert模式，想要修改文本，先将光标在Normal模式下移动到对应位置，然后再键入<code>i</code>进入Insert模式，在这个模式下添加或者删除文本。但是当我们需要修改的地方非常多时，每次都需要先移动光标再输入<code>i</code>就是一个相对麻烦的操作，因而Vim提供了一些命令将移动光标和进入Insert模式合成一步：</p>
<ul>
<li><code>i</code>在当前位置输入（光标前），<code>I</code>在行首输入</li>
<li><code>a</code>在光标后输入(append)，<code>A</code>在行尾输入</li>
<li><code>o</code>在当前行下新建一行输入，<code>O</code>在当前行上新建一行输入</li>
<li><code>c</code>+光标移动命令会先删除然后进入Insert模式，比如<code>cl</code>会删除下一个字符，<code>cw</code>会删除到单词尾，<code>c10l</code>会删除10个字符。此外，<code>ciw</code>会删除整个单词，<code>cc</code>会删除整行，<code>ci(</code>(change in)会删除小括号里的内容，<code>ca(</code>(change around)则会删除小括号以及小括号里的内容，这在修改代码里的字符串、修改函数变量之类的工作中极其有用</li>
<li><code>s</code>(substitute)会删除当前字符并进入Insert模式，等同于<code>cl</code></li>
<li><code>r</code>(replace)替换当前字母</li>
<li><code>p</code>把上次删除的行放置在当前位置</li>
</ul>
<p>进入Insert模式之后，Vim也有一些奇奇怪怪的命令，比如<code>&lt;C-h&gt;</code>等同于删除键，会删除前一个字符，<code>&lt;C-j&gt;</code>等同于回车键，将光标后的文本移到下一行，但是否要这样做就全凭个人喜好了。<br>其实在Normal模式下也能进行一些删除操作，<code>x</code>会删除当前字符，<code>d</code>+光标移动命令会删除对应文本，与<code>s</code>以及<code>c</code>命令的区别仅仅在于<code>x</code>和<code>d</code>操作完之后依然处在Normal模式，所以<code>s</code>也等同于<code>xi</code>。此外，<code>r</code>的作用也是替换当前字符，键入<code>r</code>之后会提示输入一个字符，输入完成之后自动回到Normal模式，想要替换长文本就需要键入<code>R</code>进入Replace模式。因此如果想要替换一个字符成x，最快的方法是<code>r</code>+x，也可以<code>s</code>+x+<code>&lt;ESC&gt;</code>，也可以<code>xi</code>+x+<code>&lt;ESC&gt;</code>，也可以<code>cl</code>+x+<code>&lt;ESC&gt;</code>。<br>撤销和重做也是非常常用的编辑命令，在Vim中分别对应Normal模式下的<code>u</code>(undo)和<code>U</code>，同时<code>.</code>可以重复之前最后一个命令。<br>“U”（行撤销）。恢复整行的所有操作<br>&lt;C-r&gt;重做上一个 被撤销的命令</p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>在Normal模式下键入<code>:</code>就会进入命令行模式，此时光标已经移动到了最下面。命令行中可以输入的命令种类非常多：</p>
<ul>
<li><code>w</code>保存文件，但是不退出</li>
<li><code>w !sudo tee %</code>使用sudo保存文件<br> w filename保存文件到当前目录</li>
<li><code>wq</code>、<code>x</code>、<code>ZZ</code>保存并退出</li>
<li><code>q!</code>、<code>ZQ</code>退出但不保存</li>
<li><code>!</code>+命令 可以在shell环境下执行命令</li>
<li><code>r !</code>+命令 可以在shell环境下执行命令并插入到当前光标下一行</li>
<li><code>e</code>+文件 可以加载新的文件（当前文件没保存的话会报错）</li>
<li><code>e!</code>+文件 加载新文件并丢弃当前更改</li>
<li><code>f</code>显示当前文件的文件名</li>
<li><code>%s/old/new/g</code>搜索所有<code>old</code>并替代成<code>new</code>，支持正则表达式o<br>命令行界面输入&lt;Cd&gt;显示可以选择的命令，tab自动补全o</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>除了这些直接跳转命令，Vim也提供了搜索机制。<br>首先是行内的搜索，<code>f</code>、<code>t</code>、<code>F</code>、<code>T</code>后面加上任意字符x，代表跳转到当前光标下一个x、跳转到下一个x之前、跳转到上一个x、跳转到上一个x之后，搜索到了之后也可以继续按<code>,</code>和<code>;</code>在搜索结果之间前后移动。<br>然后是文件内的搜索，<br>直接键入<code>/</code>或者<code>?</code>会进入命令行搜索模式，<code>/</code>是从开头开始搜索，<code>?</code>是从结尾开始搜索，后面可以加上任意长度的字符<br>然后键入<code>&lt;CR&gt;</code>就可以高亮显示所有的搜索结果，按<code>n</code>和<code>N</code>就可以在搜索结果之间向前和向后移动。<br>输入:set ic(ignore case)忽略大小写搜索 set noic取消<br>仅搜索一次忽略大小写:&#x2F;search_sth\s<br>输入:set hls is高亮搜索结果<br>&#x2F;&#x2F;‘ic’ ‘ignorecase’ ignore upper&#x2F;lower case when searching</p>
<p>‘is’ ‘incsearch’ show partial matches for a search phrase</p>
<p>‘hls’ ‘hlsearch’ highlight all matching phrases<br>搜索模式支持正则表达式。最后如果想要关闭搜索结果的高亮，需要借助命令行命令，输入<code>:noh</code>即可关闭高亮。<br>type :#,#s&#x2F;old&#x2F;new&#x2F;g where #,# are the line numbers of the range</p>
<p>of lines where the substitution is to be done.</p>
<p>Type :%s&#x2F;old&#x2F;new&#x2F;g to change every occurrence in the whole file.</p>
<p>Type :%s&#x2F;old&#x2F;new&#x2F;gc to find every occurrence in the whole file,</p>
<p>with a prompt whether to substitute or not.</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>编辑文本和代码难免要复制和粘贴，复制操作涉及到选择需要复制的文本，在Vim中这需要在Visual模式下进行。在Normal模式中键入<code>v</code>进入选择模式，可以跟在Normal模式下一样移动光标，被选择的文本就会高亮。<br>或者在Normal模式中键入<code>V</code>进入行选择模式，被选择的行会高亮。选择完成后，如果直接按<code>&lt;ESC&gt;</code>就会返回Normal模式，并且选择的内容高亮消失，因此不应该这么做，而应该直接在Visual模式下键入<code>y</code>(yank)复制高亮的文本，如果输入的是<code>d</code>则会删除被选择的文本，此时会自动回到Normal模式。<br>不管是<code>y</code>还是<code>d</code>操作，被选择的文本都会被操作到Vim的缓存中，在Normal模式下按<code>p</code>就会粘贴其中的文本到当前位置。与之前介绍的<code>cc</code>、<code>dd</code>类似，也可以直接在Normal模式下输入<code>yy</code>，对应复制当前行。<br>Vim还提供了列选择模式，在Normal模式下键入<code>&lt;C-V&gt;</code>进入，选择完列之后可以跟Normal模式一样进行<code>r</code>、<code>d</code>等操作，这在制表、注释中非常有用。</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>Vim中所有键盘输入都可以视为命令，可以被记录下来映射到快捷键。在Normal模式下，最基本的命令是控制光标移动的命令<code>hjkl</code>，其中<code>jk</code>控制上下(大写状态下删除行间空格)，<code>hl</code>控制左右，方向键同样可以控制光标，但是因为方向键盘离打字的范围比较远，所以推荐大家熟悉<code>hjkl</code>这四个键。在没有鼠标的情况下想实现长距离的光标跳转，每次只能移动一个单位显然是低效的，好在Vim为光标跳转提供了多种命令：</p>
<ul>
<li><p>单词间：<code>w</code>可以跳转到下一个单词的开头，<code>b</code>跳转到当前单词的开头，继续按跳转到上一个单词的开头，<code>e</code>跳转到当前单词的结尾，继续按跳转到下一个单词的结尾</p>
<blockquote>
<p>遗憾的是中文很难分词，所以在中文中键入<code>w</code>会跳转到下一个短句</p>
</blockquote>
</li>
<li><p>括号、引号间：如果光标在括号或者引号中间，<code>%</code>会高亮显示括号或引号，继续按会在头和尾反复横跳</p>
</li>
<li><p>行内：<code>0</code>跳转到行的开头，<code>^</code>跳转到行的第一个非空格的字符，<code>$</code>跳转到行的结尾</p>
</li>
<li><p>段落间：<code>&#123;</code>跳转到上一段，<code>&#125;</code>跳转到下一段</p>
</li>
<li><p>屏幕内：<code>H</code>跳转到屏幕最上面，<code>M</code>跳转到屏幕最中间，<code>L</code>跳转到屏幕最下面</p>
</li>
<li><p>屏幕滑动：<code>&lt;C-u&gt;</code>向上滑动，<code>&lt;C-d&gt;</code>向下滑动</p>
</li>
<li><p>文件内：<code>gg</code>跳转到文件开头，<code>G</code>跳转到文件结尾,</p>
</li>
<li><p>&lt;CG&gt;显示当前行数，数字G跳转到对应行</p>
</li>
<li><p>其他：<code>zz</code>会将光标置于屏幕中心</p>
</li>
</ul>
<p>这些基本命令可以和数字进行组合，输入任意数字（默认情况下显示在右下角），然后输入<code>j</code>就会向下移动对应行数，同理，如果是数字+<code>w</code>，就会移动对应单词数。另外，数字+<code>&lt;CR&gt;</code>等同于数字+<code>j</code>，数字+<code>G</code>会跳转到整个文件的第几行。  </p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>Normal模式是最基本的模式，在这个模式下基本只能移动光标，不能直接输入文本，因为此时键入任何字符都会被当成是Vim的命令而非插入到文本中。想要输入文本需要切换到Insert模式，可以直接键入<code>i</code>进入Insert模式，此时输入任何字符都会插入到光标所在位置。想从输入模式中返回Normal模式，只需要键入<code>&lt;ESC&gt;</code>。事实上，在任何模式下键入<code>&lt;ESC&gt;</code>都 能回到Normal模式。Normal模式和Insert模式是Vim中最常用的两种模式，理论上我们只需要这两种模式就能完成修改文本的所有操作，其他 模式和命令都是用来更快地完成一些任务。默认情况下，所处模式会显示在Vim窗口的左下角，Normal模式没有显示，Insert模式会显示<code>--INSERT--</code>，Command-line模式会显示所输入的命令等等。在Normal模式下键入<code>R</code>进入Replace模式，用于替换当前光标处的文本，键入<code>v</code>进入Visual模式，用于选择文本。</p>
<p><img src="/images/obsidian/vim-mode.jpg" alt="图片" title="image"></p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>.命令重复上一次命令，可用于简化操作</p>
<ul>
<li>C&#x3D;c$</li>
<li>s&#x3D;cl</li>
<li>S&#x3D;^C&#x2F;&#x2F;整行替换</li>
<li>I&#x3D;^i</li>
<li>A&#x3D;$a</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>vim</tag>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉rpg设定集</title>
    <url>/2023/09/19/%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89rpg%E8%AE%BE%E5%AE%9A%E9%9B%86/</url>
    <content><![CDATA[<h1 id="队友"><a href="#队友" class="headerlink" title="队友"></a>队友</h1><h2 id="雷克"><a href="#雷克" class="headerlink" title="雷克"></a>雷克</h2><p>帝国法律系学生，成长于如今兄弟会的前身，幼时被走投无路的父母托付给了盗贼兄弟会，并经受了盗贼训练，随后由于帝国发展进程，盗贼兄弟会决定洗白自己，于是选拔了手下聪明的学徒接受高等教育并改名兄弟会，雷克就是其中的佼佼者。</p>
<span id="more"></span>
<p>然而比起兄弟会肮脏的勾当，接触帝国新兴教育的雷克逐渐有了叛逆之心，比起法律他对医学更有兴趣，一开始是偷一些新鲜死体进行解剖，随后甚至发展成了诛杀一些地痞流氓并进行各种实验和解剖的连环杀人犯，因为这些经历，雷克下手狠辣，反应敏捷，是个优秀的盗贼。<br>偷挖尸体时被无名氏发现，并且无名氏的强大气息让他不敢敌对，由于无名氏缺少一个熟悉帝国的向导，雷克就这样被要挟着加入了队伍<br>性格意外地开朗，似乎是个不错的朋友，但很难定论他的内心藏着多少黑暗<br>阵营守序中立</p>
<h2 id="莉思"><a href="#莉思" class="headerlink" title="莉思"></a>莉思</h2><p>法师塔的高材生，学徒转正的试炼中，大法师们补下幻象，让她对决所有的同届学生，想让她意识到团结的力量，但聪明的她早就对所有人做了各种应对方案，在随机应变和一些运气下，莉思真的击败了所有对手，并且由于情况危急，她下了死手。<br>试炼完成后，在场的法师们不约而同地认识到她危险的性格是个定时炸弹，想要剥夺她的法师资格，绝望的莉思却听到了一个神秘的声音，随着声音的指引她发动了不可能成功的传送法术去到了帝国边境。<br>在那里她隐姓埋名，用几年时间成为了一位名气不小的实战派法师，随后遇到了无名氏。<br>“你身上有强大法术的气息，让我感到熟悉,我希望能与你同行”<br>阵营中立邪恶</p>
<h2 id="默克"><a href="#默克" class="headerlink" title="默克"></a>默克</h2><p>因为违反规则，徘徊于主物质界的欲灵<br>欲灵必须满足驯服他们的人类的三个愿望，但如果另一个欲灵驯服了他呢？结果就是他被规则诅咒只能徘徊于主物质界。<br>有一个欲灵伪装成人类向他许愿，这个愿望则来自一个驯服他的人类，也就是无名氏，因此才出现了这种错误。<br>这个愿望是忘记一切过去，但不知为何空间也出现了扭曲，实现愿望后，无名氏和默克被传送到一座古墓，醒来的无名氏逮住了他，思考后默克决定与他行动，寻找那个肆意妄为的欲灵。<br>为了不引发好奇，设置了一个猫头鹰幻身<br>阵营混乱中立</p>
<h2 id="欲灵女王"><a href="#欲灵女王" class="headerlink" title="欲灵女王"></a>欲灵女王</h2><p>传闻中她是一个强大的欲灵，因此能统率大批同类为其所用，但实际上她只是一个人类法师，因为善于倾听欲灵的烦恼并安抚它们，她曾让不少欲灵摆脱了由于灵魂不纯而徘徊物质界与元素界之间的痛苦，作为回报，欲灵们生前的回忆与知识有部分被她所理解，因此论阅历属于当世法师的佼佼者。<br>其自称自己的天赋一般，并对胜负毫不在意，所以，平常不会显露出多强的实力，但总感觉她留了一手<br>年龄未知，自称对玩弄无名氏的欲灵感兴趣而与他同行<br>阵营中立善良</p>
<h1 id="npc"><a href="#npc" class="headerlink" title="npc"></a>npc</h1><h2 id="苦惨女士"><a href="#苦惨女士" class="headerlink" title="苦惨女士"></a>苦惨女士</h2><p>“去杀戮，去破坏，去抢夺吧，除此以外没有获得救赎的办法了，而我会在此，为您承担所有的罪孽”</p>
<p>对七苦圣母的信仰，由于教规和神迹的苛刻，在几百年间逐渐地消失了，苦惨之女，数百年前经过血祭仪式得到圣母祝福之人，如今以及经过了她第七个，也是最后一个人生，苦恼着如何度过最后时日的她遇到了无名氏，在他身上纠缠着的痛苦命运让她深受感化。<br>“或许经历这样的痛苦才能有所领悟”<br>因此她向无名氏提出了请求，再次进行仪式，让她承担无名氏战斗时收到伤害的一半。<br>在伤害积累到一定程度后，她会死去，并在死后继续赋予无名氏减伤的祝福<br>如果拒绝她，或者积累的伤害不够，苦惨女士由于没有领悟到七苦之义，在之后的时日度过了平凡而幸福的一生。</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>基于苏大ppt的计算机硬件笔记</title>
    <url>/2023/09/19/%E7%A1%AC%E4%BB%B6%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&#96;冯·诺依曼计算机特点<br>– 计算机由五大部件组成<br>• 输入数据和程序的“输入设备”<br>• 记忆程序和数据的“存储器”<br>• 完成数据加工处理的“运算器”<br>• 控制程序执行的“控制器”<br>• 输出处理结果的“输出设备”  </p>
<span id="more"></span>
<p>– 指令和数据以同等地位存于存储器，可按地址寻访<br>– 指令和数据用二进制表示<br>– 指令由操作码和地址码组成<br>– 以运算器为中心<br>基础逻辑电路：与门，非门，或门，异或门，与非门，或非门，同或门<br>半加器<br>– 𝑆𝑖当前位， 𝐶𝑖进位符<br>全加器  （包括之前的进位cn-1）<br>– 𝐹𝑛当前位， 𝐶𝑛进位符<br>𝐶𝑛 &#x3D; 𝑋𝑛 ⋅ 𝑌𝑛 + 𝑋𝑛⨁𝑌𝑛 ⋅ 𝐶𝑛−1<br><img src="/images/obsidian/20230531113546.png" alt="图片" title="image"><br><img src="/images/obsidian/20230531113559.png" alt="图片" title="image"><br><img src="/images/obsidian/20230531113735.png" alt="图片" title="image"><br>CPU与外设之间的数据交换必须通过接口来完成，通常接口有<br>以下一些功能：<br>– 设置数据的寄存、缓冲逻辑，以适应CPU与外设之间的速度差异；<br>– 进行信息格式的转换，例如串行和并行的转换；<br>– 协调CPU和外设两者在信息的类型和电平的差异，如电平转换驱动器、<br>数&#x2F;模或模&#x2F;数转换器等；<br>– 协调时序差异；<br>– 地址译码和设备选择功能；<br>– 设置中断和DMA（直接存储器存取）控制逻辑，以保证在中断和DMA<br>允许的情况下产生中断和DMA请求信号，并在接受到中断和DMA应答<br>之后完成中断处理和DMA传输。<br>&#96;为何要用二进制表示（冯.诺依曼核心）<br>– 无法制造多个稳定状态的物理器件<br>– 编码、计数、运算规则简单<br>– 和逻辑的真、假对应，通过逻辑门电路可实现算数运算<br>BCD码<br>– 机器中用4位二进制对每个十进制数位进行编码方法<br>– 4位二进制有16种组合，选取其中的十个。<br>– 常用的方法有：8421码、余3码、格雷码</p>
<p>为什么要用BCD码<br>– 高精确度的计算<br>– 耗费更多的存储空间<br><code>数的定点与浮点表示   – 十进制的公式表示：𝑁 = 10𝐸 ∗ 𝑆   – 二进制数的公式表示：𝑁 = 2𝐸 ∗ 𝑆   • 定点数：阶码𝐸位置固定，存储时统一忽略阶码   – 定点整数: 𝐸 = 0， 𝑆为纯整数，小数点固定在数值部分的右边   – 定点小数: 𝐸 = 0， 𝑆为纯小数，小数点固定在数值部分的左边 </code>浮点数详解<br>– 浮点数的表示范围<br>• 阶码E的范围：−128 ≤ 𝑒 &lt; 127<br>• 最大正数：0.111 … 1 × 2011…1 &#x3D; (1 − 2^−23) × 2^127<br>• 最小正数：0.100 … 0 × 2100…0 &#x3D; 1<br>2 × 2−128 &#x3D; 2−129<br>– 浮点数的表示精度<br>• 总位数不变<br>– 阶码越大：数值表示范围越大<br>– 尾数越少：精度变低<br><img src="/images/obsidian/20230531114156.png" alt="图片" title="image"><br>机器数的表示形式：原码、反码、补码<br>– 原码：符号+真值<br>• +41 原 &#x3D; 0 0101001， −41 原 &#x3D; 1 0101001<br>• +0 原 &#x3D; 0 0000000， −0 原 &#x3D; 1 0000000<br>– 反码：正数不变，负数时符号不变，其他各位取反<br>• +41 反 &#x3D; 0 0101001， −41 反 &#x3D; 1 1010110<br>• +0 反 &#x3D; 0 0000000， −0 反 &#x3D; 1 1111111<br>– 补码：正数不变，负数为反码+1（计算机表示带符号数的方法）<br>• +41 补 &#x3D; 0 0101001， −41 补 &#x3D; 1 1010111<br>• +0 补 &#x3D; 0 0000000， −0 补 &#x3D; 0 0000000<br>• +127 补 &#x3D; 0 1111111， −127 补 &#x3D; 1 0000001<br>• −128 补 &#x3D; 1 0000000<br>&#96;溢出<br>– 运算结果超出机器数所能表示的范围时，称为溢出<br>– 定点数溢出的判断方法<br>• 两个同符号的数相加，得到的和的符号与相加数的符号不一致。<br>– 采用双符号位：正数的符号位为00，负数的符号位为11。符号位参加运算。如果<br>两个符号位不相同，则溢出。（浪费资源）<br>• 任意两数相加，如果数值最高位的进位不等于符号位的进位，则溢出。<br>– 浮点数溢出的判断方法<br>• 看阶码是否溢出！</p>
<p>BCD码：用四位二进制数表达一个十进制数，方便运算和显示<br>浮点数：尾数S和阶码E<br>符号+阶码+符号+尾数<br>反码：正数不变，负数除了符号位取反<br>补码：正数不变，负数除了符号位加一<br>+0：00000000<br>-128:10000000<br>[x+y]补&#x3D;[x]补+[y]补<br>[x-y]补&#x3D;[x]补+[-y]补</p>
<p>有效地址EA&#x3D;基址（BX&#x2F;BP）+变址值(SI&#x2F;DI)+位移量DISP<br>+段基址&#x3D;物理地址</p>
<h2 id="CISC和RISC是CPU的两种基本架构"><a href="#CISC和RISC是CPU的两种基本架构" class="headerlink" title="CISC和RISC是CPU的两种基本架构"></a>CISC和RISC是CPU的两种基本架构</h2><p>– CISC：寻址方式多，方便编程<br>– RISC：寻址方式少，指令短、规整</p>
<h3 id="RISC特点"><a href="#RISC特点" class="headerlink" title="RISC特点"></a>RISC特点</h3><p>– 指令系统<br>• RISC指令长度相同；寻址方式少；指令执行时间相当<br>– RISC CPU内部寄存器多<br>– 存储器操作<br>• 只有取数&#x2F;存数指令访问存储器，大部分指令都在寄存器之间进行<br>– 代码量增多，实现特殊功能时程序复杂<br>– 较少的单元电路，面积小，功耗低<br>– 结构简单，设计周期短</p>
<h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h3><p>– PC发起地址查询<br>– 内存依据地址返回指令&#x2F;数据<br>– CPU进行指令解析<br>– PC增量或PC赋值<br>• 指令结构<br>– 操作码+地址码（操作数所在地）</p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>立即数寻址（办理人随身携带）<br>– 操作数由指令的地址码部分直接给出来<br>• 操作码+操作数  </li>
<li>寄存器直接寻址（办理人已寄存）<br>– 指令地址码部分给出某一通用寄存器地址<br>– 从寄存器存取数据比主存快得多<br>– 由于寄存器的数量较少，其地址码字段短</li>
<li>直接寻址（办理人在队伍里）<br>– 指令中地址码字段给出操作数的地址<br>• PC赋值——取操作数</li>
<li>间接寻址（办理人在哪问家长）<br>– 指令中给出的地址是存放操作数地址的地址<br>– 寄存器间接寻址（家长已寄存）<br>– 存储器间接寻址（家长在队伍里）</li>
<li>偏移寻址（相对寻址）<br>– 从我往后数A个<br>– EA：有效地址<br>– 相对寻址： EA&#x3D;A+(PC) 相对于当前指令处位移量为A的单元<br>– 基址寻址： EA&#x3D;A+(B) 相对于基址(B)处位移量为A的单元<br>– 变址寻址： EA&#x3D;A+(I) 相对于首址A处位移量为(I)的单元</li>
</ul>
<h2 id="8086-8088微处理器"><a href="#8086-8088微处理器" class="headerlink" title="8086&#x2F;8088微处理器"></a>8086&#x2F;8088微处理器</h2><h3 id="指令队列缓冲器"><a href="#指令队列缓冲器" class="headerlink" title="指令队列缓冲器"></a>指令队列缓冲器</h3><p>– 取指令时，每当指令队列缓冲区满一条指令，EU立即开始执行<br>– 当指令队列中有2个空字节（8088一个）BIU自动去取指<br>– EU从指令队列中去取指，然后执行指令，当该指令需要内存或<br>I&#x2F;O访问，EU请求BIU进入总线周期完成访问：<br>• BIU空闲状态：立即响应<br>• 正在取指：取指完后响应<br>– 指令队列已满，EU没有对BIU有请求，BIU进入空闲状态<br>– 执行转移、调用、返回指令：指令队列中的内容（原顺序指令）<br>被清除，BIU去取EU所指示的新的程序段指令</p>
<h3 id="寻址空间计算"><a href="#寻址空间计算" class="headerlink" title="寻址空间计算"></a>寻址空间计算</h3><p>– 8位机寻址：8根地址线<br>• 地址范围：0~255<br>• 最大内存空间：28 &#x3D; 256Byte<br>– 16位机：216 &#x3D; 64KB<br>– 32位机：232 &#x3D; 4GB<br>– 64位机：264 &#x3D; 16EB</p>
<h3 id="编程结构"><a href="#编程结构" class="headerlink" title="编程结构"></a>编程结构</h3><p><img src="/images/obsidian/20230603134629.png" alt="图片" title="image"><br>– 4个通用寄存器(16位)<br>• AX、BX、CX、DX（可8位单独使用）<br>– 4个专用寄存器(16位)<br>• BP（Base Pointer）基数指针<br>• SP（Stack Pointer）堆栈指针<br>• SI（Source Index）源变址<br>• DI（Destination Index）目的变址<br>– 4个段寄存器（16位）<br>• CS（Code Segment）代码段寄存器<br>• DS（Data Segment）数据段寄存器<br>• SS（Stack Segment）堆栈段寄存器<br>• ES（Extra Segment）扩展段寄存器<br>– CS用来存放程序当前使用的代码段的段地址，CPU执行的指令<br>将从代码段取得<br>• CS:IP构成传统意义的PC<br>– SS用来存放堆栈段的段地址，堆栈操作的数据就在堆栈段中<br>• 通常SS:SP和SS:BP构成堆栈段的访问<br>– DS用来存放数据段的段地址，一般地说，程序所用的数据就存<br>放在数据段中<br>• 通常DS:XX（通用寄存器）构成对数据段的访问；<br>– ES用来存放附加段的段地址，也用来存放数据，但典型用法是<br>存放处理后的数据</p>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存储器处于中心地位的原因："><a href="#主存储器处于中心地位的原因：" class="headerlink" title="主存储器处于中心地位的原因："></a>主存储器处于中心地位的原因：</h3><p>• 当前计算机正在执行的程序和数据均存放在存储器中，<br>CPU直接从存储器取指令或数据；<br>• 输入输出设备增多，数据传输速度加快，因此采用了<br>DMA(直接存储器存取)技术和输入&#x2F;输出通道技术，<br>在存储器与输入&#x2F;输出系统之间直接传送数据；<br>• 共享存储器的多处理机的出现，利用存储器存放共享<br>数据，并实现处理机之间的通信。</p>
<h3 id="存储器的分类和指标"><a href="#存储器的分类和指标" class="headerlink" title="存储器的分类和指标"></a>存储器的分类和指标</h3><p>随机存储器（random access memory，RAM）<br>• 又称读写存储器，指通过指令可以随机地、个别地对<br>各个存储单元进行访问（读写）的存储器<br>• 访问所需时间基本固定，与存储单元地址无关<br>• 停电会造成信号丢失<br>非易失性存储器<br>• 停电仍能保持其内容<br><code>容量 • 计算机可寻址的最小单位是一个存储字，一个存储字   所包括的二进制位数称为字长   • 一个字节（Byte）为8个二进制位（bit），一个字可   以由若干字节组成，一个字的字长通常是8的倍数。   • 主存储器的容量：以字或字节为单位来表示主存储器   存储单元的总数   • 单位：B、KB、MB、GB、 TB、PB、EB、ZB...   • 指令中地址码的位数决定了主存储器的可直接寻址的   最大空间   • 32位微型机提供32位物理地址，支持对4G字节的物理主存   空间的访问 </code>存储器存取时间(Memory Access Time)<br>• 又称存储器访问时间<br>• 启动一次存储器操作到完成该操作所经历的时间。<br>&#96;存储周期(Memory Cycle Time)<br>• 连续启动两次独立的存储器操作(例如连续两次读操<br>作)所需间隔的最小时间<br>• 主存储器和CPU是由总线连接的。CPU通过使<br>用AR（地址寄存器）和DR（数据寄存器）个<br>主存储器进行数据传送。若AR为K位字长，<br>DR为n位字长，则允许主存包含2^k个可寻址<br>字节或字。<br>• 在一个周期内，CPU和主存储器之间进行n位<br>数据传送。<br>读操作：存储器→CPU<br>• CPU把信息字的地址送到<br>AR,经地址总线送往主存<br>储器<br>• CPU通过控制总线发读<br>(Read)命令<br>• CPU等待主存储器的<br>Ready回答信号，Ready<br>为 1，表示信息已读出经<br>数据总线,送入DR。<br>AR：地址寄存器<br>DR：数码寄存器<br>主存储器的基本操作</p>
<p>• 写操作：CPU→存储器<br>• CPU把信息字的地址送<br>到AR，经地址总线送往<br>主存储器,并将信息字送<br>往DR<br>• CPU通过控制总线发写<br>(Write)命令<br>• CPU等待主存储器的<br>Ready回答信号，Ready<br>为 1，表示信息已从DR<br>经数据总线写入主存储<br>器</p>
<h3 id="读写存储器"><a href="#读写存储器" class="headerlink" title="读写存储器"></a>读写存储器</h3><p>按存储元件在运行中能否长时间保存信息分为静<br>态存储器SRAM和动态存储器DRAM两种<br>• 静态存储器：利用双稳态触发器来保存信息，只<br>要不断电，信息就不会丢失<br>• 动态存储器：利用MOS电容存储电荷来保存信<br>息，使用时需不断给电容充电才能使信息保持<br>• 静态存储器的集成度低，功耗较大；动态存储器<br>的集成度高，功耗小，主要用于大容量存储器<br>• DRAM每片容量大，引脚少; 价格低; 功耗低; 但<br>速度低，须再生。 DRAM一般用作计算机的主<br>存储器。<br>• SRAM速度快，价格较高，一般用作容量不大的<br>高速存储器。<br>DRAM和SRAM是可任意读写的随机存储器，当发生掉电时，存储的<br>内容容易立即消失，属于易失性存储器。<br>非易失性存储器，即使掉电，内容也不会消失：<br>只读存储器(ROM)<br>• 掩膜式ROM，由芯片制造商在制造时写入内容，以后只能读不能写<br>可编程序的只读存储器(PROM)<br>• 用户根据自己需要确定ROM的内容；<br>• 有熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元<br>的熔丝(写入)。<br>可擦除可编程序的只读存储器(EPROM)<br>• 产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线<br>照射后,浮置栅上的电子将逸散,即整体擦除。<br>可用电擦除的可编程序的只读存储器(E2PROM)<br>• 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写<br>入周期要几毫秒,寿命为10万次。<br>闪速存储器(Flash Memory)<br>• 用电擦除,但只能整体擦除或分区擦除。</p>
<h2 id="8086-8088存储器组织"><a href="#8086-8088存储器组织" class="headerlink" title="8086&#x2F;8088存储器组织"></a>8086&#x2F;8088存储器组织</h2><p>存储器分段<br>– 为什么分段<br>• 地址寄存器均为16位： 216 &#x3D; 64KB<br>– 分段方便操作系统进行存储管理<br>– 如何分段<br>• 8086地址空间为20位&#x3D;1MB，地址为5位16进制数：00000H~FFFFFH<br>– 从偏移地址考虑，理论上最多16个不重叠的地址段<br>– 从段地址考虑，最多可以定义216个不同段<br>– 段重叠<br>• 段区分配通常由操作系统完成<br>– CS、DS、SS、ES存储与程序相关的段基址<br>– IP、SP、BP、SI、DI存储与程序相关的偏移地址<br>逻辑地址和物理地址<br>– 逻辑地址<br>• 程序和指令表示的一种地址<br>• 包括两部分：段地址和偏移地址<br>– 物理地址<br>• 段地址*\16+偏移地址&#x3D;物理地址<br>– 寻址操作根据操作系统默认规则完成<br>堆栈（段）<br>– 机制<br>• 栈顶为唯一出入口<br>– 地址较小的一端<br>• 后进先出原则<br>– 作用<br>• 数据暂存<br>• 保留轨迹<br>段加偏移”寻址机制允许重定位<br>– 重定位是指一个完整的程序块或数据块可以在存储器所允许的空<br>间内任意浮动，并定位到一个新的可寻址的区域<br>– 允许程序和数据不需要做任何修改</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>• 微处理器的设计有CISC与RISC两种基本架构。深入理解16位微处理器8086的内部结构<br>及其工作原理，是掌握微机工作原理的基础和关键。Intel系列高档微处理器内部的复杂<br>结构及其工作原理，都是在8086CPU的结构基础上逐步分解结构和细化流水线操作而发<br>展起来的。透彻地掌握8086CPU的基础，将有利于理解高档微处理器的技术发展。<br>• 8086&#x2F;8088 CPU的内部结构由总线接口单元BIU和执行单元EU两部分组成。其内部有3<br>组共14个寄存器，必须了解它们各自的功能，并能掌握它们的使用方法。<br>• 总线周期是理解CPU按时序工作的重要概念。8086&#x2F;8088 CPU一个最基本的总线周期由<br>4个时钟周期组成，简称为4个状态，即T1、T2、T3与T4这4个状态。<br>• 微处理器的引脚及其功能是其重要的外部特性。由于8086／8088 CPU只有40条引脚，<br>学习和掌握它们的功能相对于高档微处理器说来就比较简单。</p>
<p>CF - 进位标志(Carry Flag),表示上一条指令的运算是否产生进位。如果产生进位,CF为1,否则为0。OF - 溢出标志(Overflow Flag),表示上一条指令的结果是否越界。如果结果超出目的操作数可以表示的范围,OF为1,否则为0。<br>SF - 符号标志(Sign Flag),表示上一条指令运算结果的符号。如果结果为负数,SF为1,如果为正数,SF为0。<br>ZF - 零标志(Zero Flag),表示上一条指令的运算结果是否为0。如果结果为0,ZF为1,否则为0。</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>计算机是通过指令来处理各种数据，为指出数据的来源、<br>操作结果的去向及执行何操作，一条指令必须包含以下信<br>息：<br>– (1) 操作码——位数及位置。<br>– (2) 操作数的地址——操作数的个数<br>– (3) 操作结果的存储地址。<br>– (4) 下一条指令的地址<br><code>指令长度   – 可以等于机器字长，也可以大于或小于机器字长。   • 尽可能短   • 等于字节的整数倍。   – 若所有指令的长度都是相等的，称为定长指令字结构   • RISC指令大多采用定长指令结构   – 若各种指令的长度随指令功能而异， </code>操作码<br>– 操作码的位数取决于计算机指令系统的规模<br>– 定长编码和变长编码<br>变长编码：分散地放在指令字的不同字段中，如INTEL 8086&#x2F;Pentium<br>– 优点：能表示更多的指令<br>– 缺点：增加了译码难度，控制器复杂<br><code>指令涉及的数据类型   – 地址：无符号数，一般是加减操作（含移位）   • 8、16或32位   – 数值数据   • 定点数（整数）：补码表示   – 16位、32位、64位   • 浮点数（实数）：IEEE754标准   – 位、位串、字符与字符串   • 用来表示文本、声音和图像等   • 字节、字(16位)、双字(32位)、四字(64位)   – 现代32位计算机通常以32位为一个字：字节、半字(16位)、字(32位)、双字(64位)   – 逻辑数据   • 按位操作（0-假/非0-真） </code>数据寻址方式<br>– 有效地址EA（Effective Address）&#x3D;基址值（BX或BP）+变址<br>值（SI或DI）+位移量DISP<br>• +段基址&#x3D;物理地址<br>– 根据命令判断字段长短<br>• 通常由寄存器长度决定</p>
<h3 id="寻址方式-1"><a href="#寻址方式-1" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>直接数据寻址</li>
<li>寄存器间接寻址（间接寻址目标为存储器，故不能确定目标位置长度）</li>
<li>基址加变址寻址</li>
<li>寄存器相对寻址</li>
<li>相对基址加变址寻址(带DISP的基址加变址寻址)<br>程序存储器寻址方式<br>– 实现程序转移<br>• 条件转移<br>– 段内短转移（-128~+127）<br>• JMP<br>– 段内&#x2F;段间，直接&#x2F;间接寻址<br>• CALL<br>– 段内&#x2F;段间，直接&#x2F;间接寻址<br>• 中断<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他寻址方式  </span><br><span class="line">– 串操作指令寻址方式  </span><br><span class="line">• 操作类别：清0、复制、比较等  </span><br><span class="line">• 源数据地址：DS:SI  </span><br><span class="line">• 目标数据地址：ES:DI  </span><br><span class="line">– I/O端口寻址方式  </span><br><span class="line">• 直接端口寻址  </span><br><span class="line">– IN AL, n OUT n, AL  </span><br><span class="line">– 端口号：0～255  </span><br><span class="line">• 间接端口寻址  </span><br><span class="line">– IN AL, DX OUT DX, AL  </span><br><span class="line">– 端口号：0～65535</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通用数据传送"><a href="#通用数据传送" class="headerlink" title="通用数据传送"></a>通用数据传送</h2><p>&#x2F;&#x2F;CS - Code Segment,代码段寄存器。它保存代码段的起始地址,用于查找程序的指令。IP - Instruction Pointer,指令指针寄存器。它保存下条指令的地址,用于告诉CPU去哪里找到下一条要执行的指令。<br>1、基本传送指令 MOV（Move）：传送<br>– 一般形式：MOV dest, src<br>• dest  src，将源操作数src复制到目的操作数dest，src不变<br>2、堆栈操作<br>– PUSH src<br>– POP dest<br>– LIFO后进先出<br>– 堆栈操作按字进行<br>– 不能POP CS<br>3、XCHG（Exchange）：交换<br>– 一般形式：<br>• XCHG oprd1, oprd2 ;交换oprd1与oprd2的内容<br>– 语法格式：<br>• XCHG reg&#x2F;mem, reg&#x2F;mem<br>4.字节翻译指令XLAT（代码转换或查表指令）<br>– BX 基址：代码转换表首地址（表大小：0~255）<br>– AL 偏移（码值）<br>MOV BX,0030H<br>MOV AL,5<br>XLAT</p>
<h2 id="目标地址传送类指令"><a href="#目标地址传送类指令" class="headerlink" title="目标地址传送类指令"></a>目标地址传送类指令</h2><p><code>LEA（Load Effective Address）装入有效地址   – 语法格式：LEA reg16, mem ;reg16 = mem的有效地址   – 通常用于建立串操作   – 对标志位的影响：无。   – 【例】设BX = 5678H   • LEA SI, 2\[BX]   ;执行后，SI = 567AH 将计算结果放入BX寄存器,而不会访问那个地址的值 </code>LDS reg16, mem<br>– 定位串操作源地址<br>– LDS SI, [DI+100AH]<br>– 低16位存入reg16，高16位存入DS<br><code>LES reg16, mem   – 定位串操作目标地址   – 同上，高16位存入ES </code>LAHF、SAHF（保存和设置标志位）<br>– 与AH寄存器交互<br>– SF：符号标志：运算结果符号位<br>– ZF：零标志：运算结果是否为0<br>– AF：辅助进位标志：低四位是否向高四位进位<br>– PF：奇偶标志：是否有偶数个1<br>– CF：进位标志：是否进位&#x2F;借位</p>
<h2 id="算术运算类指令"><a href="#算术运算类指令" class="headerlink" title="算术运算类指令"></a>算术运算类指令</h2><p>加法<br>– 一般形式：<br>• ADD dest, src ; dest  dest + src<br>• ADC dest, src ; dest  dest + src + CF<br>• INC oprd ;oprd  oprd + 1<br>– 语法格式：<br>• ADD reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• ADC reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• INC reg&#x2F;mem<br>– 对标志位的影响：<br>• ADD、ADC：按一般规则影响CF、OF、SF和ZF<br>• INC：不影响CF，其它同ADD<br>• ADD与ADC的2个操作数必须类型匹配，且不能同时是内存操作数<br>减法<br>– 一般形式：<br>• SUB dest, src ; dest  dest - src<br>• SBB dest, src ; dest  dest - src - CF<br>• CMP oprd1, oprd2 ; oprd1 - oprd2<br>– 与SUB的区别在于，不将减法结果存入dest，只影响标志位<br>• DEC oprd ; oprd  oprd - 1<br>• NEG oprd ; oprd  0 – oprd &#x3D; oprd + 1<br>– 语法格式：<br>• SUB reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• SBB reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• CMP reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>• DEC reg&#x2F;mem<br>• NEG reg&#x2F;mem<br>SUB、SBB、CMP：影响CF、OF、SF、ZF、AF和PF<br>• DEC：不影响CF，其它同SUB<br>• SUB与SBB的2个操作数必须类型匹配，且不能同时是内存操作数<br>乘法<br><code>– MUL（Unsigned Multiplication）：无符号乘法   – 一般形式：   • MUL src   – 语法格式：   • MUL reg8/mem8 ; AX = AL × src   • MUL reg16/mem16 ; DX:AX = AX × src   • 对标志位的影响：若8位×8位、16位×16位的结果分别能由8、16位容   纳（即结果的高一半为0），则CF = OF = 0，否则，CF = OF = 1；其   余标志无定义。   • 由于2个n位数的乘积可能需要2n位，因此，若操作数是8位，则结果为   16位；同样，16位操作数相乘结果为32位（80386中32位数相乘结果   为64位）。 </code>IMUL（Integer Multiplication）：带符号乘法<br>– 一般形式：<br>• IMUL src<br>– 语法格式：<br>• IMUL reg8&#x2F;mem8 ; AX &#x3D; AL × src<br>• IMUL reg16&#x2F;mem16 ; DX:AX &#x3D; AX × src<br>• 对标志位的影响：若结果的高一半为低一半的符号扩展，则CF &#x3D; OF &#x3D;<br>0，否则，CF &#x3D; OF &#x3D; 1；其余标志无定义<br>– 【例】对于同一个二进制数，采用 MUL与IMUL执行的结果可能<br>不同。设AL &#x3D; 0FFH，BL &#x3D; 1，分别执行下列指令，会得出不同<br>结果。<br>• MUL BL ; AX &#x3D; 00ffh（255D）<br>• IMUL BL ; AX &#x3D; 0ffffh（-1D）<br>除法<br>– 一般形式：<br>• DIV src ; 无符号数除法<br>• IDIV src ; 带符号数除法<br>– 语法格式：<br>• DIV reg&#x2F;mem<br>• IDIV reg&#x2F;mem<br>– 功能描述：<br>• src是8位：AX÷src，结果商在AL、余数在AH<br>• src是16位：DX:AX÷src，结果商在AX、余数在DX<br>– 对标志位的影响：无定义<br>– 若是8位÷8位或16位÷16位怎么解决？</p>
<p>符号扩展<br>– 对标志位的影响：无<br>– CBW、CWD（Convert Byte&#x2F;Word to Word&#x2F;Double word）<br>– 语法格式：<br>• CBW ; AL符号扩展为AX<br>– (若AL为正数,则零扩展,若AL为负数,则扩展部分全1)<br>• CWD ; AX符号扩展为32位数DX:AX<br>– 【例】设AL &#x3D; 0FEH，给出依次执行下列指令后的结果。<br>• CBW ; ax &#x3D; fffeh<br>• CWD ; dx &#x3D; ffffh, ax不变，即dx:ax &#x3D; -2<br>• 十进制调整指令（不要求）<br>– BCD码的加减乘除</p>
<h2 id="逻辑运算类指令"><a href="#逻辑运算类指令" class="headerlink" title="逻辑运算类指令"></a>逻辑运算类指令</h2><p>AND reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– OR reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– XOR reg&#x2F;mem, reg&#x2F;mem&#x2F;imm<br>– NOT reg&#x2F;mem<br>– TEST reg&#x2F;mem, reg&#x2F;mem&#x2F;imm；执行AND操作但不存储<br>结果<br>• 对标志位的影响：<br>– NOT：无。<br>– 其它指令：CF &#x3D; OF &#x3D; 0，按一般规则影响SF和ZF<br>&#96;使某位变反，其余位保持不变：对应位异或1，其余位为0<br>• 例： XOR AL, 60H ; 使第5、6两位为原来码的反码<br>• 特例： XOR AL, 0FFH &#x3D; NOT AL</p>
<h2 id="移位指令和循环移位指令"><a href="#移位指令和循环移位指令" class="headerlink" title="移位指令和循环移位指令"></a>移位指令和循环移位指令</h2><p>一般形式：<br>– SHL dest, count ; dest逻辑左移，count为移位次数<br>– SAL dest, count ; dest算术左移<br>– SHR dest, count ; dest逻辑右移<br>– SAR dest, count ; dest算术右移<br>– ROL, ROR循环左&#x2F;右移；RCL, RCR带进位标志循环左&#x2F;右移<br>对标志位的影响：<br>– 移位次数为1时，若移位后符号位发生了变化，则OF &#x3D; 1，否则<br>OF &#x3D; 0；若移位次数 &gt; 1，则OF无定义<br>– 按一般规则影响ZF与SF。然而，若移位次数为0，则不影响标志<br>位；CF为最后移入位<br>• 参数规范：当count &#x3D; 1时，可以立即数输入，否则需先<br>存入CL中；count取值范围0~255<br>• 【例】设AX的值为一个2字节非压缩BCD码，将其转换为<br>1字节压缩BCD码存入AL。<br>MOV CL, 4<br>SHL AH, CL ; ah低4位移到高4位<br>AND AL , 0FH ; al高4位清0<br>OR AL , AH</p>
<h2 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h2><p>目标和源都是存储器 (字、字节)<br>– DS:SI 提供源，ES:DI提供目的，CX提供长度<br>• 种类<br>– MOVS（Move）传送<br>– CMPS（Compare）比较<br>– SCAS（Scan）搜索<br>– LODS（Load）读<br>– STOS（Store）写<br>• 方向（DF标志位）<br>• 重复前缀<br>– REP（Repeat）<br>– REPE&#x2F;REPZ<br>– REPNE&#x2F;REPNZ</p>
<h2 id="程序控制类指令"><a href="#程序控制类指令" class="headerlink" title="程序控制类指令"></a>程序控制类指令</h2><p>无条件转移JMP（Jump）<br>• 一般形式：<br>– JMP target ; 转移到target指定的目标地址处<br>– 根据转移的距离，JMP指令可分为下列两类：<br>• 段内转移：在同一代码段内进行，又称近（Near）转移，只要修改IP的<br>值即可实现<br>• 段间转移：可在不同代码段之间进行，又称远（Far）转移，需要同时<br>修改CS和IP的值<br>– 根据目标地址的指定方式，JMP指令又可分为直接转移和间接转<br>移<br>• 直接转移：是指转移的目标地址直接出现在指令中，在程序执行前就已<br>确定<br>• 间接转移：指转移的目标地址是寄存器或内存操作数的值，只有执行到<br>该条指令时才能确定<br>– 直接转移<br>• JMP [NEAR PTR] label ; 段内转移<br>– 目标地址 &#x3D; IP + label（2字节） ; ±32KB<br>例：JMP ADDR1 ; ADDR1代表一个段内目标地址<br>ADDR1与当前IP位移量1235H, CS&#x3D;1500H, IP&#x3D;2400H<br>目的地址：18638H<br>JMP SHORT label<br>– 目标地址 &#x3D; IP + label（1字节） ; -128~127<br>• JMP FAR PTR label ; 段间转移<br>– 间接转移<br>• JMP reg16&#x2F;WORD PTR mem<br>; IP &#x3D; reg16&#x2F;mem16 段内间接转移<br>例：JMP FAR PTR ADDR2 ; ADDR2代表一个段间目标地址<br>ADDR2所在CS&#x3D;6500H，IP&#x3D;020CH<br>目的地址：6520CH<br>例：JMP BX ；BX→IP，CS不变<br>JMP WORD PTR [DI] ；[DS:DI] →IP，CS不变<br>JMP DWORD PTR mem<br>– ; CS &#x3D; [mem+2]，IP &#x3D; [mem]<br>例：当前CS&#x3D;1000H, IP&#x3D;026AH<br>DS&#x3D;2000H, BX&#x3D;1400H, ADDR3&#x3D;020AH<br>JMP DWORD PTR [BX+ADDR3]<br>CS&#x3D;4000H, IP&#x3D;320EH<br>• CALL过程名<br>– CALL NEAR PROC 段内直接寻址（修改IP, CS不变）<br>– CALL BX 段内间接转移（BX → IP）<br>– CALL FAR PROC 段间直接调用<br>• IP、CS都改变，例如：CALL 2000H:5600H<br>• 返回地址入栈包括CS和IP<br>– CALL DWORD PTR [reg16] 段间间接调用<br>• 低字 → IP，高字 → CS<br>– CALL与JMP区别<br>• CALL调用时会将修改前IP（或IP与CS）入栈，且完成后会返回当前位置<br>• RET<br>– 要和CALL调用类型对应：RET（段内）与RETF（段间）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例】求AX累加器和BX累加器中两个无符号数之差的绝  </span><br><span class="line">对值，结果放在2800H单元中  </span><br><span class="line">CMP AX, BX  </span><br><span class="line">JB AA  </span><br><span class="line">SUB AX, BX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], AX  </span><br><span class="line">JMP STOP ;该句缺少怎样？  </span><br><span class="line">AA: SUB BX, AX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], BX  </span><br><span class="line">STOP： HLT</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例】从外设71H中取一个数M,判断其值是否在10和20之  </span><br><span class="line">间，如果M≥20，则送0FFH给外设73H;如果M&lt;10,则送  </span><br><span class="line">00H给外设73H;如果10≤M&lt;20,则送88H给外设73H  </span><br><span class="line">IN AL, 71H  </span><br><span class="line">CMP AL, 10  </span><br><span class="line">JNC LP1  </span><br><span class="line">MOV AL, 00H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP1: CMP AL, 20  </span><br><span class="line">JNC LP2  </span><br><span class="line">MOV AL, 88H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP2: MOV AL, 0FFH  </span><br><span class="line">LP3: OUT 73H, AL  </span><br><span class="line">HLT</span><br></pre></td></tr></table></figure>
<p>循环控制（短地址区间）<br>– LOOP 目标地址<br>• CX-1,如CX≠0,转移到目标地址（负值）<br>– LOOPE&#x2F;LOOPZ 目标地址<br>• CX-1,如ZF&#x3D;1且CX≠0循环（LOOPNE&#x2F;LOOPNZ时ZF&#x3D;0）  </p>
<figure class="highlight plaintext"><figcaption><span>【例】求2个数组之和，每个数组长度为N。如遇到2个组</span></figcaption><table><tr><td class="code"><pre><span class="line">数元素都为0，则停止求和  </span><br><span class="line">MOV SI, -1  </span><br><span class="line">MOV CX, N  </span><br><span class="line">NEXT: INC SI  </span><br><span class="line">MOV AL, [ADDR1 + SI]  </span><br><span class="line">ADD AL, [SI + ADDR2]  </span><br><span class="line">MOV [SI + ADDR3], AL  </span><br><span class="line">LOOPNZ NEXT</span><br></pre></td></tr></table></figure>
<p>中断指令<br>– INT 中断类型<br>• 0-255<br>• 中断向量表<br>– 每种中断占4个字节<br>» 前两个为偏移地址，后两个为段地址<br>– 和CALL的区别<br>• 相同点：断点入栈<br>• 不同点<br>– 清除中断标志IF<br>– 清除单步标志TF<br>– 标志寄存器入栈<br>• 【例】 INT 20H<br>– IRET<br>– INTO 溢出中断（中断号04H）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">延时一秒</span><br><span class="line">START: MOV CX, 1000  </span><br><span class="line">DELAY1S: CALL DELAY1MS  </span><br><span class="line">LOOP DELAY1S  </span><br><span class="line">HLT  </span><br><span class="line">DELAY1MS: PUSH CX  </span><br><span class="line">MOV CX, 374  </span><br><span class="line">LP1: PUSHF  </span><br><span class="line">POPF  </span><br><span class="line">LOOP LP1  </span><br><span class="line">POP CX  </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><code>汇编流程   – 汇编源程序：用助记符指令、变量名和标号编写的程序。   • 文件名：\*\*\*.ASM   – 目标程序：机器能识别的二进制代码程序。   • 文件名：\*\*\*.OBJ   – 执行程序：为PC系统所接受的应用程序。   • 文件名：\*\*\*.EXE   • 工具程序   –</code> 汇编程序：把汇编源程序翻译成机器能识别的机器指令程序的工<br><code>具程序。   • 文件名：MASM.EXE   – 连接程序：把目标文件与库文件以及其他目标文件连接在一起。   • 文件名：LINK.EXE </code>汇编语言语句类型<br>– 指令性语句——真指令<br>• 实际的CPU指令<br>• 汇编程序将其翻译成机器目标代码<br>• 由四部分组成：<br>[标号:] 指令助记符 [操作数] [; 注释]<br>– 指示性语句——伪指令[伪操作指令]<br>• 方便编制程序<br>• 不产生代码<br>[名字] 伪操作命令 [操作数表] [; 注释]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSEG SEGMENT PARA STACK ; 堆栈段定义  </span><br><span class="line">DW 256 DUP (?)  </span><br><span class="line">SSEG ENDS  </span><br><span class="line">DSEG SEGMENT ; 数据段定义  </span><br><span class="line">MESS DB &#x27;HELLO&#x27;, 0DH, 0AH, &#x27;$&#x27;  </span><br><span class="line">DSEG ENDS  </span><br><span class="line">CSEG SEGMENT ; 代码段(指令区)  </span><br><span class="line">ASSUME CS:CSEG, DS:DSEG ; 规定段的性质  </span><br><span class="line">START: MOV AX, DSEG ; 设置数据段基值  </span><br><span class="line">MOV DS, AX  </span><br><span class="line">MOV DX, OFFSET MESS ; 显示字符串信息  </span><br><span class="line">MOV AH, 09  </span><br><span class="line">INT 21H  </span><br><span class="line">MOV AH,4CH ; 结束本程序运行，返回DOS  </span><br><span class="line">INT 21H  </span><br><span class="line">CSEG ENDS  </span><br><span class="line">END START  </span><br><span class="line">汇编语言有若干个段  </span><br><span class="line">段名、开始、结束  </span><br><span class="line">唯一的END结束  </span><br><span class="line">定义起始执行地址</span><br></pre></td></tr></table></figure>
<p>表达式和运算符<br>– 由汇编程序计算<br>• 值<br>• 地址<br>– 算术运算符（7种）<br>• +、-、*、&#x2F;<br>• MOD<br>• SHL、SHR<br>逻辑运算符（4种）<br>• AND、OR、XOR、NOT<br>• 和指令助记符的区别<br>• MOV AL, 0ADH AND 0EAH → MOV AL, 0A8H<br>– 关系运算符（6种）<br>• EQ、NE、LT、GT、LE、GE<br>• 关系成立时返回0FFFFH，不成立时返回0<br>– 数值返回运算符<br>• SEG<br>• OFFSET<br>• TYPE<br>• SIZE<br>• LENGTH<br>属性运算符<br>• PTR 修改操作数类型<br>• THIS</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>数据定义伪指令（变量定义）<br>– 数据定义伪指令用来为数据分配内存空间(规定变量的类型），<br>并设置相应内存单元的初始值。<br>– 形式：<br>变量名 变量定义符 操作数, 操作数, …, 操作数<br>• 其中，变量名是一个符号地址，表示其后操作数的首地址，变量名为可<br>选项，给出变量名只是为了按名存取其对应的内存单元。<br>变量定义符主要包括下列几种<br>– DB（Define Byte）：定义字节，后面的每个操作数占1个字节。<br>– DW（Define Word）：定义字，后面的每个操作数占1个字。<br>– DD（Define Dword）：定义双字，后面的每个操作数占2个字。<br>– 操作数可以是<br>• 常数 例：DATA DB 10, 4, 10H<br>• 表达式 例：DATA DW 2*3, 8&#x2F;4<br>• 字符串 例：DATA DB ‘ABCD’<br>– ？表示只保留内存空间，未定义初始值。<br>• 例：DATA DD ？, 1, ？<br>• 重复次数 DUP （操作数，．．．，操作数）<br>– 例：DATA DB 3 DUP（？，9）</p>
<h2 id="存储器的分类与组成"><a href="#存储器的分类与组成" class="headerlink" title="存储器的分类与组成"></a>存储器的分类与组成</h2><p><code>存储器分类   – 程序的执行是从主存中自动的取指令到控制器进行解释执行，需   要的数据也放在主存中根据指令需要存取。   – 按存储介质分类   • 半导体存储器：双极型，静态MOS型，动态MOS型   • 磁表面存储器：磁盘（Disk）、磁带 （Tape）   • 光存储器：CD、CD-ROM、DVD   – 按断电后信息的可保存性分类   • 非易失性存储器   – 信息可一直保留，不需电源维持（如 ：ROM、磁表面存储器、光存储器等）   • 易失性存储器   – 电源关闭时信息自动丢失。（如：RAM、Cache等） – 按存储器功能分类   • 读写存储器（Read/Write Memory)：可读可写   • 只读存储器（Read Only Memory)：只能读不能写   – 按工作方式/存取方式分类   • 随机存取存储器Random Access Memory (RAM)   – 每个单元读写时间一样，且与各单元所在位置无关，如：内存。   • 顺序存取存储器Sequential Access Memory (SAM)   – 数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置   有关，例如：磁带。   • 直接存取存储器Direct Access Memory (DAM)   – 直接定位到要读写的数据块，在读写某个数据块时按顺序进行。例如：磁盘。   • 相联存储器Associate Memory/Content Addressed Memory (CAM）   – 按内容存储与检索，根据内容访问存储位置并进行读写。例如：快表。 – 按容量/速度   • 寄存器   • 高速缓存   • 主存   • 外存储器 </code>参数<br>– 存取速度：<br>• 存取时间𝑇𝑎：指的是CPU从启动一次存储器操作到完成所需要的时间。<br>• 存取周期𝑇𝑚：是指连续启动两次独立的存储器操作所需最小时间间隔。<br>• 带宽（数据传输速度）</p>
<h3 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h3><p>– 读<br>• CPU先把读单元地址送到AR，经过地址总线送往主存，同时CPU通过控<br>制总线发一个读请求，然后CPU等待从主存储器发来的信号，通知CPU<br>读操作已经完成。<br>• 存储器通过ready线回答，如果ready信号为1，说明存储字的内容已经<br>读出，并放在数据总线上，送往DR。<br>– 写<br>• CPU先将写单元地址经AR送往地址总线，并把写内容字送DR，同时通<br>过控制总线发出写命令，然后CPU等待写操作完成信号。<br>• 主存把收到的信息字写入CPU指定的地址后通过ready线发出完成信号。</p>
<h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><p>分类<br>– ROM<br>• 芯片的内容在制造时已经输入，只能读，不能修改。<br>• 存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。存储<br>元件：二极管或晶体管。<br>– PROM（Programmable ROM, PROM）<br>• 用户可根据自己的需要来确定ROM里的内容，常见的是熔丝式PROM<br>是以熔丝的接通来表示1、断开表示0。常用于工业控制机。<br>– EPROM（Erasable PROM, EPROM）<br>• 紫外线擦除，只能对芯片进行整体擦除，而不能对芯片中个别需要改写<br>的存储单元单独擦除。编程次数不受限制。<br>E2PROM（Electrically EPROM）<br>• 电擦除，可以用字擦除方式擦除，也可以用数据块擦除方式擦除。以字<br>擦除方式操作时，能够只擦除被选中的那个存储单元的内容；在数据块<br>擦除方式操作时，可擦除数据块内所有单元的内容。编程次数受限制。<br>– 闪速存储器（Flash Memory）<br>• 一种快擦写型存储器，它的主要特点是：既可在不加电的情况下长期保<br>存信息，又能进行快速擦除（整体擦除或分区擦除）与重写，兼备了E2<br>PROM和RAM的优点。<br>• 闪存的读取速度与DRAM相近，是磁盘的100倍左右；写数据（快擦－<br>编程）则与硬盘相近。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li>字扩展（位数不变、扩充容量）</li>
<li>位扩展（字数不变，位数扩展）</li>
<li>字位同时扩展（字和位同时扩展）</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>解决内存访问速度慢的措施有三个：<br>• 提高主存芯片本身的速度<br>• 采用多模块存储器技术<br>• 在主存和CPU之间加入Cache</p>
<h3 id="外部存储器（辅助存储器"><a href="#外部存储器（辅助存储器" class="headerlink" title="外部存储器（辅助存储器"></a>外部存储器（辅助存储器</h3><p>磁表面存储器<br>– 两类：数字磁记录和模拟磁记录。<br>– 原理：磁性材料沉积在基体上形成记录介质，通过磁头与记录介<br>质的相对运动来读写信息。<br>– 优点：<br>①容量大，位价低<br>②记录介质可重复使用<br>③信息可长期保存甚至可脱机保存<br>④非破坏性读出<br>– 缺点：<br>①速度慢<br>②对工作环境要求高<br>光存储器<br>– 记录原理：用激光在具有感光特性的介质上非接触地记录高密度<br>信息，以介质材料的光学性质的变化来表示0或1。<br>– 优点：容量大、可替换（便携带）<br>– 缺点：速度慢。</p>
<p>寻址时间<br>– 寻址时间包括两部分：磁头寻找目标磁道所需的寻道时间和找到<br>磁道后磁头等待所需要读写的区段旋转到磁头下方的等待时间。<br>– 平均寻址时间&#x3D;平均寻道时间+平均等待时间<br>– 平均等待时间与磁盘转速有关，用磁盘旋转一周所需时间的一半<br>来表示。<br>数据传输率<br>– 外部：磁表面存储器的缓存在单位时间内与主机之间传送数据的<br>位数或字节数。<br>• 单位bps。<br>• 取决于总线的类型和标准<br>– ATA、SCSI、SATA、SAS<br>– 内部：磁头与硬盘内存之间的数据传输率。<br>• 传输率&#x3D;记录密度D x 运动速度V<br>• 误码率<br>– 衡量磁表面存储器的出错概率，等于出错信息的位数和读出的总<br>信息位数比。<br>磁盘cache<br>– 基本情况：硬盘内存速度差 (ms-ns)<br>• 可采用增加磁盘主轴转速<br>• 提高I&#x2F;O总线速度<br>• 改进读写算法<br>• 采用磁盘cache等方法<br>– 缓存的大小与速度是直接关系到硬盘的传输速度的重要因素。<br>– 主流硬盘的缓存8M以上（有些甚至1G）。<br>– 类型一般是DRAM或SDRAM。<br>– 采用预读策略（局部性规则）：对顺序数据特别有效<br>• 视频数据<br>• 图像文件<br>磁盘阵列存储器（RAID）<br>• 廉价冗余磁盘阵列（RAID）是用多台磁盘储存器组成的大<br>容量外存储子系统。（Redundant Arrays of<br>Inexpensive Disk）由美国加州大学伯克利分校提出。<br>• 目的<br>– 组合小的廉价磁盘来代替大的昂贵的磁盘，降低大批量数据存储<br>的费用；<br>– 希望采用冗余信息的方式，使得磁盘失效时不会使对数据的访问<br>受损失；<br>– 能适当的提升数据传输速度。<br>– 保证数据的可靠性和高可用性<br>RAID的实现<br>– 专门的控制芯片来完成<br>– 用软件的方法来实现，<br>RAID 0级（无冗余和无校验的数据分块）<br>– 将连续的数据块分别存放在不同的磁盘上。具有最高的I&#x2F;O性能<br>和磁盘空间利用率，无数据冗余，无容错能力，不能应用于数据<br>安全性要求高的场合。<br>• RAID 1级（镜像磁盘阵列）<br>– 由磁盘对组成，每一个工作盘都有对应的镜像盘，上面保存着与<br>工作盘完全相同的数据，安全性高，但磁盘空间的利用率只有<br>50%<br>RAID 2级（具有纠错海明码的磁盘阵列）<br>– 采用海明码纠错技术和位交叉技术，用户需增加足够的校验盘来<br>提供单纠错和双验错功能。当阵列内有G个数据盘时，则所需的<br>校验盘数C要满足公式： 2𝐶 ≥ 𝐺 + 𝐶 + 1，如果有4个数据盘，<br>则需要3个校验盘。对数据的访问涉及到磁盘阵列中的每一个盘，<br>对大数据量传送有较高性能，但不利于小数据量的传送。RAID<br>2很少使用。<br>位交叉存取<br>– 将一个数据段中的各位分别存储在不同的磁盘上，以同步方式进<br>行读写，最小访问数据单位是每个磁盘的最小读写单位（例如扇<br>区）X磁盘数。<br>– 适合传送批量数据<br>• 块交叉存取<br>– 以数据块为单位，将连续的数据块分别存放在不同的磁盘上，最<br>小访问数据单位是每个磁盘的最小读写单位（例如扇区）<br>– 适合传送少量数据<br>RAID 5级（无专用校验盘的奇偶校验磁盘阵列）<br>– 无专用的校验盘，将校验信息分布到组内所有盘上，对大、小数<br>据量的读写都有很好的性能，因而是一种较好的方案。<br>• RAID 10级（RAID 0级+RAID 1级）<br>– 由分块和镜像组成，是所有RAID中性能最好的磁盘阵列，但每<br>次写入时要写两个互为镜像的盘， CPU占用率高，磁盘的利用<br>率低<br>磁盘存储器与光盘存储器的比较<br>– 两种存储器的记录原理、组成部分等方面都是相同的。在计算机<br>中它们各有自己的特点与功能。<br>– 硬盘驱动器<br>• 容量大、数据传输率高、等待时间短。<br>– 光盘驱动器<br>• 存储密度高、容量大、价格低。但是光盘与主机的速度不匹配所以不能<br>作为中间存储器，即不能替代硬盘<br><img src="/images/obsidian/20230610145852.png" alt="图片" title="image"><br>为什么这种层次化结构是有效的？<br>– 时间局部性（Temporal Locality）<br>• 含义：刚被访问过的单元很可能不久又被访问<br>• 做法：让最近被访问过的信息保留在靠近CPU的存储器中<br>– 空间局部性 （Spatial Locality）<br>• 含义：刚被访问过的单元的邻近单元很可能不久被访问<br>• 做法：将刚被访问过的单元的邻近单元调到靠近CPU的存储器中<br>– 大量典型程序的运行情况分析结果表明：程序具有访问局部性特<br>征<br>• 指令：指令按序存放，地址连续，循环程序段或子程序段重复执行<br>• 数据：连续存放，数组元素重复、按序访问</p>
<p>• 键盘<br>– 键盘是一组排列成阵列形式的按键开关，按下一个键就产生一个<br>相应的字符，然后转换成ASCII或其他码送往主机<br>– 键盘输入信号处理可分为三个步骤：<br>• (1) 按下一个键；<br>• (2) 查出按下的是哪一个键；<br>• (3) 将该键翻译成能被计算机接收的代码<br>• 键盘的种类<br>– 机械式键盘<br>• 触点的导通或断开<br>• 每个键由底座、轴帽、轴帽固定卡、弹簧、金属支脚、触点金属片<br>导电橡胶式键盘<br>• 通过导电的橡胶实现触点的连接<br>– 电容式键盘<br>• 当人体（手指）接触金属感应片的时候，由于人体相当于一个接大地的<br>电容，因此会在感应片和大地之间形成一个电容<br>薄膜式键盘<br>• 无机械磨损<br>• 低价格<br>• 低噪音<br>• 低成本<br>• 市场占有相当份额<br>• 鼠标<br>– 一种坐标定位部件，只能用来输入相对坐标。<br>• CMOS传感器将每一幅图像都发送给数字信号处理器（DSP）进行分析。<br>• DSP检测各图像中的图案，并分析图像中图案的位置如何变动。<br>• 根据一系列图像中图案位置的变化，DSP确定鼠标的移动距离并将相应<br>坐标发送给计算机。<br>• 计算机根据从鼠标接收到的坐标信息，移动屏幕上的光标。<br>– 与轨迹球鼠标相比，光电鼠标具有下列优势：<br>• 没有可移动的零部件，这意味着磨损更少、故障率更低。<br>• 灰尘无法进入鼠标内部并干扰跟踪传感器。<br>• 增加的跟踪分辨率意味着响应更顺畅。<br>• 不需要鼠标垫等专用表面。<br>触摸屏<br>– 电阻式：利用压力感应进行控制电阻<br>– 电容式：利用人体的电流感应进行工作<br>– 红外式：在显示器上加上光点距架框，在屏幕表面形成一个红外<br>线网<br>– 表面声波触摸屏：玻璃屏的左上角和右下角各固定了竖直和水平<br>方向的超声波发射换能器，右上角则固定了两个相应的超声波接<br>收换能器。玻璃屏的四个周边则刻有45°角由疏到密间隔非常精<br>密的反射条纹<br>条形码（Bar Code）<br>– 由一组宽度和反射率不同的平行相邻条和空按预先规定的编码规<br>则组合起来，用来表示一组数据的符号<br>主要类型<br>• 堆叠式&#x2F;行排式<br>– 建立在一维条码基础之上，按需要堆积成二行或多行<br>– 继承了一维条码的一些特点<br>– 需要对行进行判定，其译码算法与软件也不完全相同于一维条码<br>• 矩阵式二维码<br>– 它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码<br>– 用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制<br>的“0”，点的排列组合确定了矩阵式二维条码所代表的意义<br>显示器显色原理<br>– 像素点：颜色显示的最小单元<br>• 一个像素点包含三原色<br>• 通过调整三原色的显示强弱来控制颜色<br>CRT<br>– 可用于字符、图形和图像显示器。<br>– CRT是一个真空器件，由电子枪、偏转装置和荧光屏组成。<br>– 玻璃屏内壁涂有荧光粉，它将电子束的动能转换成光能，显示出<br>光点。不同的荧光粉在电子束的轰击下发出不同的颜色。<br>– 对电子束的要求<br>• （1）电子束要有足够的强度和速度。<br>• （2）电子束要足够细。<br>• （3）电子束的运动方向要高度可控<br>有机发光二极管（OLED）<br>– 自发光的二极管，无需背光<br>• 等离子显示器（PDP）<br>– 利用惰性气体在一定电压下产生气体放电现象而实现的发光技术。<br>• 显示技术的重要技术指标<br>– 分辨率<br>• 字符显示方式<br>– 一屏可显示的最多字符数称为分辨率，例如80列×25行，表示每屏最多可显示25<br>行，每行可有80个字符。<br>• 在图形显示方式<br>– 一屏可显示的像点数称为分辨率，例如800×600，表示一屏可包含600条水平扫<br>描线，每线可分为800点。<br>• 分辨率越高，显示的信息越多<br>颜色数（位深）：每个像素点可显示的颜色数（灰度级）<br>• 每种原色由8位表示灰度，三原色共计224种颜色<br>• 实际传输过程中采用32位表示一种颜色，而高端显示器每种原色用10位<br>表示，总共可表示230，约10.7亿色<br>按打字原理分：击打式打印机（点阵针式打印机）和非击<br>打式打印机（喷墨打印机、激光打印机）。<br>• 按工作方式分：串行打印机和行式打印机。串行打印机一<br>次只能打一个字，行式打印机一次可以打印一行<br>• 常见打印机类型<br>– 点阵针式打印机<br>– 激光打印机<br>– 喷墨打印机<br>– 热转印和热敏打字机<br>• 发展趋势<br>– 击打式和非击打式并存<br>– 击打式的多样化、特殊化：银行、铁路、超市、酒店</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls原著梗解析</title>
    <url>/2023/09/18/blacksouls%E5%8E%9F%E8%91%97%E6%A2%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1>]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls人物解析</title>
    <url>/2023/09/18/black%20souls%E4%BA%BA%E7%89%A9%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="尸龙贾巴沃克"><a href="#尸龙贾巴沃克" class="headerlink" title="尸龙贾巴沃克"></a>尸龙贾巴沃克</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在天之繁星哟！命数已定之众哟！尽管去为爱所煎熬吧，为嫉妒之苦吧！呜呼！感激涕零吧！为这幸灾乐祸暗黑舞台点缀色彩就好！！！</span><br></pre></td></tr></table></figure>
<p>象征着腐败与神秘的紫黑色，遍布全身的缝合痕迹与绷带，恶魔一样的卷曲角，晦暗如死尸的肤色，以及左眼燃烧着的灵魂之火（致敬黑岩射手可能性微存），<code>尸龙</code>姐姐的人物形象无时无刻不在传达着神秘强大而阴暗的气氛，本视频将对<code>尸龙</code>的整个人物进行解析</p>
<span id="more"></span>
<p><code>尸龙</code>在爱丽丝镜中奇遇的原型是一首小诗，这首诗的大意是勇者手提沃伯尔之剑斩杀邪龙<code>贾巴沃克</code>，游戏中也承袭了这一设定，<code>贾巴沃克</code>一直都以死尸的形象登场<br>要解析这一角色，我们首先从最直接的行为说起，按游戏的时间线，<code>尸龙</code>姐姐大概做了以下这些事<br>1把童话（具体哪本未知，根据混沌迷宫的狼外婆信息推测可能是小红帽）给了渴望母爱的玛丽.苏，从而激发了虫虫的创作能力，导致她创造出一代的箱庭。顺便一提，关于<code>尸龙</code>和<code>玛丽苏</code>的关系，游戏里没有直接证据支持姐妹说，混沌迷宫提到黑山羊有两个子嗣，米兰达认为<code>尸龙</code>有黑山羊的气息，且明显<code>尸龙</code>和<code>玛丽苏</code>有一定关系，这些是确定的，但并未明说姐妹，有人从克苏鲁的设定中寻找论据，但本人对克系了解不多在此不评价。<br>2红偶像约会中电影《三人的茶会》提及茶会时期的三人曾经打倒过贾巴沃奇，不知是否和<code>尸龙</code>有关，此外<code>尸龙</code>也曾被昔日的勇者，如今的猎头兔打倒，自称在之后洗心革面，但相关资料太少，我们不知道是不是她放水或另有隐情<br>3格林被引导进<code>玛丽苏</code>的箱庭开始一代的故事，此时<code>尸龙</code>（不知道<code>玛丽苏</code>是否知情）已经乱入到一代的不思议之国，为格林一行人提供帮助，通关d结局后找她对话，她会直接把二代给剧透了，不过由于时间线上d结局应该直接接上二代，所以“正史”上可能没有这件事，顺便一提，一代的不思议之国是爱丽丝的箱庭，或者说<code>玛丽苏</code>的仿造品，也没有定论，所以很难推测<code>尸龙</code>是入侵还是本来就在那里<br>4来到二代时间线，由于不思议之国是奈亚的箱庭，而黑山羊则是奈亚的“配偶”，所以<code>尸龙</code>出现在这倒是理所应当，此时的<code>尸龙</code>以四噩梦之一的身份登场，，但工作内容则是在卡罗尔川上堆雪人，以及在格林面前装出温柔大姐姐的形象，十足的关系户做派。<br>里路线中，格林和米兰达等人可以先后对战三噩梦，以及杀死其余两个噩梦后现出真身的<code>尸龙</code>，值得一提的是这似乎是她全系列中唯一一次全力出手，并且在此战中死亡，但考虑到支配者的特性，是否死透了依旧存疑<br>以上就是<code>尸龙</code>在系列中的行动，接下来我将对这些行动的目的与<code>尸龙</code>的性格进行归纳。<br><code>尸龙</code>首先是一个安静的观察者，一代中她只是在一棵树下扮尸体，二代则在河边堆雪人，如果格林不找她，在里线之前不会和她有任何交集，然而，隐藏和善表面下的真相是<code>尸龙</code>其实是个性格扭曲唯恐天下不乱的乐子人，是她启发了<code>玛丽苏</code>创造自己的黑童话箱庭，间接引发之后所有的故事，而一开始的目的可能只是以<code>玛丽苏</code>面对求而不得的母爱痛苦挣扎的样子为乐，也是她诅咒了狩猎邪龙的英雄，使兔子一族成为贪食尸体的魔兽，其中被沃波尔斩下头颅可能是她行事风格的分界线，其自述死前曾是无恶不作的邪龙，在复活后变得收敛，但其实依旧不改邪龙本质，只是变得只在关键时刻推波助澜<br>而将这两种性格统一起来的则是她的创作欲，没错，和<code>玛丽苏</code>一样，<code>尸龙</code>对创作也有自己的执念，在<code>玛丽苏</code>涌现起黑暗的创作力之后，<code>尸龙</code>意识到，<code>玛丽苏</code>那邪恶的灵魂一定程度其实是自己的作品，如果说<code>玛丽苏</code>是支配者中第一个创造故事的人，<code>尸龙</code>就是第一个“创作者”，这激发出她内心最深层的欲望，那就是创作出足够黑暗污秽的灵魂，方法则是让一个灵魂在无尽的痛苦与求而不得中循环。<br>可以说在这点上<code>尸龙</code>和奈亚有一定的共同点，就是让格林经历无数次的痛苦循环，但二者还是有着分歧，奈亚想要的是格林求而不得的爱，<code>尸龙</code>则想要格林本就污秽的灵魂更加黑暗。<br>这时我们就可以理解<code>尸龙</code>的行为了，由于里线实际上也处于轮回之中，所以对<code>尸龙</code>来说，告诉格林一些真相只会让他的反抗更加激烈，也会在反抗之后更加绝望，这样才符合她的目的。<br>而以上依旧是<code>贾巴沃克</code>的表层性格，而她隐藏最深的性格则是扭曲的独占欲，在卡罗尔川的地牢中有个四个雪人，分别是<code>玛丽苏</code>，小红帽，爱丽丝和格林，此外，班达斯奈奇的住处也有着一个写着想将其变为收藏品的雪人（sen0才能看到真相），可见<code>尸龙</code>内心最深的欲望其实是独占欲，培育最污秽的灵魂，随后将其收藏起来，这才是<code>尸龙</code>的愿景，但她为何要隐藏这一欲望呢，在qf<code>尸龙</code>失败的逆监禁剧情里，由于<code>尸龙</code>发现格林的灵魂已经黑暗到想要独占自己，<code>尸龙</code>就会唯一一次直接暴露自己的独占欲来收割这个丰硕的成果，然而，奈亚或者其他支配者绝不会容忍这种行为，所以一旦<code>尸龙</code>试图独占格林就会立刻被排除出世界，这就是<code>尸龙</code>一直压抑着独占欲的原因。<br>此外，根据dlc3入口处的对话以及数量庞大的雪人，或许可以猜测<code>尸龙</code>曾经一边观察一边玩弄过很多灵魂，但这些灵魂最后都因为经历过多的痛苦和绝望后变得麻木，因此才会对有着无穷成长性的格林视若珍宝<br>一切温柔的言语都不过是为了将格林引导向更绝望的结局，独占污秽的黑之魂，玩到腻后就扔掉，对<code>贾巴沃克</code>之魂的描述为包藏在虚伪的母性之下的独占欲之影可谓恰如其分。<br>值得一提的是，独占欲这种感情不止在<code>尸龙</code>一人上出现，大部分支配者都有着这种感情，如白之女王诺登就承认自己多次有独占格林的想法，爱丽丝01也曾吐露自己害怕不可控制地想要独占格林，但她们与<code>尸龙</code>的区别则是，她们能够理解人类的爱，并为了人类的幸福选择放手，与红白女王的对比或许也是<code>尸龙</code>人物形象设计的一个目的<br>现在可以做一个总结了，<code>尸龙</code>姐姐是一个对格林有着强烈爱意的角色，她的母性是虚伪的，但这种爱意却不是，尽管她扭曲，残酷，自私，虚伪，但是她始终知道自己要做什么并理性地付出行动，即使失败了也不失风度从容自若，相较于虫虫几乎写在脸上的扭曲性格，直截了当的作恶行径，以及一有挫败就大呼小叫的行径，<code>尸龙</code>的感情更加内敛，行事也更加隐秘，但可谓是个很有恶人魅力的反派角色<br>同时，由于bs的碎片化叙事并且尚未完结，关于<code>尸龙</code>依旧有很多谜团，例如她和<code>玛丽苏</code>以及其他支配者的具体关系，里线中她是不是仍然在演戏，她究竟为何会给<code>玛丽苏</code>童话书，<code>尸龙</code>等三噩梦和三个爱丽丝的关系等等，就期待续作的解答了<br>大家都来和<code>尸龙</code>姐姐做朋友吧，尸门</p>
<h1 id="玛丽苏"><a href="#玛丽苏" class="headerlink" title="玛丽苏"></a>玛丽苏</h1><p><code>玛丽苏</code>，作为bs中自称的女主角，是bs唯二个三代都有出场（包括红森）的支配者，还有一个是<code>贾巴沃克</code>），在此过程中做过的好事可谓数不胜数，罄竹难书，我们来按着时间线整理一下<br>1一开始的<code>玛丽苏</code>是个渴望母爱的孩子，尽管我们不知道bs设定下一开始的支配者到底会不会有类似人类的亲情，她掌管自己的世界，倾听子民的祈祷，开始感到厌烦，这时<code>贾巴沃克</code>不知出于什么目的，送了她一本童话书，这本书，我们不知道是哪个童话，但本人猜测很可能这本书的作者是<code>玛丽苏</code>第一个抓住的，并在黑之魂的融合中有重要地位，根据青鸟的文本，卡罗尔并不是第一个抓住的素材，所以基本可以排除梦游仙境，结合男主角格林的名字和混沌迷宫的狼外婆，我个人猜测是小红帽，她开始渴望创作自己的故事来打动母亲，至少一开始是这样，她派遣属下四处收集童话作者的灵魂作为素材，同时肆意进行同人创作。<br>2<code>玛丽苏</code>的处女作是小红帽，也是她第二得意的作品，根据一些信息，小红帽的灵魂可能以现实世界的一个女学生为素材，在魔改剧情的同时，她还给了小红帽注定20岁早逝的设定，并可能赋予了小红帽通过镜子穿梭位面之类的特殊能力来担任女主角，但不知道为什么她又不满意，想做一个男主角出来，但她对小红帽的善后却颇有些问题，小红帽不仅杀穿了红森，而且还能意识到她这个黑幕的存在。<br>3缝合了众多童话作家灵魂的格林诞生了，并被赋予了给周围的女主角带来不幸的设定，格林污秽的黑之魂有成为支配者的潜质，<code>玛丽苏</code>甚至还大胆地保留了他的部分创作能力，因为最关键的改变权能在她手上，为什么叫做格林则未知，可能是最初的童话书就是格林童话的一本，这之后格林不知道为什么，以什么身份在一个叫不思议之国的地方和叫爱丽丝和祈祷主的存在开起了茶会，随后格林与爱丽丝01相恋，嫉妒的祈祷主呼唤了<code>玛丽苏</code>，导致格林被带走了，连同格林不知何时创造出的故事们也被篡改<br>4基于以上提到的各种童话故事素材，<code>玛丽苏</code>魔改出了失落帝国的箱庭，把格林放进去经历一次次绝望故事的轮回，自己则担任女主角欣赏故事，还设计把母亲叫了进来欣赏自己的大作。不知多少次循环后，这个大好局面被打破了，母亲黑山羊为了逃离这个世界和她战斗，连圣森都磨灭了，战胜母亲后，奈亚丽丝前来捡漏带走格林进行新一轮追寻爱的游戏，本来想顺带着把<code>玛丽苏</code>也灭了，但在诺登的劝阻以及可能的其他考量下放过了她<br>5奈亚，红女王，白女王中的某位或若干位剥夺了她的改变权能，把她囚禁在库因兰德，失去权能的她改名为玛丽安，但不知何时也不知何人前来探访了她，到格林试图从梦中醒来的里线，玛丽安乘乱逃出，由于正史上不太可能发生f结局，所以此时应该是g结局，也有可能正史上g结局有少许与游戏不同，不管怎么说此时的玛丽安应该被格林小红帽两人打败，但h结局中可以看到她没有死，而且不知道怎么逃了出来<br>可以说，bs中的一切悲剧，<code>玛丽苏</code>至少有五成功劳，接下来让我们来分析一下<code>玛丽苏</code>的角色特质。<br>首先，最直接的一点，<code>玛丽苏</code>是个典型的支配者，高高在上地支配着人类这样的低等种族，但<code>玛丽苏</code>特殊之处在于，她可能是最能理解人类感情的支配者之一，首先我们就可以看到她居然渴望所谓的母爱，而根据2代大部分支配者的表现，即使因融入皮套逐渐有了感情，也没有第二个有亲情这种非常类似人类感情的支配者，此外，她还以玩弄人类的灵魂为乐，当然有这种兴趣的支配者恐怕不少，但这股风气可以说是<code>玛丽苏</code>带起来的，也是她最先玩出各种花样。<br>因此可以引出<code>玛丽苏</code>的第二个特点了，她是很像人类的一个支配者，尽管理解非常片面，但她确实懂得并拥有不少人性，而她为什么这么喜欢玩弄人类呢？这也很容易理解，一般来说越通人性的动物越被人类亲近，逗猫逗狗远远比逗蚂蚁有意思，因为这些宠物的智力和人类更接近，人类可以很容易地理解它们在想什么，然后在逗弄它们的过程中获得一种智力上的优越感，以及一种“支配感”，这恐怕就是<code>玛丽苏</code>看到自己编排的好戏上演的感觉。<br>这点可以说是我们对<code>玛丽苏</code>进行解析的基石，毕竟任何角色首先都是人的投影，而人性越丰富，就有越多的性格侧面。<br><code>玛丽苏</code>第三个特点就是由此衍生的纯粹性，当然，此处并不是说纯洁善良云云，而是某种意义上的纯粹之恶，很多支配者在扮演人类后都会被皮套影响而恐慌或纠结，但<code>玛丽苏</code>却没有这种烦恼，她以融入人类扮演人类为乐（小精灵也算类人种族），她作为支配者的漆黑本性和人性之恶完美地兼容了，不会有徘徊二者之间的身份认同问题，而她大部分所作所为也就是为了践行人性之恶，什么是恶呢，比较狭隘的解释就是为了为了自己的利益或者取乐而伤害他人，而<code>玛丽苏</code>的邪恶就很纯粹，就是为了取乐，甚至有损自己利益也要作恶，如果解救了被囚禁的<code>玛丽苏</code>，此时她会自认为东山再起，但她想的不是第一时间抹杀已经成长了的格林或者藏起来，而是想再让格林经历一次悲惨的故事，可以说她作恶的动机相当纯粹，也相当执着。<br>在此之上的第四个特点，就是她的创作者身份，很多支配者都会赞扬她的创作能力，连奈亚构建的不思议之国都有不少<code>玛丽苏</code>箱庭的影子，但这种创造力也只是对于支配者来说了，如果我们用人类的视角看如何呢？寿司在访谈时轻蔑地说到“她说到底也只是<code>玛丽苏</code>，也只能整点二次创作了”可以说道出了<code>玛丽苏</code>所谓创作的本质，说到底，<code>玛丽苏</code>就是那种典型的黑深残小鬼，把一个可能有很多种解释的作品曲解为单一的猎奇世界观，当然不是说这样不行，如果原创一个黑深残世界观自娱自乐当然是可以接受的，但<code>玛丽苏</code>的行为就是最恶劣的一种同人女行为，魔改原来的作品，把自己做成角色代入进去搞cp，还要把所有其他角色踩一遍，情节和人物关系只要对自己代入的角色有利就行，然后把这部除了自己看谁也不会喜欢的同人拿给原作者看，我就不详细说这种行为的恶劣程度了，但这种作品折射出来的创作观我必须要辩驳一下。<br>当然，本视频所有讨论只局限于二次元文化内，<br>荒木飞吕彦认为漫画有四要素，角色、剧情、世界观、主题，我们就用这四个维度来剖析<code>玛丽苏</code>的所谓创作。<br>首先是角色，直接创作一个鲜活的灵魂对强大的支配者来说也是一件难事，所以对于角色的选取，<code>玛丽苏</code>很可能都是使用现实存在的灵魂然后再魔改来适配进童话或者传说的人物，因此她笔下所谓角色虽然很多但其实并不是她自己的功劳，而她为了把这些灵魂塞进角色对设定随意删改，把小红帽的外婆和母亲缝成了一笔烂账，人物关系更是一团乱麻，怎么方便怎么来，角色设定连基本的自洽也做不到，水平着实不敢恭维<br>随后是世界观，失落帝国这个箱庭本质上来说就是个童话故事的缝合体，没有历史演化，没有详细设定，这并不是一个鲜活的世界观，只不过是一个临时搭建的舞台而已，当然，很多线性的故事并不需要一个多详尽的世界观，在这点上<code>玛丽苏</code>只能说无功无过<br>最后是剧情和主题，<code>玛丽苏</code>的主题是简单粗暴的黑深残，剧情则是当常规的rpg剧本演到最后的happy end时毫无铺垫伏笔地急转直下变成bad end，当然，能设置这么大规模的箱庭，还写了不少支线剧情，证明<code>玛丽苏</code>确实是有一些笔力的，但首先，她的角色基本靠抓人，故事则都有童话原型，故事演变她只需要把握大方向，其他可以让角色自己来，而最后没有任何铺垫的bad end依旧表明了她创作的失败，如果一个设定没有任何铺垫和暗示，直到使用时才抛出，那只能证明这部作品情节编排的失败，因为一部作品的生命周期不是作者创作出来就结束了的，而要等到读者看完理解了故事才会结束，这个过程作者读者应该处于相对公平的地位，根据故事的设定，人物有充分的理由这样行动，这样才能让读者认同这个故事，而<code>玛丽苏</code>却完全相反，滥用作者的权能让故事不仅没有逻辑，还自相矛盾，很明显，对<code>玛丽苏</code>来说她是作者也自认为是唯一的读者，那些被抓走被改造的灵魂不过是用完即扔的工具罢了，不需要自圆其说，只要自己看得高兴就行了，或许就支配者的立场来说她不过是自娱自乐罢了，但对人类（至少灵魂上是人类），以及同样作为创作者的格林来说，首先就绝不可能认同这种恶行，更不可能认同自己的作品被改成这样的烂作<br>说到这里，就可以讨论一下<code>玛丽苏</code>对于格林的看法了，直观地说，是<code>玛丽苏</code>创造了名为格林的污秽黑之魂，但其实在最初，是格林等童话作家激发了<code>玛丽苏</code>的创作欲，因此，事实上，两者是相互创造的关系，<code>玛丽苏</code>创造格林的目的，首先是为了成为她作品的男主角，让她能够代入女主角的位置欣赏这个故事，这样说来似乎格林除了男主角的身份和其他角色也没什么本质的不同。但格林还有一点对<code>玛丽苏</code>有着重大意义，就是他童话作家灵魂集合体的身份，即使自我中心如<code>玛丽苏</code>这种存在，也会有对别人欣赏自己作品的渴望，因此<code>玛丽苏</code>特地设置了一个c结局，用演戏的形式让格林得以了解她的整个创作生涯，至于目的，除了单纯的表现欲和欣赏格林的痛苦以外，恐怕也有一丝希望作为原作者的格林认同自己的心情，哪怕是厌恶，<code>玛丽苏</code>也想得到一些对创作的反馈，而格林是唯一能在创作这个领域和她有一些共鸣的人，作者，读者，男主角，格林三位一体的身份对<code>玛丽苏</code>来说，可以说是难得的知己，尽管这种关系非常扭曲，但不能否认，在这点上<code>玛丽苏</code>作为创作者的心情是有些真心的。而<code>玛丽苏</code>会渴望认同这点，一开始是希望得到母爱，但在得到格林这个玩具之后，<code>玛丽苏</code>就一点也不在意黑山羊的死活了，这也是佐证。<br>最后不得不提的是，<code>玛丽苏</code>的特殊性质，很大程度上她是寿司这个作者的投影，我个人觉得<code>玛丽苏</code>这个角色有不少表达寿司自己创作观的成分，这也解释了寿司为何这么偏爱她当然，一部好的作品，任何角色都是基于自己的设定和世界观行动，不可能因为是作者的投影就有特别待遇，所以可以说，<code>玛丽苏</code>虽然很大程度上是寿司的投影，但投影的目的其实是对比，<code>玛丽苏</code>的创作肤浅，笔下的故事只是无聊的黑深残，但寿司却喜欢在绝望时写一些希望，在希望中铺设绝望，最后的反转再怎么说都是有因可循，单论创作的层次来说就高出绿虫子太多了，当然，我也不是在吹寿司笔力多高，因为高出<code>玛丽苏</code>这个水平的创作者多如牛毛。<br>寿司设置<code>玛丽苏</code>这个角色，其实是使用了一种嵌套的结构来讲故事，首层是童话的原作，这些是毋庸置疑的好故事，随后是虫子和奈亚魔改出的箱庭，是烂故事的典型，最后一层寿司想讲的重点其实是格林怎么察觉真相，挣脱出烂故事的循环，书写自己的结局的故事，在这三层中，第一层<code>玛丽苏</code>是读者，格林等人是作者，只出现在设定层面，第二层<code>玛丽苏</code>是一半作者一半角色，格林是一半读者一半角色，体现在abc结局，最后一层中寿司是唯一的作者，<code>玛丽苏</code>和格林就都是角色了，体现在d结局以及之后的二代，这种层层演变虽然有些炫技，但确实非常有意思。<br>就<code>玛丽苏</code>这个角色而言，整个泛二次元文化里她这样的反派也不常见，究其原因，则是因为一个有能力玩弄主角取乐的boss必然会导致战力失衡，冲突不起来，让读者感到憋屈，因此想要打败这种boss要么机械降神唯心爆发，比如一代c结局（虽然是演的），要么引入新的boss和同伴体系取代她如d结局，也因此，虽然我个人很喜欢一代，但一代的真结局d结局远没有2代h结局震撼<br>来做个总结吧，<code>玛丽苏</code>无疑是个纯粹邪恶的支配者，一个烂到骨子里的创作者，她作为创作者无疑是失败的，但作为bs这个故事里的角色反而是很成功的，不仅纯粹有特点，还有很多角色侧面可以挖掘，寿司巧妙地利用她读者，创作者和角色的三重身份来塑造她的多面性，颇有荒木在漫画术中写的“在作恶道路上高歌猛进”的成功反派角色风格。</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls剧情解析</title>
    <url>/2023/09/18/black%20souls%E5%89%A7%E6%83%85%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="冬之钟"><a href="#冬之钟" class="headerlink" title="冬之钟"></a>冬之钟</h1><p>由于black souls的故事远远没有完结，因此现阶段我们很难对<code>红白女王</code>与<code>梅贝尔</code>这些与格林牵扯极深的支配者们进行什么定论，只能就已有的剧情和文本进行一些归纳，本期视频我将就bs2比较难懂的一处地方，冬之钟的主线事件，进行一些个人向的分析。</p>
<span id="more"></span>
<p>在冬之钟最后一章地图能遇到5个白熊，白熊的身份迄今为止依然是谜团，但他们提供了整整五段发生在支配者之间的重要对话，我将概括一下这五段对话提供的主要信息以便进一步的分析<br>我们按解包后的地图顺序开始，<br>第一段对话发生于<code>梅贝尔</code>和妹妹爱丽丝之间，可以猜测妹妹爱丽丝属于支配者之一，数量众多的支配者都在奈亚的箱庭占据一个角色以便和格林繁殖，但随着时间推移，支配者们发现扮演角色的同时，他们也在被角色同化（<code>梅贝尔</code>所言），因此纷纷退场，妹妹爱丽丝也逐渐被角色影响对格林产生好感，此外，姐姐爱丽丝不知何故地退场。<br>第二场对话发生于<code>梅贝尔</code>和白之女王之间，对话中提及冬之钟正是白女王的箱庭，而白之女王由于爱上了格林自愿放弃女王的身份去守护他，而<code>梅贝尔</code>则对这场追寻爱的闹剧，以及陪着胡闹的其他支配者感到无聊，向白女王提出一个让格林摆脱循环，并且能够独占他的计划。<br>第三第四场对话都发生于红白女王之间，<code>红女王</code>为陷入痛苦轮回的格林而痛苦，不断进行自残，白女王制止了她，两人由于同样爱上格林而心意相通<br>第四场对话则告诉我们，<code>红女王</code>接过了白女王的权王冠（推测为箱庭权限），并以此创造出库因兰德，并使其能排除奈亚的监视，两人密谋让格林挣脱循环的方法，<code>红女王</code>恳请白女王放弃对格林的独占欲，白女王同意了，此外，<code>梅贝尔</code>也知晓这一计划，并根据后面的行动来看，她不知为何也参与了这个计划<br>第五场对话发生于白女王和玛丽苏之间，白女王夺走了玛丽苏的改变能力，并且根据混沌迷宫的情报，将其赋予了古兰剧场，玛丽苏察觉白女王爱上了格林，并且等待着格林的到来，结尾，玛丽苏等到了一个神秘人（黑山羊？）<br>总结这些信息，我们可以推测出针对格林，一共提出了两个计划，一个是<code>梅贝尔</code>怂恿的独占计划，一个是红偶像策划的拯救计划，这两个计划都必须有<code>诺登</code>的参与，但此时我们并不知道<code>诺登</code>的真正想法是哪个<br>在推进h结局的过程后，格林会有两个选择，1是和暗黑舞台合二为一2是打败舞台，夺取舞台的改变能力， “此时”的冬之钟虽然沉睡，但相信<code>诺登</code>依旧有一定的控制能力，然而不同于G结局的阻拦，此时的<code>诺登</code>选择了旁观，并在最后支持格林任意一个选择<br>总结一下大致发生的事件（以下事件的时间顺序难以具体确定）<br>1<code>诺登</code>作为支配者之一管理着自己的箱庭冬之钟，和奈亚创造自己箱庭的时间关系未知<br>2奈亚将格林带到箱庭，邀请支配者们参加繁殖游戏，根据牛津学院人偶爱丽丝的说法，是舞台装置创造出了让格林在舞台上登场的皮套（格林的灵魂出自玛丽苏的手笔，因此推测只能创造皮套），并且在创造格林时两者间确立了深远的联系，白女王也参加了这个游戏，可以肯定白女王为了心爱的格林才舍弃了王冠（王冠可能指代管理箱庭的权能），因此推测白女王在爱上格林后可能以放弃王冠为代价，得到了管理奈亚箱庭的权限和陪伴在格林身边的权力<br>3红偶像被奈亚切割，由于茶会时期她曾经打倒初代红之女王，因此此刻可以说她的身份是第二任红之女王，为格林自责的她不断紫餐，得到了白女王的同情，白女王将自己原来的王冠权能移交给被奈亚切割的<code>红女王</code>，让她在原冬之钟的地盘上创造出自己的箱庭。<br>4红白女王合谋，或者其中之一从奈亚手中夺走了玛丽苏并囚禁起来，为了避免红白女王相互猜疑，二者将从玛丽苏手上得到的改变能力赋予舞台装置古兰，创造出一个新的支配者暗黑舞台，藏于处于过去时间线的冬之钟，同时由于处于过去的时间线，冬之钟几乎没有被发现的风险，通过dlc3经常出现的齿轮与其他信息可以推测，舞台装置拥有着影响整个箱庭以及舞台上大部分“演员”的能力，即在部分地图的bg和格林脑中的“齿轮声”，是不思议之国这场戏的核心，此外，由于<code>诺登</code>为了管理这个箱庭必须借助舞台的力量，而红白女王理论上权能接近，因此本视频中猜测红白女王都有部分操控舞台的权限<br>4由于支配者们发现扮演箱庭的角色会改变自己的本质，因此纷纷退出，白女王被迫用自己和格林的子嗣填补空缺<br>5<code>梅贝尔</code>认为这场游戏无聊透顶，一场剧本烂透的戏剧重复多少遍也只会让人厌倦（她自己是这么说的），因此她怂恿白女王让格林脱出循环，并抢先独占他<br>6<code>红女王</code>努力让自己的领域能排除奈亚的监视，并在此向白女王提出了拯救格林的计划，这个计划<code>梅贝尔</code>也知情，白女王同意了拯救计划，我们不知道白女王听到这两个计划的顺序，但他们明显是冲突的<br>7可能是人为，可能是自发，舞台觉醒了自我意识呼唤着格林的爱，同时在<code>梅贝尔</code>的指引下格林也朝着舞台进发，一场死斗在所难免，可以推测，在夺取舞台能力的结局中，<code>诺登</code>执行了<code>红女王</code>的拯救计划，舍身为格林断后，使其在爱丽丝01，即现在的红偶像的帮助下回到现实。在舞台与格林合一的bad end中，<code>诺登</code>执行了<code>梅贝尔</code>提出的独占计划，该结局中<code>诺登</code>辅佐着通过合体得到创作能力的格林与奈亚进行斗争，并且前往世界尽头来逃避一切纷争和毁灭，顺便一提，我觉得这结局也不算坏，白女王很可能会确保格林在融合中占据主导，此时格林成为了名副其实的支配者，和白女王的结合甚至能和奈亚势均力敌，不过寿司在采访中提到执着于爱丽丝身份的奈亚无法发挥全力就是了，毫无疑问这时的格林是目前为止的（格林）战力巅峰。<br>这就是冬之钟里发生的主要事件了，下面我将对事件的主要参与者，红白女王和虚无的少女进行分析。<br>首先是参与程度较低的<code>梅贝尔</code>，<code>梅贝尔</code>虽然入局较浅，但却是格林的引导者，并帮助拖延了一下奈亚，也是她告诉我们打破这一循环只能正面和舞台装置对决，那么她的目的是什么呢？<br>首先，<code>梅贝尔</code>在混沌迷宫中会直接提及支配者间不可避免将爆发战争，并且导致阿撒托斯的苏醒毁灭一切，而身份不是支配者却可能得到支配者之器的格林，才能发动不会惊醒阿撒托斯的箱庭战争，这可能是她帮助格林的首要目的<br>其次，<code>梅贝尔</code>是个不可救药的收藏狂，她的箱庭是个巨大的垃圾场，什么都有，因此她也想把格林培养成一个完美收藏品或者棋子<br>最后，在个人感情上，很难定论<code>梅贝尔</code>到底产生了多少感情，她自称对永无止境的劣质戏剧循环感到厌倦，才会帮助格林创造自己的故事，但又在背叛剧情中声称想要让格林得到更高的器随后利用他，最后如果试图救她又会说自己涌现出了一些对格林的爱，由于信息过少，很难知道她到底觉醒了多少感情。<br>不过可以肯定的是，如果是<code>梅贝尔</code>真有意背叛动机是不充分的，如果她只需要格林成为拥有支配者之器的棋子，那么独占和拯救计划都能实现这个目的，并且由于白女王看着，融合后大概率是格林占主导地位，无非是好不好操控的问题，因此猜测<code>梅贝尔</code>实际上是真心帮助格林，只是在用激将法，或者习惯性毒舌。<br>冬之钟的棋局不管怎么走<code>梅贝尔</code>都不是输家，如果独占计划成功，白女王和格林则会成为一股对抗奈亚甚至其他支配者的强大力量，如果拯救计划成功，格林则会成为一个有着支配者的器，却对大部分支配者恨之入骨的棋子或潜在盟友，不论哪个结果都对<code>梅贝尔</code>阻止阿撒托斯苏醒的目的有利，而她的损失不过是万千分身中的一个而已<br>随后则是红之女王，尽管游戏中没有直接说<code>红女王</code>就是一代的爱丽丝01，以及茶会中的爱丽丝，但大量证据表明她和爱丽丝01有着千丝万缕的关系，爱丽丝01也极有可能就是茶会爱丽丝，所以本视频采纳这一说法，可以说最早钻进人类皮套的她是人性化最深的支配者，她人类的一面深爱格林，但又恐惧支配者的一面暴露，因此自觉配不上格林，甚至认为是自己导致了格林的一切悲剧，顺便一提关于茶会以及更早时期的资料实在太少，所以我们现在对这段剧情的讨论很可能是不完整甚至有较大误解的，因此在此我只能尽可能保守地做一些推测，由于支配者本性难以剥离，在她身上有着强烈的自毁倾向，想爱，却又自觉没有资格去爱，因此她只能用紫餐的方式填补内心的负罪感，H结局中，她以几乎自杀的方式当着奈亚的面帮助格林逃离了奈亚的掌控，可以说为了格林，<code>红女王</code>自降身份把自己变成了棋子，而且是必死的棋子，只为了能在后续将奈亚一军。<br>等待着这个叛徒的是什么结局，我们只能发挥一下想象力了<br>最后则是冬之钟的核心人物，白之女王<code>诺登</code>，<code>诺登</code>的原型之一是爱丽丝梦游仙境的白兔先生，白兔最明显的元素就是他永远匆忙的样子和怀表，这点也在<code>诺登</code>身上得以体现，白女王作为这场繁殖游戏事实上的管理者，为了协调任性的演员们可谓操碎了心，在轮回的最后，台上的演员几乎全部是她的子嗣（兔子可是繁殖力非常强的生物），可以猜测在制定剧本和排练上她也得下不少功夫，而dlc3的核心意象，齿轮，其实可以说既指着暗黑舞台的齿轮带动了戏码的上演，也指着<code>诺登</code>怀表的齿轮，<code>诺登</code>就是那个负责在指针快点到达终点前让齿轮倒转，重新开始计时的人，这也是为何她会在结局中说为齿轮停止感到害怕，让齿轮转动是她的职责，在她的内心深处或许也有着对无尽循环中格林真正爱上自己并一起逃到世界尽头的希望，但最后她选择成全格林真正的爱，而放弃管理齿轮的职责则意味着她与自己支配者的身份完全决裂，将一切奉献给人类的爱。此外，<code>诺登</code>的支配者原型则是所谓的幻梦境之主，这或许解释了为何是她在实际上管理着二代这个巨大的梦境<br>我在尸龙的人物解析说，类似尸龙的独占欲在红白女王身上也出现过，但<code>红女王</code>由于害怕自己的支配者本性选择放手，那么白女王呢？在h结局中，<code>梅贝尔</code>被古兰（推测，也可能是奈亚）针对性的陷阱解决，但拥有舞台权限的红白女王应该不受影响，<code>红女王</code>为了最后拯救格林必须蛰伏，因此辅助格林对抗古兰以及奈亚的任务只能交给白女王，但即使在此时此刻，白女王依旧有着独占格林的选项，如果她控制或者协助舞台装置强迫和格林融合，就可以抢先一步独占所有支配者都垂涎的格林，但如果把舞台的改变能力给予格林，那么失去王冠和舞台的<code>诺登</code>则会失去自己在棋局上的几乎所有棋子，面对这种选择，<code>诺登</code>将选择权给了格林，不能说她是完全无私的，但面对这样的诱惑，她也会尊重格林的选择，这不得不说是非常伟大的爱<br>可以说白女王是一个有着两面性的角色，她支配者的一面始终对格林有着独占欲，但她人性的一面始终压抑着这些黑暗的感情，她是一个徘徊于人与神界限的存在，但无论如何，她都尊重并支持着格林的选择，所以她闪耀着人性光辉的一面始终是压过支配者的黑暗一面的。<br>让我们给这幕疯狂剧场的落幕做一个总结吧，这局棋是红白女王和<code>梅贝尔</code>设下的，目的是为了让格林得到古兰的改变能力并逃离奈亚的箱庭，其中没有舞台权限的<code>梅贝尔</code>负责引导格林，<code>红女王</code>则在最后帮助得到改变能力的格林摆脱奈亚掌控，而白女王则有着最关键的决策权，即是否利用舞台独占格林，但她最后将决定权给了格林，而格林真正的选择应该是夺取舞台的改变能力，因此最后白女王舍弃了一切帮助格林逃离崩坏的舞台。<br>这场棋局中，<code>梅贝尔</code>横竖不亏，<code>红女王</code>陷入必死之局，最关键的棋手就是白女王，只要她愿意，随时可以下出必赢的一着，但最后她依旧选择了放弃自己的棋子，把终结棋局的希望留给了格林<br>在经历如此多的牺牲之后，格林终于从棋子升为了棋手，只是不知道他又会下出怎样的一着</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>基于恐龙书和苏大ppt的操作系统笔记</title>
    <url>/2023/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机系统可以分为四个部分</span><br><span class="line">硬件(Hardware) – 提供基本的计算资源</span><br><span class="line">CPU, memory, I/O devices</span><br><span class="line">操作系统(Operating System)</span><br><span class="line">控制和协调各用户的应用程序对硬件的使用</span><br><span class="line">应用程序(Application programs) – 规定了用户按何种方式使用系统资源</span><br><span class="line">字处理程序, 编译器, 网络浏览器, 数据库系统, 视频游戏</span><br><span class="line">用户(Users)</span><br><span class="line">人, 机器, 其他计算机</span><br><span class="line">操作系统的目标:</span><br><span class="line">运行用户程序  ---核心目标</span><br><span class="line">更方便使用计算机 ---面向用户</span><br><span class="line">更高效使用计算机 ---面向系统</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>计算机启动时，会启动引导程序，来初始化系统的各个组件，加载操作系统并开始执行<br>操作系统加载到内存后，开始为系统和用户提供服务，成为系统进程或者后台程序该阶段完成后系统完全启动并且等待事件发生。<br>事件发生通过”中断“机制来通知，cpu被中断时，停止正在做的事，并立即转到固定位置继续执行中断服务程序，执行完后继续执行被中断的计算</p>
<ul>
<li>中断：指当出现需要时，CPU暂时停止当前程序的执行，转而执行处理新情况的程序和执行过程</li>
<li>中断号：外部设备进行I&#x2F;O操作时产生的中断信号，发送给CPU</li>
<li>中断向量：中断服务程序的入口地址</li>
<li>中断服务程序：执行中断处理的代码</li>
<li>陷阱(trap):是由于出错或用户请求引起的软件生成的中断<br>操作系统是中断驱动</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在冯·诺依曼体系结构( von Neumann architecture)上执行时，一个典型的指令执行周期是，首先从内存中获取指令，并存到指令寄存器( instruction register)。接着，该指令被解码，也可能会从内存中获取操作数据并且存到内部寄存器。在指令完成对操作数据的执行后，结果也可存到内存。注意:内存单元只能看到内存地址的流，而并不知道它们如何产生(通过指令计数器、索引、间接、常量地址或其他方式)或它们是什么样（指令或数据）的地址。相应地，我们可以忽略程序如何产生内存地址，而只关注由程序运行所生成的地址序列。</span><br></pre></td></tr></table></figure>

<h2 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h2><p>由两个或多个独立的系统耦合起来<br>共享数据 storage-area network (SAN)。<br>提供高可用性。<br>一定的冗余<br>非对称集群(Asymmetric Clustering)：一台机器运行应用程序，而其他机器处于热备份模式。<br>对称集群(Symmetric Clustering)：多个主机都运行应用程序<br>提供high-performance computing (HPC)<br>用专门的应用程序利用集群，并行计算parallelization</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多道程序设计：在内存中同时存在多道作业，在管理程序控制下相互穿插运行</span><br><span class="line">通过作业调度(Job Scheduling)选中一个作业并运行</span><br><span class="line">当该作业必须等待时 (如等待I/O), 切换到另一个作业</span><br><span class="line">目的:提高CPU的利用率，充分发挥计算机系统部件的并行性</span><br></pre></td></tr></table></figure>

<p>分时系统：控制响应时间较短，使计算机可交互，一般采用时间片轮转方式使一台计算机为多个用户服务<br>并行：两个或者多个作业在同一时刻运行<br>并发：两个或多个作业在同一时间间隔内依次运行<br>双重模式：允许OS保护自身和其他系统部件<br>用户模式(user mode)和内核模式(kernel mode)，由硬件提供模式位<br>特权指令：可能引起系统崩溃的指令，只能运行在内核模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果操作系统不能获得CPU控制权，就无法管理系统</span><br><span class="line">eg.用户程序死循环，用户程序不调用系统调用</span><br><span class="line">解决方法：定时器</span><br><span class="line">在一段时间后发生中断，CPU控制权返回操作系统</span><br><span class="line">固定时间和可变时间定时器</span><br><span class="line">利用时钟和计数器实现</span><br></pre></td></tr></table></figure>

<p>I&#x2F;O保护<br>防止用户程序执行非法I&#x2F;O<br>解决方法：所有I&#x2F;O指令都是特权指令<br>用户程序通过系统调用进行I&#x2F;O操作<br>内存保护<br>防止内存非法访问<br>解决方法：存储保护机制<br>硬件支持<br>程序运行必须的存储设备<br>CPU只能直接访问寄存器、高速缓存和内存<br>处理前和处理后的所有数据都在内存<br>执行的指令都在内存<br>内存管理：提供内存的分配、回收、地址转换、共享和保护等功能<br>提高内存利用率<br>提高内存访问速度<br>从而提高计算机运行效率</p>
<p>操作系统服务提供对用户很有用的函数:</p>
<ul>
<li><p>用户界面 – 所有的操作系统都有用户界面(UI)<br>形式有命令行界面(CLI)、图形用户界面(GUI)、批界面</p>
</li>
<li><p>程序执行 – 系统必须能将程序转入内存并运行程序。程序必须能结束执行，包括正常或不正常结束（指明错误）</p>
</li>
<li><p>I&#x2F;O 操作 -  运行程序可能需要I&#x2F;O,这些I&#x2F;O可能涉及文件或设备.</p>
</li>
<li><p>文件系统操作 -  文件系统特别重要。很明显，程序需要读写文件和目录，创建和删除文件，搜索文件，列出文件信息，访问管理</p>
</li>
<li><p>通信 – 进程间可能需要交换信息，发生同一台计算机运行的进程间或由网络连接的不同计算机上的进程间(消息传递和共享内存)<br>通信可以通过共享内存或消息交换技术来实现 (消息包由OS移动)</p>
</li>
<li><p>错误检测 – OS 需要知道可能出现的错误<br>错误可能发生在CPU 或内存硬件、I&#x2F;O设备和用户程序中<br>对于每种类型的错误，OS 应该采取适当的动作以确保正确和一致的计算<br>调试工具可以在很大程度上加强用户和程序员有效使用系统的能力</p>
</li>
</ul>
<p><code>层次结构</code>：操作系统划分为若干层，在低层上构建高层，底层（0层）为硬件，最高层（ N层）为用户层，每层只使用低层次的功能和服务<br>优点<br>简化了系统设计和实现，便于调试和升级维护<br>缺点<br>层定义困难，效率差<br><code>微内核</code>：<br>问题：内核越来越大，越来越难管理<br>内核微型化：核内移出尽可能多功能到用户空间<br>好处:<br>便于扩充，便于移植操作系统到新架构系统上，更稳定 (更少的代码运行在核心态)，更安全<br>坏处:<br>用户空间和内核空间通信的系统开销增加<br>解决方法：提出消息传递机制<br><code>模块化</code>：<br>大部分现代操作系统采用模块结构(Linux, Solaris)<br>使用面向对象方法<br>每个核心部件分开<br>每个与其他模块的会话被称为接口<br>每个模块在需要时被加载到内核<br>总体而言，类似于分层方法，但更灵活</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个程序可对应一个或多个进程，同样一个进程可对应一个或多个程序</span><br><span class="line">程序是进程的代码部分</span><br><span class="line">进程是活动(active)实体，程序静止（被动passive）实体</span><br><span class="line">进程在内存，程序在外存</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>Control Block)</span></figcaption><table><tr><td class="code"><pre><span class="line">PCB包含同进程有关的信息，包括：</span><br><span class="line">进程状态</span><br><span class="line">程序计数器</span><br><span class="line">CPU寄存器</span><br><span class="line">CPU调度信息</span><br><span class="line">内存管理信息</span><br><span class="line">计账信息</span><br><span class="line">I/O状态信息</span><br></pre></td></tr></table></figure>

<p><img src="/images/obsidian/20230529221113.png" alt="图片" title="image"><br><code>进程调度队列</code>：<br>作业队列 - 在系统中的所有进程的集合<br>就绪队列 - 在主内存中的，就绪并等待执行的所有进程的集合<br>设备队列 - 等待某一I&#x2F;O设备的进程队列<br>在各种队列之间进程的迁移<br><code>进程终止</code>：</p>
<ul>
<li>进程执行最后一项并退出（exit）<br>从子进程向父进程输出数据（通过wait）<br>操作系统收回进程的资源<br>父进程可中止子进程的执行（ abort）</li>
<li>子进程超量分配资源<br>赋予子进程的任务不再需要<br>若父进程终止，一些系统不允许子进程继续存在<br>所有子进程终止– 级联终止</li>
<li>父进程可以等子进程结束<br>调用wait()系统调用<br><code>进程通信</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息传递在微内核中的应用</span><br><span class="line">远程通信无法采用共享内存</span><br><span class="line">两个操作 :</span><br><span class="line">发送send(message) - 固定或可变大小消息</span><br><span class="line">接收receive(message)</span><br><span class="line">若P与Q要通信，需要:</span><br><span class="line">建立通信连接</span><br><span class="line">通过send/receive交换消息</span><br><span class="line">通信连接的实现</span><br><span class="line">物理的（如，共享存储，硬件总线）</span><br><span class="line">逻辑的（如，逻辑特性）</span><br><span class="line">消息传递可阻塞（blocking）或非阻塞（non-blocking）</span><br><span class="line">阻塞-同步</span><br><span class="line">阻塞send：发送进程阻塞，直到消息被接收</span><br><span class="line">阻塞receive：接受者进程阻塞，直到有消息可用</span><br><span class="line">非阻塞-异步</span><br><span class="line">非阻塞send：发送进程发送消息并继续操作</span><br><span class="line">非阻塞receive: 接收者收到一个有效消息或空消息</span><br><span class="line">如果通过信箱，则可分为直接和间接通信</span><br></pre></td></tr></table></figure>

<p><code>线程</code>（轻型进程lightweight process, LWP ）是CPU使用的一个基本单元，包括</p>
<ul>
<li>线程ID</li>
<li>程序计数器</li>
<li>寄存器集<br><code>栈空间</code><br>一个线程与它的对等线程共享：</li>
<li>代码段</li>
<li>数据段</li>
<li>操作系统资源<br>总体作为一个任务<br>多线程的优点：</li>
<li>响应性</li>
<li>资源共享</li>
<li>经济</li>
<li>可伸缩性：可在多处理核上并行运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调度</span><br><span class="line">线程是调度的基本单位，同一进程中的线程切换不会引起进程切换。</span><br><span class="line">并发</span><br><span class="line">线程可以提高系统的并发性。</span><br><span class="line">资源</span><br><span class="line">进程拥有资源，是资源分配的基本单位，而线程则不拥有资源，但它可以访问创建它的进程所拥有的资源</span><br><span class="line">上下文切换</span><br><span class="line">线程的上下文切换的代价比进程小。</span><br></pre></td></tr></table></figure>

<p>可分为数据并行和任务并行<br><img src="/images/obsidian/20230530184144.png" alt="图片" title="图片"><br><img src="/images/obsidian/20230530184243.png" alt="图片" title="图片"><br><img src="/images/obsidian/20230530185433.png" alt="图片" title="图片"><br>&#x2F;&#x2F;S是应用程序的一部分，N是它在N个处理器上串行运行<br><code>线程的分类</code>：</p>
<ul>
<li>用户线程：由用户线程库进行管理的线程<br>内核看不到用户线程<br>用户线程的创建和调度在用户空间中，不需要内核的干预<br>应用于传统的只支持进程的操作系统</li>
<li>内核线程：内核进行管理的线程<br>需要内核支持<br>由内核完成线程调度<br>由内核进行创建和撤销<br><code>多线程模型的分类</code>：</li>
<li>多对一模型：<br>不支持内核线程的操作系统<br>内核只有进程<br>内核只看到一个进程<br>多个线程不能并行运行在多个处理器上<br>进程中的用户线程由进程自己管理<br>进程内线程切换不会导致进程切换<br>一个线程的系统调用会导致整个进程阻塞</li>
<li>一对一模型<br>用于支持线程的操作系统<br>用户线程一对一映射到内核线程<br>操作系统管理这些线程<br>并发性好：多个线程可并行运行在多个处理器上<br>内核开销大</li>
<li>多对多模型：<br>多个用户线程映射为相等或更小数目的内核线程<br>并发性和效率兼顾<br>增加复杂度<br><code>线程库</code><br>为程序员提供API来创建和管理线程<br>两种模式：</li>
<li>用户库（用户线程）<br>存在于用户空间<br>没有内核支持<br>调用线程库不会产生系统调用</li>
<li>内核库（内核线程）<br>存在于内核<br>操作系统支持<br>调用线程库会产生系统调用<br><code>隐式线程</code>：在编译或者运行的时候由编译器或者运行库决定而不是编程者<br><code>线程池</code>：在池中创建一批线程，等待任务<br>优点：<br>利用线程池中的线程来响应请求比创建一个线程更加快速<br>允许一个应用程序中的线程数量达到线程池的上限<br><code>大中央调度</code>:<br>Apple 技术用于Mac OS X 和 iOS<br>扩展C, C++ languages, API, 和 run-time library<br>允许辨认可并行区段<br>管理线程的大多数细节<br>块格式“^{ }” -   ˆ{ printf(“I am a block”); }<br>块放置在调度队列中<br>在线程池中有可用的线程的时候离开队列<br><code>线程撤销</code>在完成前终止线程<br>要取消的线程称为目标线程 target thread<br>大体两种方法:<br>异步取消Asynchronous cancellation 立刻终止目标线程<br>延迟取消Deferred cancellation 允许目标线程周期性检查它是否应该被终止<br><code>调度程序激活</code></li>
<li>通常用一种中间数据结构在用户和内核线程间 – 轻量级进程 lightweight process (LWP)<br>类似虚拟处理器<br>每个 LWP 和内核进行相连<br>一定数量的LWP</li>
<li>调度器激活提供 upcalls – 一种线程库中内核使用upcall处理句柄 upcall handler 来告知特定事件<br><img src="/images/obsidian/20230530200404.png" alt="图片" title="image"><br>这种通讯允许一个应用程序保持正确数目的内核线程</li>
</ul>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>&#96;需要调度的四种情况</p>
<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程从运行切换到就绪状态（eg.出现中断）</li>
<li>进程从等待状态切换到就绪状态(eg.IO完成)</li>
<li>进程终止时<br>调度只发生在1，4情况下是非抢占调度<br><code>非抢占调度 一旦把CPU分配给某进程后，系统不可以抢占已分配的CPU并分配该其它进程 只有进程自愿释放CPU，才可把CPU分配给其他进程 优点：易实现，调度开销小，适合批处理系统 缺点：响应时间长，不适合交互式系统 </code>抢占调度<br>调度程序可根据某种原则暂停某个正在执行的进程，将已分配给它的CPU重新分配给另一进程<br>可防止单一进程长时间独占CPU<br>系统开销大<br>抢占式与非抢占式的区分<br>运行进程是否是自愿放弃CPU<br><code>长程调度 又称作业调度、高级调度 “新建”状态转换到“就绪”状态 由调度程序选择 控制多道程序的“道/度”（Degree） </code>短程调度<br>又称CPU调度、低级调度<br>调度程序选择下一个执行进程</li>
<li>切换频率<br>短程调度切换频率高<br>长程调度切换频率低</li>
<li>切换开销<br>短程调度开销小(milliseconds，切换快)<br>长程调度开销大(seconds&#x2F;minutes，切换慢)</li>
<li>操作系统中应用<br>短程调度：必需<br>长程调度：可选<br><code>中程调度 又称交换 将进程在内存和外存间换进换出 目的：节省内存空间 </code>就绪队列<code>- 在主内存中处于就绪状态并等待执行的所有进程集合</code>设备队列<code>- 等待某一I/O设备的进程队列 进程的执行过程实际上就是进程在各种队列之间的迁移</code>基本指标</li>
<li>CPU利用率 – 固定时间内CPU运行时间的比例</li>
<li>吞吐量 – 单位时间内运行完的进程数</li>
<li>周转时间 – 进程从提交到运行结束的全部时间</li>
<li>等待时间 – 进程等待调度（不运行）的时间片总和</li>
<li>响应时间 – 从进程提交到首次运行[而不是输出结果]的时间段，也就是第一段的等待时间</li>
</ul>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p><code>等待时间</code>&#x3D;开始处理时间-到达时间<br><code>周转时间</code>&#x3D;等待时间+处理时间</p>
<h2 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务-FCFS"></a>先来先服务-FCFS</h2><p>优点：实现简单<br>缺点：长进程在前会使多个短进程等待过久，增加平均等待时间</p>
<h2 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先-SJF"></a>短作业优先-SJF</h2><p>SJF是最优的 – 对一组指定的进程而言，它给出了最短的平均等待时间</p>
<h3 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><p>有比当前进程所需时间更短进程到达时，更换目前进行进程<br>常用于长进程调度，缺点在于进程的cpu区间难以估计<br>通常用指数平均估计</p>
<h3 id="非抢占式调度"><a href="#非抢占式调度" class="headerlink" title="非抢占式调度"></a>非抢占式调度</h3><p>进程只在结束后让出cpu</p>
<h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>基于进程紧迫程度赋予优先级，cpu分配给最高优先级进程<br>优点<br>实现简单，考虑了进程的紧迫程度<br>灵活，可模拟其它算法</p>
<ul>
<li>静态优先级<br>进程创建时确定，运行期间不变</li>
<li>动态优先级<br>优先级随着进程推进或者等待时间增加而改变</li>
</ul>
<p>&#96;问题</p>
<ul>
<li>饥饿：低优先级进程可能永远无法运行</li>
<li>老化：视进程等待时间延长提高优先级</li>
</ul>
<h3 id="响应比高者优先调度"><a href="#响应比高者优先调度" class="headerlink" title="响应比高者优先调度"></a>响应比高者优先调度</h3><p>响应比&#x3D;（开始时间-到达时间）&#x2F;运行时间</p>
<ul>
<li>如等待时间相同，运行时间越短，优先级越高，类似于SJF</li>
<li>如运行时间相同，优先级取决于其等待时间，类似于FCFS</li>
<li>长进程的优先级可随等待时间的增加而提高，最终可得到服务</li>
<li>缺点：每次调度之前，都需要计算响应比，增加系统开销</li>
</ul>
<h2 id="轮转调度-RR"><a href="#轮转调度-RR" class="headerlink" title="轮转调度-RR"></a>轮转调度-RR</h2><p>将较小的时间单元定义为时间片，就绪队列为循环队列，调度程序循环整个队列，为每个进程分配不超过一个时间片的cpu</p>
<h2 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h2><p>进程分为前台进程（交互进程）和后台进程（批处理进程）<br>不同类型的进程需要不同策略<br>交互进程需要短的响应时间<br>批处理进程需要短的等待时间<br><code>多级队列梯度</code>系统中存在多个就绪队列，每个队列有自己的调度算法</p>
<h3 id="多级反馈序列-MLFQ"><a href="#多级反馈序列-MLFQ" class="headerlink" title="多级反馈序列-MLFQ"></a>多级反馈序列-MLFQ</h3><p><em>(MultiLevel Feedback Queue Scheduling)</em><br>多级队列的延伸<br>不同：</p>
<ul>
<li>多级队列：进程不能在不同队列间移动</li>
<li>多级反馈队列：进程能在不同队列间移动</li>
<li>多级反馈队列调度需要考虑以下问题：<br>队列数<br>每一队列的调度算法<br>决定进程升级（低级队列到高级队列）的方法<br>决定进程降级（高级队列到低级队列）的方法<br>决定新进程将进入哪个队列的方法<br>&#96;最常用的调度算法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">Q0-RR时间片8ms</span><br><span class="line">Q1-RR时间片16ms</span><br><span class="line">Q2-FCFS</span><br></pre></td></tr></table></figure>

<p>缺点：优先级一开始确定，无法调整</p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><p>区别用户层和内核层<br>调度线程而不是进程<br>多对多和多对一模型，线程库在可用的LWP上调度用户层线程<br>process-contention scope (PCS) 在进程中进行调度竞争<br>通常由程序员通过优先级设置<br>内核线程通过system-contention scope (SCS) 在CPU上调度– 系统中统一竞争<br>一对一模型仅使用SCS，如Windows， Linux</p>
<h2 id="局部调度"><a href="#局部调度" class="headerlink" title="局部调度"></a>局部调度</h2><p>[[线程库]]决定哪个线程列入轻量级进程LWP</p>
<h2 id="全局调度"><a href="#全局调度" class="headerlink" title="全局调度"></a>全局调度</h2><p>内核决定下一个运行的内核线程</p>
<h1 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h1><p>调度类似单处理器，但需要将任务平均分配</p>
<h2 id="对称多处理器-SMP"><a href="#对称多处理器-SMP" class="headerlink" title="对称多处理器-SMP"></a>对称多处理器-SMP</h2><h3 id="单队列多核调度方法-SQMP"><a href="#单队列多核调度方法-SQMP" class="headerlink" title="单队列多核调度方法(SQMP)"></a>单队列多核调度方法(SQMP)</h3><p>系统有一个就绪队列。当任意一个CPU空闲时，就从就绪队列中选择一个进程到该CPU上运行<br>优点：<br>容易从单核调度算法推广到多核&#x2F;多处理器、<br>实现简单，负载均衡<br>缺点：<br>不具有亲和性<br>加锁问题</p>
<h3 id="多队列调度方法-MQMP"><a href="#多队列调度方法-MQMP" class="headerlink" title="多队列调度方法(MQMP)"></a>多队列调度方法(MQMP)</h3><p>系统有多个就绪队列，一般每个CPU一个。每个就绪队列有自己的调度算法，并且每个就绪队列的调度相对独立<br>优点：<br>亲和性好<br>不需要加锁<br>缺点：<br>负载不均衡<br>策略：“偷”进程<br><code>每个处理器决定自己调度方式 定期检测每个cpu负载，分配任务给空闲处理器 </code>亲和性：进程倾向于在给定cpu上运行</p>
<ul>
<li>软亲和性：不强制禁止迁移</li>
<li>硬亲和性：禁止迁移</li>
</ul>
<h3 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h3><p>共享队列，分配给不同cpu<br>不具有亲和性</p>
<h3 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h3><p>不同cpu有各自队列<br><code>优点</code>：亲和性较好，不需要加锁<br><code>缺点</code>：负载不均匀</p>
<h2 id="非对称处理器-ASMP"><a href="#非对称处理器-ASMP" class="headerlink" title="非对称处理器-ASMP"></a>非对称处理器-ASMP</h2><p>仅一个处理器处理系统数据结构，减轻共享需求</p>
<h1 id="实时cpu调度"><a href="#实时cpu调度" class="headerlink" title="实时cpu调度"></a>实时cpu调度</h1><ul>
<li>软实时系统：不保证调度关键实时进程</li>
<li>硬实时系统：任务必须在截止期限前完成<br>对实时调度，必须支持抢占式、优先级调度<br>但仅仅支持软实时<br>对硬实时必须提供满足截止时间的能力<br>需要调度进程的新特性：<br>周期性 periodic 定期需要CPU<br>有进程时间 t, 截止时间 d, 周期 p<br>0 ≤ t ≤ d ≤ p<br>周期任务的速率Rate 1&#x2F;p</li>
</ul>
<h2 id="单速速度调度"><a href="#单速速度调度" class="headerlink" title="单速速度调度"></a>单速速度调度</h2><p>依照周期倒数分配一个优先级<br><code>优点</code>：最大化cpu利用率<br><code>缺点</code>：不保证每个进程都赶上截止期限(周期内执行不完)</p>
<h2 id="最早截止期限优先调度-EDF"><a href="#最早截止期限优先调度-EDF" class="headerlink" title="最早截止期限优先调度-EDF"></a>最早截止期限优先调度-EDF</h2><p>根据截止时间分配优先级<br>越早截止期限，优先级越高</p>
<h2 id="比例分享调度"><a href="#比例分享调度" class="headerlink" title="比例分享调度"></a>比例分享调度</h2><p>所有应用中分配T股，确保所有进程有固定的cpu时间，如果新加入进程大于T股剩余量，则不允许进入</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li>实时任务有静态优先级（友好值）</li>
<li>抢占式<br>没有真正的线程</li>
</ul>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul>
<li>抢占调度</li>
<li>优先级</li>
</ul>
<p>对共享数据的并发访问可能导致数据的不一致性，需要保证并发进程正确执行顺序的机制<br><code>竞争条件</code>：多个进程并发访问同一共享数据</p>
<ul>
<li><code>同步</code>：协调执行次序</li>
<li><code>互斥</code>：进程排他性运行，可以独占资源<br><code>临界资源</code>：一次只允许一个进程使用的资源，又称互斥资源、独占资源或共享变量<br><code>共享资源</code>：一次允许多个进程使用的资源</li>
</ul>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><ul>
<li><code>互斥</code>：临界区执行的进程排斥其他进程（有相同临界资源）</li>
<li><code>进步</code>:临界区无进程执行，不能无限期延长下一个需要临界区进程的等待时间</li>
<li><code>优先等待</code>：一个进程进入临界区时，其他进程进入<code>临界区</code>有次数限制</li>
<li>进入区：互斥</li>
<li>退出区：有空让进</li>
<li>每个临界区不能过大：有限等待<br>空闲则入：其他进程均不处于临界区；<br>忙则等待：已有进程处于其临界区；<br>有限等待：等待进入临界区的进程不能”死等”；<br>让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peterson算法</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">  flag [i]:= true;  </span><br><span class="line">  turn = j;  </span><br><span class="line">  while (flag [j] and turn == j) ;</span><br><span class="line"></span><br><span class="line">  critical section</span><br><span class="line"></span><br><span class="line">  flag [i] = false;</span><br><span class="line"></span><br><span class="line">  remainder section</span><br><span class="line"></span><br><span class="line">  &#125; while (1);</span><br></pre></td></tr></table></figure>

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acquire() &#123;  </span><br><span class="line">       while (!available)</span><br><span class="line">          ; /* busy wait */</span><br><span class="line">       available = false;;</span><br><span class="line">    &#125;</span><br><span class="line">   release() &#123;</span><br><span class="line">       available = true;</span><br><span class="line">    &#125;</span><br><span class="line">   do &#123;</span><br><span class="line"></span><br><span class="line">    acquire lock</span><br><span class="line"></span><br><span class="line">       critical section</span><br><span class="line"></span><br><span class="line">    release lock</span><br><span class="line"></span><br><span class="line">      remainder section</span><br><span class="line"></span><br><span class="line"> &#125; while (true);</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁（自旋锁）"><a href="#互斥锁（自旋锁）" class="headerlink" title="互斥锁（自旋锁）"></a>互斥锁（自旋锁）</h3><p>原子执行acquire(),release()<br>acquire：while(!available) waiting;<br>available&#x3D;false<br>release:available&#x3D;false</p>
<h3 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h3><ul>
<li>在进入临界区前，每个进程接收一个号码。具有最小号码的进程进入临界区。</li>
<li>如果进程Pi和Pj接收到同样的号码，如果i &lt; j ，则Pi先得到服务，否则Pj先得到服务。</li>
<li>这种号码方案总是以递增序列产生号码；如： 1,2,3,3,3,3,4,5…</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  choosing[i] = true;</span><br><span class="line">  number[i] = max(number[0], number[1], …, number [n – 1])+1;</span><br><span class="line">  choosing[i] = false;</span><br><span class="line">  for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">  while (choosing[j]) ;</span><br><span class="line">  while ((number[j] != 0) &amp;&amp; (number[j,j] &lt; number[i,i])) ;</span><br><span class="line">  &#125;</span><br><span class="line">  critical section</span><br><span class="line">  number[i] = 0;</span><br><span class="line">  remainder section</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>

<h2 id="信号量（软件解决方案）"><a href="#信号量（软件解决方案）" class="headerlink" title="信号量（软件解决方案）"></a>信号量（软件解决方案）</h2><ul>
<li>保证多个代码段不被并发调用</li>
<li>进入关键代码段前，进程必须获取信号量，否则不能运行</li>
<li>执行完关键代码段，必须释放信号量</li>
<li>信号量有值，说明空闲，为负说明忙碌</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信号量S – 整型变量</span><br><span class="line">提供两个不可分割的[原子操作]访问信号量</span><br><span class="line">wait (S):</span><br><span class="line">     while S&lt;= 0 do no-op;  </span><br><span class="line">     S--;  </span><br><span class="line">signal(S):</span><br><span class="line">     S++;</span><br><span class="line">wait (S)又称为P(S)</span><br><span class="line">signal(S)又称为V(S)</span><br></pre></td></tr></table></figure>

<p>&#96;分类</p>
<ul>
<li>计数信号量：没有限制的整型值计数信号量&#x3D;同步信号量</li>
<li>二值信号量：0 || 1 二值信号量&#x3D;互斥信号量<br>&#96;使用<br>必须取一次且仅有一次初值<br>初值不为负<br>除了初始化，只能通过执行P、V操作来访问S</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：P1  和 P2 需要 C1 比C2先运行</span><br><span class="line">       semaphore s=0</span><br><span class="line">P1:</span><br><span class="line">   C1;</span><br><span class="line">   signal(s);</span><br><span class="line"></span><br><span class="line">P2:</span><br><span class="line">   wait(s);</span><br><span class="line">   C2;</span><br></pre></td></tr></table></figure>

<p>死锁 – 两个或多个进程无限期地等待一个事件的发生，而该事件正是由其中的一个等待进程引起的.<br>P0  P1<br>  P(S);  P(Q);<br>  P(Q);  P(S);<br>  V(S);  V(Q);<br>  V(Q)  V(S);<br>饥饿 – 无限期地阻塞。进程可能永远无法从它等待的信号量队列中移去.</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><p><code>生产者 把产品放入指定缓冲区 in:所有的生产者对in指针需要互斥 counter：所有生产者消费者进程对counter互斥 </code>消费者<br>从指定缓冲区取出产品<br>out:所有的消费者对out指针需要互斥<br>counter：所有生产者消费者进程对counter互斥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer[in] = nextProduced;</span><br><span class="line">in = (in + 1) % BUFFER_SIZE;</span><br><span class="line">counter++;</span><br><span class="line"></span><br><span class="line">nextConsumed = buffer[out];</span><br><span class="line">out = (out + 1) % BUFFER_SIZE;</span><br><span class="line">counter--;</span><br><span class="line"></span><br><span class="line">生产者：</span><br><span class="line"> &#123;</span><br><span class="line">  …</span><br><span class="line">  生产一个产品</span><br><span class="line">  …</span><br><span class="line">  wait(empty);</span><br><span class="line">  wait(m);</span><br><span class="line">   …</span><br><span class="line">  C1：把产品放入指定缓冲区</span><br><span class="line">   …</span><br><span class="line">  signal(m);</span><br><span class="line">  signal(full);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">消费者：</span><br><span class="line"> &#123;</span><br><span class="line">  …</span><br><span class="line">  wait(full)；</span><br><span class="line">  wait(m);</span><br><span class="line">   …</span><br><span class="line">  C2：从指定缓冲区取出产品</span><br><span class="line">   …</span><br><span class="line">  signal(m);</span><br><span class="line">  signal(empty);</span><br><span class="line">   …</span><br><span class="line">  消费取出的产品</span><br><span class="line">   …</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>&#96;同步分析</p>
<ul>
<li>找出需要同步的代码段</li>
<li>分析片段执行顺序</li>
<li>增加同步信号量并赋初始值</li>
<li>关键代码前后加wait和signal操作<br>&#96;生产者</li>
<li>判断是否能获得空缓冲区，否则阻塞</li>
<li>满缓冲区数量++，如果有消费者由于等待阻塞，唤醒该消费者<br>&#96;消费者</li>
<li>判断能否获得满缓冲区，否则阻塞</li>
<li>空缓冲区数量++，如果有生产者等待，唤醒该生产者</li>
</ul>
<h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><p>两组并发进程读者和写者,共享一组数据区进行读写<br>&#96;要求</p>
<ul>
<li>允许多个读者同时读</li>
<li>不允许读者、写者同时读写</li>
<li>不允许多个写者同时写<br>&#96;读者</li>
<li>无读者写者，新读者可读</li>
<li>有写者等，其他读者读，新读者可读</li>
<li>有写者写，新读者等<br>&#96;写者</li>
<li>无读者写者，新写者可写</li>
<li>有读者读，写者等</li>
<li>有其他写者，写者等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个读者计数器rc，设置初始值为0；</span><br><span class="line">读者：Repeat</span><br><span class="line">P(mutex);</span><br><span class="line">readcount:=readcount+1;</span><br><span class="line">if readcount=1</span><br><span class="line">then P (w);</span><br><span class="line">V(mutex);//mutex为互斥信号量，初始值为1</span><br><span class="line">读</span><br><span class="line">P(mutex);</span><br><span class="line">readcount:=readcount-1;</span><br><span class="line">if readcount=0</span><br><span class="line">then V(w);</span><br><span class="line">V(mutex);</span><br><span class="line">Until false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Writers</span><br><span class="line">……</span><br><span class="line">P(W);</span><br><span class="line">写</span><br><span class="line">V(W);</span><br><span class="line">…...</span><br></pre></td></tr></table></figure>

<p>&#96;问题：写者可能饥饿</p>
<ul>
<li>读者写者互斥，写者直到读者count为0才进入进程</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>5个哲学家、5根筷子，每个哲学家左右各有一根筷子，每个哲学家只有拿起左右两个筷子才能吃饭<br>五个元素数组储存筷子，对每个哲学家有拿起左右筷子，放下左右筷子的函数<br>&#96;防止死锁</p>
<h5 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h5><p>最多允许四个哲学家同时坐在桌子周围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semephore *chopstick[5];   //初始值为1</span><br><span class="line">semaphore *seat;  //初始值为4</span><br><span class="line">哲学家 i:</span><br><span class="line">  ……</span><br><span class="line">  P(seat);  //看看4个座位是否有空</span><br><span class="line">  P(chopStick[i]);  //拿左边筷子</span><br><span class="line">  P(chopStick[(i + 1) % 5]);  //拿右边筷子</span><br><span class="line">   吃饭</span><br><span class="line">   V(chopStick[i]);  //放下左边筷子</span><br><span class="line">   V(chopStick[(i + 1) % 5]);  //放下右边筷子</span><br><span class="line">   V(seat);  //释放占据的位置</span><br></pre></td></tr></table></figure>

<ul>
<li>左右筷子都可用时才拿起筷子</li>
<li>非对称解决，单号哲学家优先拿左边筷子，双号优先拿右边</li>
</ul>
<h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>仅当一个哲学家左右两边筷子都可用时，才允许他拿筷子<br>哲学家分为三个状态thinking,hungry,eating<br>设置5个信号量代表所有哲学家，仅当自身hungry且左右都不在吃饭时才开始eating</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(int i);</span><br><span class="line">    &#123;</span><br><span class="line">        if (state[i] == hungry) &amp;&amp;  //是否饿了</span><br><span class="line">          (state[(i+4)%5]!=eating) &amp;&amp; //左边哲学家是否在吃饭</span><br><span class="line">          (state[(i+1)%5]!=eating)  //右边哲学家是否在吃饭</span><br><span class="line">          &#123;</span><br><span class="line">                 state[i]=eating;  //设置哲学家状态为eating</span><br><span class="line">                 V(ph[i]);  //ph[i]设置为1</span><br><span class="line">           &#125;     </span><br><span class="line">     &#125;</span><br><span class="line">     state[i]=hungry；</span><br><span class="line">            P(m);</span><br><span class="line">            test(i);</span><br><span class="line">            V(m);</span><br><span class="line">            P(ph[i]);</span><br></pre></td></tr></table></figure>

<h5 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h5><p>给所有哲学家编号，奇数号哲学家必须首先拿左边筷子，偶数号哲学家则反之</p>
<h3 id="信号量总结"><a href="#信号量总结" class="headerlink" title="信号量总结"></a>信号量总结</h3><p>S&gt;0：有S个资源可用<br>S&#x3D;0：无资源可用<br>S&lt;0：则|S|表示S等待队列中的进程个数<br>P(S)：申请一个资源<br>V(S)：释放一个资源<br>互斥信号量初始值：一般为1<br>同步信号量初始值：0-N<br>&#96;P、V操作成对出现<br>互斥操作：P、V操作处于同一进程内<br>同步操作：P、V操作在不同进程内<br>两个一起的P操作的顺序至关重要<br>同步与互斥P操作一起时，同步P操作要在互斥P操作前<br>两个V操作的次序无关紧要</p>
<p><code>缺点</code>：同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如P、V操作的次序错误、重复或遗漏）<br>易读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序；<br>不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局；<br>正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误；</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据<br>封装数据以及对数据的操作<br>确保每次只要一个进程在管程内活动<br><code>互斥 管程中的变量只能被管程中的操作访问 任何时候只有一个进程在管程中操作 类似临界区 由编译器完成 </code>同步<br>条件变量<br>唤醒和阻塞操作<br>x.wait(): 进程阻塞直到另外一个进程调用x.signal()<br>x.signal()：唤醒另外一个进程</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>管程内可能存在不止1个进程<br>如：进程P调用signal操作唤醒进程Q后<br>存在的可能<br>P等待直到Q离开管程 （Hoare）<br>Q等待直到P离开管程（Lampson &amp; Redll，MESA语言）<br>P的signal操作是P在管程内的最后一个语句 (Hansen，并行Pascal)</p>
<h2 id="内存概念"><a href="#内存概念" class="headerlink" title="内存概念"></a>内存概念</h2><ul>
<li>程序必须装入内存才能被执行</li>
<li>CPU可以直接访问的存储器只有主存和寄存器</li>
<li>寄存器通常可以在一个（或少于一个）CPU时钟周期内完成访问</li>
<li>完成主存访问可能需要多个CPU时钟周期</li>
<li>CPU暂停（Stall）：在读取内存数据时，CPU空闲</li>
<li>Cache 位于主存和CPU寄存器之间，协调速度差异</li>
<li>内存保护需要保证正确的操作</li>
<li>基址寄存器（ Base）：进程最小的合法物理内存地址</li>
<li>界限寄存器（Limit）：进程地址的长度</li>
<li>CPU在执行指令时，需要进行地址合法性验证<br><code>给进程提供一段地址</code>：基地址寄存器（最小地址）和界限地址寄存器（地址范围）<br>物理地址对进程是隐藏的<br><code>地址绑定（程序加载地址）</code>：可以静态绑定也可以动态绑定，动态绑定生成可重定位代码<br><code>动态加载</code>，所有程序以可重定位格式存储在磁盘，只有在调用时才被加载<br><code>动态链接和共享库</code>:每个库程序都有一个存根，指出如何定位内存驻留库程序，或者程序不在内存时如何家在程序，执行存根时检查程序是否在内存，若不是，则加载程序到内存</li>
</ul>
<h3 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h3><p>地址绑定（重定位）：把程序中的相对地址转换为内存中的绝对地址的过程<br>指令和数据绑定到内存地址可在三个不同阶段：<br><code>编译时期（ Compile time） 如果内存位置已知，可生成绝对代码 如果开始位置改变，需要重新编译代码 </code>加载时期（ Load time）<br>如果存储位置在编译时不知，则必须生成可重定位（ relocatable ）代码<br>&#96;执行时期（ Execution time）<br>如果进程执行时可在内存移动，则地址绑定可延迟到运行时<br>需要硬件对地址映射的支持（例如基址和限长寄存器）<br>大部分操作系统用这个方法</p>
<h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><p>逻辑地址空间的概念同物理地址空间相关联，它是正确内存管理的中心<br>逻辑地址Logical address<br>由CPU产生<br>在进程内的相对地址<br>也称：虚拟地址、程序地址<br>物理地址Physical address<br>内存地址<br>所有内存统一编址<br>也称：绝对地址、实地址</p>
<h3 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h3><p>把虚拟地址映射到物理地址的硬件<br>是CPU用来管理内存的控制线路<br>在MMU策略中，基址寄存器中的值在其送入内存的时候被加入到由一个用户进程所产生的每个地址中<br>用户程序所对应到的是逻辑地址，物理地址对它从来都不可见</p>
<h3 id="动态加载和链接"><a href="#动态加载和链接" class="headerlink" title="动态加载和链接"></a>动态加载和链接</h3><p><code>加载 例程在调用之前并不加载 更好的内存空间利用率 没有被使用的例程不被载入 当需大量代码来处理不经常使用的功能时非常有用 </code>链接<br>和各种库文件的链接被推迟到执行时期<br>需要动态装载技术支持<br>一小段代码 - 存根，用来定位合适的保留在内存中的库程序<br>存根用例程地址来替换自己，并开始执行例程<br>操作系统需要检查例程是否在进程的内存空间，所以需要操作系统支持</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行。<br><code>备份区</code>—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">滚入，滚出(Roll out, roll in )—交换由于基于优先级的算法而不同，低优先级的进程被换出，这样高优先级的进程可以被装入和执行。</span><br><span class="line">交换时间的主要部分是转移时间，总的转移时间直接同交换的内存的数量成比例。</span><br><span class="line">在许多系统如：UNIX，Linux，Windows中，可以找到一些被修正过的交换措施。</span><br><span class="line">系统维持一个就绪队列，它包括在备份存储或在内存中准备运行的所有进程</span><br></pre></td></tr></table></figure>

<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><p>为一个用户程序分配一个连续的内存空间</p>
<ul>
<li>单一连续分配：单道程序环境下，仅装有一道用户程序，即整个内存的用户空间由该程序独占</li>
<li>固定分区分配<br>固定分配多个区域，用于放置单个进程<br>预先把可分配的主存空间分割成若干个连续区域，称为一个分区。<br>每个分区的大小可以相同也可以不同。但分区大小固定不变，每个分区装一个且只能装一个程序<br>内存分配：如果有一个空闲分区, 则分配给进程</li>
<li>可变分区分配：<br>用表格记录内存使用情况，根据内存块和孔调度进程<br>当一个进程到来的时候，它将从一个足够容纳它分区中分配内存。<br>操作系统包含以下信息:<br>a) 已分配的分区-已分配分区表   b) 空的分区-空闲分区表</li>
</ul>
<h3 id="选择孔"><a href="#选择孔" class="headerlink" title="选择孔"></a>选择孔</h3><ul>
<li>首次适应（First-fit）: 分配最先找到的合适的分区</li>
<li>最佳适应（Best-fit）: 搜索整个列表，找到适合条件的最小的分区进行分配</li>
<li>最差适应（Worst-fit）: 搜索整个列表，寻找最大的分区进行分配</li>
</ul>
<p><code>碎片</code>：</p>
<ul>
<li>外部碎片：存储被分为大量小孔</li>
<li>内部碎片：分配给进程的孔，进程不需要使用的部分则成为内部碎片<br>外碎片 –整个可用内存空间可以用来满足一个请求，但它不是连续的<br>内碎片 –分配的内存可能比申请的内存大一点，这两者之间的差别是在分区内部，但又不被使用<br>&#96;可通过紧缩来减少外碎片<br>把一些小的空闲内存结合成一个大的块。<br>只有重定位是动态的时候，才有可能进行紧缩，紧缩在执行时期进行</li>
</ul>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>一个程序是一些段的集合，一个段是一个逻辑单位<br>每个段用段名称和段偏移指定位置<br>一个逻辑地址是两个向量的集合:<br>&lt;segment-number, offset&gt;</p>
<p>段表 - 映射二维用户地址，每个表项包括:<br>基址 - 包含内存中段物理地址的起始地址<br>限长 - 指定段的长度<br>段表基址寄存器(STBR)指向段表在内存中的地址<br>段表限长寄存器(STLR)表明被一个程序所使用的段的数目<br>如果 s &lt; STLR，段号s 是合法的</p>
<p>由于段的长度各不相同，内存分配是一个动态存储-分配问题</p>
<p>&#96;内存分配<br>首先&#x2F;最佳适应法<br>外碎片问题</p>
<p>&#96;重定位<br>动态<br>由段表来执行</p>
<p>&#96;共享<br>共享的段<br>同样的段号</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>允许进程的物理地址不连续<br><code>基本方法</code>：将物理内存分为固定大小的块，称为帧或页帧，逻辑内存分为同样大小的块，称为页或页面<br>进程物理地址空间可能不连续<br>如果有可用的物理内存，它将分给进程<br>把物理内存分成大小固定的块，称为帧（Frame）<br>大小为2的幂<br>早期：512字节至8192字节<br>现在：4K-64K<br>把逻辑内存也分为同样大小的块，称为页（Page）<br>系统保留所有空闲帧的记录<br>运行一个有N页大小程序，需要找到N个空帧来装入程序<br>建立一个页表，把逻辑地址转换为物理地址<br>存在内碎片<br><code>内存保护 内存的保护由与每个帧相连的保护位来实现 有效-无效位附在页表的每个表项中: “有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页 “无效”表示页不在进程的逻辑地址空间中 </code>共享代码<br>如果代码是可重入代码（只读），可以在进程间共享 (如文本编辑器, 编译器, 数据库系统)<br>共享代码必须出现在所有进程的逻辑地址空间的相同位置<br>&#96;私有代码和数据<br>每个进程保留一个代码和数据副本<br>存有私有数据和代码的页能够出现在逻辑地址空间的任意位置</p>
<h3 id="页表的层次结构"><a href="#页表的层次结构" class="headerlink" title="页表的层次结构"></a>页表的层次结构</h3><h4 id="二层页表"><a href="#二层页表" class="headerlink" title="二层页表"></a>二层页表</h4><p>内存的保护由与每个帧相连的保护位来实现<br>有效-无效位附在页表的每个表项中:<br>“有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页<br>“无效”表示页不在进程的逻辑地址空间中<br><img src="/images/obsidian/20230605104632.png" alt="图片" title="image"></p>
<h4 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h4><p>虚拟页号被散列到一个页表中。这种页表的每一个条目都包括了一个链表元素，这些元素哈希成同一<br>虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。<br>虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。</p>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>对于每个真正的内存页或帧有一个条目。<br>每个条目保存在真正内存位置的页的虚拟地址，以及包括拥有这个页的进程的信息。<br>&#96;优缺点<br>减少了需要储存每个页表的内存，但是当访问一个页时，增加了寻找页表需要的时间。<br>使用哈希表来将查找限制在一个或少数几个页表条目。<br>实现共享内存困难</p>
<h4 id="段页式原理"><a href="#段页式原理" class="headerlink" title="段页式原理"></a>段页式原理</h4><p>分段和分页原理的结合<br>先将用户程序分成若干个段，再把每个段分成若干个页，并为每个段赋予一个段号<br>逻辑地址：&lt;段号，页号，页内偏移&gt;<br>存在内碎片<br>无外碎片</p>
<h3 id="内存扩充技术"><a href="#内存扩充技术" class="headerlink" title="内存扩充技术"></a>内存扩充技术</h3><ol>
<li>紧缩Compaction（可变分区）</li>
<li>覆盖技术Overlaying</li>
<li>交换技术Swapping</li>
<li>虚拟内存Virtual Memory</li>
</ol>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>解决问题à程序大小超过物理内存总和<br>程序执行时<br>只在内存中保留那些在任何时间都需要的指令和数据<br>程序的不同部分在内存中相互替换<br>由程序员声明覆盖结构，不需要操作系统的特别支持<br>覆盖结构的程序设计很复杂<br>应用于早期的操作系统</p>
<h4 id="交换-1"><a href="#交换-1" class="headerlink" title="交换"></a>交换</h4><p>在多道程序环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况<br>另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况<br>浪费资源，降低系统吞吐量。<br>一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行<br>备份区—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问<br>交换（备份区）：系统指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问</p>
<h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>资源类型 R1, R2, . . ., Rm<br>CPU周期，内存空间，I&#x2F;O设备<br>每一种资源Ri 有Wi  种实例<br>每一个进程通过如下方法来使用资源<br>申请，使用，释放<br>资源动态申请-常用方法<br>在进程运行过程中申请资源<br>资源静态申请<br>在进程运行前一次申请所有资源</p>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>死锁指一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组中其他进程所持有的资源</p>
<ul>
<li>互斥：一次只有一个进程可以使用一个资源</li>
<li>占用并等待：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源</li>
<li>非抢占：一个资源只有当持有它的进程完成任务后，自由的释放</li>
<li>循环等待：等待资源的进程之间存在环 {P0, P1, …, P0}</li>
</ul>
<h2 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h2><p>被分为两个部分<br>P &#x3D; {P1, P2, …, Pn}, 含有系统中全部的进程<br>R &#x3D; {R1, R2, …, Rm}, 含有系统中全部的资源<br>请求边：有向边Pi-&gt;Rj<br>分配边：有向边Ri-&gt;P</p>
<ul>
<li>如果图没有环，那么不会有死锁</li>
<li>如果图有环<br>如果每一种资源类型只有一个实例，那么死锁发生<br>如果一种资源类型有多个实例，可能死锁<br><img src="/images/obsidian/20230604203017.png" alt="图片" title="image"></li>
</ul>
<h2 id="死锁处理的分类"><a href="#死锁处理的分类" class="headerlink" title="死锁处理的分类"></a>死锁处理的分类</h2><ul>
<li>确保系统永远不会进入死锁状态<br>死锁预防<br>死锁避免</li>
<li>允许系统进入死锁状态，然后检测它，并加以恢复<br>死锁检测<br>死锁恢复</li>
<li>忽略这个问题，假装系统中从未出现过死锁。<br>这个方法被大部分的操作系统采用，包括UNIX、Windows<br>由开发人员自行处理死锁</li>
</ul>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>&#96;抑制死锁发生的必要条件</p>
<ul>
<li>互斥：可共享资源不涉及死锁，互斥资源必须强制互斥</li>
<li>持有并等待：保证进程申请资源时不占有其他资源，要求进程在执行前一次性申请全部资源，或者只有不占有资源时才可以分配资源，&#96;可能出现饥饿</li>
<li>抢占：</li>
</ul>
<ol>
<li>如果一个进程的申请没有实现，它要释放所有占有的资源</li>
<li>先占的资源放入进程等待资源列表中</li>
<li>进程在重新得到旧的资源的时候可以重新开始</li>
<li>进程申请资源时，如果资源可用则分配，如果不可用，检查资源是否被分配给等待额外资源的其他进程，如果是，抢占资源，否则，申请进程等待</li>
</ol>
<ul>
<li>循环等待:对所有资源完全排序，进程按顺序申请资源<br>银行家算法</li>
</ul>
<h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><ul>
<li>一个简单而有效的模型要求每一个进程声明它所需要的资源的最大数</li>
<li>死锁避免算法动态检查资源分配状态以确保循环等待条件不可能成立</li>
<li>资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量所决定</li>
</ul>
<h4 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h4><p>当进程申请一个有效的资源的时候，系统必须确定分配后是安全的<br>如果存在一个安全序列，系统处于安全态<br>进程序列&lt;P1, P2, …, Pn&gt;是安全的，如果每一个进程Pi所申请的可以被满足的资源数加上其他进程所持有的该资源数小于系统总数<br>如果 Pi 需要的资源不能马上获得，那么Pi 等待直到所有的Pi-1进程结束。<br>当Pi-1 结束后， Pi获得所需的资源，执行、返回资源、结束。<br>当Pi结束后， Pi+1获得所需的资源执行，依此类推。<br>&#96;定理<br>如果一个系统在安全状态，就没有死锁<br>如果一个系统不是处于安全状态，就有可能死锁<br>避免&#x3D;&gt;确保系统永远不会进入不安全状态</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>多个实例</li>
<li>每一个进程必须事先声明使用的最大量</li>
<li>当一个进程请求资源，它可能要等待</li>
<li>当一个进程得到所有的资源，它必须在有限的时间释放它们</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Available:  长度为 m的向量。 如果available[j]=k,那么资源Rj有k个实例有效</span><br><span class="line">Max: n x m 矩阵。 如果Max[i,j]=k,那么进程Pi最多可以请求k个资源Rj的实例</span><br><span class="line">Allocation:  n x m 矩阵。 如果Allocation[i,j]=k,那么进程Pj当前分配了k个资源Rj的实例</span><br><span class="line">Need:  n x m 矩阵。如果Need[,j]=k,那么进程Pj还需要k个资源Rj的实例</span><br><span class="line">Need [i,j] = Max[i,j] – Allocation [i,j].</span><br><span class="line">1.让Work和Finish作为长度为m和n的向量初始化：</span><br><span class="line">Work := Available</span><br><span class="line">Finish [i] = false for i - 1,2,3, …, n.</span><br><span class="line">2.  查找i</span><br><span class="line">(a) Finish [i] = false</span><br><span class="line">(b) Needi £ Work</span><br><span class="line">If no such i exists, go to step 4.</span><br><span class="line">3.  Work := Work + Allocationi  </span><br><span class="line">Finish[i] := true  </span><br><span class="line">go to step 2.</span><br><span class="line">4.  如果对所有i的 Finish [i] = true, 则系统处在安全状态。</span><br></pre></td></tr></table></figure>

<p>   Requesti &#x3D;进程 Pi 的资源请求向量.  如果Requesti [m] &#x3D; k 则进程 Pi 想要资源类型为Rjm的k个实例<br>1.  如果 Requesti £ Needi 转 step 2.  否则报错, 因为进程请求超出了其声明的最大值<br>2.  如果 Requesti £ Available, 转 step 3.  否则 Pi  必须等待, 因为资源不可用.<br>3.  假设通过修改下列状态来分配请求的资源给进程Pi :<br>  Available :&#x3D; Available - Requesti;<br>  Allocationi :&#x3D; Allocationi + Requesti;<br>  Needi :&#x3D; Needi – Requesti;;<br> <br>•如果系统安全 Þ 将资源分配给 Pi.<br>•如果系统不安全 Þ Pi 必须等待，恢复原有的资源分配状态</p>
<h3 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h3><p><code>每个资源类型有一个实例</code>：维护进程等待图<br><code>每个资源类型有多个实例</code>：用available和finished数组探查是否死锁<br>允许进入死锁状态并加以恢复<br>维护等待图<br>节点是进程<br>Pi-&gt;Pj表明Pi在等待Pj<br>定期调用算法来检查是否有环<br>一个检查图中是否有环的算法需要n^2的操作来进行，n为图中的节点数<br>Available ：一个长度为m的向量，表示每一种资源类型可用的实例数目<br>Allocation:  一个n x m 的矩阵，定义了当前分配的每一种资源类型的实例数目<br>Request: 一个n x m 的矩阵，表明了当前的进程请求。如果Request[i，j]&#x3D;k，那么进程Pi请求k个资源Rj的实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  让Work和Finish作为长度为m和n的向量初始化</span><br><span class="line">(a) Work = Available</span><br><span class="line">(b)  For i = 0,2, …, n-1, if Allocationi ¹ 0, thenFinish[i] = false;otherwise, Finish[i] = true.</span><br><span class="line"></span><br><span class="line">2.  找到满足下列条件的下标i</span><br><span class="line">(a)  Finish[i] = false</span><br><span class="line">(b)  Requesti &lt;= Work</span><br><span class="line">如果没有这样的i存在，转4</span><br><span class="line"></span><br><span class="line">3.  Work = Work + Allocationi  </span><br><span class="line">Finish[i] = true  </span><br><span class="line">转 2.</span><br><span class="line"></span><br><span class="line">4.如果有一些i (0 £ i &lt; n) , Finish[i] = false, 则系统处在死锁状态。而且， 如果 Finish[i] = false, 则进程 Pi 是死锁的。</span><br></pre></td></tr></table></figure>

<p>&#96;算法需要m x n^2 次操作来判断是否系统处于死锁状态</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>可以一次中断所有进程排查，也可以一个一个终结进程<br>选择牺牲进程：最小化代价<br>回滚：返回到安全的状态，然后重新开始进程<br>饥饿：同样进程的可能总是被选中。在代价因素中加入回滚次数</p>
<h2 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h2><p><code>局部性原理</code>：在一较短的时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域<br>一个程序只要部分装入内存就可以运行<br>整个程序不是同一时间都要运行<br>&#96;程序部分装入技术优点<br>进程大小不再受到物理内存大小限制<br>每个进程需要的内存更小<br>更多进程可以并发运行<br>I&#x2F;O更少</p>
<ul>
<li>虚拟存储技术：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存执行。</li>
<li>虚拟地址空间：分配给进程的虚拟内存</li>
<li>虚拟地址：在虚拟内存中指令或数据的位置</li>
<li>虚拟内存：把内存和磁盘有机结合起来使用，得到一个容量很大的“内存”，即虚存<br><code>特点 只有部分运行的程序需要在内存中 逻辑地址空间能够比物理地址空间大 允许多个进程享同一地址空间 允许更有效的进程创建 </code>虚拟内存能够通过以下手段来执行实现:<br>虚拟页式（虚拟存储技术+页式存储管理）<br>虚拟段式（虚拟存储技术+段式存储管理）<br>&#96;虚拟页式有两种方式<br>按需调页（ Demand paging ）<br>预调页（Prepaging）</li>
</ul>
<h2 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h2><p><code>基本思想 进程开始运行之前，不是装入全部页面，而是装入一个或零个页面 运行之后，根据进程运行需要，动态装入其他页面 当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面 </code>请求分页（按需调页）<br>只有在一个页需要的时候才把它换入内存<br>需要很少的I&#x2F;O<br>需要很少的内存<br>快速响应<br>多用户<br><code>懒惰交换</code>:只有在需要页时，才将它调入内存<br>交换程序(swapper)对整个进程进行操作<br>调页程序(pager)只是对进程的单个页进行操作</p>
<h3 id="有效无效位"><a href="#有效无效位" class="headerlink" title="有效无效位"></a>有效无效位</h3><p>每一个页表的表项有一个有效- 无效位相关联：<br>1表示在内存，0表示不在内存<br>在所有的表项中，这个位被初始化为0<br>一个页表映象的例子</p>
<h3 id="缺页中断的处理"><a href="#缺页中断的处理" class="headerlink" title="缺页中断的处理"></a>缺页中断的处理</h3><p>1.访问指令或数据<br>2.查看另一个表来决定:<br>无效引用 Þ 终止<br>仅仅不在内存<br>3.找到页在后备存储上的位置<br>4.得到空的页框，把页换入页框<br>5.重新设置页表，把有效位设为v<br>6.重启指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">极端情况：进程执行第一行代码时，内存内没有任何代码和数据</span><br><span class="line">进程创建时，没有为进程分配内存，仅建立PCB</span><br><span class="line">导致缺页中断</span><br><span class="line">纯请求分页（纯粹按需调页）</span><br><span class="line"></span><br><span class="line">一条指令可能导致多次缺页（涉及多个页面）</span><br><span class="line">幸运的是，程序具有局部性（locality of reference）</span><br><span class="line"></span><br><span class="line">请求调页需要硬件支持</span><br><span class="line">带有效无效位的页表</span><br><span class="line">交换空间</span><br><span class="line">指令重启</span><br><span class="line"></span><br><span class="line">缺页率（缺页的概率）：0 &lt;= p &lt;= 1.0</span><br><span class="line">如果 p = 0 ，没有缺页</span><br><span class="line">如果 p = 1， 每次访问都缺页</span><br><span class="line"></span><br><span class="line">有效访问时间（ EAT ）</span><br><span class="line">    EAT = (1 – p) x 内存访问时间+ p x 页错误时间</span><br><span class="line"></span><br><span class="line">页错误时间=处理缺页中断</span><br><span class="line">  + [页交换出去时间 ]</span><br><span class="line">  + 读入页时间</span><br><span class="line">  + 重启进程开销</span><br></pre></td></tr></table></figure>

<p><code>性能优化</code>：<br>页面转换时采用交换空间，而不是文件系统<br>交换区的块大，比文件系统服务快速</p>
<p>在进程装载时，把整个进程拷贝到交换区<br>基于交换区调页<br>早期的 BSD Unix</p>
<p>利用文件系统进行交换<br>Solaris和当前的BSD<br>部分内容仍旧需要交换区（堆栈等）<br><code>写时复制</code>:允许父进程和子进程在初始化时共享页面<br>如果其中一个进程修改了一个共享页面，会产生副本<br>更加高效<br>应用在Windows，Linux，macOS等系统</p>
<h3 id="需要页置换的情况"><a href="#需要页置换的情况" class="headerlink" title="需要页置换的情况"></a>需要页置换的情况</h3><p>页置换—找到内存中当前没有使用的一些页，换出<br>同一个页可能会被装入内存多次<br>基本页置换方法</p>
<ol>
<li>查找所需页在磁盘上的位置</li>
<li>查找一空闲帧<br>如果有空闲帧，就使用它<br>如果没有空闲帧，使用页置换算法选择一个“牺牲”页框<br>将“牺牲”帧的内容写到磁盘上，更新页表和帧表</li>
<li>将所需页读入（新）空闲帧，更新页表和帧表</li>
<li>重启用户进程</li>
</ol>
<p>如果发生页置换，则缺页处理时间加倍<br>使用修改位modify bit或脏 (dirty bit) 来防止页面转移过多—只有被修改的页面才写入磁盘<br>页置换完善了逻辑内存和物理内存的划分—在一个较小的物理内存基础之上可以提供一个大的虚拟内存</p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="先进先出-FIFO-算法"><a href="#先进先出-FIFO-算法" class="headerlink" title="先进先出(FIFO)算法"></a>先进先出(FIFO)算法</h3><p>置换在内存中驻留时间最长的页面<br>容易理解和实现、但性能不总是很好<br>实现：使用FIFO队列管理内存中的所有页<br>FIFO算法可能会产生Belady异常<br>更多的页框 &#x3D;&gt;更多的缺页</p>
<h3 id="最优置换算法OPT"><a href="#最优置换算法OPT" class="headerlink" title="最优置换算法OPT"></a>最优置换算法OPT</h3><p>被置换的页是将来不再需要的或最远的将来才会被使用的页<br>实现？<br>作用：作为一种标准来衡量其它算法的性能</p>
<h3 id="最近最少使用算法-LRU"><a href="#最近最少使用算法-LRU" class="headerlink" title="最近最少使用算法(LRU)"></a>最近最少使用算法(LRU)</h3><p>置换最长时间没有使用的页<br>性能接近OPT<br>实现：计数器（时间戳）或栈<br>开销大、需要硬件支持<br>栈实现—在一个双链表中保留一个记录页数目的栈:<br>被访问的页:<br>移到栈顶<br>需要改变6个指针<br>没有为置换进行查找</p>
<p>在没有硬件支持的系统中，可使用LRU近似算法访问位<br>每个页都与一个位相关联，初始值为0<br>当页访问时设位1</p>
<ul>
<li>附加引用位算法</li>
<li>二次机会算法</li>
<li>增强型二次机会算法</li>
</ul>
<h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>需要访问位<br>如果访问位为0，直接置换<br>如果将要交换的页访问位是1，则:<br>把访问位设位0<br>把页留在内存中<br>以同样的规则，替换下一个页</p>
<p>实现：时钟置换（顺时针方式）</p>
<h3 id="基于计数的页面置换"><a href="#基于计数的页面置换" class="headerlink" title="基于计数的页面置换"></a>基于计数的页面置换</h3><p>用一个计数器记录对每一个页的访问次数<br>LFU 以最小的计数置换一个页</p>
<h3 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h3><ol>
<li>总是保留一个空闲帧缓冲池</li>
</ol>
<ul>
<li>在缺页错误时有帧可用</li>
<li>读页面到空闲帧，无需等待写出牺牲帧</li>
<li>牺牲帧以后被写出后，添加到缓冲池</li>
</ul>
<ol start="2">
<li>扩展之一，维护一个修改页面的列表</li>
</ol>
<ul>
<li>当设备空闲时选择一个修改页面写到磁盘上，然后重置它的修改位</li>
</ul>
<ol start="3">
<li></li>
<li>另一种修改,保留一个空闲帧池，并且记着哪些页面在哪些帧内</li>
</ol>
<ul>
<li>如果在重用之前被再次需要，就不需要从磁盘上重新装载了</li>
<li>降低因错误选择牺牲页面而引起的开销</li>
</ul>
<h2 id="帧分配"><a href="#帧分配" class="headerlink" title="帧分配"></a>帧分配</h2><p>两种主要分配策略</p>
<ul>
<li>固定分配</li>
<li>优先分配</li>
</ul>
<h3 id="固定分配"><a href="#固定分配" class="headerlink" title="固定分配"></a>固定分配</h3><p>平均分配 Equal allocation– 例如，如果有100帧和5个进程，给每个进程20帧<br>在缓冲池里保存空闲帧<br>比例分配 Proportional allocation – 根据进程大小分配内存<br>按照多道程度而动态分配，进程分得的数量变化</p>
<h3 id="优先级分配"><a href="#优先级分配" class="headerlink" title="优先级分配"></a>优先级分配</h3><p>优先级分配:用优先级而不是大小来进行比例分配<br>如果进程 Pi 跑出页面错误,<br>从自己的帧里选择一个替代<br>从优先级较低的进程里选择一个替代</p>
<h3 id="全局-vs-局部分配"><a href="#全局-vs-局部分配" class="headerlink" title="全局 vs. 局部分配"></a>全局 vs. 局部分配</h3><p>全局置换 Global replacement – 允许进程从所有帧的集合中选择一个置换帧；一个进程可以从另一个进程那里获取帧<br>但是进程执行时间可能变化很大，不能控制缺页错误率<br>有更好的系统吞吐量，更常用<br>局部置换 Local replacement – 每个进程只从它自己分配的帧中进行选择<br>对每个进程的表现更一致<br>但是可能内存低利用</p>
<h4 id="非均匀内存访问（NUMA）"><a href="#非均匀内存访问（NUMA）" class="headerlink" title="非均匀内存访问（NUMA）"></a>非均匀内存访问（NUMA）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v以上假设所有内存可以被平等访问</span><br><span class="line"></span><br><span class="line">v很多系统如 NUMA – 内存访问速度变化的</span><br><span class="line"></span><br><span class="line">考虑CPU和内存在系统中通过总线互连</span><br><span class="line"></span><br><span class="line">v让分配的内存帧‘尽可能地靠近’运行进程的CPU</span><br><span class="line"></span><br><span class="line">通常意味着位于同一系统扳</span><br><span class="line"></span><br><span class="line">Solaris通过在内核中创建延迟组 lgroups</span><br><span class="line"></span><br><span class="line">v将相近的CPU和内存聚集在一起</span><br><span class="line"></span><br><span class="line">v在组内调度进程的所有线程，并分配它的所有内存</span><br><span class="line"></span><br><span class="line">v最大限度减少总体内存延迟，最大化CPU缓存命中率</span><br></pre></td></tr></table></figure>

<h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><p>如果一个进程没有足够的页，那么缺页率将很高，这将导致:<br>CPU利用率低下.<br>操作系统认为需要增加多道程序的道数<br>系统中将加入一个新的进程<br>颠簸（抖动）&#x3D;一个进程的页面经常换入换出<br>原因：分配的帧数 &lt; 局部大小之和</p>
<h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>工作集窗口 º 固定数目的页的引用<br>WSSi (进程Pi的工作集) &#x3D; 最近D中所有页的引用 (随时间变化)<br><img src="/images/obsidian/20230605190700.png" alt="图片" title="image"><br>vExample: D &#x3D; 10,000</p>
<p>每5000个时钟单位时钟中断</p>
<p>为每个页在内存中保留两个位</p>
<p>任何时候一个时钟中断拷贝，把所有访问位设为0</p>
<p>如果一个在内存中的位是0，说明页在工作集</p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>通过映射一个磁盘块成内存的一页，内存映象文件I&#x2F;O 允许文件I&#x2F;O 作为普通内存访问。<br>开始的文件访问按普通请求分页来进行，一页大小的部分文件从文件系统读入物理页。以后文件的读、写操作就按通常的内存访问来处理。<br>由于通过内存的文件操作而不是使用系统调用read() write() ，简化了文件访问和使用。<br>多个进程可以允许将同一文件映射到各自的虚拟内存中，以允许数据共享</p>
<h2 id="内核内存分配"><a href="#内核内存分配" class="headerlink" title="内核内存分配"></a>内核内存分配</h2><p>通常从空闲内存池中获取<br>内核需要为不同大小的数据结构分配内存<br>一些内核内存需要连续的物理页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v内核在使用内存块时有如下特点：</span><br><span class="line"></span><br><span class="line">    (1)内存块的尺寸比较小；</span><br><span class="line"></span><br><span class="line">    (2)占用内存块的时间比较短；</span><br><span class="line"></span><br><span class="line">    (3)要求快速完成分配和回收；</span><br><span class="line"></span><br><span class="line">    (4)不参与交换。</span><br><span class="line"></span><br><span class="line">    (5)频繁使用尺寸相同的内存块，存放同一结构的数据；</span><br><span class="line"></span><br><span class="line">    (6)要求动态分配和回收。</span><br></pre></td></tr></table></figure>
<h3 id="伙伴-Buddy-系统"><a href="#伙伴-Buddy-系统" class="headerlink" title="伙伴(Buddy)系统"></a>伙伴(Buddy)系统</h3><p>v主要用于Linux早期版本中内核底层内存管理<br>v一种经典的内存分配方案<br>v从物理上连续的大小固定的段上分配内存<br>v主要思想：内存按2的幂的大小进行划分，即4KB、8KB等，组成若干空闲块链表；查找链表找到满足进程需求的最佳匹配块<br>满足要求是以2的幂为单位的<br>如果请求不为2的幂，则需要调整到下一个更大的2的幂<br>当分配需求小于现在可用内存时，当前段就分为两个更小的2的幂段，继续上述操作直到合适的段大小<br>&#96;算法<br>首先将整个可用空间看作一块: 2^n<br>假设进程申请的空间大小为s，如果满足<br>2^(n-1)&lt;s&lt;&#x3D;2^n，则分配整个块<br>   否则，将块划分为两个大小相等的伙伴，大小为2^(n-1)<br>一直划分下去直到产生大于或等于s的最小块</p>
<h3 id="Slab-分配"><a href="#Slab-分配" class="headerlink" title="Slab 分配"></a>Slab 分配</h3><p>v内核分配的另一方案<br>vSlab 是由一个或多个物理上连续的页组成<br>vCache 含有一个或多个 slab<br>v每个内核数据结构都有一个cache<br>每个 cache 含有内核数据结构的对象实例</p>
<p>v当创建 cache 时, 包括若干个标记为空闲的对象<br>v当内核对象时，从cache上直接获取，并标识对象为使用<br>v当一个slab充满了已使用的对象时，下一个对象的分配从空的slab开始分配<br>如果没有空的slab, 则从物理连续页上分配新的slab<br>v优点<br>①没有因碎片而引起的内存浪费</p>
<p>②内存请求可以快速满足</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p><code>预调页面 v在进程启动初期，减少大量的缺页中断 v在引用前，调入进程的所有或一些需要的页面 v如果预调入的页面没有被使用，则内存被浪费 </code>页面尺寸大小<br>v碎片 – 需要小的页<br>v表大小 – 需要大的页<br>vI&#x2F;O 开销 – 需要大的页<br>v程序局部 – 需要小的页<br>v缺页次数 – 需要大的页<br>v其他因素<br>没有最佳答案，总的来说，趋向更大的页<br><code>TLB 范围 vTLB 范围 – 通过TLB所访问的内存量 vTLB 范围 = (TLB 大小) X (页大小) v理想情况下，一个进程的工作集应存放在 TLB中 否则会有大量的缺页中断 v增加页的大小 对于不需要大页的应用程序而言，这将导致碎片的增加 v提供多种页的大小 这允许需要大页的应用程序有机会使用大页而不增加碎片的大小 </code>倒置页表<br>v倒置页表降低了保存的物理内存<br>v不再包括进程逻辑地址空间的完整信息<br>v为了提供这种信息，进程必须保留一个外部页表<br>v外部页表可根据需要换进或换出内存<br>&#96;I&#x2F;O 联锁与页面锁定<br>v允许某些页在内存中被锁住</p>
<p>vI&#x2F;O时，正在进行I&#x2F;O的页面不允许被置换算法置换出内存<br><code>linux vSLAB vDemand paging vGlobal page replacement(LRU) v两个帧列：active_list和inactive_list vKswapd daemon 定期检查 </code>windows10<br>vBoth IA-32 and x86-64<br>v32bit支持4GB，64bit支持128TB内存<br>vShared memory, demand paging, copy-on-write, paging和memory compression<br>v按需调页-clustering，预调入3-7页<br>vWorking-Set 管理（最少50-最多345页）</p>
<h2 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h2><p><code>文件 计算机中信息存储的基本组织形式 相关信息结合 具有文件名 </code>文件名<br>按名存取：文件名     存储位置<br>文件名由一串ASCII码或(和)汉字构成<br>名字长度<br>v8.3规则：文件名8个字符，类型3个字符，之间有“.”分割<br>v长文件名：可以最多输入255多个字符作为文件名<br>文件名可能大小写敏感<br><code>文件的打开 v需要数据结构 打开文件表：跟踪打开文件 文件指针:指向最后一次读写的位置，每个进程1个 打开文件计数器：打开文件次数（调用open次数） 文件存储位置：文件存放在存储设备上的位置信息 访问权限：每个进程的访问权限 v优点 方便文件共享 提高文件存取效率 </code>文件锁<br>共享锁 Shared lock 类似于读者锁– 多个进程可以并发获取它。<br>独占锁 Exclusive lock 类似于写者锁<br>&#96;文件结构<br>v目的：便于程序理解文件内容<br>无结构：文字流、字节流等<br>简单记录结构：线性、固定长度、可变长度等<br>复杂结构：格式化文档、多媒体文件等<br>v谁决定了文件结构<br>操作系统<br>程序</p>
<h2 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h2><h3 id="逻辑文件"><a href="#逻辑文件" class="headerlink" title="逻辑文件"></a>逻辑文件</h3><p>v文件呈现在用户面前的组织结构<br>v又称为文件逻辑结构<br>v逻辑文件决定了文件访问方法<br>&#96;文件访问方式</p>
<ul>
<li>顺序访问<br>最简单的访问方式<br>文件信息按照存放顺序，一个记录一个记录地依次访问<br>顺序文件<br>典型存储设备：磁带</li>
<li>直接（随机）访问<br>可以直接定位到文件的某条记录进行访问<br>直接文件<br>典型设备：磁盘<br>v访问方式：直接（随机）访问<br>v直接通过计算得到需要读写记录的位置，直接跳转进行文件读写</li>
<li>索引文件<br>v基本方法：为顺序文件建立索引表<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">记录平均长度：40B   索引表项大小：4B   1M条记录长度：44MB</span><br><span class="line"></span><br><span class="line">访问第1万条记录：</span><br><span class="line"></span><br><span class="line">       1）计算得到第1万条记录的索引项在索引表中首址：10000*4=40000</span><br><span class="line"></span><br><span class="line">       2）从索引表地址40000处读入4个字节，内容为第1万条记录在顺序文件中的首址P</span><br><span class="line"></span><br><span class="line">       3）从顺序文件地址P处读入40个字节（假如第1万条记录长度为40B）</span><br><span class="line"></span><br><span class="line">合计读入：4+40=44B</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="文件控制块（FCB）"><a href="#文件控制块（FCB）" class="headerlink" title="文件控制块（FCB）"></a>文件控制块（FCB）</h3><p>存放操控文件所需的各类文件属性信息<br>文件名<br>长度<br>创建时间<br>存放位置<br>访问控制权限<br>类似一个索引项<br>v目录项<br>存放一个文件的各类属性<br>有的系统等同于文件控制块<br>v目录<br>包含着所有文件信息的节点集合<br>根据文件名检索文件的桥梁<br>目录项的有序集合<br>v目录文件<br>目录组织形式<br>目录作为一个文件存在于文件系统<br>v每个目录项中存放了文件在存储设备的存放地址<br>v目录和文件都驻留在存储设备（如磁盘）</p>
<h3 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h3><p>v文件检索是一个遍历目录项的过程<br>1.打开目录文件<br>2.从磁盘读入该目录文件的1个(物理)块，该块包含若干个目录项<br>3.根据文件名遍历内存中的该块，如找到则结束<br>4.判断该目录文件是否还有物理块没有读入，如果是转2；否则，结束。表示该目录中没有此文件名的文件<br>v目录项由于经常变化，一般不排序<br>v平均遍历目录项数：       （1+n）&#x2F;2<br>  不包括文件查不到的情况<br>  <br>  目录项大小&#x3D; ds bytes<br>目录中最多文件数 &#x3D; n<br>物理块大小 &#x3D; b<br>v那么<br>目录文件大小 &#x3D; ds*n bytes<br>目录文件需要的物理块数目 &#x3D; ds*n&#x2F;b<br>检索一个文件需要平均读入的块数&#x3D;(ds*n&#x2F;b+1)&#x2F;2</p>
<h3 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h3><p><code>设计目标 v效率 快速定位文件位置 提高文件访问效率 v命名 方便用户使用 同名的不同文件 不同名的相同文件 v分组 文件分组（子目录） 兼顾效率和方便性 </code>单层目录<br>v所有文件在同一目录中，只有一级目录：根目录<br>v根目录（&#x2F;）：一个文件系统最顶层的目录<br>v优点：结构简单<br>v缺点<br>检索效率差（目录下文件过多）<br>不能有同名文件，一个文件只能有一个名称<br>不能分组<br><code>双层目录 v每个用户有自己的目录结构 v目录下的目录 v缺点：1）无法分组；2）同一用户不能有相同文件名的文件 v优点：1）不同用户可有相同文件名的文件；2）比单层目录提高检索效率（文件分布在多个用户目录中） </code>树形目录<br>v特点<br>检索高效（子目录增多导致每个目录下文件减少）<br>可以分组<br>允许重名<br>v当前目录：工作目录<br>cd &#x2F;spell&#x2F;mail&#x2F;prog<br>type list<br>v绝对路径<br>从根开始的路径名<br>v相对路径<br>从当前目录开始的路径名<br>提高检索效率<br><code>（有向）无环图目录 v文件共享：不同目录中的文件指向同一个物理文件，也就是它们内容相同 v树型目录不能实现文件共享 v解决方法：图型目录 无环图目录 通用图目录（有环图） v无环图：有向边无环 </code>如何保证无环？<br>仅允许指向文件的链接，不允许指向子目录的链接<br>垃圾回收<br>每当加入新链接时，使用环路检测算法判断是否正确<br>优化遍历目录算法，避免对环的重复搜索</p>
<h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><p>v要访问一个文件系统，必须先安装它。<br>一个未安装的文件系统将被安装在一个安装点(mount point)上。</p>
<h3 id="远程文件系统"><a href="#远程文件系统" class="headerlink" title="远程文件系统"></a>远程文件系统</h3><p>v用网络使得远程计算机之间的联系成为可能<br>手动传输文件如 FTP<br>自动，直接访问文件用分布文件系统 distributed file systems<br>半自动用万维网 world wide web<br>vClient-server 客户机-服务器模型允许客户机登录远程服务器的文件系统<br>服务器可以服务多台客户机<br>识别客户可能是不安全和复杂的<br>NFS 是标准 UNIX 下客户机-服务器的文件共享协议<br>CIFS 是Windows下标准协议<br>标准操作系统文件调用翻译为远程调用<br>v分布式信息系统 (分布式命名服务 distributed naming services) 如LDAP, DNS, NIS。</p>
<h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>v所有文件系统都有故障模式<br>例如目录结构或者其他磁盘管理信息（元数据 metadata 损坏。<br>v远程文件系统加入新的故障模式，来自网络故障或者服务器故障<br>v从故障中恢复包含维护状态信息 state information<br>vStateless 无状态协议如NFC在每个请求里包含所有信息，允许较为容易的故障恢复但是不够安全</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>v规定系统的多个用户如何访问共享文件<br>类似于第六章的进程同步算法<br>v由于磁盘和网络的巨大延迟和很慢的传输速率，倾向于没这么复杂<br>Andrew File System (AFS) 实现了复杂共享语义<br>Unix file system (UFS) 使用:<br>v一个用户对已打开文件的写入，对于打开同一文件的其他用户立即可见。<br>v一种共享模式允许用户共享文件的当前位置指针。<br>AFS 有会话语义<br>v一旦文件关闭，对其所作的更改只能被后来打开的会话可见。</p>
<h3 id="访问控制权限和分组"><a href="#访问控制权限和分组" class="headerlink" title="访问控制权限和分组"></a>访问控制权限和分组</h3><p>v访问模式：读&#x2F;写&#x2F;执行<br>v三种类型的用户<br>  RWX<br>  a) 所有者  7  &#x3D;&gt;1 1 1    RWX<br>  b) 组用户  6  &#x3D;&gt;  1 1 0    RWX<br>  c) 公共用户  1  &#x3D;&gt;  0 0 1<br>v建立一个组，加入一些用户<br>v对特定的文件或目录(game) ，定义适当的访问权限</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
