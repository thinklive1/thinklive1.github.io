<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>thinklive的迪瑞克拉图书馆</title>
    <url>/2023/09/17/blacksouls%E5%8E%9F%E8%91%97%E6%A2%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1>]]></content>
  </entry>
  <entry>
    <title>thinklive的迪瑞克拉图书馆</title>
    <url>/2023/09/17/thinklive%E7%9A%84%E8%BF%AA%E7%91%9E%E5%85%8B%E6%8B%89%E5%9B%BE%E4%B9%A6%E9%A6%86/</url>
    <content><![CDATA[<h1 id="欢迎来到迪瑞克拉"><a href="#欢迎来到迪瑞克拉" class="headerlink" title="欢迎来到迪瑞克拉"></a>欢迎来到迪瑞克拉</h1><p>这里是thinklive的个人博客，不定时地会发一些个人技术学习心得和生活体会<br>使用左侧的分类来定位内容</p>
<h2 id="迪瑞克拉的由来"><a href="#迪瑞克拉的由来" class="headerlink" title="迪瑞克拉的由来"></a>迪瑞克拉的由来</h2><p><code>狄利克雷函数</code>（英语：<code>dirichlet function</code>）是一个定义在实数范围上、值域不连续的函数。<code>狄利克雷函数</code>的图像以Y轴为对称轴，是一个偶函数，它处处不连续，处处极限不存在，不可黎曼积分。这是一个处处不连续的可测函数。<br>在我看来它象征着混沌，不可知与无限的可能性，<code>狄利克雷</code>换一种方式音译就成了迪瑞克拉</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>2023&#x2F;9&#x2F;17<br>迪瑞克拉博客的生日，当天增加了背景音乐，搜索，相册，标签，目录，置顶等基础功能<br>2023&#x2F;9&#x2F;18<br>新增了评论，预估阅读时间，字数统计，网站访问统计功能,将背景音乐的歌曲改为歌单,为了方便使用，菜单切换成了中英双语</p>
]]></content>
  </entry>
  <entry>
    <title>基于恐龙书和苏大ppt的操作系统笔记</title>
    <url>/2023/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机系统可以分为四个部分</span><br><span class="line">硬件(Hardware) – 提供基本的计算资源</span><br><span class="line">CPU, memory, I/O devices</span><br><span class="line">操作系统(Operating System)</span><br><span class="line">控制和协调各用户的应用程序对硬件的使用</span><br><span class="line">应用程序(Application programs) – 规定了用户按何种方式使用系统资源</span><br><span class="line">字处理程序, 编译器, 网络浏览器, 数据库系统, 视频游戏</span><br><span class="line">用户(Users)</span><br><span class="line">人, 机器, 其他计算机</span><br><span class="line">操作系统的目标:</span><br><span class="line">运行用户程序  ---核心目标</span><br><span class="line">更方便使用计算机 ---面向用户</span><br><span class="line">更高效使用计算机 ---面向系统</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>计算机启动时，会启动引导程序，来初始化系统的各个组件，加载操作系统并开始执行<br>操作系统加载到内存后，开始为系统和用户提供服务，成为系统进程或者后台程序该阶段完成后系统完全启动并且等待事件发生。<br>事件发生通过”中断“机制来通知，cpu被中断时，停止正在做的事，并立即转到固定位置继续执行中断服务程序，执行完后继续执行被中断的计算</p>
<ul>
<li>中断：指当出现需要时，CPU暂时停止当前程序的执行，转而执行处理新情况的程序和执行过程</li>
<li>中断号：外部设备进行I&#x2F;O操作时产生的中断信号，发送给CPU</li>
<li>中断向量：中断服务程序的入口地址</li>
<li>中断服务程序：执行中断处理的代码</li>
<li>陷阱(trap):是由于出错或用户请求引起的软件生成的中断<br>操作系统是中断驱动<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在冯·诺依曼体系结构( von Neumann architecture)上执行时，一个典型的指令执行周期是，首先从内存中获取指令，并存到指令寄存器( instruction register)。接着，该指令被解码，也可能会从内存中获取操作数据并且存到内部寄存器。在指令完成对操作数据的执行后，结果也可存到内存。注意:内存单元只能看到内存地址的流，而并不知道它们如何产生(通过指令计数器、索引、间接、常量地址或其他方式)或它们是什么样（指令或数据）的地址。相应地，我们可以忽略程序如何产生内存地址，而只关注由程序运行所生成的地址序列。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h2><p>由两个或多个独立的系统耦合起来<br>共享数据 storage-area network (SAN)。<br>提供高可用性。<br>一定的冗余<br>非对称集群(Asymmetric Clustering)：一台机器运行应用程序，而其他机器处于热备份模式。<br>对称集群(Symmetric Clustering)：多个主机都运行应用程序<br>提供high-performance computing (HPC)<br>用专门的应用程序利用集群，并行计算parallelization</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多道程序设计：在内存中同时存在多道作业，在管理程序控制下相互穿插运行</span><br><span class="line">通过作业调度(Job Scheduling)选中一个作业并运行</span><br><span class="line">当该作业必须等待时 (如等待I/O), 切换到另一个作业</span><br><span class="line">目的:提高CPU的利用率，充分发挥计算机系统部件的并行性</span><br></pre></td></tr></table></figure>
<p>分时系统：控制响应时间较短，使计算机可交互，一般采用时间片轮转方式使一台计算机为多个用户服务<br>并行：两个或者多个作业在同一时刻运行<br>并发：两个或多个作业在同一时间间隔内依次运行<br>双重模式：允许OS保护自身和其他系统部件<br>用户模式(user mode)和内核模式(kernel mode)，由硬件提供模式位<br>特权指令：可能引起系统崩溃的指令，只能运行在内核模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果操作系统不能获得CPU控制权，就无法管理系统</span><br><span class="line">eg.用户程序死循环，用户程序不调用系统调用</span><br><span class="line">解决方法：定时器</span><br><span class="line">在一段时间后发生中断，CPU控制权返回操作系统</span><br><span class="line">固定时间和可变时间定时器</span><br><span class="line">利用时钟和计数器实现</span><br></pre></td></tr></table></figure>
<p>I&#x2F;O保护<br>防止用户程序执行非法I&#x2F;O<br>解决方法：所有I&#x2F;O指令都是特权指令<br>用户程序通过系统调用进行I&#x2F;O操作<br>内存保护<br>防止内存非法访问<br>解决方法：存储保护机制<br>硬件支持<br>程序运行必须的存储设备<br>CPU只能直接访问寄存器、高速缓存和内存<br>处理前和处理后的所有数据都在内存<br>执行的指令都在内存<br>内存管理：提供内存的分配、回收、地址转换、共享和保护等功能<br>提高内存利用率<br>提高内存访问速度<br>从而提高计算机运行效率</p>
<p>操作系统服务提供对用户很有用的函数:</p>
<ul>
<li><p>用户界面 – 所有的操作系统都有用户界面(UI)<br>形式有命令行界面(CLI)、图形用户界面(GUI)、批界面</p>
</li>
<li><p>程序执行 – 系统必须能将程序转入内存并运行程序。程序必须能结束执行，包括正常或不正常结束（指明错误）</p>
</li>
<li><p>I&#x2F;O 操作 -  运行程序可能需要I&#x2F;O,这些I&#x2F;O可能涉及文件或设备.</p>
</li>
<li><p>文件系统操作 -  文件系统特别重要。很明显，程序需要读写文件和目录，创建和删除文件，搜索文件，列出文件信息，访问管理</p>
</li>
<li><p>通信 – 进程间可能需要交换信息，发生同一台计算机运行的进程间或由网络连接的不同计算机上的进程间(消息传递和共享内存)<br>通信可以通过共享内存或消息交换技术来实现 (消息包由OS移动)</p>
</li>
<li><p>错误检测 – OS 需要知道可能出现的错误<br>错误可能发生在CPU 或内存硬件、I&#x2F;O设备和用户程序中<br>对于每种类型的错误，OS 应该采取适当的动作以确保正确和一致的计算<br>调试工具可以在很大程度上加强用户和程序员有效使用系统的能力</p>
</li>
</ul>
<p><code>层次结构</code>：操作系统划分为若干层，在低层上构建高层，底层（0层）为硬件，最高层（ N层）为用户层，每层只使用低层次的功能和服务<br>优点<br>简化了系统设计和实现，便于调试和升级维护<br>缺点<br>层定义困难，效率差<br><code>微内核</code>：<br>问题：内核越来越大，越来越难管理<br>内核微型化：核内移出尽可能多功能到用户空间<br>好处:<br>便于扩充，便于移植操作系统到新架构系统上，更稳定 (更少的代码运行在核心态)，更安全<br>坏处:<br>用户空间和内核空间通信的系统开销增加<br>解决方法：提出消息传递机制<br><code>模块化</code>：<br>大部分现代操作系统采用模块结构(Linux, Solaris)<br>使用面向对象方法<br>每个核心部件分开<br>每个与其他模块的会话被称为接口<br>每个模块在需要时被加载到内核<br>总体而言，类似于分层方法，但更灵活</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个程序可对应一个或多个进程，同样一个进程可对应一个或多个程序</span><br><span class="line">程序是进程的代码部分</span><br><span class="line">进程是活动(active)实体，程序静止（被动passive）实体</span><br><span class="line">进程在内存，程序在外存</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>Control Block)</span></figcaption><table><tr><td class="code"><pre><span class="line">PCB包含同进程有关的信息，包括：</span><br><span class="line">进程状态</span><br><span class="line">程序计数器</span><br><span class="line">CPU寄存器</span><br><span class="line">CPU调度信息</span><br><span class="line">内存管理信息</span><br><span class="line">计账信息</span><br><span class="line">I/O状态信息</span><br></pre></td></tr></table></figure>

<p>![[Pasted image 20230529221113.png]]<br><code>进程调度队列</code>：<br>作业队列 - 在系统中的所有进程的集合<br>就绪队列 - 在主内存中的，就绪并等待执行的所有进程的集合<br>设备队列 - 等待某一I&#x2F;O设备的进程队列<br>在各种队列之间进程的迁移<br><code>进程终止</code>：</p>
<ul>
<li>进程执行最后一项并退出（exit）<br>从子进程向父进程输出数据（通过wait）<br>操作系统收回进程的资源<br>父进程可中止子进程的执行（ abort）</li>
<li>子进程超量分配资源<br>赋予子进程的任务不再需要<br>若父进程终止，一些系统不允许子进程继续存在<br>所有子进程终止– 级联终止</li>
<li>父进程可以等子进程结束<br>调用wait()系统调用<br><code>进程通信</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息传递在微内核中的应用</span><br><span class="line">远程通信无法采用共享内存</span><br><span class="line">两个操作 :</span><br><span class="line">发送send(message) - 固定或可变大小消息</span><br><span class="line">接收receive(message)</span><br><span class="line">若P与Q要通信，需要:</span><br><span class="line">建立通信连接</span><br><span class="line">通过send/receive交换消息</span><br><span class="line">通信连接的实现</span><br><span class="line">物理的（如，共享存储，硬件总线）</span><br><span class="line">逻辑的（如，逻辑特性）</span><br><span class="line">消息传递可阻塞（blocking）或非阻塞（non-blocking）</span><br><span class="line">阻塞-同步</span><br><span class="line">阻塞send：发送进程阻塞，直到消息被接收</span><br><span class="line">阻塞receive：接受者进程阻塞，直到有消息可用</span><br><span class="line">非阻塞-异步</span><br><span class="line">非阻塞send：发送进程发送消息并继续操作</span><br><span class="line">非阻塞receive: 接收者收到一个有效消息或空消息</span><br><span class="line">如果通过信箱，则可分为直接和间接通信</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>线程</code>（轻型进程lightweight process, LWP ）是CPU使用的一个基本单元，包括</p>
<ul>
<li>线程ID</li>
<li>程序计数器</li>
<li>寄存器集<br><code>栈空间</code><br>一个线程与它的对等线程共享：</li>
<li>代码段</li>
<li>数据段</li>
<li>操作系统资源<br>总体作为一个任务<br>多线程的优点：</li>
<li>响应性</li>
<li>资源共享</li>
<li>经济</li>
<li>可伸缩性：可在多处理核上并行运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调度</span><br><span class="line">线程是调度的基本单位，同一进程中的线程切换不会引起进程切换。</span><br><span class="line">并发</span><br><span class="line">线程可以提高系统的并发性。</span><br><span class="line">资源</span><br><span class="line">进程拥有资源，是资源分配的基本单位，而线程则不拥有资源，但它可以访问创建它的进程所拥有的资源</span><br><span class="line">上下文切换</span><br><span class="line">线程的上下文切换的代价比进程小。</span><br></pre></td></tr></table></figure>
<p>可分为数据并行和任务并行<br>![[Pasted image 20230530184144.png]]<br>![[Pasted image 20230530184243.png]]<br>&#x2F;&#x2F;S是应用程序的一部分，N是它在N个处理器上串行运行<br>![[Pasted image 20230530185433.png]]<br><code>线程的分类</code>：</p>
<ul>
<li>用户线程：由用户线程库进行管理的线程<br>内核看不到用户线程<br>用户线程的创建和调度在用户空间中，不需要内核的干预<br>应用于传统的只支持进程的操作系统</li>
<li>内核线程：内核进行管理的线程<br>需要内核支持<br>由内核完成线程调度<br>由内核进行创建和撤销<br><code>多线程模型的分类</code>：</li>
<li>多对一模型：<br>不支持内核线程的操作系统<br>内核只有进程<br>内核只看到一个进程<br>多个线程不能并行运行在多个处理器上<br>进程中的用户线程由进程自己管理<br>进程内线程切换不会导致进程切换<br>一个线程的系统调用会导致整个进程阻塞</li>
<li>一对一模型<br>用于支持线程的操作系统<br>用户线程一对一映射到内核线程<br>操作系统管理这些线程<br>并发性好：多个线程可并行运行在多个处理器上<br>内核开销大</li>
<li>多对多模型：<br>多个用户线程映射为相等或更小数目的内核线程<br>并发性和效率兼顾<br>增加复杂度<br><code>线程库</code><br>为程序员提供API来创建和管理线程<br>两种模式：</li>
<li>用户库（用户线程）<br>存在于用户空间<br>没有内核支持<br>调用线程库不会产生系统调用</li>
<li>内核库（内核线程）<br>存在于内核<br>操作系统支持<br>调用线程库会产生系统调用<br><code>隐式线程</code>：在编译或者运行的时候由编译器或者运行库决定而不是编程者<br><code>线程池</code>：在池中创建一批线程，等待任务<br>优点：<br>利用线程池中的线程来响应请求比创建一个线程更加快速<br>允许一个应用程序中的线程数量达到线程池的上限<br><code>大中央调度</code>:<br>Apple 技术用于Mac OS X 和 iOS<br>扩展C, C++ languages, API, 和 run-time library<br>允许辨认可并行区段<br>管理线程的大多数细节<br>块格式“^{ }” -   ˆ{ printf(“I am a block”); }<br>块放置在调度队列中<br>在线程池中有可用的线程的时候离开队列<br><code>线程撤销</code>在完成前终止线程<br>要取消的线程称为目标线程 target thread<br>大体两种方法:<br>异步取消Asynchronous cancellation 立刻终止目标线程<br>延迟取消Deferred cancellation 允许目标线程周期性检查它是否应该被终止<br><code>调度程序激活</code></li>
<li>通常用一种中间数据结构在用户和内核线程间 – 轻量级进程 lightweight process (LWP)<br>类似虚拟处理器<br>每个 LWP 和内核进行相连<br>一定数量的LWP</li>
<li>调度器激活提供 upcalls – 一种线程库中内核使用upcall处理句柄 upcall handler 来告知特定事件</li>
<li>![[Pasted image 20230530200404.png]]<br>这种通讯允许一个应用程序保持正确数目的内核线程</li>
</ul>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>&#96;需要调度的四种情况</p>
<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程从运行切换到就绪状态（eg.出现中断）</li>
<li>进程从等待状态切换到就绪状态(eg.IO完成)</li>
<li>进程终止时<br>调度只发生在1，4情况下是非抢占调度<br><code>非抢占调度 一旦把CPU分配给某进程后，系统不可以抢占已分配的CPU并分配该其它进程 只有进程自愿释放CPU，才可把CPU分配给其他进程 优点：易实现，调度开销小，适合批处理系统 缺点：响应时间长，不适合交互式系统 </code>抢占调度<br>调度程序可根据某种原则暂停某个正在执行的进程，将已分配给它的CPU重新分配给另一进程<br>可防止单一进程长时间独占CPU<br>系统开销大<br>抢占式与非抢占式的区分<br>运行进程是否是自愿放弃CPU<br><code>长程调度 又称作业调度、高级调度 “新建”状态转换到“就绪”状态 由调度程序选择 控制多道程序的“道/度”（Degree） </code>短程调度<br>又称CPU调度、低级调度<br>调度程序选择下一个执行进程</li>
<li>切换频率<br>短程调度切换频率高<br>长程调度切换频率低</li>
<li>切换开销<br>短程调度开销小(milliseconds，切换快)<br>长程调度开销大(seconds&#x2F;minutes，切换慢)</li>
<li>操作系统中应用<br>短程调度：必需<br>长程调度：可选<br><code>中程调度 又称交换 将进程在内存和外存间换进换出 目的：节省内存空间 </code>就绪队列<code>- 在主内存中处于就绪状态并等待执行的所有进程集合</code>设备队列<code>- 等待某一I/O设备的进程队列 进程的执行过程实际上就是进程在各种队列之间的迁移</code>基本指标</li>
<li>CPU利用率 – 固定时间内CPU运行时间的比例</li>
<li>吞吐量 – 单位时间内运行完的进程数</li>
<li>周转时间 – 进程从提交到运行结束的全部时间</li>
<li>等待时间 – 进程等待调度（不运行）的时间片总和</li>
<li>响应时间 – 从进程提交到首次运行[而不是输出结果]的时间段，也就是第一段的等待时间</li>
</ul>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p><code>等待时间</code>&#x3D;开始处理时间-到达时间<br><code>周转时间</code>&#x3D;等待时间+处理时间</p>
<h2 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务-FCFS"></a>先来先服务-FCFS</h2><p>优点：实现简单<br>缺点：长进程在前会使多个短进程等待过久，增加平均等待时间</p>
<h2 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先-SJF"></a>短作业优先-SJF</h2><p>SJF是最优的 – 对一组指定的进程而言，它给出了最短的平均等待时间</p>
<h3 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><p>有比当前进程所需时间更短进程到达时，更换目前进行进程<br>常用于长进程调度，缺点在于进程的cpu区间难以估计<br>通常用指数平均估计</p>
<h3 id="非抢占式调度"><a href="#非抢占式调度" class="headerlink" title="非抢占式调度"></a>非抢占式调度</h3><p>进程只在结束后让出cpu</p>
<h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>基于进程紧迫程度赋予优先级，cpu分配给最高优先级进程<br>优点<br>实现简单，考虑了进程的紧迫程度<br>灵活，可模拟其它算法</p>
<ul>
<li>静态优先级<br>进程创建时确定，运行期间不变</li>
<li>动态优先级<br>优先级随着进程推进或者等待时间增加而改变</li>
</ul>
<p>&#96;问题</p>
<ul>
<li>饥饿：低优先级进程可能永远无法运行</li>
<li>老化：视进程等待时间延长提高优先级</li>
</ul>
<h3 id="响应比高者优先调度"><a href="#响应比高者优先调度" class="headerlink" title="响应比高者优先调度"></a>响应比高者优先调度</h3><p>响应比&#x3D;（开始时间-到达时间）&#x2F;运行时间</p>
<ul>
<li>如等待时间相同，运行时间越短，优先级越高，类似于SJF</li>
<li>如运行时间相同，优先级取决于其等待时间，类似于FCFS</li>
<li>长进程的优先级可随等待时间的增加而提高，最终可得到服务</li>
<li>缺点：每次调度之前，都需要计算响应比，增加系统开销</li>
</ul>
<h2 id="轮转调度-RR"><a href="#轮转调度-RR" class="headerlink" title="轮转调度-RR"></a>轮转调度-RR</h2><p>将较小的时间单元定义为时间片，就绪队列为循环队列，调度程序循环整个队列，为每个进程分配不超过一个时间片的cpu</p>
<h2 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h2><p>进程分为前台进程（交互进程）和后台进程（批处理进程）<br>不同类型的进程需要不同策略<br>交互进程需要短的响应时间<br>批处理进程需要短的等待时间<br><code>多级队列梯度</code>系统中存在多个就绪队列，每个队列有自己的调度算法</p>
<h3 id="多级反馈序列-MLFQ"><a href="#多级反馈序列-MLFQ" class="headerlink" title="多级反馈序列-MLFQ"></a>多级反馈序列-MLFQ</h3><p><em>(MultiLevel Feedback Queue Scheduling)</em><br>多级队列的延伸<br>不同：</p>
<ul>
<li>多级队列：进程不能在不同队列间移动</li>
<li>多级反馈队列：进程能在不同队列间移动</li>
<li>多级反馈队列调度需要考虑以下问题：<br>队列数<br>每一队列的调度算法<br>决定进程升级（低级队列到高级队列）的方法<br>决定进程降级（高级队列到低级队列）的方法<br>决定新进程将进入哪个队列的方法<br>&#96;最常用的调度算法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg.</span><br><span class="line">Q0-RR时间片8ms</span><br><span class="line">Q1-RR时间片16ms</span><br><span class="line">Q2-FCFS</span><br></pre></td></tr></table></figure>
缺点：优先级一开始确定，无法调整</li>
</ul>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><p>区别用户层和内核层<br>调度线程而不是进程<br>多对多和多对一模型，线程库在可用的LWP上调度用户层线程<br>process-contention scope (PCS) 在进程中进行调度竞争<br>通常由程序员通过优先级设置<br>内核线程通过system-contention scope (SCS) 在CPU上调度– 系统中统一竞争<br>一对一模型仅使用SCS，如Windows， Linux</p>
<h2 id="局部调度"><a href="#局部调度" class="headerlink" title="局部调度"></a>局部调度</h2><p>[[线程库]]决定哪个线程列入轻量级进程LWP</p>
<h2 id="全局调度"><a href="#全局调度" class="headerlink" title="全局调度"></a>全局调度</h2><p>内核决定下一个运行的内核线程</p>
<h1 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h1><p>调度类似单处理器，但需要将任务平均分配</p>
<h2 id="对称多处理器-SMP"><a href="#对称多处理器-SMP" class="headerlink" title="对称多处理器-SMP"></a>对称多处理器-SMP</h2><h3 id="单队列多核调度方法-SQMP"><a href="#单队列多核调度方法-SQMP" class="headerlink" title="单队列多核调度方法(SQMP)"></a>单队列多核调度方法(SQMP)</h3><p>系统有一个就绪队列。当任意一个CPU空闲时，就从就绪队列中选择一个进程到该CPU上运行<br>优点：<br>容易从单核调度算法推广到多核&#x2F;多处理器、<br>实现简单，负载均衡<br>缺点：<br>不具有亲和性<br>加锁问题</p>
<h3 id="多队列调度方法-MQMP"><a href="#多队列调度方法-MQMP" class="headerlink" title="多队列调度方法(MQMP)"></a>多队列调度方法(MQMP)</h3><p>系统有多个就绪队列，一般每个CPU一个。每个就绪队列有自己的调度算法，并且每个就绪队列的调度相对独立<br>优点：<br>亲和性好<br>不需要加锁<br>缺点：<br>负载不均衡<br>策略：“偷”进程<br><code>每个处理器决定自己调度方式 定期检测每个cpu负载，分配任务给空闲处理器 </code>亲和性：进程倾向于在给定cpu上运行</p>
<ul>
<li>软亲和性：不强制禁止迁移</li>
<li>硬亲和性：禁止迁移</li>
</ul>
<h3 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h3><p>共享队列，分配给不同cpu<br>不具有亲和性</p>
<h3 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h3><p>不同cpu有各自队列<br><code>优点</code>：亲和性较好，不需要加锁<br><code>缺点</code>：负载不均匀</p>
<h2 id="非对称处理器-ASMP"><a href="#非对称处理器-ASMP" class="headerlink" title="非对称处理器-ASMP"></a>非对称处理器-ASMP</h2><p>仅一个处理器处理系统数据结构，减轻共享需求</p>
<h1 id="实时cpu调度"><a href="#实时cpu调度" class="headerlink" title="实时cpu调度"></a>实时cpu调度</h1><ul>
<li>软实时系统：不保证调度关键实时进程</li>
<li>硬实时系统：任务必须在截止期限前完成<br>对实时调度，必须支持抢占式、优先级调度<br>但仅仅支持软实时<br>对硬实时必须提供满足截止时间的能力<br>需要调度进程的新特性：<br>周期性 periodic 定期需要CPU<br>有进程时间 t, 截止时间 d, 周期 p<br>0 ≤ t ≤ d ≤ p<br>周期任务的速率Rate 1&#x2F;p</li>
</ul>
<h2 id="单速速度调度"><a href="#单速速度调度" class="headerlink" title="单速速度调度"></a>单速速度调度</h2><p>依照周期倒数分配一个优先级<br><code>优点</code>：最大化cpu利用率<br><code>缺点</code>：不保证每个进程都赶上截止期限(周期内执行不完)</p>
<h2 id="最早截止期限优先调度-EDF"><a href="#最早截止期限优先调度-EDF" class="headerlink" title="最早截止期限优先调度-EDF"></a>最早截止期限优先调度-EDF</h2><p>根据截止时间分配优先级<br>越早截止期限，优先级越高</p>
<h2 id="比例分享调度"><a href="#比例分享调度" class="headerlink" title="比例分享调度"></a>比例分享调度</h2><p>所有应用中分配T股，确保所有进程有固定的cpu时间，如果新加入进程大于T股剩余量，则不允许进入</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li>实时任务有静态优先级（友好值）</li>
<li>抢占式<br>没有真正的线程</li>
</ul>
<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul>
<li>抢占调度</li>
<li>优先级</li>
</ul>
<p>对共享数据的并发访问可能导致数据的不一致性，需要保证并发进程正确执行顺序的机制<br><code>竞争条件</code>：多个进程并发访问同一共享数据</p>
<ul>
<li><code>同步</code>：协调执行次序</li>
<li><code>互斥</code>：进程排他性运行，可以独占资源<br><code>临界资源</code>：一次只允许一个进程使用的资源，又称互斥资源、独占资源或共享变量<br><code>共享资源</code>：一次允许多个进程使用的资源</li>
</ul>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><ul>
<li><code>互斥</code>：临界区执行的进程排斥其他进程（有相同临界资源）</li>
<li><code>进步</code>:临界区无进程执行，不能无限期延长下一个需要临界区进程的等待时间</li>
<li><code>优先等待</code>：一个进程进入临界区时，其他进程进入<code>临界区</code>有次数限制</li>
<li>进入区：互斥</li>
<li>退出区：有空让进</li>
<li>每个临界区不能过大：有限等待<br>空闲则入：其他进程均不处于临界区；<br>忙则等待：已有进程处于其临界区；<br>有限等待：等待进入临界区的进程不能”死等”；<br>让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peterson算法</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">  flag [i]:= true;  </span><br><span class="line">  turn = j;  </span><br><span class="line">  while (flag [j] and turn == j) ;</span><br><span class="line"></span><br><span class="line">  critical section</span><br><span class="line"></span><br><span class="line">  flag [i] = false;</span><br><span class="line"></span><br><span class="line">  remainder section</span><br><span class="line"></span><br><span class="line">  &#125; while (1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acquire() &#123;  </span><br><span class="line">       while (!available)</span><br><span class="line">          ; /* busy wait */</span><br><span class="line">       available = false;;</span><br><span class="line">    &#125;</span><br><span class="line">   release() &#123;</span><br><span class="line">       available = true;</span><br><span class="line">    &#125;</span><br><span class="line">   do &#123;</span><br><span class="line"></span><br><span class="line">    acquire lock</span><br><span class="line"></span><br><span class="line">       critical section</span><br><span class="line"></span><br><span class="line">    release lock</span><br><span class="line"></span><br><span class="line">      remainder section</span><br><span class="line"></span><br><span class="line"> &#125; while (true);</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁（自旋锁）"><a href="#互斥锁（自旋锁）" class="headerlink" title="互斥锁（自旋锁）"></a>互斥锁（自旋锁）</h3><p>原子执行acquire(),release()<br>acquire：while(!available) waiting;<br>available&#x3D;false<br>release:available&#x3D;false</p>
<h3 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h3><ul>
<li>在进入临界区前，每个进程接收一个号码。具有最小号码的进程进入临界区。</li>
<li>如果进程Pi和Pj接收到同样的号码，如果i &lt; j ，则Pi先得到服务，否则Pj先得到服务。</li>
<li>这种号码方案总是以递增序列产生号码；如： 1,2,3,3,3,3,4,5…<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  choosing[i] = true;</span><br><span class="line">  number[i] = max(number[0], number[1], …, number [n – 1])+1;</span><br><span class="line">  choosing[i] = false;</span><br><span class="line">  for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">  while (choosing[j]) ;</span><br><span class="line">  while ((number[j] != 0) &amp;&amp; (number[j,j] &lt; number[i,i])) ;</span><br><span class="line">  &#125;</span><br><span class="line">  critical section</span><br><span class="line">  number[i] = 0;</span><br><span class="line">  remainder section</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="信号量（软件解决方案）"><a href="#信号量（软件解决方案）" class="headerlink" title="信号量（软件解决方案）"></a>信号量（软件解决方案）</h2><ul>
<li>保证多个代码段不被并发调用</li>
<li>进入关键代码段前，进程必须获取信号量，否则不能运行</li>
<li>执行完关键代码段，必须释放信号量</li>
<li>信号量有值，说明空闲，为负说明忙碌<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信号量S – 整型变量</span><br><span class="line">提供两个不可分割的[原子操作]访问信号量</span><br><span class="line">wait (S):</span><br><span class="line">     while S&lt;= 0 do no-op;  </span><br><span class="line">     S--;  </span><br><span class="line">signal(S):</span><br><span class="line">     S++;</span><br><span class="line">wait (S)又称为P(S)</span><br><span class="line">signal(S)又称为V(S)</span><br></pre></td></tr></table></figure>
&#96;分类</li>
<li>计数信号量：没有限制的整型值计数信号量&#x3D;同步信号量</li>
<li>二值信号量：0 || 1 二值信号量&#x3D;互斥信号量<br>&#96;使用<br>必须取一次且仅有一次初值<br>初值不为负<br>除了初始化，只能通过执行P、V操作来访问S<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：P1  和 P2 需要 C1 比C2先运行</span><br><span class="line">       semaphore s=0</span><br><span class="line">P1:</span><br><span class="line">   C1;</span><br><span class="line">   signal(s);</span><br><span class="line"></span><br><span class="line">P2:</span><br><span class="line">   wait(s);</span><br><span class="line">   C2;</span><br></pre></td></tr></table></figure>
死锁 – 两个或多个进程无限期地等待一个事件的发生，而该事件正是由其中的一个等待进程引起的.<br>P0  P1<br>  P(S);  P(Q);<br>  P(Q);  P(S);<br>  V(S);  V(Q);<br>  V(Q)  V(S);<br>饥饿 – 无限期地阻塞。进程可能永远无法从它等待的信号量队列中移去.</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><p><code>生产者 把产品放入指定缓冲区 in:所有的生产者对in指针需要互斥 counter：所有生产者消费者进程对counter互斥 </code>消费者<br>从指定缓冲区取出产品<br>out:所有的消费者对out指针需要互斥<br>counter：所有生产者消费者进程对counter互斥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer[in] = nextProduced;</span><br><span class="line">in = (in + 1) % BUFFER_SIZE;</span><br><span class="line">counter++;</span><br><span class="line"></span><br><span class="line">nextConsumed = buffer[out];</span><br><span class="line">out = (out + 1) % BUFFER_SIZE;</span><br><span class="line">counter--;</span><br><span class="line"></span><br><span class="line">生产者：</span><br><span class="line"> &#123;</span><br><span class="line">  …</span><br><span class="line">  生产一个产品</span><br><span class="line">  …</span><br><span class="line">  wait(empty);</span><br><span class="line">  wait(m);</span><br><span class="line">   …</span><br><span class="line">  C1：把产品放入指定缓冲区</span><br><span class="line">   …</span><br><span class="line">  signal(m);</span><br><span class="line">  signal(full);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">消费者：</span><br><span class="line"> &#123;</span><br><span class="line">  …</span><br><span class="line">  wait(full)；</span><br><span class="line">  wait(m);</span><br><span class="line">   …</span><br><span class="line">  C2：从指定缓冲区取出产品</span><br><span class="line">   …</span><br><span class="line">  signal(m);</span><br><span class="line">  signal(empty);</span><br><span class="line">   …</span><br><span class="line">  消费取出的产品</span><br><span class="line">   …</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&#96;同步分析</p>
<ul>
<li>找出需要同步的代码段</li>
<li>分析片段执行顺序</li>
<li>增加同步信号量并赋初始值</li>
<li>关键代码前后加wait和signal操作<br>&#96;生产者</li>
<li>判断是否能获得空缓冲区，否则阻塞</li>
<li>满缓冲区数量++，如果有消费者由于等待阻塞，唤醒该消费者<br>&#96;消费者</li>
<li>判断能否获得满缓冲区，否则阻塞</li>
<li>空缓冲区数量++，如果有生产者等待，唤醒该生产者</li>
</ul>
<h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><p>两组并发进程读者和写者,共享一组数据区进行读写<br>&#96;要求</p>
<ul>
<li>允许多个读者同时读</li>
<li>不允许读者、写者同时读写</li>
<li>不允许多个写者同时写<br>&#96;读者</li>
<li>无读者写者，新读者可读</li>
<li>有写者等，其他读者读，新读者可读</li>
<li>有写者写，新读者等<br>&#96;写者</li>
<li>无读者写者，新写者可写</li>
<li>有读者读，写者等</li>
<li>有其他写者，写者等待<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增加一个读者计数器rc，设置初始值为0；</span><br><span class="line">读者：Repeat</span><br><span class="line">P(mutex);</span><br><span class="line">readcount:=readcount+1;</span><br><span class="line">if readcount=1</span><br><span class="line">then P (w);</span><br><span class="line">V(mutex);//mutex为互斥信号量，初始值为1</span><br><span class="line">读</span><br><span class="line">P(mutex);</span><br><span class="line">readcount:=readcount-1;</span><br><span class="line">if readcount=0</span><br><span class="line">then V(w);</span><br><span class="line">V(mutex);</span><br><span class="line">Until false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Writers</span><br><span class="line">……</span><br><span class="line">P(W);</span><br><span class="line">写</span><br><span class="line">V(W);</span><br><span class="line">…...</span><br></pre></td></tr></table></figure>
&#96;问题：写者可能饥饿</li>
<li>读者写者互斥，写者直到读者count为0才进入进程</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>5个哲学家、5根筷子，每个哲学家左右各有一根筷子，每个哲学家只有拿起左右两个筷子才能吃饭<br>五个元素数组储存筷子，对每个哲学家有拿起左右筷子，放下左右筷子的函数<br>&#96;防止死锁</p>
<h5 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h5><p>最多允许四个哲学家同时坐在桌子周围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semephore *chopstick[5];   //初始值为1</span><br><span class="line">semaphore *seat;  //初始值为4</span><br><span class="line">哲学家 i:</span><br><span class="line">  ……</span><br><span class="line">  P(seat);  //看看4个座位是否有空</span><br><span class="line">  P(chopStick[i]);  //拿左边筷子</span><br><span class="line">  P(chopStick[(i + 1) % 5]);  //拿右边筷子</span><br><span class="line">   吃饭</span><br><span class="line">   V(chopStick[i]);  //放下左边筷子</span><br><span class="line">   V(chopStick[(i + 1) % 5]);  //放下右边筷子</span><br><span class="line">   V(seat);  //释放占据的位置</span><br></pre></td></tr></table></figure>
<ul>
<li>左右筷子都可用时才拿起筷子</li>
<li>非对称解决，单号哲学家优先拿左边筷子，双号优先拿右边</li>
</ul>
<h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>仅当一个哲学家左右两边筷子都可用时，才允许他拿筷子<br>哲学家分为三个状态thinking,hungry,eating<br>设置5个信号量代表所有哲学家，仅当自身hungry且左右都不在吃饭时才开始eating</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(int i);</span><br><span class="line">    &#123;</span><br><span class="line">        if (state[i] == hungry) &amp;&amp;  //是否饿了</span><br><span class="line">          (state[(i+4)%5]!=eating) &amp;&amp; //左边哲学家是否在吃饭</span><br><span class="line">          (state[(i+1)%5]!=eating)  //右边哲学家是否在吃饭</span><br><span class="line">          &#123;</span><br><span class="line">                 state[i]=eating;  //设置哲学家状态为eating</span><br><span class="line">                 V(ph[i]);  //ph[i]设置为1</span><br><span class="line">           &#125;     </span><br><span class="line">     &#125;</span><br><span class="line">     state[i]=hungry；</span><br><span class="line">            P(m);</span><br><span class="line">            test(i);</span><br><span class="line">            V(m);</span><br><span class="line">            P(ph[i]);</span><br></pre></td></tr></table></figure>
<h5 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h5><p>给所有哲学家编号，奇数号哲学家必须首先拿左边筷子，偶数号哲学家则反之</p>
<h3 id="信号量总结"><a href="#信号量总结" class="headerlink" title="信号量总结"></a>信号量总结</h3><p>S&gt;0：有S个资源可用<br>S&#x3D;0：无资源可用<br>S&lt;0：则|S|表示S等待队列中的进程个数<br>P(S)：申请一个资源<br>V(S)：释放一个资源<br>互斥信号量初始值：一般为1<br>同步信号量初始值：0-N<br>&#96;P、V操作成对出现<br>互斥操作：P、V操作处于同一进程内<br>同步操作：P、V操作在不同进程内<br>两个一起的P操作的顺序至关重要<br>同步与互斥P操作一起时，同步P操作要在互斥P操作前<br>两个V操作的次序无关紧要</p>
<p><code>缺点</code>：同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如P、V操作的次序错误、重复或遗漏）<br>易读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序；<br>不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局；<br>正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误；</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据<br>封装数据以及对数据的操作<br>确保每次只要一个进程在管程内活动<br><code>互斥 管程中的变量只能被管程中的操作访问 任何时候只有一个进程在管程中操作 类似临界区 由编译器完成 </code>同步<br>条件变量<br>唤醒和阻塞操作<br>x.wait(): 进程阻塞直到另外一个进程调用x.signal()<br>x.signal()：唤醒另外一个进程</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>管程内可能存在不止1个进程<br>如：进程P调用signal操作唤醒进程Q后<br>存在的可能<br>P等待直到Q离开管程 （Hoare）<br>Q等待直到P离开管程（Lampson &amp; Redll，MESA语言）<br>P的signal操作是P在管程内的最后一个语句 (Hansen，并行Pascal)</p>
<h2 id="内存概念"><a href="#内存概念" class="headerlink" title="内存概念"></a>内存概念</h2><ul>
<li>程序必须装入内存才能被执行</li>
<li>CPU可以直接访问的存储器只有主存和寄存器</li>
<li>寄存器通常可以在一个（或少于一个）CPU时钟周期内完成访问</li>
<li>完成主存访问可能需要多个CPU时钟周期</li>
<li>CPU暂停（Stall）：在读取内存数据时，CPU空闲</li>
<li>Cache 位于主存和CPU寄存器之间，协调速度差异</li>
<li>内存保护需要保证正确的操作</li>
<li>基址寄存器（ Base）：进程最小的合法物理内存地址</li>
<li>界限寄存器（Limit）：进程地址的长度</li>
<li>CPU在执行指令时，需要进行地址合法性验证<br><code>给进程提供一段地址</code>：基地址寄存器（最小地址）和界限地址寄存器（地址范围）<br>物理地址对进程是隐藏的<br><code>地址绑定（程序加载地址）</code>：可以静态绑定也可以动态绑定，动态绑定生成可重定位代码<br><code>动态加载</code>，所有程序以可重定位格式存储在磁盘，只有在调用时才被加载<br><code>动态链接和共享库</code>:每个库程序都有一个存根，指出如何定位内存驻留库程序，或者程序不在内存时如何家在程序，执行存根时检查程序是否在内存，若不是，则加载程序到内存</li>
</ul>
<h3 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h3><p>地址绑定（重定位）：把程序中的相对地址转换为内存中的绝对地址的过程<br>指令和数据绑定到内存地址可在三个不同阶段：<br><code>编译时期（ Compile time） 如果内存位置已知，可生成绝对代码 如果开始位置改变，需要重新编译代码 </code>加载时期（ Load time）<br>如果存储位置在编译时不知，则必须生成可重定位（ relocatable ）代码<br>&#96;执行时期（ Execution time）<br>如果进程执行时可在内存移动，则地址绑定可延迟到运行时<br>需要硬件对地址映射的支持（例如基址和限长寄存器）<br>大部分操作系统用这个方法</p>
<h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><p>逻辑地址空间的概念同物理地址空间相关联，它是正确内存管理的中心<br>逻辑地址Logical address<br>由CPU产生<br>在进程内的相对地址<br>也称：虚拟地址、程序地址<br>物理地址Physical address<br>内存地址<br>所有内存统一编址<br>也称：绝对地址、实地址</p>
<h3 id="内存管理单元"><a href="#内存管理单元" class="headerlink" title="内存管理单元"></a>内存管理单元</h3><p>把虚拟地址映射到物理地址的硬件<br>是CPU用来管理内存的控制线路<br>在MMU策略中，基址寄存器中的值在其送入内存的时候被加入到由一个用户进程所产生的每个地址中<br>用户程序所对应到的是逻辑地址，物理地址对它从来都不可见</p>
<h3 id="动态加载和链接"><a href="#动态加载和链接" class="headerlink" title="动态加载和链接"></a>动态加载和链接</h3><p><code>加载 例程在调用之前并不加载 更好的内存空间利用率 没有被使用的例程不被载入 当需大量代码来处理不经常使用的功能时非常有用 </code>链接<br>和各种库文件的链接被推迟到执行时期<br>需要动态装载技术支持<br>一小段代码 - 存根，用来定位合适的保留在内存中的库程序<br>存根用例程地址来替换自己，并开始执行例程<br>操作系统需要检查例程是否在进程的内存空间，所以需要操作系统支持</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行。<br><code>备份区</code>—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">滚入，滚出(Roll out, roll in )—交换由于基于优先级的算法而不同，低优先级的进程被换出，这样高优先级的进程可以被装入和执行。</span><br><span class="line">交换时间的主要部分是转移时间，总的转移时间直接同交换的内存的数量成比例。</span><br><span class="line">在许多系统如：UNIX，Linux，Windows中，可以找到一些被修正过的交换措施。</span><br><span class="line">系统维持一个就绪队列，它包括在备份存储或在内存中准备运行的所有进程</span><br></pre></td></tr></table></figure>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><p>为一个用户程序分配一个连续的内存空间</p>
<ul>
<li>单一连续分配：单道程序环境下，仅装有一道用户程序，即整个内存的用户空间由该程序独占</li>
<li>固定分区分配<br>固定分配多个区域，用于放置单个进程<br>预先把可分配的主存空间分割成若干个连续区域，称为一个分区。<br>每个分区的大小可以相同也可以不同。但分区大小固定不变，每个分区装一个且只能装一个程序<br>内存分配：如果有一个空闲分区, 则分配给进程</li>
<li>可变分区分配：<br>用表格记录内存使用情况，根据内存块和孔调度进程<br>当一个进程到来的时候，它将从一个足够容纳它分区中分配内存。<br>操作系统包含以下信息:<br>a) 已分配的分区-已分配分区表   b) 空的分区-空闲分区表</li>
</ul>
<h3 id="选择孔"><a href="#选择孔" class="headerlink" title="选择孔"></a>选择孔</h3><ul>
<li>首次适应（First-fit）: 分配最先找到的合适的分区</li>
<li>最佳适应（Best-fit）: 搜索整个列表，找到适合条件的最小的分区进行分配</li>
<li>最差适应（Worst-fit）: 搜索整个列表，寻找最大的分区进行分配</li>
</ul>
<p><code>碎片</code>：</p>
<ul>
<li>外部碎片：存储被分为大量小孔</li>
<li>内部碎片：分配给进程的孔，进程不需要使用的部分则成为内部碎片<br>外碎片 –整个可用内存空间可以用来满足一个请求，但它不是连续的<br>内碎片 –分配的内存可能比申请的内存大一点，这两者之间的差别是在分区内部，但又不被使用<br>&#96;可通过紧缩来减少外碎片<br>把一些小的空闲内存结合成一个大的块。<br>只有重定位是动态的时候，才有可能进行紧缩，紧缩在执行时期进行</li>
</ul>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>一个程序是一些段的集合，一个段是一个逻辑单位<br>每个段用段名称和段偏移指定位置<br>一个逻辑地址是两个向量的集合:<br>&lt;segment-number, offset&gt;</p>
<p>段表 - 映射二维用户地址，每个表项包括:<br>基址 - 包含内存中段物理地址的起始地址<br>限长 - 指定段的长度<br>段表基址寄存器(STBR)指向段表在内存中的地址<br>段表限长寄存器(STLR)表明被一个程序所使用的段的数目<br>如果 s &lt; STLR，段号s 是合法的</p>
<p>由于段的长度各不相同，内存分配是一个动态存储-分配问题</p>
<p>&#96;内存分配<br>首先&#x2F;最佳适应法<br>外碎片问题</p>
<p>&#96;重定位<br>动态<br>由段表来执行</p>
<p>&#96;共享<br>共享的段<br>同样的段号</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>允许进程的物理地址不连续<br><code>基本方法</code>：将物理内存分为固定大小的块，称为帧或页帧，逻辑内存分为同样大小的块，称为页或页面<br>进程物理地址空间可能不连续<br>如果有可用的物理内存，它将分给进程<br>把物理内存分成大小固定的块，称为帧（Frame）<br>大小为2的幂<br>早期：512字节至8192字节<br>现在：4K-64K<br>把逻辑内存也分为同样大小的块，称为页（Page）<br>系统保留所有空闲帧的记录<br>运行一个有N页大小程序，需要找到N个空帧来装入程序<br>建立一个页表，把逻辑地址转换为物理地址<br>存在内碎片<br><code>内存保护 内存的保护由与每个帧相连的保护位来实现 有效-无效位附在页表的每个表项中: “有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页 “无效”表示页不在进程的逻辑地址空间中 </code>共享代码<br>如果代码是可重入代码（只读），可以在进程间共享 (如文本编辑器, 编译器, 数据库系统)<br>共享代码必须出现在所有进程的逻辑地址空间的相同位置<br>&#96;私有代码和数据<br>每个进程保留一个代码和数据副本<br>存有私有数据和代码的页能够出现在逻辑地址空间的任意位置</p>
<h3 id="页表的层次结构"><a href="#页表的层次结构" class="headerlink" title="页表的层次结构"></a>页表的层次结构</h3><h4 id="二层页表"><a href="#二层页表" class="headerlink" title="二层页表"></a>二层页表</h4><p>内存的保护由与每个帧相连的保护位来实现<br>有效-无效位附在页表的每个表项中:<br>“有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页<br>“无效”表示页不在进程的逻辑地址空间中<br>![[Pasted image 20230605104632.png]]</p>
<h4 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h4><p>虚拟页号被散列到一个页表中。这种页表的每一个条目都包括了一个链表元素，这些元素哈希成同一<br>虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。<br>虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。</p>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>对于每个真正的内存页或帧有一个条目。<br>每个条目保存在真正内存位置的页的虚拟地址，以及包括拥有这个页的进程的信息。<br>&#96;优缺点<br>减少了需要储存每个页表的内存，但是当访问一个页时，增加了寻找页表需要的时间。<br>使用哈希表来将查找限制在一个或少数几个页表条目。<br>实现共享内存困难</p>
<h4 id="段页式原理"><a href="#段页式原理" class="headerlink" title="段页式原理"></a>段页式原理</h4><p>分段和分页原理的结合<br>先将用户程序分成若干个段，再把每个段分成若干个页，并为每个段赋予一个段号<br>逻辑地址：&lt;段号，页号，页内偏移&gt;<br>存在内碎片<br>无外碎片</p>
<h3 id="内存扩充技术"><a href="#内存扩充技术" class="headerlink" title="内存扩充技术"></a>内存扩充技术</h3><ol>
<li>紧缩Compaction（可变分区）</li>
<li>覆盖技术Overlaying</li>
<li>交换技术Swapping</li>
<li>虚拟内存Virtual Memory</li>
</ol>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>解决问题à程序大小超过物理内存总和<br>程序执行时<br>只在内存中保留那些在任何时间都需要的指令和数据<br>程序的不同部分在内存中相互替换<br>由程序员声明覆盖结构，不需要操作系统的特别支持<br>覆盖结构的程序设计很复杂<br>应用于早期的操作系统</p>
<h4 id="交换-1"><a href="#交换-1" class="headerlink" title="交换"></a>交换</h4><p>在多道程序环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况<br>另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况<br>浪费资源，降低系统吞吐量。<br>一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行<br>备份区—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问<br>交换（备份区）：系统指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问</p>
<h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>资源类型 R1, R2, . . ., Rm<br>CPU周期，内存空间，I&#x2F;O设备<br>每一种资源Ri 有Wi  种实例<br>每一个进程通过如下方法来使用资源<br>申请，使用，释放<br>资源动态申请-常用方法<br>在进程运行过程中申请资源<br>资源静态申请<br>在进程运行前一次申请所有资源</p>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>死锁指一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组中其他进程所持有的资源</p>
<ul>
<li>互斥：一次只有一个进程可以使用一个资源</li>
<li>占用并等待：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源</li>
<li>非抢占：一个资源只有当持有它的进程完成任务后，自由的释放</li>
<li>循环等待：等待资源的进程之间存在环 {P0, P1, …, P0}</li>
</ul>
<h2 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h2><p>被分为两个部分<br>P &#x3D; {P1, P2, …, Pn}, 含有系统中全部的进程<br>R &#x3D; {R1, R2, …, Rm}, 含有系统中全部的资源<br>请求边：有向边Pi-&gt;Rj<br>分配边：有向边Ri-&gt;P </p>
<ul>
<li>如果图没有环，那么不会有死锁</li>
<li>如果图有环<br>如果每一种资源类型只有一个实例，那么死锁发生<br>如果一种资源类型有多个实例，可能死锁<br>![[Pasted image 20230604203017.png]]</li>
</ul>
<h2 id="死锁处理的分类"><a href="#死锁处理的分类" class="headerlink" title="死锁处理的分类"></a>死锁处理的分类</h2><ul>
<li>确保系统永远不会进入死锁状态<br>死锁预防<br>死锁避免</li>
<li>允许系统进入死锁状态，然后检测它，并加以恢复<br>死锁检测<br>死锁恢复</li>
<li>忽略这个问题，假装系统中从未出现过死锁。<br>这个方法被大部分的操作系统采用，包括UNIX、Windows<br>由开发人员自行处理死锁</li>
</ul>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>&#96;抑制死锁发生的必要条件</p>
<ul>
<li>互斥：可共享资源不涉及死锁，互斥资源必须强制互斥</li>
<li>持有并等待：保证进程申请资源时不占有其他资源，要求进程在执行前一次性申请全部资源，或者只有不占有资源时才可以分配资源，&#96;可能出现饥饿</li>
<li>抢占：</li>
</ul>
<ol>
<li>如果一个进程的申请没有实现，它要释放所有占有的资源</li>
<li>先占的资源放入进程等待资源列表中</li>
<li>进程在重新得到旧的资源的时候可以重新开始</li>
<li>进程申请资源时，如果资源可用则分配，如果不可用，检查资源是否被分配给等待额外资源的其他进程，如果是，抢占资源，否则，申请进程等待</li>
</ol>
<ul>
<li>循环等待:对所有资源完全排序，进程按顺序申请资源<br>银行家算法</li>
</ul>
<h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><ul>
<li>一个简单而有效的模型要求每一个进程声明它所需要的资源的最大数</li>
<li>死锁避免算法动态检查资源分配状态以确保循环等待条件不可能成立</li>
<li>资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量所决定</li>
</ul>
<h4 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h4><p>当进程申请一个有效的资源的时候，系统必须确定分配后是安全的<br>如果存在一个安全序列，系统处于安全态<br>进程序列&lt;P1, P2, …, Pn&gt;是安全的，如果每一个进程Pi所申请的可以被满足的资源数加上其他进程所持有的该资源数小于系统总数<br>如果 Pi 需要的资源不能马上获得，那么Pi 等待直到所有的Pi-1进程结束。<br>当Pi-1 结束后， Pi获得所需的资源，执行、返回资源、结束。<br>当Pi结束后， Pi+1获得所需的资源执行，依此类推。<br>&#96;定理<br>如果一个系统在安全状态，就没有死锁<br>如果一个系统不是处于安全状态，就有可能死锁<br>避免&#x3D;&gt;确保系统永远不会进入不安全状态</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>多个实例</li>
<li>每一个进程必须事先声明使用的最大量</li>
<li>当一个进程请求资源，它可能要等待</li>
<li>当一个进程得到所有的资源，它必须在有限的时间释放它们<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Available:  长度为 m的向量。 如果available[j]=k,那么资源Rj有k个实例有效</span><br><span class="line">Max: n x m 矩阵。 如果Max[i,j]=k,那么进程Pi最多可以请求k个资源Rj的实例</span><br><span class="line">Allocation:  n x m 矩阵。 如果Allocation[i,j]=k,那么进程Pj当前分配了k个资源Rj的实例</span><br><span class="line">Need:  n x m 矩阵。如果Need[,j]=k,那么进程Pj还需要k个资源Rj的实例</span><br><span class="line">Need [i,j] = Max[i,j] – Allocation [i,j].</span><br><span class="line">1.让Work和Finish作为长度为m和n的向量初始化：</span><br><span class="line">Work := Available</span><br><span class="line">Finish [i] = false for i - 1,2,3, …, n.</span><br><span class="line">2.  查找i</span><br><span class="line">(a) Finish [i] = false</span><br><span class="line">(b) Needi £ Work</span><br><span class="line">If no such i exists, go to step 4.</span><br><span class="line">3.  Work := Work + Allocationi  </span><br><span class="line">Finish[i] := true  </span><br><span class="line">go to step 2.</span><br><span class="line">4.  如果对所有i的 Finish [i] = true, 则系统处在安全状态。</span><br></pre></td></tr></table></figure>
   Requesti &#x3D;进程 Pi 的资源请求向量.  如果Requesti [m] &#x3D; k 则进程 Pi 想要资源类型为Rjm的k个实例<br>1.  如果 Requesti £ Needi 转 step 2.  否则报错, 因为进程请求超出了其声明的最大值<br>2.  如果 Requesti £ Available, 转 step 3.  否则 Pi  必须等待, 因为资源不可用.<br>3.  假设通过修改下列状态来分配请求的资源给进程Pi :<br>  Available :&#x3D; Available - Requesti;<br>  Allocationi :&#x3D; Allocationi + Requesti;<br>  Needi :&#x3D; Needi – Requesti;;</li>
</ul>
<p> <br>•如果系统安全 Þ 将资源分配给 Pi.<br>•如果系统不安全 Þ Pi 必须等待，恢复原有的资源分配状态</p>
<h3 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h3><p><code>每个资源类型有一个实例</code>：维护进程等待图<br><code>每个资源类型有多个实例</code>：用available和finished数组探查是否死锁<br>允许进入死锁状态并加以恢复<br>维护等待图<br>节点是进程<br>Pi-&gt;Pj表明Pi在等待Pj<br>定期调用算法来检查是否有环<br>一个检查图中是否有环的算法需要n^2的操作来进行，n为图中的节点数<br>Available ：一个长度为m的向量，表示每一种资源类型可用的实例数目<br>Allocation:  一个n x m 的矩阵，定义了当前分配的每一种资源类型的实例数目<br>Request: 一个n x m 的矩阵，表明了当前的进程请求。如果Request[i，j]&#x3D;k，那么进程Pi请求k个资源Rj的实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  让Work和Finish作为长度为m和n的向量初始化</span><br><span class="line">(a) Work = Available</span><br><span class="line">(b)  For i = 0,2, …, n-1, if Allocationi ¹ 0, thenFinish[i] = false;otherwise, Finish[i] = true.</span><br><span class="line"></span><br><span class="line">2.  找到满足下列条件的下标i</span><br><span class="line">(a)  Finish[i] = false</span><br><span class="line">(b)  Requesti &lt;= Work</span><br><span class="line">如果没有这样的i存在，转4</span><br><span class="line"></span><br><span class="line">3.  Work = Work + Allocationi  </span><br><span class="line">Finish[i] = true  </span><br><span class="line">转 2.</span><br><span class="line"></span><br><span class="line">4.如果有一些i (0 £ i &lt; n) , Finish[i] = false, 则系统处在死锁状态。而且， 如果 Finish[i] = false, 则进程 Pi 是死锁的。</span><br></pre></td></tr></table></figure>
<p>&#96;算法需要m x n^2 次操作来判断是否系统处于死锁状态</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>可以一次中断所有进程排查，也可以一个一个终结进程<br>选择牺牲进程：最小化代价<br>回滚：返回到安全的状态，然后重新开始进程<br>饥饿：同样进程的可能总是被选中。在代价因素中加入回滚次数</p>
<h2 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h2><p><code>局部性原理</code>：在一较短的时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域<br>一个程序只要部分装入内存就可以运行<br>整个程序不是同一时间都要运行<br>&#96;程序部分装入技术优点<br>进程大小不再受到物理内存大小限制<br>每个进程需要的内存更小<br>更多进程可以并发运行<br>I&#x2F;O更少</p>
<ul>
<li>虚拟存储技术：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存执行。</li>
<li>虚拟地址空间：分配给进程的虚拟内存</li>
<li>虚拟地址：在虚拟内存中指令或数据的位置</li>
<li>虚拟内存：把内存和磁盘有机结合起来使用，得到一个容量很大的“内存”，即虚存<br><code>特点 只有部分运行的程序需要在内存中 逻辑地址空间能够比物理地址空间大 允许多个进程享同一地址空间 允许更有效的进程创建 </code>虚拟内存能够通过以下手段来执行实现:<br>虚拟页式（虚拟存储技术+页式存储管理）<br>虚拟段式（虚拟存储技术+段式存储管理）<br>&#96;虚拟页式有两种方式<br>按需调页（ Demand paging ）<br>预调页（Prepaging）</li>
</ul>
<h2 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h2><p><code>基本思想 进程开始运行之前，不是装入全部页面，而是装入一个或零个页面 运行之后，根据进程运行需要，动态装入其他页面 当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面 </code>请求分页（按需调页）<br>只有在一个页需要的时候才把它换入内存<br>需要很少的I&#x2F;O<br>需要很少的内存<br>快速响应<br>多用户<br><code>懒惰交换</code>:只有在需要页时，才将它调入内存<br>交换程序(swapper)对整个进程进行操作<br>调页程序(pager)只是对进程的单个页进行操作</p>
<h3 id="有效无效位"><a href="#有效无效位" class="headerlink" title="有效无效位"></a>有效无效位</h3><p>每一个页表的表项有一个有效- 无效位相关联：<br>1表示在内存，0表示不在内存<br>在所有的表项中，这个位被初始化为0<br>一个页表映象的例子</p>
<h3 id="缺页中断的处理"><a href="#缺页中断的处理" class="headerlink" title="缺页中断的处理"></a>缺页中断的处理</h3><p>1.访问指令或数据<br>2.查看另一个表来决定:<br>无效引用 Þ 终止<br>仅仅不在内存<br>3.找到页在后备存储上的位置<br>4.得到空的页框，把页换入页框<br>5.重新设置页表，把有效位设为v<br>6.重启指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">极端情况：进程执行第一行代码时，内存内没有任何代码和数据</span><br><span class="line">进程创建时，没有为进程分配内存，仅建立PCB</span><br><span class="line">导致缺页中断</span><br><span class="line">纯请求分页（纯粹按需调页）</span><br><span class="line"></span><br><span class="line">一条指令可能导致多次缺页（涉及多个页面）</span><br><span class="line">幸运的是，程序具有局部性（locality of reference）</span><br><span class="line"></span><br><span class="line">请求调页需要硬件支持</span><br><span class="line">带有效无效位的页表</span><br><span class="line">交换空间</span><br><span class="line">指令重启</span><br><span class="line"></span><br><span class="line">缺页率（缺页的概率）：0 &lt;= p &lt;= 1.0</span><br><span class="line">如果 p = 0 ，没有缺页</span><br><span class="line">如果 p = 1， 每次访问都缺页</span><br><span class="line"></span><br><span class="line">有效访问时间（ EAT ）</span><br><span class="line">    EAT = (1 – p) x 内存访问时间+ p x 页错误时间</span><br><span class="line"></span><br><span class="line">页错误时间=处理缺页中断</span><br><span class="line">  + [页交换出去时间 ]</span><br><span class="line">  + 读入页时间</span><br><span class="line">  + 重启进程开销</span><br></pre></td></tr></table></figure>
<p><code>性能优化</code>：<br>页面转换时采用交换空间，而不是文件系统<br>交换区的块大，比文件系统服务快速</p>
<p>在进程装载时，把整个进程拷贝到交换区<br>基于交换区调页<br>早期的 BSD Unix</p>
<p>利用文件系统进行交换<br>Solaris和当前的BSD<br>部分内容仍旧需要交换区（堆栈等）<br><code>写时复制</code>:允许父进程和子进程在初始化时共享页面<br>如果其中一个进程修改了一个共享页面，会产生副本<br>更加高效<br>应用在Windows，Linux，macOS等系统</p>
<h3 id="需要页置换的情况"><a href="#需要页置换的情况" class="headerlink" title="需要页置换的情况"></a>需要页置换的情况</h3><p>页置换—找到内存中当前没有使用的一些页，换出<br>同一个页可能会被装入内存多次<br>基本页置换方法</p>
<ol>
<li>查找所需页在磁盘上的位置</li>
<li>查找一空闲帧<br>如果有空闲帧，就使用它<br>如果没有空闲帧，使用页置换算法选择一个“牺牲”页框<br>将“牺牲”帧的内容写到磁盘上，更新页表和帧表</li>
<li>将所需页读入（新）空闲帧，更新页表和帧表</li>
<li>重启用户进程</li>
</ol>
<p>如果发生页置换，则缺页处理时间加倍<br>使用修改位modify bit或脏 (dirty bit) 来防止页面转移过多—只有被修改的页面才写入磁盘<br>页置换完善了逻辑内存和物理内存的划分—在一个较小的物理内存基础之上可以提供一个大的虚拟内存</p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="先进先出-FIFO-算法"><a href="#先进先出-FIFO-算法" class="headerlink" title="先进先出(FIFO)算法"></a>先进先出(FIFO)算法</h3><p>置换在内存中驻留时间最长的页面<br>容易理解和实现、但性能不总是很好<br>实现：使用FIFO队列管理内存中的所有页<br>FIFO算法可能会产生Belady异常<br>更多的页框 &#x3D;&gt;更多的缺页</p>
<h3 id="最优置换算法OPT"><a href="#最优置换算法OPT" class="headerlink" title="最优置换算法OPT"></a>最优置换算法OPT</h3><p>被置换的页是将来不再需要的或最远的将来才会被使用的页<br>实现？<br>作用：作为一种标准来衡量其它算法的性能</p>
<h3 id="最近最少使用算法-LRU"><a href="#最近最少使用算法-LRU" class="headerlink" title="最近最少使用算法(LRU)"></a>最近最少使用算法(LRU)</h3><p>置换最长时间没有使用的页<br>性能接近OPT<br>实现：计数器（时间戳）或栈<br>开销大、需要硬件支持<br>栈实现—在一个双链表中保留一个记录页数目的栈:<br>被访问的页:<br>移到栈顶<br>需要改变6个指针<br>没有为置换进行查找</p>
<p>在没有硬件支持的系统中，可使用LRU近似算法访问位<br>每个页都与一个位相关联，初始值为0<br>当页访问时设位1</p>
<ul>
<li>附加引用位算法</li>
<li>二次机会算法</li>
<li>增强型二次机会算法</li>
</ul>
<h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>需要访问位<br>如果访问位为0，直接置换<br>如果将要交换的页访问位是1，则:<br>把访问位设位0<br>把页留在内存中<br>以同样的规则，替换下一个页</p>
<p>实现：时钟置换（顺时针方式）</p>
<h3 id="基于计数的页面置换"><a href="#基于计数的页面置换" class="headerlink" title="基于计数的页面置换"></a>基于计数的页面置换</h3><p>用一个计数器记录对每一个页的访问次数<br>LFU 以最小的计数置换一个页</p>
<h3 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h3><ol>
<li>总是保留一个空闲帧缓冲池</li>
</ol>
<ul>
<li>在缺页错误时有帧可用</li>
<li>读页面到空闲帧，无需等待写出牺牲帧</li>
<li>牺牲帧以后被写出后，添加到缓冲池</li>
</ul>
<ol start="2">
<li>扩展之一，维护一个修改页面的列表</li>
</ol>
<ul>
<li>当设备空闲时选择一个修改页面写到磁盘上，然后重置它的修改位</li>
</ul>
<p>3.<br>4. 另一种修改,保留一个空闲帧池，并且记着哪些页面在哪些帧内</p>
<ul>
<li>如果在重用之前被再次需要，就不需要从磁盘上重新装载了</li>
<li>降低因错误选择牺牲页面而引起的开销</li>
</ul>
<h2 id="帧分配"><a href="#帧分配" class="headerlink" title="帧分配"></a>帧分配</h2><p>两种主要分配策略</p>
<ul>
<li>固定分配</li>
<li>优先分配</li>
</ul>
<h3 id="固定分配"><a href="#固定分配" class="headerlink" title="固定分配"></a>固定分配</h3><p>平均分配 Equal allocation– 例如，如果有100帧和5个进程，给每个进程20帧<br>在缓冲池里保存空闲帧<br>比例分配 Proportional allocation – 根据进程大小分配内存<br>按照多道程度而动态分配，进程分得的数量变化</p>
<h3 id="优先级分配"><a href="#优先级分配" class="headerlink" title="优先级分配"></a>优先级分配</h3><p>优先级分配:用优先级而不是大小来进行比例分配<br>如果进程 Pi 跑出页面错误,<br>从自己的帧里选择一个替代<br>从优先级较低的进程里选择一个替代</p>
<h3 id="全局-vs-局部分配"><a href="#全局-vs-局部分配" class="headerlink" title="全局 vs. 局部分配"></a>全局 vs. 局部分配</h3><p>全局置换 Global replacement – 允许进程从所有帧的集合中选择一个置换帧；一个进程可以从另一个进程那里获取帧<br>但是进程执行时间可能变化很大，不能控制缺页错误率<br>有更好的系统吞吐量，更常用<br>局部置换 Local replacement – 每个进程只从它自己分配的帧中进行选择<br>对每个进程的表现更一致<br>但是可能内存低利用</p>
<h4 id="非均匀内存访问（NUMA）"><a href="#非均匀内存访问（NUMA）" class="headerlink" title="非均匀内存访问（NUMA）"></a>非均匀内存访问（NUMA）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v以上假设所有内存可以被平等访问</span><br><span class="line"></span><br><span class="line">v很多系统如 NUMA – 内存访问速度变化的</span><br><span class="line"></span><br><span class="line">考虑CPU和内存在系统中通过总线互连</span><br><span class="line"></span><br><span class="line">v让分配的内存帧‘尽可能地靠近’运行进程的CPU</span><br><span class="line"></span><br><span class="line">通常意味着位于同一系统扳</span><br><span class="line"></span><br><span class="line">Solaris通过在内核中创建延迟组 lgroups</span><br><span class="line"></span><br><span class="line">v将相近的CPU和内存聚集在一起</span><br><span class="line"></span><br><span class="line">v在组内调度进程的所有线程，并分配它的所有内存</span><br><span class="line"></span><br><span class="line">v最大限度减少总体内存延迟，最大化CPU缓存命中率</span><br></pre></td></tr></table></figure>


<h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><p>如果一个进程没有足够的页，那么缺页率将很高，这将导致:<br>CPU利用率低下.<br>操作系统认为需要增加多道程序的道数<br>系统中将加入一个新的进程<br>颠簸（抖动）&#x3D;一个进程的页面经常换入换出<br>原因：分配的帧数 &lt; 局部大小之和</p>
<h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>工作集窗口 º 固定数目的页的引用<br>WSSi (进程Pi的工作集) &#x3D; 最近D中所有页的引用 (随时间变化)<br>![[Pasted image 20230605190700.png]]<br>vExample: D &#x3D; 10,000</p>
<p>每5000个时钟单位时钟中断</p>
<p>为每个页在内存中保留两个位</p>
<p>任何时候一个时钟中断拷贝，把所有访问位设为0</p>
<p>如果一个在内存中的位是0，说明页在工作集</p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>通过映射一个磁盘块成内存的一页，内存映象文件I&#x2F;O 允许文件I&#x2F;O 作为普通内存访问。<br>开始的文件访问按普通请求分页来进行，一页大小的部分文件从文件系统读入物理页。以后文件的读、写操作就按通常的内存访问来处理。<br>由于通过内存的文件操作而不是使用系统调用read() write() ，简化了文件访问和使用。<br>多个进程可以允许将同一文件映射到各自的虚拟内存中，以允许数据共享</p>
<h2 id="内核内存分配"><a href="#内核内存分配" class="headerlink" title="内核内存分配"></a>内核内存分配</h2><p>通常从空闲内存池中获取<br>内核需要为不同大小的数据结构分配内存<br>一些内核内存需要连续的物理页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v内核在使用内存块时有如下特点：</span><br><span class="line"></span><br><span class="line">    (1)内存块的尺寸比较小；</span><br><span class="line"></span><br><span class="line">    (2)占用内存块的时间比较短；</span><br><span class="line"></span><br><span class="line">    (3)要求快速完成分配和回收；</span><br><span class="line"></span><br><span class="line">    (4)不参与交换。</span><br><span class="line"></span><br><span class="line">    (5)频繁使用尺寸相同的内存块，存放同一结构的数据；</span><br><span class="line"></span><br><span class="line">    (6)要求动态分配和回收。</span><br></pre></td></tr></table></figure>
<h3 id="伙伴-Buddy-系统"><a href="#伙伴-Buddy-系统" class="headerlink" title="伙伴(Buddy)系统"></a>伙伴(Buddy)系统</h3><p>v主要用于Linux早期版本中内核底层内存管理<br>v一种经典的内存分配方案<br>v从物理上连续的大小固定的段上分配内存<br>v主要思想：内存按2的幂的大小进行划分，即4KB、8KB等，组成若干空闲块链表；查找链表找到满足进程需求的最佳匹配块<br>满足要求是以2的幂为单位的<br>如果请求不为2的幂，则需要调整到下一个更大的2的幂<br>当分配需求小于现在可用内存时，当前段就分为两个更小的2的幂段，继续上述操作直到合适的段大小<br>&#96;算法<br>首先将整个可用空间看作一块: 2^n<br>假设进程申请的空间大小为s，如果满足<br>2^(n-1)&lt;s&lt;&#x3D;2^n，则分配整个块<br>   否则，将块划分为两个大小相等的伙伴，大小为2^(n-1)<br>一直划分下去直到产生大于或等于s的最小块</p>
<h3 id="Slab-分配"><a href="#Slab-分配" class="headerlink" title="Slab 分配"></a>Slab 分配</h3><p>v内核分配的另一方案<br>vSlab 是由一个或多个物理上连续的页组成<br>vCache 含有一个或多个 slab<br>v每个内核数据结构都有一个cache<br>每个 cache 含有内核数据结构的对象实例</p>
<p>v当创建 cache 时, 包括若干个标记为空闲的对象<br>v当内核对象时，从cache上直接获取，并标识对象为使用<br>v当一个slab充满了已使用的对象时，下一个对象的分配从空的slab开始分配<br>如果没有空的slab, 则从物理连续页上分配新的slab<br>v优点<br>①没有因碎片而引起的内存浪费</p>
<p>②内存请求可以快速满足</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p><code>预调页面 v在进程启动初期，减少大量的缺页中断 v在引用前，调入进程的所有或一些需要的页面 v如果预调入的页面没有被使用，则内存被浪费 </code>页面尺寸大小<br>v碎片 – 需要小的页<br>v表大小 – 需要大的页<br>vI&#x2F;O 开销 – 需要大的页<br>v程序局部 – 需要小的页<br>v缺页次数 – 需要大的页<br>v其他因素<br>没有最佳答案，总的来说，趋向更大的页<br><code>TLB 范围 vTLB 范围 – 通过TLB所访问的内存量 vTLB 范围 = (TLB 大小) X (页大小) v理想情况下，一个进程的工作集应存放在 TLB中 否则会有大量的缺页中断 v增加页的大小 对于不需要大页的应用程序而言，这将导致碎片的增加 v提供多种页的大小 这允许需要大页的应用程序有机会使用大页而不增加碎片的大小 </code>倒置页表<br>v倒置页表降低了保存的物理内存<br>v不再包括进程逻辑地址空间的完整信息<br>v为了提供这种信息，进程必须保留一个外部页表<br>v外部页表可根据需要换进或换出内存<br>&#96;I&#x2F;O 联锁与页面锁定<br>v允许某些页在内存中被锁住</p>
<p>vI&#x2F;O时，正在进行I&#x2F;O的页面不允许被置换算法置换出内存<br><code>linux vSLAB vDemand paging vGlobal page replacement(LRU) v两个帧列：active_list和inactive_list vKswapd daemon 定期检查 </code>windows10<br>vBoth IA-32 and x86-64<br>v32bit支持4GB，64bit支持128TB内存<br>vShared memory, demand paging, copy-on-write, paging和memory compression<br>v按需调页-clustering，预调入3-7页<br>vWorking-Set 管理（最少50-最多345页）</p>
<h2 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h2><p><code>文件 计算机中信息存储的基本组织形式 相关信息结合 具有文件名 </code>文件名<br>按名存取：文件名     存储位置<br>文件名由一串ASCII码或(和)汉字构成<br>名字长度<br>v8.3规则：文件名8个字符，类型3个字符，之间有“.”分割<br>v长文件名：可以最多输入255多个字符作为文件名<br>文件名可能大小写敏感<br><code>文件的打开 v需要数据结构 打开文件表：跟踪打开文件 文件指针:指向最后一次读写的位置，每个进程1个 打开文件计数器：打开文件次数（调用open次数） 文件存储位置：文件存放在存储设备上的位置信息 访问权限：每个进程的访问权限 v优点 方便文件共享 提高文件存取效率 </code>文件锁<br>共享锁 Shared lock 类似于读者锁– 多个进程可以并发获取它。<br>独占锁 Exclusive lock 类似于写者锁<br>&#96;文件结构<br>v目的：便于程序理解文件内容<br>无结构：文字流、字节流等<br>简单记录结构：线性、固定长度、可变长度等<br>复杂结构：格式化文档、多媒体文件等<br>v谁决定了文件结构<br>操作系统<br>程序</p>
<h2 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h2><h3 id="逻辑文件"><a href="#逻辑文件" class="headerlink" title="逻辑文件"></a>逻辑文件</h3><p>v文件呈现在用户面前的组织结构<br>v又称为文件逻辑结构<br>v逻辑文件决定了文件访问方法<br>&#96;文件访问方式</p>
<ul>
<li>顺序访问<br>最简单的访问方式<br>文件信息按照存放顺序，一个记录一个记录地依次访问<br>顺序文件<br>典型存储设备：磁带</li>
<li>直接（随机）访问<br>可以直接定位到文件的某条记录进行访问<br>直接文件<br>典型设备：磁盘<br>v访问方式：直接（随机）访问<br>v直接通过计算得到需要读写记录的位置，直接跳转进行文件读写</li>
<li>索引文件<br>v基本方法：为顺序文件建立索引表<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">记录平均长度：40B   索引表项大小：4B   1M条记录长度：44MB</span><br><span class="line"></span><br><span class="line">访问第1万条记录：</span><br><span class="line"></span><br><span class="line">       1）计算得到第1万条记录的索引项在索引表中首址：10000*4=40000</span><br><span class="line"></span><br><span class="line">       2）从索引表地址40000处读入4个字节，内容为第1万条记录在顺序文件中的首址P</span><br><span class="line"></span><br><span class="line">       3）从顺序文件地址P处读入40个字节（假如第1万条记录长度为40B）</span><br><span class="line"></span><br><span class="line">合计读入：4+40=44B</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="文件控制块（FCB）"><a href="#文件控制块（FCB）" class="headerlink" title="文件控制块（FCB）"></a>文件控制块（FCB）</h3><p>存放操控文件所需的各类文件属性信息<br>文件名<br>长度<br>创建时间<br>存放位置<br>访问控制权限<br>类似一个索引项<br>v目录项<br>存放一个文件的各类属性<br>有的系统等同于文件控制块<br>v目录<br>包含着所有文件信息的节点集合<br>根据文件名检索文件的桥梁<br>目录项的有序集合<br>v目录文件<br>目录组织形式<br>目录作为一个文件存在于文件系统<br>v每个目录项中存放了文件在存储设备的存放地址<br>v目录和文件都驻留在存储设备（如磁盘）</p>
<h3 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h3><p>v文件检索是一个遍历目录项的过程<br>1.打开目录文件<br>2.从磁盘读入该目录文件的1个(物理)块，该块包含若干个目录项<br>3.根据文件名遍历内存中的该块，如找到则结束<br>4.判断该目录文件是否还有物理块没有读入，如果是转2；否则，结束。表示该目录中没有此文件名的文件<br>v目录项由于经常变化，一般不排序<br>v平均遍历目录项数：       （1+n）&#x2F;2<br>  不包括文件查不到的情况<br>  <br>  目录项大小&#x3D; ds bytes<br>目录中最多文件数 &#x3D; n<br>物理块大小 &#x3D; b<br>v那么<br>目录文件大小 &#x3D; ds*n bytes<br>目录文件需要的物理块数目 &#x3D; ds*n&#x2F;b<br>检索一个文件需要平均读入的块数&#x3D;(ds*n&#x2F;b+1)&#x2F;2</p>
<h3 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h3><p><code>设计目标 v效率 快速定位文件位置 提高文件访问效率 v命名 方便用户使用 同名的不同文件 不同名的相同文件 v分组 文件分组（子目录） 兼顾效率和方便性 </code>单层目录<br>v所有文件在同一目录中，只有一级目录：根目录<br>v根目录（&#x2F;）：一个文件系统最顶层的目录<br>v优点：结构简单<br>v缺点<br>检索效率差（目录下文件过多）<br>不能有同名文件，一个文件只能有一个名称<br>不能分组<br><code>双层目录 v每个用户有自己的目录结构 v目录下的目录 v缺点：1）无法分组；2）同一用户不能有相同文件名的文件 v优点：1）不同用户可有相同文件名的文件；2）比单层目录提高检索效率（文件分布在多个用户目录中） </code>树形目录<br>v特点<br>检索高效（子目录增多导致每个目录下文件减少）<br>可以分组<br>允许重名<br>v当前目录：工作目录<br>cd &#x2F;spell&#x2F;mail&#x2F;prog<br>type list<br>v绝对路径<br>从根开始的路径名<br>v相对路径<br>从当前目录开始的路径名<br>提高检索效率<br><code>（有向）无环图目录 v文件共享：不同目录中的文件指向同一个物理文件，也就是它们内容相同 v树型目录不能实现文件共享 v解决方法：图型目录 无环图目录 通用图目录（有环图） v无环图：有向边无环 </code>如何保证无环？<br>仅允许指向文件的链接，不允许指向子目录的链接<br>垃圾回收<br>每当加入新链接时，使用环路检测算法判断是否正确<br>优化遍历目录算法，避免对环的重复搜索</p>
<h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><p>v要访问一个文件系统，必须先安装它。<br>一个未安装的文件系统将被安装在一个安装点(mount point)上。</p>
<h3 id="远程文件系统"><a href="#远程文件系统" class="headerlink" title="远程文件系统"></a>远程文件系统</h3><p>v用网络使得远程计算机之间的联系成为可能<br>手动传输文件如 FTP<br>自动，直接访问文件用分布文件系统 distributed file systems<br>半自动用万维网 world wide web<br>vClient-server 客户机-服务器模型允许客户机登录远程服务器的文件系统<br>服务器可以服务多台客户机<br>识别客户可能是不安全和复杂的<br>NFS 是标准 UNIX 下客户机-服务器的文件共享协议<br>CIFS 是Windows下标准协议<br>标准操作系统文件调用翻译为远程调用<br>v分布式信息系统 (分布式命名服务 distributed naming services) 如LDAP, DNS, NIS。</p>
<h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>v所有文件系统都有故障模式<br>例如目录结构或者其他磁盘管理信息（元数据 metadata 损坏。<br>v远程文件系统加入新的故障模式，来自网络故障或者服务器故障<br>v从故障中恢复包含维护状态信息 state information<br>vStateless 无状态协议如NFC在每个请求里包含所有信息，允许较为容易的故障恢复但是不够安全</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>v规定系统的多个用户如何访问共享文件<br>类似于第六章的进程同步算法<br>v由于磁盘和网络的巨大延迟和很慢的传输速率，倾向于没这么复杂<br>Andrew File System (AFS) 实现了复杂共享语义<br>Unix file system (UFS) 使用:<br>v一个用户对已打开文件的写入，对于打开同一文件的其他用户立即可见。<br>v一种共享模式允许用户共享文件的当前位置指针。<br>AFS 有会话语义<br>v一旦文件关闭，对其所作的更改只能被后来打开的会话可见。</p>
<h3 id="访问控制权限和分组"><a href="#访问控制权限和分组" class="headerlink" title="访问控制权限和分组"></a>访问控制权限和分组</h3><p>v访问模式：读&#x2F;写&#x2F;执行<br>v三种类型的用户<br>  RWX<br>  a) 所有者  7  &#x3D;&gt;1 1 1    RWX<br>  b) 组用户  6  &#x3D;&gt;  1 1 0    RWX<br>  c) 公共用户  1  &#x3D;&gt;  0 0 1<br>v建立一个组，加入一些用户<br>v对特定的文件或目录(game) ，定义适当的访问权限</p>
]]></content>
      <tags>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls剧情解析</title>
    <url>/2023/09/17/black%20souls%E5%89%A7%E6%83%85%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="冬之钟"><a href="#冬之钟" class="headerlink" title="冬之钟"></a>冬之钟</h1><p>由于black souls的故事远远没有完结，因此现阶段我们很难对红白女王与梅贝尔这些与格林牵扯极深的支配者们进行什么定论，只能就已有的剧情和文本进行一些归纳，本期视频我将就bs2比较难懂的一处地方，冬之钟的主线事件，进行一些个人向的分析。<br>在冬之钟最后一章地图能遇到5个白熊，白熊的身份迄今为止依然是谜团，但他们提供了整整五段发生在支配者之间的重要对话，我将概括一下这五段对话提供的主要信息以便进一步的分析<br>我们按解包后的地图顺序开始，<br>第一段对话发生于梅贝尔和妹妹爱丽丝之间，可以猜测妹妹爱丽丝属于支配者之一，数量众多的支配者都在奈亚的箱庭占据一个角色以便和格林繁殖，但随着时间推移，支配者们发现扮演角色的同时，他们也在被角色同化（梅贝尔所言），因此纷纷退场，妹妹爱丽丝也逐渐被角色影响对格林产生好感，此外，姐姐爱丽丝不知何故地退场。<br>第二场对话发生于梅贝尔和白之女王之间，对话中提及冬之钟正是白女王的箱庭，而白之女王由于爱上了格林自愿放弃女王的身份去守护他，而梅贝尔则对这场追寻爱的闹剧，以及陪着胡闹的其他支配者感到无聊，向白女王提出一个让格林摆脱循环，并且能够独占他的计划。<br>第三第四场对话都发生于红白女王之间，红女王为陷入痛苦轮回的格林而痛苦，不断进行自残，白女王制止了她，两人由于同样爱上格林而心意相通<br>第四场对话则告诉我们，红女王接过了白女王的权王冠（推测为箱庭权限），并以此创造出库因兰德，并使其能排除奈亚的监视，两人密谋让格林挣脱循环的方法，红女王恳请白女王放弃对格林的独占欲，白女王同意了，此外，梅贝尔也知晓这一计划，并根据后面的行动来看，她不知为何也参与了这个计划<br>第五场对话发生于白女王和玛丽苏之间，白女王夺走了玛丽苏的改变能力，并且根据混沌迷宫的情报，将其赋予了古兰剧场，玛丽苏察觉白女王爱上了格林，并且等待着格林的到来，结尾，玛丽苏等到了一个神秘人（黑山羊？）<br>总结这些信息，我们可以推测出针对格林，一共提出了两个计划，一个是梅贝尔怂恿的独占计划，一个是红偶像策划的拯救计划，这两个计划都必须有诺登的参与，但此时我们并不知道诺登的真正想法是哪个<br>在推进h结局的过程后，格林会有两个选择，1是和暗黑舞台合二为一2是打败舞台，夺取舞台的改变能力， “此时”的冬之钟虽然沉睡，但相信诺登依旧有一定的控制能力，然而不同于G结局的阻拦，此时的诺登选择了旁观，并在最后支持格林任意一个选择<br>总结一下大致发生的事件（以下事件的时间顺序难以具体确定）<br>1诺登作为支配者之一管理着自己的箱庭冬之钟，和奈亚创造自己箱庭的时间关系未知<br>2奈亚将格林带到箱庭，邀请支配者们参加繁殖游戏，根据牛津学院人偶爱丽丝的说法，是舞台装置创造出了让格林在舞台上登场的皮套（格林的灵魂出自玛丽苏的手笔，因此推测只能创造皮套），并且在创造格林时两者间确立了深远的联系，白女王也参加了这个游戏，可以肯定白女王为了心爱的格林才舍弃了王冠（王冠可能指代管理箱庭的权能），因此推测白女王在爱上格林后可能以放弃王冠为代价，得到了管理奈亚箱庭的权限和陪伴在格林身边的权力<br>3红偶像被奈亚切割，由于茶会时期她曾经打倒初代红之女王，因此此刻可以说她的身份是第二任红之女王，为格林自责的她不断紫餐，得到了白女王的同情，白女王将自己原来的王冠权能移交给被奈亚切割的红女王，让她在原冬之钟的地盘上创造出自己的箱庭。<br>4红白女王合谋，或者其中之一从奈亚手中夺走了玛丽苏并囚禁起来，为了避免红白女王相互猜疑，二者将从玛丽苏手上得到的改变能力赋予舞台装置古兰，创造出一个新的支配者暗黑舞台，藏于处于过去时间线的冬之钟，同时由于处于过去的时间线，冬之钟几乎没有被发现的风险，通过dlc3经常出现的齿轮与其他信息可以推测，舞台装置拥有着影响整个箱庭以及舞台上大部分“演员”的能力，即在部分地图的bg和格林脑中的“齿轮声”，是不思议之国这场戏的核心，此外，由于诺登为了管理这个箱庭必须借助舞台的力量，而红白女王理论上权能接近，因此本视频中猜测红白女王都有部分操控舞台的权限<br>4由于支配者们发现扮演箱庭的角色会改变自己的本质，因此纷纷退出，白女王被迫用自己和格林的子嗣填补空缺<br>5梅贝尔认为这场游戏无聊透顶，一场剧本烂透的戏剧重复多少遍也只会让人厌倦（她自己是这么说的），因此她怂恿白女王让格林脱出循环，并抢先独占他<br>6红女王努力让自己的领域能排除奈亚的监视，并在此向白女王提出了拯救格林的计划，这个计划梅贝尔也知情，白女王同意了拯救计划，我们不知道白女王听到这两个计划的顺序，但他们明显是冲突的<br>7可能是人为，可能是自发，舞台觉醒了自我意识呼唤着格林的爱，同时在梅贝尔的指引下格林也朝着舞台进发，一场死斗在所难免，可以推测，在夺取舞台能力的结局中，诺登执行了红女王的拯救计划，舍身为格林断后，使其在爱丽丝01，即现在的红偶像的帮助下回到现实。在舞台与格林合一的bad end中，诺登执行了梅贝尔提出的独占计划，该结局中诺登辅佐着通过合体得到创作能力的格林与奈亚进行斗争，并且前往世界尽头来逃避一切纷争和毁灭，顺便一提，我觉得这结局也不算坏，白女王很可能会确保格林在融合中占据主导，此时格林成为了名副其实的支配者，和白女王的结合甚至能和奈亚势均力敌，不过寿司在采访中提到执着于爱丽丝身份的奈亚无法发挥全力就是了，毫无疑问这时的格林是目前为止的（格林）战力巅峰。<br>这就是冬之钟里发生的主要事件了，下面我将对事件的主要参与者，红白女王和虚无的少女进行分析。<br>首先是参与程度较低的梅贝尔，梅贝尔虽然入局较浅，但却是格林的引导者，并帮助拖延了一下奈亚，也是她告诉我们打破这一循环只能正面和舞台装置对决，那么她的目的是什么呢？<br>首先，梅贝尔在混沌迷宫中会直接提及支配者间不可避免将爆发战争，并且导致阿撒托斯的苏醒毁灭一切，而身份不是支配者却可能得到支配者之器的格林，才能发动不会惊醒阿撒托斯的箱庭战争，这可能是她帮助格林的首要目的<br>其次，梅贝尔是个不可救药的收藏狂，她的箱庭是个巨大的垃圾场，什么都有，因此她也想把格林培养成一个完美收藏品或者棋子<br>最后，在个人感情上，很难定论梅贝尔到底产生了多少感情，她自称对永无止境的劣质戏剧循环感到厌倦，才会帮助格林创造自己的故事，但又在背叛剧情中声称想要让格林得到更高的器随后利用他，最后如果试图救她又会说自己涌现出了一些对格林的爱，由于信息过少，很难知道她到底觉醒了多少感情。<br>不过可以肯定的是，如果是梅贝尔真有意背叛动机是不充分的，如果她只需要格林成为拥有支配者之器的棋子，那么独占和拯救计划都能实现这个目的，并且由于白女王看着，融合后大概率是格林占主导地位，无非是好不好操控的问题，因此猜测梅贝尔实际上是真心帮助格林，只是在用激将法，或者习惯性毒舌。<br>冬之钟的棋局不管怎么走梅贝尔都不是输家，如果独占计划成功，白女王和格林则会成为一股对抗奈亚甚至其他支配者的强大力量，如果拯救计划成功，格林则会成为一个有着支配者的器，却对大部分支配者恨之入骨的棋子或潜在盟友，不论哪个结果都对梅贝尔阻止阿撒托斯苏醒的目的有利，而她的损失不过是万千分身中的一个而已<br>随后则是红之女王，尽管游戏中没有直接说红女王就是一代的爱丽丝01，以及茶会中的爱丽丝，但大量证据表明她和爱丽丝01有着千丝万缕的关系，爱丽丝01也极有可能就是茶会爱丽丝，所以本视频采纳这一说法，可以说最早钻进人类皮套的她是人性化最深的支配者，她人类的一面深爱格林，但又恐惧支配者的一面暴露，因此自觉配不上格林，甚至认为是自己导致了格林的一切悲剧，顺便一提关于茶会以及更早时期的资料实在太少，所以我们现在对这段剧情的讨论很可能是不完整甚至有较大误解的，因此在此我只能尽可能保守地做一些推测，由于支配者本性难以剥离，在她身上有着强烈的自毁倾向，想爱，却又自觉没有资格去爱，因此她只能用紫餐的方式填补内心的负罪感，H结局中，她以几乎自杀的方式当着奈亚的面帮助格林逃离了奈亚的掌控，可以说为了格林，红女王自降身份把自己变成了棋子，而且是必死的棋子，只为了能在后续将奈亚一军。<br>等待着这个叛徒的是什么结局，我们只能发挥一下想象力了<br>最后则是冬之钟的核心人物，白之女王诺登，诺登的原型之一是爱丽丝梦游仙境的白兔先生，白兔最明显的元素就是他永远匆忙的样子和怀表，这点也在诺登身上得以体现，白女王作为这场繁殖游戏事实上的管理者，为了协调任性的演员们可谓操碎了心，在轮回的最后，台上的演员几乎全部是她的子嗣（兔子可是繁殖力非常强的生物），可以猜测在制定剧本和排练上她也得下不少功夫，而dlc3的核心意象，齿轮，其实可以说既指着暗黑舞台的齿轮带动了戏码的上演，也指着诺登怀表的齿轮，诺登就是那个负责在指针快点到达终点前让齿轮倒转，重新开始计时的人，这也是为何她会在结局中说为齿轮停止感到害怕，让齿轮转动是她的职责，在她的内心深处或许也有着对无尽循环中格林真正爱上自己并一起逃到世界尽头的希望，但最后她选择成全格林真正的爱，而放弃管理齿轮的职责则意味着她与自己支配者的身份完全决裂，将一切奉献给人类的爱。此外，诺登的支配者原型则是所谓的幻梦境之主，这或许解释了为何是她在实际上管理着二代这个巨大的梦境<br>我在尸龙的人物解析说，类似尸龙的独占欲在红白女王身上也出现过，但红女王由于害怕自己的支配者本性选择放手，那么白女王呢？在h结局中，梅贝尔被古兰（推测，也可能是奈亚）针对性的陷阱解决，但拥有舞台权限的红白女王应该不受影响，红女王为了最后拯救格林必须蛰伏，因此辅助格林对抗古兰以及奈亚的任务只能交给白女王，但即使在此时此刻，白女王依旧有着独占格林的选项，如果她控制或者协助舞台装置强迫和格林融合，就可以抢先一步独占所有支配者都垂涎的格林，但如果把舞台的改变能力给予格林，那么失去王冠和舞台的诺登则会失去自己在棋局上的几乎所有棋子，面对这种选择，诺登将选择权给了格林，不能说她是完全无私的，但面对这样的诱惑，她也会尊重格林的选择，这不得不说是非常伟大的爱<br>可以说白女王是一个有着两面性的角色，她支配者的一面始终对格林有着独占欲，但她人性的一面始终压抑着这些黑暗的感情，她是一个徘徊于人与神界限的存在，但无论如何，她都尊重并支持着格林的选择，所以她闪耀着人性光辉的一面始终是压过支配者的黑暗一面的。<br>让我们给这幕疯狂剧场的落幕做一个总结吧，这局棋是红白女王和梅贝尔设下的，目的是为了让格林得到古兰的改变能力并逃离奈亚的箱庭，其中没有舞台权限的梅贝尔负责引导格林，红女王则在最后帮助得到改变能力的格林摆脱奈亚掌控，而白女王则有着最关键的决策权，即是否利用舞台独占格林，但她最后将决定权给了格林，而格林真正的选择应该是夺取舞台的改变能力，因此最后白女王舍弃了一切帮助格林逃离崩坏的舞台。<br>这场棋局中，梅贝尔横竖不亏，红女王陷入必死之局，最关键的棋手就是白女王，只要她愿意，随时可以下出必赢的一着，但最后她依旧选择了放弃自己的棋子，把终结棋局的希望留给了格林<br>在经历如此多的牺牲之后，格林终于从棋子升为了棋手，只是不知道他又会下出怎样的一着</p>
]]></content>
      <tags>
        <tag>游戏杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls人物解析</title>
    <url>/2023/09/17/black%20souls%E4%BA%BA%E7%89%A9%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="尸龙贾巴沃克"><a href="#尸龙贾巴沃克" class="headerlink" title="尸龙贾巴沃克"></a>尸龙贾巴沃克</h1><p>象征着腐败与神秘的紫黑色，遍布全身的缝合痕迹与绷带，恶魔一样的卷曲角，晦暗如死尸的肤色，以及左眼燃烧着的灵魂之火（致敬黑岩射手可能性微存），尸龙姐姐的人物形象无时无刻不在传达着神秘强大而阴暗的气氛，本视频将对尸龙的整个人物进行解析<br>尸龙在爱丽丝镜中奇遇的原型是一首小诗，这首诗的大意是勇者手提沃伯尔之剑斩杀邪龙贾巴沃克，游戏中也承袭了这一设定，贾巴沃克一直都以死尸的形象登场<br>要解析这一角色，我们首先从最直接的行为说起，按游戏的时间线，尸龙姐姐大概做了以下这些事<br>1把童话（具体哪本未知，根据混沌迷宫的狼外婆信息推测可能是小红帽）给了渴望母爱的玛丽.苏，从而激发了虫虫的创作能力，导致她创造出一代的箱庭。顺便一提，关于尸龙和玛丽苏的关系，游戏里没有直接证据支持姐妹说，混沌迷宫提到黑山羊有两个子嗣，米兰达认为尸龙有黑山羊的气息，且明显尸龙和玛丽苏有一定关系，这些是确定的，但并未明说姐妹，有人从克苏鲁的设定中寻找论据，但本人对克系了解不多在此不评价。<br>2红偶像约会中电影《三人的茶会》提及茶会时期的三人曾经打倒过贾巴沃奇，不知是否和尸龙有关，此外尸龙也曾被昔日的勇者，如今的猎头兔打倒，自称在之后洗心革面，但相关资料太少，我们不知道是不是她放水或另有隐情<br>3格林被引导进玛丽苏的箱庭开始一代的故事，此时尸龙（不知道玛丽苏是否知情）已经乱入到一代的不思议之国，为格林一行人提供帮助，通关d结局后找她对话，她会直接把二代给剧透了，不过由于时间线上d结局应该直接接上二代，所以“正史”上可能没有这件事，顺便一提，一代的不思议之国是爱丽丝的箱庭，或者说玛丽苏的仿造品，也没有定论，所以很难推测尸龙是入侵还是本来就在那里<br>4来到二代时间线，由于不思议之国是奈亚的箱庭，而黑山羊则是奈亚的“配偶”，所以尸龙出现在这倒是理所应当，此时的尸龙以四噩梦之一的身份登场，，但工作内容则是在卡罗尔川上堆雪人，以及在格林面前装出温柔大姐姐的形象，十足的关系户做派。<br>里路线中，格林和米兰达等人可以先后对战三噩梦，以及杀死其余两个噩梦后现出真身的尸龙，值得一提的是这似乎是她全系列中唯一一次全力出手，并且在此战中死亡，但考虑到支配者的特性，是否死透了依旧存疑<br>以上就是尸龙在系列中的行动，接下来我将对这些行动的目的与尸龙的性格进行归纳。<br>尸龙首先是一个安静的观察者，一代中她只是在一棵树下扮尸体，二代则在河边堆雪人，如果格林不找她，在里线之前不会和她有任何交集，然而，隐藏和善表面下的真相是尸龙其实是个性格扭曲唯恐天下不乱的乐子人，是她启发了玛丽苏创造自己的黑童话箱庭，间接引发之后所有的故事，而一开始的目的可能只是以玛丽苏面对求而不得的母爱痛苦挣扎的样子为乐，也是她诅咒了狩猎邪龙的英雄，使兔子一族成为贪食尸体的魔兽，其中被沃波尔斩下头颅可能是她行事风格的分界线，其自述死前曾是无恶不作的邪龙，在复活后变得收敛，但其实依旧不改邪龙本质，只是变得只在关键时刻推波助澜<br>而将这两种性格统一起来的则是她的创作欲，没错，和玛丽苏一样，尸龙对创作也有自己的执念，在玛丽苏涌现起黑暗的创作力之后，尸龙意识到，玛丽苏那邪恶的灵魂一定程度其实是自己的作品，如果说玛丽苏是支配者中第一个创造故事的人，尸龙就是第一个“创作者”，这激发出她内心最深层的欲望，那就是创作出足够黑暗污秽的灵魂，方法则是让一个灵魂在无尽的痛苦与求而不得中循环。<br>可以说在这点上尸龙和奈亚有一定的共同点，就是让格林经历无数次的痛苦循环，但二者还是有着分歧，奈亚想要的是格林求而不得的爱，尸龙则想要格林本就污秽的灵魂更加黑暗。<br>这时我们就可以理解尸龙的行为了，由于里线实际上也处于轮回之中，所以对尸龙来说，告诉格林一些真相只会让他的反抗更加激烈，也会在反抗之后更加绝望，这样才符合她的目的。<br>而以上依旧是贾巴沃克的表层性格，而她隐藏最深的性格则是扭曲的独占欲，在卡罗尔川的地牢中有个四个雪人，分别是玛丽苏，小红帽，爱丽丝和格林，此外，班达斯奈奇的住处也有着一个写着想将其变为收藏品的雪人（sen0才能看到真相），可见尸龙内心最深的欲望其实是独占欲，培育最污秽的灵魂，随后将其收藏起来，这才是尸龙的愿景，但她为何要隐藏这一欲望呢，在qf尸龙失败的逆监禁剧情里，由于尸龙发现格林的灵魂已经黑暗到想要独占自己，尸龙就会唯一一次直接暴露自己的独占欲来收割这个丰硕的成果，然而，奈亚或者其他支配者绝不会容忍这种行为，所以一旦尸龙试图独占格林就会立刻被排除出世界，这就是尸龙一直压抑着独占欲的原因。<br>此外，根据dlc3入口处的对话以及数量庞大的雪人，或许可以猜测尸龙曾经一边观察一边玩弄过很多灵魂，但这些灵魂最后都因为经历过多的痛苦和绝望后变得麻木，因此才会对有着无穷成长性的格林视若珍宝<br>一切温柔的言语都不过是为了将格林引导向更绝望的结局，独占污秽的黑之魂，玩到腻后就扔掉，对贾巴沃克之魂的描述为包藏在虚伪的母性之下的独占欲之影可谓恰如其分。<br>值得一提的是，独占欲这种感情不止在尸龙一人上出现，大部分支配者都有着这种感情，如白之女王诺登就承认自己多次有独占格林的想法，爱丽丝01也曾吐露自己害怕不可控制地想要独占格林，但她们与尸龙的区别则是，她们能够理解人类的爱，并为了人类的幸福选择放手，与红白女王的对比或许也是尸龙人物形象设计的一个目的<br>现在可以做一个总结了，尸龙姐姐是一个对格林有着强烈爱意的角色，她的母性是虚伪的，但这种爱意却不是，尽管她扭曲，残酷，自私，虚伪，但是她始终知道自己要做什么并理性地付出行动，即使失败了也不失风度从容自若，相较于虫虫几乎写在脸上的扭曲性格，直截了当的作恶行径，以及一有挫败就大呼小叫的行径，尸龙的感情更加内敛，行事也更加隐秘，但可谓是个很有恶人魅力的反派角色<br>同时，由于bs的碎片化叙事并且尚未完结，关于尸龙依旧有很多谜团，例如她和玛丽苏以及其他支配者的具体关系，里线中她是不是仍然在演戏，她究竟为何会给玛丽苏童话书，尸龙等三噩梦和三个爱丽丝的关系等等，就期待续作的解答了<br>大家都来和尸龙姐姐做朋友吧，尸门</p>
<h1 id="玛丽苏"><a href="#玛丽苏" class="headerlink" title="玛丽苏"></a>玛丽苏</h1><p>玛丽苏，作为bs中自称的女主角，是bs唯二个三代都有出场（包括红森）的支配者，还有一个是贾巴沃克），在此过程中做过的好事可谓数不胜数，罄竹难书，我们来按着时间线整理一下<br>1一开始的玛丽苏是个渴望母爱的孩子，尽管我们不知道bs设定下一开始的支配者到底会不会有类似人类的亲情，她掌管自己的世界，倾听子民的祈祷，开始感到厌烦，这时贾巴沃克不知出于什么目的，送了她一本童话书，这本书，我们不知道是哪个童话，但本人猜测很可能这本书的作者是玛丽苏第一个抓住的，并在黑之魂的融合中有重要地位，根据青鸟的文本，卡罗尔并不是第一个抓住的素材，所以基本可以排除梦游仙境，结合男主角格林的名字和混沌迷宫的狼外婆，我个人猜测是小红帽，她开始渴望创作自己的故事来打动母亲，至少一开始是这样，她派遣属下四处收集童话作者的灵魂作为素材，同时肆意进行同人创作。<br>2玛丽苏的处女作是小红帽，也是她第二得意的作品，根据一些信息，小红帽的灵魂可能以现实世界的一个女学生为素材，在魔改剧情的同时，她还给了小红帽注定20岁早逝的设定，并可能赋予了小红帽通过镜子穿梭位面之类的特殊能力来担任女主角，但不知道为什么她又不满意，想做一个男主角出来，但她对小红帽的善后却颇有些问题，小红帽不仅杀穿了红森，而且还能意识到她这个黑幕的存在。<br>3缝合了众多童话作家灵魂的格林诞生了，并被赋予了给周围的女主角带来不幸的设定，格林污秽的黑之魂有成为支配者的潜质，玛丽苏甚至还大胆地保留了他的部分创作能力，因为最关键的改变权能在她手上，为什么叫做格林则未知，可能是最初的童话书就是格林童话的一本，这之后格林不知道为什么，以什么身份在一个叫不思议之国的地方和叫爱丽丝和祈祷主的存在开起了茶会，随后格林与爱丽丝01相恋，嫉妒的祈祷主呼唤了玛丽苏，导致格林被带走了，连同格林不知何时创造出的故事们也被篡改<br>4基于以上提到的各种童话故事素材，玛丽苏魔改出了失落帝国的箱庭，把格林放进去经历一次次绝望故事的轮回，自己则担任女主角欣赏故事，还设计把母亲叫了进来欣赏自己的大作。不知多少次循环后，这个大好局面被打破了，母亲黑山羊为了逃离这个世界和她战斗，连圣森都磨灭了，战胜母亲后，奈亚丽丝前来捡漏带走格林进行新一轮追寻爱的游戏，本来想顺带着把玛丽苏也灭了，但在诺登的劝阻以及可能的其他考量下放过了她<br>5奈亚，红女王，白女王中的某位或若干位剥夺了她的改变权能，把她囚禁在库因兰德，失去权能的她改名为玛丽安，但不知何时也不知何人前来探访了她，到格林试图从梦中醒来的里线，玛丽安乘乱逃出，由于正史上不太可能发生f结局，所以此时应该是g结局，也有可能正史上g结局有少许与游戏不同，不管怎么说此时的玛丽安应该被格林小红帽两人打败，但h结局中可以看到她没有死，而且不知道怎么逃了出来<br>可以说，bs中的一切悲剧，玛丽苏至少有五成功劳，接下来让我们来分析一下玛丽苏的角色特质。<br>首先，最直接的一点，玛丽苏是个典型的支配者，高高在上地支配着人类这样的低等种族，但玛丽苏特殊之处在于，她可能是最能理解人类感情的支配者之一，首先我们就可以看到她居然渴望所谓的母爱，而根据2代大部分支配者的表现，即使因融入皮套逐渐有了感情，也没有第二个有亲情这种非常类似人类感情的支配者，此外，她还以玩弄人类的灵魂为乐，当然有这种兴趣的支配者恐怕不少，但这股风气可以说是玛丽苏带起来的，也是她最先玩出各种花样。<br>因此可以引出玛丽苏的第二个特点了，她是很像人类的一个支配者，尽管理解非常片面，但她确实懂得并拥有不少人性，而她为什么这么喜欢玩弄人类呢？这也很容易理解，一般来说越通人性的动物越被人类亲近，逗猫逗狗远远比逗蚂蚁有意思，因为这些宠物的智力和人类更接近，人类可以很容易地理解它们在想什么，然后在逗弄它们的过程中获得一种智力上的优越感，以及一种“支配感”，这恐怕就是玛丽苏看到自己编排的好戏上演的感觉。<br>这点可以说是我们对玛丽苏进行解析的基石，毕竟任何角色首先都是人的投影，而人性越丰富，就有越多的性格侧面。<br>玛丽苏第三个特点就是由此衍生的纯粹性，当然，此处并不是说纯洁善良云云，而是某种意义上的纯粹之恶，很多支配者在扮演人类后都会被皮套影响而恐慌或纠结，但玛丽苏却没有这种烦恼，她以融入人类扮演人类为乐（小精灵也算类人种族），她作为支配者的漆黑本性和人性之恶完美地兼容了，不会有徘徊二者之间的身份认同问题，而她大部分所作所为也就是为了践行人性之恶，什么是恶呢，比较狭隘的解释就是为了为了自己的利益或者取乐而伤害他人，而玛丽苏的邪恶就很纯粹，就是为了取乐，甚至有损自己利益也要作恶，如果解救了被囚禁的玛丽苏，此时她会自认为东山再起，但她想的不是第一时间抹杀已经成长了的格林或者藏起来，而是想再让格林经历一次悲惨的故事，可以说她作恶的动机相当纯粹，也相当执着。<br>在此之上的第四个特点，就是她的创作者身份，很多支配者都会赞扬她的创作能力，连奈亚构建的不思议之国都有不少玛丽苏箱庭的影子，但这种创造力也只是对于支配者来说了，如果我们用人类的视角看如何呢？寿司在访谈时轻蔑地说到“她说到底也只是玛丽苏，也只能整点二次创作了”可以说道出了玛丽苏所谓创作的本质，说到底，玛丽苏就是那种典型的黑深残小鬼，把一个可能有很多种解释的作品曲解为单一的猎奇世界观，当然不是说这样不行，如果原创一个黑深残世界观自娱自乐当然是可以接受的，但玛丽苏的行为就是最恶劣的一种同人女行为，魔改原来的作品，把自己做成角色代入进去搞cp，还要把所有其他角色踩一遍，情节和人物关系只要对自己代入的角色有利就行，然后把这部除了自己看谁也不会喜欢的同人拿给原作者看，我就不详细说这种行为的恶劣程度了，但这种作品折射出来的创作观我必须要辩驳一下。<br>当然，本视频所有讨论只局限于二次元文化内，<br>荒木飞吕彦认为漫画有四要素，角色、剧情、世界观、主题，我们就用这四个维度来剖析玛丽苏的所谓创作。<br>首先是角色，直接创作一个鲜活的灵魂对强大的支配者来说也是一件难事，所以对于角色的选取，玛丽苏很可能都是使用现实存在的灵魂然后再魔改来适配进童话或者传说的人物，因此她笔下所谓角色虽然很多但其实并不是她自己的功劳，而她为了把这些灵魂塞进角色对设定随意删改，把小红帽的外婆和母亲缝成了一笔烂账，人物关系更是一团乱麻，怎么方便怎么来，角色设定连基本的自洽也做不到，水平着实不敢恭维<br>随后是世界观，失落帝国这个箱庭本质上来说就是个童话故事的缝合体，没有历史演化，没有详细设定，这并不是一个鲜活的世界观，只不过是一个临时搭建的舞台而已，当然，很多线性的故事并不需要一个多详尽的世界观，在这点上玛丽苏只能说无功无过<br>最后是剧情和主题，玛丽苏的主题是简单粗暴的黑深残，剧情则是当常规的rpg剧本演到最后的happy end时毫无铺垫伏笔地急转直下变成bad end，当然，能设置这么大规模的箱庭，还写了不少支线剧情，证明玛丽苏确实是有一些笔力的，但首先，她的角色基本靠抓人，故事则都有童话原型，故事演变她只需要把握大方向，其他可以让角色自己来，而最后没有任何铺垫的bad end依旧表明了她创作的失败，如果一个设定没有任何铺垫和暗示，直到使用时才抛出，那只能证明这部作品情节编排的失败，因为一部作品的生命周期不是作者创作出来就结束了的，而要等到读者看完理解了故事才会结束，这个过程作者读者应该处于相对公平的地位，根据故事的设定，人物有充分的理由这样行动，这样才能让读者认同这个故事，而玛丽苏却完全相反，滥用作者的权能让故事不仅没有逻辑，还自相矛盾，很明显，对玛丽苏来说她是作者也自认为是唯一的读者，那些被抓走被改造的灵魂不过是用完即扔的工具罢了，不需要自圆其说，只要自己看得高兴就行了，或许就支配者的立场来说她不过是自娱自乐罢了，但对人类（至少灵魂上是人类），以及同样作为创作者的格林来说，首先就绝不可能认同这种恶行，更不可能认同自己的作品被改成这样的烂作<br>说到这里，就可以讨论一下玛丽苏对于格林的看法了，直观地说，是玛丽苏创造了名为格林的污秽黑之魂，但其实在最初，是格林等童话作家激发了玛丽苏的创作欲，因此，事实上，两者是相互创造的关系，玛丽苏创造格林的目的，首先是为了成为她作品的男主角，让她能够代入女主角的位置欣赏这个故事，这样说来似乎格林除了男主角的身份和其他角色也没什么本质的不同。但格林还有一点对玛丽苏有着重大意义，就是他童话作家灵魂集合体的身份，即使自我中心如玛丽苏这种存在，也会有对别人欣赏自己作品的渴望，因此玛丽苏特地设置了一个c结局，用演戏的形式让格林得以了解她的整个创作生涯，至于目的，除了单纯的表现欲和欣赏格林的痛苦以外，恐怕也有一丝希望作为原作者的格林认同自己的心情，哪怕是厌恶，玛丽苏也想得到一些对创作的反馈，而格林是唯一能在创作这个领域和她有一些共鸣的人，作者，读者，男主角，格林三位一体的身份对玛丽苏来说，可以说是难得的知己，尽管这种关系非常扭曲，但不能否认，在这点上玛丽苏作为创作者的心情是有些真心的。而玛丽苏会渴望认同这点，一开始是希望得到母爱，但在得到格林这个玩具之后，玛丽苏就一点也不在意黑山羊的死活了，这也是佐证。<br>最后不得不提的是，玛丽苏的特殊性质，很大程度上她是寿司这个作者的投影，我个人觉得玛丽苏这个角色有不少表达寿司自己创作观的成分，这也解释了寿司为何这么偏爱她当然，一部好的作品，任何角色都是基于自己的设定和世界观行动，不可能因为是作者的投影就有特别待遇，所以可以说，玛丽苏虽然很大程度上是寿司的投影，但投影的目的其实是对比，玛丽苏的创作肤浅，笔下的故事只是无聊的黑深残，但寿司却喜欢在绝望时写一些希望，在希望中铺设绝望，最后的反转再怎么说都是有因可循，单论创作的层次来说就高出绿虫子太多了，当然，我也不是在吹寿司笔力多高，因为高出玛丽苏这个水平的创作者多如牛毛。<br>寿司设置玛丽苏这个角色，其实是使用了一种嵌套的结构来讲故事，首层是童话的原作，这些是毋庸置疑的好故事，随后是虫子和奈亚魔改出的箱庭，是烂故事的典型，最后一层寿司想讲的重点其实是格林怎么察觉真相，挣脱出烂故事的循环，书写自己的结局的故事，在这三层中，第一层玛丽苏是读者，格林等人是作者，只出现在设定层面，第二层玛丽苏是一半作者一半角色，格林是一半读者一半角色，体现在abc结局，最后一层中寿司是唯一的作者，玛丽苏和格林就都是角色了，体现在d结局以及之后的二代，这种层层演变虽然有些炫技，但确实非常有意思。<br>就玛丽苏这个角色而言，整个泛二次元文化里她这样的反派也不常见，究其原因，则是因为一个有能力玩弄主角取乐的boss必然会导致战力失衡，冲突不起来，让读者感到憋屈，因此想要打败这种boss要么机械降神唯心爆发，比如一代c结局（虽然是演的），要么引入新的boss和同伴体系取代她如d结局，也因此，虽然我个人很喜欢一代，但一代的真结局d结局远没有2代h结局震撼<br>来做个总结吧，玛丽苏无疑是个纯粹邪恶的支配者，一个烂到骨子里的创作者，她作为创作者无疑是失败的，但作为bs这个故事里的角色反而是很成功的，不仅纯粹有特点，还有很多角色侧面可以挖掘，寿司巧妙地利用她读者，创作者和角色的三重身份来塑造她的多面性，颇有荒木在漫画术中写的“在作恶道路上高歌猛进”的成功反派角色风格。</p>
]]></content>
      <tags>
        <tag>游戏杂谈</tag>
      </tags>
  </entry>
</search>
