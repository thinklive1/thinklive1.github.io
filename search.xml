<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>thinklive的迪瑞克拉图书馆</title>
    <url>/thinklive/3852/</url>
    <content><![CDATA[<video src="/images/thinklive.mp4" autoplay>
</video>
<h1 id="欢迎来到迪瑞克拉">欢迎来到迪瑞克拉</h1>
<p>这里是thinklive的个人博客，不定时地会发一些个人技术学习心得和生活体会,申请友链可邮件联系<br />
使用左侧的分类来定位内容<br />
为了响应环保号召，并且给你的电脑省点电，推荐<strong>禁止浏览器的js功能</strong>，例如firefox浏览器可下载<code>disable javascript</code>插件禁用js<br />
这意味着该网站的动态功能全部瘫痪，包括背景动效，加密页面，左侧的时钟，游戏等页面，但浏览普通博文的功能保持正常<br />
可以通过左下角的"🌓"按钮切换白天/黑夜模式(功能测试中)<br />
有时可能出现latex数学公式不渲染的bug，这时一般刷新页面就可以解决</p>
<p><a href="./thinklive/22586/">建站指北</a></p>
<p>菜单的<a href="./webstack">资源地图</a>和<a href="./cyberblog">神龛</a>是迪瑞克拉子站，分别用于存放资源网站和随笔,主站主要存放学习笔记或者一些公开的创作</p>
<h2 id="迪瑞克拉的由来">迪瑞克拉的由来</h2>
<p><code>狄利克雷函数</code>（英语：<code>dirichlet function</code>）是一个定义在实数范围上、值域不连续的函数。<code>狄利克雷函数</code>的图像以Y轴为对称轴，是一个偶函数，它处处不连续，处处极限不存在，不可黎曼积分。这是一个处处不连续的可测函数。</p>
<p>在我看来它象征着混沌，不可知与无限的可能性，<code>狄利克雷</code>换一种方式音译就成了迪瑞克拉</p>
<h2 id="更新日志">更新日志</h2>
<span id="more"></span>
<p>2023/9/17<br />
迪瑞克拉博客的生日，当天增加了背景音乐，搜索，相册，标签，目录，置顶等基础功能</p>
<p>2023/9/18<br />
新增了评论，预估阅读时间，字数统计，网站访问统计,加载进度条功能,将背景音乐的歌曲改为歌单,为了方便使用，菜单切换成了中英双语</p>
<p>2023/9/19<br />
新增了多级分类的特性，让返回顶部的进步条已读百分比，页面底部能看到阅读进度条了，新增了代码块复制功能，现在可以通过书签功能自动储存阅读进度，使退出后重进仍是当初的进度，也可以手动点击右上角书签图标实现相同效果,新增了彩带背景，并把背景色改成黑色</p>
<p>2023/9/20<br />
替换一些页面ui文本，为一些页面ui文本加入了颜文字</p>
<p>2023/9/26<br />
在guestbook和首页嵌入了好友做的一个赛博朋克logo视频</p>
<p>2023/9/27<br />
开启了一些next的小功能，侧边栏加了一个thinklive的赛博朋克logo</p>
<p>2023/9/28<br />
新增了加密页面，由秘密这个目录名检索，密码不会向任何人透露，部分页面会有提示</p>
<p>2023/9/29<br />
新增了资源地图菜单，点击会跳转到使用不同主题的子站，可以通过子站的侧边栏回到主页</p>
<p>2023/9/30<br />
给子站加了看板娘，主站加了鼠标轨迹，子站加了鼠标轨迹和点击烟花特效，看板娘有截屏，提示等功能，但是主站不会加，毕竟主站定位比较严肃嘛,顺便加了个小彩蛋，离开页面一秒后就能看到</p>
<p>2023/10/1<br />
修了一下标签页彩蛋的bug，新增了线条特效，鼠标不动时会慢慢聚集起来,由于next层级的原因，主站只有背景会生效，改起来很麻烦，正好对主站来说也有点太花哨了，就只在子站用吧 主站加了个小游戏页面，左上角回到主站，只能玩一把是故意的，避免一直摸鱼，绝对不是懒得写</p>
<p>2023/10/2<br />
新增了神龛子站，用来放一些文学创作之类的玩意，更新随缘，主要是赛博朋克风挺好看的想整一个,返回主站会开新标签页是因为，伊卡洛斯这个主题没有不开新标签页的api，所以将就一下吧</p>
<p>2023/10/7<br />
新增了点开源的threejs网页端特效小游戏</p>
<p>2023/10/19<br />
现在首页的文章按更新时间排序了</p>
<p>2023/10/25<br />
添加了基于pandoc的lateX公式支持，主要用于写算法的笔记</p>
<p>2023/11/20<br />
更换了一下子站和资源站的logo图片</p>
<p>2023/11/22<br />
新增了一个字符版bad apple，以及一个开源的思维导图页面</p>
<p>2023/11/25<br />
升级了hexo到最新版本，代价是由于没备份配置文件重新做了一下配置，但相应的增加了一些功能，比如代码块折叠，还有改变了字数统计算法（缩水了一半，草）</p>
<p>2023/11/27<br />
添加rss订阅 ，在左侧的社交栏,以及分享功能</p>
<p>2023/12/10<br />
新增作者名/文章唯一编号的url形式</p>
<p>2023/12/14<br />
修复了加密页面没有目录,也就是toc识别不到加密页面的问题(好像这次修复只有我是受益人？)</p>
<p>2023/12/16<br />
新增了侧边栏的时钟和背景的波浪特效</p>
<p>2024/1/27<br />
现在神龛也是按更新时间排序了</p>
<p>2024/2/3<br />
添加了雪花效果，并开始新年特辑</p>
<p>2024/2/4<br />
更换了背景，与一些js特效的微调</p>
<p>2024/4/4<br />
现在迪瑞克拉被谷歌和必应所收录</p>
<p>2024/4/8<br />
添加了steam库存菜单</p>
<p>2024/6/25<br />
增加黑夜白天模式切换(测试中)</p>
<p>2025/9/25<br />
减少了特效的规格(优化性能)</p>
<p>2025/9/28<br />
针对aplayer优化了黑夜模式<br />
去除了steam页面(不太美观,用处也不大)</p>
]]></content>
  </entry>
  <entry>
    <title>具身智能论文阅读笔记</title>
    <url>/thinklive/52409/</url>
    <content><![CDATA[<p>关于具身智能领域的论文</p>
<span id="more"></span>
<ul>
<li><a href="#semantic-mapping-语义地图">Semantic Mapping 语义地图</a>
<ul>
<li><a href="#survey">survey</a>
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#名词介绍">名词介绍</a></li>
<li><a href="#地图结构">地图结构</a>
<ul>
<li><a href="#spatial-grid-map">Spatial grid map</a></li>
<li><a href="#topological-map">Topological map</a></li>
<li><a href="#point-cloud-map">Point-cloud map</a></li>
<li><a href="#hybrid-map">Hybrid map</a></li>
</ul></li>
<li><a href="#地图编码-map-encoding">地图编码 map encoding</a>
<ul>
<li><a href="#显式编码">显式编码</a></li>
<li><a href="#隐式编码">隐式编码</a></li>
</ul></li>
<li><a href="#地图评估-map-evaluation">地图评估 Map Evaluation</a></li>
<li><a href="#展望未来与结语">展望未来与结语</a></li>
</ul></li>
<li><a href="#dualmap-在线开放词汇语义建图助力智能体自然语言导航">DualMap: 在线开放词汇语义建图助力智能体自然语言导航</a>
<ul>
<li><a href="#背景">背景</a></li>
<li><a href="#dualmap-的改进">DualMap 的改进</a>
<ul>
<li><a href="#具象地图">具象地图</a></li>
<li><a href="#抽象地图">抽象地图</a></li>
<li><a href="#导航策略">导航策略</a></li>
</ul></li>
<li><a href="#测试结构与总结">测试结构与总结</a></li>
<li><a href="#附录">附录</a></li>
</ul></li>
<li><a href="#conceptgraphs-open-vocabulary-3d-scene-graphs-for-perception-and-planning">ConceptGraphs: Open-Vocabulary 3D Scene Graphs for Perception and Planning</a>
<ul>
<li><a href="#3d-对象图生成">3d 对象图生成</a></li>
<li><a href="#3d-场景图生成">3d 场景图生成</a></li>
</ul></li>
<li><a href="#hierarchical-open-vocabulary-3d-scene-graphs--for-language-grounded-robot-navigation">Hierarchical Open-Vocabulary 3D Scene Graphs for Language-Grounded Robot Navigation</a>
<ul>
<li><a href="#实验">实验</a></li>
</ul></li>
<li><a href="#open-scene-graphs-for-open-world-object-goal-navigation">Open Scene Graphs for Open-World Object-Goal Navigation</a>
<ul>
<li><a href="#场景图">场景图</a></li>
<li><a href="#地图生成和定位">地图生成和定位</a>
<ul>
<li><a href="#自动生成osg">自动生成OSG</a></li>
<li><a href="#图像解析-image-parser">图像解析 Image Parser</a></li>
<li><a href="#状态评估">状态评估</a></li>
<li><a href="#osg-更新">OSG 更新</a></li>
<li><a href="#基于概率的osg">基于概率的OSG</a></li>
</ul></li>
<li><a href="#推理和控制">推理和控制</a></li>
<li><a href="#实验-1">实验</a></li>
</ul></li>
</ul></li>
<li><a href="#vision-language-action-models">Vision-Language-Action Models</a>
<ul>
<li><a href="#large-vlm-based-vision-language-action-models-for-robotic-manipulation-a-survey">Large VLM-based Vision-Language-Action Models for Robotic Manipulation: A Survey</a>
<ul>
<li><a href="#前言-1">前言</a></li>
<li><a href="#背景知识">背景知识</a></li>
<li><a href="#monolithic-models-单片模型">MONOLITHIC MODELS 单片模型</a>
<ul>
<li><a href="#single-system-models">Single-system Models</a>
<ul>
<li><a href="#model-performance-enhancement">Model Performance Enhancement</a></li>
<li><a href="#inference-efficiency-optimization">Inference Efficiency Optimization</a></li>
</ul></li>
<li><a href="#dual-system-models">Dual-system Models</a>
<ul>
<li><a href="#cascade-based-methods">Cascade-based Methods</a></li>
<li><a href="#parallel-based-methods">Parallel-based Methods</a></li>
</ul></li>
</ul></li>
<li><a href="#hierarchical-models-分层模型">HIERARCHICAL MODELS 分层模型</a>
<ul>
<li><a href="#planner-only">Planner-Only</a></li>
<li><a href="#plannerpolicy">Planner+Policy</a></li>
</ul></li>
<li><a href="#其他前沿领域">其他前沿领域</a></li>
<li><a href="#vla-的特点">VLA 的特点</a></li>
<li><a href="#数据集和基准测试">数据集和基准测试</a></li>
<li><a href="#总结和展望">总结和展望</a></li>
</ul></li>
<li><a href="#π0-a-vision-language-action-flow-model-for--general-robot-control">π0: A Vision-Language-Action Flow Model for General Robot Control</a>
<ul>
<li><a href="#模型介绍">模型介绍</a></li>
<li><a href="#训练与实验">训练与实验</a></li>
<li><a href="#细节">细节</a></li>
</ul></li>
</ul></li>
<li><a href="#实例">实例</a>
<ul>
<li><a href="#openin">OpenIN</a></li>
<li><a href="#learning-fine-grained-bimanual-manipulation-with--low-cost-hardware">Learning Fine-Grained Bimanual Manipulation with Low-Cost Hardware</a>
<ul>
<li><a href="#前言-2">前言</a></li>
<li><a href="#real-work">real work</a></li>
<li><a href="#实验与总结">实验与总结</a></li>
</ul></li>
</ul></li>
</ul>
<p>具身智能: 集成了物理上的机械以及 ai(一般是常用的机器学习模型)的一种智能体, 这个词与 robotics(机器人学)的区别是, 后者较为关心硬件上的很多问题, 以及操作系统等偏底层的问题; 而具身智能较为关注抽象层面的智能, 暂时屏蔽掉底层的一些细节</p>
<h1 id="semantic-mapping-语义地图">Semantic Mapping 语义地图</h1>
<h2 id="survey">survey</h2>
<h3 id="前言">前言</h3>
<p>语义地图以结构化的方式捕获环境信息, 让代理能够利用这些信息进行推理<br />
由于具身智能面对的现实问题复杂性, 它会需要很多种 ai 技术, 单单是抓取一件物品, 就需要包括视觉辨识, 自然语言的理解与推理, 导航, 操控机械臂的能力等等<br />
在这一系列任务中, 辨识理解环境是第一步, 在认知科学中, 研究者发现人类和动物实际上也会将现实的空间抽象化为一种“认知地图”, 也就是说, 对我们的大脑来说, 一处地点在脑中的印象不只是一些有长宽高形状的障碍物, 还有名称, 物理性质, 用途之类的“语义”, 这一定程度上启发了研究者使用类似的机制让 ai 理解环境, 也就是语义地图<br />
为了方便, 将建立(语义)地图的过程简称为映射(mapping)<br />
对于导航, 寻物等任务, 当前主流的流程可分为三步:</p>
<ol type="1">
<li>将当前的环境合理地建立数据模型</li>
<li>定位自己的当前位置</li>
<li>路径规划</li>
</ol>
<p>智能机器人可以分为很多种, 我们只考虑不联网(用不了 gps), 没有复杂传感器的一类, 就叫 bot 吧, bot 想建立地图, 最直观的方法就是以自己为中心开始认知环境, 这就有点类似人类的认路, 对这种机器人来说,1. 2.其实可以视为一体, 因为在对当前环境建模的过程中可以自然地知道自己的位置, 主流的技术也是这么做的, 称为 <code>simultaneous localization and mapping (SLAM)</code><br />
总结一下, 接下来要讨论的 SLAM 是一种对环境的不断认知地同时进行地图制定及定位的一种技术<br />
现在设想一个传统印象里的机器人, 它可能有光学或者声学的某些传感器, 这些传感器能很容易地捕捉到附近的障碍物, 这和初中生物讲的蝙蝠超声波定位也没什么本质区别, 但这些障碍物信息并不包括语义信息<br />
附带语义的 slam 称为 <code>semantic slam</code>, 常见的做法是对传感器画面做特征提取, 例如可以提取成一系列词汇, 这称为 <code>Bag of Visual Words</code>, 得到这些词后, 查找词典匹配到一个具体物品; 如果想要更好的效果, 则可以进行深度学习</p>
<h3 id="名词介绍">名词介绍</h3>
<p>如果我们想要真正能用的机器人, 就不得不想办法让它能理解概念性的东西, 例如自然语言里的上下文, 词义向量, 而在具身智能的问题场景中, 则需要带有语义的地图, 例如客厅和餐厅都摆着大桌子, 要区分这两种房间就需要很多上下文信息<br />
以下开始介绍一些细节, 首先是地图的表示方法(结构), 考虑室内这个场景, 由于其最大高度是固定的, 因此可以比较方便地使用 2d 的拓扑图, 网格来表示, 除此之后也可以使用 3d 的点云或者其他混合结构<br />
我们首先做的是物体辨识和分类问题, 在室内, 例如普通住房中, 房间、家具的种类都是有限且数量级很小的, 对于机器人, 用内置芯片的算力可能就能做出来, 在机器人探索的过程中, 得到的各个空间、物体关系可以不断存入语义地图中供之后调用, 例如让机器人找一个苹果, 它能发现苹果在冰箱里面, 拓扑关系上可能就是客厅-冰箱-苹果, 这样之后找苹果也可以跟着这条路径走</p>
<div class="note info"><ul>
<li><code>开放词汇语义地图（Open-Vocabulary Semantic Maps）</code>: 系统能够识别和处理未在训练中见过的新对象或特征, 而不仅仅局限于预定义的类别; 与其相反的情况就可以视为是一个分类问题</li>
<li><code>Embodied AI tasks</code>: 大致可分为: 探索、导航、操纵, 更细粒度的划分可以使用目标的类型, 例如图像目标比定位上的目标需要更细的信息</li>
<li><code>End-to-end | Modular approaches</code>: 前者直接用传感器信息生成行动, 优点是对中小型任务效果不错, 但复杂的 3d 空间, 长期路径规划等任务中表现不佳, 此外也无法复用; 后者会将输入信息投入不同模块中处理例如编码器, 映射, 探索等, 最后生成行动, 优点是各个模块可以分开训练或者使用预训练模型</li>
<li>e2e 相关
<ul>
<li><code>intermediate map representation</code>: 输入和输出之间的中间数据, 一般用于提取关键信息</li>
<li><code>egocentric map</code>: 从个体的视角（通常是观察者或移动体的视角）表示环境的地图</li>
</ul></li>
<li>模块化相关
<ul>
<li>一般包括: <code>visual encoder</code>、<code>mapper</code>、<code>exploration</code>(决定去哪探索)、<code>planner</code>(决定机器采取什么动作), 以上提及的这些是顺序关系</li>
<li>视觉编码器: 将观察转化为带有语义的编码, 一般使用预训练的模型, 最后可以将检测到的物体放入标好名字的 box</li>
<li>映射器: 接受编码器的特征信息, 构建语义地图</li>
<li>探索: 类似红警 2 的探图能产生信息优势, 由于知道越多的地图信息应该是越好的, 因此设置这个模块鼓励智能探索未知区域, 优先探索哪边可以选取合适的方法, 例如图文相关型, VLM 输出的最佳方向</li>
<li>计划: 在地图建后, 需要指定导航路径, 这部分取决于机器的运动方式等细节</li>
</ul></li>
<li><code>Active SLAM</code>: 强调机器人自己能选择以某种方式主动收集地图信息用于映射, 比如自己走几步, 让摄像头拍到更多画面, 也就是相比 ALAM 增加了 planning 部分。</li>
</ul>
</div>
<p>具体环节:</p>
<ol type="1">
<li><code>localization</code>: 非常依赖于传感器, 由于本领域相对不关注底层细节, 一般假设每次采样都获得了最佳结果或者每次行动都实现了理想的位移
<ol type="1">
<li>由于现实中不可能有理想情况, 我们有 <code>Loop Closure(闭环检测)</code> 这样的算法来矫正误差, 该算法会利用再次访问之前访问过的地点时的数据矫正对行为位移的估计值</li>
</ol></li>
<li><code>feature extraction</code>: 关键部分, 后文详细介绍</li>
<li><code>projection</code>: 存储 3 维地图是一件非常难的事, 而且常识上高度轴上的物体关系较简单, 因此我们常用 2 维地图, 学习时将 3 维信息添加到 2 维地图上, 如果我们通过相机来获取空间信息, 那么过程就是, 根据相机的内置功能算出物体的世界坐标(X, Y, Z)将世界坐标投影到 2 维地图坐标(x, y),</li>
<li><code>Accumulation</code>: 上一步中可能遇到不同的物体堆到同一个二维点的情况, 为此有很多方法, 例如取最大, 取平均, 等, 其中可学习的方法可以有带有 LSTM 或者 GRU 的 RNN</li>
</ol>
<p>此外还有一些权衡的地方:</p>
<ul>
<li>Egocentric vs allocentric</li>
<li>Tracking visited areas</li>
<li>View point selection: 固定视角的摄像头或者全局摄像头</li>
<li>Online vs offline map building: 考虑到盲点等问题, 一般 online 是更好的</li>
<li>现实世界的复杂性: 例如我们以上提到的 localization 假设与现实肯定不符的</li>
</ul>
<p>总结一下常见的问题:</p>
<ul>
<li>计算量较大: 尤其对于本地模型来说, 更需要优秀的算法, 部分任务还会要求低延迟</li>
<li>容量需求: 对复杂的场景, 传统地图已经很庞大了, 加上语义, 复杂度更高, 储存和更新都是个问题</li>
<li>噪声: 现实世界的噪声很多, 还有各种随机因素, 学界目前没有很好的过滤方法</li>
<li>动态的环境: 如果环境不断变化, 现有的方法可能无法有效地更新</li>
<li>语义理解: 这部分较为依赖 clip 之类的视觉语言模型或者 llm</li>
<li>可用性和可靠性: 事实上, 目前的 em-ai 都很难落地</li>
<li>标准化: 目前的机器人或者 ai 社区使用不同的系统或者平台</li>
</ul>
<h3 id="地图结构">地图结构</h3>
<ol type="1">
<li>Spatial map building</li>
</ol>
<p>我们将地图做成一个(M×N×K)的网格, 其中(M, N)是空间上的维度, K 是语义上的 channel, 一般来说过程是这样的: 划分输入图片-&gt; 把图片投影到自我为中心的地图 ego_map -&gt; ego_map 注册进外部坐标系的 allo_map -&gt; 降噪</p>
<ol start="2" type="1">
<li>Topological map building</li>
</ol>
<p>类似图论, 用(v, e)两个集合就可以表示一个图, 节点和边可以各自携带语义, agent 在更新中定位或者新建自己所处 node, 并可以根据一轮中学习的信息对整个图进行修改</p>
<ol start="3" type="1">
<li>point cloud map</li>
</ol>
<p>由于成本较大, 这方面应用有限</p>
<p><img src="/assets/ml/Pasted%20image%2020250911154734.png" /></p>
<p>下面对各个结构详细介绍</p>
<h4 id="spatial-grid-map">Spatial grid map</h4>
<p>现在对室内具身智能的研究通常用 MP3D, HM3D 等数据集, 这些都是对现实空间的 3d 建模, 都小于 1000 平米, 一个 cell 表示 400-900 平方厘米的空间, 有时也会再拓展一个高度维<br />
早期研究直接使用自我中心的映射, 并直接端到端训练, 这样的缺点是无法认知到全局的空间结构, 甚至还会忘掉过去的学习结果, 于是就需要得到外部坐标系的空间地图<br />
但由于智能体只能观察到自己传感器的部分, 也就是其观察内容是自我中心的, 所以想要得到外部坐标系的空间模型, 就需要有一种办法通过一次次的观察结果一笔一笔“画”出全局的地图<br />
我们将这种办法称为 <code>registration 注册</code>, 也就是将每次的自我中心观察提取到的图像特征一点点放进全局地图, 这其实和人类画地图的方向比较像<br />
每一轮中, 将观察信息融入到一些特定的 grid cells, 如果有重叠, 则通过某种方法把两个值叠加为一个结果值, 这种叠加称为 <code>aggregation</code>(聚合)<br />
有一种基于注册的方法叫做 <code>MapNet</code>, 即通过使用已知的相机内参和对深度的测算, 将 egocentric 图像特征投影到一个 2D 俯视网格上<br />
它执行 <code>注册</code> 的方法是: 首先获取一系列旋转多次后的 egocentric 地图, 然后与之前 allocentric 地图进行 <code>密集匹配</code>, 以确定代理在地图上的当前位置</p>
<p>另一种方法是: 直接通过相机内置函数将图片像素转化为（相对于相机的）3d 坐标, 由于相机的 pose 我们是知道的, 所以可以直接将其转化为世界坐标, 并将其体素化, 投影到 2d 平面时, 我们可以把这些体素的 weight 也压上去<br />
这样的缺点就是太依赖相机功能, 对于现实的噪声敏感, 需要额外的降噪步骤, 使用这种方法的 <code>Semantic MapNet</code> 和 <code>MOPA</code> 都各自用了一些降噪算法, 前者还发现, 先对图像编码, 然后投影, 最后执行分割会减少噪声, 甚至可以不去降噪</p>
<p>总结: 使用 grid 能比较方便地表示空间, 也能方便 agent 学习, 但固定的宽高对于变化环境不太方便, 而且内存占用较多</p>
<div class="note info"><ul>
<li>密集匹配(dense matching) : 计算机视觉和图像处理中的一种技术, 用于在图像或视频序列中找到像素级别的对应关系。与稀疏匹配（只在特定特征点上进行匹配）不同, 密集匹配试图为图像中的每一个像素找到对应的像素。</li>
<li>pose: 物体在三维空间中的位置和方向</li>
<li>体素（Voxel）: 是“体积像素（volume pixel）”的缩写。它是三维空间中的最小单元, 具有位置、大小和属性（如颜色、密度等）</li>
<li>体素化(voxelized): 将三维空间中的物体或场景表示为一组 <strong>体素（voxel）</strong> 的过程</li>
</ul>
</div>
<h4 id="topological-map">Topological map</h4>
<p>拓扑图更注重节点(地标)之间的关系, 这其实也是人类认路的一种方法, 符合常识, 但缺点是抽象层级较高<br />
首先考虑怎么表示给出一个空间, 怎么画它的拓扑图, 什么是节点, 什么是边呢？符合直觉的想法是, 节点有较为重要的语义信息, 例如是一种房间的典型物体, 而边描述节点之间的连接性, 常见方法中节点通常存储图像特征或时间信息 (访问时间戳) 等信息, 而边缘可以存储一对节点之间的相对 pose<br />
实际训练中, 可以让模型预先跑几遍结合这几次的轨迹画出一个 graph, 然后的规划过程寻找 graph 中最接近的节点, 这称为 <code>Semi-Parametric Topological Memory (SPTM)</code>, 这种做法有很多缺点, 例如预探索可能有很多没走到的路, 不适合未知场景等<br />
为了解决这种问题, 我们需要让 agent 能实时地感知到自己有哪边不了解, 应该先探索那边, 也就是 online 学习, 一种做法叫 <code>Neural Topological SLAM (NTS)</code>, 它使用 <code>Graph Update</code> 模块更新 map, <code>Global Policy</code> 模块对 map 采样, <code>Local Policy</code> 模块输出离散的导航行动; 其中图更新模块作用如下:</p>
<ol type="1">
<li>定位: 尝试将智能体在前一个时间戳的图中进行定位</li>
<li>对已存在节点:
<ol type="1">
<li>如果智能体成功定位到一个现有节点, 便在该节点与上一个时间戳的节点之间添加一条边</li>
<li>存储两个节点之间的相对 pose</li>
</ol></li>
<li>如果智能体无法定位, 则在图中添加一个新节点</li>
</ol>
<p>这就产生了另一个问题, 什么情况下是在已有节点, 什么情况下要新增节点呢？这需要判断两个观察值是否相似, 可以视为一个分类（二分）问题, 用一个既有的分类器计算, 也可以用可达性估计或者一些预训练的无监督网络处理(附近拍的观察可以视为一类, 这样就不用手动标注)<br />
与网格地图相比, 拓扑的空间占用少, 但也因此可能漏掉细粒度的信息</p>
<h4 id="point-cloud-map">Point-cloud map</h4>
<p>用过建模软件的都知道, 出于优化性能考虑, 复杂的模型经常用三角形 mesh 表示, 由于训练智能体大多是在虚拟环境中, 点云与 meshes 有不错的适配性<br />
而对于语义信息, 可以直接为每个点赋予一定的寓意, 最后我们就得到了一个不那么传统的 map, 我们一般用一个神经网络来赋予每个(x, y, z)点一个语义向量, 这个网络称为 <code>neural field</code><br />
这方面的应用暂时不算多, 点云更多被用在场景理解或者分类上, 这里暂且略过少数几个例子<br />
光看简介就能看出来, 点云的计算和存储成本都很高, 并且对于稀疏的场景, 提供的信息可能也不足, 是一种有待探索的结构</p>
<h4 id="hybrid-map">Hybrid map</h4>
<p>混合方法也是常见的思路, 一些相关的应用有:</p>
<ul>
<li>拓扑更能捕捉空间之间的关系, 而 grid 更有距离上的细节, 两者结合称为 <code>topometric map</code>
<ul>
<li>例如, 先生成一个粗糙的拓扑图, 根据拓扑图完善一个细粒度的 grid; 实验发现, 拓扑图能修正一些巨大的测量问题, 也就是全局问题, 而网格则能更好地解决局部问题</li>
<li>另一篇文章中, 为了处理紧凑的环境, 作者将转角和走廊用拓扑表示, 房间则用网格表示, 由于一般来说我们只需要房间里有详细的信息, 而对交通空间不关心具体情况</li>
<li>以上两篇都比较古早, 最近的一种基于 bert 的文章离线训练 hybrid maps, 然后训练一个多模态模型进行语言指导式的空间推理</li>
<li>还有结合三者的, 网格存储 occupancy(障碍物)信息, 拓扑图存储地标及其连通性, 点云则存储详细的语义信息</li>
</ul></li>
<li>构建能够捕捉场景语义层次的地图可以实现不同层次的推理, 例如不同的节点实际上在不同层级(坐标系)中而, 边表示坐标系的转化关系; 除了分层, 还可以额外存储物体, agent 之间的时空关系, 实验证明分层的场景表示对复杂的环境效果更好, 这样的技术甚至可以用来对城市的交通系统进行建模</li>
</ul>
<p>混用这些地图结构时需谨慎考虑各自的特点, 例如拓扑和点云地图在大环境中比网格地图更具可扩展性, 但点云需要更多存储空间, 拓扑地图所需的存储空间最少</p>
<h3 id="地图编码-map-encoding">地图编码 map encoding</h3>
<p>地图编码是指将信息通过某种方式存储在语义地图中, 而这些信息可以分为隐式和显式的, 显式指的是可以被直接解释或者理解的信息, 例如像素的颜色, object 所属的类别等; 隐式则指一些提取出来的特征, 无法被直接地理解</p>
<h4 id="显式编码">显式编码</h4>
<p>那么根据常识, 至少障碍物信息, 也就是 <code>occupancy information</code> 信息是很值得显式存储的, 并且可以用一个 bool 就能表示是否占用的二元关系<br />
此外, 为了鼓励 agent 探索未去过的区域, <code>Active Neural SLAM</code> 方法会存储一个 bool 值表示是否已探索<br />
而对于更复杂或者更长期的任务, 例如针对语义目标的导航任务, 就需要额外存储语义信息, 例如 <code>SemExp</code> 会额外存储 agent 认知的语义类别标签, 这些标签通过 <code>MaskRCNN</code> 产生, 在 <code>aggregate</code> 时使用 <code>element-wise max pooling</code>(取各个子区域里的最大值), 且保留最新的预测值<br />
首先将图像分割再投影会造成 <code>label splattering</code> 现象, 也就是一些噪声标签会散布到多个 <code>grid cells</code>, 这是因为对深度的观察会受到环境噪声的影响; 但首先投影编码后的特征再分割能实现一定的降噪效果(需要预探索)<br />
此外, 图像, 文字, 目标检测概率(对目标属于某个类别的置信度评分)等值也可以作为存储标签, 近年一些图文, 图图匹配也有不错的效果; 存储音频信息(例如声音强度)的地图在视听导航任务中也有作用;<br />
以上都是网格地图的应用, 拓扑图中, 可存储每次都会替换更新的访问时间戳, 用来表示地点之间的时间相对关系</p>
<p>总结: 显式编码的优点是其可解释性, 对于具体的任务, 我们可以选择常识上有益的信息类型并编码存储, 但是这较为依赖人类对问题的理解</p>
<h4 id="隐式编码">隐式编码</h4>
<p>大部分的早期工作使用预训练的基于封闭词汇表的视觉模型提取特征, 例如 cnn, 近年来, 更多使用预训练的基于开放词汇表的大型视觉-语言模型<br />
封闭词汇表:</p>
<p>可以使用 cnn 或者流行的 <code>vision model</code> 例如 <code>ResNet</code> 除了图像以外, 也可以根据可微分的映射器和 <code>planner</code> 进行非监督学习, 通过计算微分, 模型可以不断优化性能, 地图则可以通过 <code>differentiable warp</code> 不断集成</p>
<p>开放词汇表:</p>
<p>封闭词汇表最大的漏洞是: 无法编码不认识的特征, <code>Large Vision-Language Model (LVLM)</code> 如 <code>CLIP</code> 可以缓解这个问题, 这些模型有庞大的训练资料, 对于不认识的物品, 可以通过已有知识建立新的类别<br />
<code>CLIP</code> 有强大的图文匹配能力, 利用这点, 可以在 2Dmap 中存储图文相似得分(<code>value maps</code>), 这在下游应用例如 <code>zero-shot</code> 的语言驱动的导航中表现良好, 也有论文将其拓展到 3D<br />
尽管其匹配能力相比封闭词汇表十分强大, 但仅限于图片和文本的匹配, 依旧缺乏更详细的语义和空间信息, 因此空间推理能力欠缺<br />
为了增强推理能力, 需要找到判断物体在图片中的位置, 以及提取特征的方法, 一个思路是对图片的所有像素嵌入一些特征, 根据摄像头的深度信息, 可以得知这些像素对应 3d 空间的坐标, 随后投影(聚合)到 2d 网格上, 在查询时, 先从输入提取出物品名, 再和这些像素匹配<br />
这个方法的缺点是, 并没有做到物体级别的语义, 可能忽略了空间上的一些关系, 此外很多像素可能就是空气, 毫无语义信息, 没有必要存储。24 年(<code>OneMap</code>)的一种方法使用分层的编码器缓解了这个问题<br />
NLMap(grid): 如果想直接辨别图像里的物品, 则可以使用 <code>class-agnostic region proposal network</code> 来划分出感兴趣的图像区域(region), 对于这些 region, 提取特征并将其存入 3d map(携带坐标和估计的大小信息), 这样一来, 对每次查询(会被先转化为物体名), 只要查找匹配度最高的 region 就可以了<br />
<code>ConceptGraphs(topo)</code>: 使用无类别的 2d 分割算法划分出物体, 这些物体可以直接作为拓扑图的节点并存储一些信息, 除了特征信息外, 例如对其的描述, <code>Candidate Masks</code> 的点云等也可以存储。接下来考虑边, 在这种方法中, 考察物体的点云是否有几何相似性或者重叠部分, 有两个物体的点云重合度到达一个阈值, 则认为它们是空间相关的, 从而建立边。边也可以额外存储信息, 例如大模型对链接方关系的描述<br />
开放词汇表映射编码的优点是它可以一次构建, 然后复用到不同的下游任务。它可以有效地使用开放词汇表进行查询, 并且具有较高的可解释性<br />
缺点是, 当前阶段大模型的训练开销和计算开销都极大</p>
<div class="note info"><ul>
<li><code>Zero-Shot Manner（零样本方式）</code>: 在机器学习和人工智能中, 模型能够在没有针对特定任务或类别进行微调的情况下, 直接执行任务的能力</li>
<li><code>class-agnostic region proposal network</code>: 一种用于目标检测的网络架构, 旨在生成图像中潜在目标的区域分割, 而无需事先知道目标的具体类别, 如 <code>ViLD</code></li>
<li><code>Candidate Masks</code>: 计算机视觉中的一种概念, 通常用于目标检测和图像分割任务。它们代表了图像中可能包含目标的区域或对象的区域</li>
</ul>
</div>
<h3 id="地图评估-map-evaluation">地图评估 Map Evaluation</h3>
<p>很明显, 对智能效果最直接的评价标准就是 agent 执行任务的效果, 因此目前对 map 的评估较少, 本文讨论如何从准确性, 完整性, 一致性, 健壮性以及实用性的角度评价地图对于下游任务的功效</p>
<ul>
<li>Utility 实用性: 大部分工作将语义地图作为一个中间步骤, planner 使用它来规划路径, 产生动作指令, 如果我们只用地图做这一件事, 那么直接看任务完成地怎么样就是最好的评价标准了; 但对一些和地图有关的任务, 例如导航、勘探, 则也可以用覆盖率, 导航准确性等作为指标<br />
</li>
<li>Accuracy 准确性: 地图准确度是指与现实地形进行比较时, 地图捕获语义信息的准确度, 问题在于, 很多时候现实的地理信息较难获取。如果只论语义的比对, 则可以使用一些语义分割上的指标, 与智能的语义划分进行比对; 还有一个问题是, 这种比较对常常种类有限的显式特征较为方便, 但对隐式的特征则无从下手, 对此只能再用一个分割器将隐式转化为显式, 又或者人工评估</li>
<li>Completeness 完整性: 地图是否完整地表示环境, 这包括了几何和语义层面。这点很大程度上取决于机器人在下游任务中探索环境的彻底程度, 并且与 “停止标准 <code>stopping criteria</code>” 密切相关, 一般来说, 会在任务完成或者达到时间限制时停止; 而语义上的完整则很难测算, 几乎没有成熟的方法</li>
<li>Consistency 一致性: 几何一致性指的是地图的空间结构能反映环境物理布局的准确性, 不严谨的说可以视为地图局部细节(距离, 角度, 物体相对位置)的准确性, 模拟环境下不存在传感器噪声, 因此几乎可以不考虑, 但实际情况中, 由于各种因素影响, 代理可能错估自己走过的距离, 相对位置等, 从而破坏一致性; 语义一致性则指随着机器人运动, 语义信息和物理位置能否对齐。由于当前还处于理论阶段, 这方面的研究尚且不足</li>
<li>Robustness 健壮性: 在不可预测或动态环境中的可靠性, 由于现在大量使用预训练模型, 可以用预测的置信度来评估; 此外也可以使用模型预测的方差来评估, 但由于能落地的应用有限, 这方面的研究也比较缺乏</li>
</ul>
<h3 id="展望未来与结语">展望未来与结语</h3>
<p>当前的趋势为创建灵活、通用、开放词汇和可查询的地图, 以支持多种任务; 为了提高空间推理能力, 密集, 可扩展和内存高效也是一种方向</p>
<ul>
<li>General-purpose maps: 由于机器人任务多样化, 通用的模型明显有着重要意义, 更有通用能力的开放词汇表也可能是趋势, 这需要对计算成本和内存消耗的平衡<br />
</li>
<li>Dense yet efficient maps: 为了更好的空间推理能力, 需要高密度的地图, 但又为了计算效率, 需要其尽可能节省内存和算力, 常用方法中拓扑图过于稀疏难以捕捉细粒度信息, grid 难以处理多层面信息, 点云则过于密集, 性能消耗大, 可能需要一个更好的结构</li>
<li>Dynamic maps: 当前的地图技术基本都是基于静态环境, 对动态环境如室外的交通, 则很难有高效地建模方法</li>
<li>Hybrid map structure: 上文已经提到过混合结构的优点, 但如何融合或者切换也是值得研究的方面</li>
<li>Devising evaluation metrics: 与下游任务中代理表现的评估相比, 语义地图的评估在具身 AI 研究中受到的关注较少。为了推动该领域的发展, 需要强调使用准确性、完整性、一致性和健壮性等指标对地图进行评估。</li>
</ul>
<h2 id="dualmap-在线开放词汇语义建图助力智能体自然语言导航">DualMap: 在线开放词汇语义建图助力智能体自然语言导航</h2>
<h3 id="背景">背景</h3>
<p>鉴于近年 ai 领域的发展, 机器人领域逐渐开始研究对于自然语言理解能力的集成, 对此可以分为 3 种任务:</p>
<ol type="1">
<li>开放词汇理解</li>
<li>高效地在线建图</li>
<li>动态环境导航</li>
</ol>
<p>一些经典方法如 yolo(深度学习的对象检测模型), 虽然表现较为不错, 但鉴于它基于封闭的词汇表, 对于 "不认识" 的类别是没有辨别能力的<br />
而所谓的开放词汇, 就是需要让模型能够理解没见过的类型, 并逐渐学习怎么更好地分类和认知, 常见的方法有:</p>
<ol type="1">
<li>通过图像标注模型标出标签, 再根据标签使用基于封闭集合的检测器, 不过图像模型成本较为高昂, 很难在线学习</li>
<li>类别无关分割: 使用一种不依赖具体类别的专用分割模型, 再借助视觉基础模型(VFM)提取语义特征, 开销也较大</li>
</ol>
<p>其主要的创新点正如其名, 在开放词汇的基础上使用两种地图, 空间占用较低的抽象地图用于导航任务, 具象地图在需要更多细节时用于参考</p>
<h3 id="dualmap-的改进">DualMap 的改进</h3>
<ol type="1">
<li><p>开放词汇的目标分割<br />
利用 llm 提供类别, 让 yolo 快速生成粗略的目标检测结果, 并通过 mobileSAM 生成分割掩码; 同时让 FastSAM(开放词汇表分割模型)捕捉 yolo 的封闭表外的对象(这步可能会过度分割, 之后还会进行合并操作); 对两者进行融合时 yolo 优先, 补充不重复的 FastSAM 片段；这样的设计主要是为了使用成本较低的 yolo 和 fastsam, 从而实现在线学习<br />
这里补充一下对每一帧 I 的处理, 事实上有三个模块会并行地使用 I, 即上述的 YOLO, FastSAM 以及一个点云生成器, 点云地图和语义信息无关, 只是用于提供空间布局</p></li>
<li><p>语义特征处理<br />
由于我们希望能让机器人做到能理解模糊的指令, 就需要让地图也携带语义信息, 这方面也有很方便的图文嵌入模型例如 CLIP, CLIP 提供对图像的编码功能, 在第一步的分割后, 对裁剪出的图像区域编码为 <span class="math inline">\(f_{image}\)</span> , 如果之前的分割给出应该类别标签, 对标签编码为 <span class="math inline">\(f_{text}\)</span> , 最后通过加权求和得到总的特征<br />
<span class="math display">\[\mathbf{f}=w_{\mathrm{image}}\mathbf{f}_{\mathrm{image}}+w_{\mathrm{text}}\mathbf{f}_{\mathrm{text}},\qquad\mathbf  {f}_{\{ {\mathrm{image,~text}\}}}   \in\mathbb{R}^{d}\]</span><br />
对于 FastSAM 标记为“null”的对象, 用所有已知类别嵌入的归一化平均文本特征替换 <span class="math inline">\(f_{text}\)</span>  , 以消除语义偏差</p></li>
<li><p>观察结构<br />
摄像机拍到的一帧为 I, 每个 I 提取出一个观察集 Z, Z 由 N 个片段 <span class="math inline">\(z_i\)</span> 组成, z 称为观察 , 可表示为: <span class="math inline">\(z=(P_{z},f_{z},y_{z},t_{z})\)</span><br />
其中 P 表示分割区域从深度图投影到世界坐标系中生成的 3D 点云; f 表示之前我们得到的语义特征; y 表示 yolo 检测的对象类别, 对于 fastSAM 分辨出的则设置为 null; t 为观测的时间戳</p></li>
<li><p>场景建模<br />
本模型使用点云对场景建模, 但为了减少性能消耗, 只在遇到姿态变化大的帧时通过投影(相机带有深度信息)更新点云(这个更新线程并行低频运行)</p></li>
</ol>
<p>dualmap 最大的特点正如其名, 使用两种 Map, 下文分别介绍</p>
<h4 id="具象地图">具象地图</h4>
<ol type="1">
<li><p>地图初始化<br />
地图有一系列对象组成, 每个对象, 这里称为 o, <span class="math inline">\(o=(P_{o},y_{o},f_{o},L_{o})\)</span><br />
其结构类似于观察 z, 但其中的 L 记录与对象关联的观测集, 即 <code>L=set&#123;z&#125;</code></p></li>
<li><p>地图更新<br />
当新的观测集合到达时, 系统开始新一轮匹配(第一轮所有观测 z 都会分配一个对象 o), 定义一个相似度矩阵 <span class="math inline">\({ S}\in R^{\mathbb{N}{\times}\mathcal{M}}\)</span> , 从点云重合度和语义相似度两个角度衡量<br />
<span class="math display">\[S(z_{i},o_{j})=\mathrm{cos}(f_{z_{i}},f_{o_{j}})+\mathrm{Overlap}(P_{z_{i}},P_{o_{j}})\]</span> 而更新条件用一个简单的阈值 <span class="math inline">\(\tau\)</span> 表示, 超过阈值认为是相同对象, 更新过程则是对 f 求新增一个 f 后的平均, 扩充点云, L 内部新增加一个观察 z; 否则新建对象</p></li>
<li><p>地图维护<br />
一般来说, 语义地图最“昂贵”的地方就是对 3d 物体进行合并, 为了避免这种开销, 通过轻量级的内部对象状态检查来维护地图的保真度, 可分为:</p></li>
</ol>
<ul>
<li>稳定性检查: 对一个较长时间未更新的对象
<ul>
<li>如果有足够观测次数, 至少有 2/3 的类别是同一个, 则保留</li>
<li>否则删除</li>
</ul></li>
<li>分割检测: 如果有若干连续帧(每一帧产生一个观察集)中在同一时间步内出现具有不同类别 ID 的观测, 例如对象 chair 连续 3 帧对应的时间步内有两个类别标签 chair 和 cushion
<ul>
<li>触发分割操作, 将对象的观测列表按类别 ID 分割并创建新对象</li>
</ul></li>
</ul>
<h4 id="抽象地图">抽象地图</h4>
<p>上一节我们讨论的地图依然是不包含全部语义信息, 只有对象(包括一些类别 id)信息的具象地图<br />
而相比前者, 抽象地图牺牲易变对象, 只存储锚点对象, 且新增一些语义信息与空间关系信息, 具体包括:</p>
<ol type="1">
<li>锚点对象
<ol type="1">
<li>首先使用两个代表性的锚点, 易变类别列表(list)对现有对象分类, 使用 CLIP 对对象编码得到特征 f, 如果 f 和两个列表的近似度相差达到一个门槛值, 则分到相似度更高的一类, 此时的门槛值较小, 仅设 0.05</li>
<li>除了 1.中的两个列表, 典型锚点对象的列表还有一个存储对应描述信息的列表, 对 1.中没有决定的对象, 计算其特征与描述列表的相似度, 这里设一个较大的门槛值 0.5, 并且强制二分</li>
<li>丢弃易变对象的非语义属性(因为对导航任务没用)</li>
</ol></li>
<li>空间关系(易变与锚点对象之间), 以 on 关系为主:
<ol type="1">
<li>以锚点对象点云的 Z 轴直方图以提取其支撑平面, 计算对象与锚点 2d 投影的重叠比例, 如果两者重叠且对象底部到支撑平面的垂直距离小于阈值, 则存在 on 关系</li>
<li>建立空间关系后, 易变对象的语义特征 f 将存储于对应锚点对象的特征列表 L(L 存储于其关联的易变对象语义特征), 对每个锚点对象 a, <span class="math inline">\(a\,=\,(P_{a},f_{a},y_{a},L_{a})\)</span><br />
</li>
</ol></li>
<li>场景布局
<ol type="1">
<li>将点云投影到鸟瞰平面, 划分出单元格, 对最密集的地方, 视为墙壁等结构物, 这种结构物只在新的查询请求到来时更新</li>
</ol></li>
</ol>
<h4 id="导航策略">导航策略</h4>
<ol type="1">
<li>候选检索<br />
对查询语句, 用 CLIP 编码为语义特征, 并与我们现有的锚点以及易变对象的特征集比较, 得分最高者作为候选, 候选锚点称为 a*<br />
锚点得分的计算公式:</li>
</ol>
<p><span class="math display">\[s(a)=\mathrm{max}\Biggl(\mathrm{cos}\big(f_{q},\,f_{a}\big),\,\mathrm{max\underset{i}\,cos}\big(f_{q},\,f_{v i}\big)\Big)\]</span> 其中 q 下标表示查询, a 下标表示锚点对象, vi 下标表示易变对象</p>
<ol start="2" type="1">
<li>导航策略
<ol type="1">
<li>全局路径规划: 使用基于 Voronoi 图的规划器在抽象地图上规划一条通往候选锚点的全局路径; 智能体移动时, 会逐步构建局部具象地图, 局部地图中的对象也可以用于匹配</li>
<li>局部路径规划: 对局部具象地图中的对象, 计算其特征与查询特征的余弦相似度 s, 如果 s 接近之前的全局候选相似度, 且正好在去之前的候选对象的路上, 使用 RRT*算法规划局部路径</li>
<li>动态环境导航: 如果 a*附近没有可信匹配, 那么环境可能变化, 系统会更新抽象地图 Ma'重新寻找候选
<ol type="1">
<li>Ma'会将局部具象地图中的稳定对象合并, 详解下文</li>
<li>更新地图后, 全局相似度分数依旧使用过去的版本, 即保留历史上下文信息</li>
</ol></li>
</ol></li>
<li>抽象地图更新
<ol type="1">
<li>对局部具象地图中的稳定对象, 进行一轮抽象化得到新的锚点 <span class="math inline">\(a_{new}\)</span></li>
<li>每个 <span class="math inline">\(a_{new}\)</span> 与现有的 a 比较, 计算重叠率
<ol type="1">
<li>如果重叠率超过门槛值, 说明 <span class="math inline">\(a_{new}\)</span> 和 a 有一定关系, 更新: <span class="math inline">\(f_{a}~\longleftarrow~{\frac{\left|P_{a}\right|\cdot{f}_{a} + \left|\mathcal{P}_{a_{\mathrm{new}} }\right|\cdot\ {f}a_{\mathrm{new}} } {\left|\mathcal{P}_{a}\right|\ +\left|\mathcal{P}_{a_{\mathrm{new} } }\right|} }\)</span></li>
<li>如果超过更严格的阈值, 则用 <span class="math inline">\(L_{a_{new}}\)</span> 替代 La</li>
<li>如果以上都不满足, 将 <span class="math inline">\(a_{new}\)</span> 作为新节点插入抽象地图中</li>
</ol></li>
</ol></li>
</ol>
<div class="note info"><ul>
<li><code>RRT*（Rapidly-exploring Random Tree Star）</code> 算法: 一种用于路径规划的优化算法, 尤其适用于高维空间中的移动机器人和其他自动化系统; 使用随机采样的方法在配置空间中探索路径, 逐步构建一棵树, 与基本的 RRT 算法不同, RRT* 在扩展树的过程中, 会不断优化已有路径, 尽量减少路径的成本</li>
<li><code>平均交并比（mIoU）</code>: 计算分割或检测任务中预测区域与真实区域交集与并集之比的平均值</li>
<li><code>频率加权交并比（F-mIoU）</code>: 对 mIoU 的一种加权版本, 考虑了每个类在数据集中出现的频率, 将每个类的 IoU 乘以该类在数据集中出现的频率, 然后求和, 最后除以总频率</li>
</ul>
</div>
<h3 id="测试结构与总结">测试结构与总结</h3>
<p>定义两种典型的变化: In-anchor relocation(和一个锚点有关的对象移动位置但不改变和锚点关系, 例如桌子上移动水杯)、Cross-anchor relocation(易变对象转换锚点, 例如从桌子移到架子上)<br />
对锚内变化, dualmap 可以通过更新局部具体地图找到目标；对于跨锚点变化, dualmap 可以通过更新抽象地图解决<br />
与 <code>ConceptGraphs</code> 和 <code>HOV-SG</code> 相比, dualmap 在表现提升之外, 内存使用量大大减少, 相比 <code>HOV-SG</code> 减少了 96%以上, 这是因为其避免了 3d 合并开销, 抛弃了多余的易变对象非语义数据, 并执行稳定性检查减少噪声数据等<br />
消融实验中, FastSAM、YOLO 细化、加权特征合并和对象分割检测等组件对性能有显著影响</p>
<h3 id="附录">附录</h3>
<p>实验中存在一些问题:</p>
<ul>
<li>YOLO 可能会将不一致的类标签分配给同一对象的不同部分, 基于类别的合并将无法将它们识别为一个对象</li>
<li>对多个堆叠关系或者离得很近的类的对象, 容易导致错误合并</li>
</ul>
<p>对合并问题, 在合并前使用一次额外的 rgb 检测尽可能经济地解决, 也就是对待合并对象画出 rgb 三个 channel 的直方图, 根据直方图计算余弦相似度, 超过一个阈值时才合并</p>
<h2 id="conceptgraphs-open-vocabulary-3d-scene-graphs-for-perception-and-planning">ConceptGraphs: Open-Vocabulary 3D Scene Graphs for Perception and Planning</h2>
<p>来自 ICRA 2024</p>
<p>这篇论文写得比较早(2023), 所以前言部分这里写得简略一点, 在当时主流的技术往往是封闭词汇或者一些性能消耗大的开放词汇表(也就是携带语义特征的点云)；此外还有个痛点是难以表达结构信息<br />
本文提出的感知图是一种以对象为中心的语义地图, 其几何信息由 3d 形式存储, 语义信息由 2d 形式存储</p>
<h3 id="d-对象图生成">3d 对象图生成</h3>
<ol type="1">
<li>类别无关的 2d 图像分割: 当传入观察帧后, 使用分割模型得到一个掩码集合 { <span class="math inline">\(m_{t,i}\)</span> } , 每个掩码得到图片片段, 将这个片段传入视觉特征编码器如 CLIP, DINO, 从而得到视觉特征向量；此外对片段中的点, 根据深度形象投影到 3d 坐标系中, 对投影后的点云使用聚类算法降噪, 最后放入地图中；最后我们得到了点云以及对应的单位归一化后的语义特征向量</li>
<li>对象中心的 3d 图: 令观察帧(rgbd)为 <span class="math inline">\(I={I_t}\)</span> , 其中 <span class="math inline">\(I_{t}\ =\ \langle I_{t}^{\mathrm{rgb}},I_{t}^{\mathrm{depth}},\theta_{t}^{*}\rangle\)</span> (color image, depth image, pose) 类似的, 图 M ={O, E}中的对象集合为 O, 边集合为 E<br />
</li>
<li>对象关联: 对每个新检测到的对象 <span class="math inline">\(o_t\)</span> 即 <code>&lt;p,f&gt;</code>(点云和特征向量), 计算它与在 3d 图上有空间重叠的对象 <span class="math inline">\(o_{t-1,j}\)</span> 的几何以及语义相似度
<ol type="1">
<li>几何相似度 <span class="math inline">\(\phi_{\mathrm{geo}}(i,j)\;=\;{\mathfrak{n}}_{\mathrm{nnratio}}({\bf p}_{t,i},{\bf p}_{oj})\)</span> 也就是 <span class="math inline">\(p_{t,i}\)</span> 中的最近的邻居点在 <span class="math inline">\(p_{oj}\)</span> 中的点所占比率(有一个门槛值)<br />
</li>
<li>语义相似度 <span class="math inline">\(\phi_{\mathrm{sem}}(i,j)\,=\,\mathbb{F}_{t.i}^{T}\mathbf{f_{oj}} / 2+1/2\)</span></li>
<li>以上两种相似度的简单相加作为总体相似度, 权衡计算花费和表现后, 贪心地选择相似度最高的对象匹配(如果超过一个门槛值), 而如果不到门槛值, 创建一个新对象</li>
</ol></li>
<li>对象融合: 对上一步关联的两个对象, 进行融合, 融合过程就是一个简单的求平均: <span class="math inline">\({\bf f_{o j}}\,=\,(n_{o_{j}}{\bf f_{o j}}+{\bf f}_{t,i})/(n_{o_{j}}+1)\)</span> 其中 n 是迄今为止(融合前)被关联到这个对象的观察片段数量, 点云部分则执行一个简单的并集操作, 并进行下采样降低成本</li>
<li>节点描述: 很实用主义的一步, 在我们暂时完成了一系列图像处理后, 对得到的对象, 将最好的 10 张图片送给 LVLM 处理, LVLM 生成对应的粗略描述, 再将其送给一个 LLM 生成一个最终描述</li>
</ol>
<p>简单地概括一下, 上述主要处理空间和语义上的物体(对象)表示, 空间部分是从二维图片提取的点云, 确定点云是和语义类别无关, 直到确认后才编辑语义部分, 提取语义的过程也很单纯, 将图片发给 LVM 和 LLM 得到描述, 每个对象存储一个关于自己的描述</p>
<h3 id="d-场景图生成">3d 场景图生成</h3>
<p>之前已经得到了对象层面的抽象, 这部分主要处理对象关系<br />
对每对 3d 对象, 计算器 3d 边界 Box 的 IoU 生成一个相似度矩阵, 并通过估计应该最小生成树 MST 来修剪矩阵, 从而得到数量可控的候选边<br />
(可能有人好奇为什么之前的描述不进行编码直接存储, 这是因为后面还会对 LLM 会使用描述信息)<br />
对这棵树的每条边, 将边对应的一对 obj 的描述和位置信息喂给 LLM, LLM 生成其可能的关系, 这个关系作为场景图的标签存储, 例如 on, in<br />
之后, 对自然语言类型的查询, 让 LLM 读取一个存储好相关信息的对象列表, 找到最有可能的关联对象并将这个对象交给下游应用<br />
当然还有一个很常见的思路是, 为什么不舍弃描述性信息, 直接使用 CLIP 之类的模型嵌入编码查询语句然后查找匹配对象呢？ 答案很简单: 实验者尝试过, 但效果不如 LLM, 准确地说, clip 对描述性的查找表现不错, 但对于比较模糊的查询表现不佳<br />
相比更近年的 dualmap, 这个模型还有一个比较直观的问题, 对动态环境无能为力, 但优点在于 llm 的泛化能力能解决很多导航问题, 例如一开始没找到之后去哪里找, 有障碍物的路径其障碍物能否推开等</p>
<p>场景图对象的 json 表示示例:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>  </span><br><span class="line">    id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    bbox_extent<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">2.0</span><span class="punctuation">,</span> <span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.6</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    bbox_center<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">-0.6</span><span class="punctuation">,</span> <span class="number">1.1</span><span class="punctuation">,</span> <span class="number">-1.2</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    object_tag<span class="punctuation">:</span> &#x27;wooden dresser or chest of drawers&#x27;<span class="punctuation">,</span></span><br><span class="line">    caption<span class="punctuation">:</span> &#x27;A wooden dresser or chest of drawers&#x27; </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简评: 无疑这个系统很实用, 但过于依赖 LLM 了, 文本描述很可能不是最好的空间表示方式</p>
<div class="note info"><ul>
<li>下采样（subsampled）: 简单地说, 尽可能保留信息地压缩原数据, 上采样与其相反</li>
</ul>
</div>
<h2 id="hierarchical-open-vocabulary-3d-scene-graphs-for-language-grounded-robot-navigation">Hierarchical Open-Vocabulary 3D Scene Graphs for Language-Grounded Robot Navigation</h2>
<p>来自 RSS 2024</p>
<p>本文提出的模型简称为 HOVSG, 相比同行最大的特点在于它是分层结构的, 我们之前提到的工作往往只是用拓扑图基于一个简单的图论空间模型表示现实空间, 也就是对象层级的地图, 但对于更加复杂的现实空间例如多层建筑, 其表现力就会受限, 因此本文使用分层的模型增强表示能力</p>
<p><img src="/assets/ml/overview-icra.png" /></p>
<p>本模型专注于解决对有 rpgd 相机和里程计(里程计用于构建坐标系)的多层环境建图问题, 其最初的 3d 建图和上一章的感知图比较类似, 之后增加分层信息<br />
下面介绍其流程, 和感知图类似的部分会略过</p>
<ol type="1">
<li>进行类别无关的分割, 并将片段投影为 3d 点云, 其合并算法与感知图不同, 重叠度记作: <span class="math inline">\(R(m,n)=m a x(o\nu e r l a p(S_{m},S_{n}),o\nu e r l a p(S_{n},S_{m}))\)</span> 其中 <span class="math inline">\(overlap(S_a, S_b)\)</span> 表示 Sa 中的点在 Sb 的邻域内（在一定距离内）的比率, 但合并不是一对对进行的, 而是构建一个全连接的图, 每条边存储连接的一对节点(片段)的重叠度, 这样就能找到一些重叠度较高的子图, 将所有子图一起合并</li>
<li>接下来开始计算特征, 这里还是用我们的老熟人 CLIP, 但有一些 trick, 由于之前的分割我们其实是有各个区域的掩码的, 按常识想, 似乎应该只把分割出的部分用来求特征, 但也有些工作会把掩码部分和整个图像都求特征算加权和, 根据本文团队的经验, 其特征也是加权和的形式, 写作: <span class="math inline">\(f_{i}=w_{g}f_{g}+w_{l}f_{l}+w_{m}f_{m}\)</span> 其中 i 表示第 i 个 2d 掩码, g 表示整个图像, l 表示基于掩码的图像裁剪, m 表示在l基础上再去除背景的图像裁剪, 详细可参考上图左侧
<ol type="1">
<li>接下来考虑怎么将算出的语义和点云表示的空间相关联, 这里简单地说, hovsg 采取了空间消耗最大的方法, 用 3d 点云存储语义, 但是会进行一定的优化</li>
<li>在准备阶段, 会预计算出大概的点云, 这称为参考点云, 而对在之前一步中得到的掩码区域, 会计算逐点特征并将其映射到(参考点云的) 3d 坐标系中,映射中片段的各个点会与参考点云中的最近点匹配, 也就是语义特征会关联到那个对应点,称为参考点, 在映射结束后，对各个参考点关联到的语义算平均作为其最终语义</li>
<li>在 2. 结束后, 我们得到一个有逐点语义信息的参考点云,接下来反过来从片段内的点出发匹配参考点作为语义, 之后在片段内用 DBSCAN 算法进行聚类(将最密集的聚类中最接近平均值的特征作为片段语义)达到降噪和规避模式崩溃的效果, 以上三步可参考上图中间, 也就是空间上每个片段只存储一个特征</li>
</ol></li>
<li>在完成语义存储后, 接下来的任务就是构建场景模型, 本文的抽象数据结构是主流的拓扑图, 但在设计上有一些 trick , 准确地说应该是分层图
<ol type="1">
<li>其中 <span class="math inline">\({\cal N}\;=\;{\cal N}_{S}\;\cup\;{\cal N}_{F}^{\;}\;\cup{\cal N}_{R}\;{ {\cup}}\;{\cal N}_{O}\)</span> 其中 s 下标是根节点, 其他则是 floor, room, object 的简称</li>
<li>类似的, 边集合定义为 <span class="math inline">\({ \mathcal{E}}={ \mathcal{E}}_{S F}\cup{\mathcal{E}}_{F R}\cup{\mathcal{E}}_{R O}\)</span> ,也就是自上到下的树状关系</li>
<li>以上的定义都比较常识化, 接下来讨论具体的实现:
<ol type="1">
<li>floor: 对目前已有片段的点云画出高度上的直方图, 然后寻找一些峰值(也就是找到点相对最多的高度), 具体来说, 只选择超过最高峰 90%或以上的峰值；用 DBSCAN 选择每个片段点云中排名最高的两个峰, 用常识想, 应该其中最密集的高度是楼层底面或者天花板; 对最后得到的所有候选高度(存储为一个向量)排序, 文章假设每两个连续的高度对是天花板和地板的高度</li>
<li>room: 基于划分好的层级, 画一个 2d 鸟瞰直方图, 由于一般墙壁处是最密集的, 用一个阈值就可以分离出大概, 然后用一个 EDF 加上分水岭算法完善分割; 同样基于常识, 房间应该有一些语义信息, 将一些观察帧用于嵌入, 用 k-means 方法选出 k 个代表；推理时, 将一系列常见房间类别输入 clip 编码, 然后将这些编码和之前的房间代表信息计算余弦相似度, 这里的代表其实是个双关, 每个房间有 k 个代表, 这些代表每人一票投给与其最类似的房间种类, 然后根据票数或者投票分数决定房间种类</li>
<li>object: 得到房间划分后, 我们其实就能知道之前的片段各自落在什么房间, 而对不落在任何房间里的对象, 将其与欧几里得距离最小的房间相关联, 类似之前的工作, 这部分也会进行重叠度高对象的合并(空间标准前文写过, 语义标准是对封闭词汇表的查询, 或者说分类任务, 有相同标签输出), 每个对象存储自己的 3d 点云,片段信息, 特征和最大得分的标签</li>
<li>互动图: 对机器人来说, 很重要的是整个场景中物件的可交互性, 在本文的模型里, 还涉及对跨层交通的标注, 这使用一个 Voronoi graph(下文简称 v 图)实现; 在此前我们得到了各个楼层的地图, 将相机姿势作为一个个点投影到各层平面, 假设这些轨迹点的两两连线周围(有点像轨迹的描边)是可通行的, 此外, 根据高度范围 <code>[ymin + δ1, ymin + δ2] 其中ymin表示楼层内的最低点高度, 而两个偏移是经验值</code> 的点画出障碍物地图; 对姿势区域图和楼层平面区域图做并集并减去障碍物区域图, 就得到了每层的自由空间图; 对跨层交通(楼梯), 将分类为楼梯的片段上的相机姿态点连起来, 然后寻找上下两层中与楼梯最近的点, 将这些点都连起来, 就得到了跨层区域</li>
</ol></li>
</ol></li>
<li>完成以上 3 步后, 现在我们已经得到了完整的语义地图, 对导航任务, 使用 LLM 将其分解为 3 个子任务, 也就是楼层、房间和对象, 分解后是一个常见的处理； 嵌入查询语句并通过比较余弦相似度选择候选</li>
</ol>
<p><img src="/assets/ml/image-7.png" /> <img src="/assets/ml/image-9.png" /> <img src="/assets/ml/image-8.png" /></p>
<div class="note info"><ul>
<li>分水岭(Watershed)算法: 广泛应用于图像处理的分割技术, 特别用于图像的边缘检测和区域分割</li>
<li>欧几里得距离场（Euclidean Distance Field, EDF）: 在一个给定的空间中, 欧几里得距离场为每个点分配一个值, 这个值是该点到某个特定形状（如物体边界或目标点）的最短距离</li>
<li>Voronoi graph: 一种用于将空间划分为离散区域的图形表示方法, 其分割出的一个个单元是泰森多边形</li>
</ul>
</div>
<h3 id="实验">实验</h3>
<p>语义分割上, 用 mIOU 和 FmIOU 评估效果, HOVSG 对比基线模型有不错的提升, 作者将其归功于合并策略使用逐点计算的特征以及聚类算法；此外使用掩码特征的加权和来降低背景图像的影响<br />
对于房间分类，作者比较了基于使用模型预测的房间内物体分类和真实分类数据为输入的llm预测和本文方法(特权和非特权), hovsg战胜了非特权与基于gpt 3.5的特权方法，惜败于特权gpt4<br />
对于对象语义信息, 提出一种新的度量方法 <span class="math inline">\(\mathrm{AUC}_{k}^{t o p}\)</span>, 也就是基于类别(为了通用性横坐标设置为k%形式)画出 top-k 的准确率曲线， 并计算与坐标轴围成的面积</p>
<p><img src="/assets/ml/auc.png" /></p>
<div class="note info"><ul>
<li>groundtruth: 一般指机器学习样本中的真实数据</li>
</ul>
</div>
<h2 id="open-scene-graphs-for-open-world-object-goal-navigation">Open Scene Graphs for Open-World Object-Goal Navigation</h2>
<p>来自 IJRR 2025 / ICRA 2024</p>
<p>本文引入了 <code>OSG Navigator</code>, 一种开放语义的面向对象，有较强泛化能力的导航模型<br />
鉴于这是一篇很新的工作， 其泛化能力也超越了以上的文章, 上文的分层模型虽然做到了层次结构的语义地图，但过于依赖人为规定好的结构, 本文通过LLM等模型提供更强的结构模板，增强对不同环境的适应能力, 此外结构上OSG使用模块化设计, 完全用LLM这样的基础模型组成<br />
略过相关工作部分, 开始概述这个系统:</p>
<ol type="1">
<li>之前的工作(ObjectNav,2022)输入为rgbd信息与无噪声的定位, 而输出是速度命令</li>
<li>在1. 的基础上, 本系统拓展到了开放世界, zero-shot任务,面向现实考虑,输入只限于RGB,输出则是线/角速度, 而代理部分接受自然语言的开放词汇表查询</li>
<li>本文将上述定义的任务视为一个物体和地点中心的POMDP(<code>Partially Observable Monte Carlo Planning 部分可观察马尔可夫决策过程</code>) 对此定义以下符号 $ s_a , s_r , s_o, s_e, o, r,  , O , $ 分别是: 代理状态，空间地点状态, 物体状态, 物体/地点的关系(edge), MOVETOOBJECT(动作), MOVETOREGION(动作), 过渡， 观察， 目标(开放词汇的描述)<br />
</li>
<li>对于这个问题模型，使用基础模型来对其最最大似然估计, 并由llm选取行动策略</li>
<li>具体的模块分为: LLMs,GNMs(图神经网络模型),VFMs(视觉基础模型, 即有完成通用性视觉任务能力的模型) for Visual Question Answering (VQA 视觉问答模型) , VF for Open-set Object Detection</li>
<li>任务流程上: 开放场景图作为基础, 被高层模块调用进行推理，产生图像子目标来指导底层导航模块, 细节上, 映射器会从图像中提取出描写其中突出物体的文本, 这些描述数据送给LLM用于更新场景图, 推理器则使用LLM从场景图中提取子目标并规划路径, 所谓的路径其实是一个图像目标序列，也就是说其路径点就是图像的经过裁剪的部分(即图像中的某个物体), 由于这些裁剪的物体是中间路径上的, 导航区能使用这些子目标具体地产生动作指令， 同时在导航过程中会动态更新场景与导航计划</li>
</ol>
<p><img src="/assets/ml/image-10.png" /></p>
<h3 id="场景图">场景图</h3>
<p>其场景图大体上可以表示为以下的类似yaml的形式，比起只有楼层、房间、物体三级的分层图以及没有分层关系只有物体间关系的双重图都有着更强的抽象能力<br />
可以看到，其并非是隐变量而是显式的文字描述，这就意味着也可以根据经验提供一些预设语义，本文中使用LLM来生成<br />
下面介绍细节</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">Floor:</span></span><br><span class="line">  <span class="attr">layer_type:</span> <span class="string">Region</span></span><br><span class="line">  <span class="attr">layer_id:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">contains:</span> <span class="string">Room</span> <span class="string">,</span> <span class="string">Corridor</span></span><br><span class="line">  <span class="attr">connects_to:</span> <span class="string">Stairs</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Room:</span></span><br><span class="line">  <span class="attr">layer_type:</span> <span class="string">Place</span></span><br><span class="line">  <span class="attr">layer_id:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">has:</span> <span class="string">Object</span></span><br><span class="line">  <span class="string">connects_to:Entrance,Room,Stairs</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>节点定义: 可分为4个抽象类, 除了Objects外其他3种都可以视为地点(location)类:
<ol type="1">
<li>Objects: 占据局部空间的对象</li>
<li>Places(地点): 较为细粒度的空间，例如对民居来说可以是房间和走廊</li>
<li>Connectors: 连接相邻空间的局部元素,同时有物体和地点属性, 例如大门, 在语义上可以作为路径点或者探索边界</li>
<li>Region(区域): 比较粗粒度的空间, 可以包含很多局部地点, 例如楼层</li>
</ol></li>
<li>有向边定义,也可以分为4类:
<ol type="1">
<li>Proximity: 空间上的近邻关系, 端点是物体或者连接体, 可用来构建上下文关系</li>
<li>Connectivity: 即可达性关系，端点可以是任意节点,</li>
<li>Inclusion: location和object的单向关系, 表示地点内存在物体</li>
<li>Hierarchy: region/place-region/place的关系, 捕获层级关系, 源节点必须是区域节点，且目标节点必须是树中下一个较低级别的位置节点(region/place)</li>
</ol></li>
<li>OSG层次定义, 以下是自底向上的顺序:
<ol type="1">
<li>Objects Layer: 存放独立的物体, 以及它们之间的关系,
<ol type="1">
<li>每个其中的节点保存四个属性:
<ol type="1">
<li>开放词汇标签, 一般就是物体的名字 <span class="math inline">\(\mathcal{v}_{label}^o\)</span></li>
<li>对物体外观的开放词汇文本描述, <span class="math inline">\(\mathcal{v}_{desc}^o\)</span></li>
<li>独特的节点id, <span class="math inline">\(\mathcal{v}_{id}^o\)</span></li>
<li>图片剪切, <span class="math inline">\(\mathcal{v}_{img}^o\)</span></li>
</ol></li>
<li>除了属性以外, 还会存储<code>is near</code>边组成的数组, 例如对有k个近邻的节点形如 <span class="math inline">\([(v_{l a b e l}^{o},\ \ v_{d e s c}^{\mathcal{o}})_{0},\ \ ...,\ (v_{l a b e l}^{\mathcal{o}},\ \ v_{d e s c}^{o})_{k-1}]\)</span>, 这个数组可以作为用于区分object的特征<br />
</li>
</ol></li>
<li>Places and Connectors Layer: 捕获细粒度的空间位置信息，并描述场景中位置之间的连通性,在导航期间，机器人的状态被指定为该层的位置节
<ol type="1">
<li>每个<code>Place</code>节点 <span class="math inline">\(v^p\)</span> 有三个属性:
<ol type="1">
<li>类别信息, <span class="math inline">\(\mathcal{v}_{cls}^p\)</span> , 来自OSG架构，形式是字符串</li>
<li>对地点(place)的开放词汇文本标签, <span class="math inline">\(\mathcal{v}_{label}^p\)</span></li>
<li>独特的节点id , <span class="math inline">\(\mathcal{v}_{id}^p\)</span></li>
</ol></li>
<li><code>Place</code>节点的边集包括:
<ol type="1">
<li><code>connects to</code> 边(下文也称连接边)指向 <code>Place/Connector</code>, 表示联通关系</li>
<li><code>contains</code> 边(下文也称包含边)指向 <code>Place</code> 内的物体, 即Place的特征可表示为它<code>contains</code>的物体的特征(标签和描述)集</li>
</ol></li>
<li><code>Connectors</code>节点不同于地点节点的是没有<code>包含边</code>指向物体节点(或者说它自己就是物体节点), 但是可以通过<code>连接边</code>指向其他地点</li>
</ol></li>
<li>Region Abstract Layer(可选): 更加通用的抽象空间划分, 例如对多层的住房场景可以是不同楼层, 从这层开始， 对高层对低层只用<code>包含边</code>, 但是可以被低层的<code>连接体</code>用<code>连接边</code>指向，详情可见下图
<ol type="1">
<li>属性只有 <span class="math inline">\(\mathcal{v}_{label}^i\)</span> , <span class="math inline">\(\mathcal{v}_{id}^i\)</span> , 含义类似上文其他节点</li>
</ol></li>
</ol></li>
</ol>
<p><img src="/assets/ml/image-11.png" /></p>
<h3 id="地图生成和定位">地图生成和定位</h3>
<p><img src="/assets/ml/image-12.png" /> Mapper职能如上图所示, 接下来分组件介绍其生成和更新OSG的方式</p>
<h4 id="自动生成osg">自动生成OSG</h4>
<p>为了泛化能力， 本模型的环境图结构也由模型来自动生成, 输入一个环境的简单描述， 生成器就会产生一个OSG架构<br />
具体地说, OSG以json的形式被生成, 过程分为三个Pipeline</p>
<ol type="1">
<li>描述生成: 让llm生成无结构, 尽可能长, 包含典型空间抽象关系的自然语言描述</li>
<li>规范化(Canonicalise): 让LLM将上一步的描述转化为规范图表示, 此外这一步会让LLM将节点和边定义为上面提到的类型, 形式上类似于<code>[Abstraction1, Relation, Abstraction2]</code></li>
<li>验证: 根据OSG的结构要求检查规范图, 通过一个测试类检验其结构是否满足上一节定义的OSG， 如果不满足，将检测到的错误添加到1. 中的文字描述, 并让LLM修正生成的图, 循环直到满足条件，将其以json格式返回</li>
</ol>
<h4 id="图像解析-image-parser">图像解析 Image Parser</h4>
<p>使用VFMs解析视觉输入, 开放集的物体检测模型来区分标记场景元素, 以及一个VQA把图像观察翻译为密集的语言描述(对于Places, Objects Connectors), 过程为:</p>
<ol type="1">
<li>解析地点: 将机器人周边的RGB图像输入VQA
<ol type="1">
<li>首先提问哪种地点能最好地描述观察帧</li>
<li>得到类别后，继续提问从而获得一个更详细的标签来反映这个地点的语义信息</li>
</ol></li>
<li>物体/连接体解析: 探测器是区分不出本文自己定义出的两类物体的, 但可以得到基于自然语言的物体信息,将这些信息输入LLM进行分类, 然后让VQA模型产生对其图像裁剪的描述，使用 <code>is near</code> 边连接两个体积盒距离低于门槛值的一对节点</li>
<li>目标探测: 使用VQA或者LLM处理上面得到的数据, 如果有和目标很相似的物体，则直接让代理导航过去</li>
</ol>
<h4 id="状态评估">状态评估</h4>
<p><img src="/assets/ml/image-13.png" /> 输入上一步得到的文本描述与已有的OSG, 输出目前的机器人状态即占据的Place节点<br />
流程如上图所示, 其中(P,O,C)指Places, Objects, Connectors三种对象, LLM第一次用于提取一些候选Place,这些候选对象根据和上一个s的距离被贪心地匹配, 匹配过程中也有LLM根据两者的描述等信息决定是否匹配成功(优先考虑较大的物体)</p>
<h4 id="osg-更新">OSG 更新</h4>
<p>将来自图像解析器的观察结果递增地集成到OSG中, 这部分的难点主要在于门槛的设定， 即更新和新建的选择, 在本文定义的OSG还有个问题就是节点间关系的选取</p>
<p><img src="/assets/ml/image-14.png" /></p>
<p>过程总结如下:</p>
<ol type="1">
<li>数据关联: 本文认为一个物体的上下文(周边的物体)是其独特的标志,</li>
</ol>
<h4 id="基于概率的osg">基于概率的OSG</h4>
<h3 id="推理和控制">推理和控制</h3>
<h3 id="实验-1">实验</h3>
<h1 id="vision-language-action-models">Vision-Language-Action Models</h1>
<h2 id="large-vlm-based-vision-language-action-models-for-robotic-manipulation-a-survey">Large VLM-based Vision-Language-Action Models for Robotic Manipulation: A Survey</h2>
<h3 id="前言-1">前言</h3>
<p>机器操控, 作为机器人学和具身智能的关键领域, 需要精确的动力控制以及内置的视觉和语义信息理解能力的智能, 其传统做法一般局限于使用预定义的动作以及严格的控制策略, 泛用性较为有限<br />
近年来随着算力和研究方法的进步, 基于大量图像文本数据上预训练的大型视听语言模型(VLM)以及基于 VLM 增加了动作能力的 VLA, 可以称为一种新的技术趋向<br />
所谓的 VLA 其实是一件很有野心的事, 它不但有对图像、文本这两种信息量最大的载体的理解能力, 还要有做出合适行动的机械系统, 这几乎涉及了 cv, nlp, em-ai 等 cs 大部分的前沿领域, 理论也相当庞杂<br />
VLA 具体可以定义为:</p>
<ol type="1">
<li>使用 VLM 理解视觉观察和自然语言指令</li>
<li>进行推理并直接或间接地帮助动作指令的生成</li>
</ol>
<p>又可以分为:</p>
<ol type="1">
<li>Monolithic Models: 单片模型, 也就是集成度高的模型
<ol type="1">
<li>Single-system models: 将环境理解, 视觉感知, 语言理解, 机器状态认知, 动作生成都统一到一个模型</li>
<li>dual-system models: 将认知环境和动作生成分为两个任务, 分别让 VLM 和一个 action expert 去做, 这是因为相比前者, 后者时效性更强</li>
</ol></li>
<li>Hierarchical Models: 分层模型, 耦合度最低的模型, 一般有结构, 中间输出可解释的中间产物, 例如计划模块产生 <code>keypoint detections</code>, <code>affordance maps</code>, <code>trajectory proposals</code> , 交给策略模块来产生动作; 这样的解耦让不同模块可以并行训练, 使用不同的 loss 和优化方式</li>
</ol>
<div class="note info"><ul>
<li><code>Keypoint Detection</code> : 计算机视觉中的一种技术, 旨在识别图像中具有显著特征的点</li>
<li><code>Affordance Maps</code> : 一种表示对象与环境之间交互可能性的图像或图形</li>
<li><code>Backbone</code> : 一个神经网络结构的基础部分, 主要用于特征提取。Backbone 是整个模型的核心组件, 负责从输入数据（如图像）中提取重要的特征信息</li>
<li><code>Internet-scale</code> : 表示很大的数据或者整体性能消耗的规格</li>
</ul>
</div>
<h3 id="背景知识">背景知识</h3>
<p>得益于用于跨领域和多模态能力的 VLM 的出现, 现代的 VLM 模型能执行对能力需求更加多样的任务例如自动驾驶, 图形用户界面交互等<br />
这些模型往往由一个视觉编码器, 一个用于将视觉特征嵌入到文本的投影器(projector), 以及一个大语言模型组成; 这其中, 最为重要的是 <strong>大</strong> 模型为其带来的泛化能力, 如 GPT4 这种 LLM 能提供极强的过滤输入, 降噪, 处理模糊指令的能力, 从而为 VLA 定下基础, 也就是说, VLA 相当重视泛化、通用性质的能力</p>
<p>V、L、A 可以视为三种不同的任务, 早期的模型往往会将三者分开, 这样的好处是可以并行训练, 但缺点是可能降低一些理解和推理能力; 最近的模型一般会加强集成度, 例如除了传统的大规模(<code>Internet-scale</code>)训练资料外, 把机器人的动作也转化为文本标记并放入训练语料库中, 这能让 action 作为语言任务被语言模块理解, 增强整个模型的理解能力, 其他一些使用动作资料的模型也取得了较好的效果</p>
<p>接下来从单片/多片的角度讨论两种模式的发展趋势</p>
<h3 id="monolithic-models-单片模型">MONOLITHIC MODELS 单片模型</h3>
<h4 id="single-system-models">Single-system Models</h4>
<p>其经典范式为 <code>Autoregressive Decoding</code>, 将机器人的连续动作空间离散化为 token 序列, 模型能够序列化地生产动作 token, 再由一个 de-tokenizer 转化为具体动作。较为知名的模型有 <code>RT series</code> , <code>OpenVLA</code></p>
<h5 id="model-performance-enhancement">Model Performance Enhancement</h5>
<ol type="1">
<li>认知模态(Perception Modalities):
<ol type="1">
<li>3d 感知(perception): 一般能从传感器得到的数据就是 2d 图片, 为了构建 3d 的地图模型, 可以模拟环境并根据图片画出点云; 或者根据图片及其深度信息, 画出自我中心的地图</li>
<li>4d 感知: 多出来的 d 指的是轨迹, 也就是时空序列信息, 例如将动作或者轨迹信息添加到图像中, 从而增强模型的时空推理能力</li>
<li>触觉和听觉（Tactile and auditory）感知: 触觉信息可以使用视觉编码器, 听觉信息可以使用专用的编码器, 且两者都需要专用的数据集, 这两种能力均可以与语言模块对齐, 然后得到接受听觉触觉指令的能力</li>
</ol></li>
<li>推理能力: 以下简单介绍一些相关工作
<ol type="1">
<li><code>ECoT</code>: 生成一个推理链, 将高层任务规划与视觉特征相结合, 输出最终行动</li>
<li><code>CoT-VLA</code>: 引入视觉链式推理, 通过预测代表计划状态的子目标观察, 增强推理能力</li>
<li><code>LoHoVLA</code>: 采用“层次闭环控制 <code>Hierarchical Closed-Loop Control</code> ”机制, 解决规划错误、行动失败和外部干扰等问题, 适用于长周期任务</li>
<li><code>ReFineVLA</code>: 通过“选择性迁移微调 <code>Selective Transfer Fine-Tuning</code> ”策略, 仅微调上层, 增强多模态理解</li>
</ol></li>
<li>泛化能力: 也就是处理各种场景需求的能力
<ol type="1">
<li><code>UniAct</code>: 定义一个 <code>Universal Action Codebook</code>, 将所有机器人行动抽象到有限的类别中, 增强泛化能力</li>
<li><code>ReVLA</code>: 使用可逆的训练策略, 缓解遗忘问题</li>
<li><code>HybridVLA</code>: 使用一个 <code>Collaborative Action Ensemble</code> 机制, 融合 <code>diffusion and autoregressive decoding</code>, 针对任务选取不同策略</li>
<li><code>VOTE</code>: 使用一种 <code>Ensemble Voting</code> 机制, 将过去的动作预测根据与当前预测的相似性进行分组, 并对大多数集进行平均处理, 从而生成更稳健的动作输出</li>
<li>也有一些模型在物理规律层面进行学习</li>
</ol></li>
</ol>
<h5 id="inference-efficiency-optimization">Inference Efficiency Optimization</h5>
<p><code>Inference Efficiency Optimization</code> 推理效率优化 : 机器人对及时性(控制频率)往往有一定要求, 因此模型的推理效率优化也是一个重要的方向</p>
<ol type="1">
<li><code>Architectural Optimization 体系优化</code>: 一些常用的方法用, 跳过层级, 早停止等, 进阶的有一些方法会动态计算哪些层级是关键的, 从而激活关键层完成推理; 此外也有方法会逐步减少视觉 token, 也就是修建掉那些与指令生成无关的 token, 再加上注意力机制, 这甚至能同时提高指令准确性</li>
<li><code>Parameter Optimization 参数优化</code>: 也就是压缩模型的大小, 通过蒸馏的模型提高效率; 或者使用 tokenizer 将高维动作指令转化为 token 的序列从而减少模型复杂度</li>
<li><code>Inference Acceleration 推理加速</code>: 即加速动作解码, 可以使用专门优化过的 action head, 一次生成一个动作序列; 通过某种方式实现并行运算等; 也可以单纯地(但有选择地)放开限制, 接受一些“不完善”的推理结果</li>
</ol>
<div class="note info"><ul>
<li><code>Distillation-Aware Training</code>: 一种优化训练方法, 旨在通过知识蒸馏（knowledge distillation）技术提高模型的性能和效率。这一过程通常涉及将一个大型、复杂的“教师”模型的知识转移到一个较小的“学生”模型中, 以便在保持性能的同时减少计算资源和加速推理</li>
<li><code>action head</code>: 用于将模型的输出转换为具体的动作或决策的组件</li>
</ul>
</div>
<h4 id="dual-system-models">Dual-system Models</h4>
<p>双系统主要是为了解决动作生成速度与推理速度要求不同的问题, 引入了一个动作专家模块来对系统解耦, 而其与分层模型不同的是, 不会产生可解释的中间输出<br />
<img src="/assets/ml/image.png" /></p>
<h5 id="cascade-based-methods">Cascade-based Methods</h5>
<p>串联的方法中, 负责推理部分(称为高级 <code>high-level</code> )的系统一般使用 VLM 处理多模态的输入, 提取语义并产生动作 <strong>计划</strong> 输出, 这些会被编码为某种中间形态, 然后由低级(<code>low-level</code>)系统解码为具体的动作指令<br />
由于在双系统中, 认知和行为是解耦的, 行动可以使用一个不同的模型, 例如 <code>diffusion transformer</code>, <code>Behavioral Cloning transformer</code><br />
此外, 还有很多种改进方法:</p>
<ul>
<li>再加入一个视频生成模块来预测未来的帧, 并使用 <code>diffusion action expert</code></li>
<li>从人类演示中提取场景喂给 LLM 来生成可解释的行为树, 并转化为底层行为</li>
<li>将 VLM 与扩散策略模型整合, VLM 会发射一个 TOKEN 控制是否允许动作生成</li>
<li>使用预训练的卷积残差网络增加性能</li>
<li>将 action expert 集成到 VLA 主干中, 两者可以复用一些组件, 协调工作</li>
</ul>
<div class="note info"><ul>
<li><code>Cartesian Actions</code>: 机器人学和控制系统中使用的一个概念, 指的是以笛卡尔坐标系为基础的运动或操作。这种动作通常涉及到机器人的末端执行器（如机械手臂的抓手）在三维空间中移动或执行任务</li>
<li><code>convolutional residual</code>: 卷积神经网络（CNN）中使用的架构设计, 最著名的实现是 ResNet（Residual Network）。这一设计理念旨在解决深层网络训练中的退化问题, 即随着网络层数增加, 模型的性能反而下降; 引入残差连接（<code>residual connections</code>）, 模型可以学习到输入与输出之间的“残差”而不是直接学习目标输出</li>
</ul>
</div>
<h5 id="parallel-based-methods">Parallel-based Methods</h5>
<p>上图中展示了一种共享注意力的架构, 它受到 <code>mix-of-experts (MoE)</code> 启发, 在注意力层中, VLM 与动作模块进行 token 上的交互, 过程中, 输入的视觉文本信息, 噪声, 机器人特定的输入在共享的注意力层中交互, 从而提高了任务效果<br />
由于这种架构的低耦合性, 它可以实现字面意义上的 MoE, 也就是对每个子任务都让一个“专家”去做, 其中一个典例称为 <code>π0</code>, 其主干网络是 VLM, 为了处理机器人特定的输入输出, 它使用一个独立的权重集合和一个流匹配(<code>Flow Matching(FM)</code>)的动作模块<br />
π0 有一些变种, 例如增加显式推理, 基于最近推理生成动作两种模式, 可以根据需求切换; 降低信息力度; 防止动作模块的梯度流入 VLM 以保持 VLM 的知识优势; 增加动作 token 化方法从而自回归训练等; 其他的变种也一般是增加某个维度的输入或者通过复用注意力信息提高性能等常规优化</p>
<div class="note info"><ul>
<li><code>Normalizing Flows(NFs)</code>: 通过一系列概率密度函数的变量变换, 将复杂的概率分布转换为简单的概率分布, 并通过逆变换生成新的数据样本</li>
<li><code>Continuous Normalizing Flows(CNFs)</code> 是 <code>Normalizing Flows</code> 的扩展, 它使用常微分方程(ODE)来表示连续的变换过程, 用于建模概率分布</li>
<li><code>Flow Matching(FM)</code> 是一种训练 <code>Continuous Normalizing Flows</code> 的方法, 它通过学习与概率路径相关的向量场(<code>Vector Field</code>)来训练模型, 并使用 ODE 求解器来生成新样本</li>
</ul>
</div>
<h3 id="hierarchical-models-分层模型">HIERARCHICAL MODELS 分层模型</h3>
<p>对于很大规模的任务, 由于算力, 存储空间等方面的要求都较高, 更低耦合的架构如分层模型较为常用, 例如长期推理, 空间抽象, 动作分解等<br />
这些模型一般由高等级的 planner, 低等级的 policy 等组成, 计划期接受指令和观察, 转化为中间产物, policy 接受中间产物, 产生动作序列或底层指令<br />
相比单片模型, 它能实现更复杂的组合, 甚至可以只有计划器; 相比其单片双系统, 它的中间产物是显式（可解释）的</p>
<h4 id="planner-only">Planner-Only</h4>
<p>可分为:</p>
<ul>
<li><code>Program-based Methods</code>: 计划器生成中间程序, 即直接可执行的程序或者辅助程序, 辅助程序一般用于辅助对任务策略的制定</li>
<li><code>Keypoint-based Methods</code>: 标记出一些关键点, 例如机器臂的可抓取点, 导航任务的路线节点等, 这些提取出来的点可以视为对问题的一种抽象, 从而输入给通用模型如处理, 也可以用作轨迹生成</li>
<li><code>Subtask-based Methods</code>: 一般用于较大的 VLM, 接受一个抽象的隐式指令, 并输出详细的文字命令, 实际部署中可能还会需要一个控制策略。由于该种方法抽象程度较高, 可以使用一些通用模型进行任务分解或者规划</li>
</ul>
<h4 id="plannerpolicy">Planner+Policy</h4>
<p>其分类上和前一类较为类似</p>
<p>可分为:</p>
<ul>
<li><code>Keypoint-based Methods</code>: 一般用 LVLM 产生一些关键点, 或者关键路径, 但这些信息将会交给低级策略模块, 用于生成指令; 例如在导航任务中, 对 生成的关键点进行排序, 并将这个有序路径用于之后的指引; 此外也可以用 LLM 为关键点赋予 cost, 用于确定最佳路径; 也有方法会将关键点赋予互动性上的标注, 用于生成控制指令。总的来说, 一般关键点会被赋予帮助决策的一些信息, 用于最后产生指令</li>
<li><code>Subtask-based Methods</code>: 这种方法主要的工作在于如何划分子任务, 而对具体的子任务执行者则有很高的灵活性。例如对模糊的文字指令, 将其转化为一系列原子命令; 也有模型分出空间感知任务, 使用点云增强空间感知; 或者让高级模型划分任务, 低级扩散策略模型具体实现, 且这样的划分可以继续拓展, 例如再加一个中间的 skill 层辨识一些可重复使用的行动控制底层的执行者; 划分后的子任务也可以一步流水线执行从而增加效率; 这方面有非常多的类似变种</li>
</ul>
<div class="note info"><ul>
<li><code>Embodiment-Agnostic Affordance Representation</code>: Affordance 前文介绍过, 是对可交互性的标识, 而 Embodiment-Agnostic 指的是不依赖于机器人形态或者物理特性, 可以理解为通用的可互动性</li>
</ul>
</div>
<p><strong>Monolithic vs Hierarchical:</strong></p>
<ol type="1">
<li>两者的输入输出是一致的, 主要区别为统一化/模块化的内部结构, 其优缺点和这两种常见的结构是类似的</li>
<li>另一个关键区别是中间产物的可解释性, 整体模型的中建五不可解释, 但更方便机器学习一些人类可能无法理解的特征; 分层模型输出可解释的中间数据, 这对需要兼容性, 可解释性的操控领域可能更好</li>
</ol>
<h3 id="其他前沿领域">其他前沿领域</h3>
<ul>
<li>RL: 与 LLM, VLM 不同的是, VLA 的问题更加长周期, 其最大的问题在于难于产生基于规则的奖励函数, 可能人类也不知道怎么做是更好的, 这方面没有特别好的解决方法, 一般将学习过程作为密集奖励或者以视觉上的近似成功率作为奖励;
<ul>
<li>此外, 由于模拟环境现状, 在线学习效率有限, 一些方法会把在线, 离线方法混合起来, 例如离线用 q 学习, 在线用 <code>Soft Actor-Critic</code> 提高效率又或者引入人类监督</li>
<li>部分方法会只把 RL 用作数据引擎来增强泛化能力, 例如先用 HIL-SERL 训练, 然后通过 sft 将训练成果提取融入给主要模型</li>
</ul></li>
<li>Training-Free Methods: 通常利用模块化和可扩展的设计来改进现有的 VLA 架构, 而无需训练, 例如改变触发机制, 行为和视觉都稳定时不需要完全解码, 可以选择性重用之前的 visual tkoens; 其他的类似方法也是对于简单, 复用性强的任务使用低成本的方式计算, 或者通过一些变换方式压缩动作序列等负担较大的数据提高效率</li>
<li>Learning from Human Videos: 也就是将人类行为与机器行为对齐, 从而提高机器人行为的表现</li>
<li>World Model-based VLA: 世界模型(模拟环境), 允许一定程度上对未来状态的预测, 从而让 agent 能根据预测修正自己的策略, 并且世界模型也可以同步改进</li>
</ul>
<div class="note info"><ul>
<li><code>Robotic Process Reward Model (RPRM)</code>: 一种用于强化学习和机器人控制的框架, 为机器人在执行特定任务时的行为提供奖励信号, 进而不断优化其行为模式</li>
<li><code>HIL-ConRFT（Hardware-in-the-Loop Control with Reinforcement Feedback Training）</code>: 结合了硬件在环（HIL）测试和 RL 的控制方法, 旨在优化复杂系统的控制策略, HIL 测试允许在真实硬件上进行控制算法的验证和优化, 通过将模拟环境与实际硬件连接, 确保控制系统在真实条件下的有效性, 结合强化学习的反馈机制, HIL-ConRFT 可以根据系统的表现持续优化控制策略。通过从环境中获取奖励信号, 系统能够学习最佳操作策略</li>
<li><code>HIL-SERL（Hardware-in-the-Loop Sample-Efficient Reinforcement Learning）</code>: 是一种结合了硬件在环（HIL）测试和样本高效强化学习（Sample-Efficient Reinforcement Learning）的框架, 旨在优化机器人和自动化系统的控制策略</li>
<li><code>SFT（Supervised Fine-Tuning）</code>: 通常用于在预训练模型的基础上进行进一步的监督学习, 模型首先在大规模数据集上进行预训练, 以学习通用的特征和表示。然后, 在特定任务的数据集上进行微调, 使模型能够针对特定任务进行优化</li>
</ul>
</div>
<h3 id="vla-的特点">VLA 的特点</h3>
<ol type="1">
<li>多模态:
<ol type="1">
<li>Shared Embedding Space: 视觉, 文字信息会被一起嵌入一个共享的语义对齐空间, 这个共享的语义空间能减少转码过程的损失, 提供更好的推理能力, 理解能力</li>
<li>Multimodal Token-Level Integration: 通过 transformer 可以将连续的视觉文字等信息转化为离散序列, 提供了对这些不同类型的信息的综合性理解能力, 减少语义转化损失</li>
<li>Comprehensive Modal Compatibility: 得益于强大的 VLM, VLA 天生有着与具体模态无关的语义对齐能力, 新的传感器信息, 例如声音, 点云等信息都可以在不影响主干网络的情况下加入</li>
</ol></li>
<li>Instruction Following
<ol type="1">
<li>Semantic Instruction Grounding</li>
<li>Task Decomposition and Collaboration</li>
<li>Explicit Reasoning via Chain-of-Thought: 链式的思考能力能让 VLA 能一定程度上预测未来的图像, 减少了短视现象</li>
</ol></li>
<li>Multi-Dimensional Generalization
<ol type="1">
<li>Cross-Task Generalization: 相比传统模型任务特化的训练过程, 很多 VLA 模型有着 zero-shot 或者 few-shot 级别的泛化能力, 有时可以直接用到没有特别训练的领域</li>
<li>Cross-Domain Data Generalization: 相比传统模型, 多模态的 VLA 可以接受各种各样的数据, 从而得到相应的泛化能力</li>
<li>Cross-Embodiment and Sim-to-Real Generalization: 由于现代 VLA 的解耦性质, 其经过抽象的规划起和底层动作解码器可以互相解耦, 也就是不同的机器人形态也可以被泛化</li>
</ol></li>
</ol>
<h3 id="数据集和基准测试">数据集和基准测试</h3>
<ol type="1">
<li>真实世界机器人数据集: 尽管理论上讲真实世界是检验以及训练的最好数据, 但由于条件限制, 往往不够全面或者丰富</li>
<li>模拟数据集: 其优点是可以针对想要特化的能力调整模拟环境, 而缺点则是相比现实可能有较大差距, 导致可迁移不足</li>
<li>人类行为数据集: 对一些特定任务, 例如物体识别, 任务分解等较为实用</li>
<li>具身数据集: 强调主动感知, 推理和执行, 提供严格的协议来评估通用 VLA 中的高级语义规划</li>
</ol>
<h3 id="总结和展望">总结和展望</h3>
<ol type="1">
<li>数据集和基准测试: 当前的真实数据稀少, 模拟环境存在缺陷, 可能需要更好的结合方法; 基准测试需要增加长期性, 且更丰富的指标</li>
<li>记忆机制和长期规划: 大多数当前的 VLAs 依赖于逐帧推理, 产生了短视问题, 需要增加记忆以及未来预测能力</li>
<li>3D&amp;4D 感知: 当前的主要输入形式依旧是 2d 图片, 如果能增加输入维度(空间与时间维度)或许能增强模型能力</li>
<li>移动操纵: 鉴于现实任务特点, 导航能力和交互能力应该更加集成</li>
<li>多代理合作: 现实有很多协作任务, 且增加代理数量可以更灵活地划分子任务</li>
<li>开放世界终身学习: 大部分 VLA 模型基于静态数据集, 由于硬件以及当前软件性质难以长期积累知识</li>
<li>模型效率: 在机器人平台的性能往往受限, 因此需要平衡存储, 计算成本与模型表现</li>
</ol>
<h2 id="π0-a-vision-language-action-flow-model-for-general-robot-control">π0: A Vision-Language-Action Flow Model for General Robot Control</h2>
<p>VLM 大模型的发展, 不仅在通用能力上取得了进步, 同时由于海量数据带来的能力, 在一些专业任务上也有应用空间<br />
来到 VLA 领域, 想要融合 VLM 并得到一定的行动能力, 有几个挑战:</p>
<ol type="1">
<li>这样的研究需要很大规模的数据和训练</li>
<li>需要能有效从海量数据中学习的模型架构</li>
<li>需要正确的训练技巧</li>
</ol>
<p>π0 正是为了解决这三个问题的原型模型, 相比其他系统, 其技术特点:</p>
<ol type="1">
<li>跨实体地进行训练</li>
<li>为了提供对复杂动作的生成能力使用动作块体系和流匹配方法</li>
</ol>
<p>最近涌现出一批高质量数据集(关于机器人控制), 但往往总共的时长规模在 10h 左右甚至更少, 而为了尽可能地获取综合能力, 本文使用量 10kh 的演示数据(由研究者自己的数据和一些开源数据补充组成), 除了数量以外, 在涉及机器人的种类、任务类别数、标注数外规模也较大<br />
与其他领域的大模型一样, 极大规模的输入也产生了极强的效果</p>
<div class="note info"><ul>
<li>Broad Generalization: 一个模型或系统在面对新数据或未见过的任务时, 能够有效地适应和推理的能力。这种概念通常在机器学习和人工智能领域讨论, 特别是在评估模型的泛化能力时</li>
</ul>
</div>
<h3 id="模型介绍">模型介绍</h3>
<p>其主干可以说是一个基于 tf 的视觉模型, 将图像输入编码嵌入到语言空间, 但正如很多动作模型一样, 出于任务考虑输入输出数据会增加机器人感知与动作<br />
模型使用条件流匹配(之前写的 <a href="https://thinklive1.github.io/thinklive/48061/#flow-matching">介绍博文</a>)来对连续的动作分布建模<br />
模型不依赖特定的 VLM, 为了方便实验中使用 <code>PaliGemma</code></p>
<p>受一个叫 <code>transfusion</code> 的模型(用一个 tf 处理不同类型的输出, 对连续输出使用流匹配的损失函数, 对离散输出使用交叉熵的损失函数)启发, 基于 transfusion, 在工程上(高情商说法), 发现机器人特有的 token 上(即动作与状态), 应用特定的权重集合能提高表现<br />
作为一个生成任务, 技术上具体可以描述为对分布 <span class="math inline">\(p(A_t|o_t)\)</span> 建模, 其中 At 是从 t 下标开始, 长度为 H 的动作序列（动作块）, 文中的 H 为 50, 而观察 o 由 RGB 图像、语言指令和机器人状态(关节角度)组成分别用 I, l, q 表示<br />
虽然输入类别有很多, 但 I, q 都会由编码器以及一个线性投影层投影到 l 的嵌入空间<br />
将损失函数定义为:</p>
<p><span class="math display">\[L^{\tau}(\theta)=\mathbb{E}_{p(\mathbf{A}_{t}|o_{t}),q(\mathbf{A}_{t}^{\tau}|\mathbf{A}_{t})}||\mathbf{v}\theta(\mathbf{A}_{t}^{\tau},\mathbf{o}_{t})-\mathbf{u}(\mathbf{A}_{t}^{\tau}|\mathbf{A}_{t})||^{2}\]</span></p>
<p>其中上标是流匹配的时间步, 下标则是机器人的时间步, <span class="math inline">\(\tau\ \in\ [0,1]\)</span> , 训练时从标准正态分布中采样一个 <span class="math inline">\(\epsilon\)</span> , 令噪声行动 <span class="math inline">\(A_t^\tau = \tau A_t + (1-\tau ) \epsilon\)</span> , 训练目标是让 <span class="math inline">\(\mathbf{v}\theta(\mathbf{A}_{t}^{\tau},\mathbf{o}_{t})\)</span> 与去噪向量场 <span class="math inline">\(\mathbf{u}(\mathbf{A}_{t}^{\tau}|\mathbf{A}_{t}) = \epsilon - A_t\)</span> 匹配, 初始动作输入是一个从标准正态分布中取样的噪声动作</p>
<p>这里先不讨论太多细节, 整体上这是比较标准的条件流匹配方法, 只不过学习的不是直接的动作输出, 而是如何对输入降噪, 最后我们得到的其实是一个和定义出来的降噪向量场尽可能接近的一个基于模型参数的向量场 v<br />
得到向量场后, 推断过程就是做一个积分: <span class="math inline">\({\bf A}_{t}^{\tau+\delta}={\bf A}_{t}^{\tau}+\delta{\bf v}_{\theta}({\bf A}_{t}^{\tau},{\bf o}_{t})\)</span><br />
其中 $ $ 是积分的步长, 这里设 0.1, 由于 $ $ 范围是 <code>[0,1]</code>, 这就意味着一共积分 10 次<br />
由于作者是企业, π0 其实算是一篇技术介绍或者说报告, 原理写得很简略, 后文会结合其他资料阐述 类似 LLM, 本文也将模型分为两个阶段, 预训练阶段让模型尽可能获得泛化能力(包括对物理任务的泛化), 后训练阶段则让模型流畅地执行下游任务</p>
<h3 id="训练与实验">训练与实验</h3>
<p>数据上, 正如前文所说, π0 使用了一组庞大的数据集, 包括一些开源数据与自己的数据, 且与以往数据不同的是, 自己的数据部分复杂度较高, 可以视为一些行为的组合<br />
由于数据组成较为复杂, 因此对不同的数据集来源进行加权, 动作和状态向量(a, q)按最复杂的机器人设置, 对更简单的机器人, 则填零或者掩盖(mask out)掉缺失的维度<br />
此外一个常见的思路是将复杂的任务分解为简单的任务组合, 由于 VLM 赋予了语言能力, π0 可以实现这种程度的语义推断<br />
进一步的实验中, 为了评估语言能力, 对指令进行划分, 只接受整体性指令的模型表现最差, 而接受人类指令和高级 VLM 指令的模型互有胜负, 比没有任务分解的表现好一个阶层<br />
论文还比较了 π0 的无预训练版本和预训练版本以及其他模型(包括这篇博文写过的 ACT), 较为符合常识的是, 对任务类型相似的任务, 预训练能带来更大提升, 但对其他模型, 往往直接从头开始面向任务训练的模型表现最好; 有些不不符合常识的是, 部分任务训练时间更长的版本表会更差(但降幅不高)<br />
最后的实验针对最为复杂的任务, 例如兼顾移动与操控, 对这种任务, 往往预训练并微调后的模型有相当好表现, 有时能成倍于从头训练版本和 zero-shot 版本</p>
<h3 id="细节">细节</h3>
<p>前置知识: <a href="https://thinklive1.github.io/thinklive/48061/#flow-matching">flow matching</a></p>
<p>参考 :</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=114844942470263&amp;bvid=BV142uFzWEdY&amp;cid=31186487108&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>这部分解释一些技术细节:</p>
<p>先放一张架构图<br />
<img src="/assets/ml/image-5.png" /></p>
<p>π0 将输入分为 3 个 block, 分别是 图像与文字指令、机器人状态、动作, 第一个 block 由 VLM 处理, 后两个交给动作专家<br />
从 VLM 部分说起, 先简单地对图像处理为 token, 将图像 token 和文字 token 拼接, 交给注意力来计算 kvq, 这是个很简单的处理, 需要注意的是为了提高效率这里的 kv 之后会复用<br />
然后是较为关键的动作专家, 机器人状态是一种很单纯的输入不需要额外处理, 而对(噪声化的)动作, 因为动作是有序的, 需要编码时间步信息(使用正弦编码), 这里不是常见的相加, 而是使用拼接(concat), 最后会得到两倍宽度的一个序列, 然后在经过线性层和激活函数得到最后的 action tokens<br />
<img src="/assets/ml/image-6.png" /></p>
<p>现在我们有了三种输入, 符合常识地, 他们之间存在顺序关系(图文-&gt; 状态-&gt; 动作), 后面的可以“注意”前面的数据(如果长度不够就 padding 0), 这种注意力关系会用 mask 实现, 且使用之前的 kv cache<br />
所有这些信息最后喂给动作专家(一个较小的 VLM), 但沿用的 kv-cache 来自最初的大型 VLM, 结果投影至动作空间, 也就是流匹配的向量 v<br />
那么 π0 使用的流匹配具体是怎样的呢, 作者根据先前研究的经验使用简单的线性高斯, 即 <span class="math display">\[ q(\mathbf{A}_{t}^{\tau}|\mathbf{A}_{t})={\mathcal{N}}(\tau\mathbf{A}_{t},(1-\tau)\mathbf{I}) ; \mathrm{A}_{t}^{\tau}=\tau\mathrm{A}_{t}+(1- \tau )\epsilon \]</span><br />
而 <span class="math inline">\(\mathbf{u}(\mathsf{A}_{t}^{\mathsf{\tau}}|\mathsf{A}_{t})\ =\ \mathsf{\epsilon}-\ A_{t}\)</span> 此外, <span class="math inline">\(\tau\)</span> 来自于 β 采样</p>
<p>简单回顾一下流匹配, 它的概率路径应该有的性质:</p>
<ol type="1">
<li>t = 0 时, p(x|x1)服从一个标准正态分布</li>
<li>t = 1 时, p(x|x1)服从一个均值 x1, 方差较小的正态分布</li>
</ol>
<p>上面提到的 t 其实对应本文的 <span class="math inline">\(\tau\)</span>, 确实是满足条件的, 而这个 u 也很直观, 既然对原来的 At 加上噪声(动作噪声同系数, 动作正噪声负), 那么去噪过程就是噪声减去动作, 也就是噪声如何还原动作</p>
<h1 id="实例">实例</h1>
<h2 id="openin"><a href="https://mp.weixin.qq.com/s/Ro3Vrjx0GiN8eWe6veT-kg">OpenIN</a></h2>
<p>本文提出了一种「<strong>开放词汇、实例导向</strong>」的导航系统, 该系统「<strong>支持多模态和多类型对象导航指令</strong>」, 能够实现对 <strong>位置可变日常实例</strong> 的有效导航<br />
OpenIN 的框架和大部分系统比较类似, 都可以分为场景图构建以及图更新(包括导航)两个主要模块</p>
<ol type="1">
<li><p>CRSG<br />
具体而言, 本系统的地图称为 <code>载体关系场景图（CRSG）</code>, 它基于一个开放词汇实例图 M, 结构上分为 <strong>建筑与房间层、载体层、承载层和其他对象层</strong></p></li>
<li><p>位移对象导航策略<br />
本系统特殊之处在于, 输入是多模态的, 即可以是文本、图像的任意组合:</p></li>
</ol>
<ul>
<li>对图像输入: 使用大语言模型获取文本描述</li>
<li>对文本输入以及图像的文本描述: 使用 SBERT 对其编码, 与 CRSG 对象的特征比较余弦相似度, 最高者作为模板对象 Ot</li>
</ul>
<p>确定目标后, 以 MDP 模型定义探索过程:</p>
<p>定义状态空间: <span class="math inline">\(S_{t}=(L_{t},C R_{t},C T_{t},F_{t})\)</span> 其中 L 为机器人位姿, CR 是未探索的载体层对象集合, CT 为未探索载体层对象上的候选目标对象集合, F 是一个表示是否找到目标的布尔值, 对初始状态 CR0＝ 载体层对象全集, CT0 是上一轮选择的候选对象 Ot<br />
定义动作空间: <span class="math inline">\(A=S t o p,E x p l o r e(c r),G o t o(c t)|c r\in C R_{t},c t\in C T_{t}\)</span> 其中 stop 表示任务完成或者所有载体对象已探索, explore 表示探索载体层对象, goto 表示导航到 ct 的位置<br />
定义策略(以下省略下标 t, 用伪代码表示):<br />
1. if F ==1 CR == <span class="math inline">\(\emptyset\)</span> then a = stop<br />
2. if F == 0 &amp;&amp; <span class="math inline">\(CT_t !=\emptyset\)</span> , CT.sort(by priority); SS = similarity(CT, O) ;<br />
3. Depth = distance(L, CT); D' = mean(distance(camera, CT));<br />
4. <span class="math inline">\(P_{-}R(O_{t j})=\omega_{r}\cdot\frac{\omega_{1}s s_{t j}\cdot f(\bar{d}_{t j})}{1\ +\omega_{2}d_{t j}}\)</span> (priority of <span class="math inline">\(O_{tj}\)</span> in CT)<br />
5. if F == 0 &amp;&amp; $CT ==$ &amp;&amp; $ CR!=$ then (CR.description, O.image, O.image_description) -&gt; LLM -&gt; $cr_k CR_t $ ( <span class="math inline">\(cr_k\)</span> is best target )<br />
6. <span class="math inline">\(a_t\)</span> = Explore( <span class="math inline">\(cr_k\)</span> ); excute( <span class="math inline">\(a_t\)</span> )<br />
7. if <span class="math inline">\(a_t\)</span> == Explore(cr) || <span class="math inline">\(a_t\)</span> == Goto(ct) then while moving: <span class="math inline">\(CR_{observed}\)</span> = observed objects which don't include candidates in the radial r ; <span class="math inline">\(CR_{new}\)</span> = new candidates in unexplored CT objects $</p>
<p>总结: 每轮中在候选对象里优先级排序, 对最佳候选对象的位置, 机器人导航到此处并探索是否存在目标对象; 如果没有候选对象但有为探索载体对象, 让 llm 选一个候选者进行探索; 在探索过程中, 机器人会不断更新 map 且寻找新的候选对象或者载体对象</p>
<h2 id="learning-fine-grained-bimanual-manipulation-with-low-cost-hardware">Learning Fine-Grained Bimanual Manipulation with Low-Cost Hardware</h2>
<p>精细的操控任务例如扎电线、将电池插入槽中, 往往需要较大的计算成本或者高端的硬件设备, 而想要落实应用, 成本控制是非常重要的, 因此需要找到在有限的预算下实现精细操作的智能<br />
本文基于端到端的模仿学习, 训练数据也完全来自于现实的演示, 在高精度任务中, 模仿学习的缺点是对策略错误较为敏感, 且人类演示数据相差较大, 不便于学习; 为此, 本文提出了一种 <code>Action Chunking with Transformers (ACT)</code> 算法, 可以通过低成本地通过动作序列学习, 并得到不错的准确率</p>
<h3 id="前言-2">前言</h3>
<p>举一个生活中的例子, 例如打开一个有盖的杯子, 这就需要一只手(假设为右手)握住杯子, 倾斜让左手靠近杯盖, 然后辨别出杯盖边缘, 让左手轻轻掀起; 这种任务对 ai 来说相当精细<br />
由于需要在有限的成本内完成精细任务, 我们选择端到端的模型, 使用低成本的摄像头 rgb 图像作为输入, 让模型只学习操作策略而无需对整个环境建模(当然对这种复杂任务建模也非常难, 例如在电子游戏界, 几乎没有游戏能做好吃饭等人物的日常动画)<br />
以下简述本文使用的一些技术:</p>
<ul>
<li>远程操控(tleoperation): 使用两只大致相同的低成本机械臂, 共用一个空间地图, 使用一下些 3d 打印组件来增强反向驱动, 总预算控制在 $20k 内</li>
<li>模仿学习算法: 为了避免模仿学习常见的累积误差问题, 参考心理学的 <code>动作块</code>, 让学习策略预测接下来 k 步的一连串动作, 防止某个错误的一步影响后面的推理; 且能减少一些不相干因素的影响, 例如演示中的部分暂停
<ul>
<li>为了提高策略的平滑度, 设置了 <code>temporal ensembling</code> 机制, 更频繁地查询策略, 且将重叠的动作块取平均值</li>
<li>使用 Transformers 处理动作块(序列数据)</li>
</ul></li>
</ul>
<div class="note info"><ul>
<li><code>Backdriving</code> : 在机械和控制系统中使用的术语, 通常指的是在某些系统中, 外部力或运动驱动系统的运动, 而不是通过其内部控制机制来实现, 也就是正向驱动是电机驱动机械装置, 反向驱动则可以是相对机械的外力——比如人力也可以驱动机械臂</li>
<li><code>compounding error（累积误差）</code>: 指在(模仿)学习过程中, 由于对错误示范的逐步复制和执行, 错误逐渐积累, 从而影响系统的整体表现</li>
<li><code>action chunking</code>： 心理学术语, 将一系列动作或行为组合成一个更大、更有意义的单元（或“块”）, 以提高任务执行的效率和流畅性</li>
</ul>
</div>
<h3 id="real-work">real work</h3>
<ol type="1">
<li><p><code>Behavioral cloning</code><br />
行为克隆是最简单的模仿学习方法, 但很明显也有非常多的问题, 例如之前提及的累积误差, 应该解决思路是使用额外的在线学习或者额外标注来更正, 但对低成本硬件的远程操纵常见, 难以适用<br />
如果常识在数据集加入噪声, 很可能会直接让训练失败, 又或者离线地生成校正数据, 但这种方法这在部分场景有效<br />
出于对以上过往问题的考虑, 本文引入了 <code>动作块</code> 机制</p></li>
<li><p>实体机器介绍<br />
如前文介绍, 本文的技术选择准则可以概括为“物美价廉”, 两个机械臂控制在数千美元, 本文使用的 <code>ViperX arm</code> 有 750g 的负重能力,1.5m 的宽度, 5-8mm 的准确度, 其关键电机可替换, 但手指对复杂任务不够适用, 为此 3d 打印了一些手指, 并用 Grip tape(握把胶带)缠一圈来提高抓取能力(it just works!)<br />
接下来要选择远程操作系统, 市面上一些常见的系统通过 vr 或者摄像头捕捉手臂姿势来操纵机械臂, 这称为 <code>task-space mapping</code>, 本文使用 <code>WidowX</code> 一种让用户通过反向驱动 "leader"(一个更小的机器部件)来驱动机械臂("follower")的系统, 这称为 <code>joint-space mapping</code><br />
为什么选择这种系统:</p>
<ol type="1">
<li>系统中的机械臂有 6 个自由度且没有冗余, 如果使用反向运动学, 很容易陷入起一点</li>
<li>共用空间减少计算消耗和延迟</li>
<li>leader 的重量防止用户动作过快且相比 VR 控制器减少振动</li>
</ol></li>
</ol>
<p>除此之外, 系统做了一些改造减少 leader 的耗力, 详见官网<br />
这个机器系统称为 ALOHA</p>
<p><img src="/assets/ml/image-1.png" /></p>
<ol start="3" type="1">
<li>ACT 理论部分</li>
</ol>
<p>ACT 系统可以视为一种有条件(conditional)的 VAE(之前写的 <a href="https://thinklive1.github.io/thinklive/48061/#vae-%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8">介绍博文</a>), 其编码器将动作序列和关节位置作为观察结果(输入数据)编码为 z(测试时会丢弃编码器), tf 部分的编码器接受所有相机输入、关节位置以及 z, 其解码器生成一个动作序列<br />
实操中, 让操作员操作 leader 机器人(leader 由于要人类操纵, 规格与 follower 不同, 两者的动作参数之间可以隐式转换), ACT 不断预测人类操作员在给定观察下的未来 k 步操作<br />
这样有个额外的好处, 由于学习的样本是人类提供的行为, 而这种行为不一定是符合马尔科夫假设的, 单步学习很可能会被暂停之类的行为误导, 而如果误导行为集中在一个动作块中, 对训练的损害则不会那么巨大<br />
但相应的, 由于每 k 步切换, 可能过程不会太平滑, 因此在每步都会查询策略, 类似滑动窗口, 这样依赖每次预测的动作块都会有部分重叠, 因此为了充分利用这些信息, 对未来时刻的所有预测动作, 计算一个加权和, 这个过程称为 <code>temporal ensembling</code>, 实验发现这样的聚合效果要好于传统的对于时间上相邻动作动作的平滑化, 这部分机制会在下文详细讨论</p>
<p>接下来阐释对输入的处理:</p>
<ol type="1">
<li>我们用 CVAE 处理人类输入, 它由一个编码器和一个解码器组成, 解码器会预测 z 的均值与方差, 用作对角高斯分布, 也就是根据输入数据拟合一个高斯分布</li>
<li>出于训练速度考虑, 对输入数据, 不使用图像观察结果, 只用机器人的本体感知数据(例如姿势, 角度等)</li>
<li>解码器则会使用 z 以及当前观察结果(图像+关节位置)预测未来的动作序列</li>
<li>测试时, 设 z 为先验分布(给定)的均值, 如果想要确定性地解码, 可以直接设 0(注意是测试时这么做)</li>
<li>训练的过程中不断地最大化模型输出与演示数据里的相同动作块的对数概率; 同时也使用标准 VAE 的两个标准(重建损失与正则化项), 对正则化项, 乘以一个超参数 β(用于控制 z 包含的信息量, 更高的正则化会导致更少的信息转入 z)</li>
</ol>
<p>具体实现:</p>
<p><img src="/assets/ml/image-2.png" /></p>
<ol type="1">
<li>使用 tf 作为编码和解码器, 具体来说, CVAE 的编码器类似 BERT, 其输入是当前关节位置以及长度为 k 的演示动作序列, 同样类似 BERT, 每段序列会有个 <code>CLS</code> 前缀, 具体见上图左侧部分</li>
<li>CVAE 解码器实际上更为复杂, 由 <code>ResNet image encoders, a transformer encoder, a transformer decoder</code> 组成, 接受的输入也比编码器更多, 其动作空间是机器人的所有关键位置也就是一个 14 维向量(一只手对应 7 维), 大致过程如下
<ol type="1">
<li>resnet 的编码器将图像输入转化为特征地图, 再被展平(flatten)为序列(另外使用正弦位置编码保存空间关系)</li>
<li>处理完图像后, 特征数据以及关节位置, z 作为输入通过一个线性层投影到一个向量组, 其向量数为 k</li>
<li>得益于前一步中得到的固定长度的向量组, tf 解码器通过 cross-attention 产生相同长度的输出组, 然后在经过 MLP(多层感知机)的投影为 14 长度的动作向量组</li>
</ol></li>
</ol>
<p>神奇的是, 用 L1 损失作为重建损失的表现更好, 此外用 <code>delta joint position</code>(关节变化量)训练效果不如目标位置</p>
<div class="note info"><ul>
<li>逆向运动学（Inverse Kinematics, IK）: 运动学（Kinematics）是在给定所有关节角度的情况下计算链接结构（如一节人体的关节）的末端的空间位置的过程; 逆向运动学则相反, 知道末端状态, 需要求解关节应该是什么角度</li>
<li>奇异点（singularities）: 机器人在某些特定配置下失去自由度或控制能力的状态。在这些状态下, 机器人可能无法有效地执行运动或控制其末端执行器的位置和姿态</li>
<li>变分自编码器（Variational Autoencoder, VAE）: 一种生成模型, 结合了神经网络和贝叶斯推断的思想, 广泛应用于无监督学习、数据生成和特征学习</li>
<li>风格变量（Style Variable）: 生成模型中, 用于控制输出样本风格或特征的潜在变量, 能够影响生成内容的“风格”而不改变其“内容”</li>
</ul>
</div>
<h3 id="实验与总结">实验与总结</h3>
<p>由于此部分大多是现实情况的细节, 省略这些部分, 只说结果<br />
ACT 主要创新点在于能够预测连续的, 精确的动作序列, 而一些先前的模仿学习方法只能像分类问题一样预测离散动作, 此外端到端的训练方式对特化的任务可能有更好的效果<br />
消融实验中, CVAE, 动作块等机制都较为有效<br />
相比先前方法, ACT 大部分任务都取得了更好的表现, 但是会在对比度低图像难以捕捉特征的场景表现不佳</p>
<div class="note info">
</div>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>想法</title>
    <url>/thinklive/18985/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励" data-whm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励">
  <script id="hbeData" type="hbeData" data-hmacdigest="8025a466689a93ba79832921708f4f3108b315c4d6eaad31dfb3212eb682ce8f">e834cbb106c5f9f156c5296000fb1eb3c8112485b8c915a4d7b9f425ea9480bc660e5ebac43346a7a877de6b990568924e0da84f22e5759fd81d247ba14576cbbcd73d220d0d22da614d13608db4929a24d7debf71e6f5ef623a18439ec332e26bc15bb530d5027d3a1de190350933b30bf919f20f42f1e37e0f7d496d61da8d9c269c8bbf89e5f5be5f8620e962840a368395df02ffb7897f8e0441a2d47c7602f254b6411a6fdb283fb41a6f65e7774720431ff6bee51dbf3f398e963a3c17001b5ea32390eafb956431353613a2116050980e45b0f1235669b263856f3f0bd2ed41541735845250b0600dfd2aaa0a2f8c682b22c767558724ff1c2992f5d38789305eb594eacf8f2c6db68411d0be4464da08a5553dbfc7ff793ef7c5799b4a92c460f595a441a4b5421048f8475df4343f3bc232e6ba759c3462bf32148876eac79285da59c8dd4da76baf3b64416e3aced04b1181585ac39a3f2db6f4528c43a7d4f8b737ed5a0a2c12a0e4ff4810bde2f693e7ff3e555df1f29a35e90fc370682d9cb332fada4817a9e4dc613c212d83835024067e1957c95e24e6bcebbe4099e68153f246be24b24fc94c5c900387ddd03ad685756c275029bee2936bfc5363a7e0bb58686e0cae6156483fe649f47966eece7979ea8eb773b2bb96762c8e38c1832ed62db6cae0365c692c5d3fd1c6b3047c2f987675f60fb6e50689b601b48449c22674690b04d8afd97599d6dde73843a676a3e173cbc4f20fe47ef9b9edb681f939a8efd032336a0104153da7e842e076945c1874f92356cfc787f219d285d287bb0386bf245532d73422aec7936294309fdeaa994e114e806c130c5d2c9ae7222810bfa4313598f5da24197456288f46ab054a5753941cd0df9d87f340ad8b3ff3afa6071f8a9c0ae1b2814406c959612f0176aa5699370d6c5998a91ae2c91874c68e57bd04eece78e49184762eb5b6c59e9c63c8a02a47da34dfe65376e3bbafecb1d3b191affc132a9d42e9ad2e9707feec915b80401b7c75f4bc14e0b79100caf38d6141b5ca6debae6cbd4b3b00aaa26bb429eda1c14a6295433c9399495a4cfc75721888b31c9dfd6f7b5efa4268eafd2cf4dc3196f57ae348aed07e6513bad805d7163a418564</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">摇曳着苦闷光辉的火焰在跳动着……</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>秘密</category>
      </categories>
      <tags>
        <tag>秘密</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记 all in one</title>
    <url>/thinklive/48061/</url>
    <content><![CDATA[<p><a href="https://speech.ee.ntu.edu.tw/~hylee/ml/2022-spring.php">李宏毅机器学习</a> <a href="https://zh.d2l.ai/">动手学深度学习</a></p>
<span id="more"></span>
<h1 id="前期工作">前期工作</h1>
<h2 id="数学">数学</h2>
<h3 id="统计">统计</h3>
<p>机器学习的本质是寻找一个理想的函数, 这个理想可以定义为在训练集和全集上表现几乎一致, 使用统计的原理可以尽可能理解这其中的一些关系:<br />
定义: <code>|𝐿 ℎ, 𝒟𝑡𝑟𝑎𝑖𝑛 − 𝐿 ℎ, 𝒟𝑎𝑙𝑙 | &gt; 𝜀</code> 时 <code>Dtrain</code> 是差的, 那么:</p>
<p><span class="math display">\[P(\mathcal{D}_{t r a i n}\;i s\;b a d)\leq|\mathcal H|\cdot2e x p(-2N\varepsilon^{2})\]</span></p>
<p>其中, N 是训练样本数, H 为备选函数的集合, 也就是如果想要这个理想条件, H 和 N 会存在这种约束条件<br />
需要注意的是, 这个理想条件并不包括具体的 loss 值, 如果 H 过小, 那么 loss 就可能会很大</p>
<h3 id="概率论">概率论</h3>
<p>数学期望:</p>
<p><span class="math display">\[E[X]=\sum_{x}x P(X=x).\]</span></p>
<p>当函数 f(x)的输入是从分布 P 中抽取的随机变量时, f(x)的期望值为:</p>
<p><span class="math display">\[E_{x\sim P}[f(x)]=\sum_{x}f(x)P(x).\]</span></p>
<p>方差：</p>
<p><span class="math display">\[\operatorname{Var}[X]=E\left[(X-E[X])^{2}\right]=E[X^{2}]-E[X]^{2}.\]</span></p>
<h4 id="分布"><a href="https://d2l.ai/chapter_appendix-mathematics-for-deep-learning/distributions.html">分布</a></h4>
<h3 id="信息论"><a href="https://d2l.ai/chapter_appendix-mathematics-for-deep-learning/information-theory.html">信息论</a></h3>
<h4 id="熵">熵</h4>
<p>在不同的领域中，熵被表示为混乱程度，不确定性，惊奇程度，不可预测性，信息量等，但在机器学习中我们只需要对信息论中的熵有基本了解<br />
信息论中熵的概念首次被香农提出，目的是寻找一种高效/无损地编码信息的方法，即 <strong>无损编码事件信息的最小平均编码长度</strong> 即信息熵 H(X) = -Σ p(x) log2 p(x) (p 为概率)</p>
<p>接下来说明这个公式，假设我们用二进制的哈夫曼编码，一个信息出现概率是 1/2, 即其他所有情况加起来也是 1/2，那么我们会发现其编码长度必然是-log(1/2), 也就是 1，恰好和我们的香农熵定义一致了，这是为什么呢？<br />
严谨的数学证明超出了 cs 专业范围，这里只说一下直观理解，熵有两个性质：</p>
<ul>
<li>概率越小信息量越大(如果一个小概率事件发生了，就排除了非常多其他可能性)</li>
<li>假设两个随机变量 x, y 相互独立，那么分别观测两个变量得到的信息量应该和同时观测两个变量的信息量是相同的，<code>h(x+y)=h(x)+h(y)</code></li>
</ul>
<p>如此一来对数函数的负数完美符合条件，基数则无所谓，直观地理解，基数对应用几进制编码，而要最短化编码，越小概率就应该用更长的位数，把短位数腾出来给大概率事件用，当然实际中编码的位数是离散的，而且相比对数取负只能多不能少，因此香农熵是一个理论最优值，熵编码就指无损情况下的编码方式，最常用的就是哈夫曼编码，所有熵编码方式的编码长度大于等于香农熵</p>
<p>现实中常用二进制编码信息，例如对 8 种不同的信息，最直观的编码是三位二进制，每三位表示一个独特信息。<br />
我们可以用概率表示每种信息出现的可能，例如 8 种信息，每个都等可能出现，那么以概率为权的哈夫曼编码就会用所有的 3 位二进制编码这 8 种信息，熵就是 3，而其他情况熵可以当做哈夫曼树的总编码长度算<br />
那么如何理解熵能反映混乱度呢？如果熵比较大(即平均编码长度较长)，意味着这一信息有较多的可能状态，相应的每个状态的可能性比较低；因此每当来了一个新的信息，我们很难对其作出准确预测，即有着比较大的混乱程度/不确定性/不可预测性</p>
<p><strong>交叉熵</strong>：<br />
交叉熵用于评估估计概率得到的熵与真实熵的差距，交叉的含义很直观，就是使用 P 计算期望，使用 Q 计算编码长度<br />
为什么这么选而不是反过来呢？这取决于我们的目的，一般来说，我们希望估计的编码长度和理论最优的熵差距较小，要比对取优的主要是模型的编码长度即 logQ，可以这么理解，熵公式中的对数函数视为视为对一个特定概率事件的编码长度，由于现实的概率分布实际上是确定的，那么需要评估的也就是编码方式的效率<br />
由于熵是给定概率分布下的最优值，<strong>交叉熵只可能大于等于熵</strong>，两者差越小或者说交叉熵越小表示模型估计越准<br />
例如在最极端的 one-hot 编码中，交叉熵等价于 <strong>对应正确解标签的输出的自然对数</strong></p>
<h3 id="线性代数">线性代数</h3>
<h4 id="范数">范数</h4>
<p>范数是具有“长度”概念的函数，用于衡量一个矢量的大小（测量矢量的测度）<br />
由于不是数学系的，这里就极为不严谨地记录一下范数的理解：</p>
<ul>
<li>0 范数，向量中非零元素的个数</li>
<li>1 范数，为绝对值之和</li>
<li>2 范数，就是通常意义上的模</li>
</ul>
<p>正则化的目的可以理解为限制权重向量的复杂度，实际做法为在损失函数中加入与权重向量复杂度有关的惩罚项，而范数在某种意义上可以反映这点，因此可作为选取正则项的依据<br />
顺便一提 a star 算法也会用类似的测度估计距离</p>
<h2 id="工具">工具</h2>
<h3 id="cuda">cuda</h3>
<p>Compute Unified Device Architecture (CUDA): 简单地说，就是允许软件调用 gpu 来计算的一个接口<br />
CUDA Runtime API vs. CUDA Driver API</p>
<ul>
<li>驱动版本需要 ≥ 运行时 api 版本</li>
<li>driver user-space modules 需要和 driver kernel modules 版本一致</li>
<li>当我们谈论 cuda 时，往往是说 runtime api</li>
</ul>
<p>以下是 nvida 的介绍原文：</p>
<div class="note default"><p>It is composed of two APIs:</p>
<ul>
<li>A low-level API called the CUDA driver API,</li>
<li>A higher-level API called the CUDA runtime API that is implemented on top of the CUDA driver API.</li>
</ul>
<p>The CUDA runtime eases device code management by providing implicit initialization, context management, and module management. The C host code generated by nvcc is based on the CUDA runtime (see Section 4.2.5), so applications that link to this code must use the CUDA runtime API.</p>
<p>In contrast, the CUDA driver API requires more code, is harder to program and debug, but offers a better level of control and is language-independent since it only deals with cubin objects (see Section 4.2.5). In particular, it is more difficult to configure and launch kernels using the CUDA driver API, since the execution configuration and kernel parameters must be specified with explicit function calls instead of the execution configuration syntax described in Section 4.2.3. Also, device emulation (see Section 4.5.2.9) does not work with the CUDA driver API.</p>
</div>
<p>简单地说, driver 更底层，更抽象但性能和自由度更好，runtime 则相反</p>
<h3 id="容器">容器</h3>
<p><img src="/assets/ml/Pasted%20image%2020250401210138.png" /><br />
infrastructure(基础设施)<br />
简单地说，虚拟机的隔离级别比容器更高，虚拟机会模拟出一个系统及其系统 api，而 docker 依旧调用宿主机的 api，因此 docker 更为轻量级<br />
docker 是处理复杂环境问题的良策，比虚拟机更为轻量<br />
其他常用的容器: Slurm and Kubernetes</p>
<p><a href="https://hub.docker.com/r/pytorch/pytorch/tags">Docker Hub repository of PyTorch</a></p>
<h3 id="python">python</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="comment"># 生成数据  x = np.arange(0, 6, 0.1) # 以 0.1 为单位, 生成 0 到 6 的数据 </span></span><br><span class="line"></span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形  </span></span><br><span class="line">plt.plot(x, y1, label=<span class="string">&quot;sin&quot;</span>) plt.plot(x, y2, linestyle = <span class="string">&quot;--&quot;</span>, label=<span class="string">&quot;cos&quot;</span>) </span><br><span class="line"><span class="comment"># 用虚线绘制 </span></span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>) </span><br><span class="line"><span class="comment"># x 轴标签 </span></span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>) </span><br><span class="line"><span class="comment"># y 轴标签 </span></span><br><span class="line">plt.title(<span class="string">&#x27;sin &amp; cos&#x27;</span>) </span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="理论">理论</h2>
<p><a href="https://pytorch.org/docs/stable/tensors.html">官方文档</a><br />
<a href="https://pytorch.org/tutorials/index.html">Official Pytorch Tutorials</a><br />
<a href="https://github.com/wkentaro/pytorch-for-numpy-users">pytorch-for-numpy-users</a></p>
<h3 id="张量">张量</h3>
<p><strong>张量 tensor</strong>: 用于表示 n 维数据的一种概念，例如一维张量是向量，二维是矩阵……</p>
<p><code>dim in PyTorch == axis in NumPy</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>, torch.cuda.is_available())</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;There are <span class="subst">&#123;torch.cuda.device_count()&#125;</span> GPU(s) available.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Device name:&quot;</span>, torch.cuda.get_device_name(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No GPU available, using the CPU instead.&quot;</span>)</span><br><span class="line">        device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<pre><code> True
There are 1 GPU(s) available.
Device name: NVIDIA GeForce RTX 2070</code></pre>
<p>以下是一些朴素的张量操作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([[<span class="number">1</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">x = torch.from_numpy(np.array([[<span class="number">1</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">1</span>]]))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 1, -1],
        [-1,  1]])
tensor([[ 1, -1],
        [-1,  1]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.zeros([<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">x = torch.ones([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0., 0.],
        [0., 0.]])
tensor([[[1., 1., 1., 1., 1.],
         [1., 1., 1., 1., 1.]]])</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.zeros([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line"></span><br><span class="line">x = x.transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([2, 3])  
torch.Size([3, 2])</code></pre>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>) </span><br><span class="line">B = A.clone() <span class="comment"># 通过分配新内存, 将 A 的一个副本分配给 B  </span></span><br><span class="line"></span><br><span class="line">A*B<span class="comment">#按元素乘法的 Hadamard 积，即矩阵相同位置的元素相乘，得到结果矩阵该位置的元素，数学符号 ⊙</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果如下：</span></span><br><span class="line"><span class="string">tensor([[ 0., 1., 4., 9.], </span></span><br><span class="line"><span class="string">        [ 16., 25., 36., 49.], </span></span><br><span class="line"><span class="string">        [ 64., 81., 100., 121.],</span></span><br><span class="line"><span class="string">        [144., 169., 196., 225.],</span></span><br><span class="line"><span class="string">        [256., 289., 324., 361.]])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">A_sum_axis0 = A.<span class="built_in">sum</span>(axis=<span class="number">0</span>)  <span class="comment">#沿0 轴对 A 求和</span></span><br><span class="line">A_sum_axis0, A_sum_axis0.shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">numpy的对某一轴求和，就是把输入轴所有值加起来，投影到剩下的轴上，这个轴不是消失了，而是现在被投影到一起，例如二维矩阵里，沿0轴求和，就是沿着所有行求和，所有行的对应元素加起来，投影到一行，结果行数为1可以降低一个维度为向量，作为sum的输出(更高维情况下除了输入轴都不变，最后维度-1)</span></span><br><span class="line"><span class="string">在这个例子中，结果是：</span></span><br><span class="line"><span class="string">(tensor([40., 45., 50., 55.]), torch.Size([4]))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果让sum的参数keepdims=True，就不会执行维度减一的操作，结果会是个行数1，列数4的矩阵</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>沿某个轴计算 A 元素的累积总和, 比如 <code>axis=0(按行计算)</code>, 可以调用 <code>cumsum</code> 函数。此函数不会沿任何轴降低输入张量的维度。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A.cumsum(axis=<span class="number">0</span>)  </span><br><span class="line">tensor([[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],  </span><br><span class="line">        [ <span class="number">4.</span>, <span class="number">6.</span>, <span class="number">8.</span>, <span class="number">10.</span>],  </span><br><span class="line">        [<span class="number">12.</span>, <span class="number">15.</span>, <span class="number">18.</span>, <span class="number">21.</span>],  </span><br><span class="line">        [<span class="number">24.</span>, <span class="number">28.</span>, <span class="number">32.</span>, <span class="number">36.</span>],  </span><br><span class="line">        [<span class="number">40.</span>, <span class="number">45.</span>, <span class="number">50.</span>, <span class="number">55.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="神经网络的定义">神经网络的定义</h3>
<p>对每一层神经网络，输入的 x 乘以权重向量 w(eight)，加上一个标量 b(ias)后就是输出 y<br />
例如训练一个将 32 维向量转化为 64 维向量输出的模型，权值矩阵规模是 64×32, 输入向量是 32×1，输出是 64×1<br />
算出线性的权值和之后，增加一层激活函数 <strong>Activation Function</strong>, 激活函数常是非线性的，用于增强网络学习能力，如果没有激活函数，网络就是单纯的有很多层数的线性回归<br />
最基础的神经网络是 <strong>全连接前馈神经网络(fully-connected feed-forward network)</strong>: 前馈表示从前到后训练，全连接表示相邻的两层中，所有的神经元都是相连的; 网络第一层称为输入层（input layer），最后一层称为输出层（output layer），中间的层数被称为隐藏层(hidden layer)</p>
<div class="note info"><p><em>前向和反向，forward &amp;&amp; backward: 理解这两个词应该看英文，forward 这个前指的是时间上从前往后，也就是训练时的正常时间顺序，backward 与其相反，就是从结果推开头</em></p>
</div>
<p>深度学习：这个定义非常简单粗暴，意思是隐藏层很多，一般可能有三位数起步，并非越多层就越好，这需要合适的数据集，合适的提取特征方式，即 <strong>特征工程 feature engineering</strong>，才能定义一个较好的网络</p>
<p>常见激活函数：</p>
<ul>
<li>Sigmoid 函数也叫 Logistic 函数，用于隐层神经元输出，取值范围为(0,1)，它可以将一个实数映射到(0,1)的区间，可以用来做二分类。在特征相差比较复杂或是相差不是特别大时效果比较好，图像类似一个 S 形曲线:
<ul>
<li> $ f(x)=\frac{1}{1+e^{-x}} $  </li>
</ul></li>
<li>ReLU 函数又称为修正线性单元（Rectified Linear Unit），是一种分段线性函数，弥补了 sigmoid 函数的梯度消失问题(即该函数两端非常平滑，导数趋近 0，遇到数值偏两端的数据，loss 很难传播):
<ul>
<li> $f(x)={\left\{\begin{array}{l l}{x}&{,x\gt =0}\\ {0}&{,x\lt 0}\end{array}\right.} $ </li>
</ul></li>
</ul>
<p><img src="/assets/ml/Pasted%20image%2020250402152918.png" /> <img src="/assets/ml/Pasted%20image%2020250402152932.png" /></p>
<p><strong>损失函数 loss function</strong>：评估训练成果的一个标准，越小越好<br />
loss = criterion(model_output, expected_value) #nn: neural network</p>
<ul>
<li><code>criterion = nn.MSELoss()</code>: Mean Squared Error</li>
<li><code>criterion = nn.CrossEntropyLoss()</code>: Cross Entropy 交叉熵</li>
</ul>
<h3 id="常见问题">常见问题</h3>
<ol type="1">
<li>模型偏差：模型在训练资料上的损失函数很大时，可能是因为在这个问题中选择的模型太过简单，以至于无论用这个给模型选择什么样的参数 θ，损失函数 f(θ)都不会变得很小</li>
<li>优化问题，梯度下降看上去很美好，但常常会卡在一个局部最优（local minima）点，这个局部最优可能和全局最优（global minima）差得很远，因此需要选取更好的优化算法如 Adam，RMSProp，AdaGrad 等</li>
<li>过拟合，训练集 Loss 很小，测试集却很大，需要注意的是首先得满足前一个条件，不然也可能是 1.2.问题
<ol type="1">
<li>最有效的一种解决方案是增加训练资料，但很多时候是无法做到的</li>
<li>第二种方法就是数据增广（Data Augmentation），常用于图像处理。既然不能增加数据，那就更好地利用现有数据；例如：对图像左右镜像，改变比例等等，需要注意不能过度改变数据特征，例如上下颠倒图片</li>
<li>增加对模型的限制，常见如早停止，正则化，丢弃部分不合理数据等等</li>
</ol></li>
</ol>
<h3 id="优化算法-optimizer">优化算法 optimizer</h3>
<p><a href="https://pytorch.org/docs/stable/optim.html">torch.optim</a><br />
e.g.</p>
<ol type="1">
<li>optimizer.zero_grad()：重设梯度(即训练完一段后梯度置 0, 截断反向传播再继续训练)</li>
<li>Call loss.backward() 反向传播以减少损失</li>
<li>Call optimizer.step() 调整模型参数</li>
</ol>
<h4 id="归一化-normalization">归一化 Normalization</h4>
<p>训练中的数据很多情况下大小完全不统一，基于直觉的想法是：同一维度的数据我们只关心其相对大小关系，不同维度的数据我们认为它们的地位平等，尺度应到一致，所以需要归一化<br />
简单地说就是把一个维度的数据大小都调整到 <code>[0-1]</code> 这个区间，例如 softmax 函数就用于将一个向量转化成概率分布(令其总和为 1)</p>
<div class="note info"><p>归一化 <strong>normalization</strong> 容易和正则化 <strong>regularization</strong> 搞混，来看看词典解释：</p>
<ul>
<li>normalization: to start to consider something as normal, or to make something start to be considered as normal</li>
<li>regularization: the act of changing a situation or system so that it follows laws or rules, or is based on reason</li>
</ul>
<p>也就是，归一化偏向于“正常”，正则化偏向于“规则”，差别非常微妙，但硬要说的话，0-1 的数据看起来是比其他的更“正常”一点</p>
<p>神经网络中进行的处理有推理(inference)和学习两个阶段。神经网络中未被正规 化(归一化)的输出结果有时被称为“得分”。也就是说, 当神经网络的推理只需要给出一个答案的情况下, 因为此时只对得分最大值感兴趣, 所以不需要 Softmax 层。 不过, 神经网络的学习阶段则需要 Softmax 层</p>
</div>
<h4 id="梯度下降">梯度下降</h4>
<p><strong>梯度下降法</strong>：<br />
有点类似于牛顿法(牛顿法理论是二阶收敛，梯度则为一阶，牛顿法速度更快计算量更大)，所谓的梯度就是一个多元函数中，对一个点求各个元的偏导数取值组成的一个表示方向的向量(即偏导数乘对应元的单位向量)<br />
这个梯度一般指向当前点增加最快的方向，把他乘以-1 就会得到下降最快的方向(一般用于最小化损失函数)，梯度只表示方向，因此还需要选择合适的步长 α，乘以方向向量后就得到移动的路径，步长太长了会跨过极小值然后来回震荡，太短了效率会很差<br />
梯度下降算法需要设置一个 <strong>学习率(learning rate)</strong>，每次迭代中，未知参数的梯度下降的步长取决于学习率的设置，这种由人为设定的参数被称为 <strong>超参（hyperparameters）</strong><br />
如果我们的数据集很大，计算梯度会相当复杂，则可以分为 n 个 batch, 每个 batch 有 B 个资料，即 <strong>mini-batch 梯度下降（MBGD，Mini-Batch GradientDescent</strong><br />
在 numpy 里用形如 <code>np.random.choice(scope, num)</code> 的方法就可以在 scope 内随机选取 num 个索引作为 mini batch</p>
<h4 id="反向传播">反向传播</h4>
<p><a href="https://www.cnblogs.com/charlotte77/p/5629865.html">通俗讲解反向传播</a><br />
反向传播是梯度下降在神经网络上的具体实现方式，与前向训练过程相反，用结果的损失值修正训练中的权值，在数学上就是求损失对前一层权重的偏导数<br />
但是损失函数的参数是本层的输出值，因此需要链式法则求偏导，先求出损失函数对输出的偏导，再乘以本层输出对前一层权重的偏导(当然我们知道本层神经元收到上层的输出后还要算个激活函数才能得到最后的输出，因此中间还有一步本层输出对上层输出求偏导，只有上层输出直接和上层权重有关)</p>
<p><img src="/assets/ml/pk7amw95.png" /> 如图，权重结合上层 out 得到 net, net 经过激活函数得到本层 out，本层 out 用来计算损失值，因此反向传播会反过来算<br />
对着这些复杂的名称求偏导数看起来有点奇怪，但这和常见的 yx 没什么不同<br />
得到偏导函数后，接下来正如在梯度下降中学到的，我们希望通过不断调整上层权重来最小化结果层的损失函数，每次用一个“学习速率 <span class="math inline">\(\eta\)</span> ”乘以偏导数来更新权重</p>
<p><img src="/assets/ml/o7aq5jae.png" /></p>
<p>涉及隐藏层时稍微有所不同，在由于隐藏层的下一层会连到不同的结果，也就会产生多个损失值，在 out 部分需要对不同的损失值求偏导，即总误差对 outh1 的偏导是 E(o1)和 E(o2)对 outh1 偏导的和</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dataset = MyDataset(file)</span><br><span class="line">tr_set = DataLoader(dataset, <span class="number">16</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">model = MyModel().to(device)</span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> tr_set:</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        x, y = x.to(device), y.to(device)</span><br><span class="line">        pred = model(x)</span><br><span class="line">        loss = criterion(pred, y)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step() <span class="comment">#更新模型的参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info"><p><strong>梯度消失</strong>：</p>
<p>如果我们用最常见的 sigmoid 函数，且在某层上输入值在函数的两端，此时导数非常小，也就是梯度非常小，这层上的反向传播几乎无法更新，不仅如此，更之前的层级也很难继续传播，这就是所谓的梯度消失问题。<br />
除了更新缓慢问题外，这还会导致浅层和深层的更新程度区别巨大，让模型变得“不均匀”，此外，由于 sig 函数的梯度区间较小，模型深了几乎必然有这种问题</p>
<p>ReLU 用于解决梯度消失问题，其梯度要么是 0 要么是 1，只在负端消失，这样有个可能的好处，如果负端的数据其实是噪声或者是一些我们不关注的特征，那么扔掉反而会让模型效果更好<br />
这种激活函数的缺点是，梯度非负数，对于一层所有的 w，梯度的符号都是一样的，只能一起增大或者减小，这可能减少模型的准确度<br />
通常，激活函数的输入值有一项偏置项(bias)，假设 bias 变得太小，以至于输入激活函数的值总是负的，那么反向传播过程经过该处的梯度恒为 0, 对应的权重和偏置参数此次无法得到更新。如果对于所有的样本输入，该激活函数的输入都是负的，那么该神经元再也无法学习，称为神经元”死亡“问题</p>
<p>LeakyReLU 的提出就是为了解决神经元”死亡“问题，其输入小于 0 的部分，值为负，且有微小的梯度，除了避免死亡还有一个可能的好处是，该微小的梯度可能让训练有一些微小的振动，在特定情况能跳出局部最优解</p>
<p>python 实现:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>): </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x)) <span class="comment">#NumPy 的广播特性: 如果在标量和 NumPy 数组之间进行运算, 则标量会和 NumPy 数组的各个元素进行运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">x</span>): </span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>, x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div>
<p>参考项目:</p>
<ul>
<li><a href="https://github.com/huggingface/transformers">Huggingface Transformers</a> (transformer models: BERT, GPT, ...)</li>
<li><a href="https://github.com/pytorch/fairseq">Fairse</a> (sequence modeling for NLP &amp; speech)</li>
<li><a href="https://github.com/espnet/espnet">ESPnet</a> (speech recognition, translation, synthesis, ...)</li>
</ul>
<h4 id="momentum">Momentum</h4>
<p>梯度下降简单易懂，但当然也存在问题，考虑如下的函数：</p>
<p><span class="math display">\[f(x,y)=\frac{1}{20}x^{2}+y^{2}\]</span></p>
<p>其 x 轴梯度远小于 y 轴梯度，函数像一个山岭，但底部是个起伏不大的抛物线，更新路径是一个个之字形，y 轴更新地快不断震荡，x 轴则慢慢向真正的底部前进<br />
也就是说，对非均向(anisotropic)的函数，梯度下降效率有限</p>
<p>Momentum(动量)是一种改进的优化方式，这里不管其物理含义，具体更新方法如下所示：</p>
<p><span class="math display">\[v\leftarrow\alpha v-\eta{\frac{\partial L}{\partial W}}\]</span> <span class="math display">\[W\leftarrow W+v\]</span></p>
<p>其他变量我们都知道了，这个 v 对应物理上的速度，表示物体在梯度方向受力，α 模拟类似摩擦力导致的减速，一般比 1 略小，如 0.9，也就是说，原来的梯度下降可视为无阻力的运动，动量法让其速度越来越慢，这可以有效减少路径的折线情况</p>
<h4 id="adagrad">AdaGrad</h4>
<p>学习率衰减(learning rate decay), 即随着学习的进行, 使学习率逐渐减小是一种常见的思路；AdaGrad 进一步发展了这个想法, 针对不同参数, 赋予相互独立的学习率，即 Adaptive Grad</p>
<p><span class="math display">\[h\leftarrow h+{\frac{\partial L}{\partial W}}\leftarrow{\frac{\partial L}{\partial W}}\]</span> <span class="math display">\[W\leftarrow W-\eta\frac{1}{\sqrt{h}}\frac{\partial L}{\partial W}\]</span></p>
<p>h 保存了以前的所有梯度值的平方和, 这样能够按参数的元素进行学习率衰减, 使变动大的参数的学习率逐渐减小，直至无限接近 0；RMSProp 方法会舍弃一些比较早的梯度避免这个问题<br />
为了避免棘手的除 0 问题，h 的平方根可以加一个微小值如 1e-7</p>
<p><a href="https://arxiv.org/abs/1412.6980">adam</a> 是 2015 年提出的新方法, 直观但不准确地说就是融合了 Momentum 和 AdaGrad 的方法</p>
<h3 id="正则化">正则化</h3>
<p>正则化指为解决适定性问题或过拟合而加入额外信息的过程，在机器学习中，常见的就是为损失函数添加一些调整项<br />
根据前文所述，学习的过程就是根据损失函数与权重的关系不断调整权重以最小化损失，而正则化的目的是不要让权重关系太复杂以致于没有普适性。我们将原始的损失函数画一个图，正则项再画一个图，需要找的就是两个函数同样权重基础上的最小和<br />
用比较简单的双权重，均方误差损失函数来说，w1, w2 就是 xy 轴，最后的 loss 作为 z 轴，原始损失函数 L 可能千奇百怪，但最后要找的是其与正则项的最小和.这个值通常在两个函数的交点取，而(二维层面上)L1 的图像是菱形，l2 是个圆，符合直观地推导，前者交点很容易在坐标轴上取，后者容易在离坐标轴近的地方取，即 l1 容易让权重稀疏，L2 容易让它们的值的绝对值较小且分布均匀<br />
数学上讲，抛开不确定的损失函数，l1 正则项的导数是 w× 正负信号量，迭代时如果 w 大于 0 会减少，大于 0 会增加，最后很容易变成 0；而 l2 的导数是 w 的一次函数且一次项系数小于 1，迭代让 w 不断减小，这个减小量与 w 本身有关，因此一般来说不容易减到 0</p>
<h3 id="训练技巧">训练技巧</h3>
<h4 id="初始权值">初始权值</h4>
<p>什么是最好的初始权重？这个问题很难回答，不如反过来举一些反例<br />
相同的权重肯定是最坏的选择，由于随机梯度下降法对相同或者相似的权值会有非常相似的传导效果，最终模型的权值也会趋同，降低其表达力</p>
<p>一般来说，我们用高斯分布来初始权重，例如常用的 Xavier 初始值根据上层(以及下层)的节点数量确定初始权重的分布，例如在与前一层有 n 个节点连接时, 初始值使用标准差为 <span class="math inline">\(\frac{1}{\sqrt{n}}\)</span> 的分布<br />
Xavier 初始值是以激活函数是线性函数为前提而推导出来的。因为 sigmoid 函数和 tanh 函数左右对称, 且中央附近可以视作线性函数, 所以适合使用 Xavier 初始值。但当激活函数使用 ReLU 时, 一般推荐使用 ReLU 专用的初始值, 也就是 Kaiming He 等人推荐的初始值, 也称为“He 初始值”<br />
当前一层的节点数为 n 时, He 初始值使用标准差为 <span class="math inline">\(\sqrt{\frac{2}{n}}\)</span> 的高斯分布。当 Xavier 初始值是 <span class="math inline">\({\sqrt{\frac{1}{n}}}\)</span> 时,(直观上)可以解释为, 因为 ReLU 的负值区域的值为 0, 为了使它更有广度, 所以需要 2 倍的系数</p>
<h4 id="batch-normalization">Batch Normalization</h4>
<p>Batch Norm 的思路是调整各层的激活值分布使其拥有适当的广度, 具体而言, 就是进行使数据分布的均值为 0、方差为 1 的正规化</p>
<p><span class="math display">\[\mu_{B}\,\leftarrow\,\frac{1}{m}\sum_{i=1}^{m}x_{i}\]</span> <span class="math display">\[\sigma_{B}^{2}\iff\sum_{i=1}^{m}(x_{i}-\mu_{B})^{2}\]</span> <span class="math display">\[\hat{x}_{i}\enspace\leftarrow\ \frac{x_{i}\leftarrow\mu_{B}}{\sqrt{\sigma_{B}^{2}\,+\,\varepsilon}}\,\]</span></p>
<p>ε 是一个微小值，用来防止除 0</p>
<p>Batch Norm 层会对正规化后的数据进行缩放和平移的变换:</p>
<p><span class="math display">\[y i\longleftarrow\gamma\hat{x}_{i}+\beta\]</span></p>
<p>γ、β 是参数，初始为 1、0，随后根据学习来调整</p>
<h4 id="抑制过拟合">抑制过拟合</h4>
<p><strong>权值衰减</strong>：为损失函数加上权重的平方范数(L2 范数)，即让正则项为 <span class="math inline">\(\textstyle{ {\frac{1}{2}}\lambda W^{2} }\)</span> ，其中 λ 是控制正则化强度的超参数，其梯度也会加上一个 λW</p>
<p><strong>dropout</strong>：在学习的过程中随机删除神经元，停止向前传递信号</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dropout</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dropout_ratio=<span class="number">0.5</span></span>):</span><br><span class="line">        self.dropout_ratio = dropout_ratio</span><br><span class="line">        self.mask = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, train_flg=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="keyword">if</span> train_flg:</span><br><span class="line">            self.mask = np.random.rand(*x.shape) &gt; self.dropout_ratio<span class="comment">#*x.shape 将 x 的形状解包</span></span><br><span class="line">            <span class="keyword">return</span> x * self.mask</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> x * (<span class="number">1.0</span> - self.dropout_ratio)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>):</span><br><span class="line">        <span class="keyword">return</span> dout * self.mask</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>集成学习</strong>：让多个模型单独进行学习, 推理时再取多个模型的输出的平均值。Dropout 可以理解为：通过在学习过程中随机删除神经元, 从而每一次都让不同的模型进行学习；推理时, 通过对神经元的输出乘以删除比例, 可以取得模型的平均值。</p>
<h4 id="超参数">超参数</h4>
<p>超参数(hyper-parameter)：如各层的神经元数量、batch 大小、参 数更新时的学习率或权值衰减等<br />
需要注意的是，不能使用测试数据评估超参数的性能，否则会让超参数的值会对测试数据发生过拟合，一般用验证数据来评估性能 <a href="https://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a.pdf">有报告显示</a>，在进行神经网络的超参数的最优化时, 与网格搜索等有规律的搜索相比, 随机采样的搜索方式效果更好。这是因为在 多个超参数中, 各个超参数对最终的识别精度的影响程度不同 大致的步骤是：</p>
<ol type="1">
<li>设定超参数的范围</li>
<li>从设定的超参数范围中随机采样</li>
<li>使用 1.中采样到的超参数的值进行学习, 通过验证数据评估识别精度(但是要将 epoch 设置得很小)</li>
<li>重复 1. 2. 不断缩小参数到一个合理的值</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">weight_decay = <span class="number">10</span> ** np.random.uniform(-<span class="number">8</span>, -<span class="number">4</span>)<span class="comment">#uniform 生成指定范围内的随机数, 默认 0 维度，可以指定维度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="神经网络模型">神经网络模型</h1>
<h2 id="python-相关">python 相关</h2>
<ul>
<li><code>DataLoader(train_date,shuffle=True)</code> 中 shuffle 表示打乱数据集，符合直觉的想法是：这对避免过拟合有帮助<br />
</li>
<li>epoch 是一个单位。一个 epoch 表示学习中所有训练数据均被使用过一次时的更新次数。比如, 对于 10000 笔训练数据, 用大小为 100 笔数据的 mini-batch 进行学习时, 重复随机梯度下降法 100 次, 所有的训练数据就都被“看过”了。此时,100 次就是一个 epoch</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My_model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self，inputdim</span>):</span><br><span class="line">        <span class="built_in">super</span>(My_model,self).__init__()</span><br><span class="line">        self.layers=nn.sequential(<span class="comment">#将多个层按顺序组合在一起</span></span><br><span class="line">            nn.Linear(input_dim,<span class="number">64</span>), </span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>，<span class="number">32</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">32</span>，<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.layers(x)</span><br><span class="line">        x = x.sgueeze(<span class="number">1</span>)<span class="comment">#(B, l) -&gt; B</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">#Training loop</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3000</span>):</span><br><span class="line">    model.train() <span class="comment"># Set your model to train mode.</span></span><br><span class="line">    <span class="comment"># tgdm is a package to visualize your training progress</span></span><br><span class="line">    train_pbar = tqdm(train_loader, position=<span class="number">0</span>, leave=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> train_pbar:</span><br><span class="line">        x, y = x.to(<span class="string">&#x27;cuda&#x27;</span>), y.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">        pred = model(x)</span><br><span class="line">        loss = criterion(pred, y)</span><br><span class="line">        loss.backward()<span class="comment"># Compute gradient(backpropagation).</span></span><br><span class="line">        optimizer.step()<span class="comment"># Update parameters.</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment"># Set gradient to zero.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://pytorch.org/docs/stable/">PyTorch Documentation</a></p>
<p>广播机制(broadcasting mechanism):</p>
<ol type="1">
<li>通过适当复制元素来扩展一个或两个数组, 以便操作的不同张量具有相同的形状;<br />
</li>
<li>对生成的数组执行按元素操作</li>
</ol>
<p>例如，a 和 b 分别是 3 × 1 和 1 × 2 矩阵，广播会成为一个更大的 3 × 2 矩阵: 矩阵 a 将复制列, 矩阵 b 将复制行, 然后再按元素相加 广播机制有一些实用的技巧:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>) </span><br><span class="line">sum_A = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">A / sum_A <span class="comment">#sum_A 没有降维，仍然是个矩阵，可以通过广播将 A 除以 sum_A。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果如下：</span></span><br><span class="line"><span class="string">tensor([[0.0000, 0.1667, 0.3333, 0.5000],  </span></span><br><span class="line"><span class="string">        [0.1818, 0.2273, 0.2727, 0.3182],</span></span><br><span class="line"><span class="string">        [0.2105, 0.2368, 0.2632, 0.2895],  </span></span><br><span class="line"><span class="string">        [0.2222, 0.2407, 0.2593, 0.2778],  </span></span><br><span class="line"><span class="string">        [0.2286, 0.2429, 0.2571, 0.2714]])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这是一种很方便的归一化操作</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="基础训练方法示例">基础训练方法示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;构造一个PyTorch数据迭代器&quot;&quot;&quot;</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br></pre></td></tr></table></figure>
<p>使用 <code>iter</code> 构造 Python 迭代器，并使用 <code>next</code> 从迭代器中获取第一项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">next</span>(<span class="built_in">iter</span>(data_iter))</span><br></pre></td></tr></table></figure>
<pre><code>[tensor([[-0.0714, -1.8597],
         [-0.4744,  0.4050],
         [ 0.2402,  0.5660],
         [ 1.6367, -0.9899],
         [ 0.6723,  0.1904],
         [ 0.5322, -0.4337],
         [-0.5749,  0.6719],
         [-0.0317,  1.3456],
         [ 1.0865, -1.3968],
         [-0.0130, -0.9245]]),
 tensor([[10.3747],
         [ 1.8749],
         [ 2.7762],
         [10.8325],
         [ 4.9005],
         [ 6.7224],
         [ 0.7743],
         [-0.4169],
         [11.1058],
         [ 7.3157]])]</code></pre>
<p><code>Sequential</code> 类将多个层串联在一起, 并自动让其前向传播<br />
在 PyTorch 中，全连接层在 <code>Linear</code> 类中定义。<br />
值得注意的是，我们将两个参数传递到 <code>nn.Linear</code> 中，第一个指定输入特征形状，即 2，第二个指定输出特征形状，输出特征形状为单个标量，因此为 1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nn 是神经网络的缩写</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>可以直接访问参数以设定它们的初始值，如通过 <code>net[0]</code> 选择网络中的第一个图层，然后使用 <code>weight.data</code> 和 <code>bias.data</code> 方法访问参数。<br />
我们还可以使用替换方法 <code>normal_</code> 和 <code>fill_</code> 来重写参数值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net[<span class="number">0</span>].weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">net[<span class="number">0</span>].bias.data.fill_(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>损失函数与优化算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">loss = nn.MSELoss()</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>)<span class="comment">#使用小批量随机梯度下降，第一个参数是优化对象，lr 则是学习率</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>训练：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        l = loss(net(X) ,y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward()</span><br><span class="line">        trainer.step()</span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>epoch 1, loss 0.000247
epoch 2, loss 0.000110
epoch 3, loss 0.000110</code></pre>
<p>比较生成数据集的真实参数和通过有限数据训练获得的模型参数<br />
要访问参数，我们首先从 <code>net</code> 访问所需的层，然后读取该层的权重和偏置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = net[<span class="number">0</span>].weight.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w的估计误差：&#x27;</span>, true_w - w.reshape(true_w.shape))</span><br><span class="line">b = net[<span class="number">0</span>].bias.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的估计误差：&#x27;</span>, true_b - b)</span><br></pre></td></tr></table></figure>
<pre><code>w 的估计误差： tensor([0.0005, 0.0006])
b 的估计误差： tensor([0.0006])</code></pre>
<h2 id="线性模型">线性模型</h2>
<p>回归问题常常用若干输入产生一个连续值作为输出，线性回归（Linear Regression）和逻辑回归（Logistics Regression）是常见的线性模型</p>
<h3 id="线性回归">线性回归</h3>
<p>线性回归，即 y = wx + b , 是最简单的回归模型，但纯一次项的拟合能力较为受限，这种情况下就需要多项式回归<br />
我们将 w 视为权值向量，x 视为从一次 x'到 n 次 x'组成的向量，那么多项式模型依旧可以用原先的线性公式表示<br />
增加多项式的次数可以更好拟合训练集，但对测试集的效果就未必了，很容易出现过拟合问题, 如果出现，依旧需要正则化，增加数据数量或者维度等优化 线性模型优化是个纯粹的数学问题，其解析解在线代课上就会讲到，即：</p>
<p><span class="math display">\[\mathbf{w}^{*}=(\mathbf{X}^{\mathsf{T}}\mathbf{X})^{-1}\mathbf{X}^{\mathsf{T}}\mathbf{y}.\]</span></p>
<h4 id="python-实现">python 实现</h4>
<p>求梯度更像一个数学问题，这里就用 pytorch 的自动求导功能，实际上也可以自己通过计算图实现<br />
简单生成一个有噪声项 <span class="math inline">\(\epsilon\)</span> 的数据集，噪声项有标准差 0.01, 均值为 0 的正态分布生成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成y=Xw+b+噪声&quot;&quot;&quot;</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))根据正态分布随机计算初始权值向量</span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">    <span class="keyword">return</span> X, y.reshape(-<span class="number">1</span>,<span class="number">1</span>)<span class="comment">#-1 表示不固定形状，根据总元素数和其他维度数量计算该维度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])<span class="comment">#w形状与 features 单行的形状相同</span></span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)<span class="comment">#labels 被 reshape 为单列的向量</span></span><br><span class="line">labels.shape</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([1000])</code></pre>
<p>通过生成第二个特征 <code>features[:, 1]</code> 和 <code>labels</code> 的散点图， 可以直观观察到两者之间的线性关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d2l.set_figsize()<span class="comment">#控制图像大小</span></span><br><span class="line">d2l.plt.scatter(features[:, <span class="number">1</span>].detach().numpy(), labels.detach().numpy(), <span class="number">1</span>);<span class="comment">#detach() 用于从计算图中分离张量</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/ml/output_8_0.svg" alt="" /><figcaption>svg</figcaption>
</figure>
<p>为了提高效率，设置一个划分小批量的工具函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    num_examples = <span class="built_in">len</span>(features)</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))</span><br><span class="line">    <span class="comment"># 这些样本是随机读取的，没有特定的顺序</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        batch_indices = torch.tensor(</span><br><span class="line">            indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)])</span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br></pre></td></tr></table></figure>
<p>定义模型：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linreg</span>(<span class="params">X, w, b</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性回归模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(X, w) + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">squared_loss</span>(<span class="params">y_hat, y</span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;均方损失&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="number">2</span> / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            param.grad.zero_()</span><br><span class="line"></span><br><span class="line">w = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>,<span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y)  <span class="comment"># X 和 y 的小批量损失</span></span><br><span class="line">        <span class="comment"># 因为 l 形状是(batch_size,1)，而不是一个标量。l 中的所有元素被加到一起， 并以此计算关于 [w, b] 的梯度</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        sgd([w, b], lr, batch_size)  <span class="comment"># 使用参数的梯度更新参数</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()):f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>epoch 1, loss 0.030660
epoch 2, loss 0.000105
epoch 3, loss 0.000046</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w的估计误差: <span class="subst">&#123;true_w - w.reshape(true_w.shape)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b的估计误差: <span class="subst">&#123;true_b - b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>w 的估计误差: tensor([ 0.0001, -0.0006], grad_fn = &lt;SubBackward0&gt;)
b 的估计误差: tensor([0.0004], grad_fn = &lt;RsubBackward1&gt;)</code></pre>
<h3 id="分类">分类</h3>
<p>分类问题最简单的解决方法莫过于对回归产生的结果进行筛选，一个区间对应一个类别，但这么做会很难处理区间的划分情况，因此需要其他的处理方法<br />
分类问题的损失函数与回归不同，可以单纯用分类错误率计算，常用模型有感知机、支持向量机等</p>
<h4 id="感知机">感知机</h4>
<p>感知机接收多个输入信号, 根据权重输出一个信号，例如 0 和 1<br />
如果我们用最简单的感知机(依旧输出一个连续值，通过激活函数产生分类)，那么分类任务的重点就是找的一个合适的门槛值 threshold<br />
需要注意的是，感知机本质上是个线性的界限，通过权重向量和偏置值划分不同的输入，设想这样的情况：</p>
<ol type="1">
<li>有多种输入需要分成两类</li>
<li>其中一类有两个输入连成直线 L1, 另一类中有两个输入可以连成直线 L2</li>
<li>如果 L1 和 L2 相交，那么我们不可能在中间画一条线把两个直线分开(证明就不管了)</li>
</ol>
<p>事实上，例如异或门就无法通过感知机实现，因为我们要分开(1,0)(0,1)以及(0,0)(1,1)，这两类的连线相交，准确地说，这是说单层感知机，因为曲线就可以划分这两类，也就是“<strong>单层感知机无法分离非线性空间</strong>”<br />
例如，对异或门这个问题。加一层神经就能将分界线拓展为抛物线，也就是次数+1，这样就能进行非线性划分(多层感知机) 此外，也可以通过加一层 feature 转化层，将原来的 x 映射为可以被线性划分的 x'</p>
<div class="note info"><p>python 中定义阶跃函数(输入超过阈值, 就切换输出):</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">step_function</span>(<span class="params">x</span>): </span><br><span class="line">    y=x&gt;<span class="number">0</span> <span class="keyword">return</span> <span class="comment">#产生 bool 数组</span></span><br><span class="line">    y.astype(np.<span class="built_in">int</span>) <span class="comment"># 将 bool 数组转换为 1 与 0 的 int 数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">step_function</span>(<span class="params">x</span>): </span><br><span class="line">    <span class="keyword">return</span> np.array(x &gt; <span class="number">0</span>, dtype=np.<span class="built_in">int</span>) </span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.1</span>) </span><br><span class="line">y = step_function(x) </span><br><span class="line">plt.plot(x, y) </span><br><span class="line">plt.ylim(-<span class="number">0.1</span>, <span class="number">1.1</span>) <span class="comment"># 指定 y 轴的范围 </span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div>
<h4 id="逻辑回归discriminative-model">逻辑回归(discriminative model)</h4>
<p>逻辑回归的目标是预测一个二元变量（例如，0 或 1、是或否）。通过逻辑函数（sigmoid 函数）将线性组合的输入转换为概率值<br />
相比线性回归，其最大的特点是输出在 0-1 之间，可以理解为概率，一般用于处理分类（二分）问题</p>
<p>经过简单（并不）的梯度运算，可以得到常用 loss 函数的梯度为：</p>
<ol type="1">
<li>交叉熵: <span class="math inline">\(\sum_{n}-{\bigg(}{ {\hat{y}^{n}-f_{w,b}(x^{n})} { } } {\bigg)}x_{i}^{n}\)</span></li>
<li>均方根: <span class="math inline">\(2(f_{w,b}(x)-\hat{y})f_{w,b}(x)\left(1-f_{w,b}(x)\right)x_{i}\)</span></li>
</ol>
<p>这样一来就有个问题，均方根的梯度在损失较大和较小时都很小，只有交叉熵符合远更新快近更新慢的条件</p>
<h4 id="基于概率的分类方法generative-model">基于概率的分类方法(generative model)</h4>
<p>如果有两个类 c1, c2 用于分类，抽到一个样本 x, 这就像高中数学地抽小球问题，随机抽个样本是某类小球的概率取决于在抽取的黑盒子里不同类别的分布。<br />
此时我们的目的是根据参数预测分类，也就是说不同类别的分布只能猜想，于是假设在最简单的两个参数情况下，概率密度函数满足基于这两个参数的高斯(正态)分布，训练时，我们希望分别通过样本得到两类各自的分布情况，也就是这个高斯分布的均值和协方差矩阵</p>
<div class="note info"><p>极大似然估计可以理解为利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值，例如抽球(放回式)问题中抽一百次，七十次是白球, 三十次为黑球，若抽到白球的概率是 p，这个结果的概率是 p<sup>70(1-p)</sup>30，符合直觉的猜想是 p = 0.7，这是因为我们下意识用了极大似然估计。<br />
要令出现此情况的概率最大，只需要求导算一次极值就会得到 p = 0.7，由此产生了一个估计</p>
</div>
<p>使用极大似然估计，类似抽球问题，得到目前结果的概率其实结果所有取样点概率的积，省略怎么计算，最后我们能得到两组(μ, ∑)<br />
此时模型确定了，我们可以得到 P(x|Ci), i = 1, 2，这是种先验概率（Prior Probability），通过贝叶斯公式就能算出后验概率（Posterior Probability）：P(Ci|x)</p>
<p><span class="math display">\[ P(A | B) = \frac{P(B | A) \cdot P(A)}{P(B)} \]</span></p>
<p>这么一来，分类就可以根据最大后验概率对应的种类来选<br />
优化：<br />
为了避免过拟合可以统一 ∑，模型概率变为： <span class="math display">\[\operatorname{L}(u^{1},\vert u^{2},\Sigma)=\prod_{i=1}^{79}f_{\mu^{1},\Sigma}(x^{i})\times\prod_{j=1}^{61}f_{\mu^{2},\Sigma}(x^{79+j})\]</span></p>
<p>协方差矩阵可以直接按样本数量加权和<br />
统一协方差矩阵后，其实如果进行化简会发现此时依旧是一个线性模型，即 wx+b 形式的模型</p>
<div class="note info"><p>在统计学中，方差是用来度量单个随机变量的离散程度，而协方差则一般用来刻画两个随机变量的相似程度<br />
<img src="https://www.zhihu.com/equation?tex=%5Csigma_x%5E2%3D%5Cfrac%7B1%7D%7Bn-1%7D%5Csum_%7Bi%3D1%7D%5En%5Cleft%28x_i-%5Cbar%7Bx%7D%5Cright%29%5E2&amp;consumer=ZHI_MENG" /> <img src="https://www.zhihu.com/equation?tex=%5Csigma%5Cleft%28x%2Cy%5Cright%29%3D%5Cfrac%7B1%7D%7Bn-1%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_i-%5Cbar%7Bx%7D%5Cright%29%5Cleft%28y_i-%5Cbar%7By%7D%5Cright%29&amp;consumer=ZHI_MENG" /></p>
</div>
<p>以上两种 model，其实逻辑回归的准确率在宝可梦数据集上略好于概率分布，这可能是因为概率模型会预先假设数据符合一种概率分布，因此概率模型相对更适合模型数量少或者有一定 noise 的情况</p>
<h4 id="softmax">softmax</h4>
<p>前两个模型考虑了二分的情况，那么多个类别呢？这时仍然需要模型输出概率，但是概率总和需要小于等于 1，然后选一个最高的作为输出；问题变成了如何得到这样的概率，可以用 <strong>softmax</strong><br />
对每个输出值 <span class="math inline">\(o_j\)</span> 预测概率值 <span class="math inline">\(\hat y_j\)</span> 可以这么得到：<br />
<span class="math display">\[ {\hat{y} }_{j}={\frac{\exp(o_{j})}{\sum_{k}\exp(o_{k})} } \]</span><br />
<span class="math inline">\(\hat y_j\)</span> 可以视为对给定任意输入 x 的每个类的条件概率，即 P(y = 某类 | x)<br />
整个数据集的条件概率为：<br />
<span class="math display">\[P({\bf Y}\mid{\bf X})=\prod_{i-1}^{n}P({\bf y}^{(i)}\mid{\bf x}^{(i)}).\]</span><br />
根据最大似然估计, 我们最大化 P(Y|X), 相当于最小化所有子概率的负对数和<br />
<span class="math display">\[ -\log P(\mathbf{Y}\mid\mathbf{X})=\sum_{i=1}^{n}-\log P(\mathbf{y}^{(i)}\mid\mathbf{x}^{(i)})=\sum_{i=1}^{n}l(\mathbf{y}^{(i)},{\hat{\mathbf{y} } }^{(i)}) \]</span><br />
其中的损失函数是交叉熵<br />
<span class="math display">\[l({\bf y},\hat{\bf y})=-\sum_{j=1}^{q}y_{j}\log\hat{y}_{j}.\]</span> 

$$\begin{align}
l({\bf y},\hat{\bf y})=  -\sum_{j = 1}^{q}y_{j}\log{\frac{\exp(o_{j})}{\sum_{k = 1}^{q}\exp(o_{k})}}   \\ 
=\sum_{j = 1}^{q}y_{j}\log\sum_{k = 1}^{q}\exp(o_{k})-\sum_{j = 1}^{q}y_{j}o_{j} \\
=\log\sum_{k = 1}^{q}\exp(o_{k})-\sum_{j = 1}^{q}y_{j}o_{j}.

\end{align}$$

$$ \partial_{o_{j}l}({\bf y},\hat{\bf y})=\frac{\exp(o_{j})}{\sum_{k=1}^{q}\exp(o_{k})}-y_{j}=\mathrm{sofmax}({\bf o})_{j}-y_{j} $$

</p>
<p>softmax 是一个非线性函数, 但 softmax 回归的输出仍然由输入特征的仿射变换(保持点、直线和面之间相对关系的变换)决定，因此, softmax 回归是一个线性模型<br />
看上去很巧，导数就是 softmax 模型分配的概率与实际发生的情况(由独热标签向量表示)之间的差异 <a href="./#分布">数学原理</a></p>
<h3 id="优化技巧">优化技巧</h3>
<p>训练效果取决于很多因素，常见的排查思路有：</p>
<ul>
<li>Model Bias: 训练数据有一定倾向性，实际的 function set 过于小以致于没有理想的函数，此时可能需要增加参数或者增加数据量</li>
<li>局部最小值和鞍点: 可以用泰勒公式估算附近的函数值，这两种点的梯度(一阶导)都是 0，区别在于二阶导数，如果恒非正/非负，就是极值，否则就是鞍点
<ul>
<li>令附近点与求导的点之间的向量为 v, 泰勒公式的二阶项可以写成 <span class="math inline">\(v^THv\)</span> 的形式(H 是对各个 w 的二阶导数项组成的句子)，用线代的指示，该式恒非正/非负等价于 H 的特征值恒非正/非负
<ul>
<li>这样一来，对鞍点，设 H 的特征向量为 u， <span class="math inline">\(u^THu = \lambda||u||^2\)</span> , 沿着为负的特征向量方向就能继续下降</li>
</ul></li>
<li>另一种思路是所谓的动量，动量本质上是之前的梯度的加权和，类比物理上的动量，能一定程度上保持训练整体的倾向, 将其与当前梯度相加, 能一定程度上帮助跳出局部最低点</li>
</ul></li>
<li>有时静态的更新很难达到最低点(更新快会遇到不同参数收敛速度不同导致的震荡，慢会龟速爬行)，因此需要动态的更新机制: <span class="math inline">\(\theta_{i}^{t+1}\leftarrow\theta_{i}^{t}-\frac{\eta}{\sigma_{i}^{t} }\,g_{i}^{t}\)</span> 其中 <span class="math inline">\(\sigma_{i}^{t}=\sqrt{\frac{1}{t+1} \sum_{i=0}^{t}(g_{i}^{t})^{2} }\)</span> <span class="math inline">\(g_{i}^{t}=\frac{\partial L}{\partial\theta_{i}}|_{\theta=\theta^{t}}\)</span> (adagrad)
<ul>
<li>但依然有问题: 同一个参数在不同的取值范围内收敛速度也不同，因此需要进一步的动态机制(RMS Prop): <span class="math inline">\(\theta_{i}^{t+1}\leftarrow\theta_{i}^{t}-\frac{\eta}{\sigma_{i}^{t}}\,g_{i}^{t}\quad\sigma_{i}^{t}=\sqrt{\alpha\!\left(\sigma_{i}^{t-1}\right)^{2}+(1-\alpha)\!\left(g_i^{t}\right)^{2}}\)</span> 从而让最近的梯度影响更大</li>
<li>著名的 adam 就是同时用了 <code>momentum</code> 和 <code>RMS Prop</code>, 动量与 <span class="math inline">\(\sigma\)</span> 的不同是: 动量考虑方向, 而后者只考虑大小</li>
</ul></li>
<li>上述方法还是会有震荡, 只不过震荡会最后收敛, 因此考虑能否动态调整学习率
<ul>
<li>最常见的做法是学习率衰减 <code>learning rate decay</code></li>
<li><code>warm up</code>, 也就是让学习率先快后慢, 很难解释, 但先快后慢的 warmup 在很多知名模型里表现很好</li>
</ul></li>
</ul>
<p>一般来说, adam 比 SGDM(使用动量的 sgd)速度快, 但最后收敛的效果差一点, 这两者可以说是两个极端, 常用的优化策略会在两者间折中或者微调, 但可解释性嘛, 都很难说 以下简单的记录一些相关方法:</p>
<p>adam 部分:</p>
<ul>
<li>SWATS: 朴素的方法, 先用 adam 快速逼近目标, 再用 sgdm 慢慢收敛</li>
<li>AMSGrad: 某些局部的梯度可能会超过几个数量级的高, 因但由于 adam 算的是平方均根, 这个局部梯度影响会非常有限,(例如 a 比 b 小 100 倍, 平方根只差 10 倍,100 个 a 的梯度却大于一个 b 的梯度) 因此可以记住一个历史最大值, 从而相对扩大大梯度的影响力, 这样的话连续遇到小梯度学习率不会减少, <span class="math inline">\({ {\theta_{t}=\theta_{t-1}-\frac{p}{\sqrt{\hat{v}_{t}+\varepsilon}}m_{t}\space\space } } { {\hat{v}_{t}=\operatorname*{max}(\hat{v}_{t-1},v_{t})} }\)</span> 但这其实没有解决 adagrad 学习率不断衰减的问题, 只是延缓了</li>
<li>AdaBound: 给 learning rate 设置上下限(clip 函数), 简单粗暴, 可解释性也很迷</li>
<li>cyclicalLR: 让 lr 周期性波动, 简单的线性波动或者 cos 函数都可以, lr 大是探索性的, 小是寻找收敛点, 类似的有 <code>SGDR</code>, <code>One-cycle LR</code> 等</li>
</ul>
<p>RAdam: 用于解决训练初期梯度方差大, 先用 sgdm 积累足够的样本, 再转到类似 adam 的方法, 同时让非初期的梯度有更高影响力<br />
假设梯度是取样于一种分布, 因此参数只和取样次数 t 有关, 学习率满足以下条件, 其中 rt 是恒增的</p>
<p><span class="math display">\[\begin{array}{c}{ {\rho_{t}=\rho_{\infty}-\frac{2t\beta_{2}^{\ t} }{1-\beta_{2}^{\ 2} } } }\\ { {\rho_{\infty}=\displaystyle\frac{2}{1-\beta_{2}^{\prime} }-1} }\\ r_{t}={\sqrt{\frac{(\rho_{t}-4)(\rho_{t}-2)\rho_{\infty} } {(\rho_{\infty}-4)(\rho_{\infty}-2)\rho_{t} } } } \end{array}\]</span></p>
<p><span class="math display">\[\theta_{t}=\theta_{t-1}-\eta\hat{m}_{t} \space when \space 𝜌𝑡 ≤ 4\]</span></p>
<p><span class="math display">\[\theta_{t}=\theta_{t-1}-{\frac{\eta r_{t} }{ {\sqrt{\hat{v} }_{t}+\varepsilon} } }\,{\hat{m} }_{t} \space when \space 𝜌𝑡 &gt; 4\]</span></p>
<p>这是一个比较保守的策略, 防止太过激进的学习</p>
<p>动量相关:</p>
<ul>
<li>Nesterov accelerated gradient (NAG): 与普通动量法区别是, 用动量来预测下一个参数位置, 通过预测位置的梯度更新参数 <span class="math inline">\(m_{t}={\lambda}m_{t-1}+\eta\nabla L(\theta_{t-1}-\lambda m_{t-1})\)</span></li>
</ul>
<p>其他:</p>
<ul>
<li>Lookahead: 一种很抽象的方法, 不管用什么优化方法, 每轮中走 k 步到一个理论上的终点, 在起点和终点间找一个点作为实际终点<br />
</li>
<li>Shuffling, Dropout, Gradient noise: 这些都是增加随机性的方法</li>
<li>Warm-up, Curriculum learning(先学容易的数据), Fine-tuning(使用预训练的模型)</li>
</ul>
<p>经验上, cv 用 sgdm 多一点; nlp, gan 用 adam 多一点</p>
<h3 id="normalization">Normalization</h3>
<p>为了处理不同维度上输入规模不一的问题, 需要归一化<br />
Feature Normalization: 我们把统一维度的 x 输入视为正态分布的, 令 <span class="math inline">\(\widetilde{x}_{i}^{r}\leftarrow{\frac{x_{i}^{r}-m_{i} }{\sigma_{i}} }\)</span> 其中 m 为平均数, 𝜎 是标准差<br />
当然也可以对与 w 的加权和 z 向量做归一化: <span class="math inline">\({\tilde{z}}^{i}=\frac{z^{i}-\mu}{\sigma}\)</span><br />
然后令 <span class="math inline">\(z^{i}=\gamma\Theta\widetilde{z}^{i}+\beta\)</span> , 其中 γ 初始为 1, β 初始为 0, 这两个是学习参数, 用于在之后调整分布<br />
这样的归一化计算量较大, 实际中一般只对 batch 做归一化</p>
<p><img src="/assets/ml/Pasted%20image%2020250902150544.png" /></p>
<h2 id="卷积神经网络-cnn">卷积神经网络 CNN</h2>
<p>名词解释:</p>
<ul>
<li>Receptive Field（感受野）: 字面意思, 就是神经元的视野, cv 中我们希望神经元各自只捕捉一个局部特征, 一般感受野会是方形矩阵
<ul>
<li>最常见的 rf 是覆盖所有维度(channel)的, 也就是所有色彩空间, 常见的 rf 是 3×3, 且会有复数的神经元</li>
<li>共享参数: 即两个神经元用相同的参数, 常见的共享方法是: 每个 rf 有 n 组神经元, 不同的 rf 相同组序号的神经元共享参数; 也可以理解为用不同的 filter 矩阵(也就是共享参数的神经元)做卷积</li>
</ul></li>
<li>stride(步幅): 感受野之间的步幅, 例如一个 rf 对上的最左上元素是(i, j), 下一个对上的左上元素就是(stride+i, j)</li>
<li>padding: 由于内核矩阵以及步幅未必会让最后一步正好够运算, 有时需要填充若干行/列, 最常用的是直接填 0</li>
<li>pooling(池化): 在不改变关键信息的前提下尽可能简化输入规模, 例如对规模是 m×m 的矩阵, 对每个 n×n 的子矩阵取一个最大值, 最后得到边长 m/n 的方阵</li>
<li>flatten: 将最后的结果拉长为一维向量, 用于之后的模型学习</li>
</ul>
<p>基于以上限制, cnn 的 <code>model bias</code> 其实相对较大, 但在影像辨识中不是坏事</p>
<h3 id="spatial-transformer-layer">spatial transformer layer</h3>
<p>鉴于 CNN 的特点, 它对图片缩放, 旋转, 镜像后的数据, 不会依旧保有识别能力.当然想处理这个问题很简单, 把经过变化的图片也塞进训练集就可以了, 但是这样会严重影响训练效率, 而更好的做法是, 增加一个图片变化层, 用于转化图片到训练集的对应数据<br />
对图片的每个像素, 一个 2×2 的权重矩阵加一个 2 维的偏移向量就可以得出其对应像素, 而对于非整数的对应坐标, 出于可微性考虑, 将其与周边点的距离积为权值乘以周边点的值, 最后相加, 如下所示:<br />
<span class="math display">\[\begin{array}{l}{ {a_{22}^{l}=(1-0.4)\times(1-0.4)\times{}(1-0.4)\times a_{22}^{l-1} } }\\ { {+(1-0.6)\times(1-0.4)\times(1-0.6)\times a_{12}^{l-1} } }\\ { {+(1-0.6)\times(1-0.6)\times(1-0.6)\times a_{23}^{l-1} } } \\ { +(1-\,0.4)\times(1-0.6)\times a_{23}^{l-1} } \end{array}\]</span> 由于这样的取值是可微的, 也就可以用梯度下降进行学习, 将其嵌入神经网络中则可提高对变化后图片的识别效果</p>
<h2 id="self-attention">self-attention</h2>
<p>sequence labeling: 即为输入序列中的每个元素分配一个标签, 例如 nlp 中标注词性.这种问题的难点在于: 由于输入的向量长度不定, 难以确定应该用什么规格的网络, 于是需要注意力这种机制来让一个输入向量 a 能获取一些序列中的上下文信息形成向量 b 再进入网络<br />
那么怎么让 a 携带上下文信息呢, 常见的思路有做加权和(additive)或者加权积(dot-product), 后者更常用, 也就是输入向量各种乘以一个(互不相同的)权重, 然后乘在一起<br />
s-a 层所做的运算如下图:</p>
<p><img src="/assets/ml/Pasted%20image%2020250831171404.png" /></p>
<p>实际上, 该层学习的就是三个权值矩阵</p>
<p>相关技术:</p>
<ul>
<li>Multi-head Self-attention: 简单地说就是用两个独立的注意力神经, 其产物算加权和作为最终输出</li>
<li>Positional Encoding: 为了弥补注意力没有位置信息的问题, 最早的处理是对输入 ai 加上一个 ei 偏置, 后续发展中有不同的添加位置信息的方法</li>
<li>Truncated Self-attention: 对语音这种规模很大的输入, 出于效率考虑, 可以减少注意力计算的范围, 只看很小的上下文</li>
<li>CNN: cnn 可以视为注意力的一种特例</li>
<li>RNN: 相比 rnn, 注意力在并行性, 以及对上下文信息的利用能力上都相对更好</li>
</ul>
<h3 id="变形金刚">变形金刚</h3>
<p>transformer, 下文简称 tf, 是一种 seq2seq 模型, 这种模型有相当广泛的应用, 语音辨识/合成, 句法分析, 目标检测, 以及现在热门的对话生成都可以使用</p>
<p><img src="/assets/ml/seq2seq_v9.png" /></p>
<p>tf 的架构相当复杂, 这里简单地描述一下: 其主要用 en/decoder 组成, encoder 中有很多 <code>block</code> 用于生成中间向量, 每层 <code>block</code> 先做一次注意力(结果向量加上输入向量, 这叫做 <code>residual connection</code>, 随后做一次 <code>layer normalization</code>), 再用全连接(fc)网络计算, 这个 fc 网络也会用 <code>residual</code><br />
<code>decoder</code> 除了接受 <code>encoder</code> 数据外, 还要接受一个表示开始产生输出的符号(bos), 这个符号可以用 one-hot 表示, 类似 rnn, dec 不断把自己的输出当做下一轮的输入, 如果输出一个终止符来结束, 就叫 <code>Autoregressive</code>; 而 <code>Non-autoregressive</code> 则一次生成所有输出, 一个输入对应一个输出, 为此需要一个分类器来产生长或者一个足够长的默认长度, 让机器自己选一个槽位输出终止符, 这样的好处是并行化且容易控制长度, 缺点则是表现差<br />
关于 dec 的架构, 观察其与 enc 不同, 首先是注意力层多了 masked 前缀, 这个掩码就是让所有输入维度的注意力只能注意自己极其以前的输入(由于 decoder 输出有顺序, 这样很符合直觉)<br />
关于两者的交互, 看下面的图比较直观, 不太准确的说就是同时用双方的数据不断地做 masked 注意力(输出会不断作为下一轮输入加进来), 这叫做 <code>Cross Attention</code><br />
原始论文中 dec 不断从 enc 的最后一层拿数据, 但也有论文会对应着拿<br />
<img src="/assets/ml/seq2seq_v9_1.png" /></p>
<p>相关技术:</p>
<ul>
<li>Teacher Forcing: 简单地说就是训练时直接将答案作为 dec 输入</li>
<li>Copy Mechanism: 从输入中复制文字给输出用的能力</li>
<li>Guided Attention: 对一些规则严格的场景, 可以直接对训练中的模型加以限制, 例如语音合成</li>
<li>Beam Search: 一种常用于序列预测任务的搜索算法, 能在一定程度上预测相对更优的序列/路径</li>
<li>exposure bias: dec 辨识错误的能力差, 导致一步错步步错, 解决方法是增加一些 Noise</li>
<li>Scheduled Sampling: 在训练过程中, 逐步减小使用真实目标序列的概率</li>
</ul>
<h3 id="bert">bert</h3>
<p>bert, 目前很火的预训练 seq2seq 模型, 是一种无监督学习模型, 也就是没有 label 数据, 其特点是训练中使用掩码数据(Masking Input), 也就是遮住输入的部分字词, 而加上遮住数据的完整输入就是我们希望 bert 能输出的结果, 而损失函数也可以比较方便地用交叉熵(可以理解为以所有字符为类别的分类问题)<br />
bert 是基于 tf 的, 其架构和 tf 类似, 区别就是用掩码机制来无监督学习, 由于不需要标注的数据集, bert 很容易得到规模非常庞大的数据, 因此有着很好的表现 除此以外有一些其他训练方法, 如 Next Sentence Prediction: 预测两个句子是否相接; Sentence order prediction: 判断句子的顺序关系<br />
在以下这些常见的一些基准测试中, bert 都有不俗的表现:</p>
<ul>
<li>Corpus of Linguistic Acceptability (CoLA)</li>
<li>Stanford Sentiment Treebank (SST-2)</li>
<li>Microsoft Research Paraphrase Corpus (MRPC)</li>
<li>Quora Question Pairs (QQP)</li>
<li>Semantic Textual Similarity Benchmark (STS-B)</li>
<li>Multi-Genre Natural Language Inference (MNLI)</li>
<li>Question-answering NLI (QNLI)</li>
<li>Recognizing Textual Entailment (RTE)</li>
<li>Winograd NLI (WNLI)</li>
</ul>
<p>尽管 BERT 的预训练是无监督的，但在特定下游任务（如文本分类、语法分析等）中(对这些下游任务来说, 可以简单地给 bert 接上分类或者线性模型)，BERT 可以进行微调, 这个过程是监督学习。微调阶段使用标注好的数据集，通过已知的标签来优化模型参数.所以如果想准确一点, 可以叫半监督学习(semi)<br />
bert 的优异性能常常被归因于注意力对上下文的捕获能力以及大量的训练资料, 但神奇的是用于做蛋白质分类效果也很好, 英语 Bert 用在中文上效果也很好, 这或许可以理解为这些有规律的编码作为语言其实在词义向量以及结构上有相似之处, 根据李老师自己的实验, 这种神奇的能力只会出现在足够大的训练集上</p>
<h2 id="rnn">RNN</h2>
<p>相关场景:</p>
<p>slot filling: 类似一个分类问题, 将给定输入向量(一句话)中的词语分类到特定的槽位去</p>
<p>rnn 用于解决输入向量间有顺序关系的问题, 普通的前馈网络所有输入的词语都是地位相同的, 因此很难捕捉文字的前后语义关系, 于是产生了 rnn 这种方法, 也就是把前面的计算结果作为之后的输入, 常见的类型有:</p>
<ul>
<li>简单 rnn
<ul>
<li>elman network: 先前的隐藏层计算结果存起来, 后面被下一个神经元的隐藏层调用</li>
<li>jordan network: 将前一个神经元的输出存起来, 被下一个神经元调用</li>
</ul></li>
<li>其他
<ul>
<li>Bidirectional RNN: 训练正向和反向的两个 rnn, 最后的输出算加权和</li>
</ul></li>
</ul>
<h3 id="long-short-term-memory-lstm">Long Short-term Memory (LSTM)</h3>
<p>简单地说就是用两个阀门控制是否存入或放出历史信息, 一个阀门控制是否遗忘已有的信息, 阀门的开闭让网络学习<br />
其训练过程相对来说比较繁琐, 还好李老师细心地做了流程图, 这里直接贴上来</p>
<div class="pdf-container" data-target="/assets/ml/RNN.pdf" data-height="800px"></div>
<p>LSTM 的缺点是过于复杂导致计算成本高, 因此有 Gated Recurrent Unit (GRU)这样的简化版本(三个 gate)</p>
<h3 id="问题">问题</h3>
<ol type="1">
<li><p>RNN 会复用之前的模型, 例如其权值 w, 这会导致层数上来后, 后面神经的权值会产生幂函数关系, 使 loss surface 非常陡峭<br />
更准确地说, 由于幂函数的特性, w 小会很容易梯度消失, w 大则非常陡峭, LSTM 可以一定程度上解决前一个问题, 因为它能存储历史信息更长时间<br />
而后一个问题, 工程上最实用的方法是 clip 设置上界</p></li>
<li><p>鉴于 rnn 的特性, 处理不定长的输入(向量)是很方便的, 但如何处理不定长的输出呢?<br />
例如语音识别, 对若干音频输入, 简单的想法是每个音频输出一个字符, 结果把每个输出的重复部分拿掉, 但如何处理叠词呢?<br />
可以用一个 φ 符号代表 null, 也就是分割符, φ 间的有意义输出作为识别结果, 下一个问题是, 音频可能切的很碎, 不能保证对应关系具体应该怎么排<br />
为此需要 <code>Connectionist Temporal Classification (CTC)</code> 简单地说就是穷举可能的排列(实际会用 dp 优化), 选取其中最多的一种(即概率最大的排列/对应关系)</p></li>
</ol>
<p>以上讨论的语音识别其实有一个预设--识别结果的字符数 ≤ 音频样本数, 对没有这种条件的问题, 例如机器翻译该怎么做呢?<br />
由于是循环的, rnn 可以不断地产生输出, 只需要一个特殊的表示结束的符号就可以, 例如 <code>===</code></p>
<h2 id="深度学习">深度学习</h2>
<p>Q: 为什么要深度, 为什么要用那么多隐藏层而不是一个很宽的单层网络?<br />
A: 深度学习能增加预测函数的弹性, 这是因为它可以复杂的不同线性关系去拟合数据, 那么为什么要用很深的网络?实际上, 相同神经数量且较浅的网络预测效果会不如 dl, 也就是 dl 能用相对更少的参数拟合数据, 因此更不容易 overfitting, 有更好的准确率; 而 dl 的这种高效其实类似编程中的依赖关系, 例如某个节点的后继节点都可以依赖于前一个节点, 而整段程序只需要保留这个被多重依赖的节点的一个副本, 节省大量空间, dl 中其实也可能存在对某个前继神经的依赖关系, 也就是 dl 是一个有结构上关系的网络</p>
<h3 id="概念">概念</h3>
<p>对于复杂的网络, 会使用神经网络块(block)来描述若干个网络层的组合, 一般来说, 块有自己的参数, 前向传播, 反向传播函数, 这是一个逻辑概念, torch 中可以用模块或者 seq 来实现</p>
<div class="note info"><ul>
<li><code>torch.nn.Module</code>: Base class for all neural network modules.Your models should also subclass this class.即所有模型的基类</li>
<li><code>torch.nn.Sequential</code>: Modules will be added to it in the order they are passed in the constructor. 有顺序的 <code>module</code> 的容器, 与 <code>ModuleList</code> 的是它提供对内置模块的顺序调用, 也就是已经实现了前向传播, 因此它很适合用来定义一个 block</li>
<li><code>torch.nn.ModuleList</code>: Holds submodules in a list. 模块的 list, 和普通的 list 没什么区别, 有索引顺序, 但并没有逻辑上的顺序</li>
</ul>
</div>
<h1 id="技术">技术</h1>
<h2 id="扩散模型">扩散模型</h2>
<h3 id="vae-变分自编码器">VAE 变分自编码器</h3>
<p>对于生成任务，有一套直白的思路： 对一群数据提取特征，编码为一种分布，然后在生成时从分布中采样作为解码<br />
若输入的数据为 x, 编码出的隐式数据为 x, p(z|x)称为后验概率，也就是给定发生了什么得到的估计；p(x|z)称为似然，也就是根据已有知识，对应该发生什么的估计<br />
现在的问题是，如何得到一个性质良好的 z，这个良好指两方面:</p>
<ol type="1">
<li>解码(重建)时还原程度高</li>
<li>在通过对隐空间采样来反向预测 x 时也有良好的表现</li>
</ol>
<p>为此，VAE 用高斯分布建模一个隐式空间，且定义其 loss 如下:</p>
<p><span class="math inline">\(\mathcal{L}(x)=\mathbb{E}_{q(z|x)}\left[\log p(x|z)\right]-{ { {\operatorname{KL}(q(z|x)\ |\ p(z))}}}\)</span></p>
<p>这个 loss 想实现的目的是，在分布散度差距和还原损失之间取得平衡<br />
我们要学习的参数是方差和均值，那么怎么做呢？这里引入一个 <span class="math inline">\(\epsilon\)</span> 表示对标准正态分布的随机采样，将其乘方差再加上均值，就得到了一个模拟的采样结果可用于求梯度</p>
<h3 id="flow-based-model">flow-based model</h3>
<h4 id="normalizing-flow">Normalizing flow</h4>
<p>主要参考李宏毅老师的视频以及一篇 <a href="https://zhuanlan.zhihu.com/p/718997970">博文</a></p>
<p>在数学上，生成模型其实生成的是概率分布，一般将输入数据视为对某种分布的采样，用来学习一种分布 G，最后再对学习的分布 G 随机采样来得到新的生成数据<br />
这种所谓的随机采样，可以理解为对一种分布例如常见的正态分布采样，将这个采样的数据映射到我们学习到的分布 G 上，我们希望 G 的分布和真实数据的分布(这个分布是假想的)越接近越好，例如上面的 VAE 就会不断约束 G 的重构损失和 KL 散度<br />
如果我们想直接优化分布之间的映射关系呢？</p>
<p>接下来需要引入一些前置知识:</p>
<div class="note info"><p><strong>Jacobian matrix</strong> 是一个数学概念，主要用于多变量微积分和向量微分。在函数的多变量情况下，Jacobian 矩阵描述了函数的局部线性近似<br />
对于一个从 <span class="math inline">\({R}^n\)</span> 到 <span class="math inline">\({R}^m\)</span> 的函数 ，其 Jacobian 矩阵 ( J ) 定义为函数在某一点的偏导数矩阵。矩阵的元素形式如下：</p>
<p><span class="math display">\[ \begin{bmatrix}
\frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_1}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_1}{\partial x_n} \\
\frac{\partial f_2}{\partial x_1} &amp; \frac{\partial f_2}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_2}{\partial x_n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\frac{\partial f_m}{\partial x_1} &amp; \frac{\partial f_m}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_m}{\partial x_n}
\end{bmatrix}
\]</span> 此外，逆函数的 J 矩阵也互逆</p>
<p>行列式学过线代的都知道，其几何意义可以粗略理解为一个任意维度空间中的，矩阵所描绘的几何体的 "体积"</p>
</div>
<p>那么，开始讨论概率分布的转化方法，给定随机变量 z，及其概率密度函数 π(z)，将其的分布转化为另一种分布实际上就是一种映射，设这个映射函数为 f, 即 <span class="math inline">\(x=f(z)\)</span> ，X 是转化出的新变量，其概率密度函数为 p(x)<br />
那么对这个映射，我们知道所有概率函数的积分总和为 1，也就是面积在映射中是不变的，那么基于常识让 <span class="math inline">\(p(x)dx=\pi (z)dz\)</span><br />
而对向量的映射，其实也类似，只不过 z 对应向量的微分乘积会对应到 x 对应向量矩阵的行列式<br />
代入和化简后得到:<br />
<span class="math display">\[p(x^{\prime})=\pi(z^{\prime})\left|\frac{1}{d e t(J_{f})}\right|\]</span> 由于互逆矩阵的 det 乘积为 1 且 J 矩阵的逆矩阵和对应逆函数的 J 矩阵相同, 也可以写成</p>
<p><span class="math display">\[p(x^{\prime})=\pi(z^{\prime}){\big|}d e t{\big(}J_{f^{-1}}{\big)}{\big|}\]</span></p>
<p>其实这个式子很直观，J 矩阵里是 x 对 z 的微分，那么其逆矩阵就是 z 对 x 的微分，那么其行列式可以理解为映射中，z 的“底面积 "对应 x”底面积" 的比例关系(而“高 " 就对应概率本身)<br />
基于这个数学式的生成模型称为 G，即 G 将 π(z)(通常是对正态分布取样)转化为一个概率分布 p(x), 可以形象地写作 <span class="math inline">\(x=G(z) \space | \space z=G^{-1}(x)\)</span></p>
<p>先前的表达式的对数形式为:<br />
<span class="math inline">\(l o g p_{G}(x^{i})=l o g\pi\left(G^{-1}(x^{i})\right)+l o g|d e t(J_{G^{-1}})|\)</span><br />
由于 π 一般是一个正态分布，第一项会倾向于在中间(标准正态分布就是 0 向量附近)取点，第二项表示的可以某种意义上理解为映射后微分空间的分散的程度的对数，如果总在中间取点，几乎没有分散，则对数是很小的负数，产生很大的惩罚; 因此这样的形式能一定程度上约束分布不要过于集中</p>
<p>目前为止我们得到了一个优雅的数学式，但与常见的 ml 模型不同的是，在这个情况下(需要 x, z 相互可逆)，x、z 有相同的长度，这产生了两个问题：</p>
<ol type="1">
<li>计算量大</li>
<li>对模型的约束较大，可能会降低泛化能力</li>
</ol>
<p>这就是为什么名字叫 flow 了，因为我们会用一串 G 来弥补模型弹性不足的问题, 为什么可以这样做？对 z 的变化可以说是链式的，在微分层面可以很直接地表示为多个 J 矩阵行列式对 p(z)连乘，用一个对数函数就可以转化为连加, 因此实际上用一个 G 和一连串 G 除了计算量没有本质区别，以下讨论一个 G 的情况<br />
对一个具体的 G，实际训练时考虑到计算量，会使用 <code>coupling layer</code> 这样的技术，它巧妙地牺牲一部分输入数据(不做变换仅复制)让涉及到的行列式和逆矩阵都很容易计算; 也可以用一对一的卷积，对其内核矩阵(涉及的论文里是 3×3)算行列式以及微分</p>
<p><img src="/assets/ml/image-4.png" /></p>
<h3 id="flow-matching">Flow Matching</h3>
<h4 id="数学-1">数学</h4>
<p>常微分方程: 形如 <span class="math inline">\({\frac{d y(t)}{d t}}\,=\,f(y(t),t)\)</span></p>
<p>其中, t 为时间，f 描述 y 与 t 的关系且可微分，一般来说 y 是需要求解的量<br />
例如如果已知一个初始值，可以写作: <span class="math inline">\(y(t_{1})=y_{t_{0}}+\int_{t_{0}}^{t_{1}}f(y(t),t)d t\)</span><br />
对复杂的神经网络，很多时候不能也没有必要求解析解，可以用一些数值方法估算：</p>
<ul>
<li><code>Euler Method</code>: 直接用区间面积的和估算，形如 <span class="math inline">\(y(t_{1})\approx y(t_{0})+\sum_{i=0}^{N-1}h f(y(t_{0}+i h),t_{0}+i h)\)</span> 其中 h 是区间宽度</li>
<li><code>Neural ODE</code>: 使用例如 <code>residual network</code> 之类的网络求解，这里不详细介绍</li>
</ul>
<h4 id="向量场与流">向量场与流</h4>
<p><a href="https://xyfjason.top/blog-main/2024/06/22/Flow-Matching">参考博文1</a> <a href="https://zhuanlan.zhihu.com/p/1946706315792619506">参考博文2</a></p>
<p>上文介绍的标准流是通过组合一系列的生成器获得表达能力的，而每个生成器通过微分矩阵来评估映射的性质，因此命名为 flow 很直观<br />
而对 flow 来说，想到向量也很直观，CNF 正是一种基于向量场的方法<br />
为什么要用向量场呢？想象分布 p 是一群点，当然它可以是无数个，这些点我们希望能都被一一映射到另一个分布里去，这就像初中物理课做的磁场实验，改变电磁铁的通电流向(磁性)，在磁场的作用下铁屑们就会纷纷自己组成另一种形状<br />
在这种场作用下的 <strong>概率分布 p</strong> 的运动轨迹成为概率密度路径，与之前不同的是运动需要时间，这里引入一个时间 t 变量，范围是 <code>[0,1]</code>, 此外概率函数自己的性质是 p(x)对 x 的积分必定是 1，即 <span class="math inline">\(\textstyle\int p_{t}(\mathbf{x})\mathrm{d}\mathbf{x}=1\)</span><br />
接下来定义向量场为: <span class="math inline">\(\mathbf{u}:[0,1]\times\mathbb{R}^{d}\to\mathbb{R}^{d}\)</span> u 也可以理解为瞬时速度<br />
那么 u 和 p 什么关系，作为计算机专业不用懂原理，但存在这么一个方程式:</p>
<p><span class="math display">\[\frac{\partial}{\partial t}p_{t}({\bf x})+\nabla\cdot(p_{t}({\bf x}){\bf u}_{t}({\bf x}))=0\]</span></p>
<p>需要注意概率密度路径与速度场不是一一对应的，不同的速度场可以产生相同的概率密度路径</p>
<p>接下来回归标题，标题的流 flow 正是运动时的轨迹，定义为: <span class="math inline">\(\frac{\partial}{\partial t}\phi_{t}({\bf x})={\bf u}_{t}(\phi_{t}({\bf x}))\)</span> , 其中 <span class="math inline">\(\phi _t(x)\)</span> 初值为 x 的粒子在 t 时刻运动到的位置, 也就是对其在 <code>[0,t]</code> 积分就会得到 t 点位置和初始位置的位移<br />
那么显然 p 和 <span class="math inline">\(\phi\)</span> 之间也有关系，这里之间放出来:</p>
<p><span class="math display">\[ p_t(\mathbf x)=p_0(\boldsymbol\phi_t^{-1}(\mathbf x))\left|\det\left[\frac{\partial\boldsymbol\phi_t^{-1}}{\partial\mathbf x}(\mathbf x)\right]\right| \]</span></p>
<p>这称为 push-forward 方程，其中 t 时刻位于 x 位置处的粒子在 0 时刻的出发位置是 <span class="math inline">\(\boldsymbol\phi_t^{-1}(\mathbf x)\)</span></p>
<p><img src="/assets/ml/relation.png" /></p>
<h4 id="连续归一化流-continuous-normalizing-flows-cnfs">连续归一化流 (Continuous Normalizing Flows, CNFs)</h4>
<p>终于说到生成模型了，令 <span class="math inline">\(p_t(x)\)</span> 为概率密度路径，p0 是一种简单分布(例如标准正态分布), p1 是输入数据的分布, <span class="math inline">\(u_t(x)\)</span> 为 p0 运动到 p1 对应的向量场，那么流匹配的模板就是用网络构建向量场 <span class="math inline">\(\mathbf v_{t}^{\theta}(\mathbf x)\)</span> 去近似 <span class="math inline">\(u_t(x)\)</span><br />
虽然一上来就定义了很多变量，但经过前文介绍，其实其目的很直观，接下来得到一个同样直观的损失函数:<br />
<span class="math display">\[\mathcal L_\text{FM}(\theta)=\mathbb E_{t,p_t(\mathbf x)}\left[\Vert\mathbf v_{t}^{\theta}(\mathbf x)-\mathbf u_t(\mathbf x)\Vert^2\right]\]</span></p>
<p>当然，真实速度场是未知的，这是生成模型的经典问题，同样有一个经典解决方案，也就是每次取一个样本去近似，不断更新训练，这就需要 <strong>条件速度场</strong><br />
给定某特定样本 x1 ，称 <span class="math inline">\(p_t(x|x1)\)</span> 为条件概率路径，含义为在终点为 x1 的前提下粒子的概率路径, t=0时<code>p(x|x1)=p(x)</code>, t=1时 <span class="math inline">\(p_{1}(x|x_{1})=\mathcal{N}(x|x_{1},\sigma_{m i n}^{2}I)\)</span> , 即此时粒子离x1极近</p>
<p><span class="math display">\[p_t(\mathbf x)=\int p_t(\mathbf x\vert\mathbf x_1)q(\mathbf x_1)\mathrm d\mathbf x_1=\mathbb E_{q(\mathbf x_1)}[p_t(\mathbf x\vert\mathbf x_1)]\]</span> <span class="math display">\[\mathbf u_t(\mathbf x)=\int \mathbf u_t(\mathbf x\vert\mathbf x_1)\frac{p_t(\mathbf x\vert\mathbf x_1)q(\mathbf x_1)}{p_t(\mathbf x)}\mathrm d\mathbf x_1=\mathbb E_{p(\mathbf x_1\vert\mathbf x)}[\mathbf u_t(\mathbf x\vert\mathbf x_1)]\]</span></p>
<p>使用这种条件向量场更新的流匹配称为 <strong>conditional flow matching</strong><br />
其损失函数为:</p>
<p><span class="math display">\[\mathcal L_\text{CFM}(\theta)=\mathbb E_{t,q(\mathbf x_1),p_t(\mathbf x\vert\mathbf x_1)}\left[\Vert\mathbf v_{t}^{\theta}(\mathbf x)-\mathbf u_t(\mathbf x\vert\mathbf x_1)\Vert^2\right]\]</span></p>
<p>接下来只剩下具体的条件向量场设计问题了，详见 <a href="https://xyfjason.top/blog-main/2024/06/22/Flow-Matching/#%E6%9D%A1%E4%BB%B6%E9%80%9F%E5%BA%A6%E5%9C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1">博文</a></p>
<p>由于这里面有相当多的公式推导，可理解不是那么强，这么简单总结一下作者想表达什么:<br />
<strong>使用条件向量以及上述的损失函数来更新模型理论上和不使条件的情况是一致的(即每次的参数更新梯度一致)</strong> 更好理解的推导可见以下视频</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=112692861864835&amp;bvid=BV1Wv3xeNEds&amp;cid=28321514161&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>接下来是我们最关心的问题：代码怎么写，换句话说，条件向量场 <span class="math inline">\(u_t\)</span> 以及条件概率路径 <span class="math inline">\(p_t(x|x1)\)</span> 怎么表示( <span class="math inline">\(q_{x1}\)</span> 可以采样), 理论上讲，可以有无数种方法，这里这说最常用的高斯分布<br />
对给定样本 x1, 我们希望其拥有的性质:</p>
<ol type="1">
<li>t = 0 时，p(x|x1)服从一个标准正态分布</li>
<li>t = 1 时，p(x|x1)服从一个均值 x1, 方差较小的正态分布</li>
</ol>
<p>令 <span class="math inline">\(p_{t}({\bf x}|{\bf x_{1}})={\cal N}\left({\bf x};\mu_{t}({\bf x_{1}}),\sigma_{t}^{2}({\bf x_{1}}){\bf I}\right)\)</span><br />
流可以写作: <span class="math inline">\(\psi_{t}({\bf x}) = \sigma_{t}({\bf x}_{1}){\bf x}+\mu_{t}({\bf x}_{1})\)</span></p>
<p>可能有读者能猜到，经典的扩散模型例如 DDPM 可以视为这种形式的某种特例,即: <span class="math display">\[u_t(x|x1) =  \frac{\alpha_{1-t}^{\prime}}{1-\alpha_{1-t}^{2}}(\alpha_{1-t}x-x_{1})\]</span></p>
<p>实际中更常用的是最优传输(线性表示):<br />
<span class="math display">\[\mu_t(\alpha)=t x_{1},\;\sigma_{t}(x)=1-(1-\sigma_{m i n})t\]</span><br />
<span class="math display">\[u_{t}(x|x_{1})={\frac{x_{1}-(1-\sigma_{m i n})x}{1-(1-\sigma_{m i n})t}}\]</span><br />
<span class="math display">\[\psi_{t}(x)=(1-(1- \sigma_{m i n})t)x+t x_{1}\]</span><br />
优化为:<br />
<span class="math display">\[\begin{array}{c}{ {u_{t}(\psi_{t}(x_{0};x_{1})|x_{1})=\frac{\mathrm{d}\psi_{t}(x_{0};x_{1})}{\mathrm{d}t}}}\\ { {=x_{1}-({\mathrm{1}}-\sigma_{m i n})x_{0}}}\end{array}\]</span></p>
<p>需要强调的是，最有传输理论上的“直线”更新路径只在给定采样x1的条件下成立，在真正生成数据时粒子依旧走的是曲线路径</p>
<div class="note info">
</div>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>人工智能</tag>
        <tag>国立台湾大学</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习笔记 all in one</title>
    <url>/thinklive/37185/</url>
    <content><![CDATA[<h1 id="基础概念">基础概念</h1>
<p>强化学习和监督学习的区别：</p>
<ol type="1">
<li>强化学习输入的样本是序列数据,监督学习的样本之间相互独立</li>
<li>没有明确的监督者,通过奖励机制进行学习,但回馈可能是长期的,模糊的</li>
</ol>
<p>一些强化学习的演示视频中,ai会做一些人类看来无意义的动作,正是这种“玄学”的回馈机制导致的</p>
<ul>
<li>actor: 行为主体
<ul>
<li>action则可分为离散和连续,例如2d游戏中走格子迷宫就是一个典型的离散动作空间</li>
</ul></li>
<li>observaton o /states s: 观测与状态
<ul>
<li>观测到的情况o和现实情况（状态s）其实有可能不同,假设可以观察到全景,rl则成为一个马尔科夫决策过程</li>
</ul></li>
<li>policy π: 行为策略
<ul>
<li>带有参数θ</li>
</ul></li>
<li>reward：反馈
<ul>
<li>baseline: 避免总是正值的reward,增加的偏置值,例如取期望</li>
</ul></li>
<li>episode: 一轮行动</li>
<li>trajectory τ: <span class="math inline">\(\tau=\{s_{1},a_{1},s_{2},a_{2},\cdots,s_{T},a_{T}\}\)</span></li>
<li>折扣γ: 直觉上,最开始的训练回馈可能更重要,越往后则训练收益越小,所以对每步的回馈可以乘以一个 <span class="math inline">\(\gamma^{t-1}\)</span>,t为训练次数,这个超参数也可以用于控制训练策略偏短期还是偏长期</li>
</ul>
<span id="more"></span>
<p>流程： env(s1)-&gt;actor(a1)-&gt;env(s2)……<br />

$\begin{array}{l}{ {p_{\theta}(\tau)} }{ { {}=p(s_{1})p_{\theta}(a_{1}|s_{1})p(s_{2}|s_{1},a_{1})p_{\theta}(a_{2}|s_{2})p(s_{3}|s_{2},a_{2})\cdots} } \\   =p(s_{1})\prod_{t=1}^{T}p_{\theta}(a_{t}|s_{t})p(s_{t+1}|s_{t},a_{t})\end{array}$  
</p>
<p>同一轮中每对(s,a)产生一个reward,其期望为: <span class="math inline">\(\bar{R}_{\theta}=\sum_{\tau}R(\tau)p_{\theta}(\tau)=E_{\tau\cap P_{\theta}(\tau)}[R(\tau)]\)</span></p>
<p>取梯度</p>


$$ \begin{align*}{r l}{\nabla{\bar{R} }_{\theta} \\ =\sum_{\tau}R(\tau)\nabla p_{\theta}(\tau)}&{\\ =\sum_{\tau}R(\tau)p_{\theta}(\tau){\frac{\nabla p_{\theta}(\tau)}{p_{\theta}(\tau)} } } \\ &=\sum_{\tau}R(\tau)p_{\theta}(\tau){\nabla}l o g p_{\theta}(\tau) \\ &=E_{\tau \sim p_{\theta}(\tau)}[R(\tau)\nabla l o g p_{\theta}(\tau)]\approx\frac{1}{N}\sum_{n=1}^{N}R(\tau^{n})\nabla \log p_{\theta}(\tau^{n}) \\ &={\frac{1}{N} }\sum_{n=1}^{N}\sum_{t=1}^{T_n}R(\tau^{n})\nabla l o g p_{\theta}(a_{t}^{n}|s_{t}^{n}) \end{align*} $$


<p>虽然回报值一般是很难预测的,但是就梯度下降来说这只是个常数,这里取出一个log的微分形式,由于轨迹的概率可以用采样估算,接下来只需要处理log,这个轨迹概率 $ {P(|)=} {p(s_{1})p(a_{1}|s_{1},)p(r_{1},s_{2}|s_{1},a_{1})p(a_{2}|s_{2},)p(r_{2},s_{3}|s_{2},a_{2})} $ 事实上就是轨迹初始状态的概率与一连串的条件概率相乘,对其取微分,忽略与θ无关的项,可以将积转化为和,得到最后这个式子<br />
类似于机器学习的梯度下降,我们通过梯度计算寻找最大化reward的参数,也就是总回报为正时让相关行动的概率增加,为负时相反<br />
这里会用到log的微分,考虑其性质就知道,这会概率,也就是用来估算的采样到的频率,较低的极端值影响,如果运气不好没有采样到某个动作,还会让其他动作相对更高,因此可以考虑将总回报减去一个baseline（因为这里控制倾向性的其实是回报的正负以及大小<br />
和log函数的很多应用场景一样,这里实际上可以理解为分类问题,因为模型输出的动作是有限的,策略最后产生的是动作空间中的概率分布,稍微不同的是需要乘回报值,并且要分很多轮训练</p>
<h2 id="马尔可夫过程">马尔可夫过程</h2>
<p>马尔可夫过程中,对一个特定状态则有一个特定的未来状态概率分布（可以理解为策略）,很容易算出之后的期望回报<br />
即,如果我们希望知道一个特定状态是好是坏,可以定义状态价值V为其回报的期望,即从这个状态开始,折扣γ的指数与之后回报乘积的和,V与回报G的区别是,V绑定一个特定的状态s,即某个s开始的之后获取的回报的期望<br />
t时刻后的回报为：<br />
<span class="math display">\[G_{t}=r_{t+1}+\gamma r_{t+2}+\gamma^{2}r_{t+3}+\gamma^{3}r_{t+4}+\ldots+\gamma^{T-t-1}r_{T}\]</span> 状态s的价值为：<br />
<span class="math display">\[\begin{array}{l}{ {V^{t}(s)=\mathbb{E}\left[G_{t}\mid s_{t}=s\right]} }\\ { {\ } }\\ { {=\mathbb{E}\left[r_{t+1}+\gamma r_{t+2}+\gamma^{2}r_{t+3}+.\cdot.+\gamma^{T-t-1}r_{T}\mid s_{t}=s\right]} }\end{array}\]</span><br />
即给定 <span class="math inline">\(s_t = s\)</span>这个条件后的Gt期望<br />
实际训练中概率没法直接看出来,符合常识的想法是靠采样估算,也就是可以对采样的多组数据取平均值,这称为 <code>蒙特卡洛(Monte Carlo,MC)采样</code><br />
另一种方法是贝尔曼方程,这一方程常用于动态规划,使用下个状态的价值来更新之前状态,写作：<br />
<span class="math display">\[ V(s)=R(s) + \gamma\sum_{s^{\prime}\in S}p\left(s^{\prime}\mid s\right)V\left(s^{\prime}\right)  \]</span> <code>s′</code>可以看成未来的某个状态,<code>p(s′|s)</code> 是指从当前状态转移到未来状态的概率。<code>V (s′)</code> 代表的是未来某一个状态的价值,<code>R(s)</code>为s的奖励组成的向量<br />
贝尔曼方程的证明：<br />

$$\begin{array}{l}{ {V(s)=\mathbb{E}\left[G_{t}\mid s_{t}=s\right]} }\\ { {=\mathbb{E}\left[r_{t+1}+\gamma r_{t+2}+\gamma^{2}r_{t+3}+...\mid s_{t}=s\right]} }\\ { {=\mathbb{E}\left[r_{t+1}\right|s_{t}=s]+\gamma\mathbb{E}\left[r_{t+2}+\gamma r_{t+3}+\gamma^{2}r_{t+4}+\dots\mid s_{t}=s\right]} }\\ { {=R(s)+\gamma\mathbb{E}[G_{t+1}\left|s_{t}=s\right]} }\end{array}$$
 下面证明: <span class="math inline">\(\mathbb{E}[V(s_{t+1})|s_{t}]=\mathbb{E}[\mathbb{E}[G_{t+1}|s_{t+1}]|s_{t}]=\mathbb{E}[G_{t+1}|s_{t}]\)</span></p>
<p>条件期望的定义为：<br />
<span class="math display">\[\operatorname{\mathbb{E} }[X\mid Y=y]=\sum_{x}x p(X=x\mid Y=y)\]</span></p>
<p>具体证明：<br />
<img src="/assets/ml/52243716-045d-4e27-ad0c-0e84593fee81.png" /></p>
<p>代入之前的等式,得：</p>
<p><span class="math display">\[\begin{array}{c}{ {V(s)=R(s)+\gamma\mathbb{E}[V(s_{t+1})|s_{t}=s]} }\\ { {=R(s)+\gamma{\sum\limits_{s^{\prime}\in S} } p\left(s^{\prime}\mid s\right)V\left(s^{\prime}\right)} }\end{array}\]</span></p>
<p>对单个s来说,贝尔曼方程就是一个向量乘积加上偏移值,所有的s可以写成一个矩阵乘法加上奖励向量的形式:</p>
<p><span class="math display">\[\begin{array}{c}{ {V=R+\gamma P V} }\\ { {E V=R+\gamma P V} }\\ { {(E-\gamma P)V=R} }\\ { {V=(I-\gamma P)^{-1}R} }\end{array}\]</span></p>
<p>这个解析解看着很美好,但涉及到逆矩阵求解,这是个复杂度 <span class="math inline">\(O(N^3)\)</span> 的问题(单论常用算法),因此对较大的模型并不实用</p>
<p>得到V的两种方法：</p>
<ul>
<li>最简单直接的蒙特卡洛方法,只需要对某个初始状态采样大量轨迹,然后取平均值,既可作为其价值</li>
<li>不断迭代贝尔曼方程,直到结果趋向收敛,这个收敛值即可以作为价值,即“自举”（Bootstrapping）(利用当前的估计或状态值来更新和改进自身的学习过程)</li>
</ul>
<h3 id="决策">决策</h3>
<p>单纯的马尔可夫过程没有策略的空间,也就是同时根据当前的状态和动作决定之后的状态分布,策略可以基于概率或者直接产生特定输出,如果策略已知,依然可以通过计算 <span class="math inline">\(\sum_{a\in A}\pi(a\mid s)p\left(s^{\prime}\mid s,a\right)\)</span> 获取状态转移的概率<br />
也就是说,通过采样行动,我们可以得到使用特定策略的特定状态的价值 由于引进了决策,定义一个Q函数,也被称为动作价值函数(action-value function)。Q 函数定义的是在某一个状态采取某一个动作,它有可能得到的回报的一个期望 <span class="math display">\[V_{\pi}(s)=\sum_{a\in A}\pi(a\mid s)Q_{\pi}(s,a)\]</span></p>
<p><span class="math display">\[\begin{array}{r l} {Q(s,a)} &amp;=\mathbb{E}\left[G_{t}\mid s_{t}=s,a_{t}=a\right] \\ &amp;=\mathbb{E}\left[r_{t+1}+\gamma r_{t+2}+\gamma^{2}r_{t+3}+\ldots\mid s_{t}=s,a_{t}=a\right]\\ &amp;{=R(s,a)+\gamma\mathbb{E}[G_{t+1}|s_{t}=s,a_{t}=a]}\\ &amp;{=R(s,a)+\gamma\mathbb{E}[V(s_{t+1})|s_{t}=s,a_{t}=a]}\\ &amp;{=R(s,a)+\gamma\displaystyle\sum_{s^{\prime}\in S}p(s^{\prime}\mid s,a)\,V\left(s^{\prime}\right)} \end{array}\]</span></p>
<p>可以把状态价值函数和 Q 函数拆解成两个部分:即时奖励和后续状态的折扣价值,这样分解后得到一个类似于之前马尔可夫奖励过程的贝尔曼方程——贝尔曼期望方程(<code>Bellman expectation equation</code>):</p>
<p><span class="math display">\[V_{\pi}(s)=\mathbb{E}_{\pi}\left[r_{t+1}+\gamma V_{\pi}\left(s_{t+1}\right)\mid s_{t}=s\right]\]</span> <span class="math display">\[Q_{\pi}(s,a)=\mathbb{E}_{\pi}\left[r_{t+1}+\gamma Q_{\pi}\left(s_{t+1},a_{t+1}\right)\right.\mid s_{t}=s,a_{t}=a]\]</span></p>
<h3 id="备份图">备份图</h3>
<p>以上我们得到了状态和动作的价值,对某一个s,它可能对应多种a,确定一个a后得到下一个state,这其实是一种树状的关系,因此可以用树形图表示V的演变,称为备份(回溯)图<br />
<img src="https://datawhalechina.github.io/easy-rl/img/ch2/2.10.png" /></p>
<p>如图,每一个空心圆圈代表一个状态,每一个实心圆圈代表一个状态-动作对<br />
从叶节点开始向上回溯,可以得到叶节点上一层的Q,然后继续递推,得到a上一层s的V,这样逐层计算就能得出整张图的状态与动作价值</p>
<p><a href="https://cs.stanford.edu/people/karpathy/reinforcejs/gridworld_dp.html">可视化学习过程</a></p>
<h3 id="迭代">迭代</h3>
<h4 id="策略迭代">策略迭代</h4>
<p>现在我们有V和Q这两个工具,那么假设初始状态,随便选定一套参数作为策略,接下来随着训练过程,不断更新轨迹中各个状态的价值,由此再得到Q函数,利用Q函数更新策略参数,如此循环,就可以让策略收敛到较优的性能<br />
优化过程,简单地说就是先找到所有状态的V,然后根据采样结果以及V的分布算出对于各个动作a的Q,那么对于一个特定的s,应该采取的策略需要让价值最高的动作有最高的概率,如果当做分类问题做,就可以以交叉熵为loss函数做梯度下降<br />
这样的优化后,理论上,各个状态的V以及策略产生的Q都会更高,而作为表现指标的初始状态的V也会更好<br />
收敛后,取让Q函数值最大化的动作,Q函数就会直接变成价值函数,这称为<code>贝尔曼最优方程（Bellman optimality equation）</code>: <span class="math inline">\(V_{\pi}(s)=\operatorname*{max}_{a\in A}Q_{\pi}(s,a)\)</span><br />
满足贝尔曼方程就说明,这个策略对一个状态,即使采取理论上的最佳行动,也不会有更好的效果</p>
<h4 id="价值迭代">价值迭代</h4>
<p><code>最优性原理定理（principle of optimality theorem）</code>: 策略在状态s达到最优价值,当且仅当对s可达的任何s',都已经达到了最优价值,如果我们找到了初始状态s的最优价值,那么自然就得到了最佳策略<br />
其过程为：</p>
<ol type="1">
<li>初始化: 对所有状态,设置其价值为0</li>
<li>循环直至收敛(k为迭代次数)：
<ol type="1">
<li>对所有s : <span class="math inline">\(Q_{k+1}(s,a)=R(s,a)+\gamma\sum_{s^{\prime}\in S}p\left(s^{\prime}\mid s,a\right)V_{k}\left(s^{\prime}\right)\)</span></li>
<li><span class="math inline">\(V_{k+1}(s)=\operatorname*{max}_{a}Q_{k+1}(s,a)\)</span></li>
</ol></li>
<li>最优策略 <span class="math inline">\(\pi(s)=\arg\operatorname*{max}_{a}\left[R(s,a)+\gamma\sum_{s^{\prime}\in S}p\left(s^{\prime}\mid s,a\right)V_{H+1}\left(s^{\prime}\right)\right]\)</span></li>
</ol>
<p>这可以单纯视为一个规划问题,有点类似于计网中路由器网络寻找最短跳数,由于每个状态的最优解都依赖于能到达它的其他状态是否最优,而我们不知道具体迭代几次所有状态都能到达最优,所以对每个状态,不断地计算其能采取的行动的价值,找到一个最优的Q作为其V,如果网络中存在没有达到最优的节点,那么在某轮迭代中它就会被优化,直到一轮中没有任何优化发生,才算抵达了最优解<br />
设想一个类似“终点”的最优状态s,s有全局最佳的V,只要到达s就可以宣告游戏结束,例如一个跑酷游戏的终点。那么对离s一步之遥的<code>s'</code>,迭代到它后,s'更新自己的价值为<code>迈出最后一步(action)的回报+s的价值</code>(为了容易说明,这里假设迈出这步到达s的概率是1),如果总共只有这两种状态,由于s不会更好了,s'达到s也没有更好的路径,继续迭代也不会更新,问题解决了<br />
再复杂化一点,假设有若干个状态,其中s是"终点",到达s的行为会得到一个及其巨大的回报,那么每次迭代,可以通过行动到达s的s'就能达到最优解,这样依次递推,直到离s最远的状态也找到了耗费最少的到达s的路径<br />
当然,实际上,很可能不存在这么一个方便的终点,各个状态间会是互相传递更优解的情况,但这种迭代的思路不会变化</p>
<h2 id="免模型方法">免模型方法</h2>
<h3 id="蒙特卡洛">蒙特卡洛</h3>
<p>实际情况中有很多不满足马尔科夫条件,过程中回报难以获得,或者action连续值无法取最佳之类的问题,也就是说很难做出系统的理论,因此需要不通过模型进行rl的方法。</p>
<ul>
<li><code>Q表格</code>: 以采样并记录的方法,使用平均奖励估算每个状态下每个动作的价值<br />
</li>
<li><code>蒙特卡洛方法</code>: 简单地说,就是大量采样估算状态价值,简单地列式可得到 <span class="math inline">\(\mu_t=\mu_{t-1}+{\frac{1}{t}}\left(x_{t}-\mu_{t-1}\right)\)</span> 其中 <span class="math inline">\(\mu\)</span> 是到t时刻为止的平均值 <span class="math inline">\(x_{t}-\mu_{t-1}\)</span> 称为残差
<ul>
<li><code>增量式蒙特卡洛 （incremental MC）</code> : 用增量的方法更新数据 , <span class="math inline">\(\begin{array}{l}{ {N\left(s_{t}\right)\leftarrow N\left(s_{t}\right)+1}}\\ { {V\left(s_{t}\right)\leftarrow V\left(s_{t}\right)+\frac{1}{N(s_{t})}\left(G_{t}-V\left(s_{t}\right)\right)} }\end{array}\)</span> 其中N为状态s的访问次数</li>
</ul></li>
</ul>
<h3 id="时序差分">时序差分</h3>
<p>时序差分是免模型的在线算法</p>
<p><span class="math display">\[ V\left(s_{t}\right)\leftarrow V\left(s_{t}\right)+\alpha\left(r_{t+1}+\gamma V\left(s_{t+1}\right)-V\left(s_{t}\right)\right) \]</span></p>
<p>其中 <span class="math inline">\(r_{t+1}+\gamma V(s_{t+1})\)</span> 是称为时序差分目标(TD target)</p>
<p>时序差分误差（TD error）写作:</p>
<p><span class="math display">\[V\left(s_{t}\right)\leftarrow V\left(s_{t}\right)+\alpha\left(G_{i,t}-V\left(s_{t}\right)\right)\]</span></p>
<p>时序差分可以更改步数(走几步更新)</p>
<h2 id="理论问题">理论问题</h2>
<h1 id="模型">模型</h1>
<p>可以简单地讲选择action理解为分类问题,损失函数使用交叉熵,对不同的s,我们可能对执行的action有不同的期待,因此可以设置一个损失函数的系数用于控制倾向性<br />
那么如何定义reward呢?最直接的即时reward肯定不是最优解,因此设置一个Gn表示an行为之后的所有回报和,但对之后的回报要乘上一个惩罚系数γ,其次数逐渐增加;此外,可以使用将G减去一个baseline的值来产生不同行为的倾向性<br />
rl,准确地说是on-policy的rl与常见监督学习不同的是,其训练资料在更新完一次模型后就无用了,需要再次与环境互动收集资料<br />
off-policy则有所不同,它让训练模型和互动的模型分开,从而让经验可复用,例如<code>Proximal Policy Optimization(PPO)</code></p>
<p>Critic actor: 我们希望有一个跟模型参数以及当前状态有关的函数 $ V^(s) $ 表示这种情况下的'价值',可以理解为某个状态的预期回报<br />
为了得到这个价值函数,可以怎么做呢:</p>
<ul>
<li>Monte-Carlo(MC): 较为直观的做法,先训练大量的s及其G值,然后用这些资料预测V</li>
<li>Temporal-difference (TD): V函数有以下性质:</li>
</ul>
<p><span class="math display">\[\begin{array}{l}{ {V^{\theta}(s_{t})=r_{t}+\gamma r_{t+1}+\gamma^{2}r_{t+2}\ldots} }\\ { {V^{\theta}(s_{t+1})=r_{t+1}+\gamma r_{t+2}+\ldots} }\\ { {V^{\theta}(s_{t})=\gamma V^{\theta}(s_{t+1})+r_{t} } }\end{array}\]</span><br />
那么 <span class="math display">\[V^{\theta}(s_{t})-\gamma V^{\theta}(s_{t+1})\leftrightarrow r_{t}\]</span><br />
通过这种关系就可以训练</p>
<p>现在我们有了G和V,两者区别是G有一个确定的a,V则假定a是随机的,那么可以对每个 <span class="math inline">\(\{s_{t},a_{t}\}\)</span> 对,可以定义一个 <span class="math inline">\(\mathrm{A}_{t}\,=\,G_{t}^{\prime}-V^{\theta}(s_{t})\)</span> ,用于表示这个行为的"表现"<br />
也可以用 $r_{t}+V^{}(s_{t+1}) $ 代替上式的 $ G^{'}_t $ ,此式相当于采取行为 <span class="math inline">\(a_t\)</span> 后获得一个特定 <span class="math inline">\(r_t\)</span> 后的预期收益, 这称为<code>Advantage Actor-Critic</code></p>
<p><code>Reward Shaping</code>: 对回馈比较模糊或者非常慢的场景来说,想要好的表现就需要人为规定一些回报机制,例如对游戏ai来说,就需要惩罚什么都不做的行为(否则机器为了回报不为负就可能消极游戏);其中一种机制称为<code>Curiosity</code>, 也就是奖励机器发现新信息的情况</p>
<p>现实中不是所有情况都可以定义reward,此时只能通过人类提供示范来让机器学习,这样当然会有很多问题,比如数据集里没有错误示范等,因此,可能的思路是通过机器学习来找到reward再进行学习<br />
<code>Inverse Reinforcement Learning</code>: 假设老师行为是最优的,在每次迭代中:</p>
<ol type="1">
<li>actor与环境互动</li>
<li>定义一个奖励函数,满足老师的奖励更优这个条件</li>
<li>actor根据这个奖励函数进行学习</li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>人工智能</tag>
        <tag>国立台湾大学</tag>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机专业英语术语表</title>
    <url>/thinklive/44308/</url>
    <content><![CDATA[<h1 id="机器学习">机器学习</h1>
<span id="more"></span>
<ul>
<li>stochastic 随机的</li>
<li>hallucinations 幻觉</li>
<li>paradigm 范式</li>
<li>Modular 模块化</li>
<li>augmentation 增强</li>
<li>scalability 可拓展性</li>
<li>proprietary 专有</li>
<li>fine-tuning 微调</li>
<li>parameterize 参数化</li>
<li>corpora 语料库</li>
<li>downstream</li>
<li>domain-specific</li>
<li>sample space 样本空间</li>
<li>outcome space 结果空间</li>
<li>mutually exclusive 互斥</li>
<li>stochastic gradient descent 随机梯度下降法</li>
<li>granularity 粒度</li>
<li>Cross-site scripting 跨站脚本</li>
<li>off-the-shelf 现成的</li>
<li>task-agnostic 与任务无关的</li>
<li>actuators： 执行部门</li>
<li>taxonomy: 分类学</li>
<li>finer-grained：更细粒度</li>
<li>segmentations：分割</li>
<li>heuristics-based: 启发式</li>
<li>prominent：显著的</li>
<li>denoise: 去噪</li>
<li>coordinates： 坐标</li>
<li>orthographic: 正交</li>
<li>decouple: 解耦</li>
<li>heterogeneous: 异构</li>
<li>singularities: 奇异性</li>
<li>interleave: 交错</li>
<li>discretize: 离散化</li>
</ul>
<h1 id="算法与数据结构常用术语">算法与数据结构常用术语</h1>
<table>
<thead>
<tr class="header">
<th>algorithm</th>
<th>算法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>data structure</td>
<td>数据结构</td>
</tr>
<tr class="even">
<td>code</td>
<td>代码</td>
</tr>
<tr class="odd">
<td>file</td>
<td>文件</td>
</tr>
<tr class="even">
<td>function</td>
<td>函数</td>
</tr>
<tr class="odd">
<td>method</td>
<td>方法</td>
</tr>
<tr class="even">
<td>variable</td>
<td>变量</td>
</tr>
<tr class="odd">
<td>asymptotic complexity analysis</td>
<td>渐近复杂度分析</td>
</tr>
<tr class="even">
<td>time complexity</td>
<td>时间复杂度</td>
</tr>
<tr class="odd">
<td>space complexity</td>
<td>空间复杂度</td>
</tr>
<tr class="even">
<td>loop</td>
<td>循环</td>
</tr>
<tr class="odd">
<td>iteration</td>
<td>迭代</td>
</tr>
<tr class="even">
<td>recursion</td>
<td>递归</td>
</tr>
<tr class="odd">
<td>tail recursion</td>
<td>尾递归</td>
</tr>
<tr class="even">
<td>recursion tree</td>
<td>递归树</td>
</tr>
<tr class="odd">
<td>asymptotic upper bound</td>
<td>渐近上界</td>
</tr>
<tr class="even">
<td>sign-magnitude</td>
<td>原码</td>
</tr>
<tr class="odd">
<td>1’s complement</td>
<td>反码</td>
</tr>
<tr class="even">
<td>2’s complement</td>
<td>补码</td>
</tr>
<tr class="odd">
<td>array</td>
<td>数组</td>
</tr>
<tr class="even">
<td>index</td>
<td>索引</td>
</tr>
<tr class="odd">
<td>linked list</td>
<td>链表</td>
</tr>
<tr class="even">
<td>linked list node, list node</td>
<td>链表节点</td>
</tr>
<tr class="odd">
<td>head node</td>
<td>头节点</td>
</tr>
<tr class="even">
<td>tail node</td>
<td>尾节点</td>
</tr>
<tr class="odd">
<td>list</td>
<td>列表</td>
</tr>
<tr class="even">
<td>dynamic array</td>
<td>动态数组</td>
</tr>
<tr class="odd">
<td>hard disk</td>
<td>硬盘</td>
</tr>
<tr class="even">
<td>random-access memory (RAM)</td>
<td>内存</td>
</tr>
<tr class="odd">
<td>cache memory</td>
<td>缓存</td>
</tr>
<tr class="even">
<td>cache miss</td>
<td>缓存未命中</td>
</tr>
<tr class="odd">
<td>cache hit rate</td>
<td>缓存命中率</td>
</tr>
<tr class="even">
<td>stack</td>
<td>栈</td>
</tr>
<tr class="odd">
<td>top of the stack</td>
<td>栈顶</td>
</tr>
<tr class="even">
<td>bottom of the stack</td>
<td>栈底</td>
</tr>
<tr class="odd">
<td>queue</td>
<td>队列</td>
</tr>
<tr class="even">
<td>double-ended queue</td>
<td>双向队列</td>
</tr>
<tr class="odd">
<td>front of the queue</td>
<td>队首</td>
</tr>
<tr class="even">
<td>rear of the queue</td>
<td>队尾</td>
</tr>
<tr class="odd">
<td>hash table</td>
<td>哈希表</td>
</tr>
<tr class="even">
<td>hash set</td>
<td>哈希集合</td>
</tr>
<tr class="odd">
<td>bucket</td>
<td>桶</td>
</tr>
<tr class="even">
<td>hash function</td>
<td>哈希函数</td>
</tr>
<tr class="odd">
<td>hash collision</td>
<td>哈希冲突</td>
</tr>
<tr class="even">
<td>load factor</td>
<td>负载因子</td>
</tr>
<tr class="odd">
<td>separate chaining</td>
<td>链式地址</td>
</tr>
<tr class="even">
<td>open addressing</td>
<td>开放寻址</td>
</tr>
<tr class="odd">
<td>linear probing</td>
<td>线性探测</td>
</tr>
<tr class="even">
<td>lazy deletion</td>
<td>懒删除</td>
</tr>
<tr class="odd">
<td>binary tree</td>
<td>二叉树</td>
</tr>
<tr class="even">
<td>tree node</td>
<td>树节点</td>
</tr>
<tr class="odd">
<td>left-child node</td>
<td>左子节点</td>
</tr>
<tr class="even">
<td>right-child node</td>
<td>右子节点</td>
</tr>
<tr class="odd">
<td>parent node</td>
<td>父节点</td>
</tr>
<tr class="even">
<td>left subtree</td>
<td>左子树</td>
</tr>
<tr class="odd">
<td>right subtree</td>
<td>右子树</td>
</tr>
<tr class="even">
<td>root node</td>
<td>根节点</td>
</tr>
<tr class="odd">
<td>leaf node</td>
<td>叶节点</td>
</tr>
<tr class="even">
<td>edge</td>
<td>边</td>
</tr>
<tr class="odd">
<td>level</td>
<td>层</td>
</tr>
<tr class="even">
<td>degree</td>
<td>度</td>
</tr>
<tr class="odd">
<td>height</td>
<td>高度</td>
</tr>
<tr class="even">
<td>depth</td>
<td>深度</td>
</tr>
<tr class="odd">
<td>perfect binary tree</td>
<td>完美二叉树</td>
</tr>
<tr class="even">
<td>complete binary tree</td>
<td>完全二叉树</td>
</tr>
<tr class="odd">
<td>full binary tree</td>
<td>满二叉树</td>
</tr>
<tr class="even">
<td>balanced binary tree</td>
<td>平衡二叉树</td>
</tr>
<tr class="odd">
<td>binary search tree</td>
<td>二叉搜索树</td>
</tr>
<tr class="even">
<td>AVL tree</td>
<td>AVL 树</td>
</tr>
<tr class="odd">
<td>red-black tree</td>
<td>红黑树</td>
</tr>
<tr class="even">
<td>level-order traversal</td>
<td>层序遍历</td>
</tr>
<tr class="odd">
<td>breadth-first traversal</td>
<td>广度优先遍历</td>
</tr>
<tr class="even">
<td>depth-first traversal</td>
<td>深度优先遍历</td>
</tr>
<tr class="odd">
<td>binary search tree</td>
<td>二叉搜索树</td>
</tr>
<tr class="even">
<td>balanced binary search tree</td>
<td>平衡二叉搜索树</td>
</tr>
<tr class="odd">
<td>balance factor</td>
<td>平衡因子</td>
</tr>
<tr class="even">
<td>heap</td>
<td>堆</td>
</tr>
<tr class="odd">
<td>max heap</td>
<td>大顶堆</td>
</tr>
<tr class="even">
<td>min heap</td>
<td>小顶堆</td>
</tr>
<tr class="odd">
<td>priority queue</td>
<td>优先队列</td>
</tr>
<tr class="even">
<td>heapify</td>
<td>堆化</td>
</tr>
<tr class="odd">
<td>graph</td>
<td>图</td>
</tr>
<tr class="even">
<td>vertex</td>
<td>顶点</td>
</tr>
<tr class="odd">
<td>undirected graph</td>
<td>无向图</td>
</tr>
<tr class="even">
<td>directed graph</td>
<td>有向图</td>
</tr>
<tr class="odd">
<td>connected graph</td>
<td>连通图</td>
</tr>
<tr class="even">
<td>disconnected graph</td>
<td>非连通图</td>
</tr>
<tr class="odd">
<td>weighted graph</td>
<td>有权图</td>
</tr>
<tr class="even">
<td>adjacency</td>
<td>邻接</td>
</tr>
<tr class="odd">
<td>path</td>
<td>路径</td>
</tr>
<tr class="even">
<td>in-degree</td>
<td>入度</td>
</tr>
<tr class="odd">
<td>out-degree</td>
<td>出度</td>
</tr>
<tr class="even">
<td>adjacency matrix</td>
<td>邻接矩阵</td>
</tr>
<tr class="odd">
<td>adjacency list</td>
<td>邻接表</td>
</tr>
<tr class="even">
<td>breadth-first search</td>
<td>广度优先搜索</td>
</tr>
<tr class="odd">
<td>depth-first search</td>
<td>深度优先搜索</td>
</tr>
<tr class="even">
<td>binary search</td>
<td>二分查找</td>
</tr>
<tr class="odd">
<td>searching algorithm</td>
<td>搜索算法</td>
</tr>
<tr class="even">
<td>sorting algorithm</td>
<td>排序算法</td>
</tr>
<tr class="odd">
<td>selection sort</td>
<td>选择排序</td>
</tr>
<tr class="even">
<td>bubble sort</td>
<td>冒泡排序</td>
</tr>
<tr class="odd">
<td>insertion sort</td>
<td>插入排序</td>
</tr>
<tr class="even">
<td>quick sort</td>
<td>快速排序</td>
</tr>
<tr class="odd">
<td>merge sort</td>
<td>归并排序</td>
</tr>
<tr class="even">
<td>heap sort</td>
<td>堆排序</td>
</tr>
<tr class="odd">
<td>bucket sort</td>
<td>桶排序</td>
</tr>
<tr class="even">
<td>counting sort</td>
<td>计数排序</td>
</tr>
<tr class="odd">
<td>radix sort</td>
<td>基数排序</td>
</tr>
<tr class="even">
<td>divide and conquer</td>
<td>分治</td>
</tr>
<tr class="odd">
<td>hanota problem</td>
<td>汉诺塔问题</td>
</tr>
<tr class="even">
<td>backtracking algorithm</td>
<td>回溯算法</td>
</tr>
<tr class="odd">
<td>constraint</td>
<td>约束</td>
</tr>
<tr class="even">
<td>solution</td>
<td>解</td>
</tr>
<tr class="odd">
<td>state</td>
<td>状态</td>
</tr>
<tr class="even">
<td>pruning</td>
<td>剪枝</td>
</tr>
<tr class="odd">
<td>permutations problem</td>
<td>全排列问题</td>
</tr>
<tr class="even">
<td>subset-sum problem</td>
<td>子集和问题</td>
</tr>
<tr class="odd">
<td>dynamic programming</td>
<td>动态规划</td>
</tr>
<tr class="even">
<td>initial state</td>
<td>初始状态</td>
</tr>
<tr class="odd">
<td>state-transition equation</td>
<td>状态转移方程</td>
</tr>
<tr class="even">
<td>knapsack problem</td>
<td>背包问题</td>
</tr>
<tr class="odd">
<td>edit distance problem</td>
<td>编辑距离问题</td>
</tr>
<tr class="even">
<td>greedy algorithm</td>
<td>贪心算法</td>
</tr>
</tbody>
</table>
<h1 id="计算机专业术语对照">计算机专业术语对照</h1>
<p><a href="#a">A</a> | <a href="#b">B</a> | <a href="#c">C</a> | <a href="#d">D</a> | <a href="#e">E</a> | <a href="#f">F</a> | <a href="#g">G</a> | <a href="#h">H</a> | <a href="#i">I</a> | <a href="#j">J</a> | <a href="#k">K</a> | <a href="#l">L</a> | <a href="#m">M</a> | <a href="#n">N</a> | <a href="#o">O</a> | <a href="#p">P</a> | <a href="#q">Q</a> | <a href="#r">R</a> | <a href="#s">S</a> | <a href="#t">T</a> | <a href="#u">U</a> | <a href="#v">V</a> | <a href="#w">W</a> | <a href="#x">X</a> | <a href="#y">Y</a> | <a href="#z">Z</a></p>
<h2 id="a">A</h2>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Abstract Factory</td>
<td>抽象工厂</td>
</tr>
<tr class="even">
<td>Abstract Factory Pattern</td>
<td>抽象工厂模式</td>
</tr>
<tr class="odd">
<td>abstraction layer</td>
<td>抽象层</td>
</tr>
<tr class="even">
<td>access</td>
<td>获取，存取</td>
</tr>
<tr class="odd">
<td>access modifier</td>
<td>访问修饰符</td>
</tr>
<tr class="even">
<td>acoustic coupler</td>
<td>声音耦合器</td>
</tr>
<tr class="odd">
<td>Active Directory</td>
<td>活动目录</td>
</tr>
<tr class="even">
<td>Acyclic Dependencies Principle</td>
<td>非循环依赖原则（ADP）</td>
</tr>
<tr class="odd">
<td>acyclic digraph</td>
<td>有向无环图</td>
</tr>
<tr class="even">
<td>Adapter</td>
<td>适配器</td>
</tr>
<tr class="odd">
<td>Adapter Pattern</td>
<td>适配器模式</td>
</tr>
<tr class="even">
<td>Adaptive Code</td>
<td>自适应代码</td>
</tr>
<tr class="odd">
<td>Add Parameter</td>
<td>添加参数</td>
</tr>
<tr class="even">
<td>ADSL</td>
<td>Asymmetrical Dingital Subscriber Loop，非对称数字用户环线</td>
</tr>
<tr class="odd">
<td>affinity</td>
<td>绑定</td>
</tr>
<tr class="even">
<td>affinity group</td>
<td>地缘组</td>
</tr>
<tr class="odd">
<td>agent</td>
<td>代理</td>
</tr>
<tr class="even">
<td>agent-based interface</td>
<td>代理人界面</td>
</tr>
<tr class="odd">
<td>Aggregate</td>
<td>聚合</td>
</tr>
<tr class="even">
<td>Aggregate Root</td>
<td>聚合根</td>
</tr>
<tr class="odd">
<td>Agile</td>
<td>敏捷方法论</td>
</tr>
<tr class="even">
<td>agile practice</td>
<td>敏捷实践</td>
</tr>
<tr class="odd">
<td>agile process</td>
<td>敏捷流程</td>
</tr>
<tr class="even">
<td>agility</td>
<td>敏捷性</td>
</tr>
<tr class="odd">
<td>AI</td>
<td>Artificial Intelligence，人工智能</td>
</tr>
<tr class="even">
<td>air waves</td>
<td>无线电波</td>
</tr>
<tr class="odd">
<td>algorithm</td>
<td>算法</td>
</tr>
<tr class="even">
<td>Algorithm-of-Thought</td>
<td>思维算法（AoT） <sup>6</sup></td>
</tr>
<tr class="odd">
<td>analog</td>
<td>模拟的</td>
</tr>
<tr class="even">
<td>animation</td>
<td>动画</td>
</tr>
<tr class="odd">
<td>annotation</td>
<td>注解，注释</td>
</tr>
<tr class="even">
<td>answering machine</td>
<td>电话应答机</td>
</tr>
<tr class="odd">
<td>antenna</td>
<td>天线</td>
</tr>
<tr class="even">
<td>anti-pattern</td>
<td>反模式</td>
</tr>
<tr class="odd">
<td>AoT</td>
<td>思维算法（Algorithm-of-Thought） <sup>6</sup></td>
</tr>
<tr class="even">
<td>APM</td>
<td>异步编程模型（Asynchronous Programming Model）</td>
</tr>
<tr class="odd">
<td>Apocalyptic defect</td>
<td>灾难缺陷</td>
</tr>
<tr class="even">
<td>application</td>
<td>应用，应用程序，应用软件</td>
</tr>
<tr class="odd">
<td>application life cycle</td>
<td>应用程序生命周期</td>
</tr>
<tr class="even">
<td>application pool</td>
<td>应用程序池</td>
</tr>
<tr class="odd">
<td>Application Programming Interface</td>
<td>应用程序编程接口（API），目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</td>
</tr>
<tr class="even">
<td>Application Service</td>
<td>应用服务</td>
</tr>
<tr class="odd">
<td>arbitrary error</td>
<td>任意错误</td>
</tr>
<tr class="even">
<td>architecture</td>
<td>体系机构，结构</td>
</tr>
<tr class="odd">
<td>architecture decay</td>
<td>架构腐坏</td>
</tr>
<tr class="even">
<td>Architecture Style</td>
<td>架构风格</td>
</tr>
<tr class="odd">
<td>ARPA</td>
<td>Advanced Research Projects Agency，（美国国防部）高级研究计划署</td>
</tr>
<tr class="even">
<td>ARPAnet</td>
<td>ARPA 网</td>
</tr>
<tr class="odd">
<td>Arrange-Act-Assert</td>
<td>准备-执行-断言（AAA）</td>
</tr>
<tr class="even">
<td>artifact</td>
<td>构建物<sup>4</sup></td>
</tr>
<tr class="odd">
<td>ASF</td>
<td>Apache Software Foundation 的简写</td>
</tr>
<tr class="even">
<td>Aspect-Oriented Programming</td>
<td>面向切面编程（AOP）</td>
</tr>
<tr class="odd">
<td>aspect ratio</td>
<td>屏幕高宽比</td>
</tr>
<tr class="even">
<td>assembly</td>
<td>程序集</td>
</tr>
<tr class="odd">
<td>associative array</td>
<td>关联数组</td>
</tr>
<tr class="even">
<td>Asynchronous Programming Model</td>
<td>异步编程模型（APM）</td>
</tr>
<tr class="odd">
<td>ATM</td>
<td>asynchronous transfer mode，异步传输模式</td>
</tr>
<tr class="even">
<td>atomic operation</td>
<td>原子操作</td>
</tr>
<tr class="odd">
<td>atomic transaction</td>
<td>原子事务</td>
</tr>
<tr class="even">
<td>atomicity</td>
<td>原子性</td>
</tr>
<tr class="odd">
<td>attribute</td>
<td>特性（C#）、属性（Java 等）</td>
</tr>
<tr class="even">
<td>augmented reality</td>
<td>增强实现（AR）</td>
</tr>
<tr class="odd">
<td>authentication</td>
<td>身份验证</td>
</tr>
<tr class="even">
<td>authorization</td>
<td>授权</td>
</tr>
<tr class="odd">
<td>auto-generated properties</td>
<td>自动生成的属性</td>
</tr>
<tr class="even">
<td>automated unit testing</td>
<td>自动化单元测试</td>
</tr>
<tr class="odd">
<td>automation</td>
<td>自动化</td>
</tr>
<tr class="even">
<td>autonomous</td>
<td>独立性</td>
</tr>
<tr class="odd">
<td>auxiliary database</td>
<td>辅助数据库</td>
</tr>
<tr class="even">
<td>availability</td>
<td>可用性</td>
</tr>
<tr class="odd">
<td>availability set</td>
<td>可用性集</td>
</tr>
<tr class="even">
<td>AZs</td>
<td>可用性区域（Availability Zones，亚马逊 AWS 中数据中心的叫法）<sup>4</sup></td>
</tr>
</tbody>
</table>
<h2 id="b">B</h2>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BaaS</td>
<td>Battery as a Service，电池即服务（电池租用商业模式）</td>
</tr>
<tr class="even">
<td>Backend as a Service</td>
<td>后端即服务（BaaS）</td>
</tr>
<tr class="odd">
<td>backpane</td>
<td>底板</td>
</tr>
<tr class="even">
<td>backward compatibility</td>
<td>向后兼容性</td>
</tr>
<tr class="odd">
<td>bandwidth</td>
<td>带宽</td>
</tr>
<tr class="even">
<td>bar code</td>
<td>条形码</td>
</tr>
<tr class="odd">
<td>Base Class Library</td>
<td>基类库（BCL）</td>
</tr>
<tr class="even">
<td>baseline</td>
<td>准线</td>
</tr>
<tr class="odd">
<td>baud</td>
<td>波特</td>
</tr>
<tr class="even">
<td>BCL</td>
<td>基类库（Base Class Library）</td>
</tr>
<tr class="odd">
<td>behavior</td>
<td>行为</td>
</tr>
<tr class="even">
<td>behavior preserving program transformations</td>
<td>行为保留式程序转换<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Behavioral Design Patterns</td>
<td>行为性设计模式</td>
</tr>
<tr class="even">
<td>Behavioral error</td>
<td>行为错误</td>
</tr>
<tr class="odd">
<td>BERT</td>
<td>Bidirectional Encoder Representations from Transformers，谷歌公司的 LLM，对 NLP 研究产生了重大影响。该模型使用双向方法从一个词的左右两边捕捉上下文，使得各种任务的性能提高，如情感分析和命名实体识别。</td>
</tr>
<tr class="even">
<td>BFF</td>
<td>为前端服务的后端（Backends For Frontends）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>BFS</td>
<td>广度优先搜索</td>
</tr>
<tr class="even">
<td>Big Ball of Mud</td>
<td>大泥球（BBM）</td>
</tr>
<tr class="odd">
<td>big data</td>
<td>大数据</td>
</tr>
<tr class="even">
<td>Big Design Up Front</td>
<td>大优先设计（BDUF）</td>
</tr>
<tr class="odd">
<td>binary</td>
<td>二进制的</td>
</tr>
<tr class="even">
<td>binochlar</td>
<td>双目并用的</td>
</tr>
<tr class="odd">
<td>bit</td>
<td>比特</td>
</tr>
<tr class="even">
<td>Bit-field</td>
<td>位域</td>
</tr>
<tr class="odd">
<td>bitnik</td>
<td>比特族</td>
</tr>
<tr class="even">
<td>blob</td>
<td>BLOB</td>
</tr>
<tr class="odd">
<td>block</td>
<td>阻断</td>
</tr>
<tr class="even">
<td>block blob</td>
<td>块 BLOB</td>
</tr>
<tr class="odd">
<td>Blockchain as a Service</td>
<td>区块链即服务（BaaS）</td>
</tr>
<tr class="even">
<td>bottleneck</td>
<td>瓶颈</td>
</tr>
<tr class="odd">
<td>bounded context</td>
<td>边界上下文、界限上下文<sup>4</sup></td>
</tr>
<tr class="even">
<td>box</td>
<td>装箱</td>
</tr>
<tr class="odd">
<td>bps</td>
<td>bits per second，比特/秒</td>
</tr>
<tr class="even">
<td>Brainstorming</td>
<td>头脑风暴（脑暴）</td>
</tr>
<tr class="odd">
<td>BRD</td>
<td>商业需求文档（Business Requirements Document）</td>
</tr>
<tr class="even">
<td>breakpoint</td>
<td>断点</td>
</tr>
<tr class="odd">
<td>Bridge</td>
<td>桥接</td>
</tr>
<tr class="even">
<td>Bridge Pattern</td>
<td>桥接模式</td>
</tr>
<tr class="odd">
<td>broadcast</td>
<td>（无线电或电视）广播</td>
</tr>
<tr class="even">
<td>Broken Hierarchy</td>
<td>支离破碎的层次结构<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Broken Modularization</td>
<td>拆散的模块化<sup>2</sup></td>
</tr>
<tr class="even">
<td>brownfield project</td>
<td>行进中项目</td>
</tr>
<tr class="odd">
<td>Browser Object Model</td>
<td>浏览器对象模型（BOM）</td>
</tr>
<tr class="even">
<td>browser-server</td>
<td>浏览器-服务器</td>
</tr>
<tr class="odd">
<td>bug</td>
<td>缺陷</td>
</tr>
<tr class="even">
<td>Builder Pattern</td>
<td>建造者模式</td>
</tr>
<tr class="odd">
<td>built-in</td>
<td>内置的，内建的；嵌入的；内置</td>
</tr>
<tr class="even">
<td>bulkhead</td>
<td>舱壁<sup>4</sup></td>
</tr>
<tr class="odd">
<td>business intelligence</td>
<td>商业智能，将企业中现有的数据进行有效的整合，快速准确地提供报表并提出决策依据，帮助企业做出明智的业务经营决策。</td>
</tr>
<tr class="even">
<td>business layer</td>
<td>业务层</td>
</tr>
<tr class="odd">
<td>business logic layer</td>
<td>业务逻辑层</td>
</tr>
<tr class="even">
<td>Business Requirements Document</td>
<td>商业需求文档（BRD）</td>
</tr>
<tr class="odd">
<td>busy (status)</td>
<td>忙（状态）；繁忙（状态）</td>
</tr>
<tr class="even">
<td>byte</td>
<td>字节</td>
</tr>
</tbody>
</table>
<h2 id="c">C</h2>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cable</td>
<td>电缆</td>
</tr>
<tr class="even">
<td>Cache/Caching</td>
<td>缓存</td>
</tr>
<tr class="odd">
<td>call stack</td>
<td>调用堆栈</td>
</tr>
<tr class="even">
<td>callout box</td>
<td>标注框</td>
</tr>
<tr class="odd">
<td>camelCase</td>
<td>camel 大小写</td>
</tr>
<tr class="even">
<td>canary releasing</td>
<td>金丝雀发布<sup>4</sup></td>
</tr>
<tr class="odd">
<td>carbon copy</td>
<td>复写本，副本；抄送（CC）</td>
</tr>
<tr class="even">
<td>carriage return</td>
<td>回车</td>
</tr>
<tr class="odd">
<td>Cascading Style Sheets</td>
<td>层叠样式表（CSS）</td>
</tr>
<tr class="even">
<td>catastrophic failover</td>
<td>灾难性故障转移<sup>4</sup></td>
</tr>
<tr class="odd">
<td>CD</td>
<td>持续交付（Continuous Delivery）<sup>4</sup></td>
</tr>
<tr class="even">
<td>CDC</td>
<td>消费者驱动的契约（Customer-Driven Contract）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>CDN</td>
<td>内容分发网络（Content Delivery Network）</td>
</tr>
<tr class="even">
<td>cell</td>
<td>单元</td>
</tr>
<tr class="odd">
<td>cellular telephone</td>
<td>移动电话</td>
</tr>
<tr class="even">
<td>Central Processing Unit</td>
<td>中央处理器（CPU）</td>
</tr>
<tr class="odd">
<td>certificate</td>
<td>（数字）证书</td>
</tr>
<tr class="even">
<td>Certificate Authority</td>
<td>证书认证机构</td>
</tr>
<tr class="odd">
<td>Chain of Responsibility</td>
<td>责任链</td>
</tr>
<tr class="even">
<td>Chain of Responsibility Pattern</td>
<td>责任链模式</td>
</tr>
<tr class="odd">
<td>Chain-of-Thought</td>
<td>思维链（CoT） <sup>6</sup></td>
</tr>
<tr class="even">
<td>Chain-of-Thought-Self-Consistency</td>
<td>思维链自洽性 <sup>6</sup></td>
</tr>
<tr class="odd">
<td>Change Bidirectional Association to Unidirectional</td>
<td>将双向关联改为单向关联<sup>1</sup></td>
</tr>
<tr class="even">
<td>Change Point</td>
<td>修改点：需要往代码中引入修改的点</td>
</tr>
<tr class="odd">
<td>Change Reference to Value</td>
<td>将引用对象改为值对象<sup>1</sup></td>
</tr>
<tr class="even">
<td>Change Unidirectional Association to Bidirectional</td>
<td>将单向关联改为双向关联<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Change Value to Reference</td>
<td>将值对象改为引用对象<sup>1</sup></td>
</tr>
<tr class="even">
<td>channel</td>
<td>信道，频道</td>
</tr>
<tr class="odd">
<td>character</td>
<td>字符</td>
</tr>
<tr class="even">
<td>Characterization test</td>
<td>特征测试：描述软件某部分的当前行为的测试，当你修改代码时能够用来保持行为</td>
</tr>
<tr class="odd">
<td>check in</td>
<td>签入</td>
</tr>
<tr class="even">
<td>check out</td>
<td>签出</td>
</tr>
<tr class="odd">
<td>checksum</td>
<td>校验和</td>
</tr>
<tr class="even">
<td>chip</td>
<td>芯片</td>
</tr>
<tr class="odd">
<td>choreography</td>
<td>协同</td>
</tr>
<tr class="even">
<td>CI</td>
<td>持续集成（Continuous Integration）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>cipher</td>
<td>密码</td>
</tr>
<tr class="even">
<td>claim</td>
<td>声明</td>
</tr>
<tr class="odd">
<td>class definition</td>
<td>类定义</td>
</tr>
<tr class="even">
<td>Clean Object-oriented and Layered Architecture</td>
<td>整洁面向对象分层架构（COLA）</td>
</tr>
<tr class="odd">
<td>CLI</td>
<td>公共语言基础结构（Common Language Infrastructure）</td>
</tr>
<tr class="even">
<td>client-server</td>
<td>客户端-服务器</td>
</tr>
<tr class="odd">
<td>clone</td>
<td>克隆，复制</td>
</tr>
<tr class="even">
<td>cloud computing</td>
<td>云计算</td>
</tr>
<tr class="odd">
<td>cloud service</td>
<td>云服务</td>
</tr>
<tr class="even">
<td>CLR</td>
<td>公共语言运行时（Common Language Runtime）</td>
</tr>
<tr class="odd">
<td>CLS</td>
<td>公共语言规范（Common Language Specification）</td>
</tr>
<tr class="even">
<td>cluster</td>
<td>集群</td>
</tr>
<tr class="odd">
<td>clustered index</td>
<td>聚集索引</td>
</tr>
<tr class="even">
<td>co-occurring smells</td>
<td>同时出现的坏味<sup>2</sup></td>
</tr>
<tr class="odd">
<td>CoAP</td>
<td>受限应用协议</td>
</tr>
<tr class="even">
<td>coaxial cable</td>
<td>同轴电缆</td>
</tr>
<tr class="odd">
<td>COBIT</td>
<td>信息和相关技术的控制目标，Control Objectives for Information and Related Technology<sup>4</sup></td>
</tr>
<tr class="even">
<td>CoC</td>
<td>更改开销（Cost of Change）</td>
</tr>
<tr class="odd">
<td>code smell</td>
<td>代码味道</td>
</tr>
<tr class="even">
<td>COLA</td>
<td>整洁面向对象分层架构，Clean Object-oriented and Layered Architecture</td>
</tr>
<tr class="odd">
<td>Collapse Hierarchy</td>
<td>折叠继承关系<sup>1</sup></td>
</tr>
<tr class="even">
<td>comcurrency</td>
<td>并发</td>
</tr>
<tr class="odd">
<td>command</td>
<td>命令</td>
</tr>
<tr class="even">
<td>Command Pattern</td>
<td>命令模式</td>
</tr>
<tr class="odd">
<td>command prompt</td>
<td>命令行提示</td>
</tr>
<tr class="even">
<td>Command/Query Responsibility Segregation</td>
<td>命令/查询职责分离（CQRS）</td>
</tr>
<tr class="odd">
<td>Command/Query Separation</td>
<td>命令/查询分离（CQS）</td>
</tr>
<tr class="even">
<td>commingled bits</td>
<td>混合的比特</td>
</tr>
<tr class="odd">
<td>communication</td>
<td>通信</td>
</tr>
<tr class="even">
<td>community</td>
<td>社区</td>
</tr>
<tr class="odd">
<td>committed</td>
<td>已提交（的）</td>
</tr>
<tr class="even">
<td>Common Intermediate Language</td>
<td>公共中间语言</td>
</tr>
<tr class="odd">
<td>Common Language Infrastructure</td>
<td>公共语言基础结构（CLI）</td>
</tr>
<tr class="even">
<td>Common Language Runtime</td>
<td>公共语言运行时（CLR）</td>
</tr>
<tr class="odd">
<td>Common Language Specification</td>
<td>公共语言规范（CLS）</td>
</tr>
<tr class="even">
<td>Common Type System</td>
<td>公共类型系统（CTS）</td>
</tr>
<tr class="odd">
<td>common name</td>
<td>通用名称</td>
</tr>
<tr class="even">
<td>compatibility</td>
<td>兼容性</td>
</tr>
<tr class="odd">
<td>Competing Consumer pattern</td>
<td>消费者竞争模式<sup>4</sup></td>
</tr>
<tr class="even">
<td>compile-time correctness checking</td>
<td>编译时正确性检查</td>
</tr>
<tr class="odd">
<td>Component Object Model</td>
<td>组件对象模型（COM）</td>
</tr>
<tr class="even">
<td>Composability</td>
<td>组合性</td>
</tr>
<tr class="odd">
<td>composite formatting</td>
<td>复合格式化</td>
</tr>
<tr class="even">
<td>Composite Pattern</td>
<td>复合模式、组合模式</td>
</tr>
<tr class="odd">
<td>concurrency conflicts</td>
<td>并发冲突</td>
</tr>
<tr class="even">
<td>concurrency mode</td>
<td>并发模式</td>
</tr>
<tr class="odd">
<td>conditional compilation</td>
<td>条件编译</td>
</tr>
<tr class="even">
<td>conditional compilation statement</td>
<td>条件编译语句</td>
</tr>
<tr class="odd">
<td>configuration</td>
<td>配置，设置</td>
</tr>
<tr class="even">
<td>connection string</td>
<td>连接字符串</td>
</tr>
<tr class="odd">
<td>Consolidate Conditional Expression</td>
<td>合并条件表达式<sup>1</sup></td>
</tr>
<tr class="even">
<td>Consolidate Duplicate Conditional Fragments</td>
<td>合并重复的条件片段<sup>1</sup></td>
</tr>
<tr class="odd">
<td>consistency</td>
<td>一致性</td>
</tr>
<tr class="even">
<td>constructor</td>
<td>构造函数</td>
</tr>
<tr class="odd">
<td>container</td>
<td>容器</td>
</tr>
<tr class="even">
<td>Container As A Service</td>
<td>容器即服务（CaaS）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>content</td>
<td>内容</td>
</tr>
<tr class="even">
<td>context</td>
<td>上下文</td>
</tr>
<tr class="odd">
<td>context map, 上下文映射图</td>
<td>上下文地图 <sup>5</sup></td>
</tr>
<tr class="even">
<td>Context Mapping</td>
<td>上下文映射 <sup>5</sup></td>
</tr>
<tr class="odd">
<td>contextual keyword</td>
<td>上下文关键字</td>
</tr>
<tr class="even">
<td>continuous integration</td>
<td>持续集成</td>
</tr>
<tr class="odd">
<td>contribute</td>
<td>贡献</td>
</tr>
<tr class="even">
<td>Contributor License Agreement</td>
<td>贡献者许可协议</td>
</tr>
<tr class="odd">
<td>convention</td>
<td>约定</td>
</tr>
<tr class="even">
<td>covariance</td>
<td>协变</td>
</tr>
<tr class="odd">
<td>contravariance</td>
<td>逆变</td>
</tr>
<tr class="even">
<td>convert</td>
<td>转换</td>
</tr>
<tr class="odd">
<td>Convert Procedural Design to Objects</td>
<td>将过程化设计转化为对象设计<sup>1</sup></td>
</tr>
<tr class="even">
<td>cookie</td>
<td>Cookie</td>
</tr>
<tr class="odd">
<td>copy-on-write</td>
<td>写时复制</td>
</tr>
<tr class="even">
<td>core</td>
<td>内核；.NET Core 的简写（能且仅能与 .NET Framework 的简写 <code>nfx</code> 同时出现，作如 <code>nfx/core</code>，单独使用时应为全称 <code>.NET Core</code>）</td>
</tr>
<tr class="odd">
<td>core domain</td>
<td>核心领域</td>
</tr>
<tr class="even">
<td>corruption</td>
<td>损毁</td>
</tr>
<tr class="odd">
<td>Cosmetic issue</td>
<td>外观上问题</td>
</tr>
<tr class="even">
<td>Cost of Change</td>
<td>更改开销（CoC）</td>
</tr>
<tr class="odd">
<td>CoT</td>
<td>思维链（Chain-of-Thought）<sup>6</sup></td>
</tr>
<tr class="even">
<td>COTS</td>
<td>现成的商业软件（Commercial Off-The Shelf）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>counterpoint</td>
<td>对位<sup>4</sup></td>
</tr>
<tr class="even">
<td>Coupling count</td>
<td>耦合数：当一个方法被调用时传给它以及从它传出来的值的数目。如果该方法没有返回值，则耦合数就是它的参数数目。否则就是参数数目加 1。如果你想要在没有测试的情况下提取出一个消防法的话，计算一下它的耦合数是很有意义的。</td>
</tr>
<tr class="odd">
<td>CPU</td>
<td>中央处理器（Central Processing Unit）</td>
</tr>
<tr class="even">
<td>CQRS</td>
<td>命令查询职责分离（Command-Query Responsibility Segregation）</td>
</tr>
<tr class="odd">
<td>crash</td>
<td>（程序）崩溃</td>
</tr>
<tr class="even">
<td>crash dump</td>
<td>故障转储</td>
</tr>
<tr class="odd">
<td>Creational Design Patterns</td>
<td>创建性设计模式</td>
</tr>
<tr class="even">
<td>CRC</td>
<td>类-职责-交互（class-responsibility-collaboration）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>credential</td>
<td>凭证<sup>4</sup></td>
</tr>
<tr class="even">
<td>cririque</td>
<td>评估</td>
</tr>
<tr class="odd">
<td>CRM</td>
<td>客户关系管理（Customer Relationship Management）</td>
</tr>
<tr class="even">
<td>Cross Domain</td>
<td>跨域</td>
</tr>
<tr class="odd">
<td>Cross-browser</td>
<td>跨浏览器</td>
</tr>
<tr class="even">
<td>Cross-platform</td>
<td>跨平台</td>
</tr>
<tr class="odd">
<td>Cross-Functional Requirement</td>
<td>跨功能需求（CFR）<sup>4</sup></td>
</tr>
<tr class="even">
<td>CRT</td>
<td>cathode ray tube，阴极射线管</td>
</tr>
<tr class="odd">
<td>cruft</td>
<td>残留</td>
</tr>
<tr class="even">
<td>cryptography</td>
<td>密码术</td>
</tr>
<tr class="odd">
<td>CTS</td>
<td>公共类型系统（Common Type System）</td>
</tr>
<tr class="even">
<td>cursor</td>
<td>光标</td>
</tr>
<tr class="odd">
<td>Customizability</td>
<td>可定制性</td>
</tr>
<tr class="even">
<td>cybraian</td>
<td>电脑族</td>
</tr>
<tr class="odd">
<td>cyberspace</td>
<td>电脑空间</td>
</tr>
<tr class="even">
<td>cycle time</td>
<td>周期时间</td>
</tr>
<tr class="odd">
<td>cyclic digraph</td>
<td>有向有环图</td>
</tr>
<tr class="even">
<td>Cyclic Hierarchy</td>
<td>循环层次结构<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Cyclically-dependent Modularization</td>
<td>循环依赖式模块化<sup>2</sup></td>
</tr>
<tr class="even">
<td>Cyclomatic complexity</td>
<td>圈复杂度</td>
</tr>
</tbody>
</table>
<h2 id="d">D</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DaaS</td>
<td>Data as a Service，数据即服务</td>
</tr>
<tr class="even">
<td>DAG</td>
<td>有向无循环图</td>
</tr>
<tr class="odd">
<td>dashboard</td>
<td>仪表盘</td>
</tr>
<tr class="even">
<td>data access layer</td>
<td>数据访问层</td>
</tr>
<tr class="odd">
<td>Data Storage as a Service</td>
<td>数据存储即服务（DaaS）</td>
</tr>
<tr class="even">
<td>data clumps</td>
<td>数据泥团<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Data Encryption Standard</td>
<td>数据加密标准（DES）</td>
</tr>
<tr class="even">
<td>data layer</td>
<td>数据层</td>
</tr>
<tr class="odd">
<td>data integrity</td>
<td>数据完整性</td>
</tr>
<tr class="even">
<td>data invariant</td>
<td>数据不变式</td>
</tr>
<tr class="odd">
<td>data mining</td>
<td>数据挖掘</td>
</tr>
<tr class="even">
<td>data pump</td>
<td>数据泵</td>
</tr>
<tr class="odd">
<td>Data Transfer Object</td>
<td>数据传输对象（DTO）</td>
</tr>
<tr class="even">
<td>declarative programming</td>
<td>宣告式编程</td>
</tr>
<tr class="odd">
<td>Decompose Conditional</td>
<td>分解条件表达式<sup>1</sup></td>
</tr>
<tr class="even">
<td>Decorator Pattern</td>
<td>修饰器模式（DP）、装饰模式</td>
</tr>
<tr class="odd">
<td>Deep Hierarchy</td>
<td>过深的层次结构<sup>2</sup></td>
</tr>
<tr class="even">
<td>Default Literal</td>
<td>默认常值</td>
</tr>
<tr class="odd">
<td>Defensive Programming</td>
<td>防御式编程</td>
</tr>
<tr class="even">
<td>Deficient Encapsulation</td>
<td>不充分的封装<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Definition of Done</td>
<td>完成的定义（DoD）</td>
</tr>
<tr class="even">
<td>denial-of-service attacks</td>
<td>拒绝服务攻击<sup>4</sup></td>
</tr>
<tr class="odd">
<td>dependency injection</td>
<td>依赖注入（DI）</td>
</tr>
<tr class="even">
<td>dependency</td>
<td>依赖</td>
</tr>
<tr class="odd">
<td>dependency digraph</td>
<td>依赖有向图</td>
</tr>
<tr class="even">
<td>deployment</td>
<td>部署</td>
</tr>
<tr class="odd">
<td>dequeue</td>
<td>出列</td>
</tr>
<tr class="even">
<td>derives from</td>
<td>继承</td>
</tr>
<tr class="odd">
<td>design pattern</td>
<td>设计模式</td>
</tr>
<tr class="even">
<td>Design Requirements Document</td>
<td>交互设计说明文档（DRD）</td>
</tr>
<tr class="odd">
<td>device</td>
<td>设备</td>
</tr>
<tr class="even">
<td>DFS</td>
<td>深度优先搜索</td>
</tr>
<tr class="odd">
<td>DfT</td>
<td>为可测试性而设计</td>
</tr>
<tr class="even">
<td>DI</td>
<td>依赖注入（dependency injection）</td>
</tr>
<tr class="odd">
<td>DIaaS</td>
<td>Data intelligence as a Service，数据智能即服务（出自2022年6月29日，阿里常规线上新品牌发布会）</td>
</tr>
<tr class="even">
<td>diagnostics</td>
<td>诊断</td>
</tr>
<tr class="odd">
<td>directed graph</td>
<td>有向图</td>
</tr>
<tr class="even">
<td>directive</td>
<td>指令</td>
</tr>
<tr class="odd">
<td>DiRT</td>
<td>灾难恢复测试（Disaster Recovery Test）<sup>4</sup></td>
</tr>
<tr class="even">
<td>discussion forum</td>
<td>论坛</td>
</tr>
<tr class="odd">
<td>disk</td>
<td>磁盘</td>
</tr>
<tr class="even">
<td>distributed system</td>
<td>分布式系统</td>
</tr>
<tr class="odd">
<td>DLL</td>
<td>动态链接库（Dynamic Link Library）</td>
</tr>
<tr class="even">
<td>DNS</td>
<td>域名系统（Domain Name System）</td>
</tr>
<tr class="odd">
<td>Document Object Model</td>
<td>文档对象模型（DOM）</td>
</tr>
<tr class="even">
<td>domain-driven design</td>
<td>领域驱动设计（DDD）</td>
</tr>
<tr class="odd">
<td>Domain Event</td>
<td>领域事件</td>
</tr>
<tr class="even">
<td>Domain Model</td>
<td>领域模型</td>
</tr>
<tr class="odd">
<td>Domain Name System</td>
<td>域名系统（DNS）</td>
</tr>
<tr class="even">
<td>Domain Service</td>
<td>领域服务</td>
</tr>
<tr class="odd">
<td>Domain Specific Language</td>
<td>领域特定语言（DSL）</td>
</tr>
<tr class="even">
<td>DRD</td>
<td>交互设计说明文档（Design Requirements Document）</td>
</tr>
<tr class="odd">
<td>DRY 原则</td>
<td>不自我重复原则（Don't Repeat Yourself），“不要重复你自己<sup>3</sup>”</td>
</tr>
<tr class="even">
<td>duck-typing</td>
<td>鸭子类型</td>
</tr>
<tr class="odd">
<td>duck test</td>
<td>鸭子测试</td>
</tr>
<tr class="even">
<td>dummy function</td>
<td>虚构函数</td>
</tr>
<tr class="odd">
<td>dump</td>
<td>转储</td>
</tr>
<tr class="even">
<td>Duplicate Abstraction</td>
<td>重复的抽象<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Duplicate Observed Data</td>
<td>复制“被监视数据”<sup>1</sup></td>
</tr>
<tr class="even">
<td>durability</td>
<td>持久性</td>
</tr>
<tr class="odd">
<td>Dynamic Link Library</td>
<td>动态链接库（DLL）</td>
</tr>
</tbody>
</table>
<h2 id="e">E</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EAP</td>
<td>早期评估版本（Early Assessment Program）</td>
</tr>
<tr class="even">
<td>EAP</td>
<td>基于事件的异步模式（Event-based Asynchronous Pattern）</td>
</tr>
<tr class="odd">
<td>Early Assessment Program</td>
<td>早期评估版本（EAP）</td>
</tr>
<tr class="even">
<td>effect sketch</td>
<td>影响草图</td>
</tr>
<tr class="odd">
<td>Egress</td>
<td>流出</td>
</tr>
<tr class="even">
<td>elasticity</td>
<td>弹性</td>
</tr>
<tr class="odd">
<td>ELBs</td>
<td>弹性负载均衡器（Elastic Load Balancers）<sup>4</sup></td>
</tr>
<tr class="even">
<td>Element (XML)</td>
<td>元素</td>
</tr>
<tr class="odd">
<td>Elvis Operator</td>
<td>埃尔维斯运算符</td>
</tr>
<tr class="even">
<td>Emergence</td>
<td>涌现、创发、突现、呈展、演生，是一种现象。</td>
</tr>
<tr class="odd">
<td>Encapsulate Collection</td>
<td>封装集合<sup>1</sup></td>
</tr>
<tr class="even">
<td>Encapsulate Downset</td>
<td>封装向下转型<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Encapsulate Field</td>
<td>封装字段<sup>1</sup></td>
</tr>
<tr class="even">
<td>endpoint</td>
<td>端点</td>
</tr>
<tr class="odd">
<td>enqueue</td>
<td>入列；加入队列</td>
</tr>
<tr class="even">
<td>Enterprise Resource Planning</td>
<td>企业资源计划（ERP）</td>
</tr>
<tr class="odd">
<td>entity</td>
<td>实体</td>
</tr>
<tr class="even">
<td>Entity Tags</td>
<td>实体标签（ETag）</td>
</tr>
<tr class="odd">
<td>entourage anti-pattern</td>
<td>随从反模式</td>
</tr>
<tr class="even">
<td>erosion</td>
<td>侵蚀</td>
</tr>
<tr class="odd">
<td>Event-based Asynchronous Pattern</td>
<td>基于事件的异步模式（EAP）</td>
</tr>
<tr class="even">
<td>event data pump</td>
<td>时间数据泵<sup>4</sup></td>
</tr>
<tr class="odd">
<td>event sourcing</td>
<td>事件源</td>
</tr>
<tr class="even">
<td>Evolvability</td>
<td>可进化性</td>
</tr>
<tr class="odd">
<td>exception handling</td>
<td>异常处理</td>
</tr>
<tr class="even">
<td>Exclusive OR</td>
<td>异或（XOR）</td>
</tr>
<tr class="odd">
<td>explanatory figures</td>
<td>图示</td>
</tr>
<tr class="even">
<td>Extensible Markup Language</td>
<td>可扩展标记语言（XML）</td>
</tr>
<tr class="odd">
<td>Extensibility</td>
<td>可扩展性</td>
</tr>
<tr class="even">
<td>extra large</td>
<td>特大型</td>
</tr>
<tr class="odd">
<td>extra small</td>
<td>特小型</td>
</tr>
<tr class="even">
<td>Extract Class</td>
<td>提炼类<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Extract Hierarchy</td>
<td>提炼继承体系<sup>1</sup></td>
</tr>
<tr class="even">
<td>Extract Interface</td>
<td>提炼接口<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Extract Method</td>
<td>提炼函数<sup>1</sup></td>
</tr>
<tr class="even">
<td>Extract Subclass</td>
<td>提炼子类<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Extract Superclass</td>
<td>提炼超类<sup>1</sup></td>
</tr>
<tr class="even">
<td>eXtreme Programming</td>
<td>极限编程（XP）</td>
</tr>
</tbody>
</table>
<h2 id="f">F</h2>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Facade Pattern</td>
<td>外观模式</td>
</tr>
<tr class="even">
<td>Factory Method Pattern</td>
<td>工厂方法模式</td>
</tr>
<tr class="odd">
<td>failover</td>
<td>容错转移</td>
</tr>
<tr class="even">
<td>failure domain</td>
<td>故障域</td>
</tr>
<tr class="odd">
<td>fake object</td>
<td>伪对象：在测试中伪装成一个类的合作者的对象</td>
</tr>
<tr class="even">
<td>fan-in</td>
<td>扇入</td>
</tr>
<tr class="odd">
<td>fan-out</td>
<td>扇出</td>
</tr>
<tr class="even">
<td>fat client</td>
<td>胖客户端</td>
</tr>
<tr class="odd">
<td>FCL</td>
<td>.NET Framework 类库（Framework Class Library）</td>
</tr>
<tr class="even">
<td>FDD</td>
<td>软盘（Floppy Disk Drive）</td>
</tr>
<tr class="odd">
<td>feature sketch</td>
<td>特性草图</td>
</tr>
<tr class="even">
<td>feed</td>
<td>聚合（资源聚合）</td>
</tr>
<tr class="odd">
<td>fine-tuning</td>
<td>微调</td>
</tr>
<tr class="even">
<td>first-party</td>
<td>第一方</td>
</tr>
<tr class="odd">
<td>Floopy Disk Drive</td>
<td>软盘（FDD）</td>
</tr>
<tr class="even">
<td>Flyweight Pattern</td>
<td>享元模式</td>
</tr>
<tr class="odd">
<td>follow up</td>
<td>跟进</td>
</tr>
<tr class="even">
<td>foreign key</td>
<td>外键</td>
</tr>
<tr class="odd">
<td>Form Template Method</td>
<td>塑造模板函数<sup>1</sup></td>
</tr>
<tr class="even">
<td>format item</td>
<td>格式项</td>
</tr>
<tr class="odd">
<td>format string</td>
<td>格式字符串</td>
</tr>
<tr class="even">
<td>forward</td>
<td>转发</td>
</tr>
<tr class="odd">
<td>FPP</td>
<td>零售版（Full Packaged Product）</td>
</tr>
<tr class="even">
<td>Framework Class Library</td>
<td>.NET Framework 类库（FCL）</td>
</tr>
<tr class="odd">
<td>FRD</td>
<td>功能需求文档（Functional Requirements Document）</td>
</tr>
<tr class="even">
<td>free</td>
<td>免费</td>
</tr>
<tr class="odd">
<td>free function</td>
<td>自由函数：一个不属于任何类的函数。在 C 和其他过程式语言中，自由函数被简单地称为函数；在 C++ 中被称为非成员函数。在 Java 和 C# 中没有自由函数。</td>
</tr>
<tr class="even">
<td>Functional Requirements Document</td>
<td>功能需求文档（FRD）</td>
</tr>
<tr class="odd">
<td>full-duplex</td>
<td>全双工</td>
</tr>
<tr class="even">
<td>Full Packaged Product</td>
<td>零售版（FPP）</td>
</tr>
<tr class="odd">
<td>Function Pointers</td>
<td>函数指针</td>
</tr>
</tbody>
</table>
<h2 id="g">G</h2>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Garbage Collection</td>
<td>垃圾回收器（GC）</td>
</tr>
<tr class="even">
<td>gauge</td>
<td>计量表<sup>4</sup></td>
</tr>
<tr class="odd">
<td>GC Heap</td>
<td>垃圾回收堆</td>
</tr>
<tr class="even">
<td>GC root</td>
<td>GC 根对象</td>
</tr>
<tr class="odd">
<td>Generalization</td>
<td>泛化</td>
</tr>
<tr class="even">
<td>Generalized Async</td>
<td>通用异步</td>
</tr>
<tr class="odd">
<td>Generalized Async Return</td>
<td>通用异步返回（C# 7.0）</td>
</tr>
<tr class="even">
<td>generalizing specialist</td>
<td>全科专家（敏捷开发术语）</td>
</tr>
<tr class="odd">
<td>generator</td>
<td>生成器</td>
</tr>
<tr class="even">
<td>Generic Attributes</td>
<td>泛型特性</td>
</tr>
<tr class="odd">
<td>Generic Math</td>
<td>泛型数学</td>
</tr>
<tr class="even">
<td>Geo-Replication</td>
<td>地域复制</td>
</tr>
<tr class="odd">
<td>Geo Redundant</td>
<td>地域冗余</td>
</tr>
<tr class="even">
<td>Global Assembly Cache</td>
<td>全局程序集缓存（GAC）</td>
</tr>
<tr class="odd">
<td>global state</td>
<td>全局状态</td>
</tr>
<tr class="even">
<td>global using directives</td>
<td>全局 Using 指令</td>
</tr>
<tr class="odd">
<td>Goal Directed Design</td>
<td>目标导向设计，旨在处理并满足用户目标和动机，包含产品目标和用户目标</td>
</tr>
<tr class="even">
<td>GoT</td>
<td>思维图，思维图谱（Graph-of-Thought） <sup>6</sup></td>
</tr>
<tr class="odd">
<td>GPT-3</td>
<td>Generative Pre-trained Transformer 3，是 OpenAI 最注明的 LLM 之一 <sup>6</sup> ，拥有1750亿个参数。该模型在文本生成、翻译和其他任务中表现出显著的性能，在全球范围内引起了热烈的反响，目前 OpenAI 已经迭代到了更高版本。</td>
</tr>
<tr class="even">
<td>Graph-of-Thought</td>
<td>思维图，思维图谱（GoT） <sup>6</sup></td>
</tr>
<tr class="odd">
<td>Graphical User Interface</td>
<td>图像用户界面设计（GUI），是一种结合计算机科学、美学、心理学、行为学、及各商业领域需求分析的人机系统工程，强调人、机、环境三者作为一个系统进行总体设计。</td>
</tr>
<tr class="even">
<td>GUI</td>
<td>图像用户界面设计（Graphical User Interface）</td>
</tr>
</tbody>
</table>
<h2 id="h">H</h2>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hackable</td>
<td>修改方便（根据《Web API 设计与开发》一书之翻译）</td>
</tr>
<tr class="even">
<td>HAL</td>
<td>超文本应用程序语言（Hypertext Application Language）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>handle</td>
<td>句柄</td>
</tr>
<tr class="even">
<td>Hard Disk Drive</td>
<td>硬盘（HDD）</td>
</tr>
<tr class="odd">
<td>HATEOAS</td>
<td>超媒体作为程序状态的引擎（Hypermedia As The Engine Of Application State）<sup>4</sup></td>
</tr>
<tr class="even">
<td>HCI</td>
<td>人机交互（Human-Computer Interaction），属于研究层面，是人与计算机之间传递、交换信息的媒介和对话接口，是计算机系统的重要组成部分。</td>
</tr>
<tr class="odd">
<td>HDD</td>
<td>硬盘（Hard Disk Drive）</td>
</tr>
<tr class="even">
<td>header</td>
<td>头；标头；表头</td>
</tr>
<tr class="odd">
<td>Hexagonal Architecture</td>
<td>六边形架构<sup>4</sup>，由 Alistair Cockburn 提出</td>
</tr>
<tr class="even">
<td>HMAC</td>
<td>基于哈希的小系列码（Hash-based Message Authentication）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Hide Delegate</td>
<td>隐藏“委托关系”<sup>1</sup></td>
</tr>
<tr class="even">
<td>Hide Method</td>
<td>隐藏函数<sup>1</sup></td>
</tr>
<tr class="odd">
<td>High Avaliability</td>
<td>高可用性</td>
</tr>
<tr class="even">
<td>High Fidelity Prototype</td>
<td>高保真原型，细节都比较详细的原型</td>
</tr>
<tr class="odd">
<td>high surrogate</td>
<td>高位代理项</td>
</tr>
<tr class="even">
<td>Homogeneous</td>
<td>同质化</td>
</tr>
<tr class="odd">
<td>hook</td>
<td>钩子</td>
</tr>
<tr class="even">
<td>hook point</td>
<td>挂接点</td>
</tr>
<tr class="odd">
<td>Horizontal Scale</td>
<td>水平缩放</td>
</tr>
<tr class="even">
<td>Hosting</td>
<td>宿主</td>
</tr>
<tr class="odd">
<td>Hub-like Modularization</td>
<td>轮毂式模块化<sup>2</sup></td>
</tr>
<tr class="even">
<td>HUI</td>
<td>手持设备用户界面，包括手机端和车载导航等（Handset User Interface）</td>
</tr>
<tr class="odd">
<td>Human-Computer Interaction</td>
<td>人机交互（HCI）</td>
</tr>
<tr class="even">
<td>Humane Registry</td>
<td>人文注册表（由 Martin Fowler 提出）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Hybrid Cloud</td>
<td>混合云</td>
</tr>
<tr class="even">
<td>hypertext-driven</td>
<td>超文本驱动</td>
</tr>
<tr class="odd">
<td>HyperText Markup Language</td>
<td>超文本标记语言（HTML）</td>
</tr>
</tbody>
</table>
<h2 id="i">I</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IA</td>
<td>信息架构（Information Architect）；</td>
</tr>
<tr class="even">
<td>Iaas</td>
<td>设施即服务（Infrastructure as a Service）</td>
</tr>
<tr class="odd">
<td>Idempotence</td>
<td>幂等性</td>
</tr>
<tr class="even">
<td>Idempotent Operation</td>
<td>幂等操作</td>
</tr>
<tr class="odd">
<td>Identity Provider</td>
<td>身份提供方</td>
</tr>
<tr class="even">
<td>IL</td>
<td>中间语言（intermediate language）</td>
</tr>
<tr class="odd">
<td>Illegitimate Injection</td>
<td>非法注入</td>
</tr>
<tr class="even">
<td>IM</td>
<td>即时通讯（Instant Messaging）</td>
</tr>
<tr class="odd">
<td>image</td>
<td>映像</td>
</tr>
<tr class="even">
<td>immersion approach</td>
<td>沉浸法</td>
</tr>
<tr class="odd">
<td>Imperative Abstraction</td>
<td>命令式抽象<sup>2</sup></td>
</tr>
<tr class="even">
<td>in-context learning</td>
<td>上下文学习 <sup>6</sup></td>
</tr>
<tr class="odd">
<td>Incomplete Abstraction</td>
<td>不完整的抽象<sup>2</sup></td>
</tr>
<tr class="even">
<td>index</td>
<td>索引</td>
</tr>
<tr class="odd">
<td>Information Architect</td>
<td>信息架构（IA）</td>
</tr>
<tr class="even">
<td>Infrastructure as a Service</td>
<td>设施即服务（Iaas）</td>
</tr>
<tr class="odd">
<td>ingesting</td>
<td>摄取</td>
</tr>
<tr class="even">
<td>ingress</td>
<td>流入</td>
</tr>
<tr class="odd">
<td>Inline Class</td>
<td>将类内联化<sup>1</sup></td>
</tr>
<tr class="even">
<td>Inline Method</td>
<td>内联函数<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Inline Temp</td>
<td>内联临时变量<sup>1</sup></td>
</tr>
<tr class="even">
<td>input endpoint</td>
<td>输入端点</td>
</tr>
<tr class="odd">
<td>instance</td>
<td>实例</td>
</tr>
<tr class="even">
<td>Instance InputEndpoint</td>
<td>实例输入端点</td>
</tr>
<tr class="odd">
<td>Instant Messaging</td>
<td>即时通讯（IM）</td>
</tr>
<tr class="even">
<td>instantiation</td>
<td>实例化</td>
</tr>
<tr class="odd">
<td>instantiator</td>
<td>实例化器</td>
</tr>
<tr class="even">
<td>instruction fine-tuning</td>
<td>指令微调</td>
</tr>
<tr class="odd">
<td>Insufficient Modularization</td>
<td>不充分的模块化<sup>2</sup></td>
</tr>
<tr class="even">
<td>Interaction-based testing</td>
<td>基于交互的测试</td>
</tr>
<tr class="odd">
<td>Intercept</td>
<td>截取</td>
</tr>
<tr class="even">
<td>interception point</td>
<td>拦截点：可以编写测试来感知某些条件的地方</td>
</tr>
<tr class="odd">
<td>intermediate language</td>
<td>中间语言（IL）</td>
</tr>
<tr class="even">
<td>Internal Endpoint</td>
<td>内部端点</td>
</tr>
<tr class="odd">
<td>Internet Information Service</td>
<td>Internet 信息服务（IIS）</td>
</tr>
<tr class="even">
<td>Internet Protocol</td>
<td>互联网协议（IP）</td>
</tr>
<tr class="odd">
<td>Interpreter Pattern</td>
<td>解释器模式</td>
</tr>
<tr class="even">
<td>interpolated strings</td>
<td>内插字符串</td>
</tr>
<tr class="odd">
<td>Introduce Assertion</td>
<td>引入断言<sup>1</sup></td>
</tr>
<tr class="even">
<td>Introduce Explaining Variable</td>
<td>引入解释性变量<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Introduce Foreign Method</td>
<td>引入外加函数<sup>1</sup></td>
</tr>
<tr class="even">
<td>Introduce Local Extension</td>
<td>引入本地扩展<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Introduce Null Object</td>
<td>引入 Null 对象<sup>1</sup></td>
</tr>
<tr class="even">
<td>Introduce Parameter Object</td>
<td>引入参数对象<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Intrusion Detection Systems</td>
<td>入侵检测系统（IDS）<sup>4</sup></td>
</tr>
<tr class="even">
<td>Intrusion Prevention Systems</td>
<td>入侵预防系统（IPS）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Inversion of Control</td>
<td>控制反转（IoC）</td>
</tr>
<tr class="even">
<td>Isolation</td>
<td>隔离性</td>
</tr>
<tr class="odd">
<td>isomorphism</td>
<td>同构（数学领域专用术语）</td>
</tr>
<tr class="even">
<td>iterable</td>
<td>可迭代的</td>
</tr>
<tr class="odd">
<td>iteration</td>
<td>迭代</td>
</tr>
<tr class="even">
<td>iterator</td>
<td>迭代器</td>
</tr>
<tr class="odd">
<td>Iterator Pattern</td>
<td>迭代模式</td>
</tr>
<tr class="even">
<td>iterator protocol</td>
<td>迭代器协议</td>
</tr>
</tbody>
</table>
<h2 id="j">J</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Job</td>
<td>作业</td>
</tr>
<tr class="even">
<td>Job Description</td>
<td>岗位描述（JD）</td>
</tr>
<tr class="odd">
<td>JOSE</td>
<td>JSON 对象签名和加密</td>
</tr>
<tr class="even">
<td>Json Web Token</td>
<td>JSON Web 令牌<sup>4</sup></td>
</tr>
<tr class="odd">
<td>just-in-time compilation</td>
<td>即时编译，JIT 编译</td>
</tr>
<tr class="even">
<td>JVM</td>
<td>Java 虚拟机（Java Virtual Machine）</td>
</tr>
</tbody>
</table>
<h2 id="k">K</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Key</td>
<td>密钥</td>
</tr>
<tr class="even">
<td>key-event notification</td>
<td>键事件通知</td>
</tr>
<tr class="odd">
<td>Key Opinion Leader</td>
<td>关键意见领袖（KOL），俗称大 V</td>
</tr>
<tr class="even">
<td>Key Performance Indicator</td>
<td>关键绩效考核指标（KPI）</td>
</tr>
<tr class="odd">
<td>Key Space</td>
<td>键空间</td>
</tr>
<tr class="even">
<td>key-space notification</td>
<td>键空间通知</td>
</tr>
<tr class="odd">
<td>Key-Value Pair</td>
<td>键-值对</td>
</tr>
<tr class="even">
<td>KISS 原则</td>
<td>保持简单原则（Keep It Simple Silly），“简单是一切之本<sup>3</sup>”</td>
</tr>
<tr class="odd">
<td>KPI</td>
<td>关键绩效考核指标（Key Performance Indicator）</td>
</tr>
</tbody>
</table>
<h2 id="l">L</h2>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Language Integrated Query</td>
<td>语言集成查询（LINQ）</td>
</tr>
<tr class="even">
<td>Large</td>
<td>大型</td>
</tr>
<tr class="odd">
<td>Large Language Model</td>
<td>大型语言模型（LLM） <sup>6</sup></td>
</tr>
<tr class="even">
<td>Layered Architecture</td>
<td>分层架构</td>
</tr>
<tr class="odd">
<td>LDAP</td>
<td>Lightweight Directory Access Protocol，轻型目录访问协议</td>
</tr>
<tr class="even">
<td>Leaky Encapsulation</td>
<td>泄露的封装<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Legacy system</td>
<td>遗留系统</td>
</tr>
<tr class="even">
<td>license</td>
<td>许可证</td>
</tr>
<tr class="odd">
<td>lifetime</td>
<td>生命周期</td>
</tr>
<tr class="even">
<td>Lightweight Directory Access Protocol</td>
<td>轻量级目录访问协议（LDAP）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>LINE of Business</td>
<td>业务线（LOB）<sup>4</sup></td>
</tr>
<tr class="even">
<td>link</td>
<td>链接</td>
</tr>
<tr class="odd">
<td>link seam</td>
<td>连接期接缝：在连接期接缝处，可以通过连接到另一个库来替换行为。在编译型语言中可替换的东西包括产品库、DLL、程序集或 JAR 文件。其目的是为了解除依赖，或感知某些在测试期间可有能会发生的条件。</td>
</tr>
<tr class="even">
<td>linked resource</td>
<td>链接的资源</td>
</tr>
<tr class="odd">
<td>Liskov Substitution Principle</td>
<td>里氏替换原则（LSP）</td>
</tr>
<tr class="even">
<td>literal</td>
<td>字面量、文字常量、直接量</td>
</tr>
<tr class="odd">
<td>living style guides</td>
<td>活样式指导<sup>4</sup></td>
</tr>
<tr class="even">
<td>LLM</td>
<td>大型语言模型（Large Language Model） <sup>6</sup></td>
</tr>
<tr class="odd">
<td>load-balancing</td>
<td>负载平衡</td>
</tr>
<tr class="even">
<td>load balancer</td>
<td>负载平衡器</td>
</tr>
<tr class="odd">
<td>load factor</td>
<td>负载因子</td>
</tr>
<tr class="even">
<td>load shedding</td>
<td>减载<sup>4</sup></td>
</tr>
<tr class="odd">
<td>LOC</td>
<td>代码行数</td>
</tr>
<tr class="even">
<td>Local Function</td>
<td>局部函数</td>
</tr>
<tr class="odd">
<td>lock-step release</td>
<td>同步发布<sup>4</sup></td>
</tr>
<tr class="even">
<td>log</td>
<td>日志</td>
</tr>
<tr class="odd">
<td>loop</td>
<td>自循环</td>
</tr>
<tr class="even">
<td>loose coupling</td>
<td>松散耦合</td>
</tr>
<tr class="odd">
<td>Low Fidelity Prototype</td>
<td>低保真原型，抽象原型视图</td>
</tr>
<tr class="even">
<td>low surrogate</td>
<td>低位代理项</td>
</tr>
<tr class="odd">
<td>LSUD</td>
<td>大批你所不知道的开发人员（Large Set of Unknown Developers）</td>
</tr>
</tbody>
</table>
<h2 id="m">M</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mainframe</td>
<td>主机</td>
</tr>
<tr class="even">
<td>Maintainability</td>
<td>可维护性</td>
</tr>
<tr class="odd">
<td>managed code</td>
<td>托管代码</td>
</tr>
<tr class="even">
<td>managed execution</td>
<td>托管执行</td>
</tr>
<tr class="odd">
<td>Man-In-The-Middle Attack</td>
<td>中间人攻击（MITM 攻击）</td>
</tr>
<tr class="even">
<td>Management Key</td>
<td>管理密钥</td>
</tr>
<tr class="odd">
<td>manifest</td>
<td>清单</td>
</tr>
<tr class="even">
<td>map</td>
<td>映射</td>
</tr>
<tr class="odd">
<td>Market Requirement Document</td>
<td>市场需求文档（MRD）</td>
</tr>
<tr class="even">
<td>Massive Multiplayer Online Role-Playing Game</td>
<td>大型多人在线角色扮演游戏（MMORPG）</td>
</tr>
<tr class="odd">
<td>Massively Multiplayer Online Role-Playing Game</td>
<td>大型多人在线角色扮演游戏（MMORPG）</td>
</tr>
<tr class="even">
<td>Mathematical Markup Language</td>
<td>数学标记语言（MathML）</td>
</tr>
<tr class="odd">
<td>Mean Time Between Failures</td>
<td>平均故障时间间隔（MTBF）<sup>4</sup></td>
</tr>
<tr class="even">
<td>Mean Time To Repair</td>
<td>平均修复时间（MTTR）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Media Service</td>
<td>媒体服务</td>
</tr>
<tr class="even">
<td>Mediator Pattern</td>
<td>中介者模式</td>
</tr>
<tr class="odd">
<td>Medium</td>
<td>中型</td>
</tr>
<tr class="even">
<td>Memento Pattern</td>
<td>备忘录模式</td>
</tr>
<tr class="odd">
<td>Merge</td>
<td>合并</td>
</tr>
<tr class="even">
<td>Metadata</td>
<td>元数据</td>
</tr>
<tr class="odd">
<td>metaprogramming</td>
<td>元编程</td>
</tr>
<tr class="even">
<td>Middleware</td>
<td>中间件</td>
</tr>
<tr class="odd">
<td>mind map</td>
<td>思维导图、脑图、心智图</td>
</tr>
<tr class="even">
<td>Minimum Marketable Feature</td>
<td>最小可售特性（MMF）</td>
</tr>
<tr class="odd">
<td>Minimum Viable Product</td>
<td>最小化可行产品（MVP）</td>
</tr>
<tr class="even">
<td>Minimum Viable Release</td>
<td>最小可行发布（MVR）</td>
</tr>
<tr class="odd">
<td>Missing Abstraction</td>
<td>缺失抽象<sup>2</sup></td>
</tr>
<tr class="even">
<td>Missing Encapsulation</td>
<td>缺失的封装<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Missing Hierarchy</td>
<td>缺失层次结构<sup>2</sup></td>
</tr>
<tr class="even">
<td>Mixed Reality</td>
<td>混合现实（MR）</td>
</tr>
<tr class="odd">
<td>Mobile Service</td>
<td>移动服务</td>
</tr>
<tr class="even">
<td>Mock Object</td>
<td>模拟对象，仿对象：在内部对条件进行断言的伪对象</td>
</tr>
<tr class="odd">
<td>Move Field</td>
<td>搬移字段<sup>1</sup></td>
</tr>
<tr class="even">
<td>Move Method</td>
<td>搬移函数<sup>1</sup></td>
</tr>
<tr class="odd">
<td>MRD</td>
<td>市场需求文档（Market Requirement Document）</td>
</tr>
<tr class="even">
<td>Multitenancy</td>
<td>多租户</td>
</tr>
<tr class="odd">
<td>Multifaced Abstraction</td>
<td>多方面抽象<sup>2</sup></td>
</tr>
<tr class="even">
<td>Multipath Hierarchy</td>
<td>多路径层次结构<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Multitier Architecture</td>
<td>多层体系结构</td>
</tr>
<tr class="even">
<td>Multi-factor Authentication</td>
<td>多重验证</td>
</tr>
</tbody>
</table>
<h2 id="n">N</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>naming collisions</td>
<td>命名冲突</td>
</tr>
<tr class="even">
<td>Namespace</td>
<td>命名空间，名称空间</td>
</tr>
<tr class="odd">
<td>native code</td>
<td>本机代码</td>
</tr>
<tr class="even">
<td>NCC</td>
<td>.NET Core 社区（.NET Core Community）/.NET 中国社区（.NET China Community）</td>
</tr>
<tr class="odd">
<td>Near Field Communication</td>
<td>近距离无线通信（NFC）</td>
</tr>
<tr class="even">
<td>network hops</td>
<td>网络跳数</td>
</tr>
<tr class="odd">
<td>NFC</td>
<td>近距离无线通信（Near Field Communication）</td>
</tr>
<tr class="even">
<td>nfx</td>
<td>.NET Framework（.NET 框架）</td>
</tr>
<tr class="odd">
<td>Non-clustered Index</td>
<td>非聚集索引</td>
</tr>
<tr class="even">
<td>non-managed code</td>
<td>非托管代码</td>
</tr>
<tr class="odd">
<td>non-optional</td>
<td>非可选的</td>
</tr>
<tr class="even">
<td>non-transactional pipeline</td>
<td>非事务型流水线</td>
</tr>
<tr class="odd">
<td>node</td>
<td>节点</td>
</tr>
<tr class="even">
<td>normalize</td>
<td>规格化</td>
</tr>
<tr class="odd">
<td>notification</td>
<td>通知</td>
</tr>
<tr class="even">
<td>notification hub</td>
<td>通知中心</td>
</tr>
<tr class="odd">
<td>Null Object Pattern</td>
<td>空对象模式</td>
</tr>
<tr class="even">
<td>null-coalescing</td>
<td>空值合并</td>
</tr>
<tr class="odd">
<td>Null coalescing operator</td>
<td>空值合并运算符、空值结合运算符</td>
</tr>
<tr class="even">
<td>N-Tier</td>
<td>N 层（结构）</td>
</tr>
</tbody>
</table>
<h2 id="o">O</h2>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>obfuscator</td>
<td>混淆器</td>
</tr>
<tr class="even">
<td>Object Pool</td>
<td>对象池</td>
</tr>
<tr class="odd">
<td>Object Pool Pattern</td>
<td>对象池模式</td>
</tr>
<tr class="even">
<td>Object/Relational Mapper</td>
<td>对象/关系映射器（ORM，O/RM）</td>
</tr>
<tr class="odd">
<td>object seam</td>
<td>对象接缝：在对象连接处可以通过替换一个对象为另一个对象来“更替”行为。在面向对象语言中，通常通过子类化产品代码中的类并重写其方法来实现这一点。</td>
</tr>
<tr class="even">
<td>Objectives and Key Results</td>
<td>目标与关键成果法（OKR）</td>
</tr>
<tr class="odd">
<td>Observer Pattern</td>
<td>观察者模式</td>
</tr>
<tr class="even">
<td>On-demand (media)</td>
<td>点播（媒体）</td>
</tr>
<tr class="odd">
<td>Once and Only Once</td>
<td>一次且仅一次<sup>3</sup>(OAOO)</td>
</tr>
<tr class="even">
<td>One rule, one place</td>
<td>一个规则，实现一次</td>
</tr>
<tr class="odd">
<td>One-Size-Fits-All</td>
<td>OSFA</td>
</tr>
<tr class="even">
<td>one-time token</td>
<td>一次性令牌</td>
</tr>
<tr class="odd">
<td>Onion Architecture</td>
<td>洋葱架构，由 Jeffrey Palermo 提出</td>
</tr>
<tr class="even">
<td>Open Closed Principle</td>
<td>开闭原则（OCP）</td>
</tr>
<tr class="odd">
<td>Open System Interconnection</td>
<td>开放式系统互联（OSI）</td>
</tr>
<tr class="even">
<td>Operating System</td>
<td>操作系统（OS）</td>
</tr>
<tr class="odd">
<td>Optical Character Recognition</td>
<td>光学字符识别（OCR）</td>
</tr>
<tr class="even">
<td>Optimistic Concurrency</td>
<td>乐观并发控制</td>
</tr>
<tr class="odd">
<td>optimistic locking</td>
<td>乐观锁</td>
</tr>
<tr class="even">
<td>orchestration</td>
<td>编排</td>
</tr>
<tr class="odd">
<td>Orchestration Layer</td>
<td>策略编排层</td>
</tr>
<tr class="even">
<td>Ordering Principal</td>
<td>良序原则</td>
</tr>
<tr class="odd">
<td>OS</td>
<td>操作系统（Operating System）</td>
</tr>
<tr class="even">
<td>OSGI</td>
<td>开放服务网关协议（Open Source Gateway Initiative）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>overriding</td>
<td>重写</td>
</tr>
<tr class="even">
<td>Overview</td>
<td>概览</td>
</tr>
<tr class="odd">
<td>over-post</td>
<td>过度提交</td>
</tr>
<tr class="even">
<td>OWASP</td>
<td>开放式 Web 应用程序安全项目（Open Web Application Security Project）<sup>4</sup></td>
</tr>
</tbody>
</table>
<h2 id="p">P</h2>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P2P</td>
<td>个人对个人（Person-to-Person）</td>
</tr>
<tr class="even">
<td>Paas</td>
<td>平台即服务（Platform As A Service）</td>
</tr>
<tr class="odd">
<td>packet sniffing</td>
<td>分组嗅探</td>
</tr>
<tr class="even">
<td>Page Blob</td>
<td>页 BLOB</td>
</tr>
<tr class="odd">
<td>Parameterize Method</td>
<td>令函数携带参数<sup>1</sup></td>
</tr>
<tr class="even">
<td>Partial Translate</td>
<td>部分翻译（出自 Chrome 浏览器）</td>
</tr>
<tr class="odd">
<td>partition</td>
<td>分区</td>
</tr>
<tr class="even">
<td>Partition tolerance</td>
<td>分区容忍性<sup>4</sup></td>
</tr>
<tr class="odd">
<td>PascalCase</td>
<td>Pascal 大小写</td>
</tr>
<tr class="even">
<td>pass-through</td>
<td>直托</td>
</tr>
<tr class="odd">
<td>passive</td>
<td>被动（的）</td>
</tr>
<tr class="even">
<td>pattern</td>
<td>模式</td>
</tr>
<tr class="odd">
<td>Pay as You Go</td>
<td>即用即付</td>
</tr>
<tr class="even">
<td>PC</td>
<td>个人计算机（Personal Computer）</td>
</tr>
<tr class="odd">
<td>peek</td>
<td>查看</td>
</tr>
<tr class="even">
<td>peering rules</td>
<td>对等交互规则<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Percent Encoding</td>
<td>百分号编码</td>
</tr>
<tr class="even">
<td>performance</td>
<td>性能</td>
</tr>
<tr class="odd">
<td>performance counter</td>
<td>性能计数器</td>
</tr>
<tr class="even">
<td>performance-oriented</td>
<td>面向性能</td>
</tr>
<tr class="odd">
<td>Person-to-Person</td>
<td>个人对个人（P2P）</td>
</tr>
<tr class="even">
<td>Personal Computer</td>
<td>个人计算机（PC）</td>
</tr>
<tr class="odd">
<td>Pessimistic Concurrency</td>
<td>悲观并发控制</td>
</tr>
<tr class="even">
<td>pessimistic locking</td>
<td>悲观锁</td>
</tr>
<tr class="odd">
<td>PHAME</td>
<td>由 Booch 提出的对象模型的 4 个主要元素的设计规则的统称，即 Principle of Hierarchy, Abstraction, Modularization, and Encapsulation，层次结构、抽象、模块化与封装原则</td>
</tr>
<tr class="even">
<td>pinch point</td>
<td>汇点：影响结构图中的隘口和交通要冲，在汇点编写测试的好处就是只需针对少数几个方法编写测试，就能达到探测大量其他方法的改动的目的。</td>
</tr>
<tr class="odd">
<td>placeholder</td>
<td>占位符</td>
</tr>
<tr class="even">
<td>Platform as a Service</td>
<td>平台即服务（Paas）</td>
</tr>
<tr class="odd">
<td>PMD</td>
<td>项目管理文档（Program Managment Document）</td>
</tr>
<tr class="even">
<td>point of invocation of the method</td>
<td>方法调用点</td>
</tr>
<tr class="odd">
<td>Point-to-Site</td>
<td>点到站点</td>
</tr>
<tr class="even">
<td>polling</td>
<td>轮询</td>
</tr>
<tr class="odd">
<td>polymorphism</td>
<td>多态</td>
</tr>
<tr class="even">
<td>polyrot programming</td>
<td>多语言编程</td>
</tr>
<tr class="odd">
<td>Poor Man’s Dependency Injection</td>
<td>穷人的依赖注入</td>
</tr>
<tr class="even">
<td>post-initialization</td>
<td>后初始化</td>
</tr>
<tr class="odd">
<td>postcondition</td>
<td>后置条件</td>
</tr>
<tr class="even">
<td>PoT</td>
<td>程序思维（Program-to-Thoughts） <sup>6</sup></td>
</tr>
<tr class="odd">
<td>PRD</td>
<td>产品需求文档（Product Requirements Document）</td>
</tr>
<tr class="even">
<td>pre-flight request</td>
<td>事先请求</td>
</tr>
<tr class="odd">
<td>pre-initialization</td>
<td>预初始化</td>
</tr>
<tr class="even">
<td>pre-training</td>
<td>预训练 <sup>6</sup></td>
</tr>
<tr class="odd">
<td>Predicate Decorator</td>
<td>谓词修饰器</td>
</tr>
<tr class="even">
<td>precondition</td>
<td>前提，前置条件</td>
</tr>
<tr class="odd">
<td>presentation layer</td>
<td>表现层</td>
</tr>
<tr class="even">
<td>Preserve Whole Object</td>
<td>保持对象完整<sup>1</sup></td>
</tr>
<tr class="odd">
<td>primary database</td>
<td>主数据库</td>
</tr>
<tr class="even">
<td>primary storage</td>
<td>主存储</td>
</tr>
<tr class="odd">
<td>primitive obsession</td>
<td>基本类型偏执<sup>2</sup></td>
</tr>
<tr class="even">
<td>principal</td>
<td>主体<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Private Class Data Pattern</td>
<td>私有类数据模式</td>
</tr>
<tr class="even">
<td>private cloud</td>
<td>私有云</td>
</tr>
<tr class="odd">
<td>priority queue</td>
<td>优先级队列</td>
</tr>
<tr class="even">
<td>probe</td>
<td>探测器</td>
</tr>
<tr class="odd">
<td>process</td>
<td>进程</td>
</tr>
<tr class="even">
<td>producer</td>
<td>生产者</td>
</tr>
<tr class="odd">
<td>product backlog</td>
<td>产品积压工作</td>
</tr>
<tr class="even">
<td>Product Owner</td>
<td>产品负责人（PO）</td>
</tr>
<tr class="odd">
<td>Product Requirements Document</td>
<td>产品需求文档（PRD）</td>
</tr>
<tr class="even">
<td>production</td>
<td>生产（环境）</td>
</tr>
<tr class="odd">
<td>production load</td>
<td>生产负载<sup>4</sup></td>
</tr>
<tr class="even">
<td>Program Managment Document</td>
<td>项目管理文档（PMD）</td>
</tr>
<tr class="odd">
<td>Program-to-Thoughts</td>
<td>程序思维（PoT） <sup>6</sup></td>
</tr>
<tr class="even">
<td>programming by difference</td>
<td>差异式编程</td>
</tr>
<tr class="odd">
<td>proof of concept</td>
<td>概念验证</td>
</tr>
<tr class="even">
<td>proportional error rate</td>
<td>错误率比例<sup>4</sup></td>
</tr>
<tr class="odd">
<td>protected variation</td>
<td>防止变异</td>
</tr>
<tr class="even">
<td>protocol</td>
<td>协议</td>
</tr>
<tr class="odd">
<td>prototype</td>
<td>原型</td>
</tr>
<tr class="even">
<td>Prototype Pattern</td>
<td>原型模式</td>
</tr>
<tr class="odd">
<td>proxy</td>
<td>代理</td>
</tr>
<tr class="even">
<td>Proxy Pattern</td>
<td>代理模式</td>
</tr>
<tr class="odd">
<td>public cloud</td>
<td>公有云</td>
</tr>
<tr class="even">
<td>Pull Up Constructor Body</td>
<td>构造函数本体上移<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Pull Up Field</td>
<td>字段上移<sup>1</sup></td>
</tr>
<tr class="even">
<td>Pull Up Method</td>
<td>函数上移<sup>1</sup></td>
</tr>
<tr class="odd">
<td>push</td>
<td>推送</td>
</tr>
<tr class="even">
<td>Push Down Field</td>
<td>字段下移<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Push Down Method</td>
<td>函数下移<sup>1</sup></td>
</tr>
</tbody>
</table>
<h2 id="q">Q</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>quality assurance</td>
<td>质量保证（QA）</td>
</tr>
<tr class="even">
<td>Queue</td>
<td>队列</td>
</tr>
<tr class="odd">
<td>Quota</td>
<td>配额</td>
</tr>
</tbody>
</table>
<h2 id="r">R</h2>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rack</td>
<td>机架</td>
</tr>
<tr class="even">
<td>RAII</td>
<td>Resource Acquisition Is Initialization，资源获取即初始化</td>
</tr>
<tr class="odd">
<td>Rapid Application Development</td>
<td>快速应用程序开发（RAD）</td>
</tr>
<tr class="even">
<td>RDBMS</td>
<td>关系型数据库管理系统（Relational Database Management System）</td>
</tr>
<tr class="odd">
<td>Reactive extensions</td>
<td>响应式扩展（Rx）<sup>4</sup></td>
</tr>
<tr class="even">
<td>Ready (status)</td>
<td>就绪（状态）</td>
</tr>
<tr class="odd">
<td>real-time</td>
<td>即时、实时</td>
</tr>
<tr class="even">
<td>real-time discussions</td>
<td>即时讨论、实时讨论</td>
</tr>
<tr class="odd">
<td>Rebellious Hierarchy</td>
<td>叛逆性层次结构<sup>2</sup></td>
</tr>
<tr class="even">
<td>recursion</td>
<td>递归</td>
</tr>
<tr class="odd">
<td>Redundancy</td>
<td>冗余</td>
</tr>
<tr class="even">
<td>Redundant</td>
<td>冗余（的）</td>
</tr>
<tr class="odd">
<td>Ref Return</td>
<td>应用返回</td>
</tr>
<tr class="even">
<td>Ref Local</td>
<td>局部引用</td>
</tr>
<tr class="odd">
<td>Ref Property</td>
<td>引用属性</td>
</tr>
<tr class="even">
<td>Ref-Safe-to-Escape</td>
<td>引用安全逃逸</td>
</tr>
<tr class="odd">
<td>Ref-Safe-to-Escape scope</td>
<td>引用安全逃逸范围</td>
</tr>
<tr class="even">
<td>Refactor</td>
<td>重构</td>
</tr>
<tr class="odd">
<td>region</td>
<td>地域</td>
</tr>
<tr class="even">
<td>reification</td>
<td>具体化</td>
</tr>
<tr class="odd">
<td>Reinforcement Learning</td>
<td>强化学习，一种机器学习的方法，通过从外部获得激励来校正学习方向从而获得一种自适应的学习能力</td>
</tr>
<tr class="even">
<td>Reinforcement Learning from Human Feedback</td>
<td>基于人工反馈的强化学习（RLHF）</td>
</tr>
<tr class="odd">
<td>relay</td>
<td>中继</td>
</tr>
<tr class="even">
<td>Relevancy</td>
<td>适切性</td>
</tr>
<tr class="odd">
<td>Reliability</td>
<td>可靠性</td>
</tr>
<tr class="even">
<td>Relying Party</td>
<td>依赖方</td>
</tr>
<tr class="odd">
<td>Remove Assignments to Parameters</td>
<td>移除对参数的赋值<sup>1</sup></td>
</tr>
<tr class="even">
<td>Remove Control Flag</td>
<td>移除控制标记<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Remove Middle Man</td>
<td>移除中间人<sup>1</sup></td>
</tr>
<tr class="even">
<td>Remove Parameter</td>
<td>移除参数<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Remove Setting Method</td>
<td>移除配置函数<sup>1</sup></td>
</tr>
<tr class="even">
<td>Rename Method</td>
<td>函数改名<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Array with Object</td>
<td>以对象取代数组<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Conditional with Polymorphism</td>
<td>以多态取代条件表达式<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Constructor with Factory Method</td>
<td>以工厂函数取代构造函数<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Data Value with Object</td>
<td>以对象取代数据值<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Delegation with Inheritance</td>
<td>以继承取代委托<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Error 　 Code with Exception</td>
<td>以异常取代错误码<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Exception with Test</td>
<td>以测试取代异常<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Inheritance with Delegation</td>
<td>以委托取代继承<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Magic Number with Symbolic Constant</td>
<td>以字面常量取代魔法数<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Method with Method Object</td>
<td>以函数对象取代函数<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Nested Conditional with Guard Clauses</td>
<td>以卫语句取代嵌套条件表达式<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Parameter with Explicit Methods</td>
<td>以明确函数取代参数<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Parameter with Methods</td>
<td>以函数取代参数<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Record with Data Class</td>
<td>以数据类取代记录<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Subclass with Fields</td>
<td>以字段取代子类<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Temp with Query</td>
<td>以查询取代临时变量<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Type Code with Class</td>
<td>以类取代类型码<sup>1</sup></td>
</tr>
<tr class="even">
<td>Replace Type Code with State/Strategy</td>
<td>以 State/Strategy 取代类型码<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Replace Type Code with Subclass</td>
<td>以子类取代类型码<sup>1</sup></td>
</tr>
<tr class="even">
<td>reporting</td>
<td>报表</td>
</tr>
<tr class="odd">
<td>Repository</td>
<td>存储库；仓储；仓库；资源库</td>
</tr>
<tr class="even">
<td>REpresentational State Transfer</td>
<td>表述性状态转移、表征性状态传输、具象状态传输（REST）</td>
</tr>
<tr class="odd">
<td>request pipeline</td>
<td>请求管道</td>
</tr>
<tr class="even">
<td>Requirements Churn</td>
<td>需求波动</td>
</tr>
<tr class="odd">
<td>reserved</td>
<td>专属</td>
</tr>
<tr class="even">
<td>resolution</td>
<td>解析</td>
</tr>
<tr class="odd">
<td>Resource Acquisition Is Initialization</td>
<td>资源获取即初始化（RAII）</td>
</tr>
<tr class="even">
<td>Resource Release Is Destruction</td>
<td>在构造时没有“获取”资源，但在析构时释放资源（RRID），一种 RAII 的特殊用法</td>
</tr>
<tr class="odd">
<td>Resource-Oriented Architecture</td>
<td>面向资源的架构(ROA)</td>
</tr>
<tr class="even">
<td>Response Group</td>
<td>响应群</td>
</tr>
<tr class="odd">
<td>Return on Investment</td>
<td>投资回报（ROI）</td>
</tr>
<tr class="even">
<td>reverse proxy module</td>
<td>反向代理模块</td>
</tr>
<tr class="odd">
<td>retail</td>
<td>零售版</td>
</tr>
<tr class="even">
<td>Rich Client</td>
<td>丰富客户端</td>
</tr>
<tr class="odd">
<td>Ripple Effect</td>
<td>涟漪效应</td>
</tr>
<tr class="even">
<td>RLHF</td>
<td>基于人工反馈的强化学习（Reinforcement Learning from Human Feedback）</td>
</tr>
<tr class="odd">
<td>role</td>
<td>角色</td>
</tr>
<tr class="even">
<td>Rolling Upgrade</td>
<td>滚动升级</td>
</tr>
<tr class="odd">
<td>round-robin</td>
<td>轮流（分配）；轮叫</td>
</tr>
<tr class="even">
<td>round-tripping</td>
<td>还原；回传；往返，往返切换</td>
</tr>
<tr class="odd">
<td>router</td>
<td>路由器</td>
</tr>
<tr class="even">
<td>row</td>
<td>行</td>
</tr>
<tr class="odd">
<td>RPC</td>
<td>远程过程调用（Remote Procedure Call）<sup>4</sup></td>
</tr>
<tr class="even">
<td>RRID</td>
<td>Resource Release Is Destruction，在构造时没有“获取”资源，但在析构时释放资源，一种 RAII 的特殊用法</td>
</tr>
</tbody>
</table>
<h2 id="s">S</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Saas</td>
<td>软件即服务（Software As A Service）</td>
</tr>
<tr class="even">
<td>Safe-to-Escape</td>
<td>安全逃逸</td>
</tr>
<tr class="odd">
<td>Safe-to-Escape scope</td>
<td>安全逃逸范围</td>
</tr>
<tr class="even">
<td>salted password hashing</td>
<td>加盐密码哈希<sup>4</sup></td>
</tr>
<tr class="odd">
<td>SAN</td>
<td>存储区域网络（Storage Area Network）<sup>4</sup></td>
</tr>
<tr class="even">
<td>SASL</td>
<td>简单认证与安全层</td>
</tr>
<tr class="odd">
<td>Scalability</td>
<td>缩放性</td>
</tr>
<tr class="even">
<td>Scalable Vector Graphic</td>
<td>可伸缩矢量图（SVG）</td>
</tr>
<tr class="odd">
<td>Scale</td>
<td>缩放</td>
</tr>
<tr class="even">
<td>Scale Out</td>
<td>向外缩放</td>
</tr>
<tr class="odd">
<td>Scale Up</td>
<td>向上缩放</td>
</tr>
<tr class="even">
<td>scaling pattern</td>
<td>扩展模式<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Schema (database)</td>
<td>架构（数据）</td>
</tr>
<tr class="even">
<td>Schema (xml)</td>
<td>架构（xml）</td>
</tr>
<tr class="odd">
<td>Scrum Master</td>
<td>Scrum 主管（SM）</td>
</tr>
<tr class="even">
<td>SDK</td>
<td>软件开发工具箱（Software Development Kits）</td>
</tr>
<tr class="odd">
<td>seam</td>
<td>接缝：程序中的一些特殊的点，可以让你无需做任何修改就能达到修改程序行为的目的。</td>
</tr>
<tr class="even">
<td>Search Engine</td>
<td>搜索引擎（SE）</td>
</tr>
<tr class="odd">
<td>Search Engine Marketing</td>
<td>搜索引擎营销（SEM）</td>
</tr>
<tr class="even">
<td>Search Engine Optimization</td>
<td>搜索引擎优化（SEO）</td>
</tr>
<tr class="odd">
<td>secondary storage</td>
<td>二级存储</td>
</tr>
<tr class="even">
<td>Secure Socket Layer</td>
<td>安全套接层（SSL）</td>
</tr>
<tr class="odd">
<td>Security</td>
<td>安全（性）</td>
</tr>
<tr class="even">
<td>Security Development Lifecycle</td>
<td>安全开发生命周期<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Security Socket Layer</td>
<td>安全套接层</td>
</tr>
<tr class="even">
<td>Security Token</td>
<td>安全令牌</td>
</tr>
<tr class="odd">
<td>Self Encapsulate Field</td>
<td>自封装字段<sup>1</sup></td>
</tr>
<tr class="even">
<td>self-hosted</td>
<td>自管理主机<sup>4</sup></td>
</tr>
<tr class="odd">
<td>Self-signed Certificate</td>
<td>自签名证书</td>
</tr>
<tr class="even">
<td>Semantic Kernel</td>
<td>语义核心 <sup>6</sup></td>
</tr>
<tr class="odd">
<td>semantic monitoring</td>
<td>语义监控<sup>4</sup></td>
</tr>
<tr class="even">
<td>Semantic Versioning</td>
<td>语义化版本控制</td>
</tr>
<tr class="odd">
<td>Separate Domain from Presentation</td>
<td>将领域和表述/显示分离<sup>1</sup></td>
</tr>
<tr class="even">
<td>Separate Query from Modifier</td>
<td>将查询函数和修改函数分离<sup>1</sup></td>
</tr>
<tr class="odd">
<td>Serializable</td>
<td>可序列化</td>
</tr>
<tr class="even">
<td>Server Affinity</td>
<td>服务器绑定</td>
</tr>
<tr class="odd">
<td>Server Driven Content Negotiation</td>
<td>服务器驱动的内容协商</td>
</tr>
<tr class="even">
<td>Server Side Render</td>
<td>服务器渲染（SSR）</td>
</tr>
<tr class="odd">
<td>Service Bus</td>
<td>服务总线</td>
</tr>
<tr class="even">
<td>Service Contract</td>
<td>服务合同</td>
</tr>
<tr class="odd">
<td>Service Level Agreement</td>
<td>服务水平协议（SLA）</td>
</tr>
<tr class="even">
<td>Service Provider</td>
<td>服务提供方</td>
</tr>
<tr class="odd">
<td>session jacking</td>
<td>会话劫持</td>
</tr>
<tr class="even">
<td>Setting</td>
<td>设置</td>
</tr>
<tr class="odd">
<td>Shared</td>
<td>共享；分享</td>
</tr>
<tr class="even">
<td>shared-memory data structure</td>
<td>共享内存数据结构</td>
</tr>
<tr class="odd">
<td>Short-circuit evaluation</td>
<td>短路求值</td>
</tr>
<tr class="even">
<td>Sign in</td>
<td>登录</td>
</tr>
<tr class="odd">
<td>Sign out</td>
<td>注销</td>
</tr>
<tr class="even">
<td>Signature</td>
<td>签名</td>
</tr>
<tr class="odd">
<td>Single Level of Abstraction Principle</td>
<td>单一抽象层次原则（SLAP）</td>
</tr>
<tr class="even">
<td>Single responsibility principle</td>
<td>单一职责原则（SRP）</td>
</tr>
<tr class="odd">
<td>Single Page Application</td>
<td>单页面应用（SPA）</td>
</tr>
<tr class="even">
<td>single point of failure</td>
<td>单一故障点（SPOF）</td>
</tr>
<tr class="odd">
<td>Singleton Pattern</td>
<td>单例模式</td>
</tr>
<tr class="even">
<td>Site</td>
<td>站点</td>
</tr>
<tr class="odd">
<td>Site-to-Site</td>
<td>站点到站点</td>
</tr>
<tr class="even">
<td>Skeleton-to-Thought</td>
<td>思维框架（SoT） <sup>6</sup></td>
</tr>
<tr class="odd">
<td>skip list</td>
<td>跳跃表</td>
</tr>
<tr class="even">
<td>SLA</td>
<td>服务水平协议、服务等级协议（Service Level Agreement）</td>
</tr>
<tr class="odd">
<td>Small</td>
<td>小型</td>
</tr>
<tr class="even">
<td>smart endpoint</td>
<td>智能端点<sup>4</sup></td>
</tr>
<tr class="odd">
<td>snapshot</td>
<td>快照</td>
</tr>
<tr class="even">
<td>SOA</td>
<td>面向服务的架构（Service-Oriented Architecture）</td>
</tr>
<tr class="odd">
<td>SoT</td>
<td>思维框架（Skeleton-to-Thought） <sup>6</sup></td>
</tr>
<tr class="even">
<td>Software as a Service</td>
<td>软件即服务（Saas）</td>
</tr>
<tr class="odd">
<td>source lines of code</td>
<td>源代码行数（SLOC）</td>
</tr>
<tr class="even">
<td>Speculative Hierarchy</td>
<td>凭空想象的层次结构<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Split Temporary Variable</td>
<td>分解临时变量<sup>1</sup></td>
</tr>
<tr class="even">
<td>sprint</td>
<td>冲刺（敏捷开发术语）</td>
</tr>
<tr class="odd">
<td>sprint backlog</td>
<td>冲刺积压工作</td>
</tr>
<tr class="even">
<td>SQL Database</td>
<td>SQL 数据库</td>
</tr>
<tr class="odd">
<td>SSKD</td>
<td>少量你所知道的开发人员（Small Set of Known Developers）</td>
</tr>
<tr class="even">
<td>SSO</td>
<td>单点登录（Single Sign-On）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>stage</td>
<td>阶段</td>
</tr>
<tr class="even">
<td>Staging</td>
<td>过渡（环境）</td>
</tr>
<tr class="odd">
<td>state indeterminism</td>
<td>状态不确定性</td>
</tr>
<tr class="even">
<td>State-based testing</td>
<td>基于状态的测试</td>
</tr>
<tr class="odd">
<td>State Pattern</td>
<td>状态模式</td>
</tr>
<tr class="even">
<td>Stateless</td>
<td>无状态</td>
</tr>
<tr class="odd">
<td>Sticky Session</td>
<td>黏性会话</td>
</tr>
<tr class="even">
<td>Stickyness</td>
<td>黏性；黏度</td>
</tr>
<tr class="odd">
<td>story</td>
<td>故事（敏捷开发术语）</td>
</tr>
<tr class="even">
<td>Storage</td>
<td>存储</td>
</tr>
<tr class="odd">
<td>Storage Account</td>
<td>存储账户</td>
</tr>
<tr class="even">
<td>Strangler Application Pattern</td>
<td>绞杀者模式<sup>4</sup></td>
</tr>
<tr class="odd">
<td>strategic development tools</td>
<td>战略设计工具 <sup>5</sup>，战略开发工具</td>
</tr>
<tr class="even">
<td>Strategy Pattern</td>
<td>策略模式</td>
</tr>
<tr class="odd">
<td>Stream</td>
<td>流</td>
</tr>
<tr class="even">
<td>Structural Design Patterns</td>
<td>结构性设计模式</td>
</tr>
<tr class="odd">
<td>structure</td>
<td>结构</td>
</tr>
<tr class="even">
<td>Structured Systems Analysis and Design Methodology</td>
<td>结构化系统分析和设计方法（SSADM）</td>
</tr>
<tr class="odd">
<td>Subnet</td>
<td>子网</td>
</tr>
<tr class="even">
<td>Subordinate</td>
<td>附属</td>
</tr>
<tr class="odd">
<td>Sub-region</td>
<td>子地域</td>
</tr>
<tr class="even">
<td>Subdomain</td>
<td>子领域</td>
</tr>
<tr class="odd">
<td>Subscription</td>
<td>订阅</td>
</tr>
<tr class="even">
<td>Substitute Algorithm</td>
<td>替换算法<sup>1</sup></td>
</tr>
<tr class="odd">
<td>SW</td>
<td>Apache SkyWalking 的简写</td>
</tr>
<tr class="even">
<td>symbol table</td>
<td>符号表</td>
</tr>
<tr class="odd">
<td>Synchronized Multimedia Integration Language</td>
<td>同步多媒体集成语言（SMIL）</td>
</tr>
<tr class="even">
<td>syntactic sugar</td>
<td>语法糖</td>
</tr>
<tr class="odd">
<td>System Under Test</td>
<td>测试目标系统（SUT）</td>
</tr>
</tbody>
</table>
<h2 id="t">T</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Table</td>
<td>表</td>
</tr>
<tr class="even">
<td>tactical development tools</td>
<td>战术实施工具 <sup>5</sup>，战术开发工具</td>
</tr>
<tr class="odd">
<td>TAP,</td>
<td>基于任务的异步模式</td>
</tr>
<tr class="even">
<td>targeted testing</td>
<td>目标测试</td>
</tr>
<tr class="odd">
<td>Task-based Asynchronous Pattern</td>
<td>基于任务的异步模式</td>
</tr>
<tr class="even">
<td>TCP</td>
<td>传输控制协议（Transmission Control Protocol）</td>
</tr>
<tr class="odd">
<td>TDD</td>
<td>测试驱动开发（Test-Driven Development）</td>
</tr>
<tr class="even">
<td>Tease Apart Inheritance</td>
<td>梳理并分解继承体系<sup>1</sup></td>
</tr>
<tr class="odd">
<td>technical bankruptcy</td>
<td>技术破产</td>
</tr>
<tr class="even">
<td>Technical Debt</td>
<td>技术债务（TDBT）</td>
</tr>
<tr class="odd">
<td>Template Method Pattern</td>
<td>模板方法模式</td>
</tr>
<tr class="even">
<td>Tenant</td>
<td>租户</td>
</tr>
<tr class="odd">
<td>Terminus</td>
<td>端点</td>
</tr>
<tr class="even">
<td>test doubles</td>
<td>测试替身</td>
</tr>
<tr class="odd">
<td>Test-Driven Development</td>
<td>测试驱动开发（TDD）</td>
</tr>
<tr class="even">
<td>test harness</td>
<td>测试用具</td>
</tr>
<tr class="odd">
<td>the normalization of deviance</td>
<td>异常正常化<sup>4</sup></td>
</tr>
<tr class="even">
<td>Thin Client</td>
<td>瘦客户端</td>
</tr>
<tr class="odd">
<td>Thread</td>
<td>线程</td>
</tr>
<tr class="even">
<td>Thread Environment Block</td>
<td>线程环境块</td>
</tr>
<tr class="odd">
<td>Thread Kernel Object</td>
<td>线程内核对象</td>
</tr>
<tr class="even">
<td>Thread Pool</td>
<td>线程池</td>
</tr>
<tr class="odd">
<td>Thread Starvation</td>
<td>线程饥荒</td>
</tr>
<tr class="even">
<td>Throttle</td>
<td>节流；限速</td>
</tr>
<tr class="odd">
<td>Timestamp</td>
<td>时间戳</td>
</tr>
<tr class="even">
<td>Throughput</td>
<td>吞吐量</td>
</tr>
<tr class="odd">
<td>TNP</td>
<td>交通网络提供者（Transportation Network Providers）</td>
</tr>
<tr class="even">
<td>TOFU</td>
<td>首次使用时信任（Trust On First Use）</td>
</tr>
<tr class="odd">
<td>Topic</td>
<td>主题</td>
</tr>
<tr class="even">
<td>Topology</td>
<td>拓扑结构</td>
</tr>
<tr class="odd">
<td>Token</td>
<td>令牌</td>
</tr>
<tr class="even">
<td>Top-level statements</td>
<td>顶级语句</td>
</tr>
<tr class="odd">
<td>ToT</td>
<td>思维树（Tree-of-Thought）</td>
</tr>
<tr class="even">
<td>TPL</td>
<td>任务并行库</td>
</tr>
<tr class="odd">
<td>(Code) Tracing</td>
<td>（代码）追踪</td>
</tr>
<tr class="even">
<td>Transaction</td>
<td>事务</td>
</tr>
<tr class="odd">
<td>Transaction Script</td>
<td>事务脚本</td>
</tr>
<tr class="even">
<td>Transient Error</td>
<td>瞬时错误</td>
</tr>
<tr class="odd">
<td>Transparent Data Encryption</td>
<td>透明数据加密<sup>4</sup></td>
</tr>
<tr class="even">
<td>Transportation Network Providers</td>
<td>交通网络提供者（TNP）</td>
</tr>
<tr class="odd">
<td>Tree-of-Thought</td>
<td>思维树（ToT） <sup>6</sup> 是一种通过将复杂问题分解为更易于解决的小问题，为 LLM 推理提供更结构化的提示框架</td>
</tr>
<tr class="even">
<td>Type Bloat</td>
<td>类型膨胀</td>
</tr>
</tbody>
</table>
<h2 id="u">U</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UAT</td>
<td>用户验收测试（User Acceptance Testing）<sup>4</sup></td>
</tr>
<tr class="even">
<td>Ubiquitous Computing</td>
<td>普存计算</td>
</tr>
<tr class="odd">
<td>Ubiquitous Language</td>
<td>统一语言</td>
</tr>
<tr class="even">
<td>UDDI</td>
<td>通用描述、发现与集成服务（Universal Description, Discovery, and Integration）</td>
</tr>
<tr class="odd">
<td>UI</td>
<td>用户界面，包括视觉设计、交互设计和用户体验（User Interface）</td>
</tr>
<tr class="even">
<td>Uncommitted</td>
<td>未提交（的）</td>
</tr>
<tr class="odd">
<td>Update Domain</td>
<td>更新域</td>
</tr>
<tr class="even">
<td>unbox</td>
<td>拆箱</td>
</tr>
<tr class="odd">
<td>under-post</td>
<td>提交不足</td>
</tr>
<tr class="even">
<td>undirected graph</td>
<td>无向图</td>
</tr>
<tr class="odd">
<td>Unexploited Encapsulation</td>
<td>未利用封装<sup>2</sup></td>
</tr>
<tr class="even">
<td>Unfactored Hierarchy</td>
<td>未归并的层次结构<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Unified Modeling Language</td>
<td>统一建模语言（UML）</td>
</tr>
<tr class="even">
<td>Uniform Interface</td>
<td>统一接口</td>
</tr>
<tr class="odd">
<td>Uniform Resource Locator</td>
<td>统一资源定位符（URL）</td>
</tr>
<tr class="even">
<td>unit of work</td>
<td>工作单元</td>
</tr>
<tr class="odd">
<td>Unit test</td>
<td>单元测试</td>
</tr>
<tr class="even">
<td>unit test coverage</td>
<td>单元测试覆盖率</td>
</tr>
<tr class="odd">
<td>unit-testing harnesses</td>
<td>单元测试用例</td>
</tr>
<tr class="even">
<td>unmanaged code</td>
<td>非托管代码</td>
</tr>
<tr class="odd">
<td>Unmanaged Pointers</td>
<td>非托管指针</td>
</tr>
<tr class="even">
<td>Unnecessary Abstract</td>
<td>不必要的抽象<sup>2</sup></td>
</tr>
<tr class="odd">
<td>Unnecessary Hierarchy</td>
<td>不必要的层次结构<sup>2</sup></td>
</tr>
<tr class="even">
<td>unnecessary overhead</td>
<td>不必要的开销</td>
</tr>
<tr class="odd">
<td>Unutilized Abstraction</td>
<td>未用的抽象<sup>2</sup></td>
</tr>
<tr class="even">
<td>Usability Review</td>
<td>可用性评估</td>
</tr>
<tr class="odd">
<td>User Acceptance Test</td>
<td>接受度测试（UAT）</td>
</tr>
<tr class="even">
<td>User Analysis</td>
<td>用户分析</td>
</tr>
<tr class="odd">
<td>User Datagram Protocol</td>
<td>用户数据报协议（UDP）</td>
</tr>
<tr class="even">
<td>User Interface</td>
<td>用户界面，包括视觉设计、交互设计和用户体验（UI）</td>
</tr>
<tr class="odd">
<td>User Mode Stack</td>
<td>用户模式栈</td>
</tr>
</tbody>
</table>
<h2 id="v">V</h2>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Value Object</td>
<td>值对象</td>
</tr>
<tr class="even">
<td>variant</td>
<td>变体</td>
</tr>
<tr class="odd">
<td>Variation Encapsulation Principle</td>
<td>变化封装原则（VEP）</td>
</tr>
<tr class="even">
<td>versionable interaction contract</td>
<td>可以进行版本控制的交互契约</td>
</tr>
<tr class="odd">
<td>Vertical Scale</td>
<td>垂直缩放</td>
</tr>
<tr class="even">
<td>VES</td>
<td>虚拟执行系统（Visual Execution System）</td>
</tr>
<tr class="odd">
<td>viscosity</td>
<td>粘滞性</td>
</tr>
<tr class="even">
<td>VIP</td>
<td>虚拟 IP（或不译）</td>
</tr>
<tr class="odd">
<td>VIP Swap</td>
<td>VIP 交换</td>
</tr>
<tr class="even">
<td>Virtual Execution System</td>
<td>虚拟执行系统（VES）</td>
</tr>
<tr class="odd">
<td>Virtual Network</td>
<td>虚拟网络</td>
</tr>
<tr class="even">
<td>Virtual Machine</td>
<td>虚拟机</td>
</tr>
<tr class="odd">
<td>Virtual Private Network</td>
<td>虚拟专用网络（VPN），在公用网络上建立专用网络，进行加密通讯，如网关通过对数据包的加密和数据包目标地址的转换实现远程访问</td>
</tr>
<tr class="even">
<td>Virtual Reality</td>
<td>虚拟现实（VR）</td>
</tr>
<tr class="odd">
<td>viscosity</td>
<td>粘稠性</td>
</tr>
<tr class="even">
<td>Visitor Pattern</td>
<td>访问者模式</td>
</tr>
<tr class="odd">
<td>VLO</td>
<td>团体批量许可证；大量采购授权合约（Volume Licensing for Organizations）</td>
</tr>
<tr class="even">
<td>VOL</td>
<td>团体批量许可证；大量采购授权合约（Volume Licensing for Organizations）</td>
</tr>
<tr class="odd">
<td>Volume Licensing for Organizations</td>
<td>团体批量许可证；大量采购授权合约（VOL 或 VLO）</td>
</tr>
<tr class="even">
<td>VPC</td>
<td>虚拟私有云（Virtual Private Cloud）<sup>4</sup></td>
</tr>
<tr class="odd">
<td>VPN</td>
<td>虚拟专用网络（Virtual Private Network）</td>
</tr>
</tbody>
</table>
<h2 id="w">W</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>WCF</td>
<td>Windows 通讯开发平台（Windows Comminication Foundation）</td>
</tr>
<tr class="even">
<td>Weak Generational Hypothesis</td>
<td>弱分代假设</td>
</tr>
<tr class="odd">
<td>Wearable Device</td>
<td>可穿戴设备</td>
</tr>
<tr class="even">
<td>Web Role</td>
<td>网站角色</td>
</tr>
<tr class="odd">
<td>Web Scraping</td>
<td>网络爬虫</td>
</tr>
<tr class="even">
<td>Web Service</td>
<td>网络服务</td>
</tr>
<tr class="odd">
<td>Web Service Definition Language</td>
<td>Web 服务定义语言（WSDL）</td>
</tr>
<tr class="even">
<td>Web Sites</td>
<td>网站</td>
</tr>
<tr class="odd">
<td>Weighted Method per Class</td>
<td>类累计圈复杂度（WMC）</td>
</tr>
<tr class="even">
<td>WF</td>
<td>工作流（WIndows Workflow）</td>
</tr>
<tr class="odd">
<td>Wide Hierarchy</td>
<td>过宽的层次结构<sup>2</sup></td>
</tr>
<tr class="even">
<td>Windows Comminication Foundation</td>
<td>分布式通信（WCF）</td>
</tr>
<tr class="odd">
<td>Windows Internet Name Service</td>
<td>Windows Internet 命名服务（WINS）</td>
</tr>
<tr class="even">
<td>Windows Management Instrumentation</td>
<td>Windows 管理规范（WMI）</td>
</tr>
<tr class="odd">
<td>Windows Presentation Foundation</td>
<td>富客户端表示（WPF）</td>
</tr>
<tr class="even">
<td>Windows Workflow</td>
<td>工作流（WF）</td>
</tr>
<tr class="odd">
<td>WINS</td>
<td>Windows Internet 命名服务（Windows Internet Name Service）</td>
</tr>
<tr class="even">
<td>WINS Proxy</td>
<td>WINS 代理</td>
</tr>
<tr class="odd">
<td>WINS Resource</td>
<td>WINS 资源</td>
</tr>
<tr class="even">
<td>wireless communication</td>
<td>无线通讯</td>
</tr>
<tr class="odd">
<td>WMI</td>
<td>Windows 管理规范（Windows Management Instrumentation）</td>
</tr>
<tr class="even">
<td>Worker Role</td>
<td>辅助角色</td>
</tr>
<tr class="odd">
<td>Workflow</td>
<td>工作流</td>
</tr>
<tr class="even">
<td>workgroup</td>
<td>工作组</td>
</tr>
<tr class="odd">
<td>World Wide Web Consortium</td>
<td>万维网联盟（W3C）</td>
</tr>
<tr class="even">
<td>WPF</td>
<td>富客户端表示（Windows Presentation Foundation）</td>
</tr>
<tr class="odd">
<td>writebehind</td>
<td>后写式</td>
</tr>
</tbody>
</table>
<h2 id="x">X</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X.509v3 certificate</td>
<td>X.509 证书</td>
</tr>
<tr class="even">
<td>XaaS</td>
<td>Everything as a Service，一切皆服务</td>
</tr>
<tr class="odd">
<td>XML</td>
<td>可扩展标记语言（Extensible Markup Language）</td>
</tr>
<tr class="even">
<td>XOR</td>
<td>异或（Exclusive OR）</td>
</tr>
<tr class="odd">
<td>XUL</td>
<td>XML 用户界面语言（XML User Interface Language）</td>
</tr>
</tbody>
</table>
<h2 id="y">Y</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>YAGNI</td>
<td>原则，不需要原则（You Aren't Gonna Need It），“你不会用到它<sup>3</sup>”</td>
</tr>
</tbody>
</table>
<h2 id="z">Z</h2>
<table>
<thead>
<tr class="header">
<th>Word</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Zero-downtime Upgrade</td>
<td>零停机升级</td>
</tr>
<tr class="even">
<td>zip disk</td>
<td>压缩磁盘</td>
</tr>
<tr class="odd">
<td>zone</td>
<td>区域</td>
</tr>
<tr class="even">
<td>zone list</td>
<td>区域列表</td>
</tr>
<tr class="odd">
<td>zone transfer</td>
<td>区域传送</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一些工具的使用备忘录</title>
    <url>/thinklive/24757/</url>
    <content><![CDATA[<h1 id="vim">vim</h1>
<p><img src="/assets/resources/vim_key.gif" /></p>
<span id="more"></span>
<p>vim的使用是个逐渐提升的过程，个人认为初学者，使用时间一个月以内的没必要折腾<br />
本人用了差不多一两年vscode vim后打算试试进行一些自定义</p>
<p><a href="https://github.com/VSCodeVim/Vim">Vim for Visual Studio Code 仓库</a><br />
<a href="https://github.com/easymotion/vim-easymotion#bidirectional-motions">vim-easymotion</a><br />
vscode vim的<code>.vimrc</code>支持有限，应该只支持按键重映射，但集成了不少插件，例如easymotion就比较有用</p>
<p>如最简单好用的跳转到当前光标前后的位置(w/b)<br />
快捷键<code>&lt;leader&gt;&lt;leader&gt;w</code>和<code>&lt;leader&gt;&lt;leader&gt;b</code><br />
如果要跳转行就把wb换成jk<br />
其中leader符号是vsc vim特有的调用插件功能前置键，默认为<code>\</code></p>
<p>对跳转这种功能来说，按三个键太麻烦，我们可以用vsc的按键重绑定功能<br />
对不常用的<code>cc</code>,<code>;</code>等键进行重绑定，这个重绑定既可以绑键位，也可以绑vsc的功能，例如下方就把cc绑定了vsc替换，详情可以看vsc vim的文档示例，顺便一提这个normalModeKeyBinding意思是绑定normal模式下的输入</p>
<p>编写<code>settings.json</code><br />
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vim.normalModeKeyBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;c&quot;</span><span class="punctuation">,</span><span class="string">&quot;c&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;editor.action.startFindReplaceAction&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>   <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;leader&gt;&quot;</span><span class="punctuation">,</span><span class="string">&quot;&lt;leader&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></p>
<p>常用功能改造:<br />
vim的<code>[[</code>,<code>]]</code>跳转到行首第一个<code>&#123;</code>,<code>&#125;</code>，巧的是本人不喜欢行首大括号，想要跳转任意一个大括号可以替换键位</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">&quot;vim.normalModeKeyBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;[&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;?&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;enter&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;]&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;enter&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="vscode-vim-中文标点连击问题">vscode vim 中文标点连击问题</h2>
<p>这是因为vscode的新功能<code>experimentalEditContextEnabled</code>被默认启用，类似vim这一机制试图在编辑中使用上下文信息，因此造成冲突，关掉即可</p>
<h1 id="windows">windows</h1>
<h2 id="vscode">vscode</h2>
<p>魔改快捷键:</p>
<ul>
<li><code>Ctrl + Alt + z</code>: 行内代码块(基于markdown shortcut插件)</li>
<li><code>Ctrl + Alt + q</code>: 粘贴为……</li>
</ul>
<h2 id="快捷键">快捷键</h2>
<p><a href="https://support.microsoft.com/zh-cn/windows/windows-%E7%9A%84%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F-dcc61a57-8ff0-cffe-9796-cb9706c75eec">微软官方文档</a></p>
<h3 id="文本">文本</h3>
<ul>
<li><code>Ctrl + Shift + V</code>: 粘贴为纯文本</li>
<li>powertoy
<ul>
<li><code>Windows 键 + Shift + V</code>: 自定义粘贴</li>
<li><code>Windows 键 + Ctrl + T</code>: 置顶窗口</li>
<li><code>Windows 键 + Ctrl + \</code> `: 工作区管理</li>
</ul></li>
</ul>
<h3 id="应用">应用</h3>
<ul>
<li><code>Alt + 向左键</code>:返回，向右同理</li>
<li><code>Ctrl + Shift + Esc</code>:打开任务管理器</li>
<li><code>Ctrl + Y</code>:重新执行之前使用 Ctrl + Z 撤消的操作</li>
<li><code>Ctrl + Shift + 选择任务栏上的应用图标</code>:以管理员身份打开应用</li>
<li><code>Alt + Tab</code>：切换窗口</li>
<li><code>Alt + F4</code>：关闭当前窗口</li>
<li><code>Ctrl + F4</code>:在可全屏显示且支持同时打开多个文档的应用中，关闭活动文档，但不关闭整个应用</li>
<li><code>F10</code>:激活活动窗口中的菜单栏</li>
</ul>
<h3 id="win键super键">win键(super键)</h3>
<ul>
<li><code>Windows 键 + I</code>: 设置</li>
<li><code>Windows 键 + Tab</code>: 任务视图</li>
<li><code>Windows 键 + shift + s</code>: 截图</li>
<li><code>Windows 键 + 方向键</code>: 调整当前窗口大小</li>
<li><code>Windows 键 + 数字键</code>: 打开第n个快捷栏应用</li>
<li><code>Windows 键 + shift + 数字键</code>: 打开第n个快捷栏应用的新实例</li>
<li><code>Windows 键 + D</code>：显示桌面或恢复窗口</li>
<li><code>Windows 键 + L</code>：锁定屏幕</li>
<li><code>Windows 键 + 空格</code>：切换输入法</li>
<li><code>Windows 键 + Ctrl + V</code>:声音设置</li>
<li><code>Windows 键 + M</code>:最小化所有窗口</li>
<li><code>Windows 键 + Shift + M</code>:还原最小化的窗口</li>
<li><code>Windows 键 + S\R</code>:打开搜索</li>
<li><code>Windows 键 + Tab</code>:任务视图</li>
<li><code>Windows 键 + Z</code>:打开对齐布局</li>
<li><code>Windows 键 + Ctrl + D</code>:创建另一个桌面。</li>
<li><code>Windows 键 + Ctrl + 左右方向键</code>:在桌面间移动</li>
<li><code>Windows 键 + Ctrl + F4</code>：关闭当前桌面</li>
</ul>
<h3 id="文件资源管理器浏览器">文件资源管理器/浏览器</h3>
<ul>
<li><code>Windows 键 + E</code>：打开文件资源管理器</li>
<li><code>F2</code>:重命名</li>
<li><code>F4</code>:地址栏</li>
<li><code>Alt + 方向键</code>:文件夹导航</li>
<li><code>Alt + Enter</code>：查看文件或文件夹属性</li>
<li><code>Alt + D</code>：快速选中地址栏</li>
<li><code>Ctrl + Shift + N</code>：新建文件夹</li>
<li><code>Ctrl + Shift + Tab</code>：切换到上一个标签页</li>
<li><code>Ctrl + T</code>：新建标签页</li>
<li><code>Ctrl + W</code>：关闭当前标签页</li>
<li><code>Ctrl + Tab</code>：切换到下一个标签页</li>
<li><code>Ctrl + E</code> 或 <code>F3</code>：激活搜索框</li>
<li><code>Ctrl + L</code>：快速选中地址栏</li>
<li><code>Ctrl + 数字 (1-9)</code>: 移动到该选项卡编号</li>
<li><code>Ctrl + 加号 (+)</code>:调整所有列的大小以适应文本</li>
<li><code>Ctrl + Click</code>：选中多个非连续的文件或文件夹。</li>
<li><code>Shift + Delete</code>: 永久删除</li>
<li><code>Shift + 鼠标右键单击</code>: 显示所选项的“显示更多选项”上下文菜单。</li>
<li><code>Shift + Click</code>：选择从第一个点击到最后一个点击之间的所有文件/文件夹。</li>
</ul>
<h3 id="浏览器快捷键与文件管理不通用部分">浏览器快捷键(与文件管理不通用部分)</h3>
<ul>
<li><code>Ctrl + D</code>：收藏当前页面</li>
</ul>
<h2 id="wsl">wsl</h2>
<p>更新wsl后，发现ps定位不到wsl，cmd却可以，查到这个网址<br />
<a href="https://superuser.com/questions/1501478/wsl-is-not-recognized-as-an-internal-or-external-command">wsl未被识别为内部或外部命令</a></p>
<p>Common problem when trying to access 64-bit tools from 32-bit processes. wsl.exe is in System32. But if your script happens to run as a 32-bit process, then all accesses to System32 are redirected to SysWOW64. In order to access wsl.exe in the "real" System32 folder, you'll have to use Sysnative instead, like in <code>C:\Windows\Sysnative\wsl.exe.</code><br />
尝试从 32 位进程访问 64 位工具时的常见问题。 wsl.exe是在 System32。 但是如果你的脚本碰巧作为 32 位进程运行，那么所有访问 System32被重定向到 SysWOW64。 为了访问 wsl.exe使用真正的 System32文件夹，你必须使用 Sysnative，就像 <code>C:\Windows\Sysnative\wsl.exe</code></p>
<p>也就是环境变量加一条，<code>C:\Windows\Sysnative</code></p>
<p><code>$ENV:PATH="$ENV:PATH;c:\Windows\System32"</code></p>
<h1 id="mysql">mysql</h1>
<p>为了javaweb装mysql,发现一个经典问题，安装卡在start server这一步上，查了一下stf,似乎是默认会把mysql注册成网络服务而不是本地，上面说改成本地服务再重启就行了，但我亲测无效<br />
彻底删除注册表和所有目录重装也无效<br />
于是我直接放弃了安装时注册成windows服务，打算之后再自己注册，这个倒是不难，用bin目录的mysqld就行了<br />
之后又发现不知道为什么输入注册时的密码错误，于是我重置了一下密码，这方面教程很多，比如<a href="https://www.jianshu.com/p/afe9ac17730d">这篇</a></p>
<p><strong>关于mysql提供的employees测试数据库</strong><br />
官方的安装指南是<code>mysql &lt; employees.sql</code>命令，但我发现powershell里没有<code>&lt;</code>运算符，于是看了一下时间，接近十年前了，所以得用cmd运行</p>
<h1 id="hexo">hexo</h1>
<h2 id="latex">latex</h2>
<p>写笔记时发现，有些latex公式块会被hexo的md渲染器禁止使用<code>line number probably different from source</code>，这时候似乎就只能禁用渲染，在文件头加上disableNunjucks: true<br />
这样一来的问题是，标签功能就无法使用了<br />
也可以用这样的标签括起来,但会麻烦一点<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">V=&#123;A_&#123;\mathrm&#123;s&#125;&#125;&#125;&#123;B_&#123;\mathrm&#123;s&#125;&#125;&#125;&#123;\overline&#123;&#123;S_&#123;\mathrm&#123;s&#125;&#125;&#125;&#125;&#125;+\overline&#123;&#123;A_&#123;\mathrm&#123;s&#125;&#125;B_&#123;\mathrm&#123;s&#125;&#125;&#125;&#125;S_&#123;\mathrm&#123;s&#125;&#125;</span><br><span class="line">$$  </span><br><span class="line"></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是什么原因呢？ hexo next有独有语法，将<code>&#123;&#123;`,`&#125;&#125;</code>视为关键字，因此还有一个办法是把每两个大括号之间加个空格</p>
<h2 id="hexo部署失败">hexo部署失败</h2>
<p>使用hexo的一键式部署，但今天突然报错： <code>Error: Fetching artifact metadata failed. Is githubstatus.com reporting issues with API requests, Pages, or Actions? Please re-run the deployment</code><br />
重试多次也依然能复现，起初我怀疑是版本跟不上了，但查了一下action版本号并不很早，而且一个小时前还是可以生效的<br />
红迪也没搜出什么来，于是回归新手村，打开<a href="https://hexo.io/docs/github-pages">hexo官方文档</a>试试手动部署<br />
检查一下workflow的action和该页面的yml一致，但有一点不同就是第四点<code>In your GitHub repo’s setting, navigate to Settings &gt; Pages &gt; Source. Change the source to GitHub Actions and save.</code><br />
这里我的设置是deploy from a branch,改成action再重启原来失败的workflow，又成功了<br />
下一个问题是为什么突然这样了？但实在摸不着头脑，因为hexo的官方推荐是一键部署，不需要自己改仓库设置。猜想是<code>hexo d</code>命令会启动一个脚本修改这个设置，action完再改回来？然后由于我一次<code>ctrl c</code>打断了这个应该是原子化的操作。<br />
由于一键式部署插件是from branch的，因此还得把这个设置改回来才能通过hexo命令部署，改回来后又可以直接成功部署了，无语</p>
<h1 id="gitbub">gitbub</h1>
<p>有时，防火墙完全拒绝允许 SSH 连接。 也就是用22端口连接github被拒绝，特点是此时用<code>ssh -T -p 443 git@ssh.github.com</code>连接成功，但默认端口无法连接<br />
如果能够通过 SSH 进入 git@ssh.github.com通过端口 443，可以覆盖 SSH 设置，以强制与 GitHub.com 的任何连接通过该服务器和端口运行。</p>
<p>要在 SSH 配置文件中进行设置，编辑该文件： ~/.ssh/config，并添加此部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    Hostname ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure>
<p>这样一来就可以用https和github连接</p>
<h1 id="cpp">cpp</h1>
<p><a href="https://stackoverflow.com/questions/32685540/why-cant-i-compile-an-unordered-map-with-a-pair-as-key">无法将Pair作为哈希表的元素</a></p>
<h1 id="clash">clash</h1>
<p><a href="https://www.clashverge.dev/faq/other.html?h=dns#_1">解决开着clash无法访问学校/公司内网问题</a><br />
一般来说这种网站不会有闲心检测你开没开clash，比如端口扫描，所以大概率问题在于使用内网dns服务器，而clash经手的流量使用阿里dns等公共dns解析，所以无法正确解析学校官网域名<br />
clash verge rev 贴心地给了全局拓展配置功能，因此只需要加入形如以下yaml配置(例如对苏州大学部分内部网站):<br />
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dns:</span></span><br><span class="line">    <span class="attr">nameserver-policy:</span></span><br><span class="line">        <span class="string">&#x27;+.suda.edu.cn&#x27;</span><span class="string">:</span> <span class="string">&#x27;10.9.0.110&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>左侧是域名，右侧是内部dns服务器，如果没被告知就连个内网打开powershell，输入:<br />
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure> 找到dns内行就是了，既然是内网，一般是10,172,196前缀</p>
<h1 id="leetcode">leetcode</h1>
<p>当你在力扣愉快地刷题(ctrl cv)时，是不是会恼火地发现剪切板上多了一些麻烦的后缀，如果想找到具体哪个js函数干的会很麻烦，更简单的思路是直接在剪切板删除这几行<br />
这里我们需要用到剪切板管理软件，当然不是windows自带的简陋剪切板，而是<a href="https://github.com/hluk/CopyQ/releases">copyq</a>这样的高度可自定义化的剪切板管理软件<br />
单就目前需求来说，每次剪切板变动就删去其最后4行即可，按f6打开命令界面，新建一个自动类型命令，粘贴以下js设置(删除的行数是硬编码的):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">copyq</span>:</span><br><span class="line"><span class="comment">// 定义要删除的最后 n 行</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 获取当前剪贴板内容</span></span><br><span class="line"><span class="keyword">var</span> clipboardText = <span class="title function_">str</span>(<span class="title function_">clipboard</span>());</span><br><span class="line"><span class="comment">// 按行分割剪贴板内容</span></span><br><span class="line"><span class="keyword">var</span> lines = clipboardText.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="comment">// 如果剪贴板的行数大于 n，删除最后 n 行</span></span><br><span class="line"><span class="keyword">if</span> (lines.<span class="property">length</span> &gt; n) &#123;</span><br><span class="line">    <span class="comment">// 删除最后 n 行，并将剩余内容重新组合为字符串</span></span><br><span class="line">    <span class="keyword">var</span> updatedText = lines.<span class="title function_">slice</span>(<span class="number">0</span>, -n).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="comment">// 更新剪贴板内容</span></span><br><span class="line">    <span class="title function_">copy</span>(updatedText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>好，大功告成，，了吗？并没有，这样一来力扣以外的粘贴也会被删掉末尾4行，总不能只有写力扣时才开启其他时候关闭吧<br />
我们需要加一个检测，例如被删掉的第一行行首等于“作者”时才删掉<br />
这么一来如果有一段文本不幸地倒数第四行开头是"作者"就会被删掉，不过我个人感觉不是那么常见，如果你是完美主义者可以试试用正则匹配一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">copyq</span>:</span><br><span class="line"><span class="comment">// 定义要删除的最后 n 行</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 获取当前剪贴板内容</span></span><br><span class="line"><span class="keyword">var</span> clipboardText = <span class="title function_">str</span>(<span class="title function_">clipboard</span>());</span><br><span class="line"><span class="comment">// 按行分割剪贴板内容</span></span><br><span class="line"><span class="keyword">var</span> lines = clipboardText.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lines.<span class="property">length</span> &gt; n) &#123;</span><br><span class="line">    <span class="keyword">var</span> firstLineToDelete = lines[lines.<span class="property">length</span> - n];</span><br><span class="line">    <span class="comment">// 检查第一行是否以某个str开头</span></span><br><span class="line">    <span class="keyword">if</span> (firstLineToDelete.<span class="title function_">startsWith</span>(<span class="string">&quot;作者&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 删除最后n行，并将剩余内容重新组合为字符串</span></span><br><span class="line">        <span class="keyword">var</span> updatedText = lines.<span class="title function_">slice</span>(<span class="number">0</span>, -n).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="title function_">copy</span>(updatedText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="neofetch">neofetch</h1>
<p>如果在windows上用scoop安装neofetch,会默认调用wsl的bash,显示wsl系统信息，因此需要更改<code>neofetch.cmd</code>文件，即将第二行改为 <code>@%scoop_path%\shims\bash.exe "%scoop_path%\apps\neofetch\current\neofetch"</code>这样的形式<br />
<code>%scoop_path%</code>表示scoop的根目录绝对路径</p>
<h1 id="fastfetch">fastfetch</h1>
<p>在处理完上述问题后，发现用powershell调用neofetch有口口口问题，而且识别不出windows操作系统版本，怎么办呢？答案是换成fastfetch<br />
<code>scoop install fastfetch</code><br />
fastfetch默认用的是新版windows平面风格logo,也就是四个方块，个人来说真不喜欢这个毫无特点的logo，怎么换成neofetch那个经典四色logo呢，只需要创建一个txt文件，把下列内容复制粘贴进去，然后以形如<code>fastfetch -l "%logopath%" --logo-color-1 red --logo-color-2 green --logo-color-3 blue --logo-color-4 yellow</code>的形式调用fastfetch就行了，"%logopath%"是刚刚保存的txt文件绝对路径，看上去很长，但有新版psh自带的自动补全很方便就能调用</p>
<p>如果不想要颜色的话，用vsc之类编辑器的替换功能把<code>$N</code>(N是数字)删掉即可，想要单色就删完<code>$N</code>后在文件开头放个$1,然后<code>--logo-color-1</code>后跟想要的颜色就行了<br />
顺便一提如果看到以下图标很窄，说明你现在在使用非等宽字体，在终端环境常用的等宽字体下，这些logo都是正常宽度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                         $2 ....iilll</span><br><span class="line">                $2....iilllllllllllll</span><br><span class="line">    $1....iillll  $2lllllllllllllllllll</span><br><span class="line">$1iillllllllllll  $2lllllllllllllllllll</span><br><span class="line">$1llllllllllllll  $2lllllllllllllllllll</span><br><span class="line">$1llllllllllllll  $2lllllllllllllllllll</span><br><span class="line">$1llllllllllllll  $2lllllllllllllllllll</span><br><span class="line">$1llllllllllllll  $2lllllllllllllllllll</span><br><span class="line">$1llllllllllllll  $2lllllllllllllllllll</span><br><span class="line"></span><br><span class="line">$3llllllllllllll  $4lllllllllllllllllll</span><br><span class="line">$3llllllllllllll  $4lllllllllllllllllll</span><br><span class="line">$3llllllllllllll  $4lllllllllllllllllll</span><br><span class="line">$3llllllllllllll  $4lllllllllllllllllll</span><br><span class="line">$3llllllllllllll  $4lllllllllllllllllll</span><br><span class="line">$3`^^^^^^lllllll  $4lllllllllllllllllll</span><br><span class="line">     $3 ````^^^^  $4^^lllllllllllllllll</span><br><span class="line">                     $4````^^^^^^llll</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>顺便一提新版logo长这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line"></span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line">/////////////////  /////////////////</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="firefox">firefox</h1>
<p>FireFox 书签打开新网址时，想要打开一个新的标签(tab)，而不是覆盖掉原来网页:</p>
<ol type="1">
<li>地址栏中输入 about:config</li>
</ol>
<ol start="15" type="a">
<li>搜索 browser.tabs.loadBookmarksInTabs ，会发现值为 false ，改为 true 就可以了</li>
</ol>
<h1 id="azure">azure</h1>
<p>早上起来收到了一封微软发来的邮件<br />
<img src="/assets/resoures/94f235e29ba5038582214c88c46f26ea.png" /> 顿时心中警铃大作，是诈骗邮件吗<br />
如果是诈骗邮件，这封也很奇怪，它只要求购买某个服务来维持账号，却没有给购买链接，且两个链接经f12检查都是微软和azure官网，如果这是真的，那么我在2019年注册了azure账号？还有这个 Entra ID 又是什么东西<br />
在我搜索之后，红迪也有人发帖说收到类似邮件，顺着发帖者经验我找到了azure官网中的entra服务，这是一种针对企业的身份认证服务，用于给不同权限的员工颁发不同的凭证，不知道为什么我有个免费版的entra身份，经检查和邮件中的id是一致的<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Microsoft Entra ID Free. Provides user and group management, on-premises directory synchronization, basic</span><br><span class="line">reports, self-service password change for cloud users, and single sign-on across Azure, Microsoft 365, and many</span><br><span class="line">popular SaaS apps.</span><br></pre></td></tr></table></figure> 再说azure的账号id，我绝对没有给azure付过费，首先我完全不需要它的服务，其次我也没有支付手段，那这个account是哪来的呢？跟着微软的文档我试着点开订阅管理之类的菜单，没有任何账单、订阅或者服务，也没有id<br />
到现在为止，应该可以说这确实可能是官方邮件，因为它知道只有微软才知道的entra id，且没有诱导付费行为，但还有个未解之谜是2019年我为什么会注册个azure账号，当时copilot还不火，我也不写代码，难道注册微软账号时会捆绑注册一个？<br />
再说200天前，为什么是这个时间节点，难道我在2019年注册后还活跃过？ 这或许会是永远的未解之谜</p>
]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title>复试冲刺20天</title>
    <url>/thinklive/23981/</url>
    <content><![CDATA[<h1 id="专业课">专业课</h1>
<h2 id="网络">网络</h2>
<p>USP是一个智能化的网络数据库统一检索平台。它通过一个统一界面帮助用户在多个网络数据库搜索平台中实现信息检索操作，是对外网络中的多种检索工具的智能化整合<br />
NAT即网络地址转换（Network Address Translation），是一种将IP数据包中的IP地址转换为另一个IP地址的技术</p>
<ol type="1">
<li>静态NAT
<ul>
<li>功能：实现内部IP与公网IP的一对一固定映射，常用于需要公网访问的服务器（如Web服务器），确保外部可通过固定公网IP访问内部设备</li>
</ul></li>
<li>动态NAT
<ul>
<li>功能：从定义的公网IP地址池中动态分配IP，内部设备随机获取公网IP，用完后释放，适用用户数不固定的场景</li>
</ul></li>
<li>端口地址转换(PAT/NAPT(Network Address Port Translation，网络地址端口转换))
<ul>
<li>功能：多个内部IP共享一个公网IP，通过端口号区分不同连接，极大节省IP地址，是家庭、企业最常用的NAT方式</li>
</ul></li>
</ol>
<span id="more"></span>
<h2 id="ds">DS</h2>
<p>广义表的长度是指广义表第一层元素的个数，不包括递归子表内部的元素个数</p>
<ol type="1">
<li>普通表：如(ab,c)，长度为3</li>
<li>嵌套表：如(a,(b),d)，长度为3</li>
</ol>
<p>广义表的深度是指广义表的最大嵌套层数</p>
<ol type="1">
<li>空表：深度为1</li>
<li>普通表：如(a,b,c)，深度为1</li>
<li>嵌套表：如(a,(b,c),d)，深度为2，因为(b,) 是第一层中的子表，深度为1，整体深度为2</li>
</ol>
<h2 id="软工">软工</h2>
<p>问题定义-&gt;可行性分析-&gt;需求分析-&gt;设计-&gt;开发阶段-&gt;测试-&gt;运行与维护<br />
主要的软件开发方法:</p>
<ol type="1">
<li>结构化方法：面向数据流，自顶向下逐层分解，进行结构化分析、结构化设计、结构化程序设计。适用数据处理领域，不适用大且复杂、需求一直变化的场景</li>
<li>jackson方法：面向数据结构，通过问题的输入输出数据结构来分析，推出相应程序结构。适用小规模</li>
</ol>
<p>软件测试与开发模型:</p>
<ol type="1">
<li>软件测试的目的：验证软件是否符合需求，发现缺陷，确保质量,验证功能，避免风险</li>
<li>软件测试的类型：单元测试（模块级）、集成测试（模块间交互）、系统测试（整体功能）、验收测试（分为Alpha测试和Beta测试）</li>
<li>软件测试的方法：白盒测试（代码逻辑）、黑盒测试（功能验证）、自动化测试（工具辅助）</li>
<li>模型：
<ol type="1">
<li>瀑布模型：线性流程（需求-设计-开发-测试-部署），适合需求明确的项目</li>
<li>演化模型：初始的原型逐步演化成最终软件产品的过程，演化模型适用于对软件需求缺之准确认识的情况。典型的演化模型有：增量模型、原型型、旋模型</li>
<li>增量模型：从一组给定的需求开始，一次构造一段增量，逐步完善待开发的系统。增量模型强调每一个增量都发布一个可运行的产品，可较快产生能操作的系统</li>
<li>敏捷模型：迭代开发，快速交付，适应需求变化（如Scrum、看板）</li>
<li>螺旋模型：是瀑布模型和演化模型的结合，增加了风险分析，客户参与开发，适合大型复杂项目</li>
<li>原型模型：先构建原型供用户反馈，收集用户的反馈意见，再优化开发</li>
<li>喷泉模型：支持面向对象开发的过程模型。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的。迭代是指软件的某个部分常常被重复工作多次，相关功能在每次迭代中随之加入渐进的软件成分。无间隙指在各项活动之间无明显边界，如分析和设计活动之间没有明显的界限</li>
</ol></li>
</ol>
<p>软件维护主要分为以下四种类型:</p>
<ol type="1">
<li><strong>修正性维护（Corrective Maintenance）</strong>:
<ul>
<li>概念:针对发现的软件错误或缺陷进行修复和更正的维护活动</li>
<li>目的:消除软件中存在的错误,提高软件的可靠性和正确性</li>
</ul></li>
<li><strong>适应性维护（Adaptive Maintenance）</strong>:
<ul>
<li>概念:对软件进行修改和调整,使其能够适应硬件环境、操作系统或其他外部条件的变化</li>
<li>目的:确保软件能够持续运行并满足用户的需求</li>
</ul></li>
<li><strong>完善性维护（Perfective Maintenance）</strong>:
<ul>
<li>概念:在不改变软件原有功能的情况下,对软件进行优化和改进,以提高其性能和可用性</li>
<li>目的:提升软件的质量,增强用户体验</li>
</ul></li>
<li><strong>预防性维护（Preventive Maintenance）</strong>:
<ul>
<li>概念:对软件进行系统性的分析和检查,以检测和预防潜在的问题</li>
<li>目的:降低软件故障发生的概率,延长软件的使用寿命</li>
</ul></li>
</ol>
<p>白盒测试，也称为结构化测试、基于代码的测试，是一种测试用例设计方法，它从程序的控制结构导出测试用例。用白盒测试产生的测试用例能够</p>
<ol type="1">
<li>保证一个模块中的所有独立路径至少被使用一次</li>
<li>对所有逻辑值均需测试true和false</li>
<li>在上下边界及可操作范围内运行所有循环</li>
<li>检查内部数据结构以确保其有效性</li>
</ol>
<p>黑盒测试也称功能测试，通过测试来检测每个功能是否都能正常使用。在完全不考虑程序内部结构和内部特性的情况下，对程序接口进行测试，以用户的角度，从输入数据与输出数据的对应关系出发进行测试</p>
<p>提高软件质量:</p>
<ol type="1">
<li>复审：是在软件生命周期每个阶段结束之前都采用一定的标准对该段产生的软件进行检测</li>
<li>复查：是检查已有的材料，以断定在软件生命周期某个阶段的工作是否能够开始或继续</li>
<li>管理复审：是向管理人员提供有关项目的总体状况、成本和进度等方面的情况，以便管理</li>
</ol>
<p>软件形式化：在严格数学基础上的软件开发方法，基于数学的方法来描述软件属性的技术<br />
三要素: 方法，工具，过程</p>
<h2 id="数据库">数据库</h2>
<p>候选码：可以唯一标识一个元组的最少的属性集合<br />
主键：一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性,主键是候选键的子集<br />
超键（Super Key） 是一个或多个属性的集合，这个集合可以唯一标识关系表中的每一行记录,候选键是一个最小的超键</p>
<p>存储过程是一组为了完成特定功能的语句集合，经编译后存储在数据库中。它可接收输入参数、输出参数，也可包含逻辑控制语句和数据操作语句等。用户通过调用存储过程来执行这些预定义的操作，可实现代码复用，提高数据库操作的效率和安全性，减少网络传输量<br />
触发器是一种特殊的存储过程，它在特定的数据库事件（如INSERT、UPDATE、DELETE操作）发生时自动执行。触发器可用于实现数据的完整性约束、数据审计、日志记录等功能，能在数据发生变化时自动进行一些额外的操作或检查，确保数据库中的数据符合特定的业务规则和要求</p>
<p>数据库中的死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种互相等待的现象</p>
<p>外接是指两个表在进行操作时，不仅返回符合连接和查询条件的元组，还返回不符合条件的一些元组；<br />
左外连接是指返回左表中仅符合连接条件不符合查询条件的元组：<br />
右外连接是指返回右表中仅符合连接条件不符合查询条件的元组：<br />
全外连接是左外连接和右外连接去掉重复项的元组集并集</p>
<p>索引是存储在数据库中的一个物理结构，是实际存在的，相当于一本书的目录，常用B+树实现<br />
键是一个逻辑概念，不是数据库中的物理部分</p>
<p>视图是从一个或几个基本表中导出的表，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据。基本表中的数据发生变化时，从视图中查询出来的数据也就随之发生变化<br />
作用：</p>
<ul>
<li>能够简化用户的操作</li>
<li>使用户能以多种角度看待同一数据</li>
<li>在一定程度上提供了数据的逻辑独立性</li>
<li>能够对秘密数据提供安全保护</li>
</ul>
<p>游标：将查询出来的结果集作为一个单元来进行处理，适用于逐行处理数据</p>
<p>安全性技术：用户标识和鉴别、多层存取控制、审计、视图、数据加密<br />
存取控制是指确保只授权给有资格的用户访问数据库的权限，且令所有未被授权的人员无法接近数据<br />
两个部分：定义用户权限和合法权限检查；两种方法：</p>
<ol type="1">
<li><strong>自主存取控制（DAC）</strong>：用户对不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限<br />
</li>
<li><strong>强制存取控制（MAC）</strong>：每一个数据库对象被标以一定的密级，每一个用户也被授予一定级别的许可证，只有具有合法许可证的用户才可以进行存取</li>
</ol>
<p><strong>断言</strong>是指更具有一般性的约束，断言创建后，任何涉及到断言中的关系的操作会引发数据库对断言的检查，任何使断言为假的操作都会被拒绝执行</p>
<p>悲观锁:总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现<br />
乐观锁:总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型， 这样可以提高吞吐量 ，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(compare and swap)实现的<br />
ABA 问题:如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题</p>
<p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存</p>
<p><strong>DBA(Database Administrator)</strong></p>
<p>三级模式结构是描述数据库系统中数据抽象层次的概念模型,它包括:</p>
<ul>
<li>外模式（External Model）
<ul>
<li>也称为用户视图或应用程序视图</li>
<li>描述数据库中针对特定用户或应用程序的数据视图</li>
<li>用户只能看到和操作外模式所定义的数据子集</li>
</ul></li>
<li>概念模式（Conceptual Model）
<ul>
<li>也称为逻辑模型或数据库模型</li>
<li>描述数据库中全部数据的逻辑结构和特性</li>
<li>这是数据库的整体数据模型,独立于任何硬件或软件实现</li>
</ul></li>
<li>内模式（Internal Model）
<ul>
<li>也称为存储模型或物理模型</li>
<li>描述数据在计算机内部如何存储和组织的细节</li>
<li>包括数据存储结构、存储介质、存取路径等物理存储细节</li>
</ul></li>
</ul>
<p>三级模式结构提供了以下优点:</p>
<ol type="1">
<li>数据独立性:
<ul>
<li>外模式独立于概念模式,概念模式独立于内模式</li>
<li>可以在不影响上层的情况下修改底层模式</li>
</ul></li>
<li>灵活性和可扩展性:
<ul>
<li>用户可根据需求定制外模式</li>
<li>数据库可根据应用需求进行修改和扩展</li>
</ul></li>
<li>安全性和隐私性:
<ul>
<li>通过外模式控制用户对数据的访问权限</li>
<li>内模式的物理存储细节对用户是隐藏的</li>
</ul></li>
</ol>
<p>完整性约束:</p>
<ul>
<li>实体完整性：关系模式中的主码不能为空值</li>
<li>参照完整性：关系模式中的外码只能是空值或者另一关系模式的主码</li>
<li>用户定义完整性：关系模式中针对某一属性的约束</li>
</ul>
<p>SQL（Structured Query Language）是一种专门用于管理和操作关系型数据库的标准化查询语言。它主要包括以下几个方面:</p>
<ol type="1">
<li>数据定义语言（DDL）:
<ul>
<li>用于创建、修改和删除数据库对象,如数据库、表、视图等</li>
<li>常用命令包括 CREATE、ALTER、DROP 等</li>
</ul></li>
<li>数据操作语言（DML）:
<ul>
<li>用于对数据库中的数据进行增删改查等操作</li>
<li>常用命令包括 SELECT、INSERT、UPDATE、DELETE 等</li>
</ul></li>
<li>数据控制语言（DCL）:
<ul>
<li>用于管理数据库的访问权限和安全策略</li>
<li>常用命令包括 GRANT、REVOKE 等</li>
</ul></li>
<li>事务控制语言（TCL）:
<ul>
<li>用于管理数据库事务,确保数据的完整性和一致性</li>
<li>常用命令包括 COMMIT、ROLLBACK 等</li>
</ul></li>
</ol>
<p>自然连接是等值连接的一种特殊情况：<br />
等值连接要求连接的是值相等的分量，两个关系中可以没有相同的属性；进行自然连接的两个关系中必须有相同的属性<br />
等值连接不要求去掉重复属性列；自然连接时需要除掉重复的属性列<br />
左/右外连接是在两表进行自然连接，只把左/右表要舍弃的保留在结果集中<br />
全外连接是在两表进行自然连接，只把左表和右表要舍弃的都保留在结果集中，相对应的列上填null</p>
<p>ACID特性包括：</p>
<ul>
<li>隔离性：一个事务的执行不能被其他事务所于扰</li>
<li>原子性：事务是一个不可分割的单位，要么全做，要么全不做</li>
<li>一致性：事务执行的结果必须使数据库从一个一致性状态变到另一个一致性状态</li>
<li>永久性：一旦事务被提交，它对数据库的改变就是永久的</li>
</ul>
<p>日志文件、后备副本可用于数据库恢复</p>
<p>排他锁（写锁）：当数据被加上写锁，其他事务不能对该数据进行读和写<br />
共享锁（S读锁）：当数据被加上读锁，允许其他事务对该数据进行读，不允许写</p>
<p>封锁协议:</p>
<ol type="1">
<li>一级封锁协议：事务在修改数据之前加写锁，真到事务结束才释放。该协议可以防止丢失修改<br />
</li>
<li>二级封锁协议：在一级封锁协议的基础上，加上了事务在读取数据之前对其加读锁，读完后即可释放读锁。该协议避免了读脏数据<br />
</li>
<li>三级封锁协议：在一级封锁协议的基础上，加上了事务在读取数据之前必须加上读锁，直到事务结束才释放。该协议解决了不可重复读问题</li>
</ol>
<p>范式(normal form):</p>
<p>第一范式要求数据库表中的每一列都是不可分割的原子值，即表中的每个字段都只能存储单一值，不能包含集合、数组或多值字段<br />
第二范式要求数据库表满足第一范式，并且表中的每个非主属性（不属于候选键的属性）必须完全依赖于主键，不能存在<strong>部分依赖</strong>(非主属性依赖于主键的一部分，而不是整个主键)<br />
第三范式要求数据库表满足第二范式，并且表中的每个非主属性必须直接依赖于主键，不能存在<strong>传递依赖</strong>(非主属性依赖于另一个非主属性，而另一个非主属性依赖于主键)<br />
BC范式要求数据库表满足第二范式，并且所有属性（包括主属性）都必须依赖于候选键，任何属性都不能依赖于非候选键，即表中每个非平凡函数依赖(X-&gt;Y，但Y不是X的子集) X → Y 中，X 必须是超键</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>函数依赖</td>
<td>一个属性的值唯一确定另一个属性的值</td>
</tr>
<tr class="even">
<td>部分依赖</td>
<td>非主属性依赖于主键的一部分</td>
</tr>
<tr class="odd">
<td>全依赖</td>
<td>非主属性依赖于主键的全部字段</td>
</tr>
<tr class="even">
<td>传递依赖</td>
<td>非主属性通过另一个非主属性间接依赖于主键</td>
</tr>
<tr class="odd">
<td>多值依赖</td>
<td>一个属性的值确定多个属性的值，但这些属性彼此独立</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>由1NF到2NF，消除了非主属性对主属性的部分函数依赖</li>
<li>由2NF到3NF，消除了非主属性对主属性的传递函数依赖</li>
<li>由3NF到BCNF，消除了主属性对码的部分函数依赖和传递函数依赖</li>
</ol>
<p>常见的启发式优化规则包括:</p>
<ol type="1">
<li>选择性规则:
<ul>
<li>优先选择选择性高的索引或条件,即缩小数据范围的索引或条件</li>
<li>这样可以尽早对数据进行过滤,减少后续处理的数据量</li>
</ul></li>
<li>顺序规则:
<ul>
<li>优先执行成本较低的操作,如索引扫描等</li>
<li>将成本较高的操作,如全表扫描、排序等放在最后执行</li>
</ul></li>
<li>嵌套规则:
<ul>
<li>优先处理内层的子查询或表达式</li>
<li>将外层的操作放在最后执行</li>
</ul></li>
<li>分区规则:
<ul>
<li>优先利用分区表的分区信息进行数据过滤</li>
<li>尽可能缩小扫描的分区范围</li>
</ul></li>
<li>物化视图规则:
<ul>
<li>优先利用已经物化的视图进行查询</li>
<li>可以避免重复计算</li>
</ul></li>
</ol>
<p>同步问题:</p>
<ul>
<li>当前读：像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</li>
<li>快照读：像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</li>
</ul>
<p>MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现<br />
导致 MySQL 索引失效的常见场景：</p>
<ol type="1">
<li>联合索引不满足最左匹配原则</li>
<li>模糊查询最前面的为不确定匹配字符</li>
<li>索引列参与了运算</li>
<li>索引列使用了函数</li>
<li>索引列存在类型转换</li>
<li>索引列使用 is not null 查询</li>
</ol>
<h2 id="os">OS</h2>
<p>操作系统的特征：并发性、共享性、异步性、虚拟性:</p>
<ol type="1">
<li>并发和共享互为存在的条件</li>
<li>虚拟以并发和资源共享为前提：为使并发进程能更方便、更有效地共享资源,操作系统常采用多种虚技未来在逻辑上增加CPU和设备的数量以及存储器的容量，从而解决众多并发进程对有限的系统资源的争用问题</li>
<li>异步性是并发和共享的必然结果</li>
</ol>
<h2 id="ai">ai</h2>
<p>云计算(Cloud Computing)是一种基于互联网的计算模式,它通过网络提供按需获取和使用计算资源的服务。云计算主要包括以下特点:</p>
<ol type="1">
<li>资源共享:
<ul>
<li>云计算将硬件、软件等IT资源集中管理和运营,用户可以按需使用</li>
<li>资源按需分配,提高了资源利用率</li>
</ul></li>
<li>按需服务:
<ul>
<li>用户可以根据实际需求灵活调配和使用云计算资源</li>
<li>按需付费,用多少付多少</li>
</ul></li>
<li>高可用性:
<ul>
<li>云计算平台具有高可靠性和容错性,能确保服务的可用性</li>
<li>能够应对硬件故障、网络中断等情况</li>
</ul></li>
<li>规模弹性:
<ul>
<li>云计算能根据用户需求自动扩展或收缩资源</li>
<li>用户可根据业务需求随时调整资源使用量</li>
</ul></li>
<li>虚拟化:
<ul>
<li>云计算基于虚拟化技术,可将物理硬件抽象为可编程的虚拟资源</li>
<li>提高了资源利用率和管理效率</li>
</ul></li>
</ol>
<p>主要服务模式包括:</p>
<ul>
<li>IaaS(基础设施即服务)</li>
<li>PaaS(平台即服务)</li>
<li>SaaS(软件即服务)</li>
</ul>
<p>区块链(Blockchain)是一种基于分布式账本技术的数字记录系统,具有以下主要特点:</p>
<ol type="1">
<li>分布式账本
<ul>
<li>区块链是一种去中心化的分布式账本,没有单一的中心控制节点</li>
<li>账本信息存储在全网各节点的数据库中,形成分布式的数据存储</li>
</ul></li>
<li>链式数据结构
<ul>
<li>账本信息以时间顺序组织成一个个数据块(区块),并以加密方式链接在一起</li>
<li>每个新区块都包含前一个区块的信息,形成一个不可篡改的链式结构</li>
</ul></li>
<li>加密安全性
<ul>
<li>区块链使用密码学技术(如哈希、数字签名)确保数据的安全性和完整性</li>
<li>一旦记录进入区块链,就难以被删除或篡改</li>
</ul></li>
<li>点对点传输
<ul>
<li>区块链网络采用点对点的通信模式,交易信息在网络中直接传播</li>
<li>不需要中心化的第三方中介机构参与</li>
</ul></li>
<li>共识机制
<ul>
<li>区块链节点通过共识算法(如工作量证明、权益证明等)达成对交易记录的共识</li>
<li>确保整个网络的数据一致性和可靠性</li>
</ul></li>
</ol>
<p>区块链的主要应用包括:</p>
<ul>
<li>加密货币(比特币、以太坊等)</li>
<li>供应链管理</li>
<li>数字资产交易</li>
<li>身份认证</li>
<li>智能合约</li>
</ul>
<p>ai专业名词:</p>
<ul>
<li>损失函数：用于衡量模型预测结果与真实标签之间的差异，如均方误差、交叉熵等，训练的目标是最小化损失函数</li>
<li>优化算法：用于更新模型参数以最小化损失函数的方法，如随机梯度下降及其变种Adagrad、 Adadelta、Adam等</li>
<li>准确率：分类任务中，预测正确的样本数占总样本数的比例</li>
<li>召回率：在分类任务中，真实为正例的样本中被正确预测为正例的比例</li>
<li>F1值：综合考虑准确率和召回率的评估指标，是二者的调和平均数</li>
<li>超参数：在模型训练前需要手动设置的参数，如学习率、迭代次数、神经网络的层数、隐藏层节点数等，它们影响模型的训练过程和最终性能，通常需要通过调参来确定最优值</li>
</ul>
<p>分类(Classification)和聚类(Clustering)区别:</p>
<ol type="1">
<li>监督学习 vs 无监督学习:
<ul>
<li>分类是一种监督学习任务,需要有预先标记的训练数据</li>
<li>聚类是一种无监督学习任务,不需要预先标记的训练数据</li>
</ul></li>
<li>目标不同:
<ul>
<li>分类的目标是将新的数据样本分类到预定义的类别中</li>
<li>聚类的目标是发现数据中自然存在的分组(簇)</li>
</ul></li>
<li>输出形式不同:
<ul>
<li>分类输出的是预定义的类别标签</li>
<li>聚类输出的是数据被划分到的不同簇</li>
</ul></li>
<li>应用场景不同:
<ul>
<li>分类常用于预测任务,如垃圾邮件识别、信用评级等</li>
<li>聚类常用于探索性数据分析,如客户细分、异常检测等</li>
</ul></li>
</ol>
<p>评估:</p>
<ul>
<li>分类任务：准确率（Accuracy）、精确率</li>
<li>(Precision）、召回率（Recall）、F1Score。回归任务：均方误差（MSE）、平均绝对误差(MAE)</li>
<li>泛化能力验证：交叉验证（Cross+ Validation)</li>
</ul>
<p>过拟合（Overfitting）<br />
表现：模型在训练集表现好，测试集差<br />
解决：增加数据量、正则化、减少模型复杂度、早停法（EarlyStopping）<br />
欠拟合（Underfitting）<br />
表现：模型在训练集和测试集均表现差<br />
解决：增加模型复杂度、添加更多特征、减少正则化</p>
<h1 id="科研">科研</h1>
<h2 id="knowledge">knowledge</h2>
<h3 id="梯度">梯度</h3>
<p>梯度的定义和性质如下:<br />
定义: 设 f(x1, x2, ..., xn) 是一个多变量函数, 梯度是一个 n 维列向量:∇f = [∂f/∂x1, ∂f/∂x2, ..., ∂f/∂xn]^T<br />
其中 ∂f/∂xi 表示 f 对 xi 的偏导数<br />
几何意义:</p>
<ul>
<li>梯度指向函数值增长最快的方向</li>
<li>梯度的方向就是函数值增长最快的方向, 梯度的模长就是函数值增长最快的速率</li>
</ul>
<p>性质:</p>
<ul>
<li>梯度为 0 的点是函数的临界点, 可能是极大值、极小值或鞍点</li>
<li>沿着梯度方向移动, 函数值会单调增加</li>
<li>梯度下降法利用这一性质, 通过不断沿负梯度方向移动来求解优化问题的最小值</li>
</ul>
<p>应用:</p>
<ul>
<li>在机器学习中, 梯度被用于训练各种模型, 如线性回归、神经网络等</li>
<li>在优化算法中, 如 Interior-Point 算法中的牛顿法, 梯度被用于计算搜索方向</li>
<li>在数值分析中, 梯度被用于求解偏微分方程</li>
</ul>
<h3 id="r-树">R 树</h3>
<p>一棵 R 树满足如下的性质</p>
<ol type="1">
<li>除非它是根结点之外，所有叶子结点包含有 m 至 M 个记录索引（条目）作为根结点的叶子结点所具有的记录个数可以少于 m通常，m=M/2</li>
<li>对于所有在叶子中存储的记录（条目），I 是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）</li>
<li>每一个非叶子结点拥有 m 至 M 个孩子结点，除非它是根结点</li>
<li>对于在非叶子结点上的每一个条目，i 是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质 2）</li>
<li>所有叶子结点都位于同一层，因此 R 树为平衡树</li>
</ol>
<p>结点：</p>
<ul>
<li>叶子结点所保存的数据形式为：(I, tuple-identifier)
<ul>
<li>其中，tuple-identifier 表示的是一个存放于数据库中的 tuple，也就是一条记录，它是 n 维的I 是一个 n 维空间的矩形，并可以恰好框住这个叶子结点中所有记录代表的 n 维空间中的点</li>
</ul></li>
<li>R 树的非叶子结点存放的数据结构为：(I, child-pointer)
<ul>
<li>其中，child-pointer 是指向孩子结点的指针，I 是覆盖所有孩子结点对应矩形的矩形</li>
</ul></li>
</ul>
<h3 id="hmm">HMM</h3>
<p>HMM 是 Hidden Markov Model 的缩写, 即隐马尔可夫模型它是一种重要的概率图模型, 广泛应用于语音识别、自然语言处理、生物信息学等领域</p>
<p>隐马尔可夫模型的主要特点如下:</p>
<ul>
<li>状态空间: HMM 包含一组隐藏的状态, 这些状态不能直接观测到, 而是通过观测数据来推断</li>
<li>状态转移: 模型在隐藏状态之间进行马尔可夫转移, 即每个状态只依赖于前一个状态</li>
<li>观测概率: 每个隐藏状态都与一个观测数据相关联, 并有一个观测概率分布</li>
</ul>
<p>Top-k Hidden Markov Model (Top-k HMM) 算法是一种用于高效计算 HMM 中 Top-k 概率最高的状态路径的算法它的主要思想如下:</p>
<ul>
<li>初始化: 将 HMM 的初始状态概率分布、转移概率矩阵和观测概率矩阵作为输入 设置需要计算的 Top-k 个状态路径的数量 k</li>
<li>动态规划过程: 使用动态规划的方法, 递推计算每个时刻 t 的 Top-k 状态路径 在每个时刻 t, 保留 Top-k 概率最高的状态路径</li>
<li>回溯过程: 从最后一个时刻 T 开始, 根据保留的 Top-k 状态路径, 逐步回溯得到 Top-k 概率最高的完整状态路径</li>
<li>输出结果: 输出计算得到的 Top-k 概率最高的状态路径</li>
</ul>
<h1 id="编程">编程</h1>
<h2 id="机试参考">机试参考</h2>
<p>devcpp开启调试功能:</p>
<ol type="1">
<li>点击“工具”菜单--编译选项--“代码生成/优化”--连接器--“产生调试信息”为YES,单击“确定”实现调试过程中，选择指定变量，即可显示相应变量的值，并且随着程序的变化而变化</li>
<li>点击”工具“菜单--环境选项--”浏览DEBUG变量“--选择”查看鼠标指向的变量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="vector">vector</h3>
<p><code>vector</code>包含着一系列连续存储的元素,其行为和数组类似。访问Vector中的任意元素或从末尾添加元素都可以在<code>常量级时间复杂度</code>内完成，而查找特定值的元素所处的位置或是在Vector中插入元素则是<code>线性时间复杂度</code></p>
<p>构造函数:</p>
<ul>
<li><code>vector();</code> 无参数 - 构造一个空的vector</li>
<li><code>vector(size_type num);</code> 数量(num) - 构造一个大小为num，值为Type默认值的Vector</li>
<li><code>vector(size_type num, const TYPE &amp;val);</code> 数量(num)和值(val) - 构造一个初始放入num个值为val的元素的Vector</li>
<li><code>vector(const vector &amp;from);</code> vector(from) - 构造一个与vector from 相同的vector</li>
<li><code>vector(input_iterator start, input_iterator end);</code> 迭代器(start)和迭代器(end) - 构造一个初始值为<code>[start,end)</code>区间元素的Vector(注:半开区间).</li>
<li><code>vector(initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());</code>C++11新提供的方法，类似如下方式：
<ul>
<li><code>std::vector&lt;int&gt;a&#123;1, 2, 3, 4, 5&#125;;</code></li>
<li><code>std::vector&lt;int&gt;a = &#123;1, 2, 3, 4, 5&#125;;</code></li>
</ul></li>
</ul>
<p>常用API：</p>
<ul>
<li>Operators : 对vector进行赋值或比较
<ul>
<li><code>v1 == v2</code></li>
<li><code>v1 != v2</code></li>
<li><code>v1 &lt;= v2</code></li>
<li><code>v1 &gt;= v2</code></li>
<li><code>v1 &lt; v2</code></li>
<li><code>v1 &gt; v2</code></li>
<li><code>v[]</code></li>
</ul></li>
<li><code>assign()</code>对Vector中的元素赋值</li>
<li><code>at()</code> : 返回指定位置的元素</li>
<li><code>back()</code> : 返回最末一个元素</li>
<li><code>begin()</code> : 返回第一个元素的迭代器</li>
<li><code>capacity()</code> : 返回vector所能容纳的元素数量(在不重新分配内存的情况下)</li>
<li><code>clear()</code> : 清空所有元素</li>
<li><code>empty()</code> : 判断Vector是否为空（返回true时为空）</li>
<li><code>end()</code> : 返回最末元素的迭代器(译注:实指向最末元素的下一个位置)</li>
<li><code>erase()</code> : 删除指定元素</li>
<li><code>front()</code> : 返回第一个元素</li>
<li><code>get_allocator()</code> : 返回vector的内存分配器</li>
<li><code>insert()</code> : 插入元素到Vector中</li>
<li><code>max_size()</code> : 返回Vector所能容纳元素的最大数量（上限）</li>
<li><code>pop_back()</code> : 移除最后一个元素</li>
<li><code>push_back()</code> : 在Vector最后添加一个元素</li>
<li><code>rbegin()</code> : 返回Vector尾部的逆迭代器</li>
<li><code>rend()</code> : 返回Vector起始的逆迭代器</li>
<li><code>reserve()</code> : 设置Vector最小的元素容纳数量</li>
<li><code>resize()</code> : 改变Vector元素数量的大小</li>
<li><code>size()</code> : 返回Vector元素数量的大小</li>
<li><code>swap()</code> : 交换两个Vector</li>
</ul>
<h3 id="stack">stack</h3>
<p>C++ stack（堆栈）实现了一个<strong>先进后出</strong>（FILO）的数据结构</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stkT;</code> : 采用模板类实现，stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code> : 拷贝构造函数</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>size()</code>: 返回栈中的元素数</li>
<li><code>top()</code>: 返回栈顶的元素</li>
<li><code>pop()</code>: 从栈中取出并删除元素</li>
<li><code>push(x)</code>: 向栈中添加元素x</li>
<li><code>empty()</code>: 在栈为空时返回true</li>
</ul>
<h3 id="set">set</h3>
<p>集合中以一种特定的顺序保存唯一的元素<br />
构造函数:</p>
<ul>
<li><code>set();</code> 无参数 - 构造一个空的set</li>
<li><code>set(InputIterator first, InputIterator last)</code> : 迭代器的方式构造set</li>
<li><code>set(const set &amp;from);</code> : copyd的方式构造一个与set from 相同的set</li>
<li><code>set(input_iterator start, input_iterator end);</code> 迭代器(start)和迭代器(end)</li>
<li>构造一个初始值为<code>[start,end)</code>区间元素的Vector(注:半开区间)</li>
<li><code>set (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());</code>C++11新提供的方法，类似如下方式：
<ul>
<li><code>std::set&lt;int&gt;a&#123;1, 2, 3, 4, 5&#125;;</code></li>
</ul></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>begin()</code> : 返回指向第一个元素的迭代器</li>
<li><code>clear()</code> : 清除所有元素</li>
<li><code>count()</code> : 返回某个值元素的个数</li>
<li><code>empty()</code> : 如果集合为空，返回true</li>
<li><code>end()</code> : 返回指向最后一个元素的迭代器</li>
<li><code>equal_range()</code> : 返回集合中与给定值相等的上下限的两个迭代器</li>
<li><code>erase()</code> : 删除集合中的元素</li>
<li><code>find()</code> : 返回一个指向被查找到元素的迭代器</li>
<li><code>get_allocator()</code> : 返回集合的分配器</li>
<li><code>insert()</code> : 在集合中插入元素</li>
<li><code>lower_bound()</code> : 返回指向大于（或等于）某值的第一个元素的迭代器</li>
<li><code>key_comp()</code> : 返回一个用于元素间值比较的函数</li>
<li><code>max_size()</code> : 返回集合能容纳的元素的最大限值</li>
<li><code>rbegin()</code> : 返回指向集合中最后一个元素的反向迭代器</li>
<li><code>rend()</code> : 返回指向集合中第一个元素的反向迭代器</li>
<li><code>size()</code> : 集合中元素的数目</li>
<li><code>swap()</code> : 交换两个集合变量</li>
<li><code>upper_bound()</code> : 返回大于某个值元素的迭代器</li>
<li><code>value_comp()</code> : 返回一个用于比较元素间的值的函数</li>
</ul>
<h4 id="unordered_set">unordered_set</h4>
<table>
<thead>
<tr class="header">
<th><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#begin"><code>begin</code></a></th>
<th>指定受控序列的开头</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#bucket"><code>bucket</code></a></td>
<td>获取键值的存储桶编号</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#bucket_count"><code>bucket_count</code></a></td>
<td>获取存储桶数</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#bucket_size"><code>bucket_size</code></a></td>
<td>获取存储桶的大小</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#cbegin"><code>cbegin</code></a></td>
<td>指定受控序列的开头</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#cend"><code>cend</code></a></td>
<td>指定受控序列的末尾</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#clear"><code>clear</code></a></td>
<td>删除所有元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#contains"><code>contains</code></a></td>
<td>检查 <code>unordered_set</code> 中是否包含具有指定键的元素。</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#count"><code>count</code></a></td>
<td>查找与指定键匹配的元素数，非multi的情况下非0即1。</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#emplace"><code>emplace</code></a></td>
<td>添加就地构造的元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#emplace_hint"><code>emplace_hint</code></a></td>
<td>添加就地构造的元素，附带提示</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#empty"><code>empty</code></a></td>
<td>测试元素是否存在</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#end"><code>end</code></a></td>
<td>指定受控序列的末尾</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#equal_range"><code>equal_range</code></a></td>
<td>查找与指定键匹配的范围</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#erase"><code>erase</code></a></td>
<td>移除指定位置处的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#find"><code>find</code></a></td>
<td>查找与指定键匹配的元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#get_allocator"><code>get_allocator</code></a></td>
<td>获取存储的分配器对象</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#hash"><code>hash_function</code></a></td>
<td>获取存储的哈希函数对象</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#insert"><code>insert</code></a></td>
<td>添加元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#key_eq"><code>key_eq</code></a></td>
<td>获取存储的比较函数对象</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#load_factor"><code>load_factor</code></a></td>
<td>对每个存储桶的平均元素数进行计数</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#max_bucket_count"><code>max_bucket_count</code></a></td>
<td>获取最大的存储桶数</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#max_load_factor"><code>max_load_factor</code></a></td>
<td>获取或设置每个存储桶的最多元素数</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#max_size"><code>max_size</code></a></td>
<td>获取受控序列的最大大小</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#rehash"><code>rehash</code></a></td>
<td>重新生成哈希表</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#size"><code>size</code></a></td>
<td>对元素数进行计数</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#swap"><code>swap</code></a></td>
<td>交换两个容器的内容</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#unordered_set"><code>unordered_set</code></a></td>
<td>构造容器对象</td>
</tr>
</tbody>
</table>
<h3 id="queue">queue</h3>
<p>C++队列是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构</p>
<p>构造函数：</p>
<ul>
<li><code>explicit queue (const container_type&amp; ctnr);</code></li>
<li><code>explicit queue (container_type&amp;&amp; ctnr = container_type());</code></li>
<li><code>template &lt;class Alloc&gt; explicit queue (const Alloc&amp; alloc);</code></li>
<li><code>template &lt;class Alloc&gt; queue (const container_type&amp; ctnr, const Alloc&amp; alloc);</code></li>
<li><code>template &lt;class Alloc&gt; queue (container_type&amp;&amp; ctnr, const Alloc&amp; alloc);</code></li>
<li><code>template &lt;class Alloc&gt; queue (const queue&amp; x, const Alloc&amp; alloc);</code></li>
<li><code>template &lt;class Alloc&gt; queue (queue&amp;&amp; x, const Alloc&amp; alloc);</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>back()</code> : 返回最后一个元素</li>
<li><code>empty()</code> : 如果队列空则返回真</li>
<li><code>front()</code> : 返回第一个元素</li>
<li><code>pop()</code> : 删除第一个元素</li>
<li><code>push()</code> : 在末尾加入一个元素</li>
<li><code>size()</code> : 返回队列中元素的个数</li>
</ul>
<h3 id="list">list</h3>
<p>Lists将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢.</p>
<p>构造函数：</p>
<ul>
<li><code>list (const allocator_type&amp; alloc = allocator_type());</code></li>
<li><code>list (size_type n, const value_type&amp; val = value_type(), const allocator_type&amp; alloc = allocator_type());</code></li>
<li><code>template &lt;class InputIterator&gt; list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());</code></li>
<li><code>list (const list&amp; x);</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>assign()</code> : 给list赋值</li>
<li><code>back()</code> : 返回最后一个元素</li>
<li><code>begin()</code> : 返回指向第一个元素的迭代器</li>
<li><code>clear()</code> : 删除所有元素</li>
<li><code>empty()</code> : 如果list是空的则返回true</li>
<li><code>end()</code> : 返回末尾的迭代器</li>
<li><code>erase()</code> : 删除一个元素</li>
<li><code>front()</code> : 返回第一个元素</li>
<li><code>get_allocator()</code> : 返回list的配置器</li>
<li><code>insert()</code> : 插入一个元素到list中</li>
<li><code>max_size()</code> : 返回list能容纳的最大元素数量</li>
<li><code>merge()</code> : 合并两个list</li>
<li><code>pop_back()</code> : 删除最后一个元素</li>
<li><code>pop_front()</code> : 删除第一个元素</li>
<li><code>push_back()</code> : 在list的末尾添加一个元素</li>
<li><code>push_front()</code> : 在list的头部添加一个元素</li>
<li><code>rbegin()</code> : 返回指向第一个元素的逆向迭代器</li>
<li><code>remove()</code> : 从list删除元素</li>
<li><code>remove_if()</code> : 按指定条件删除元素</li>
<li><code>rend()</code> : 指向list末尾的逆向迭代器</li>
<li><code>resize()</code> : 改变list的大小</li>
<li><code>reverse()</code> : 把list的元素倒转</li>
<li><code>size()</code> : 返回list中的元素个数</li>
<li><code>sort()</code> : 给list排序</li>
<li><code>splice()</code> : 合并两个list</li>
<li><code>swap()</code> : 交换两个list</li>
<li><code>unique()</code> : 删除list中重复的元素</li>
</ul>
<h3 id="map">map</h3>
<p>C++ Maps是一种关联式容器，包含“关键字/值”对</p>
<p>构造函数：</p>
<ul>
<li><code>map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());</code></li>
<li><code>template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last,const key_compare&amp; comp = key_compare(),const allocator_type&amp; = allocator_type());</code></li>
<li><code>map (const map&amp; x);</code></li>
<li><code>map (const map&amp; x, const allocator_type&amp; alloc);</code></li>
<li><code>map (map&amp;&amp; x);</code></li>
<li><code>map (map&amp;&amp; x, const allocator_type&amp; alloc);</code></li>
<li><code>map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>begin()</code> : 返回指向map头部的迭代器</li>
<li><code>clear()</code> : 删除所有元素</li>
<li><code>count()</code> : 返回指定元素出现的次数</li>
<li><code>empty()</code> : 如果map为空则返回true</li>
<li><code>end()</code> : 返回指向map末尾的迭代器</li>
<li><code>equal_range()</code> : 返回特殊条目的迭代器对</li>
<li><code>erase()</code> : 删除一个元素</li>
<li><code>find()</code> : 查找一个元素</li>
<li><code>get_allocator()</code> : 返回map的配置器</li>
<li><code>insert()</code> : 插入元素</li>
<li><code>key_comp()</code> : 返回比较元素key的函数</li>
<li><code>lower_bound()</code> : 返回键值&gt;=给定元素的第一个位置</li>
<li><code>max_size()</code> : 返回可以容纳的最大元素个数</li>
<li><code>rbegin()</code> : 返回一个指向map尾部的逆向迭代器</li>
<li><code>rend()</code> : 返回一个指向map头部的逆向迭代器</li>
<li><code>size()</code> : 返回map中元素的个数</li>
<li><code>swap()</code> : 交换两个map</li>
<li><code>upper_bound()</code> : 返回键值&gt;给定元素的第一个位置</li>
<li><code>value_comp()</code> : 返回比较元素value的函数</li>
</ul>
<h4 id="unordered_map">unordered_map</h4>
<table>
<thead>
<tr class="header">
<th>类型定义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#allocator_type"><code>allocator_type</code></a></td>
<td>用于管理存储的分配器的类型</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#const_iterator"><code>const_iterator</code></a></td>
<td>受控序列的常量迭代器的类型</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#const_local_iterator"><code>const_local_iterator</code></a></td>
<td>受控序列的常量存储桶迭代器的类型</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#const_pointer"><code>const_pointer</code></a></td>
<td>元素的常量指针的类型</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#const_reference"><code>const_reference</code></a></td>
<td>元素的常量引用的类型</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#difference_type"><code>difference_type</code></a></td>
<td>两个元素间的带符号距离的类型</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#hasher"><code>hasher</code></a></td>
<td>哈希函数的类型</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#iterator"><code>iterator</code></a></td>
<td>受控序列的迭代器的类型</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#key_equal"><code>key_equal</code></a></td>
<td>比较函数的类型</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#key_type"><code>key_type</code></a></td>
<td>排序键的类型</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#local_iterator"><code>local_iterator</code></a></td>
<td>受控序列的存储桶迭代器的类型</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#mapped_type"><code>mapped_type</code></a></td>
<td>与每个键关联的映射值的类型</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#pointer"><code>pointer</code></a></td>
<td>指向元素的指针的类型</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#reference"><code>reference</code></a></td>
<td>元素的引用的类型</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#size_type"><code>size_type</code></a></td>
<td>两个元素间的无符号距离的类型</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#value_type"><code>value_type</code></a></td>
<td>元素的类型</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>成员函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#at"><code>at</code></a></td>
<td>查找具有指定键的元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#begin"><code>begin</code></a></td>
<td>指定受控序列的开头</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#bucket"><code>bucket</code></a></td>
<td>获取键值的存储桶编号</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#bucket_count"><code>bucket_count</code></a></td>
<td>获取存储桶数</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#bucket_size"><code>bucket_size</code></a></td>
<td>获取存储桶的大小</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#cbegin"><code>cbegin</code></a></td>
<td>指定受控序列的开头</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#cend"><code>cend</code></a></td>
<td>指定受控序列的末尾</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#clear"><code>clear</code></a></td>
<td>删除所有元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#count"><code>count</code></a></td>
<td>查找与指定键匹配的元素数</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#contains"><code>contains</code></a></td>
<td>检查 <code>unordered_map</code> 中是否包含具有指定键的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#emplace"><code>emplace</code></a></td>
<td>添加就地构造的元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#emplace_hint"><code>emplace_hint</code></a></td>
<td>添加就地构造的元素，附带提示</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#empty"><code>empty</code></a></td>
<td>测试元素是否存在</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#end"><code>end</code></a></td>
<td>指定受控序列的末尾</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#equal_range"><code>equal_range</code></a></td>
<td>查找与指定键匹配的范围</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#erase"><code>erase</code></a></td>
<td>移除指定位置处的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#find"><code>find</code></a></td>
<td>查找与指定键匹配的元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#get_allocator"><code>get_allocator</code></a></td>
<td>获取存储的分配器对象</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#hash"><code>hash_function</code></a></td>
<td>获取存储的哈希函数对象</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#insert"><code>insert</code></a></td>
<td>添加元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#key_eq"><code>key_eq</code></a></td>
<td>获取存储的比较函数对象</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#load_factor"><code>load_factor</code></a></td>
<td>对每个存储桶的平均元素数进行计数</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#max_bucket_count"><code>max_bucket_count</code></a></td>
<td>获取最大的存储桶数</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#max_load_factor"><code>max_load_factor</code></a></td>
<td>获取或设置每个存储桶的最多元素数</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#max_size"><code>max_size</code></a></td>
<td>获取受控序列的最大大小</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#rehash"><code>rehash</code></a></td>
<td>重新生成哈希表</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#size"><code>size</code></a></td>
<td>对元素数进行计数</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#swap"><code>swap</code></a></td>
<td>交换两个容器的内容</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#unordered_map"><code>unordered_map</code></a></td>
<td>构造容器对象</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#op_at"><code>unordered_map::operator[]</code></a></td>
<td>查找或插入具有指定键的元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#op_eq"><code>unordered_map::operator=</code></a></td>
<td>复制哈希表</td>
</tr>
</tbody>
</table>
<h3 id="string">string</h3>
<p>c++字符串数组需要指定长度，如<code>vec.push_back(string(1,char c))</code> ，将字符串转化为字面数字需要用<code>stoi</code>(来自string库)函数 栈3</p>
<h4 id="string构造函数">1.string构造函数</h4>
<ul>
<li><code>string();</code>//创建一个空的字符串</li>
<li><code>string(const string&amp; str);</code>//使用一个string对象初始化另一个string对象</li>
<li><code>string(const char* s);</code>//使用字符串s初始化</li>
<li><code>string(int n,char c);</code>//使用n个字符c初始化</li>
</ul>
<h4 id="string基本赋值操作">2.string基本赋值操作</h4>
<ul>
<li><code>string&amp; operator=(const char* s);</code>//char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>//把字符串s赋值给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>//字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char* s);</code>//把字符串s赋值给当前的字符串</li>
<li><code>string&amp; assign(const char* s,int n);</code>//把字符串s的前n个字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>//把字符串s赋值给当前的字符串</li>
<li><code>string&amp; assign(int n,char c);</code>//用n个字符c赋值给当前字符串</li>
<li><code>string&amp; assign(const string &amp;s,int start,int n);</code>//将s从start开始n个字符赋值给字符串</li>
</ul>
<h4 id="string存取字符操作">3.string存取字符操作</h4>
<ul>
<li><code>char&amp; operator[](int n);</code>//通过<code>[]</code>方式取字符</li>
<li><code>char&amp; at(int n);</code>//通过at方法获取字符</li>
</ul>
<h4 id="string拼接操作">4.string拼接操作</h4>
<ul>
<li><code>string&amp; operator+=(const string&amp; str);</code>//重载+=运算符</li>
<li><code>string&amp; operator+=(const char* str);</code>//重载+=运算符</li>
<li><code>string&amp; operator+=(const char c);</code>//重载+=运算符</li>
<li><code>string&amp; append(const char *s);</code>//把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s,int n);</code>//把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>//同operator+=（）</li>
<li><code>string&amp; append(const string &amp;s,int pos,int n);</code>//把字符串s中从pos开始的n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(int n,char c);</code>//在当前字符串结尾添加n个字符c</li>
</ul>
<h4 id="string查找和替换">5.string查找和替换</h4>
<ul>
<li><code>int find(const string&amp; str,int pos = 0)const;</code>//查找str第一次出现的位置，从pos开始查找</li>
<li><code>int find(const char* s,int pos = 0)const;</code>//查找s第一次出现位置，从pos开始查找</li>
<li><code>int find(const char *s,int pos,int n)const;</code>//从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c,int pos = 0)const;</code>//查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos)const;</code>//查找str最后一次出现位置，从pos开始查找</li>
<li><code>int rfind(const char* s,int pos = npos)const;</code>//查找s最后一次出现位置，从pos开始查找</li>
<li><code>int rfind(const char* s,int pos,int n )const;</code>//从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c,int pos = 0)const;</code>//查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos,int n,const string&amp; str);</code>//替换从pos开始的n个字符为字符串str</li>
<li><code>string&amp; replace(int pos,int n,const char* s);</code>//替换从pos开始的n个字符为字符串s</li>
</ul>
<h4 id="string-比较操作">6.string 比较操作</h4>
<ul>
<li><code>int compare(const string &amp;s)const;</code>//与字符串s比较</li>
<li><code>int compare(const char*s)const;</code>//与字符串s比较</li>
<li>compare函数在&gt;时返回1，&lt;时返回-1，相等时返回0，比较区分大小写，逐个字符比较</li>
</ul>
<h4 id="string子串">7.string子串</h4>
<ul>
<li><code>string substr(int pos = 0,int n = npos)const;</code>//返回由pos开始的n个字符组成的字符串</li>
</ul>
<h4 id="string插入和删除操作">8.string插入和删除操作</h4>
<ul>
<li><code>string&amp; insert(int pos,const char* s);</code>//插入字符串</li>
<li><code>string&amp; insert(int pos,const string &amp;str);</code>//插入字符串</li>
<li><code>string&amp; insert(int pos,int n,char c);</code>//在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos,int n = npos);</code>//删除从pos开始的n个字符</li>
</ul>
<h3 id="deque">deque</h3>
<p>deque是Double-Ended Queues(双向队列)的缩写</p>
<p>双向队列和向量很相似，但是它允许在容器头部快速插入和删除（就像在尾部一样）</p>
<h4 id="deque构造函数">1.deque构造函数</h4>
<ul>
<li><code>deque&lt;T&gt; queT;</code>//queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>deque&lt;T&gt; queT(size);</code>//构造大小为size的deque，其中值为T类型的默认值</li>
<li><code>deque&lt;T&gt; queT(size, val);</code>//构造大小为size的deque，其中值为val</li>
<li><code>deque(const deque &amp;que);</code>//拷贝构造函数</li>
<li><code>deque(input_iterator start, input_iterator end);</code>//迭代器构造函数</li>
</ul>
<h4 id="deque存取插入和删除操作">2.deque存取、插入和删除操作</h4>
<ul>
<li><code>back();</code>//返回最后一个元素</li>
<li><code>front();</code>//返回第一个元素</li>
<li><code>insert();</code>//</li>
<li><code>pop_back();</code>//删除尾部的元素</li>
<li><code>pop_front();</code>//删除头部的元素</li>
<li><code>push_back();</code>//在尾部加入一个元素</li>
<li><code>push_front();</code>//在头部加入一个元素</li>
<li><code>at();</code>//访问指定位置元素</li>
</ul>
<h4 id="deque赋值操作">3.deque赋值操作</h4>
<ul>
<li><code>operator[] (size_type n);</code>//重载[]操作符</li>
</ul>
<h4 id="deque大小操作">4.deque大小操作</h4>
<ul>
<li><code>empty()</code>;//判断队列是否为空</li>
<li><code>size()</code>;//返回队列的大小</li>
</ul>
<h3 id="priority_queue">priority_queue</h3>
<p>优先队列类似队列， 但是在这个数据结构中的元素按照一定的规则排列有序</p>
<p>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有<strong>最高优先级先出</strong> （first in, largest out）的行为特征</p>
<p>首先要包含头文件<code>#include&lt;queue&gt;</code>, 他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队</p>
<p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它<strong>本质是一个堆实现的</strong></p>
<p>构造函数： <code>priority_queue&lt;Type, Container, Functional&gt;</code></p>
<ul>
<li>Type 就是数据类型，</li>
<li>Container 就是容器类型（Container必须是具备<strong>随机存取</strong>能力的容器，支持如下方法：<code>empty()</code>, <code>size()</code>, <code>front()</code>, <code>push_back()</code>,<code>pop_back()</code>。比如vector,deque等等，但不能用list。STL里面默认用的是vector）。可选</li>
<li>Functional 就是比较的方式。可选</li>
</ul>
<p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆(Functional是less)</p>
<p>api和队列基本操作相同:</p>
<ul>
<li><code>top</code> 访问队头元素</li>
<li><code>empty</code> 队列是否为空</li>
<li><code>size</code> 返回队列内元素个数</li>
<li><code>push</code> 插入元素到队尾 (并排序)</li>
<li><code>emplace</code> 原地构造一个元素并插入队列</li>
<li><code>pop</code> 弹出队头元素</li>
<li><code>swap</code> 交换内容</li>
</ul>
<p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">cpp vector</a></p>
<h3 id="algorithm">algorithm</h3>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#adjacent_find"><code>adjacent_find</code></a></th>
<th>搜索相等或满足指定条件的两个相邻元素</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#all_of"><code>all_of</code></a></td>
<td>当给定范围中的每个元素均满足条件时返回 <strong><code>true</code></strong></td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#any_of"><code>any_of</code></a></td>
<td>当指定元素范围中至少有一个元素满足条件时返回 <strong><code>true</code></strong></td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#binary_search"><code>binary_search</code></a></td>
<td>测试已排序的范围中是否有等于指定值的元素，或在二元谓词指定的意义上与指定值等效的元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#clamp"><code>clamp</code></a></td>
<td></td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#copy"><code>copy</code></a></td>
<td>将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向前方向的新位置</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#copy_backward"><code>copy_backward</code></a></td>
<td>将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向后方向的新位置</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#copy_if"><code>copy_if</code></a></td>
<td>复制给定范围中对于指定条件为 <strong><code>true</code></strong> 的所有元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#copy_n"><code>copy_n</code></a></td>
<td>复制指定数量的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#count"><code>count</code></a></td>
<td>返回范围中其值与指定值匹配的元素的数量</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#count_if"><code>count_if</code></a></td>
<td>返回范围中其值与指定条件匹配的元素的数量</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#equal"><code>equal</code></a></td>
<td>逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#equal_range"><code>equal_range</code></a></td>
<td>在排序的范围中查找符合以下条件的位置对：第一个位置小于或等效于指定元素的位置，第二个位置大于此元素位置，等效意义或用于在序列中建立位置的排序可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#fill"><code>fill</code></a></td>
<td>将相同的新值分配给指定范围中的每个元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#fill_n"><code>fill_n</code></a></td>
<td>将新值分配给以特定元素开始的范围中的指定数量的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find"><code>find</code></a></td>
<td>在范围中找到具有指定值的元素的第一个匹配项位置</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find_end"><code>find_end</code></a></td>
<td>在范围中查找与指定序列相同的最后一个序列，或在二元谓词指定的意义上等效的最后一个序列</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find_first_of"><code>find_first_of</code></a></td>
<td>在目标范围中搜索若干值中任意值的第一个匹配项，或搜索在二元谓词指定的意义上等效于指定元素集的若干元素中任意元素的第一个匹配项</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find_if"><code>find_if</code></a></td>
<td>在范围中找到满足指定条件的元素的第一个匹配项位置</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find_if_not"><code>find_if_not</code></a></td>
<td>返回指示的范围中不满足条件的第一个元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#for_each"><code>for_each</code></a></td>
<td>将指定的函数对象按向前顺序应用于范围中的每个元素并返回此函数对象</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#for_each_n"><code>for_each_n</code></a></td>
<td></td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#generate"><code>generate</code></a></td>
<td>将函数对象生成的值分配给范围中的每个元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#generate_n"><code>generate_n</code></a></td>
<td>将函数对象生成的值分配给范围中指定数量的元素，并返回到超出最后一个分配值的下一位置</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#includes"><code>includes</code></a></td>
<td>测试一个排序的范围是否包含另一排序范围中的所有元素，其中元素之间的排序或等效条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#inplace_merge"><code>inplace_merge</code></a></td>
<td>将两个连续的排序范围中的元素合并为一个排序范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_heap"><code>is_heap</code></a></td>
<td>如果指定范围中的元素形成堆，则返回 <strong><code>true</code></strong></td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_heap_until"><code>is_heap_until</code></a></td>
<td>如果指定范围形成直到最后一个元素的堆，则返回 <strong><code>true</code></strong></td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_partitioned"><code>is_partitioned</code></a></td>
<td>如果给定范围中对某个条件测试为 <strong><code>true</code></strong> 的所有元素在测试为 <strong><code>true</code></strong> 的所有元素之前，则返回 <strong><code>false</code></strong></td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_permutation"><code>is_permutation</code></a></td>
<td>确定给定范围的元素是否形成有效排列</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_sorted"><code>is_sorted</code></a></td>
<td>如果指定范围中的元素按顺序排序，则返回 <strong><code>true</code></strong></td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_sorted_until"><code>is_sorted_until</code></a></td>
<td>如果指定范围中的元素按顺序排序，则返回 <strong><code>true</code></strong></td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#iter_swap"><code>iter_swap</code></a></td>
<td>交换由一对指定迭代器引用的两个值</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#lexicographical_compare"><code>lexicographical_compare</code></a></td>
<td>逐个元素比较两个序列以确定其中的较小序列</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#lower_bound"><code>lower_bound</code></a></td>
<td>在排序的范围中查找其值大于或等效于指定值的第一个元素的位置，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#make_heap"><code>make_heap</code></a></td>
<td>将指定范围中的元素转换到第一个元素是最大元素的堆中，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#max"><code>max</code></a></td>
<td>比较两个对象并返回较大对象，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#max_element"><code>max_element</code></a></td>
<td>在指定范围中查找最大元素的第一个匹配项，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#merge"><code>merge</code></a></td>
<td>将两个排序的源范围中的所有元素合并为一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#min"><code>min</code></a></td>
<td>比较两个对象并返回较小对象，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#min_element"><code>min_element</code></a></td>
<td>在指定范围中查找最小元素的第一个匹配项，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#minmax"><code>minmax</code></a></td>
<td>比较两个输入参数，并按最小到最大的顺序将它们作为参数对返回</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#minmax_element"><code>minmax_element</code></a></td>
<td>在一次调用中执行由 <a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#min_element"><code>min_element</code></a> 和 <a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#max_element"><code>max_element</code></a> 执行的操作</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#mismatch"><code>mismatch</code></a></td>
<td>逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效，并找到出现不同的第一个位置</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#alg_move"><code>&lt;alg&gt; move</code></a></td>
<td>移动与指定范围关联的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#move_backward"><code>move_backward</code></a></td>
<td>将一个迭代器的元素移动到另一迭代器移动从指定范围的最后一个元素开始，并在此范围的第一个元素结束</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#next_permutation"><code>next_permutation</code></a></td>
<td>重新排序范围中的元素，以便使用按字典顺序的下一个更大排列（如果有）替换原有排序，其中“下一个”的意义可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#none_of"><code>none_of</code></a></td>
<td>当给定范围中没有元素满足条件时返回 <strong><code>true</code></strong></td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#nth_element"><code>nth_element</code></a></td>
<td>对范围内的元素分区，正确找到范围中序列的第 <em>n</em> 个元素，以使序列中位于此元素之前的所有元素小于或等于此元素，位于此元素之后的所有元素大于或等于此元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partial_sort"><code>partial_sort</code></a></td>
<td>将范围中指定数量的较小元素按非降序顺序排列，或根据二元谓词指定的排序条件排列</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partial_sort_copy"><code>partial_sort_copy</code></a></td>
<td>将源范围中的元素复制到目标范围，其中源元素按降序或二元谓词指定的其他顺序排序</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partition"><code>partition</code></a></td>
<td>将范围中的元素分为两个不相交的集，满足一元谓词的元素在不满足一元谓词的元素之前</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partition_copy"><code>partition_copy</code></a></td>
<td>将条件为 <strong><code>true</code></strong> 的元素复制到一个目标，将条件为 <strong><code>false</code></strong> 的元素复制到另一目标元素必须来自于指定范围</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partition_point"><code>partition_point</code></a></td>
<td>返回给定范围中不满足条件的第一个元素元素经过排序，满足条件的元素在不满足条件的元素之前</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#pop_heap"><code>pop_heap</code></a></td>
<td>移除从堆顶到范围中倒数第二个位置之间的最大元素，然后将剩余元素形成新堆</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#prev_permutation"><code>prev_permutation</code></a></td>
<td>重新排序范围中的元素，以便使用按字典顺序的下一个更大排列（如果有）替换原有排序，其中“下一个”的意义可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#push_heap"><code>push_heap</code></a></td>
<td>将范围末尾的元素添加到包括范围中前面元素的现有堆中</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#random_shuffle"><code>random_shuffle</code></a></td>
<td>将范围中 <em>N</em> 个元素的序列重新排序为随机 <em>N</em>! 种序列中的 可能排列之一</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#remove"><code>remove</code></a></td>
<td>从给定范围中消除指定值，而不影响剩余元素的顺序，并返回不包含指定值的新范围的末尾</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#remove_copy"><code>remove_copy</code></a></td>
<td>将源范围中的元素复制到目标范围（不复制具有指定值的元素），而不影响剩余元素的顺序，并返回新目标范围的末尾</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#remove_copy_if"><code>remove_copy_if</code></a></td>
<td>将源范围中的元素复制到目标范围（不复制满足谓词的元素），而不影响剩余元素的顺序，并返回新目标范围的末尾</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#remove_if"><code>remove_if</code></a></td>
<td>从给定范围中消除满足谓词的元素，而不影响剩余元素的顺序，并返回不包含指定值的新范围的末尾</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#replace"><code>replace</code></a></td>
<td>检查范围中的每个元素，并替换与指定值匹配的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#replace_copy"><code>replace_copy</code></a></td>
<td>检查源范围中的每个元素，并替换与指定值匹配的元素，同时将结果复制到新的目标范围</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#replace_copy_if"><code>replace_copy_if</code></a></td>
<td>检查源范围中的每个元素，并替换满足指定谓词的元素，同时将结果复制到新的目标范围</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#replace_if"><code>replace_if</code></a></td>
<td>检查范围中的每个元素，并替换满足指定谓词的元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#reverse"><code>reverse</code></a></td>
<td>反转范围中元素的顺序</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#reverse_copy"><code>reverse_copy</code></a></td>
<td>反转源范围中元素的顺序，同时将这些元素复制到目标范围</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#rotate"><code>rotate</code></a></td>
<td>交换两个相邻范围中的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#rotate_copy"><code>rotate_copy</code></a></td>
<td>交换源范围中两个相邻范围内的元素，并将结果复制到目标范围</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#sample"><code>sample</code></a></td>
<td></td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#search"><code>search</code></a></td>
<td>在目标范围中搜索其元素与给定序列中的元素相等或在二元谓词指定的意义上等效于给定序列中的元素的序列的第一个匹配项</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#search_n"><code>search_n</code></a></td>
<td>在范围中搜索具有特定值或按二元谓词的指定与此值相关的指定数量的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#set_difference"><code>set_difference</code></a></td>
<td>将属于一个排序的源范围、但不属于另一排序的源范围的所有元素相并到一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#set_intersection"><code>set_intersection</code></a></td>
<td>将属于两个排序的源范围的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#set_symmetric_difference"><code>set_symmetric_difference</code></a></td>
<td>将属于一个而不是两个排序的源范围的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#set_union"><code>set_union</code></a></td>
<td>将至少属于两个排序的源范围之一的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#sort"><code>sort</code></a></td>
<td>将指定范围中的元素按非降序顺序排列，或根据二元谓词指定的排序条件排列</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#shuffle"><code>shuffle</code></a></td>
<td>使用随机数生成器重新排列给定范围中的元素</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#sort_heap"><code>sort_heap</code></a></td>
<td>将堆转换为排序的范围</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#stable_partition"><code>stable_partition</code></a></td>
<td>将范围中的元素分为两个不相交的集，满足一元谓词的元素在不满足一元谓词的元素之前，并保留等效元素的相对顺序</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#stable_sort"><code>stable_sort</code></a></td>
<td>将指定范围中的元素按非降序顺序排列，或根据二元谓词指定的排序条件排列，并保留等效元素的相对顺序</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#swap"><code>swap</code></a></td>
<td>在两种类型的对象之间交换元素值，将第一个对象的内容分配给第二个对象，将第二个对象的内容分配给第一个对象</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#swap_ranges"><code>swap_ranges</code></a></td>
<td>将一个范围中的元素与另一大小相等的范围中的元素交换</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#transform"><code>transform</code></a></td>
<td>将指定的函数对象应用于源范围中的每个元素或两个源范围中的元素对，并将函数对象的返回值复制到目标范围</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#unique"><code>unique</code></a></td>
<td>移除指定范围中彼此相邻的重复元素</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#unique_copy"><code>unique_copy</code></a></td>
<td>将源范围中的元素复制到目标范围，彼此相邻的重复元素除外</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#upper_bound"><code>upper_bound</code></a></td>
<td>在排序的范围中查找其值大于指定值的第一个元素的位置，其中排序条件可通过二元谓词指定</td>
</tr>
</tbody>
</table>
<h3 id="functional">functional</h3>
<p>提供一系列有用的函数对象，包括常用的二元谓词(由于是模板函数，使用需要提供类型)</p>
<table>
<thead>
<tr class="header">
<th><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/binary-function-struct?view=msvc-170">binary_function</a></th>
<th>空基类，定义可能由提供二元函数对象的派生类继承的类型<br> （在 C++11 中已弃用，在 C++17 中已移除）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/divides-struct?view=msvc-170">divides</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行除法算术运算</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/equal-to-struct?view=msvc-170">equal_to</a></td>
<td>此二元谓词测试指定类型的一个值是否等于该类型的另一个值</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/greater-struct?view=msvc-170">greater</a></td>
<td>此二元谓词测试指定类型的一个值是否大于该类型的另一个值</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/greater-equal-struct?view=msvc-170">greater_equal</a></td>
<td>此二元谓词测试指定类型的一个值是否大于或等于该类型的另一个值</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/less-struct?view=msvc-170">less</a></td>
<td>此二元谓词测试指定类型的一个值是否小于该类型的另一个值</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/less-equal-struct?view=msvc-170">less_equal</a></td>
<td>此二元谓词测试指定类型的一个值是否小于或等于该类型的另一个值</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/logical-and-struct?view=msvc-170">logical_and</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行合取逻辑运算，并测试结果是 ture 还是 false</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/logical-not-struct?view=msvc-170">logical_not</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行求反逻辑运算，并测试结果是 ture 还是 false</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/logical-or-struct?view=msvc-170">logical_or</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行析取逻辑运算，并测试结果是 ture 还是 false</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/minus-struct?view=msvc-170">minus</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行减法算术运算</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/modulus-struct?view=msvc-170">取模</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行取模算术运算</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/multiplies-struct?view=msvc-170">multiplies</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行乘法算术运算</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/negate-struct?view=msvc-170">negate</a></td>
<td>此类提供预定义的函数对象，后者返回元素值的负值</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/not-equal-to-struct?view=msvc-170">not_equal_to</a></td>
<td>此二元谓词测试指定类型的一个值是否不等于该类型的另一个值</td>
</tr>
<tr class="odd">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/plus-struct?view=msvc-170">plus</a></td>
<td>此类提供预定义的函数对象，后对指定值类型的元素执行加法算术运算</td>
</tr>
<tr class="even">
<td><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unary-function-struct?view=msvc-170">unary_function</a></td>
<td>空基类，定义可能由提供一元函数对象的派生类继承的类型<br> （在 C++11 中已弃用，在 C++17 中已移除）</td>
</tr>
</tbody>
</table>
<h2 id="算法范式">算法范式</h2>
<p>来自<a href="https://www.hello-algo.com/chapter_backtracking">hello-algo</a></p>
<h3 id="回溯">回溯</h3>
<p>之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择<br />
例如在二叉树查找值为7的节点:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 前序遍历：例题二 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 尝试</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == <span class="number">7</span>) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上是最标准的回溯，通俗易懂地说就是穷举，对比较复杂的问题很容易就能超过多项式复杂度，到达阶乘这种程度<br />
因此需要考虑对其的优化，例如<strong>剪枝</strong><br />
此外当然也可以用例如a star之类的启发式选择算法，俗称经验公式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(State *state, vector&lt;Choice *&gt; &amp;choices, vector&lt;State *&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为解</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSolution</span>(state)) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        <span class="built_in">recordSolution</span>(state, res);</span><br><span class="line">        <span class="comment">// 不再继续搜索</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (Choice choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：判断选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(state, choice)) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            <span class="built_in">makeChoice</span>(state, choice);</span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            <span class="built_in">undoChoice</span>(state, choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>常见例题:</p>
<p><strong>搜索问题</strong>：这类问题的目标是找到满足特定条件的解决方案</p>
<ul>
<li>全排列问题：给定一个集合，求出其所有可能的排列组合</li>
<li>子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集</li>
<li>汉诺塔问题：给定三根柱子和一系列大小不同的圆盘，要求将所有圆盘从一根柱子移动到另一根柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上</li>
</ul>
<p><strong>约束满足问题</strong>：这类问题的目标是找到满足所有约束条件的解</p>
<ul>
<li>N皇后：在 n × n 的棋盘上放置N个皇后，使得它们互不攻击</li>
<li>数独：在 n × n 的网格中填入数字 0 ~ 9 ，使得每行、每列和每个 3 × 3 子网格中的数字不重复</li>
<li>图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同</li>
</ul>
<p><strong>组合优化问题</strong>：这类问题的目标是在一个组合空间中找到满足某些条件的最优解</p>
<ul>
<li>0-1 背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大</li>
<li>旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径</li>
<li>最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连</li>
</ul>
<h4 id="全排列">全排列</h4>
<div class="note default"><p>全排列问题是回溯算法的一个典型应用。它的定义是在给定一个集合（如一个数组或字符串）的情况下，找出其中元素的所有能的排列</p>
</div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：全排列 I */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;choices, vector&lt;<span class="type">bool</span>&gt; &amp;selected, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.<span class="built_in">size</span>() == choices.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> choice = choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.<span class="built_in">push_back</span>(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 I */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permutationsI</span>(vector&lt;<span class="type">int</span>&gt; nums) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">selected</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">backtrack</span>(state, nums, selected, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑有相同元素的情况:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：全排列 II */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;choices, vector&lt;<span class="type">bool</span>&gt; &amp;selected, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.<span class="built_in">size</span>() == choices.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; duplicated;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> choice = choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素 且 不允许重复选择相等元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i] &amp;&amp; duplicated.<span class="built_in">find</span>(choice) == duplicated.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            duplicated.<span class="built_in">emplace</span>(choice); <span class="comment">// 记录选择过的元素值</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.<span class="built_in">push_back</span>(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 II */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permutationsII</span>(vector&lt;<span class="type">int</span>&gt; nums) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">selected</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">backtrack</span>(state, nums, selected, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="子集和">子集和</h4>
<div class="note default"><p>给定一个正整数数组nums和一个目标正整数target，请找出所有可能的组合，使得组合中的元素和等于target。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合</p>
<p>要求:</p>
<ul>
<li>输入集合中的元素可以被无限次重复选取</li>
<li>子集不区分元素顺序</li>
</ul>
</div>
<p>默认已排序，如果题目不提供排序数组，可以手动排……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;choices, <span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.<span class="built_in">push_back</span>(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        <span class="built_in">backtrack</span>(state, target - choices[i], choices, i, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetSumI</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;              <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;                  <span class="comment">// 遍历起始点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;        <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    <span class="built_in">backtrack</span>(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果提供的choices有重复元素，即相同元素只能按顺序被选择，记录一个start表示本次选择开始位置，相同元素如果遍历到索引大于start时说明这一轮只能先选前面那个，后面这个重复元素必须被跳过；如果是不同元素或者这轮第一个该元素则正常进行:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：子集和 II */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;choices, <span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="comment">// 剪枝三：从 start 开始遍历，避免重复选择同一元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; choices[i] == choices[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.<span class="built_in">push_back</span>(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        <span class="built_in">backtrack</span>(state, target - choices[i], choices, i + <span class="number">1</span>, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 II */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetSumII</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;              <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;                  <span class="comment">// 遍历起始点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;        <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    <span class="built_in">backtrack</span>(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="n皇后">N皇后</h4>
<div class="note default"><p>根据国际象棋的规则，皇后可以攻击与同处一行、一列或一条斜线上的棋子。给定n个皇后和n×n棋盘，寻找摆放位置</p>
</div>
<p>先考虑怎么表示这个约束条件</p>
<ol type="1">
<li>行约束可以通过逐行选择放入位置解决</li>
<li>列约束可以使用一个列选择数组</li>
<li>注意到主对角线上所有格子的<strong>行索引减列索引</strong>为恒定值,可以用数组 diags1 记录每条主对角线上是否有皇后</li>
<li>同理，次对角线上的所有格子的<strong>行索引加列索引</strong>是恒定值。我们同样也可以借助数组 diags2 来处理次对角线约束</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：n 皇后 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, vector&lt;vector&lt;string&gt;&gt; &amp;state, vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; &amp;res, vector&lt;<span class="type">bool</span>&gt; &amp;cols,</span></span></span><br><span class="line"><span class="params"><span class="function">               vector&lt;<span class="type">bool</span>&gt; &amp;diags1, vector&lt;<span class="type">bool</span>&gt; &amp;diags2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当放置完所有行时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 计算该格子对应的主对角线和次对角线</span></span><br><span class="line">        <span class="type">int</span> diag1 = row - col + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> diag2 = row + col;</span><br><span class="line">        <span class="comment">// 剪枝：不允许该格子所在列、主对角线、次对角线上存在皇后</span></span><br><span class="line">        <span class="keyword">if</span> (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：将皇后放置在该格子</span></span><br><span class="line">            state[row][col] = <span class="string">&quot;Q&quot;</span>;</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 放置下一行</span></span><br><span class="line">            <span class="built_in">backtrack</span>(row + <span class="number">1</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line">            <span class="comment">// 回退：将该格子恢复为空位</span></span><br><span class="line">            state[row][col] = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 n 皇后 */</span></span><br><span class="line">vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; <span class="built_in">nQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 初始化 n*n 大小的棋盘，其中 &#x27;Q&#x27; 代表皇后，&#x27;#&#x27; 代表空位</span></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">state</span>(n, <span class="built_in">vector</span>&lt;string&gt;(n, <span class="string">&quot;#&quot;</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cols</span><span class="params">(n, <span class="literal">false</span>)</span></span>;<span class="comment">// 记录列是否有皇后</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diags1</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录主对角线上是否有皇后</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diags2</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录次对角线上是否有皇后</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态规划">动态规划</h3>
<p>dp与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题，我们可以将前一个子问题转移到下一个状态视为一个决策，然后用回溯，这是一种穷举<br />
但动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性</p>
<ol type="1">
<li><strong>最优子结构</strong>:原问题的最优解是从子问题的最优解构建得来的，如带代价的楼梯问题中：<code>dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]</code><br />
</li>
<li><strong>无后效(马尔科夫)性</strong>：给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关
<ol type="1">
<li>并不是有无后效性就适合dp解决，计算和存储状态必然有开销，当开销过大时用dp会超时</li>
<li>通过增加状态的范围，可以使状态转移更复杂的问题也满足无后效性，但往往开销较大</li>
</ol></li>
</ol>
<p>例如，爬楼梯问题改成:<code>每步可以上1阶或者2阶，但不能连续两轮跳1阶</code>，就需要记录上一轮跳了1还是2阶<br />
状态<code>dp[i,j]</code>表示处在第i阶并且上一轮跳了j阶:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 带约束爬楼梯：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsConstraintDP</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>; dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>; dp[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i - <span class="number">2</span>][<span class="number">1</span>] + dp[i - <span class="number">2</span>][<span class="number">2</span>];<span class="comment">//也可以是dp[i] = dp[i-2] + dp[i-3]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">1</span>] + dp[n][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解题思路:</p>
<ol type="1">
<li>假定我们在一个状态，思考这个状态可以怎么表示，用例如一个n维向量记忆，由于是dp问题，我们假定每个状态都是截止目前最优的</li>
<li>找出状态转移的方式，例如爬楼梯问题只依赖于n-1和n-2的情况</li>
<li>选取一个特定的顺序开始遍历解决问题，需要确保
<ol type="1">
<li>填满初始化状态</li>
<li>确保之后每个状态依赖的子问题已经被算出了</li>
<li>选取合适终止条件</li>
</ol></li>
</ol>
<p>理论上讲，为了空间最优，每层计算只需要依赖子问题数量的空间复杂度，对一维dp来说:一般是O(1)，但一般来说存储马尔科夫链上的所有状态复杂度相对也可以接受(一般是O(N))</p>
<h4 id="背包问题">0-1背包问题</h4>
<div class="note default"><p>给定n个物品，第i个物品的重量为<code>wgt[i-1]</code>、价值为<code>val[i-1]</code>，和一个容量为cap的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值</p>
</div>
<p>很容易想到，我们应该把重量排序，然后依次决策，因此需要一个i状态表示当前物品编号，以及一个目前限制容量c，<code>dp[i,c]</code>则表示遍历到i为止限制容量是c时的最大价值<br />
选到i时，如果不选i，那和i-1一样，如果选i，此时容量减少，价值增加，且因为不能重复选择，也退回到i-1<br />
dp状态转移: $d p[i,c]=(d p[i-1,c],d p[i-1,c-w g t[i-1]]+v a l[i-1]) $<br />
而依赖关系呢？<code>dp[i,c]</code>依赖<code>dp[i - 1][c], dp[i - 1][c - wgt[i - 1]]</code>，也就是i只依赖i-1好知道，c依赖范围是取决于wgt的，因此i应该放外侧，每一行c都知道了才能到下一个i</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 0-1 背包：记忆化搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDFSMem</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mem, <span class="type">int</span> i, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 若已有记录，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i][c] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][c];</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能选择不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) <span class="keyword">return</span> <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> no = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> yes = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 记录并返回两种方案中价值更大的那一个</span></span><br><span class="line">    mem[i][c] = <span class="built_in">max</span>(no, yes);</span><br><span class="line">    <span class="keyword">return</span> mem[i][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0-1 背包：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) dp[i][c] = dp[i - <span class="number">1</span>][c];<span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i - <span class="number">1</span>][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);<span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.hello-algo.com/chapter_dynamic_programming/knapsack_problem/#4">空间优化</a></p>
<h4 id="完全背包问题">完全背包问题</h4>
<div class="note default"><p>给定n个物品，第i个物品的重量为<code>wgt[i-1]</code>、价值为<code>val[i-1]</code>，和一个容量为cap的背包。每个物品可以重复选取，问在限定背包容量下能放入物品的最大价值。示例如图14-22所示</p>
</div>
<p>类似0-1背包，选到i时，如果不选i，那和i-1一样，但如果选i，此时容量减少，价值增加，<strong>且因为可以重复选择</strong>，不用退回到i-1,还是i<br />
状态转移: <span class="math inline">\(d p[i,c]=\operatorname*{max}(d p[i-1,c],d p[i,c-w g t[i-1]]+v a l[i-1])\)</span><br />
而依赖关系呢？<code>dp[i,c]</code>依赖<code>dp[i - 1][c], dp[i][c - wgt[i - 1]]</code>，依赖方向依旧是左和上，但这次都是轴向，像之前一样的遍历顺序也是可以的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 完全背包：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unboundedKnapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) dp[i][c] = dp[i - <span class="number">1</span>][c];<span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);<span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.hello-algo.com/chapter_dynamic_programming/knapsack_problem/#4">空间优化</a></p>
<h5 id="找零问题">找零问题</h5>
<div class="note default"><p>给定n种硬币,第i种硬币的面值为<code>coins[i-1]</code>，目标金额为amt,每种硬币可以重复选取,问能够凑出目标金额的最少硬币数量。如果无法凑出自标金额，则返回-1</p>
</div>
<p><strong>零钱兑换可以看作完全背包问题的一种特殊情况</strong>，两者具有以下联系与不同点</p>
<ul>
<li>两道题可以相互转换，“物品”对应“硬币”、“物品重量”对应“硬币面值”、“背包容量”对应“目标金额”</li>
<li>优化目标相反，完全背包问题是要最大化物品价值，零钱兑换问题是要最小化硬币数量</li>
<li>完全背包问题是求“不超过”背包容量下的解，零钱兑换是求“恰好”凑到目标金额的解</li>
</ul>
<p>状态i,a对应的子问题为:前i种硬币能够凑出金额a的最少硬币数量,记为 <code>dp[i,a]</code><br />
如果不能找i硬币，那么和i-1一样，否则要和<code>dp[i][a-coins[i-1]]</code>取一个较小值<br />
事实上，类似完全背包，找零只有左和上方的依赖，这就意味着要实现最佳找a元，本质上只依赖于所有a-coin的最优解的最小值，也就是固定一个a，遍历i一遍就可以找到a的对应最优解，可以优化为一维<code>dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);//遍历每个可找的i</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 零钱兑换：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> MAX = amt + <span class="number">1</span>;<span class="comment">//处理无解情况</span></span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amt + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移：首行首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) dp[<span class="number">0</span>][a] = MAX;</span><br><span class="line">    <span class="comment">// 状态转移：其余行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) dp[i][a] = dp[i - <span class="number">1</span>][a];<span class="comment">//若超过目标金额，则不选硬币 i</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][a] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][a], dp[i][a - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);<span class="comment">//不选和选硬币 i 这两种方案的较小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt] != MAX ? dp[n][amt] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="找零问题2">找零问题2</h5>
<div class="note default"><p>给定n种硬币,第i种硬币的面值为<code>coins[i-1]</code>，目标金额为amt,每种硬币可以重复选取,问出目标金额的硬币组合数量</p>
</div>
<p>状态转移: <span class="math inline">\(d p[i,a]=d p[i-1,a]+d p[i,a-c o i n s[i-1]]\)</span><br />
即对每个i <span class="math inline">\(d p[a]=d p[a]+d p[a-c o i n s[i-1]]\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 零钱兑换 II：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeIIDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amt + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) dp[a] = dp[a]; <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">            <span class="keyword">else</span> dp[a] = dp[a] + dp[a - coins[i - <span class="number">1</span>]]; <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="编辑距离问题">编辑距离问题</h4>
<div class="note default"><p>输入两个字符串s和t，返回将s转换为t所需的最少编辑步数<br />
你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符</p>
</div>
<p>字符串s和t的长度分别为 n和m，我们先考虑两字符串尾部的字符<code>s[n-1],t[m-1]</code></p>
<ul>
<li>若相同，我们可以跳过它们,考虑n-2和m-2情况</li>
<li>若不同，需要对s进行一次编辑（插入、删除、替换），使得两字符串尾部的字符相同，从而可以跳过它们</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem.assets/edit_distance_state_transfer.png" /></p>
<p>状态转移如图所示，公式为 <span class="math inline">\(d p[i,j]=\operatorname*{min}(d p[i,j-1],d p[i-1,j],d p[i-1,j-1])+1\)</span><br />
<code>dp[i][j]</code>依赖左方、上方、左上方的解，依旧可以两层遍历<br />
tip:插入短字符串和删除长字符串在该问题里其实是等价的，可以省去一次计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 编辑距离：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistanceDP</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移：首行首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="comment">// 状态转移：其余行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 若两字符相等，则直接跳过此两字符</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>; <span class="comment">// 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem/#3">空间优化</a>略麻烦……</p>
<h3 id="贪心">贪心</h3>
<p>贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解<br />
只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解，这种条件相对苛刻，证明起来也很麻烦，因此没有完全把握最好不要用贪心<br />
典型的贪心算法问题：</p>
<ul>
<li><strong>硬币找零问题</strong>：在某些硬币组合下，贪心算法总是可以得到最优解</li>
<li><strong>区间调度问题</strong>：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解</li>
<li><strong>分数背包问题</strong>：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解</li>
<li><strong>股票买卖问题</strong>：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润</li>
<li><strong>霍夫曼编码</strong>：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小</li>
<li><strong>Dijkstra 算法</strong>：解决给定源顶点到其余各顶点的最短路径问题的贪心算法</li>
</ul>
<h4 id="分数背包问题">分数背包问题</h4>
<div class="note default"><p>给定n个物品，第i个物品的重量为<code>wgt[i-1]</code>、价值为<code>val[i-1]</code>，和一个容量为cap的背包。每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下背包中物品的最大价值</p>
</div>
<p>很容易用反证法证明，每次选择价格重量比最高的物品是最优策略，因为如果选择非最高的，那么换成最高的必然更优</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 物品 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> w; <span class="comment">// 物品重量</span></span><br><span class="line">    <span class="type">int</span> v; <span class="comment">// 物品价值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Item</span>(<span class="type">int</span> w, <span class="type">int</span> v) : <span class="built_in">w</span>(w), <span class="built_in">v</span>(v) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分数背包：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fractionalKnapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建物品列表，包含两个属性：重量、价值</span></span><br><span class="line">    vector&lt;Item&gt; items;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wgt.<span class="built_in">size</span>(); i++) items.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(wgt[i], val[i]));</span><br><span class="line">    <span class="comment">// 按照单位价值 item.v / item.w 从高到低进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), [](Item &amp;a, Item &amp;b) &#123; <span class="built_in">return</span> (<span class="type">double</span>)a.v / a.w &gt; (<span class="type">double</span>)b.v / b.w; &#125;);</span><br><span class="line">    <span class="comment">// 循环贪心选择</span></span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.w &lt;= cap) &#123;</span><br><span class="line">            <span class="comment">// 若剩余容量充足，则将当前物品整个装进背包</span></span><br><span class="line">            res += item.v;</span><br><span class="line">            cap -= item.w;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若剩余容量不足，则将当前物品的一部分装进背包</span></span><br><span class="line">            res += (<span class="type">double</span>)item.v / item.w * cap;</span><br><span class="line">            <span class="comment">// 已无剩余容量，因此跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最大容量问题">最大容量问题</h4>
<div class="note default"><p>输入一个数组ht，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器<br />
谷器的容量等于高度和宽度的乘积（面积），其中高度由较短的隔板决定，宽度是两入隔板的数组索引之差，请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量</p>
</div>
<p>从最大的宽度开始收缩，只有往短板方向收缩可能有更优情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 最大容量：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCapacity</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ht)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 i, j，使其分列数组两端</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = ht.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始最大容量为 0</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环贪心选择，直至两板相遇</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 更新最大容量</span></span><br><span class="line">        <span class="type">int</span> cap = <span class="built_in">min</span>(ht[i], ht[j]) * (j - i);</span><br><span class="line">        res = <span class="built_in">max</span>(res, cap);</span><br><span class="line">        <span class="comment">// 向内移动短板</span></span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; ht[j]) i++;</span><br><span class="line">        <span class="keyword">else</span> j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最大切分乘积问题">最大切分乘积问题</h4>
<div class="note default"><p>给定一个正整数n，将其切分为至少两个正整数的和，所有整数的乘积最大是多少</p>
</div>
<ul>
<li>当n&gt;= 4时,切分出一个2后乘积会变大(2(n-2) ≥n)，这说明大于等于4的整数都应该被切分<br />
</li>
<li>如果有3个2，乘积不如两个3，因此在切分方案中，最多只应存在两个2从而获得更大的乘积</li>
</ul>
<p>综上所述，可推理出以下贪心策略:</p>
<ol type="1">
<li>输入整数n，从其不断地切分出因子3，直至余数为0、1、2</li>
<li>当余数为0时,代表n是3的倍数，因此不做任何处理</li>
<li>3.当余数为2时，不继续划分，保留</li>
<li>当余数为 1时,由于2 × 2 &gt; 1 × 3,因此应将最后一个3替换为2</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 最大切分乘积：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProductCutting</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 n &lt;= 3 时，必须切分出一个 1</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 贪心地切分出 3 ，a 为 3 的个数，b 为余数</span></span><br><span class="line">    <span class="type">int</span> a = n / <span class="number">3</span>; <span class="type">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">2</span> * <span class="number">2</span>;<span class="comment">//当余数为 1 时，将一对 1 * 3 转化为 2 * 2</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">2</span>) <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a) * <span class="number">2</span>;<span class="comment">//当余数为 2 时，不做处理</span></span><br><span class="line">    <span class="comment">// 当余数为 0 时，不做处理</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="cpp基本输入输出">cpp基本输入输出</h2>
<div class="note info"><p>和考研无关但知道也不错:</p>
<ul>
<li>C 中的输入输出函数，如 scanf() 和 printf() 等，是非类型安全的：
<ul>
<li>它们依赖于格式化字符串来指示输入/输出数据的类型</li>
<li>如果格式化字符串不正确，就会导致不可预测的结果，如缓冲区溢出和未定义的行为</li>
</ul></li>
<li>C++ 中的输入输出函数，如 std::cin 和 std::cout 等，是类型安全的：
<ul>
<li>它们使用类型安全的 C++ 流语义，其中数据类型是静态确定的，而不是动态确定的</li>
<li>这意味着数据类型在编译时就已经确定，而不是在运行时根据格式化字符串动态确定</li>
<li>这种静态类型检查可以在编译时检测到类型不匹配的错误，从而使 C++ 的输入输出更加类型安全</li>
</ul></li>
<li>因此，scanf() 的参数需要使用格式化字符串来指定输入数据的类型，而 cin 和 std::cin 可以自动识别输入数据的类型</li>
</ul>
<p>cin 和 cout 是 C++ 的输入输出流，可以使用它们来实现控制台的输入输出操作 同步流（synchronized stream）的概念：</p>
<ul>
<li>同步流意味着在程序流中输出数据时，程序必须等到数据完全输出到设备上，然后才能继续执行后面的代码</li>
<li>同样，当程序尝试从输入设备读取数据时，程序会等待用户输入完整的数据，然后才能继续执行后面的代码</li>
<li>不止c++,c的scanf() 和 printf() 也实现了同步流，但其缓冲区的实现更为底层，效率更高</li>
<li>总得来说，c++输入输出依旧为了同步等高级功能牺牲了一定性能，但这些开销可以被我们手动关闭；关闭后每次读取输入时，输出缓存区不会被刷新</li>
</ul>
</div>
<ul>
<li>getchar()函数从标准输入（stdin）中读取一个字符，返回该字符的 ASCII 码值
<ul>
<li>通常用于读取单个字符或者字符数组，可以实现简单的输入操作</li>
<li>使用时需要注意的是，由于输入的字符是直接通过键盘输入的，因此需要按下回车键才能将输入的字符送入缓冲区，此时getchar()才能够读取到输入的内容</li>
</ul></li>
<li>getline()函数从输入流中读取一行文本(可以指定分隔符)，并将其存储到一个字符串对象中，可以读取包含空格在内的一整行输入
<ul>
<li>使用时需要注意的是，如果使用默认的分隔符 <code>\n</code>，getline() 会将换行符读取到缓冲区，如果下一次使用 getline() 读取输入，就会导致缓冲区中的换行符被读取，而不是期望的输入。此时可以通过调用cin.ignore()来清除缓冲区中的字符，或者指定其他分隔符</li>
<li>c++输入输出,当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待但是如果读取成功，字符后面的分隔符是残留在缓冲区的</li>
</ul></li>
<li>stringstream 是 C++ 标准库提供的一种数据流对象，用于在内存中对字符串进行输入输出操作
<ul>
<li>它可以像 cin 和 cout 一样进行输入输出，并且具有和输入输出流相似的接口和方法，例如 &lt;&lt; 和 &gt;&gt; 操作符</li>
<li>它提供了将一个字符串转换成一个数据类型的方法，方便程序员进行数据处理</li>
<li>在 C++ 中，stringstream 也是类型安全的</li>
</ul></li>
</ul>
<p>getline() 其参数实际上有三个，第三个参数为分隔符参数，即 getline() 会以该参数分割处理数据，默认缺省该参数的情况下，getline() 会以<code>\n</code>为分隔符，即默认我们使用的是<code>getline(cin, s, '\n')</code>;<br />
例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, s);  <span class="comment">//读入 string 类型 s</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;First: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//输出 s</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s);  <span class="comment">//在此读入</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//再次输出 s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于默认换行符分割，此次输出符合预期</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, s, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">//读入 string 类型 s，并以 &#x27;,&#x27; 为分隔符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;First: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//输出 s</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">//在此读入</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//再次输出 s，并以 &#x27;,&#x27; 为分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于分隔符换成&#x27;,&#x27;，输入流残留的&#x27;\n&#x27;会被下次输入时读取，产生以下输出</span></span><br><span class="line">First: <span class="number">114</span></span><br><span class="line">Second:</span><br><span class="line"><span class="number">514</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//建议对策:</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">//读入 string 类型 s</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;First: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//输出 s</span></span><br><span class="line"><span class="comment">// 使用 cin.ignore() 忽略掉输入缓冲区中的换行符</span></span><br><span class="line"><span class="comment">// 也可以使用 cin.get() 读取缓冲区中的换行符</span></span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"><span class="comment">// cin.get();</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">//在此读入</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//再次输出 s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>stringstream 和 cin、cout 等输入输出流都有类似的接口和方法，可以进行输入输出操作，但它们的作用域不同。cin、cout 等输入输出流通常用于标准输入输出流，而 stringstream 通常用于字符串的处理 通常我们可以使用 stringstream 对字符串进行分割、转换、拼接等操作，然后再使用 cin 或 cout 输出到标准输入输出流中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream s;</span><br><span class="line">    string name = <span class="string">&quot;yjsp&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">24</span>;</span><br><span class="line">    <span class="type">double</span> height = <span class="number">170.5</span>;</span><br><span class="line">    string status = <span class="string">&quot;is dust&quot;</span>;</span><br><span class="line">    s &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Height: &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;, Status: &quot;</span> &lt;&lt; status;</span><br><span class="line">    string str = s.<span class="built_in">str</span>();<span class="comment">//将所有插入的数据转换为一个字符串</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(ss &gt;&gt; str)&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;<span class="comment">//不断通过空格的划分赋值给str</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例题:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 计算a+b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a_plus_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;please input two numbers : &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) cout &lt;&lt; <span class="string">&quot;a+b is &quot;</span> &lt;&lt; a + b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s!= <span class="number">0</span>) &#123;</span><br><span class="line">            --s;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            sum+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s!= <span class="number">0</span>) &#123;</span><br><span class="line">            --s;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            sum+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string l;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,l))&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(l)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>,num;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;num) sum+=num;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串并排序输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_from_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string l;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, l)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(l)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, num;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; num) sum += num;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_strings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;<span class="comment">//初始化语法</span></span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; s) vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>();i != vec.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strings_withdot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        vector&lt;string&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, s, <span class="string">&#x27;,&#x27;</span>)) vec.<span class="built_in">push_back</span>(s);<span class="comment">//getline属于string头文件，可以指定分隔符 </span></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>;i++) cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        --a;</span><br><span class="line">        string t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>();i!=vec.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;<span class="comment">//初始化语法</span></span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; s) vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>();i!=vec.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        vector&lt;string&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss ,s ,<span class="string">&#x27;,&#x27;</span>)) vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>()<span class="number">-1</span>;i++) cout &lt;&lt; vec[i]&lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; *(--vec.<span class="built_in">end</span>()) &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="力扣热题-100-道题解">力扣热题 100 道题解</h2>
<h3 id="哈希">哈希</h3>
<p>题号:1 两数之和<br />
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标<br />
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素<br />
对数组的每个元素：</p>
<ol type="1">
<li>查找哈希表是否有其元素值对应的<code>&lt;k,v&gt;</code>,如果有，该<code>&lt;k,v&gt;</code>的 v 值就是其匹配的数组索引号</li>
<li>将 target 与该元素值的差作为 k，其索引作为 v 写入哈希表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;<span class="comment">// 暴力解法，O(N^2)</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp, result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = nums.<span class="built_in">begin</span>(); i != nums.<span class="built_in">end</span>();i++) temp.<span class="built_in">push_back</span>(target - *i);</span><br><span class="line">    <span class="type">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = nums.<span class="built_in">begin</span>(); i != nums.<span class="built_in">end</span>();i++) &#123;</span><br><span class="line">        <span class="type">int</span> index2 = index1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = temp.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>;t &lt; index2;t++) it++;</span><br><span class="line">        <span class="keyword">while</span> (it != temp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*i == *it) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(index1);</span><br><span class="line">                result.<span class="built_in">push_back</span>(index2);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        index1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(nums[i]) != hash.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123; i,hash[nums[i]] &#125;;</span><br><span class="line">        hash[target - nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:2 字母异位词分组<br />
给你一个字符串数组，请你将 <code>字母异位词(字母相同排列不同的单词)</code> 组合在一起可以按任意顺序返回结果列表<br />
由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键, 值则是字符串数组，最后将这些数组返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; um;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : strs) &#123;</span><br><span class="line">        string t = s;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        um[t].<span class="built_in">emplace_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : um) res.<span class="built_in">push_back</span>(i.second);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:3 最长连续序列<br />
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度<br />
请你设计并实现时间复杂度为 O(n) 的算法解决此问题<br />
不需要在原数组连续，因此可以用一个哈希集合去重，然后我们开始找连续序列，对遍历中遇到的任意值 x，如果它在一个连续序列中，那么必有从序列最大或者最小值开始找起的连续序列是存在<code>x</code>的序列中最长的这个性质，因此对遍历中的 x，先找到其所在序列末端，再一边删一遍记录长度<br />
时间复杂度：O(n)<br />
空间复杂度：O(n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line">    <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) us.<span class="built_in">emplace</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!us.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> i = *us.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (us.<span class="built_in">count</span>(i + <span class="number">1</span>)) ++i;</span><br><span class="line">        <span class="keyword">while</span> (us.<span class="built_in">count</span>(i)) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            us.<span class="built_in">erase</span>(i);</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针">双指针</h3>
<p>题号:1 移动零<br />
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序<br />
请注意 ，必须在不复制数组的情况下原地对数组进行操作<br />
设置慢指针用于遍历 0，快指针用于遍历慢指针后第一个非 0 元素</p>
<ol type="1">
<li>初始快慢指针均为 0</li>
<li>while 指针不越界，循环:
<ol type="1">
<li>如果慢指针处元素为 0:
<ol type="1">
<li>快指针移动到第一个非 0 元素或者越界函数终止</li>
<li>交换快慢指针的元素</li>
</ol></li>
<li>快慢指针均+1</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n &amp;&amp; slow&lt;n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (fast &lt;n &amp;&amp; nums[fast] == <span class="number">0</span>) ++fast;</span><br><span class="line">            <span class="keyword">if</span> (fast &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            nums[fast] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++slow;++fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以优先让快指针动:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:2 盛最多水的容器<br />
给定一个长度为 n 的整数数组 height 有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水 返回容器可以储存的最大水量 很明显最大水量是x轴差值乘以最短边，要更大就需要增加x轴距离或者加长最短边<br />
从x轴最远两端开始，如果改变相对长边，那么水量必然减少，移动相对短边则水量有可能增加，因此只要不断这样遍历记录最大水量就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>, max_ar = (j - i) * <span class="built_in">min</span>(height[i], height[j]);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[j]) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">        max_ar = <span class="built_in">max</span>(max_ar, (j - i) * <span class="built_in">min</span>(height[i], height[j]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_ar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:3 三数之和<br />
给你一个整数数组 nums ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 i != j、i != k 且 j != k ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 请你返回所有和为 0 且不重复的三元组</p>
<ol type="1">
<li>先排序，然后开始遍历(遍历时跳过重复值)</li>
<li>再给定一个值，很容易就能判断有没有第三个值k满足条件</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> t = nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">while</span> (k &gt; j &amp;&amp; t + nums[k] &gt; <span class="number">0</span>) --k;</span><br><span class="line">            <span class="keyword">if</span> (j == k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) res.<span class="built_in">push_back</span>(&#123; nums[i], nums[j], nums[k] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方解双指针:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 枚举 a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">        <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">        <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> target = -nums[first];</span><br><span class="line">        <span class="comment">// 枚举 b</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) --third;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">            <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (second == third) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[second] + nums[third] == target) res.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O( <span class="math inline">\(N^2\)</span> )，其中 N 是数组 nums 的长度<br />
空间复杂度：O(logN)我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)</p>
<p>题号:4 接雨水(hard)<br />
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) leftMax[i] = <span class="built_in">max</span>(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) rightMax[i] = <span class="built_in">max</span>(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res += <span class="built_in">min</span>(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口">滑动窗口</h3>
<p>题号:1 无重复字符的最长子串<br />
给定一个字符串s,请你找出其中不含有重复字符的最长的长度<br />
用i,j表示子串，对特定的i，用一个哈希集合可以得出当前最长不重复子串长度<br />
随后固定j，i向前滑动一个位置，集合移除其对应的字符，循环直到j滑到字符串尾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hash;</span><br><span class="line">    <span class="type">size_t</span> max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">    hash.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; !hash.<span class="built_in">count</span>(s[j])) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, hash.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span> (j == s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hash.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:2 找到字符串中所有字母异位词<br />
给定两个字符串s和p，找到s中所有p的异位词(对原词的重排列，用到所有原字符刚好一次)的子串，返回这些子串的起始索引不考虑答案输出的顺序</p>
<ol type="1">
<li>用一个26字符长的数组存储字符，如果我们把s和p窗口内相同的字符抵消掉，数组非0元素数即为他们差异数</li>
<li>此题窗口范围为plen,先计算第一个窗口情况，如果差异为0直接退出</li>
<li>开始右移，对每次右移:
<ol type="1">
<li>减去左侧字符，加上右侧字符，并判断差异变化</li>
<li>如果差异为0，退出，否则继续循环</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (sLen &lt; pLen) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;<span class="comment">//计算第一个窗口的字符情况</span></span><br><span class="line">        ++count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        --count[p[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> differ = <span class="number">0</span>;<span class="comment">//子串和p不同的字母数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) <span class="keyword">if</span> (count[j] != <span class="number">0</span>) ++differ;<span class="comment">//不为0的元素说明有差异</span></span><br><span class="line">    <span class="keyword">if</span> (differ == <span class="number">0</span>) res.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        --count[s[i] - <span class="string">&#x27;a&#x27;</span>];<span class="comment">//i右移移除对应count，正式的+1由for循环完成,接下来处理differ变化</span></span><br><span class="line">        <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) --differ;  <span class="comment">// 如果i处是多余字符，即count的对应值为1，i右移后differ会减少</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)  ++differ; <span class="comment">// 如果i处正好相抵，i右移后differ会增加</span></span><br><span class="line">        </span><br><span class="line">        ++count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)  --differ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)  ++differ; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) res.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子串">子串</h3>
<p>题号:1 和为 K 的子数组<br />
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数<br />
子数组是数组中元素的连续非空序列</p>
<ol type="1">
<li>创建一个哈希表，其k存储子数组和，其v存储对应这个和的子数组的数量</li>
<li>遍历原数组逐步向哈希表添加<code>1~k</code>的前缀和
<ol type="1">
<li>如果我们找到一个sum(i,j)满足题意，那么可得sum(0,j)-sum(0,i)==sum(i,j)==k</li>
<li>也就是说，sum(0,j)-k==sum(0,i),在哈希表里找到n个prefix-k,就有n个满足题意的子数组</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums) &#123;</span><br><span class="line">        pre += x;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(pre - k)) &#123;</span><br><span class="line">            count += mp[pre - k];</span><br><span class="line">        &#125;</span><br><span class="line">        mp[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组">数组</h3>
<p>题号:1 最大子数组和<br />
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<ol type="1">
<li>类似上一题，子数组的和可以用两端前缀和差表示，这次我们只需要最大值，因此只需要保留一个量，即当前元素之前的最小差，用目前为止的前缀和减去它就行了</li>
<li>事实上可以进一步化简，如果存储到前一个元素为止的最优解sum(i-1),最优解就是<code>sum(i)和nums[i]</code>二选一</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max_sum = nums[<span class="number">0</span>], pre_sum = max_sum, min_sum = <span class="built_in">min</span>(<span class="number">0</span>, nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        min_sum = <span class="built_in">min</span>(min_sum, pre_sum);</span><br><span class="line">        pre_sum += nums[i];</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, pre_sum - min_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray_sol2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, maxres = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;x: nums) &#123;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre + x, x);</span><br><span class="line">        maxres = <span class="built_in">max</span>(maxres, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxres;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 合并区间<br />
以数组 intervals 表示若干个区间的集合，其中单个区间为<code>intervals[i] = [starti, endi]</code>请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</p>
<p>可以合并的区间在排序后必然是连续的，排序后逐个遍历合并即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = &#123; intervals[<span class="number">0</span>] &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; intervals.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="type">int</span> tail = res.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= res[tail][<span class="number">1</span>]) &#123;</span><br><span class="line">            res[tail][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], res[tail][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 轮转数组<br />
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数</p>
<p>先分两部分转，最后整体转</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (end - start + <span class="number">1</span>) / <span class="number">2</span>;i++) <span class="built_in">swap</span>(nums[start + i], nums[end - i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    k %= nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - k - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(nums, nums.<span class="built_in">size</span>() - k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 除自身以外数组的乘积<br />
给你一个整数数组 nums，返回 数组 result ，其中 <code>result[i]</code> 等于 nums 中除 <code>nums[i]</code> 之外其余各元素的乘积<br />
题目数据保证数组nums之中任意元素的全部前缀元素和后缀的乘积都在32位整数范围内<br />
请不要使用除法，且在O(n)时间复杂度内完成此题</p>
<ol type="1">
<li>对任意一个元素,要求的积就是它的前后缀积之积，因此先求前缀积数组(由于是积，第一个元素为1)</li>
<li>从后往前可以一步步算后缀积和前缀积数组对应元素相乘，减少计算量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; size;i++) res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> right_product = nums[size - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = size - <span class="number">2</span>;j &gt;= <span class="number">0</span>;--j) &#123;</span><br><span class="line">        res[j] *= right_product;</span><br><span class="line">        right_product *= nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="矩阵">矩阵</h3>
<p>题号:1 矩阵置零<br />
给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 请使用 原地 算法</p>
<p>标记行列，然后清零<br />
有空间上更优的解法，但逻辑很麻烦，感觉记也记不住……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">col</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">                row[i] = col[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 螺旋矩阵<br />
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素</p>
<p>每四个方向是一圈，而对每个方向来说，其起始点和遍历数量只与圈数有关，因此可以不断循环直到结果数组满足要求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> dire = <span class="number">0</span>, cycle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() &gt;= m * n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">switch</span> (dire) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = cycle;j &lt; n - cycle;++j) res.<span class="built_in">emplace_back</span>(matrix[cycle][j]);</span><br><span class="line">        dire = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cycle + <span class="number">1</span>;i &lt; m - cycle;++i) res.<span class="built_in">emplace_back</span>(matrix[i][n - <span class="number">1</span> - cycle]);</span><br><span class="line">        dire = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - cycle - <span class="number">2</span>;j &gt;= cycle;--j) res.<span class="built_in">emplace_back</span>(matrix[m - <span class="number">1</span> - cycle][j]);</span><br><span class="line">        dire = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">2</span> - cycle;i &gt;= <span class="number">1</span> + cycle;--i) res.<span class="built_in">emplace_back</span>(matrix[i][cycle]);</span><br><span class="line">        dire = <span class="number">0</span>;</span><br><span class="line">        ++cycle;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:3 旋转图像<br />
给定一个 n × n 的二维矩阵 matrix 表示一个图像请你将图像顺时针旋转 90 度<br />
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵请不要 使用另一个矩阵来旋转图像</p>
<p>画个图就能看出，矩阵第k行被翻转到结果矩阵的n-1-k列,k从0开始 即关键等式: <code>matrix[row][col]=matrixnew​[col][n−row−1]</code><br />
可以递推坐标映射公式,更方便的做法是先行翻转得到<code>matrixnew​[n−row−1][col]</code>然后对角线翻转得到<code>matrixnew​[col][n−row−1]</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate2</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) <span class="built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 搜索二维矩阵 II<br />
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列</li>
<li>每列的元素从上到下升序排列</li>
</ul>
<p>鉴于矩阵各行行内的有序性，可以直接在各行内二分查找</p>
<p>对任意元素，如果存在的话，其右侧和下方元素比它更大，左侧和上方元素比它小,因此:</p>
<ol type="1">
<li>从右上角或者左下角开始，不断舍弃矩阵不正确的部分</li>
<li>若当前元素大于target,其左上方元素必然比它小，舍弃，即向右或者向下</li>
<li>相反情况下，其右下方元素必然比它大，舍弃，即向左或者向上</li>
<li>大小情况下各自只能在上下，左右方向里选不同的一对情况舍入，否则会提前跑出范围</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row: matrix) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(row.<span class="built_in">begin</span>(), row.<span class="built_in">end</span>(), target);</span><br><span class="line">            <span class="keyword">if</span> (it != row.<span class="built_in">end</span>() &amp;&amp; *it == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix2</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &gt; target) --x;</span><br><span class="line">            <span class="keyword">else</span> ++y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix3</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> x = m<span class="number">-1</span>, y =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;=<span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[x][y] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &gt; target) --x;</span><br><span class="line">        <span class="keyword">else</span> ++y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="链表">链表</h3>
<p>题号:1 相交链表<br />
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点如果两个链表不存在相交节点，返回 null</p>
<p>这题有很多思路，例如用哈希表检测碰撞，求出两者长度然后让遍历长链表到和短链表有相同剩余长度的位置，再一起同步检测<br />
下面是使用双指针的做法:</p>
<p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null<br />
当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点具体做法如下</p>
<ul>
<li>每步操作需要同时更新指针 pA 和 pB</li>
<li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点</li>
<li>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点</li>
<li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null</li>
</ul>
<p>相当于同时遍历A+B和B+A,假设没有公共点，会在遍历完两链表相加的长度后终止，否则会在各自遍历完一次各自的链表后交换后的那次遍历中间相遇(除非两链表长度一致)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">NULL</span> || headB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* pA = headA;</span><br><span class="line">    ListNode* pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="literal">NULL</span> ? headB : pA-&gt;next;</span><br><span class="line">        pB = pB == <span class="literal">NULL</span> ? headA : pB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>题号:2 反转链表<br />
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表</p>
<p>迭代法很基础，递归法需要先压栈到最后一个节点，然后每轮修改后一个节点的指向到前一个节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* p = head, * q = head-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (q) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q-&gt;next;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            直到当前节点的下一个节点为空时返回当前节点</span></span><br><span class="line"><span class="comment">            由于5没有下一个节点了，所以此处返回节点5</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归传入下一个节点，目的是为了到达最后一个节点</span></span><br><span class="line">    ListNode newHead = <span class="built_in">reverseList</span>(head.next);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">        第一轮出栈，head为5，head.next为空，返回5</span></span><br><span class="line"><span class="comment">        第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，</span></span><br><span class="line"><span class="comment">                    把当前节点的子节点的子节点指向当前节点</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5</span></span><br><span class="line"><span class="comment">                    返回节点5</span></span><br><span class="line"><span class="comment">        第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                    返回节点5</span></span><br><span class="line"><span class="comment">        第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                    返回节点5</span></span><br><span class="line"><span class="comment">        第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，</span></span><br><span class="line"><span class="comment">                    此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null</span></span><br><span class="line"><span class="comment">                    此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                    返回节点5</span></span><br><span class="line"><span class="comment">        出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 回文链表<br />
给你一个单链表的头节点 head ，请你判断该链表是否为 回文链表 如果是，返回 true ；否则，返回 false</p>
<p>容易想到先转化数组再比对<br />
不顾及优雅的话，可以用一个外部变量正向迭代，辅以递归反向迭代(我个人喜欢创造函数局部值然后辅助函数传引用)<br />
也可以用快慢指针，慢指针走到中点，然后从中点开始反转链表(n/2复杂度)，再逐个比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* frontPointer;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* currentNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        frontPointer = frontPointer-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome_recur</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    frontPointer = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断该链表是否为回文链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!fast) <span class="keyword">break</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = <span class="built_in">reverseList</span>(slow);</span><br><span class="line">    <span class="keyword">while</span> (head &amp;&amp; slow) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val != slow-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 环形链表 给你一个链表的头节点 head ，判断链表中是否有环<br />
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）注意：pos 不作为参数进行传递 仅仅是为了标识链表的实际情况<br />
如果链表中存在环 ，则返回 true 否则，返回 false</p>
<p>经典的快慢指针例题，不赘述<br />
此外，这种找环的通解也可以用哈希做</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!fast) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle_hash</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; seen;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seen.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        seen.<span class="built_in">insert</span>(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 环形链表 II<br />
给定一个链表的头节点 head ，返回链表开始入环的第一个节点 如果链表无环，则返回 null<br />
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）如果 pos 是 -1，则在该链表中没有环注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况<br />
不允许修改链表</p>
<p>经典解法哈希和上一题类似</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" /> 还是用上一题的快慢指针,设链表中环外部分的长度为 aslow 指针进入环后，又走了 b 的距离与 fast 相遇,到环前最后一个结点剩下距离为c此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc<br />
即a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br />
当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置最终，它们会在入环点相遇</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            ListNode* ptr = head;</span><br><span class="line">            <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:6 合并两个有序链表<br />
将两个升序链表合并为一个新的 升序 链表并返回新链表是通过拼接给定的两个链表的所有节点组成的</p>
<p>基础链表题之一，迭代和递归都很好理解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode&#123;&#125;;</span><br><span class="line">    ListNode* tail = head, * t;</span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        t = list1-&gt;val &lt; list2-&gt;val ? list1 : list2;</span><br><span class="line">        <span class="keyword">if</span> (t == list1) list1 = list1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> list2 = list2-&gt;next;</span><br><span class="line">        tail-&gt;next = t;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = (!list1) ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == null) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == null) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = <span class="built_in">mergeTwoLists</span>(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = <span class="built_in">mergeTwoLists</span>(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:7 两数相加<br />
给你两个 非空 的链表，表示两个非负的整数它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字<br />
请你将两个数相加，并以相同形式返回一个表示和的链表<br />
你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<p>模拟位加法，记得保留进位信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *head = <span class="literal">nullptr</span>, *tail = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">        <span class="type">int</span> n1 = l1 ? l1-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n2 = l2 ? l2-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = n1 + n2 + carry;</span><br><span class="line">        <span class="keyword">if</span> (!head) head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:8 删除链表的倒数第N个节点<br />
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点</p>
<p>双指针的又一次奇技淫巧,让快指针先跑n步，然后快慢指针一起遍历到结束<br />
小心几个边界情况:</p>
<ol type="1">
<li>要删去倒数第n个节点，准确地说我们需要这个节点的前一个节点，因此可以让它空过一次或者从一个无实值头结点开始，也可以像我这样直接做一个Pre指针出来</li>
<li>如果要删头结点，也就是没有Pre的情况，需要特别判断</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, * slow = head, * pre =slow;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) fast = fast-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre == slow) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    pre-&gt;next = slow-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:9 两两交换链表中的节点<br />
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）<br />
<img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" /></p>
<p>递归:找不出一对相邻节点时终止返回,返回值实际上作为每一对的下个节点，也就是原来的左节点指向后继节点，随后把原来的右节点指向左节点，就完成了每层的任务<br />
迭代:类似递归一对一对地进行，但需要加一个头结点存储结果和保留先驱节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs_recur</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = head.next;</span><br><span class="line">    head.next = <span class="built_in">swapPairs_recur</span>(newHead.next);</span><br><span class="line">    newHead.next = head;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead =<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    ListNode* temp = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;<span class="comment">//之后两个节点都存在时才可以交换</span></span><br><span class="line">        ListNode* node1 = temp-&gt;next;</span><br><span class="line">        ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">        temp-&gt;next = node2;</span><br><span class="line">        node1-&gt;next = node2-&gt;next;</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        temp = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* res = dummyHead-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:10 随机链表的复制 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点<br />
构造这个链表的 深拷贝 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态复制链表中的指针都不应指向原链表中的节点<br />
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y<br />
返回复制链表的头节点</p>
<p>本题主要难点在于，如何指向一个随机(可能还没有被复制)的结点:</p>
<ol type="1">
<li>最简单的做法莫过于用哈希表存储原节点到复制结点的映射，然后再一一把随机指针迭代创建，这样相当于需要遍历两次，复杂度的数量级还是n，但数值较高</li>
<li>类似的思路也可以用递归做，每轮如果查哈希表失败，就创建新节点，然后对next和random指针也递归，最后返回被复制的节点给上层使用<br />
</li>
<li>为了把空间复杂度降到常数级，可以将该链表中每一个节点拆分为两个相连的节点，例如对于链表 A→B→C，我们可以将其拆分为 A→A′→B→B′→C→C′对于任意一个原节点 S，其拷贝节点 S′ 即为其后继节点但对尾节点需要进行特别处理</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; cachedNode;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Node* t = head;</span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">        Node* headNew = <span class="keyword">new</span> <span class="built_in">Node</span>(t-&gt;val);</span><br><span class="line">        cachedNode[t] = headNew;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : cachedNode) &#123;</span><br><span class="line">        Node* n0 = n.first;</span><br><span class="line">        Node* n1 = n.second;</span><br><span class="line">        n1-&gt;next = n0-&gt;next == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : cachedNode[n0-&gt;next];</span><br><span class="line">        n1-&gt;random = n0-&gt;random == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : cachedNode[n0-&gt;random];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;Node*, Node*&gt; cachedNode;</span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList_recur</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!cachedNode.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">        Node* headNew = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        cachedNode[head] = headNew;</span><br><span class="line">        headNew-&gt;next = <span class="built_in">copyRandomList_recur</span>(head-&gt;next);</span><br><span class="line">        headNew-&gt;random = <span class="built_in">copyRandomList_recur</span>(head-&gt;random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList_best</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">        Node* nodeNew = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        nodeNew-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = nodeNew;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">        Node* nodeNew = node-&gt;next;</span><br><span class="line">        nodeNew-&gt;random = (node-&gt;random != <span class="literal">nullptr</span>) ? node-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* headNew = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">        Node* nodeNew = node-&gt;next;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        nodeNew-&gt;next = (nodeNew-&gt;next != <span class="literal">nullptr</span>) ? nodeNew-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:11 排序链表<br />
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表</p>
<p>说起排序链表，最自然的想法必然是插入排序，但这样时间复杂度较高<br />
再比如可以用哈希表,k为链表结点值，v是链表指针，根据k排序完再组起来，这样空间复杂度很高<br />
最完美的办法就只有归并了，而且为了空间能O(1),还得自底向上</p>
<p>大致的思路:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    ListNode* node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> subLength = <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ListNode* prev = dummyHead, *curr = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* head1 = curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr-&gt;next != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* head2 = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            curr = head2;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">nullptr</span> &amp;&amp; curr-&gt;next != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                next = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* merged = <span class="built_in">merge</span>(head1, head2);</span><br><span class="line">            prev-&gt;next = merged;</span><br><span class="line">            <span class="keyword">while</span> (prev-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">    <span class="keyword">while</span> (temp1 != <span class="literal">nullptr</span> &amp;&amp; temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">            temp1 = temp1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">            temp2 = temp2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp-&gt;next = temp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp-&gt;next = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:12 LRU缓存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="type">int</span> _key, <span class="type">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> _capacity): <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二叉树">二叉树</h3>
<p>题号:1 二叉树的中序遍历<br />
给定一个二叉树的根节点 root ，返回 它的 中序 遍历</p>
<p>递归实现非常基础，迭代法需要用到栈:</p>
<ol type="1">
<li>一路往左子树走入栈</li>
<li>无路可走后，出栈一个节点输出</li>
<li>往出栈节点的右子树走</li>
</ol>
<p>类似的，遍历可以只用出入栈操作实现<br />
先序(中左右):初始入栈根节点，每次出栈输出一个节点，然后以右左子节点顺序入栈<br />
后序(左右中):一路往左子树走，每次出栈时我们需要一个flag标志保存最后一个输出节点(标记右子树有没有走过)，如果没有右孩子或者flag==右孩子直接输出，否则右节点先入栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (root || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            st.<span class="built_in">emplace</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            root = st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 二叉树最大深度<br />
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 翻转二叉树<br />
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">invert_helper</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">    <span class="built_in">invert_helper</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">invert_helper</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">invert_helper</span>(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 对称二叉树<br />
判断二叉树是否对称<br />
你可能会自然想到递归，但问题是我们需要沿着对称轴递归判断，也就是需要两个参数<br />
迭代实现就是两个栈同步在两个子树上出入栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; st1, st2;</span><br><span class="line">    TreeNode* p1 = root;</span><br><span class="line">    TreeNode* p2 = p1;</span><br><span class="line">    st1.<span class="built_in">emplace</span>(p1);</span><br><span class="line">    st2.<span class="built_in">emplace</span>(p2);</span><br><span class="line">    <span class="keyword">while</span> (!st1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        p1 = st1.<span class="built_in">top</span>();st1.<span class="built_in">pop</span>();</span><br><span class="line">        p2 = st2.<span class="built_in">top</span>();st2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> ((p1 &amp;&amp; !p2) || (p2 &amp;&amp; !p1)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p1) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st1.<span class="built_in">push</span>(p1-&gt;left);</span><br><span class="line">            st1.<span class="built_in">push</span>(p1-&gt;right);</span><br><span class="line">            st2.<span class="built_in">push</span>(p2-&gt;right);</span><br><span class="line">            st2.<span class="built_in">push</span>(p2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 二叉树的直径<br />
给你一棵二叉树的根节点，返回该树的直径<br />
二叉树的直径是指树中任意两个节点之间最长路径的长度这条路径可能经过也可能不经过根节点 root<br />
两节点之间路径的长度由它们之间边数表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxd =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Left = <span class="built_in">depth</span>(node-&gt;left);</span><br><span class="line">    <span class="type">int</span> Right = <span class="built_in">depth</span>(node-&gt;right);</span><br><span class="line">    maxd=<span class="built_in">max</span>(Left+Right,maxd);<span class="comment">//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(Left,Right)+<span class="number">1</span>;<span class="comment">//返回节点深度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">depth</span>(root);</span><br><span class="line">    <span class="keyword">return</span> maxd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:6 二叉树层序遍历</p>
<p>迭代做很简单，逐层入队列就行<br />
递归需要带深度信息，例如父节点的索引号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector &lt;vector &lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    queue &lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(vector &lt;<span class="type">int</span>&gt; ());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ret.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:7 将有序数组转化为平衡二叉搜索树<br />
平衡条件可以直观地想到每次二分法建树<br />
要注意的是，此题的树形不唯一，这里直接用c++的除法(向下取整)找根节点<br />
每次递归传入一个数组范围，若范围只有一个元素，直接返回新节点，否则建立根节点，递归左右子节点再返回根节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST_helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> head, <span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head &gt; tail) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[head]);</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    <span class="type">int</span> mid = (tail + head) / <span class="number">2</span>;</span><br><span class="line">    node-&gt;val = nums[mid];</span><br><span class="line">    node-&gt;left = <span class="built_in">sortedArrayToBST_helper</span>(nums, head, mid - <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">sortedArrayToBST_helper</span>(nums, mid + <span class="number">1</span>, tail);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> mid = nums.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">    root-&gt;left = <span class="built_in">sortedArrayToBST_helper</span>(nums, <span class="number">0</span>, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">sortedArrayToBST_helper</span>(nums, mid + <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:8 验证二叉搜索树<br />
此题中左右子节点有严格大小关系<br />
本题难点在于，想从上而下校验需要知道子节点的最大最小值才能判断，因此需要逆转思路，不是从上至下校验，而是从上至下限制范围，每次往下递归，都增加一个最大或者最小值限制，只要有不满足的子节点就判false<br />
此外对BST中序遍历必然是一个升序序列，可以以此判断 此外，此题阴的是数值范围是long long，用int过不了用例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isValidBST_helper</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> min_val, <span class="type">long</span> <span class="type">long</span> max_val, <span class="type">bool</span>&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!res || !root) <span class="keyword">return</span>;<span class="comment">//检验失败或root为空则退出</span></span><br><span class="line">    <span class="keyword">if</span> (min_val &gt;= root-&gt;val || root-&gt;val &gt;= max_val) &#123; res = <span class="number">0</span>;  <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">isValidBST_helper</span>(root-&gt;left, min_val, root-&gt;val, res);</span><br><span class="line">    <span class="built_in">isValidBST_helper</span>(root-&gt;right, root-&gt;val, max_val, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* roots)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">isValidBST_helper</span>(roots, LONG_MIN, LONG_MAX, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST_iter</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> inorder = (<span class="type">long</span> <span class="type">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= inorder) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder = root -&gt; val;</span><br><span class="line">        root = root -&gt; right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:9 二叉搜索树中第 K 小的元素<br />
给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）</p>
<p>迭代法可以模拟中序遍历来不断根据大小顺序生成元素，这样只有h+k的复杂度，但这个h是一路往左的子树，最坏情况有n长 考虑要多次进行这样操作的情况，例如可以新建一个结点类，带一个序号值，或者只用一个哈希表存储各个节点的左侧结点数<br />
只要查一次的话可以省略哈希表，不断根据左侧结点数选择要往哪走，这样做最坏情况会O(N)，即左子树有n-1个结点，而我们要找最小元素，之后就会一个个地往左走，总共2n左右次操作,性能和迭代差不多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        --k;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">node_num_of_tree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">node_num_of_tree</span>(root-&gt;left) + <span class="built_in">node_num_of_tree</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthSmallest_helper</span><span class="params">(TreeNode* root, <span class="type">const</span> <span class="type">int</span>&amp; k, <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//n表示root这个节点的大小顺序</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == k) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; k) <span class="keyword">return</span> <span class="built_in">kthSmallest_helper</span>(root-&gt;right, k, <span class="built_in">node_num_of_tree</span>(root-&gt;right-&gt;left) + n + <span class="number">1</span>);<span class="comment">//由于题目必然有解，此时root必存在右孩子</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kthSmallest_helper</span>(root-&gt;left, k, n - <span class="built_in">node_num_of_tree</span>(root-&gt;left-&gt;right) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">kthSmallest_helper</span>(root, k, <span class="number">1</span> + <span class="built_in">node_num_of_tree</span>(root-&gt;left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:10 二叉树的右视图<br />
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值<br />
实际上就是需要遍历每一层的最右侧节点:</p>
<ol type="1">
<li>深度遍历，优先从右侧走，也就是左节点先入栈，但同时需要维护深度信息，用一个深度栈维护</li>
<li>广度遍历，由于走到每层的最后就是我们要找的节点，所以不需要深度信息，这里我使用的两栈交替法解决判断每层结束，这样空间复杂度会稍高，但逻辑很好理解</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView_dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rightmostValueAtDepth;</span><br><span class="line">    <span class="type">int</span> max_depth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; depthStack;</span><br><span class="line">    nodeStack.<span class="built_in">push</span>(root);</span><br><span class="line">    depthStack.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = nodeStack.<span class="built_in">top</span>();nodeStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> depth = depthStack.<span class="built_in">top</span>();depthStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 维护二叉树的最大深度</span></span><br><span class="line">            max_depth = <span class="built_in">max</span>(max_depth, depth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不存在对应深度的节点我们才插入</span></span><br><span class="line">            <span class="keyword">if</span> (!rightmostValueAtDepth.<span class="built_in">count</span>(depth)) rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line"></span><br><span class="line">            nodeStack.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">            nodeStack.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">            depthStack.<span class="built_in">push</span>(depth + <span class="number">1</span>);</span><br><span class="line">            depthStack.<span class="built_in">push</span>(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rightView;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> depth = <span class="number">0</span>; depth &lt;= max_depth; ++depth) rightView.<span class="built_in">push_back</span>(rightmostValueAtDepth[depth]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rightView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView_bfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    queue&lt;TreeNode*&gt; qe1, qe2;</span><br><span class="line">    qe1.<span class="built_in">emplace</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = &#123; root-&gt;val &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!qe1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = qe1.<span class="built_in">front</span>();qe1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) qe2.<span class="built_in">emplace</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) qe2.<span class="built_in">emplace</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qe2.<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(qe2.<span class="built_in">back</span>()-&gt;val);</span><br><span class="line">        <span class="built_in">swap</span>(qe1, qe2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:11 二叉树展开为链表<br />
给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同</li>
</ul>
<p>先序遍历也就是中左右顺序，也就是需要不断把左子树插进父节点和右节点之间，可以理解为不断把左子树的最右节点(根据先序遍历顺序，该节点必是右子树的前驱)插入右子树前 或者 不断把左子树插到父节点与右节点之间(左子树根节点必然是父节点的直接后驱)<br />
我们可以用使用以上操作的(迭代)先序遍历实现算法，我们知道先序遍历的栈实现就是不断以右左顺序压栈，而栈顶元素必然是最后一个访问元素prev的最左孩子(直接后驱)，因此可以在遍历过程中不断把prev节点的左子树清空，右子树改成栈顶节点</p>
<p>要省下栈空间，可以不断寻找前驱节点，由于我们只需要不断处理左子树:</p>
<ol type="1">
<li>根节点开始向右走直到遇到左子树l，寻找前驱节点pre，即左子树的最右节点</li>
<li>"断开"右子树r，把前驱节点连到被断开部分的开头</li>
<li>把l连到父节点p的右子树上，并将父节点的左子树设为空此时连接关系是<code>p-&gt;l-&gt;pre-&gt;r</code>但l和r里可能还有左子树</li>
<li>对p处理结束后，转到1继续循环直到遇到叶节点</li>
</ol>
<p>本题的关键就是理解链接的顺序，即不断从根节点开始链接最左的孩子，直到所有节点没有左孩子<br />
例如最后一种的递归做法，维护一个last表示链表尾,对有左子树的当前链表，递归将左子树与根节点链接，对只有右子树的当前链表，将目前链表尾接到右子树上再递归<br />
也就是说不断找前驱和不断找后驱都是可以的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> stk = <span class="built_in">stack</span>&lt;TreeNode*&gt;(&#123;root&#125;);</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* curr = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = curr-&gt;left, * right = curr-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">nullptr</span>) stk.<span class="built_in">push</span>(right);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">nullptr</span>) stk.<span class="built_in">push</span>(left);</span><br><span class="line">        prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten_best</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode* curr = root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode* next = curr-&gt;left;</span><br><span class="line">            TreeNode* predecessor = next;</span><br><span class="line">            <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span>) predecessor = predecessor-&gt;right;</span><br><span class="line">            predecessor-&gt;right = curr-&gt;right;<span class="comment">//对一个节点来说，其右孩子先序遍历的前驱是左孩子最右的子节点</span></span><br><span class="line">            curr-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            curr-&gt;right = next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">flatten_recur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">subflatten</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">subflatten</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    TreeNode right = root.right;</span><br><span class="line">    TreeNode last = root; <span class="comment">//左右为空时返回root</span></span><br><span class="line">    root.left=null;</span><br><span class="line">    <span class="keyword">if</span>(left!=null) &#123;</span><br><span class="line">        root.right = left;</span><br><span class="line">        last = <span class="built_in">subflatten</span>(left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right!=null)&#123;</span><br><span class="line">        last.right = right;</span><br><span class="line">        last = <span class="built_in">subflatten</span>(right);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> last;<span class="comment">//返回链表的最后一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:12 从前序与中序遍历序列构造二叉树<br />
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点<br />
这题属于原理容易理解但实现复杂的类型,个人认为掌握递归法就够了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree_helper</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right, <span class="type">const</span> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder_left &gt; preorder_right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">    <span class="type">int</span> preorder_root = preorder_left;</span><br><span class="line">    <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">    <span class="type">int</span> inorder_root = index.<span class="built_in">at</span>(preorder[preorder_root]);</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">    <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">    <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">    <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">    root-&gt;left = <span class="built_in">BuildTree_helper</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>, index);</span><br><span class="line">    <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">    <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">    root-&gt;right = <span class="built_in">BuildTree_helper</span>(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right, index);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 构造哈希映射，用于快速定位根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        index[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BuildTree_helper</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree_iter</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preorder.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="type">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; preorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> preorderVal = preorder[i];</span><br><span class="line">        TreeNode* node = stk.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorderVal);</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                node = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                ++inorderIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorderVal);</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:13 路径总和 III<br />
给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目<br />
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）</p>
<p>虽然是二叉树，但本题完全可以看做动态规划问题来做(只需要求路径数量)，通过在遍历时缓存前缀和大小及数量，就可以以线性复杂度解决此题<br />
还有一个问题是对任意结点，它能查到的前缀和必然是它的父级节点所有的，也就在这条dst路径上，因此在遍历完子节点后必须删除计数值<br />
以及，此题又非常幽默地用了long long输入范围，也不知道图什么</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum_helper</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> curr, <span class="type">int</span> targetSum, unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    curr += root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (prefix.<span class="built_in">count</span>(curr - targetSum)) ret = prefix[curr - targetSum];</span><br><span class="line">    prefix[curr]++;</span><br><span class="line">    ret += <span class="built_in">pathSum_helper</span>(root-&gt;left, curr, targetSum, prefix);</span><br><span class="line">    ret += <span class="built_in">pathSum_helper</span>(root-&gt;right, curr, targetSum, prefix);</span><br><span class="line">    prefix[curr]--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; prefix;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pathSum_helper</span>(root, <span class="number">0</span>, targetSum, prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:14 最近公共祖先<br />
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先</p>
<ol type="1">
<li>递归:由于递归会先递归到叶节点然后自底向上匹配，所以匹配成功的必然是最近公共祖先，而这个祖先有两种情况
<ol type="1">
<li>左右侧各有这两个节点中的一个</li>
<li>祖先本身是一个节点，还有一个是其子节点</li>
<li>根据两个条件可以建立相应递归函数，注意lson,rson判定和祖先判定是两种逻辑</li>
</ol></li>
<li>建立子节点到父节点的哈希表，标记一个节点的所有父节点匹配另一个节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TreeNode* res;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> lson = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">    <span class="type">bool</span> rson = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">        res = root;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor_recur</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root, p, q);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lowestCommonAncestor_helper</span><span class="params">(TreeNode* root, unordered_map&lt;<span class="type">int</span>, TreeNode*&gt;&amp; fa)</span> </span>&#123;<span class="comment">//构建子节点到父节点的链接</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">        <span class="built_in">lowestCommonAncestor_helper</span>(root-&gt;left, fa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">        <span class="built_in">lowestCommonAncestor_helper</span>(root-&gt;right, fa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, TreeNode*&gt; fa;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line">    fa[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">lowestCommonAncestor_helper</span>(root, fa);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;<span class="comment">//一路标记p的父节点</span></span><br><span class="line">        vis[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">        p = fa[p-&gt;val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[q-&gt;val]) <span class="keyword">return</span> q;</span><br><span class="line">        q = fa[q-&gt;val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:15 BST的AVL化<br />
给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种<br />
如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过1，我们就称这棵二叉搜索树是平衡的</p>
<p>此题可以转化为中序序列建树问题，当然为什么能转化需要证明，见<a href="https://leetcode.cn/problems/balance-a-binary-search-tree/solutions/241897/jiang-er-cha-sou-suo-shu-bian-ping-heng-by-leetcod/">题解</a><br />
考场上不需要证明，直接写就行了，毕竟这个结论很符合直觉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; inorderSeq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getInorder</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;left) <span class="built_in">getInorder</span>(o-&gt;left);</span><br><span class="line">    inorderSeq.<span class="built_in">push_back</span>(o-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;right) <span class="built_in">getInorder</span>(o-&gt;right); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    TreeNode* o = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(inorderSeq[mid]);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid - <span class="number">1</span>) o-&gt;left = <span class="built_in">build</span>(l, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= r) o-&gt;right = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getInorder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">build</span>(<span class="number">0</span>, inorderSeq.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="图论">图论</h3>
<p>题号:1 岛屿数量<br />
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量<br />
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成<br />
此外，你可以假设该网格的四条边均被水包围</p>
<p>此题可以用bfs做，但有些麻烦的细节，写的时候要小心四个方向的索引别写错，每次找到新岛屿再建队列等小问题<br />
可以使用如下题的方向向量数组优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_outside</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">const</span> <span class="type">int</span>&amp; m, <span class="type">const</span> <span class="type">int</span>&amp; n, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>();<span class="comment">//行数</span></span><br><span class="line">    <span class="type">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; qe;</span><br><span class="line">                qe.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> p = qe.<span class="built_in">front</span>();qe.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> ti = p.first, tj = p.second;</span><br><span class="line">                    <span class="keyword">if</span> (grid[ti][tj] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;<span class="comment">//遇到水终止操作</span></span><br><span class="line">                    grid[ti][tj] = <span class="string">&#x27;2&#x27;</span>; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_outside</span>(ti - <span class="number">1</span>, tj, m, n, grid) &amp;&amp; grid[ti - <span class="number">1</span>][tj] == <span class="string">&#x27;1&#x27;</span>) &#123; qe.<span class="built_in">emplace</span>(ti - <span class="number">1</span>, tj); grid[ti - <span class="number">1</span>][tj] = <span class="string">&#x27;2&#x27;</span>; &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_outside</span>(ti + <span class="number">1</span>, tj, m, n, grid) &amp;&amp; grid[ti + <span class="number">1</span>][tj] == <span class="string">&#x27;1&#x27;</span>) &#123; qe.<span class="built_in">emplace</span>(ti + <span class="number">1</span>, tj); grid[ti + <span class="number">1</span>][tj] = <span class="string">&#x27;2&#x27;</span>; &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_outside</span>(ti, tj - <span class="number">1</span>, m, n, grid) &amp;&amp; grid[ti][tj - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; qe.<span class="built_in">emplace</span>(ti, tj - <span class="number">1</span>); grid[ti][tj - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>; &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_outside</span>(ti, tj + <span class="number">1</span>, m, n, grid) &amp;&amp; grid[ti][tj + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; qe.<span class="built_in">emplace</span>(ti, tj + <span class="number">1</span>); grid[ti][tj + <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 腐烂的橘子<br />
在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 0 代表空单元格</li>
<li>值 1 代表新鲜橘子</li>
<li>值 2 代表腐烂的橘子</li>
</ul>
<p>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂<br />
返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1</p>
<p>本题的特点在于，可能有多个腐蚀源头，因此需要以多个源头开始进行广度遍历</p>
<ol type="1">
<li>找到所有腐烂橘子位置，并用一个队列存储</li>
<li>遍历1.中的队列，对每个腐烂橘子，污染其邻居，如果有新鲜橘子也将其入队</li>
<li>2.遍历一轮后，时间加一，如果有新橘子腐烂继续循环</li>
<li>最后需要判别有没有新鲜橘子剩下来，最简单的做法是再遍历一次，但在之前过程中一直对新鲜橘子计数也可以做到</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//是否有新鲜橘子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)<span class="comment">//找到第一轮腐烂橘子</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123; i,j &#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>() &amp;&amp; flag)<span class="comment">//如果没有腐烂橘子并且有新鲜橘子，则新鲜橘子不可能腐烂</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">size</span>();<span class="comment">//遍历同一时间感染的橘子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; t;k++) &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;p = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> x = p.first + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = p.second + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="number">1</span>)<span class="comment">//找到新感染的橘子</span></span><br><span class="line">                &#123;</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; x,y &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果当前轮有新感染的橘子，时间加一</span></span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)<span class="comment">//检查是否有未感染的新鲜橘子</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 课程表<br />
你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1<br />
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 ai 则 必须 先学习课程 bi<br />
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1<br />
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false</p>
<p>此题表示图的方法比较非主流，只给了无序的边集合，想要发掘图的拓扑关系，应该将边以起始顶点来聚类，形成一个嵌套数组，也就是408里的邻接表<br />
然后可以分为dfs,bfs两种思路:</p>
<ol type="1">
<li>深度遍历:深度遍历的思路是后面遍历到的边的入点不能是之前访问过的点，这样就会形成一个环而无法拓扑排序
<ol type="1">
<li>一个易错点是，由于图未必联通，可能有多个子图，因此需要区分不同的有连接关系的拓扑序列，也就是结点分为3种状态
<ol type="1">
<li>完全未访问</li>
<li>已访问，但仍在一个深度遍历的过程中，这些节点在同一个联通图内</li>
<li>访问且深度遍历完，是有联通关系的拓扑序列的一部分，但和其他序列无关</li>
</ol></li>
<li>用栈理解更直观，如果只在相邻节点都已经搜索完成时入栈一个节点，那么如果可以全部入栈一个图，就可以拓扑排序</li>
</ol></li>
<li>广度遍历:即所谓的kahn算法:
<ol type="1">
<li>可以拓扑排序的图，一定同时有入度和出度为0的节点，也就是序列的首尾，我们可以不断移除入度为0的节点，令其相邻节点的入度减1</li>
<li>循环终止后我们发现所有边都被移除，就存在拓扑序列，否则不存在</li>
<li>觉得眼熟？408的死锁检测也用了类似算法</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_course</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; courses, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> node, <span class="type">bool</span>&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!res) <span class="keyword">return</span>;</span><br><span class="line">    courses[node] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> es = edges[node];<span class="comment">//该节点连向的其他节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : es) &#123;</span><br><span class="line">        <span class="keyword">if</span> (courses[e] == <span class="number">1</span>) &#123; res = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (courses[e] == <span class="number">0</span>) <span class="built_in">dfs_course</span>(courses, edges, e, res);</span><br><span class="line">    &#125;</span><br><span class="line">    courses[node] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">courses</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;<span class="comment">//课程状态数组，0表示未遍历过</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edges</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">bool</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : prerequisites) edges[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; numCourses &amp;&amp; res;++i) <span class="keyword">if</span> (courses[i] == <span class="number">0</span>) <span class="built_in">dfs_course</span>(courses, edges, i, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish_bfs</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">    indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> visited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ++visited;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            --indeg[v];</span><br><span class="line">            <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 前缀树</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code></li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code></li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p>前缀树可以视为树状存储的字符串，根节点为空字符串，根节点到每个节点的路径则是一个特定前缀，而对这个前缀，最多可以有26(此题固定位小写字母)个子节点形成下一个单词前缀。此外，如果想表示字符串终止，需要一个特定的flag，也就是每个有end标记的节点会特定一个字符串，可以看做一种编码体系<br />
看着手搓数据结构比较吓人，其实很简单，实现上就是一个26叉树，其插入就是顺着单词一路创建(如果原先没有的话)，最后标一个end;查找前缀也很容易理解，查找单词就是查找一个有end标记的前缀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[ch] ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>,<span class="literal">nullptr</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[ch]) node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="回溯-1">回溯</h3>
<p>回溯法：一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试<br />
这样听上去暴力的算法感觉很简单，但其实对有性能要求的场合，优化起来会很麻烦<br />
总得来说，回溯的思路是:</p>
<ol type="1">
<li>每层传入给下一层目前为止的选择集，同样也收到上一层的选择集，对每层来说:</li>
<li>如果没有选择或者满足终止条件，退出</li>
<li>遍历所有选择
<ol type="1">
<li>添加一个选择到选择集传给下一层</li>
<li>移除该选择集</li>
</ol></li>
</ol>
<p>需要注意的是，虽然递归后需要回溯，但如果传入下层的选择是一个副本而不是引用，就不需要回溯操作，遍历后到达作用域终点当前的选择信息也会被自动释放<br />
一般来说优化性能有两个方向:</p>
<ol type="1">
<li>预处理输入，例如如果可以简单判断无解的情况就不要回溯</li>
<li>记忆化，记忆已经做过的选择或者其他信息避免重复计算</li>
</ol>
<p>题号:1 全排列<br />
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案</p>
<p>例如对此题来说，简单的思路是通过一个状态数组维护已排列和未排列部分，然后不断递归穷举，这样很直观，但空间开销极大<br />
如果要省略这个状态数组，可以不断在穷举未排序部分时交换即将放入排序部分的元素和未排序部分边界的元素，这样就可以把拓展边界操作统一为右移一位边界，避免状态数组的开销</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">permute_helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; output, <span class="type">int</span> first, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有数都填完了</span></span><br><span class="line">    <span class="keyword">if</span> (first == len) &#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(output);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; len; ++i) &#123;<span class="comment">//[0,first]部分为已填过的数</span></span><br><span class="line">        <span class="comment">// 动态维护数组</span></span><br><span class="line">        <span class="built_in">swap</span>(output[i], output[first]);</span><br><span class="line">        <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">        <span class="built_in">permute_helper</span>(res, output, first + <span class="number">1</span>, len);</span><br><span class="line">        <span class="comment">// 撤销操作</span></span><br><span class="line">        <span class="built_in">swap</span>(output[i], output[first]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="built_in">permute_helper</span>(res, nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 子集<br />
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集<br />
解集不能包含重复的子集。你可以按 任意顺序 返回解集</p>
<p>子集和排列问题不同的是，无需考虑顺序，只需要考虑各个元素的有无，如果用递归做，每层只有两种可能,即放入和不放入一个元素，也就是其决策树画出来是颗满二叉树，每个叶节点对应一个子集<br />
眼熟？没错，这也是一种编码，我们完全可以用n位二进制数编码所有子集，k位对应第k个元素的有无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;<span class="comment">//n位二进制掩码表示子集</span></span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                t.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">    <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">    t.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 电话号码的字母排列<br />
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回</p>
<p>相当于指定层数的回溯，每一层查表得到三个字母，依次送入下一层回溯，事实上，决策树是三叉树，最后结果数量也是 <span class="math inline">\(3^n\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">letterCombinations_helper</span><span class="params">(vector&lt;string&gt;&amp; combinations, <span class="type">const</span> unordered_map&lt;<span class="type">char</span>, string&gt;&amp; phoneMap, <span class="type">const</span> string&amp; digits, <span class="type">int</span> index, string&amp; combination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits.<span class="built_in">length</span>()) combinations.<span class="built_in">push_back</span>(combination);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> digit = digits[index];</span><br><span class="line">        <span class="type">const</span> string&amp; letters = phoneMap.<span class="built_in">at</span>(digit);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; letter : letters) &#123;</span><br><span class="line">            combination.<span class="built_in">push_back</span>(letter);</span><br><span class="line">            <span class="built_in">letterCombinations_helper</span>(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">            combination.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;<span class="comment">//电话数字能表示的字母组合</span></span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;string&gt; combinations;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, string&gt; phoneMap&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    string combination;</span><br><span class="line">    <span class="built_in">letterCombinations_helper</span>(combinations, phoneMap, digits, <span class="number">0</span>, combination);</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 组合总和<br />
给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合<br />
<code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的 对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个</p>
<p>同样是标准回溯题，此题有一个大小关系约束，可以先对candidates排序，这样对相加结果大于target之后的元素就可以跳过了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combinationSum_helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; candidates, <span class="type">const</span> <span class="type">int</span>&amp; target, <span class="type">int</span> pre_sum, vector&lt;<span class="type">int</span>&gt; pre_select, <span class="type">int</span> index)</span> </span>&#123;<span class="comment">//每次进入的初始状态是pre_sum是所有pre_select的元素和，所以先判断是否满足条件可以结束</span></span><br><span class="line">    <span class="keyword">if</span> (pre_sum == target) &#123;<span class="comment">//大于的情况不会调用递归，所以只可能小于等于</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(pre_select);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index;i &lt; candidates.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">            <span class="type">int</span> sum = pre_sum + candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pre_select.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">                <span class="built_in">combinationSum_helper</span>(res, candidates, target, sum, pre_select, i);</span><br><span class="line">                pre_select.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> size = candidates.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">combinationSum_helper</span>(res, candidates, target, <span class="number">0</span>, &#123;&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 括号生成<br />
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合(这是卡特兰数问题的一个例子)</p>
<p>此题依旧没脱出回溯的模板，但规则上与之前不同的是强调成对性，<strong>也就是左括号数永远需要大于等于右括号数</strong><br />
对其的优化可以是用左右括号计数来约束每次回溯的选择，左括号数小于对数才可以放左括号，右括号数小于左括号数才可以放右括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; res, string&amp; cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == n * <span class="number">2</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="built_in">backtrack</span>(res, cur, open + <span class="number">1</span>, close, n);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="built_in">backtrack</span>(res, cur, open, close + <span class="number">1</span>, n);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string current;</span><br><span class="line">    <span class="built_in">backtrack</span>(result, current, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:6 单词搜索<br />
给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code><br />
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p>
<p>字符串匹配麻烦之处在于从任何索引开始都可能匹配上，但不管怎么说，如果能匹配，那么必然有一个开始点，因此意见可以穷举整个矩阵来解决<br />
虽然无法避免穷举矩阵的开销，但可以在遍历过程中设置一个visited数组，避免单次匹配过程中重复</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exist_helper</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> string&amp; word, <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; dire, <span class="type">int</span> index, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; coord, <span class="type">bool</span>&amp; res, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//index对应当前匹配的word字符串索引,coord则是当前所在矩阵位置</span></span><br><span class="line">    <span class="keyword">if</span> (res || word[index] != board[coord.first][coord.second]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == word.<span class="built_in">length</span>() - <span class="number">1</span>) res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        visited[coord.first][coord.second] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dire) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> x = coord.first + dir.first; <span class="type">int</span> y = coord.second + dir.second;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= board.<span class="built_in">size</span>() || y &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || visited[x][y])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">exist_helper</span>(board, word, dire, index + <span class="number">1</span>, &#123; x,y &#125;, res, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[coord.first][coord.second] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; directions = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">exist_helper</span>(board, word, directions, <span class="number">0</span>, &#123; i,j &#125;, res, visited);</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:7 分割回文串<br />
给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串 ，使每个子串都是回文 。返回 <code>s</code> 所有可能的分割方案<br />
很麻烦的一题，分割有顺序性，因此必须从左到右遍历，这点可以用双指针实现，即<code>i&lt;=j</code><br />
计算回文开销很大，因此必须预处理或者记忆化<br />
我们用一个n长方阵存储双指针，0表示未访问，1表示是回文，2表示不是回文:</p>
<ol type="1">
<li>预处理，对任何i&gt;=j,这个指针对视为回文(递归中要用)</li>
<li>每次查找回文时，先递归<code>&lt;i+1,j-1&gt;</code>这一对，<code>&lt;i,j&gt;</code>是不是回文取决于,i,j处字符是否相等且<code>&lt;i+1,j-1&gt;</code>是否是回文</li>
<li>记忆化:计算前先查表i,j，如果非0说明已经计算过</li>
</ol>
<p>回溯过程:</p>
<ol type="1">
<li>i从0到n遍历
<ol type="1">
<li>j从i到n遍历
<ol type="1">
<li>如果此时i,j是回文，分割并回溯</li>
<li>否则什么都不做</li>
</ol></li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack_string</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> i, vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt; selection, vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt;&amp; sym_word)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(selection);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">find_symmetry</span>(s, sym_word, i, j);</span><br><span class="line">        <span class="keyword">if</span> (sym_word[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            selection.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">backtrack_string</span>(s, j + <span class="number">1</span>, res, selection, sym_word);</span><br><span class="line">            selection.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_symmetry</span><span class="params">(<span class="type">const</span> string&amp; s, vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt;&amp; sym_word, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sym_word[i][j] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) sym_word[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">find_symmetry</span>(s, sym_word, i + <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        sym_word[i][j] = (s[i] == s[j] &amp;&amp; sym_word[i + <span class="number">1</span>][j - <span class="number">1</span>]==<span class="number">1</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt; <span class="built_in">sym_word</span>(n, <span class="built_in">vector</span>&lt;<span class="type">uint8_t</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n;++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = j;i &lt; n;++i) sym_word[i][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; selection;</span><br><span class="line">    <span class="built_in">backtrack_string</span>(s, <span class="number">0</span>, res, selection, sym_word);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二分查找">二分查找</h3>
<p>题号:1 搜索插入位置<br />
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置<br />
请使用时间复杂度为 O(log n) 的算法</p>
<p>经典，没什么好说的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (head + tail) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 搜索二维矩阵<br />
给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列</li>
<li>每行的第一个整数大于前一行的最后一个整数</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code></p>
<p>做两次二分搜索，一次找行,即行首小于等于target,下一行首严格大于target;再一次找行内<br />
也可以把矩阵映射成一维数组，即逐行相接，然后二分搜索</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">midsearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (head + tail) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先找一个行首小于等于目标，下一行首大于目标的行</span></span><br><span class="line">    <span class="type">int</span> up = <span class="number">0</span>, row = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, down = row, mid = down / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (up &lt;= down) &#123;</span><br><span class="line">        mid = (up + down) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid == row || (matrix[mid][<span class="number">0</span>] &lt;= target &amp;&amp; matrix[mid + <span class="number">1</span>][<span class="number">0</span>] &gt; target)) <span class="keyword">return</span> <span class="built_in">midsearch</span>(matrix[mid], target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &gt; target) down = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> up = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">midsearch</span>(matrix[mid], target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 在排序数组中查找元素的第一个和最后一个位置<br />
给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置<br />
如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code><br />
你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p>此题难点在怎么找数组首尾，当然随便找一个然后首尾顺着找也是个简单粗暴的方法，但极端情况可能有O(N)复杂度不达标<br />
因此还是需要二分找到范围首尾，这里可以用一个flag改变二分行为，但没必要这么麻烦，左右各自做一个函数更方便，也没什么开销<br />
需要注意的是由于等于的情况也会继续二分，最后有可能在不等于target的情况下结束，你可能想加一不就行了，但同样也有可能在等于情况下结束，例子就先略过了，当然也很好解决，加一个int存储最后一次匹配target的值就行了<br />
最后如何判断找没找到呢?看两个索引是否是target的值就行了，此外，先判索引是否有效也是基操，在此题里，索引越界也表示没找到target</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch_lft</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = <span class="number">0</span>, rht = nums.<span class="built_in">size</span>() - <span class="number">1</span>, res;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt;= rht) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (lft + rht) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            rht = mid - <span class="number">1</span>;</span><br><span class="line">            res = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> lft = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch_rht</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = <span class="number">0</span>, rht = nums.<span class="built_in">size</span>() - <span class="number">1</span>, res;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt;= rht) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (lft + rht) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            lft = mid + <span class="number">1</span>;</span><br><span class="line">            res = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> rht = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="type">int</span> lft = <span class="built_in">binarySearch_lft</span>(nums, target);</span><br><span class="line">    <span class="type">int</span> rht = <span class="built_in">binarySearch_rht</span>(nums, target);</span><br><span class="line">    <span class="keyword">if</span> (lft &lt; <span class="number">0</span> || rht &gt;= nums.<span class="built_in">size</span>() || nums[lft] != target || nums[rht] != target) lft = rht = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123; lft,rht &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 搜索旋转排序数组<br />
整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong><br />
在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code><br />
给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code><br />
你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p>此题麻烦在边界问题很难处理，我们先设想任意一个旋转数组，可分为两个部分，x和y长度的两个有序子数组，任意选一个点，要么正好就是两个子数组交接处，要么在一个子数组中间，知道这个性质后有两种思路:</p>
<ol type="1">
<li>先找分界点，也就是数组的最大/最小值
<ol type="1">
<li>由于条件是数组已经旋转过，那么0索引必然是一个子数组开头，并且不是最小值，利用这点，不断找比0处元素更小的部分</li>
<li>找到后对某个区间二分</li>
</ol></li>
<li>不管分界点，对每个中点必然至少有一侧有序，可以常数复杂度观察是否在有序区间内，然后跳转
<ol type="1">
<li>边界条件是mid在边界上如何判断，因此有序需要加一个左右边界相等的条件</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sorted</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lft, <span class="type">int</span> rht)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lft ==rht || nums[lft] &lt; nums[rht];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search_rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = <span class="number">0</span>, rht = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt;= rht) &#123;</span><br><span class="line">        mid = (lft + rht) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_sorted</span>(nums, lft, mid)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[lft] &amp;&amp; target &lt;= nums[mid]) rht = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> lft = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[rht]) lft = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> rht = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 寻找旋转排序数组中的最小值<br />
已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code><br />
给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong><br />
你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p>思路上一题说过，注意两个边界情况:</p>
<ol type="1">
<li>如果数组旋转0，也就是没旋转，就不会触发对最小值的更改，需要将其默认值设为0索引元素</li>
<li>对mid等于0索引的情况也应该右移(条件是严格升序，此时能等于0索引，说明lft=0,rht=1,只有这两个元素有可能更小，0是默认返回值，因此搜一下1)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = <span class="number">0</span>, rht = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid, rotate_start = nums[<span class="number">0</span>], min;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt;= rht) &#123;</span><br><span class="line">        mid = (lft + rht) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (rotate_start &lt;= nums[mid]) lft = ++mid;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            min = nums[mid];</span><br><span class="line">            rht = --mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="栈">栈</h3>
<p>题号:1 有效的括号<br />
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效<br />
有效字符串需满足：</p>
<ol type="1">
<li>左括号必须用相同类型的右括号闭合</li>
<li>左括号必须以正确的顺序闭合</li>
<li>每个右括号都有一个对应的相同类型的左括号</li>
</ol>
<p>经典题，为了方便拓展可以用哈希表匹配括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; se = &#123; <span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;[&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (se.<span class="built_in">find</span>(s[<span class="number">0</span>]) == se.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; ma = &#123; &#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,&#123;<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>&#125;,&#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (se.<span class="built_in">find</span>(c) != se.<span class="built_in">end</span>()) st.<span class="built_in">push</span>(c);<span class="comment">//左括号直接入栈</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//c是右括号</span></span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || ma[c] != st.<span class="built_in">top</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 最小栈<br />
设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象</li>
<li><code>void push(int val)</code> 将元素val推入堆栈</li>
<li><code>void pop()</code> 删除堆栈顶部的元素</li>
<li><code>int top()</code> 获取堆栈顶部的元素</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素</li>
</ul>
<p>用一个辅助栈同步基础栈的出入栈操作，但每次存取的是基础栈当前状态的最小元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; x_stack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; min_stack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_stack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">push</span>(x);</span><br><span class="line">        min_stack.<span class="built_in">push</span>(<span class="built_in">min</span>(min_stack.<span class="built_in">top</span>(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">pop</span>();</span><br><span class="line">        min_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 字符串解码<br />
给定一个经过编码的字符串，返回它解码后的字符串<br />
编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数<br />
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入</p>
<p>此题细节上非常麻烦，但框架很清晰，遍历字符串的过程中不断压栈，遇到<code>]</code>就取出来将k次字符串放入栈末尾，最后需要把栈内的所有字符串加起来<br />
细节上，为了优化存取，对连续字符应该放到一个string存储，数字如果是多位的也需要放入一个多位string存储，此外c++字符串数组需要指定长度，如<code>vec.push_back(string(1,char c))</code> ，将字符串转化为字面数字需要用<code>stoi</code>(来自string库)函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(s[i]); ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(<span class="built_in">string</span>(<span class="number">1</span>, s[i]));</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(s[i]); ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//右括号</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                string ss = vec.<span class="built_in">back</span>(); vec.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">if</span> (ss == <span class="string">&quot;[&quot;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> times = <span class="built_in">stoi</span>(vec.<span class="built_in">back</span>());vec.<span class="built_in">pop_back</span>();</span><br><span class="line">                    string t;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; times;++i) t += temp;</span><br><span class="line">                    vec.<span class="built_in">emplace_back</span>(t);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> temp.<span class="built_in">insert</span>(<span class="number">0</span>, ss);</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; vec.<span class="built_in">size</span>();++i)vec[<span class="number">0</span>] += vec[i];</span><br><span class="line">    <span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 每日温度<br />
定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替</p>
<ol type="1">
<li>设置一个辅助数组，用于存储对应温度的最小索引，初始均为无穷大
<ol type="1">
<li>反向遍历温度数组，对每个i，若有的话找到比其高的最低温度，并不断更新辅助数组里对应温度的索引</li>
</ol></li>
<li><strong>单调栈</strong>:正向遍历温度列表，对于温度列表中的每个元素 <code>temperatures[i]</code>:
<ol type="1">
<li>如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 <code>temperatures[prevIndex]</code>和当前温度<code>temperatures[i]</code></li>
<li>如果<code>temperatures[i]</code>更高，则将<code>prevIndex 移除</code>，并将<code>prevIndex</code>对应的等待天数赋为<code>i - prevIndex</code>，否则i入栈</li>
<li>重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将<code>i</code>进栈</li>
</ol></li>
</ol>
<p>单调栈的性质是:栈底到栈顶序列是单调的，此题中是严格递减关系。为什么可以用单调栈？因为此题有索引递增顺序，符合栈的序列性，又要大小要求，符合单调性<br />
每次匹配到一个较大元素，都是符合题意的首个更高温，因此可以出栈，每次匹配到一个较小元素，都说明这个元素和之前的元素都需要等一个更高温</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">temper</span><span class="params">(<span class="number">71</span>, <span class="number">0x7fffffff</span>)</span></span>;<span class="comment">//对i索引，表示30+i度温度出现的最小索引号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i) &#123;</span><br><span class="line">        <span class="type">unsigned</span> warmer = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = temperatures[i] + <span class="number">1</span>; t &lt;= <span class="number">100</span>; ++t) warmer = <span class="built_in">min</span>(warmer, temper[t - <span class="number">30</span>]);</span><br><span class="line">        <span class="keyword">if</span> (warmer != <span class="number">0x7fffffff</span>) res[i] = warmer - i;</span><br><span class="line">        temper[temperatures[i] - <span class="number">30</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures_stack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            <span class="type">int</span> previousIndex = s.<span class="built_in">top</span>();</span><br><span class="line">            res[previousIndex] = i - previousIndex;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="堆">堆</h3>
<p>题号:1 数组中的第K个最大元素<br />
给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素<br />
请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素<br />
你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题<br />
基础堆排序，用快排也行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickselect</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    <span class="type">int</span> partition = nums[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; partition);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; partition);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j)<span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, l, j, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest_qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> parent, <span class="type">const</span> <span class="type">int</span>&amp; heapsize)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = (parent &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, rht = (parent &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> max_one = (lft &lt; heapsize &amp;&amp; heap[lft] &gt; heap[parent]) ? lft : parent;</span><br><span class="line">    max_one = (rht &lt; heapsize &amp;&amp; heap[rht] &gt; heap[max_one]) ? rht : max_one;</span><br><span class="line">    <span class="keyword">if</span> (max_one != parent) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[parent], heap[max_one]);</span><br><span class="line">        <span class="built_in">maxheap</span>(heap, max_one, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_maxheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">const</span> <span class="type">int</span>&amp; heapsize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = heapsize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">maxheap</span>(heap, i, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> heapsize = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">build_maxheap</span>(nums, heapsize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        --heapsize;</span><br><span class="line">        <span class="built_in">maxheap</span>(nums, <span class="number">0</span>, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 前 K 个高频元素<br />
给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案</p>
<p>可以用一个哈希表存储<code>&lt;值，次数&gt;</code>对，然后维护一个k长度的最小堆，注意这里最小堆(优先队列的写法),首个参数是存储对象，第二个参数vector是存储形式，第三个参数是比较函数的函数类型<br />
同样也可以用快排处理哈希表键值对组成的数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; occurrences;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : nums) &#123;</span><br><span class="line">        occurrences[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(&amp;cmp)&gt; <span class="built_in">q</span>(cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [num, count] : occurrences) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">top</span>().second &lt; count) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">emplace</span>(num, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ret.<span class="built_in">emplace_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; v, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; ret, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> picked = <span class="built_in">rand</span>() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">    <span class="built_in">swap</span>(v[picked], v[start]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pivot = v[start].second;</span><br><span class="line">    <span class="type">int</span> index = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用双指针把不小于基准值的元素放到左边，</span></span><br><span class="line">        <span class="comment">// 小于基准值的元素放到右边</span></span><br><span class="line">        <span class="keyword">if</span> (v[i].second &gt;= pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(v[index + <span class="number">1</span>], v[i]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(v[start], v[index]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= index - start) &#123;</span><br><span class="line">        <span class="comment">// 前 k 大的值在左侧的子数组里</span></span><br><span class="line">        <span class="built_in">qsort</span>(v, start, index - <span class="number">1</span>, ret, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 前 k 大的值等于左侧的子数组全部元素</span></span><br><span class="line">        <span class="comment">// 加上右侧子数组中前 k - (index - start + 1) 大的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= index; i++) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(v[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; index - start + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">qsort</span>(v, index + <span class="number">1</span>, end, ret, k - (index - start + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取每个数字出现次数</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; occurrences;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: nums) &#123;</span><br><span class="line">        occurrences[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; values;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv: occurrences) &#123;</span><br><span class="line">        values.<span class="built_in">push_back</span>(kv);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    <span class="built_in">qsort</span>(values, <span class="number">0</span>, values.<span class="built_in">size</span>() - <span class="number">1</span>, ret, k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="贪心-1">贪心</h3>
<p>题号:1 跳跃游戏<br />
给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度<br />
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false</p>
<p>如果是dp做就用dp表示可达性然后遍历，但这题跳跃长度可选，因此与其维护dp数组，不如维护可以可以跳到的边界，一旦边界到达最右侧，就返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= rightmost) &#123;</span><br><span class="line">            rightmost = <span class="built_in">max</span>(rightmost, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 跳跃游戏II<br />
给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code><br />
每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code></li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code></p>
<p>设所处位置为i，可跳k步，对i来说每次的最优解是跳到一个j(i<sub>i+k范围)处，<code>j+nums[j]</code>是范围里i</sub>i+k的最大值<br />
也就是说，我们每次不仅维护一个最大范围，还要根据这个范围寻找一个下次最优解，每次跳到下次最优解时更新step</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxPos &gt;= i) &#123;</span><br><span class="line">            maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                ++step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更容易理解的版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>, i = <span class="number">0</span>, max_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        maxPos = i + nums[i];</span><br><span class="line">        <span class="keyword">if</span> (maxPos &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> ++step;<span class="comment">//此时相当于可以跳到终点，需要先加一再返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt;= maxPos;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + nums[j] &gt; max_index+nums[max_index]) max_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        i = max_index;maxPos = max_index + nums[max_index];</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 划分字母区间<br />
给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 <code>"ababcc"</code> 能够被分为 <code>["abab", "cc"]</code>，但类似 <code>["aba", "bcc"]</code> 或 <code>["ab", "ab", "cc"]</code> 的划分是非法的<br />
注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code><br />
返回一个表示每个字符串片段的长度的列表</p>
<p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。每次根据这个位置取片段，取如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的<br />
例如，s第一个字符是a，我们必须把截止最后一个a的长度填进去，然后遍历这个子串，看里面有没有其他需要填进去的字母，例如满足a的条件需要长度3，第二个字符是b，b最后出现在s第四个字符，就需要长度再加一</p>
<ol type="1">
<li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start=end=0</li>
<li>对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 endc​，则当前片段的结束下标一定不会小于 endc​，因此令 end=max(end,endc​)</li>
<li>当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 <code>[start,end]</code>，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start=end+1，继续寻找下一个片段</li>
<li>重复上述过程，直到遍历完字符串</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> last[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) last[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; partition;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        end = <span class="built_in">max</span>(end, last[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            partition.<span class="built_in">push_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态规划-1">动态规划</h3>
<h4 id="斐波那契类型">斐波那契类型</h4>
<p>题号:1 爬楼梯<br />
假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶<br />
每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>假设已经爬到了x级(x&lt;=n)，上一个状态可能是x-1或x-2，因此可得f(n)=f(n-1)+f(n-2)，也就是斐波那契数列<br />
这么一来只需要不断保留x-1和x-2项计算就行了，设置一个数组{结果，旧值，更旧值}，每次旧和更旧值相加存到结果值，下一轮的旧值是现在的结果，更旧值是现在的旧值,因此一一赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memory = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (steps &lt; n) &#123;</span><br><span class="line">        memory[<span class="number">0</span>] = memory[<span class="number">1</span>] + memory[<span class="number">2</span>];</span><br><span class="line">        memory[<span class="number">2</span>] = memory[<span class="number">1</span>];</span><br><span class="line">        memory[<span class="number">1</span>] = memory[<span class="number">0</span>];</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 第 N 个泰波那契数<br />
泰波那契序列(三个数之和版的斐波那契数)<br />
给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span> ,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        mem[<span class="number">0</span>] = mem[<span class="number">1</span>] + mem[<span class="number">2</span>] + mem[<span class="number">3</span>];</span><br><span class="line">        mem[<span class="number">3</span>] = mem[<span class="number">2</span>];</span><br><span class="line">        mem[<span class="number">2</span>] = mem[<span class="number">1</span>];</span><br><span class="line">        mem[<span class="number">1</span>] = mem[<span class="number">0</span>];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 使用最小花费爬楼梯<br />
给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶<br />
你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯<br />
请你计算并返回达到楼梯顶部的最低花费</p>
<p>楼梯，或者说斐波那契问题的关键就是，第k项只依赖于k-1和k-2项，爬到k阶的最小花费取决于k-1,k-2的最小花费+对应cost;而之前的楼梯问题相当于代价相等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = cost.<span class="built_in">size</span>(),i = <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="built_in">min</span>(mem[<span class="number">1</span>] + cost[i - <span class="number">1</span>], mem[<span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        mem[<span class="number">2</span>] = mem[<span class="number">1</span>];</span><br><span class="line">        mem[<span class="number">1</span>] = mem[<span class="number">0</span>];++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 打家劫舍<br />
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警<br />
给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额</p>
<p>假设我们已经偷到k家，如果之前偷了k-2,可以偷这家，否则和偷k-1家情况一致，也就是k家情况的最佳收益取决于<code>money(k-2)+num[k]</code>与<code>money(k-1)</code>的最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem = &#123; <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]),nums[<span class="number">0</span>],<span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]) &#125;;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="built_in">max</span>(mem[<span class="number">1</span>] + nums[i], mem[<span class="number">2</span>]);</span><br><span class="line">        mem[<span class="number">1</span>] = mem[<span class="number">2</span>];</span><br><span class="line">        mem[<span class="number">2</span>] = mem[<span class="number">0</span>];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 删除并获得点数<br />
给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作<br />
每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素<br />
开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数</p>
<p>乍一看无从下手，因为我们可以任意选择索引处的数x，但选择后x-1和x+1都清零了，现在必然选择所有x是最优的，因此每次我们选的是一个数而不是索引<br />
对一个选择集，我们会发现其可以表示成一系列相差大于1的数如<code>1,3,5,8</code>，对其排序可得到一个升序序列，没错，可以视为打家劫舍的一个变种，但逻辑更复杂一点<br />
先从简单的情形讨论，如果数组是个连续整数序列，那就纯粹是打家劫舍问题，对大小顺序里k的数，可以抢k-1或者抢k与k-2<br />
但如果有2以上的间隔呢，如<code>1,3,4,6,8</code>,此时我们发现抢1对之后的选择没有任何影响，准确地说，抢到k时，如果k-1这个数不存在，即k-1情况等价于上一个存在的树对应情况，，例如我们抢到3时，发现2不存在，那么3的最优解就是抢了3加上之前的最好情况 这么分析后，假设我们有一个实际存在值的数组，那么策略是:</p>
<ol type="1">
<li>遍历到某个数k,设j是k的上一个数
<ol type="1">
<li>如果k-1==j，按打家劫舍做，<code>k = max(k-1 ,money(k) +(k-2))</code></li>
<li>如果k-1不存在，<code>k=j+money(k)</code></li>
</ol></li>
</ol>
<p>实现细节有不少麻烦之处，这里用空间换易读性，存储不重复值的升序数组和对应哈希表的出现次数，方便之后调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteAndEarn</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), i = <span class="number">2</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; keys = &#123; nums[<span class="number">0</span>] &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!um.<span class="built_in">count</span>(i)) um[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ++um[i];</span><br><span class="line">        <span class="keyword">if</span> (i != keys.<span class="built_in">back</span>()) keys.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (keys.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> keys[<span class="number">0</span>] * um[keys[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp;<span class="comment">//偷到第二家</span></span><br><span class="line">    temp = ((keys[<span class="number">1</span>] - <span class="number">1</span>) != keys[<span class="number">0</span>]) ? keys[<span class="number">0</span>] * um[keys[<span class="number">0</span>]] + keys[<span class="number">1</span>] * um[keys[<span class="number">1</span>]] : <span class="built_in">max</span>(keys[<span class="number">1</span>] * um[keys[<span class="number">1</span>]], keys[<span class="number">0</span>] * um[keys[<span class="number">0</span>]]);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem = &#123; temp,temp,keys[<span class="number">0</span>] * um[keys[<span class="number">0</span>]] &#125;;<span class="comment">//&#123;结果，偷到第二家，偷到第一家&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; keys.<span class="built_in">size</span>()) &#123;<span class="comment">//进入时已经偷了2家或1家</span></span><br><span class="line">        <span class="keyword">if</span> ((keys[i] - <span class="number">1</span>) != keys[i - <span class="number">1</span>]) mem[<span class="number">0</span>] = mem[<span class="number">1</span>] + keys[i] * um[keys[i]];</span><br><span class="line">        <span class="keyword">else</span> mem[<span class="number">0</span>] = <span class="built_in">max</span>(mem[<span class="number">1</span>], mem[<span class="number">2</span>] + keys[i] * um[keys[i]]);</span><br><span class="line">        mem[<span class="number">2</span>] = mem[<span class="number">1</span>];</span><br><span class="line">        mem[<span class="number">1</span>] = mem[<span class="number">0</span>];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="矩阵-1">矩阵</h4>
<p>怀疑不太可能考，先略过这部分</p>
<p>题号:1 不同路径<br />
一个机器人位于一个 <code>m x n</code> 网格的左上角 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角 问总共有多少条不同的路径？</p>
<p><code>f(i,j)=f(i−1,j)+f(i,j−1)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 最小路径和<br />
给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小<br />
<strong>说明：</strong>每次只能向下或者向右移动一步</p>
<p><code>dp[i][j]</code>表示从左上角出发到 (i,j) 位置的最小路径和,从左上到右下更新dp即可</p>
<ol type="1">
<li>当 i&gt;0 且 j=0 时，<code>dp[i][0]=dp[i−1][0]+grid[i][0]</code></li>
<li>当 i=0 且 j&gt;0 时，<code>dp[0][j]=dp[0][j−1]+grid[0][j]</code></li>
<li>当 i&gt;0 且 j&gt;0 时，<code>dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">size</span>() == <span class="number">0</span> || grid[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> dp = vector &lt; vector &lt;<span class="type">int</span>&gt; &gt; (m, vector &lt;<span class="type">int</span>&gt; (n));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="字符串">字符串</h4>
<p>可分为编辑问题和比较问题，编辑问题由于可能需要一个无任何编辑的初始情况，更适合用长度作为表示问题的方式，0表示空字符串，m表示m长度的字符串(但依旧从0索引，即尾字符索引是m-1)</p>
<p>题号:1 最长回文子串<br />
给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<p>从大往小遍历，并存储最大索引和长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_symmetry_helper</span><span class="params">(<span class="type">const</span> string&amp; s, vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt;&amp; sym_word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>&amp; m, <span class="type">int</span>&amp; st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j || sym_word[i][j] == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sym_word[i][j] == <span class="number">1</span>) &#123; m = <span class="built_in">max</span>(j - i + <span class="number">1</span>, m);<span class="keyword">if</span> (m == j - i + <span class="number">1</span>) st = i; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - i == <span class="number">1</span>) sym_word[i][j] = s[i] == s[j];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">find_symmetry_helper</span>(s, sym_word, i + <span class="number">1</span>, j - <span class="number">1</span>, m, st);</span><br><span class="line">            sym_word[i][j] = (s[i] == s[j] &amp;&amp; sym_word[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sym_word[i][j] == <span class="number">1</span>) &#123; m = <span class="built_in">max</span>(j - i + <span class="number">1</span>, m);<span class="keyword">if</span> (m == j - i + <span class="number">1</span>) st = i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), max_len = <span class="number">1</span>, max_start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">uint8_t</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>;j &gt; i;--j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; max_len) <span class="built_in">find_symmetry_helper</span>(s, dp, i, j, max_len, max_start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(max_start, max_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 单词拆分<br />
给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code><br />
<strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用</p>
<p>对0-i索引的字符串，如果能被表示，则对每个词word,其词长wl:<br />
如果0-(i-wl)的字符串能被表示，且(i-wl) - i的字符串等于word，那么它可以被表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>()+<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] = <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> word_len = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (dp[i-word_len] &amp;&amp; word_len &lt;= i &amp;&amp; s.<span class="built_in">substr</span>(i-word_len, word_len) == word ) dp[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 最长回文子序列<br />
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度<br />
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列</p>
<p><code>dp[i][j]</code>表示字符串 s 的下标范围<code>[i,j]</code>内的最长回文子序列的长度</p>
<ol type="1">
<li>如果 <code>s[i]=s[j]</code>，则 <code>dp[i][j]=dp[i+1][j−1]+2</code></li>
<li>如果 <code>s[i]!=s[j]</code>，则 <code>s[i]</code> 和 <code>s[j]</code> 不可能同时作为同一个回文子序列的首尾，因此 <code>dp[i][j]=max(dp[i+1][j],dp[i][j−1])</code></li>
</ol>
<p>由这个递推公式得出，需要从内向外遍历，而起始点和i,j扩张方向则可以随意 d 下方使用i向左，j向右的方式，当然相反也行，只需要保证外层调用时内层已经准备好<br />
由于每次固定一个i，j从i+1开始往右走，因此，每次都是调用已经计算过的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c1 = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = s[j];</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 编辑距离<br />
给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em><br />
你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>注意到，别问怎么注意的，问题中缩短较长字符串等价于加长较短字符串，因此我们统一为两种操作:删除和替换 当我们获得<code>D[i][j-1]，D[i-1][j] 和 D[i-1][j-1]</code>的值之后就可以计算出<code>D[i][j]</code>。<code>D[i][j]</code>为 A 的前 i 个字符和 B 的前 j 个字符编辑距离的子问题<br />
即对于 B 的第 j 个字符，我们在 A 的末尾添加了一个相同的字符，那么<code>D[i][j]</code>最小可以为 <code>D[i][j-1] + 1</code>； <code>D[i-1][j]</code>为 A 的前 i - 1 个字符和 B 的前 j 个字符编辑距离的子问题<br />
即对于 A 的第 i 个字符，我们在 B 的末尾添加了一个相同的字符，那么<code>D[i][j]</code>最小可以为<code>D[i-1][j] + 1</code>；<code>D[i-1][j-1]</code> 为 A 前 i - 1 个字符和 B 的前 j - 1 个字符编辑距离的子问题<br />
即对于 B 的第 j 个字符，我们修改 A 的第 i 个字符使它们相同，那么<code>D[i][j]</code>最小可以为<code>D[i-1][j-1] + 1</code><br />
特别地，如果 A 的第 i 个字符和 B 的第 j 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，<code>D[i][j]</code>最小可以为<code>D[i-1][j-1]</code>。 那么我们可以写出如下的状态转移方程：</p>
<ol type="1">
<li>若 A 和 B 的最后一个字母相同： <code>D[i][j]​=min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1])=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]−1)​</code></li>
<li>若 A 和 B 的最后一个字母不同： <code>D[i][j]=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1])</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> left = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> down = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> left_down = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) left_down += <span class="number">1</span>;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(left, <span class="built_in">min</span>(down, left_down));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 两个字符串的最小ASCII删除和<br />
给定两个字符串<code>s1</code> 和 <code>s2</code>，返回 使两个字符串相等所需删除字符的 <strong>ASCII</strong> 值的最小和</p>
<p>策略:需要删掉删除和最小的字符串，考虑什么情况是没必要删的，如果s1是s2的一个子序列，那么s2里s1的字符就不需要删，也就是说这个问题其实是寻找子序列配合一个删除和约束<br />
如何寻找子序列呢？我们知道就是先比末尾字符，然后根据情况dp，此题加了一个删除和约束，那就往最小化删除和的方向dp<br />
当然反过来想，也可以找字符和最大的公共子序列，然后用两个字符串的总字符和减去它的两倍</p>
<p><code>dp[i][j]</code>表示s1直到i的子串和s2直到j的子串最小删除和</p>
<ol type="1">
<li>初始条件如果另一方不存在，就等于存在一方字符值</li>
<li>固定一个i增加j
<ol type="1">
<li>如果对应两个字符相等，不用删除就等价于(i-1,j-1)子问题</li>
<li>否则删掉一个删除和最小的，等价于对应删掉字符的值加删掉后对应子问题的删除和</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumDeleteSum</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = s1.<span class="built_in">size</span>(); <span class="type">int</span> n = s2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//上行结束后，所有有一方长度为0的子问题都解决了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">char</span> c1 = s1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = s2[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + s1[i - <span class="number">1</span>], dp[i][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最长递增子序列">最长递增子序列</h4>
<p>题号:1 最长递增子序列<br />
递增子序列有以下性质:</p>
<ol type="1">
<li>递增，比序列尾部元素大就可以扩张子序列</li>
<li>不知道具体有什么元素，或者说其尾部索引</li>
</ol>
<p>因此可以<code>dp[i]</code>表示到i为止的最长子序列尾部，这样一来每次对j索引更新时就需要遍历查找之前的最长子序列，具体地说找尾部元素比j小的子序列中最长的一个<br />
优化:考虑让每次可以新加的数尽可能小，这样至少不会是更差的选择:维护一个数组<code>d[i]</code>，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，<code>d[1]=nums[0]</code>，d数组有递增性质</p>
<p>设当前已求出的最长上升子序列的长度为 len（初始时为 1），从前往后遍历数组 nums，在遍历到<code>nums[i]</code>时：</p>
<ol type="1">
<li>如果<code>nums[i]&gt;d[len]</code> ，则直接加入到 d 数组末尾，并更新<code>len=len+1</code></li>
<li>否则，在 d 数组中二分查找，找到第一个比<code>nums[i]</code>小的数<code>d[k]</code>，并更新<code>d[k+1]=nums[i]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(),max_num;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span> (nums[j] &lt; nums[i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: dp) max_num=<span class="built_in">max</span>(i,max_num);</span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS_bin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>, n = (<span class="type">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    d[len] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; d[len]) d[++len] = nums[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 最长递增子序列的个数<br />
给定一个未排序的整数数组 <code>nums</code>， <em>返回最长递增子序列的个数</em><br />
<strong>注意</strong> 这个数列必须是 <strong>严格</strong> 递增的</p>
<p>暴力法就是上题基础上加个计数，非暴力法，嗯，不提了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), maxLen = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span>, <span class="title">cnt</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>; cnt[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    cnt[i] = cnt[j]; <span class="comment">// 重置计数</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) cnt[i] += cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = dp[i];</span><br><span class="line">            res = cnt[i]; <span class="comment">// 重置计数</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == maxLen) res += cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 最长数对链<br />
给你一个由 <code>n</code> 个数对组成的数对数组 <code>pairs</code> ，其中 <code>pairs[i] = [lefti, righti]</code> 且 <code>lefti &lt; righti</code><br />
现在，我们定义一种 <strong>跟随</strong> 关系，当且仅当 <code>b &lt; c</code> 时，数对 <code>p2 = [c, d]</code> 才可以跟在 <code>p1 = [a, b]</code> 后面。我们用这种形式来构造 <strong>数对链</strong><br />
找出并返回能够形成的 <strong>最长数对链的长度</strong><br />
你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造</p>
<p>类似上题和上上题，定义<code>dp[i]</code>为以<code>pairs[i]</code>为结尾的最长数对链的长度。计算<code>dp[i]</code>时，遍历所有小于i的索引j，<code>dp[i]</code>赋值为索引处的pair可以添加数对的dp最大值+1。这种动态规划的思路要求计算<code>dp[i]</code>时，所有潜在的<code>dp[j]</code>已经计算完成，可以先将pairs进行排序来满足这一要求。初始化时，dp需要全部赋值为1</p>
<p>二分:用一个数组arr来记录当前最优情况，<code>arr[i]</code>就表示长度为 i+1 的数对链的末尾可以取得的最小值，遇到一个新数对时，先用二分查找得到这个数对可以放置的位置，再更新arr<br />
贪心:要挑选最长数对链的第一个数对时，最优的选择是挑选右边界最小的，这样能给挑选后续的数对留下更多的空间。挑完第一个数对后，要挑第二个数对时，也是按照相同的思路，是在剩下的数对中，左边界满足题意的条件下，挑选右边界最小的。按照这样的思路，可以先将输入按照右边界排序，然后不停地判断左边界是否能满足大于前一个数对的右边界即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestChain</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = pairs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestChain_binary</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : pairs) &#123;</span><br><span class="line">        <span class="type">int</span> x = p[<span class="number">0</span>], y = p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span> || x &gt; arr.<span class="built_in">back</span>()) arr.<span class="built_in">emplace_back</span>(y);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), x) - arr.<span class="built_in">begin</span>();</span><br><span class="line">            arr[idx] = <span class="built_in">min</span>(arr[idx], y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestChain_greed</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> curr = INT_MIN, res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : pairs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr &lt; p[<span class="number">0</span>]) &#123;</span><br><span class="line">            curr = p[<span class="number">1</span>];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 最长定差子序列<br />
给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出并返回 <code>arr</code> 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code><br />
<strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列</p>
<p><code>dp[i]</code>表示以<code>arr[i]</code>为结尾的最长的等差子序列的长度，那么对任意v,其驱动元素如果存在必然是v-diff,如果存在v-difference元素，遍历到v时必然有个非0的<code>d[v-diff]</code>存在，其加一后就是<code>dp[v]</code>，由于哈希表默认值是0，因此不存在也不影响<br />
结果就是dp数组最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestSubsequence</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> difference)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v: arr) &#123;</span><br><span class="line">        dp[v] = dp[v - difference] + <span class="number">1</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 最长等差数列<br />
给你一个整数数组 <code>nums</code>，返回 <code>nums</code> 中最长等差子序列的<strong>长度</strong><br />
回想一下，<code>nums</code> 的子序列是一个列表 <code>nums[i1], nums[i2], ..., nums[ik]</code> ，且 <code>0 &lt;= i1 &lt; i2 &lt; ... &lt; ik &lt;= nums.length - 1</code>。并且如果 <code>seq[i+1] - seq[i]</code>( <code>0 &lt;= i &lt; seq.length - 1</code>) 的值都相同，那么序列 <code>seq</code> 是等差的</p>
<p>容易理解的方法:<br />
<code>dp[i][d]</code>表示以<code>nums[i]</code>结尾且公差为d的数列长度，即<code>dp[i]</code>存储一个以i元素结尾可以存在的不同d等差数列的哈希表<br />
对于<code>nums[i]</code>，可以枚举它的前一项<code>nums[j]</code>，0&lt;= j &lt; i，有了前一项<code>nums[j]</code>，其实公差就确定了<code>d=nums[i]-nums[j]</code></p>
<ol type="1">
<li>如果<code>nums[j]</code>可以是某个公差为d的数列的最后一项，<code>nums[i]</code>就可以接在后面形成更长的等差数列，状态转移方程为<code>dp[i][d]=dp[j][d]+1</code></li>
<li>否则它两就形成公差为d的等差数列前两项，状态转移方程为<code>dp[i][d]=2</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestArithSeqLength_best</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [minit, maxit] = <span class="built_in">minmax_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> diff = *maxit - *minit;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = -diff; d &lt;= diff; ++d) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(*maxit + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">int</span> prev = num - d; prev &gt;= *minit &amp;&amp; prev &lt;= *maxit &amp;&amp; f[prev] != <span class="number">-1</span>) &#123;</span><br><span class="line">                f[num] = <span class="built_in">max</span>(f[num], f[prev] + <span class="number">1</span>);</span><br><span class="line">                res = <span class="built_in">max</span>(res, f[num]);</span><br><span class="line">            &#125;</span><br><span class="line">            f[num] = <span class="built_in">max</span>(f[num], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestArithSeqLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">-500</span>; i &lt;= <span class="number">500</span>; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;<span class="comment">//头元素可以视为任意差的数列开头</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;<span class="comment">//对i之前的元素j</span></span><br><span class="line">            <span class="type">int</span> d = nums[i] - nums[j];<span class="comment">//i与j的差</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j].<span class="built_in">count</span>(d)) dp[i][d] = dp[j][d] + <span class="number">1</span>;<span class="comment">//如果j可以加在i的后面形成等差数列，其数列长度加一</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][d] = <span class="number">2</span>;<span class="comment">//否则生成一个新数列</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i][d]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最长公共子序列">最长公共子序列</h4>
<p>题号:1 最长公共子序列<br />
给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code><br />
一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列</p>
<p>过于经典，不多说了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence_better</span><span class="params">(string text1, string text2)</span> </span>&#123;<span class="comment">//dp[j]等于text2中以text2[j]为末尾元素的子序列和text1的[0,i-1]子串的最长公共子序列的长度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(text2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; text2.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="type">int</span> newlen = <span class="built_in">max</span>(maxlen, dp[j]);</span><br><span class="line">            <span class="keyword">if</span> (text1[i] == text2[j]) dp[j] = maxlen + <span class="number">1</span>;</span><br><span class="line">            maxlen = newlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">cbegin</span>(), dp.<span class="built_in">cend</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 不相交的线<br />
在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数<br />
现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线<br />
以这种方法绘制线条，并返回可以绘制的最大连线数</p>
<p>对每根线来说，两个索引都需要严格大于各自边的前方任意索引，并且对应元素要相等，这就是什么呢？每次，就是公共子序列，so……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num1 = nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> num2 = nums2[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="买卖股票">买卖股票</h4>
<p>题号:1 买卖股票的最佳时机<br />
给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格<br />
你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润<br />
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code></p>
<p>因为最多只能卖一股，到第i天，我们的最优解是买入目前为止的最低价，到目前为止的最高价全卖出，因此遍历中记录迄今为止的最低价格，每次考虑此次卖出的利润是否比之前更好<br />
如果用dp就是<code>dp[i]= max(dp[i-1], prices[i]-minprices[i-1])</code>，但我们</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minprice = <span class="number">0x7fffffff</span>, maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> price: prices) &#123;</span><br><span class="line">        maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">        minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 买卖股票的最佳时机 II<br />
给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格<br />
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售<br />
返回 <em>你能获得的 <strong>最大</strong> 利润</em></p>
<p>定义状态<code>dp[i][0]</code>表示第 i 天交易完后手里没有股票的最大利润，<code>dp[i][1]</code> 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）<br />
可得:</p>
<ol type="1">
<li><code>dp[i][0]=max&#123;dp[i−1][0],dp[i−1][1]+prices[i]&#125;</code></li>
<li><code>dp[i][1]=max&#123;dp[i−1][1],dp[i−1][0]−prices[i]&#125;</code></li>
</ol>
<p>由于这个状态转移符合马尔科夫假设，因此只需要存储前一天状态<code>dp[i−1][0]</code>和<code>dp[i−1][1]</code></p>
<p>贪心:我们只考虑利润，利润是什么？是一个子区间的右左差，由于每天可以随意买入卖出，因此i天买入，j天卖出的区间差等价于{i,i+1}……{j-1,j}的区间差之和，也就是说只要有赚头，我们当天买，第二天卖，加起来也是最优解<br />
这样一来就简单了，我们沿着所有长度为2的区间滚过去，有利润就买入卖出，加起来就是最大利润，实际上这就是获取最大利润买入卖出次数最大的一种方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int newDp0 = max(dp0, dp1 + prices[i]);</span></span><br><span class="line"><span class="comment">        int newDp1 = max(dp1, dp0 - prices[i]);</span></span><br><span class="line"><span class="comment">        dp0 = newDp0;</span></span><br><span class="line"><span class="comment">        dp1 = newDp1;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit_greed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;   </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) res += <span class="built_in">max</span>(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="动态规划树">动态规划树</h4>
<p>题号:1 不同的二叉搜索树<br />
给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数</p>
<p>定义:</p>
<ul>
<li>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数</li>
<li>F(i,n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)</li>
</ul>
<p>则:$ G(n)=_{i=1}^{n}F(i,n) $<br />
选定一个根节点后，其左右子树的结构相互独立互不影响，因此根为 i 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积<br />
则<br />
(其实这也是个卡特兰数问题)</p>
<p>具体来说，由于我们找的是个数，只要满足搜索树要求(中序遍历是升序数组)，值毫无影响，因此对任意i问题，可以随意划分根节点并转换成左右子树各自数量相乘，不同根节点的左右子树乘积就是目标值，例如我们找根为k(<code>k&lt;i</code>)时左右积，左边是0-k,右边是k-i,值不影响形状数量，左边数量就是i'=k时的子问题，右边数量就是i'=i-k时的子问题</p>
<p>$ F(i,n)=G(i-1)G(n-i) $<br />
$ G(n)=_{i=1}^{n}G(i-1)G(n-i) $</p>
<p>优化:鉴于一些乘积会重复取用，或许可以用一个乘积数组的空间换时间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">G</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    G[<span class="number">0</span>] = <span class="number">1</span>; G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 不同的二叉搜索树 II<br />
给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案</p>
<p>与上一题不同的是需要返回生成的树，也就是要把数组G换成树组，且需要考虑不同的值，因此对相同形状的不同取值也要重新生成数，没有存储子问题的必要了，每次要调用就先生成<br />
如果想用空间表达这个问题，那么<code>G[st][ed]表示st-ed自然数序列能生成的不同bst集合</code>，其可以通过不断选取st-ed之间的一个值i作为根节点其左子树集合是<code>G[st][i-1]</code>,右子树集合是<code>G[i+1][end]</code>，两者与i这个根节点的所有组合则是所求<br />
优化:取值范围相同的二叉树集合也可以被复用,或许可以用两个索引值的哈希表存储这些树的集合</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">    <span class="comment">// 枚举可行根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">        vector&lt;TreeNode*&gt; leftTrees = <span class="built_in">generateTrees</span>(start, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">        vector&lt;TreeNode*&gt; rightTrees = <span class="built_in">generateTrees</span>(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTrees) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTrees) &#123;</span><br><span class="line">                TreeNode* currTree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                currTree-&gt;left = left;</span><br><span class="line">                currTree-&gt;right = right;</span><br><span class="line">                allTrees.<span class="built_in">emplace_back</span>(currTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allTrees;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 打家劫舍 III<br />
地区只有一个入口，我们称之为 <code>root</code><br />
除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警<br />
给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em></p>
<p>用 f(o) 表示选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和<br />
g(o) 表示不选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和<br />
l 和 r 代表 o 的左右孩子</p>
<p>抢了o就不能抢它的孩子，收益是不抢两个孩子的情况和;不抢o对左右孩子选取一个最好情况相加<br />
优化:对于每个节点，我们只关心它的孩子节点们抢了和没抢的分别状况。设计一个结构，表示某个节点的 f 和 g 值，在每次递归返回的时候，都把这个点对应的 f 和 g 返回给上一级调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">unordered_map &lt;TreeNode*, <span class="type">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">    f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right];</span><br><span class="line">    g[node] = <span class="built_in">max</span>(f[node-&gt;left], g[node-&gt;left]) + <span class="built_in">max</span>(f[node-&gt;right], g[node-&gt;right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob1</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[root], g[root]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubtreeStatus</span> &#123;</span><br><span class="line">    <span class="type">int</span> selected;</span><br><span class="line">    <span class="type">int</span> notSelected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SubtreeStatus <span class="title">dfs2</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        <span class="type">int</span> selected = node-&gt;val + l.notSelected + r.notSelected;</span><br><span class="line">        <span class="type">int</span> notSelected = <span class="built_in">max</span>(l.selected, l.notSelected) + <span class="built_in">max</span>(r.selected, r.notSelected);</span><br><span class="line">        <span class="keyword">return</span> &#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob2</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rootStatus = <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rootStatus.selected, rootStatus.notSelected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="背包问题-1">背包问题</h4>
<p>题号:1 完全平方数<br />
给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em><br />
<strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是</p>
<p><code>f[i]</code>表示最少需要多少个数的平方来表示整数i，有两种可能:</p>
<ol type="1">
<li>i本身是完全平方数，返回1</li>
<li>存在一个完全平方数k,存在非0的<code>f[i-k]</code></li>
</ol>
<p>如果第一种可能，就是k=i的特例,<code>f[i]=f[0]+1=1</code>，因此不需要额外判断<br />
遍历i不断找最小的<code>f[i-k]</code>就行了，由于i-k+k=i,因此找到后+1就是i的最优解<br />
极端情况下，由于1也是完全平方数,i超过一个可以表示数的部分总可以用1补上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_num = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) min_num = <span class="built_in">min</span>(min_num, f[i - j * j]);</span><br><span class="line">        f[i] = min_num + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 零钱兑换 II<br />
给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额<br />
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code><br />
假设每一种面额的硬币有无限个<br />
题目数据保证结果符合 32 位带符号整数</p>
<p><code>dp[i]</code>表示金额之和等于i的硬币组合数，目标是求<code>dp[amount]</code>，对每个i，如果存在一个硬币coin,<code>dp[i-coin]</code>不为0，那么就可以得到对应<code>dp[i-coin]</code>的组合数<br />
为了避免重复计算同一个组合，我们用一个外层循环固定每次用的面值，例如面值有1,2,5，那么我们先用1解决所有找零问题，固定到2时我们已经知道只用1的找零方案数了，然后我们考虑增加一些用2找零的子情况，也就是用到两个1的方案都可以加个2的情况，固定到5时也类似<br />
由于每次添加一个之前没有考虑的面值，因此不会重复</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span>, <span class="title">valid</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; valid[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; coin : coins) <span class="keyword">for</span> (<span class="type">int</span> i = coin; i &lt;= amount; i++) valid[i] |= valid[i - coin];<span class="comment">//如果存在一种方式使得 valid[i] 为 1，就将其标记为可行</span></span><br><span class="line">    <span class="keyword">if</span> (!valid[amount]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; coin : coins) <span class="keyword">for</span> (<span class="type">int</span> i = coin; i &lt;= amount; i++) dp[i] += dp[i - coin];  </span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 组合总和 Ⅳ<br />
给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数<br />
题目数据保证答案符合 32 位整数范围<br />
请注意，<strong>顺序不同的序列被视作不同的组合</strong></p>
<p>本题与上题不同的是，要计算排列数而不是组合数，我们需要严格从头到尾构造，对任意i，如果可以加num得到一个和为i的排列，就加进去<br />
以及，这题闲的没事干又放一个超大用例，dp数组一定得用size_t(unsigned long long),无语</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">size_t</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums) </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num) dp[i] += dp[i - num];</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="一维问题">一维问题</h4>
<p>题号:1 乘积最大子数组<br />
给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续<br />
（该子数组中至少包含一个数字），并返回该子数组所对应的乘积<br />
测试用例的答案是一个 <strong>32位</strong> 整数</p>
<p>维护一个 fmin​(i)，它表示以第 i 个元素结尾的乘积最小子数组的乘积，由于乘法要考虑正负性，我们需要考虑之前的最小负数和最大正数，由于还可能是0，因此有可能不乘是最优解</p>
 $\begin{array}{l}{{f_{\mathrm{max}}(i)=\operatorname*{{max}_{i=1}^n}\{f_{\mathrm{max}}(i-1)\times a_{i},\,f_{\mathrm{min}}(i-1)\times a_{i},\,a_{i}\}}}\\ {{{}}}\\ {{f_{\mathrm{min}}(i)=\operatorname*{min}_{i=1}^n\{f_{\mathrm{max}}(i-1)\times a_{i},\,f_{\mathrm{min}}(i-1)\times a_{i},\,a_{i}\}}}\end{array}$  
<p>也就是说，其实只要维护一个最小值和一个最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> maxF = nums[<span class="number">0</span>], minF = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">long</span> mx = maxF, mn = minF;</span><br><span class="line">        maxF = <span class="built_in">max</span>(mx * nums[i], <span class="built_in">max</span>((<span class="type">long</span>)nums[i], mn * nums[i]));</span><br><span class="line">        minF = <span class="built_in">min</span>(mn * nums[i], <span class="built_in">min</span>((<span class="type">long</span>)nums[i], mx * nums[i]));</span><br><span class="line">        <span class="keyword">if</span>(minF&lt;INT_MIN) minF=nums[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(maxF, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 分割等和子集<br />
给你一个只包含正整数的非空数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等</p>
<p><code>dp[i][j]</code>表示从数组的<code>[0,i]</code>下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false</p>
<ul>
<li><code>dp[i][0]=true</code></li>
<li><code>dp[0][nums[0]]=true</code></li>
</ul>
<p>过程中规则:</p>
<ul>
<li>如果<code>j≥nums[i]</code>，则对于当前的数字<code>nums[i]</code>，可以选取也可以不选取，两种情况只要有一个为 true，就有<code>dp[i][j]=true</code>
<ul>
<li>如果不选取<code>nums[i]</code>，则 <code>dp[i][j]=dp[i−1][j]</code></li>
<li>如果选取<code>nums[i]</code>，则 <code>dp[i][j]=dp[i−1][j−nums[i]]</code></li>
</ul></li>
<li>如果<code>j&lt;nums[i]</code>，则在选取的数字的和等于j的情况下无法选取当前的数字<code>nums[i]</code>，因此有<code>dp[i][j]=dp[i−1][j]</code></li>
</ul>
<p>在计算 dp 的过程中，每一行的 dp 值都只与上一行的 dp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。此时的转移方程为：<span class="math inline">\(dp[j]=dp[j]\mid dp[j-n u m s[i]]\)</span><br />
第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 <code>dp[j]</code> 值的时候，<code>dp[j−nums[i]]</code>已经是被更新过的状态，不再是上一行的 dp 值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxNum &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= num) dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition_better</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        maxNum = <span class="built_in">max</span>(maxNum, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxNum &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= num; --j) dp[j] |= dp[j - num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 解决智力问题<br />
给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>questions</code> ，其中 <code>questions[i] = [pointsi, brainpoweri]</code><br />
这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong> （也就是从问题<code>0</code>开始依次解决），针对每个问题选择 <strong>解决</strong> 或者 <strong>跳过</strong> 操作。解决问题 <code>i</code> 将让你 <strong>获得</strong> <code>pointsi</code> 的分数，但是你将 <strong>无法</strong> 解决接下来的 <code>brainpoweri</code> 个问题（即只能跳过接下来的 <code>brainpoweri</code>个问题）。如果你跳过问题 <code>i</code> ，你可以对下一个问题决定使用哪种操作</p>
<ul>
<li>比方说，给你 <code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>：
<ul>
<li>如果问题 <code>0</code> 被解决了， 那么你可以获得 <code>3</code> 分，但你不能解决问题 <code>1</code> 和 <code>2</code></li>
<li>如果你跳过问题 <code>0</code> ，且解决问题 <code>1</code> ，你将获得 <code>4</code> 分但是不能解决问题 <code>2</code> 和 <code>3</code></li>
</ul></li>
</ul>
<p>请你返回这场考试里你能获得的 <strong>最高</strong> 分数</p>
<p>从无后效性的角度考虑动态规划「状态」的定义。对于每一道题目，解决与否会影响到后面一定数量题目的结果，但不会影响到前面题目的解决。因此我们可以考虑从反方向定义「状态」，即考虑解决每道题本身及以后的题目可以获得的最高分数<br />
用<code>dp[i]</code>来表示解决<strong>第 i 道题目及以后的题目</strong>可以获得的最高分数。同时，我们从后往前遍历题目，并更新 dp 数组</p>
<ol type="1">
<li>不解决第 i 道题目，此时 <code>dp[i]=dp[i+1]</code></li>
<li>解决第 i 道题目，我们只能解决下标大于<code>i+brainpower[i]</code>的题目，而此时根据 dp 数组的定义，解决这些题目的最高分数为 <code>dp[i+brainpower[i]+1]</code>（当 i≥n 的情况下，我们认为 <code>dp[i]=0</code>）。因此，我们有：</li>
</ol>
<p><span class="math inline">\(d p[i]=\operatorname*{max}(d p[i+1],p o i n t{s[i]}+d p[\operatorname*{min}(n,i+b r a i n p o w e r[i]+1)]).\)</span></p>
<p>预留<code>dp[n]=0</code>用来表示没有做任何题目的分数，则:<span class="math inline">\(dp[i]=\operatorname*{max}(dp[i+1],p o i n t s[i]+dp[\operatorname*{min}(n,i+b r a i n p o w e r[i]+1)]).\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mostPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; questions)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = questions.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;   <span class="comment">// 解决每道题及以后题目的最高分数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) dp[i] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>], questions[i][<span class="number">0</span>] + dp[<span class="built_in">min</span>(n, i + questions[i][<span class="number">1</span>] + <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 零钱兑换<br />
给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额<br />
计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code><br />
你可以认为每种硬币的数量是无限的</p>
<p>令F(S)为组成金额 S 所需的最少硬币数量，如果存在一个硬盘面额c,f(s-c)存在，则f(s)=f(s-c)+1<br />
那么通过递归不断从小到大遍历寻找就行了，此外还需要一个数组用于记忆化<br />
迭代法的情况下，从1开始，每个s都是对所有硬币面额c找一个最优s-c的情况再加一</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; count;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> rem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rem &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//说明找完了</span></span><br><span class="line">    <span class="keyword">if</span> (count[rem - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> Min = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin:coins) &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">dp</span>(coins, rem - coin);<span class="comment">//如果是-1则找不了，0及以上说明有解</span></span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; Min) Min = res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count[rem - <span class="number">1</span>] = Min == INT_MAX ? <span class="number">-1</span> : Min;</span><br><span class="line">    <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    count.<span class="built_in">resize</span>(amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(coins, amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange_dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin: coins) </span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i) dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 统计构造好字符串的方案数<br />
给你整数 <code>zero</code> ，<code>one</code> ，<code>low</code> 和 <code>high</code> ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>
<ul>
<li>将 <code>'0'</code> 在字符串末尾添加 <code>zero</code> 次</li>
<li>将 <code>'1'</code> 在字符串末尾添加 <code>one</code> 次</li>
</ul>
<p>以上操作可以执行任意次<br />
如果通过以上过程得到一个 <strong>长度</strong> 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <strong>好</strong> 字符串<br />
请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>10 + 7</code> <strong>取余</strong> 后返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(high + <span class="number">1</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>&amp; res = memo[i]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>)  <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> res = (<span class="built_in">dfs</span>(dfs, i - zero) + <span class="built_in">dfs</span>(dfs, i - one)) % MOD;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; i++) res = (res + <span class="built_in">dfs</span>(dfs, i)) % MOD;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:6 解码方法<br />
一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：<code>"1" -&gt; 'A' "2" -&gt; 'B' ... "25" -&gt; 'Y' "26" -&gt; 'Z'</code><br />
然而，在 <strong>解码</strong> 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（<code>"2"</code> 和 <code>"5"</code> 与 <code>"25"</code>）<br />
例如，<code>"11106"</code> 可以映射为：</p>
<ul>
<li><code>"AAJF"</code> ，将消息分组为 <code>(1, 1, 10, 6)</code></li>
<li><code>"KJF"</code> ，将消息分组为 <code>(11, 10, 6)</code></li>
<li>消息不能分组为 <code>(1, 11, 06)</code> ，因为 <code>"06"</code> 不是一个合法编码（只有 "6" 是合法的）</li>
</ul>
<p>注意，可能存在无法解码的字符串<br />
给你一个只含数字的 <strong>非空 </strong>字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。如果没有合法的方式解码整个字符串，返回 <code>0</code><br />
题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数</p>
<ol type="1">
<li>当前字符为 <code>0</code>，和它前一个的组合编码不合法，则整个编码不可被解码，返回 <code>0</code> 即可，比如遇到了 <code>00</code>，<code>60</code>等</li>
<li>当前字符为 <code>0</code>，和它前一个的组合编码合法，则<strong>只能</strong>将当前字符 <code>0</code> 和它的前一个字符“绑定”为“一个字符”，比如遇到了 <code>10</code>，<code>20</code>等（实际上只能是这两种情况）</li>
<li>当前字符不为 <code>0</code>，和它前一个的组合编码不合法，则<strong>只能</strong>将当前字符看做一个单独的编码，比如遇到了 <code>01</code>，<code>94</code>等</li>
<li>当前字符不为 <code>0</code>，和它前一个的组合编码合法，则可以将当前字符看做是一个单独的编码，也可以和它的前一个字符绑定，比如遇到了 <code>11</code>，<code>24</code>等，只有这种情况下有两种分叉</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, x = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        x = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> || x &gt; <span class="number">26</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">26</span> || x &lt; <span class="number">10</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:7 最低票价<br />
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 <code>days</code> 的数组给出。每一项是一个从 <code>1</code> 到 <code>365</code> 的整数<br />
火车票有 <strong>三种不同的销售方式</strong> ：</p>
<ul>
<li>一张 <strong>为期一天</strong> 的通行证售价为 <code>costs[0]</code> 美元</li>
<li>一张 <strong>为期七天</strong> 的通行证售价为 <code>costs[1]</code> 美元</li>
<li>一张 <strong>为期三十天</strong> 的通行证售价为 <code>costs[2]</code> 美元</li>
</ul>
<p>通行证允许数天无限制的旅行。例如，如果我们在第 <code>2</code> 天获得一张 <strong>为期 7 天</strong> 的通行证，那么我们可以连着旅行 7 天：第 <code>2</code> 天、第 <code>3</code> 天、第 <code>4</code> 天、第 <code>5</code> 天、第 <code>6</code> 天、第 <code>7</code> 天和第 <code>8</code> 天<br />
返回你想要完成在给定的列表 <code>days</code> 中列出的每一天的旅行所需要的最低消费</p>
<p><code>dp[i]</code>表示第i天旅游的情况下，<code>[1,i]</code>这段日子的最小花费。在这个定义下，答案就应该是<code>dp[days.back()]</code><br />
首先没开始的时候肯定不花钱，<code>dp[0]=0</code>。令j=0指向数组days的首元素，如果第i天不旅游，状态转移方程即为<code>dp[i]=dp[i−1]</code><br />
如果<code>i=days[j]</code>，那为了保证第i天旅游，有三种选择策略。状态转移方程为<code>dp[i]=min(dp[max(0,i−1)]+costs[0],dp[max(0,i−7)]+costs[1],dp[max(0,i−30)]+costs[2])</code>，分别表示选择1、7、30天有效期的策略，选择最小的转移，转移完记得让j右移 事实上，当j≥n（n为days的长度）时就可以停止DP过程了，因为最后一个需要旅行的日子已经安排完了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mincostTickets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; days, vector&lt;<span class="type">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">366</span>,<span class="number">0x3f</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= <span class="number">365</span> &amp;&amp; j &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(i == days[j]) &#123;</span><br><span class="line">            dp[i] = dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">1</span>)] + costs[<span class="number">0</span>];</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>]);</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[days.<span class="built_in">back</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="技巧">技巧</h3>
<p>题号:1 只出现一次的数字<br />
给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素<br />
如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法:</p>
<ul>
<li>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字</li>
<li>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字</li>
<li>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字</li>
</ul>
<p>但是常数空间线性时间的解法呢？注意到(别问怎么注意到的),任意偶数个相同的数异或运算都是0，而0和任意奇数个相同的数异或运算都是那个奇数的数，因此所有数异或就能得到答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums) temp ^=i;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info"><p>cpp位运算:</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;</td>
<td>与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr class="even">
<td>|</td>
<td>或</td>
<td>两个位都为0时，结果才为0</td>
</tr>
<tr class="odd">
<td>^</td>
<td>异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr class="even">
<td>~</td>
<td>取反</td>
<td>0变1，1变0</td>
</tr>
<tr class="odd">
<td>&lt;&lt;</td>
<td>左移</td>
<td>各二进位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td>右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td>
</tr>
</tbody>
</table>
</div>
<p>题号:2 多数元素<br />
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素<br />
你可以假设数组是非空的，并且给定的数组总是存在多数元素</p>
<ol type="1">
<li>最简单的做法是哈希表，不赘述<br />
</li>
<li>其次是排序，比较排序无法线性复杂度，但如果堆排可以常数空间</li>
<li>如果将 <code>nums</code> 分成两部分，那么 <code>a</code> 必定是至少一部分的众数,可以使用分治法，向上合并时，如果两侧众数不同需要遍历算出正确的众数</li>
<li>Boyer-Moore 算法:
<ol type="1">
<li>维护一个候选众数<code>candidate</code>和它出现的次数<code>count</code>初始时<code>candidate</code>可以为任意值，<code>count</code>为<code>0</code>；</li>
<li>遍历数组<code>nums</code>中的所有元素，对于每个元素<code>x</code>，在判断<code>x</code>之前，如果<code>count</code>的值为<code>0</code>，我们先将<code>x</code>的值赋予<code>candidate</code>，判断<code>x</code>：
<ol type="1">
<li>如果<code>x</code>与<code>candidate</code>相等，那么计数器<code>count</code>的值增加<code>1</code></li>
<li>如果<code>x</code>与<code>candidate</code>不等，那么计数器<code>count</code>的值减少<code>1</code></li>
</ol></li>
<li>在遍历完成后，<code>candidate</code>即为整个数组的众数</li>
</ol></li>
</ol>
<p>看起来很抽象？可以这么想，对真正的众数来说，其他数加在一起和众数相消，最后剩下的也只有众数；并且对任意对数的相消之后，这个性质都成立.为什么呢？设众数为x，非众数统称为y1-yk,不同的两个数能相消，假设y系数团结起来全部和众数想消，众数也会赢，如果y系数发生内斗相消，众数反而赢得更多，因此只要不断相消，众数就会赢到最后<br />
在这个算法中，candidate就是下次相消操作的被挑战者，极端情况下candidate从始至终是众数，其count也会严格大于0，而对其他candidate，再怎么相消也赢不过众数<br />
形象地说，可以称为相杀算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_in_range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = lo; i &lt;= hi; ++i)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target) ++count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majority_element_rec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> nums[lo];</span><br><span class="line">    <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> left_majority = <span class="built_in">majority_element_rec</span>(nums, lo, mid);</span><br><span class="line">    <span class="type">int</span> right_majority = <span class="built_in">majority_element_rec</span>(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>) <span class="keyword">return</span> left_majority;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>) <span class="keyword">return</span> right_majority;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement_div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">majority_element_rec</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement_vote</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == candidate) ++count;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 颜色分类<br />
给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列<br />
我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色<br />
必须在不使用库内置的 sort 函数的情况下解决这个问题</p>
<p>本题是经典的「荷兰国旗问题」，由计算机科学家 <a href="https://leetcode.cn/link/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E8%89%BE%E5%85%B9%E6%A0%BC%C2%B7%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB">Edsger W. Dijkstra</a> 首先提出<br />
很容易想到可以像快排一样用一个枢纽(此题里存索引就可以)划分两个部分不断交换，但既然有三个颜色，那就需要两个分界点<br />
这样一来有个问题，假设0-i是0部分，(i+1)-j是1部分，长度都不为0，那么0部分想拓展就需要挤占1部分，此时交换i+1(j部分开头)和当前索引v后，需要再把v和j+1交换<br />
下方代码使用准确界限，即p0,p1指向0，1区最后一个元素，初始为-1,极端情况下全一数组，p1也会始终和i同步更新,p1+1&lt;=i，因此不会越界</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> p0 = <span class="number">-1</span>, p1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) <span class="built_in">swap</span>(nums[i], nums[++p1]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[<span class="number">1</span> + p0]);</span><br><span class="line">            <span class="keyword">if</span> (p0 &lt; p1) <span class="built_in">swap</span>(nums[i], nums[p1 + <span class="number">1</span>]);</span><br><span class="line">            ++p1;++p0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 下一个排列<br />
整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code></li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code></li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code></li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列<br />
必须<strong>原地</strong>修改，只允许使用额外常数空间</p>
<p>下一个排列的性质:</p>
<ol type="1">
<li>需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列</li>
<li>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小</li>
</ol>
<p>具体地，我们这样描述该算法，对于长度为 n 的排列 a：</p>
<ol type="1">
<li>首先从后向前查找第一个顺序对 <code>(i,i+1)</code>，满足 <code>a[i]&lt;a[i+1]</code>(完全逆序就是最大序列了)。此时 <code>[i+1,n)</code> 必然是下降序列(从后往前找顺序对，说明找到的结果后没有这样的顺序对)</li>
<li>如果找到了顺序对，那么在区间<code>[i+1,n)</code>中从后向前查找第一个元素 j 满足<code>a[i]&lt;a[j]</code>,即找一个比<code>a[i]</code>大的数中的最小数</li>
<li>交换 <code>a[i]</code> 与 <code>a[j]</code>，此时可以证明区间<code>[i+1,n)</code>必为降序。我们可以直接使用双指针反转区间<code>[i+1,n)</code>使其变为升序，而无需对该区间进行排序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;<span class="comment">//保证i+1不越界</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) i--;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) j--;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 寻找重复数<br />
给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数<br />
假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong><br />
你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间</p>
<p>此题的其他官解都很……难以理解，只看第三种做法<br />
我们对<code>nums</code>数组建图，每个位置<code>i</code>视为一条 <code>i→nums[i]</code> 的边。由于存在且仅存在一个重复的数字<code>target</code>，因此<code>target</code>这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的<code>target</code>就是这个环的入口，那么整个问题就等价于环形链表<br />
我们已经证明过如果慢指针从起点出发，快指针从相遇位置出发，快慢指针会在环的入口相遇，所以复刻就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slow =nums[<span class="number">0</span>] , fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考研笔记</category>
        <category>研distance</category>
      </categories>
      <tags>
        <tag>研distance</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉rpg设定集</title>
    <url>/thinklive/44607/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励" data-whm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励">
  <script id="hbeData" type="hbeData" data-hmacdigest="167556ddc3a848adbd88e95c69afe36dbcf5ff2fd8a4c529e0f919fe2ee2e4dd">57820f280e028432007ed0329fa5f83c914d990394349dffb3b616863204f0fc2d749c10255bd67f837c286db0e6cfe54a5e0d9d3744b672eb12ac3f7fbc50152feb6f29944b543f50e67432be459ff162871d9459f8a2ada2a96d46a3d0d0ffe3b51cbbb1be949fa006f94160656609d1b8fc393f5fc15ae7d5a1473831fc0c9ed204d60ce2420e5c9f7114becbaa3025fc685e82ce33fc1262c822dbba8296730a11dfacde279dd174aedc60dfd04fa79fb718ee5636b9c93b60c6b1b06f32a8a3839f1a54ad7adb9e7c534c1469eabd52216825f43cc3495c05f5bcb218ef3fedae50a36dccf7783f64b8bbab992e9bed4a9706e2ef176c23fcce228833affc3ec16f01e3f4d3a2e7e3c1b0040c0ef785e7733d2f4c7fa89a3f93e6f5b3698413586601c56aaa6ab7c25be26e8ebe890960335f335f15919f01e392c0821b7c8a75e57a526a0787a445f5c04c276d932dea0e5200f435df75d2f81c221642f15c1e4193d80f974ed2d0560418f68a53ba8f75f602d9454a875ab669d7c413081340e0ee051ac72502b46ee7b609a0b213d4ab6decd33fa75c65aa717cf108f25251c9f5551948dcf0cda9b13357149d79464ddc084703c2c1b222ed4fdea94ea9644f7ef905fbfdeb911d5f13657fede50880241d9ac7959a8694b8ca7b6655bfdae9572a062cd4771082da482470d2a5ebce6b8819342e62ccea798affd21e00aeba91023b47db4c89e23330c126ec299601861772f4d814ddea92ecfdaae02dab620f7cf79313f35cb92f193dd9452c3c44c3a919889845d1c1b340a212de679af2d4e8bd48e84450c316bfa856131e5240c2f3b516830d05299f045f3d9b1c8e0bd1dbb361f86cdf5b67dfdb74ba1c9bbcb71603090dbdd78da652c6f6c84e818a40c752cd73de22b4f12102d8ada463ad86c9f5858e63b5b2b29fdeab7e9c2a52b2fc5c066ea82606615af1bf638834b390c9007acc669c4b1d362c95a3beadc68ca349029875918bf82c8d38030f29a12adc3d16d292590cbd73adf7e5eb9e171443dbb78994d25d3f82f00306d0083f57afb31f6d3f0c4f1fe6d998f3fb4c2e0f3fa2936b5765ecf2cf32523e61e6908113c0a0f7fe41bbfad633de80f05dce45bb410d7bd2611e8272cb5ff8eaa046b8ae5297cb6fa5cf811b4f55fcbeb5d08c1fdcec96ab24aaded6e0adcc6d6082f09948ad35ff70dfe5157a9b1d12d2c04382ba15803b92e3c31cb787decf5d3e6ad317459f4bd2b0627930547e88da9bb9c636293b103c2f6454e00f3aabcb8abc09c5d2166623102402085f4ee43d0d015790864716129f2d17acc54c3f49f503cf9f4ff6f265d31ee4e1a95a7f10b8da168cd06a65c3934ec4b11896148b5aa0b35f843e3a28f24ffe60f102fa97d118c5cab3d43d9a39d3fa118ec6232f8d95ce15aeee77232780b69238edb1b6f630a614eec3c7416ce16d13a5bcf039404d1c26ee7a051361a1a1f0555fa6bbd20cbfe41eb306e144d72762814f29822cac5a933713fe514d9128a6d86a916f55635b8e554aec813951e05e55555f6491bee0deba0097b3d94177c292ce39988d51630f98b8d3efd73e399e1daa8b8c3bfde583d16cfa69c23faf068b3a210088fac3e51197a29ad217830797bc335056aa1b50f37386db05755d1c9eb8e58ad1c059352fe1aff78b2d92a3bf00456c4ecc17205bbbd80c56fd6f77cecac6ce7ec68491d28c1150a0cc5c9b259597f3a7c6bd559478a23ab09457d4ade6d3f5625eef76566586bc8344e8871d9247d1d0067f49dcf77eb5e6d25062e5b38330e1f36eb06e89c1576692ae471f912e799b6e758949b3ea445c498da5d15bd8d37c1adb84016b4fb2ae1e704c7607fb241277e8d0c97c0258056c3edbab820193ac28845e79cc70a42c57a95c211af35b82766817d6438ba39a78fd23f0c3ddd39f1c804ffaf54fe48f78e69911516bd3e94f66eb4fc3e52ac46fc7d6adcf9d94ded6fc932388cb85627e8e7f0c0bd6211763041a556fe0ecd63cd60ef0f722398c14ce68900c2d353f465b92e8d09b3761a4d89c8e4ab3b61060d5586e565dde5b90643c3f879c99fa5b738769377bbf63c6db757e1118b8b3c589ba27a4c8c3474b584e37adcf1ac91a1945a2c703c9209357eb8ab724b30688f0eb2c4a8d77ec9f5cebc391801d0bee7f0658e88d24df6881c9f411a68e17bc7620b4ba8f22dddb4422bd1a65ef88d85e99aa4b7da2e4885aed417c17177bb6b1aafe03ab61c3d190622910f5609fcfee6ef232e14648f7edf6512f0a975d47bca93be3fceb23113cf8747a2efdd0554e0dd0c397d68943368f2dac9a5d4d715c31d9a316f0e0c37394fb24c885c2f2c6d982711d7bfe84c42595802da8d911c75fb66666b8affa28f21d9baba0b21f326fae060afe2b52a98d3c739bc32b3b3a77057a85a44e6bda16c17acce9001a2e1e66152545c3f12c71273ca29c359bfe9be9d8410e733573f18e308385d196c4cd9dfd8d45c86c98c54541776f76538502cc545b01f537e674b736090206dd3bba0944d0c9a28837d9b62f2db098f504a240f81c273538e5531d325a3122aa74600d575710bf000e37fc891073a3844e64c9303eabad027244148eb53aad1637412adf824a0e2d72fed56a4b5dda94740173082d78eb0689ff42edcaed48a1b472f0219939f5deec968b9a9a1fb1b5ebec848e8ffa7d9351045beba6b367be2b0f6b060cc40b36433022a20aa29504fa23adf2340c007c49730f99c619467cde7d7520528dec42d57aa4fd237efc7c19a71728564104b5806c74ac08f07563e4cd3f1033867cc72a2340c445cd6831434dadcd4ecd6d939bb1c55dfb77bc95d32dd4a35b204591136c605df75e4a0dd00bffe2aed6ca25d504b21a638832d291912bc7d4f7df39ec0f3e930eb60e6a88bfe861a4452e13b858e66454e91ccc931e0e666961dd9f42de9368b46f440acae22a7ff4cf6d3a7b2cd0a268dad5238a2ba4baf2989a320f975ff6b6f106c57d4dab3ce841c0b3977207037bbfa4df48bcd8793a373d93f288b5085d18aa9989ea5258c365aa71674e05af180e9700f92ad3ada29fc8e504b5c2e18fb669f6eddfd359c1eaeb1f502feb593d4cbccf780bbdb4c99846cad38b96aac6fbf94dfaec1ebbcc53df257708add8e6eae738804248ea6c6b3f9d4bdc43feb1f3c0c53359deaa39688510cb1025ec29e5b745ea114167518856fb423bfed38d592dde5beb805d4eca73eb1095cb4e6a421eaf4e5335528219a5d38a422831b738249a1f6dc4dc280774073713215885f048a30717fd4c22c671405729f4a41264b8c13c639423b046765c99e379165980b6e53a5ce46db2f15f45ee79aa03b1b1965505987a5ffaad3ae97cd7880b446eed2d2c82a15010606849861558f87b8b34132ef25b359ab8d0bd14ca8cdbaa7fc7f642f5e40c4545dc2cfa677ded3b681314d6e3c0d2ef07f3468fd9d1ca73dbceea0a442b8a982c27c7735479766ad3dd7d60912aa2a010a171c024239510ad2f875cd5656879c7c8c153c79caf49ed2e5ec71e05b35982cca6ffd5847c9f594564b6663f248f14734ff46447f3fbdce1cf92a1b563b3c3b97723ea109cddce3fdc9f7f4535d9378149f7ce68bd9126d4543e43e8c2c5ef5ba12bf507ceb9020b54291d82c435eaa6a851818680d1ff256b54006ef0490561808914505287b4161d25841230883ce8a1c245d478999f3dc2c9b077bd5f37e862953dc5404a392713e0d82e6399da398a1245fca0af4b5193601f62227499d60b84344950f3dbc37f118d5c74f20dad7be64cf01260a836d764afea6a317785d778b67afffe7ef9790b371f35f39451edfe8df051db661fc33936e73acbe19d9af92ad61c53724d97df1ca20f3b1443ce0a4e44e477939076fd116d87aee257230e4faced849b711ca795f3fd10b1ebd955124b6375a9945bc9d1bedd522af2de74a931cbdf84c48ada30cbfb21d904154d2432d241179286e5a129d3d104d6a19c9c7ba0b7c89ee962c1cfa1de54f66df0d06f0220370617ff55d71c1164f1b26595151a16336f1df5bfdff7fd3954f8aa0556f30f0e6cc430843fbd8d194ad5ac8f185dc1651556d3f5bdb5e3410f9c3e741260d88546ecdb616eb7e7110e106c542c6d0d81bb4717ce87ded71b7937b9cbf5e0c7a100cee1f4e1409ea20d24217e13e6d851699bd1eb31fd0d86155d0ebf96491691056f4cdc9f506251b5eb1d49b10c1ab2fbcf370f2dbe0ab4e04552c872a19a2fb6bf84ed24f87bb64d156dd40d99be22c9d758efb8ca54a54a20052a202661fd1805f5f8beb076003aadac454b4f4f70a10f1581c3322fcc57ad77e79be21bcdc1f8ce7652b32370a596c7a55fbfc676b7f49c52fd3e04f5342a7b55b1800f555b9102799c0072097b7fadd10c32c4a6b2c8c4364c7c071b7e39228bfda1f25f8c5f650179b26ba5d3614bf9a3b086e77472f6a83efaeb3d068ed98039bef27104932bf0154674221fd302fdf0e16a397371483d416d9899f3a17b2c2dabbfe6a2ba8f779678edf03bae144f3217c00fd9b32975c35c2c2785c803d52bfb833f1dd89441b2c5eb44a6881b3841b450c8b23d6179e5f9392224f6d02cf91137d5b8d78417038acdc863927c298113899153dd56b87087a3f9dc32dedc2e1733df018d6501248859c6b58411454d6eca278c4a9b8cdbca494ea16c82c3cdbc2eebb93b8925ad55e551e02a6354b4a244c3a16bc028d17c28fa7094b54e5e9648bf78acfe4244b52e6094eb5e16e8e5bff38f7e21855648e5775894a55800d007dc03167f7a7e90699df2037bb26f99c50db1bd2426a2e392862165197cf782d927289b2f26eb20dc7a6d898a154ede0d270a7f78e394c9e94043cd10e0e5288d284367f920341911ea6fc0c40c38a8f5598f6d3aaf4c0959793f6d7f0fcd090083ebb24e032de728f04f7110b463e4d38c0bc325591bf6426cbbd0b6acffe9667f752ae41e2524488804eb23566cb73fa573208173a8b086bcd06bfb72b224d28dd944b0e557db0ac2cb60a8ca5b9c470b16cb5d54579bcab22db5365bbe77adc261997d8a39b14ce82e123b2897edd445d3a88815103b082a4a53dd3faf6f5afb74dc820ef24d1e5e2aaade117331b618aaab3dce75847fffa897587d38cc5bb2078fda8e0152462ba886ad5dc382bfbb04530f3687277ee5aad6f1a91b7fa32cffbbb3f427e8ffba46c6bd779c53fa7ba1104bd44ed921aa14ebb0aeafb92209f69f8f53bbc598428aa0658ba78127f8990826b751d37e2ca90f62494190765ba42f9c559f6735657f6507c9be3bf80374585dcf6cf31f28f38a1460b03edc46aba0faf4bd57a3a5b383004a657e410a243e4f4acf5f544b1f7670e4cbfd69867ad3dc8700b9ff933b75b7b74d99469746dc6db0ee5a057d20c2bb31c8b9821a65054f9ec8c38cf017ce79e193cfef97e01632b99b0e7b187d5a83f036efbe797b8290a91bdc236fb9407bb548659d4fee04e294021546b1a952480f4307485834b1bca968e573964963151c4df4b51330eda5f1ee04d3ea9a95efc08de23cf0167f4374710dc0c7aad48ebe7e64449fbc6cf50b518b8f51b4b8c5ec1dd49f7bce0e2d40d997dcdddcab41f2877eb671e12533effb5ba948e5817c147894f734ab21069ee029fd33bc29dee9e242f7765f3d95d54f0b505e843ae97024f8260d491fbbbe43c8b86b57be9e9bd4644b3fe45e9f5f1e22772abfd7983de5baa596a45d2b20bee34258318d69e47a2a970edd48896064337a0b71d6f8b2a823c9f3ada81ca73d562c6b94c59df2389c8d651326845f838463bbab77ef6f02498a46754be553a880a90795150edb32cdbd90ac9c27b1ccda900374bb7de50cd7bc384a7d195070309cd22f401a0ec3e346928b37f6a895e33107c73f876724291879add315aa46ffbe7ff09d3c0d742cd5b40ad85c955b22a815f193cd43dace2abc32f1a9f4ea81803a73259f6ece80047ef0e30f3fcab2c954a02d91e545fa1b87f096aefd4edf7b5140087fccb51ed979f7bd0a4eb95e03b5b3891fa093015600752b310efe177478a4bbf3d85b1ed7dd51fa6b4cb02f7eab61b4a0eba3e68313350c21e3aec83a2c8b64401c700c8da28a13f71aff21d26fe3a1c51ffc0829baf200bfe92ab7f7867bb15ad576d2dfed5774e1b638116f815bf8af5d9bbb6ba121de85aae9fb067f1dc30f4496648ddab70fbea0eab3e7c46200c374de93b15626eaddd000e839ce0c149b9f0f51d0704b66d8791bd30f930966d5e21e50fed42e5e7a2331a29b8248043cec6228723e1edb98f97ec5543ed4c7a25602e174db323ac9af882304566836f8e4188411349c9dca38c6d9835c62982071a03fff59569f0ec727dfc68b55fcfc74b0fba309b8d67a76ea1861e7468e36c042ad8c48e2934d5ddab36feb64625dc58555b4a05174120461e5c8d52fae664e20c689aaa11ae68208a81f33c68d41c363219904730f4e03baed8349e5e329cddca24ba844f9e2fd73391c67bb71be80883809b5833ab5110e49fda79b8d3b9722ff443b6d91ff45866d8be57753198e877e43a131ad2d5f3dbbfb44915217be5cedee842dbf909ba88ad4f4e2b570e9c697795c6ade2694d4f0f354e59fce67b28596f66d8cff53db270b5b7022a181081faa3aa0a8de210f5022852f347c19ad1cf9a227074405d9308fb629e889443b48d5932829da09ff640add4e23ac44a1bce45a3ea8345f574e9d23e9b46c2f6a41026aefec366c445d377eebc8044f1d9a0a802f61cc4ffaa3567e270e1f39150cf05240a9f2fc993ce51f4c8994f35cc794c2e786f4d5208ce67698c607f2fffeccce4159b3e01e63302b15b2f9e45fd5656c5561abfcb5da51101d41c193336044b07e22e6166ce34dcbe6b834bc43fa2a7a000660f9ec385a85104df43c11c594c3fd44f574932978b3ec49485f1fe058a959d79bd1122c7aec99debcc8830d6495ad700fbc2d57341286323068c94cb77f98c395ac68266b53b0bf5c6b7cde69d6a48fcf2955229dec4a5f6496b0dd8f14e2c1047c7293c57dc4cadb3e120dbc5a6d38f0f8195392858b843717a9737c5ae65dc724cb21bde8319e1dc44580cd084ea85589b5ea5b093c7815fa88647d541b1fa76caa4c6939bf6b82ac2554e055c7fa803ad0603fecbff4bf70065b2427356582d5186c96d87118baac43ede7bc781aff17faf0a0f0e5cb12568926d4a4c1b39485f0e109c8f7fb660600406cb31c21a5a521e03f846127d157c10bc89a9a81c0abf1e8871c7a936393d31ab651c194ef2198f1d680a15073e127d79d41feda7912c0fe8ebf0726c1ed5b943e4db909410381357d24a015b350bd90b49c92efb7f48bbdc859bac9ca16ffb4fd15ef4f67e334c384dfd8b957a811e45504f28236f90f2376f7741d2dbc9520f22fb463095bb1cc59288c6e87cf3266816abe525adcba9ba5c0aea6eec05de5a22de0932b63f671bf47ec7a6575a7123c15654aa8d4141fce04911ad64a810c4226fd8fefce16b397cd124972c151d04cc39d5aed6caa5c4d069108c37dc7bbae33e24492ce8f752fee28c774440fc3868dbba33fe2824264244834df72fb1b198fcae0b780734de8c1800144f3fcf81071b68f631c7f2ff8d4ff318d71c857f81255a4bc73770fb1990690a7eda1c3e05ab855f1062e820e788131e14a2f13f63ba88bca4aa6fbe74c48122436035942c5479b723d916258ef6c6d7e50cdb6a463ff82900c00eb1e83b3509b87b0184215f663ad4ef102f0e7107f07810d590d5f5a842dfcfa8ba2f4e3229f796a78378c62778e2a90fd1c945060330dc76d60e413986e4cdd6d174f4590b397ab5050116092d63cb7f2bd8b06e0aeb362b9a038f837732d2f40dff09ba06ae3ebb1ef3969dada7d0062445cdfc291ee844eb79ae6dbb67d233ba45f419eff7eb00965f2ff50a85b5640581b68ed0441500a9b13b8d2cb380599e067c6ff6c40ce944451ee6b9a7e071670579af71056a7fdeb1dec80007e08366ebba97a05a309c36cce16a2850e13d93221f483a53d7b1623d1448f919538c94adc93ac07677549703de465df398ee076f55076572673eef7625686c818bc654aa94d0bbaf8b5d441cba0d5ab94bb42f34dfaeae0ef1f84509b5ac86bc5562545e341f8477e436d88ec1d78c44a4e9295a6303ba127a002f83d3458663282eaa9c25503bf9aa4a381eee8e6c5e133862666ec3797453116d3e2858123562aa02a787b243f89871bea1271bfba07c839558f5e245f792a785c1eba4cb2cf31e8728c7fbd9439a1f0efbd1769f762ab2bb50a8a3093fcab8a89387f3ff2f4b5a63ab0e238a659a109395e9bb2641ee0da8b37bc67b73f7839f4c63f4ce04cdb6f8680a46b63197c2352f661ff461ccfebe7263e859958266c223e08049527d5ab11f6bc894df6813b639d6c68b659e906a19ec215f68115a83d922ca3865fe4097c930809d6c9a31ebc701ef23ce2151e6d72d9a0191a6575d605192dc93774f3a242f66493dc390861a2a2df94fcca674344c33cfb0dc0c37d5eab2ba1ef6561d50933033450c6f861ef95f2d4359db70f9a632f102daac165a836ec96bf77202032b973b84e658f94026014c173f2ef972911aa0964526c56edc7cdcb554a046b3bb8ca40b6889fa32206d7cc20b16956900f794b7474768217cb66463dd508dbe2443e09cd1250655ef7cea1f89523c58361c9a644b687ac5bb78091380d6faabd3240ea823a7659fb0788d5302bc04cfb687752e81e47c9c946cd10e8dba1bbef56c23cf7d9d902cdb3cfeb842045b8de27abb55f798b0193f3f56437ec557e55460fbb2471f1fb41e6557008104b2ec28a96a6545a278dbe178056368642d4c24423013bee47b6da8e87ec256019077005de600967cf802c24fc293e8c3074eb3c8877e138d1cbfd61ac94b5280e9b4f370793451d64ce2a271c9118b3d5fbdd014e3673d0121cb51857da911cd4e7c25136cec5ebd9a2976c225ffd414c6d00f92d3a7aaaf9bae90533c8b4e1b0d928c8e44b65e3e7aabdb4bf1b6a5b264a1f09eff6d99d782827eecd22d2a3f386ef83fb1f370927862c7d745a0756d1c210af62cdc4ee8ef4c1085cc02fd49e996406a8051b241e0f6a40c4a4e081d72bd35401784272facc09f2daa6d9cb32afc57066133c1a32e196a144f210b2b5e9394f170311e7701d15a10f516fa40d8873f73e60c10cda9dcdca9e787e4c6c8438468873f1c8d7a4242aeb4a52e6327bb024f602324aa372c06393b1fc608d56a0ad89021673a25ca1d840b36fb06715f6e0fceebc668b48e1c4bccf6f2fd6dbc9e4a427a32890714071463bb12f87c22dde4a64ea29e89746e7172c2342f0b6d7b19fb4ce5797edfea79cbfd8ed41cec2f9be288f2fe60e95ee5f35115b8234c4aef897b089f835f00cfa64e3805f11ba0a6a693c5846866da5edef7424068ce0c20c23c3923f2ddd3c1b1566b8be32c6237e3cecae013fc89ef14ccf1c2211f6327694c26b4dd361c8bdd311ca5c9a6d67b9970050c6df2f6f3c32c60b74c6e49c79e1b25a0ac4f9faccf47ef06895e4b6e40e3376e91bc7024cf3ae65670591ba1c01b66394b1d4aab5348bba2d802c6b69f3689a1265d2df4755cb0e0b156b9e72f0e4f69dd3dbc964bcb3956dab4f47885039e04de20962dddaf9c347840e4e7cf94775448039696d410a338df504a66fb88ce4b4ad99b4c0134ef7623e08dd26d86831b9ff1c212ac6f264754441526e0ae859600be2bcf1a2418ab01f1fdbb85349e4356cd869e8c0639cda44adecc4784c04bfc4ce5ff537b9bac0ca621bdeb7dbcbe262848cbdd2c9ead42de6c1e3588d88cd54496c8d0f54efdf8f655eef2df7539b5e588428fbbe35cf4e62adaf8f79ab98668c73dc2ffa99f744e58d7dd0006a2b67996cfcb56f1836b5da553ec418429ec4e693a03fe506a13a8f8e2d9f9e2a69e0f1c66baeea15f455e95864caaf5254ea1330b9f41f8399d5967b980454f0119a0a6b81404ba56abb62f46204fef9c2580e68c9219aaf7620b97bf60b22f051336fff5c02ed2350c0cbca330f207be2e277a4e1eca245ca8a44ddd00318a4c0c84609a4ac341bad77cd254dd685d5254d9c0c329a6d6a59c7f4679842895ed5b53ebbea09d8b87ee136558b9336da22341827c1676453a48eb0b1ebb37a4f812b375d231dfee3057313017028f8b39019600be927474350beb069f56941d617335f76a68765e5865bc61e10740a0ac2d38543f22ba5c7488c8ea3e4fd557d3b9cdb10dd93712e09aa6ef1646ef1ef6e1490da38fa4af1ee0fb71a2a4312dc8167c5e741691e09d0c443ec0472c44fba114651be5ae775a5e2cefabcefcf14393463e06a9306ee7d94a8676ccef47cf457c3b501247e8bbf6f2864f39c74c2ce55ce97c10a7e6ef5ffaafaf50b41b55a6728151150b40e1f5c13de7ce41a69091a05028c9e27ffd8515675621d934bb192d9f378ef7a14e728a34f2f3f72af6700ee66e1eb7079e6a1d6add118cd1ba9ad06ff92ec0dbd785ccfd82282c69a47d9ad0dd0d38d4e87089b4f71bee4329d41345d47edf202245aa80ccf55b6e48df7ab3887ee06b19a0e61dfdd8cc5378f6997f7f0e7c02274681b27eb0eebf37eddd73f7a7f9869358a7755b64086cde1d39808ad61db43a81c1e7b86634c66ad62b414f5157fc87cd61aeedfff62d826f42bc55dd25a19e43636fd1eb4fb7950920aba3803f96402e5f4d6d45b32065b12565cb3a5d8a90a8e2159b169c5614183831f5deb926ba957255397b38e3fd22e8672bd9375669d4e3f61baea17600f29540cf0f2fe2ea0a8f78170798b2e962d054f214286bb6ac5df333a40dcc617bebe4f7ae0c16942b3f9bf729c833e94a2b77228fcde4a3bc14845ab2cc1f7e929724ab01d102d2ef2b34cbb996bcd63d2505bbbbb47fbed1e6ad91d2989375eba2bb9d27a20746444567a40420921ceb9c479a3a35cf8f9160130f09304a8403a964d1d5e5b59810ec6e378635e87fa0d65467463b20f45f05a59c7145c8e383ef72e995085c166574c6ce32fea5c019f9e2b6e763a421e510d4d91a17505e6849424a119f784c1d2f5a6828c65564c6a92a4a91f2ceaa1e8555be837347777bfb7925fe8abe3968d87d2fa6bc308281b7dcef324dcbb89b29b6b731d60b91567dc5091c86afd0ebb434d649a1ae77ed00cc024eaadaa2cc91031b4120f5cd37c4e1b90e730d53d02ed072d9fcec6c735c466a8dc2f1afcc0d84968668dce6a21f0c8b2854f885d12b93096ac9844186eccbe3c5da3274015aab9131981114e0e5ab919c701f83ac55d1634d996e09a3f67500cc5d8cce7dc32be8e7e66df93ab0eff5d4273ec7a6fe06c18f3e08c83aa7a1d77c5ee247dcd9e108880e30ebd7e05205f82275e4e2d32dd0bf6d190a2301b3e392237c5ccfdef8d6931f153677e0212692b7c951f06ae366cc987827acb8686da4e75892502b62f200e6761aeb2b47715fde2d209fe5b3c617b66bd44ff62833d3f5eb2834516971dbfa39466cf9d8295e7ab190107b9138a15159a922cdc2a98ebcacf293993ac42c0f5f0d768000bb5a66dd037d68536fe4b0e4666b908d215881cce7ec56a7b8b0c1b3332264a73ff189b25fab91795f31d1788dc10deead226f38fbd0cb0c3255381eb83409c289faf8a221d1a582d6dd3fdefa4abc353a93e6b1ce6146642acded7a04718b0f35172f4a28d2094605899dba2f2effdb2f9320ba93abe7c08d2a53bd853f54bf817b85d5c0f1ededf2a36e1e87cff5d3ef7c1389e1be8f63c455c8884f91a115f8fa9b628bbbe787751c319d22b3b4fe93551434e1e61cc187873f9aece5105b23f64132234192aef808eea44a3a9522ccebff64f53cf8d751a87fef756f7c03991c39cb7310b3c130e41c0899b42139a499af7f14f9c7c1902b95c2279c1282716d9b15dd31868c9b3ed946c724fb03efcccafafef18950caf697020b26eeaf7345c1eea291b252540942408c3289378674daf79e173ba41e3355575041f2360256176814edfbbd084867ff5a5bd1ccfff34abdc495a5b00709bc4574592967a67afcecad268b40f4272800db70b1cb074d1b10919f58bbd8c54bff44de0ace5e239e8c9bf6ed8f5784652bf4d847f6f2be0532b7aab2e80aa2aab012561cb79d6a7ef1af3f32e0545681ec1617012c1d37ed85850d1eb6deb1ce1d4f1027dcaebeed974ae22866304e49f7c146797589666689de769a1f8ccf026612c5376b7438b20411c336fc5d8f1945f80ae75b778113419933d167f0e39e11c4608ea480567e29bb87e99f1a4008cccd1832a5f9e6bc9626cb357200df7ba5900fc08124c06f0922696b3b61bb0a7ae0386684fd7115fb196da32410efe98bffb606e6d6b4d776dcbed22ed802db126385d13b9729cc07cebdff0d515adf10b8774b405da9032720294d7c237465629fea5f9d750165cf6ae9324d2b8fcd89ef3138adaca4e2ab878ed02b47a613b3c7d03b9f70902f3357f320d8e86d683280b68363e2f4f612ffca1dfb844850dd2ce71fd068ceb60f4ddc7a148c995efd5a8291cab683d23efe25c732ca9504d2422a3aa6a17d08738ef451e9f97f7918ebda3b9439141555a203da19b5155d98aaac7834b054d8a56ccf0183f23af36644f8600ba11ae3a674c191ac46d885b2ffecc06809a87e5d73e93893013571898f2a31eec9db8db1d1c212e3612c7a397cb1b131795d083a02cf63944da57209510eeed0688e212089ad24cf580410ab369c2b51251677ce4cf8fc4ab5e668fc3512bcc1d668db16228c7b5cabc85370de4756825c54c357103a11b9a91a76b29ee776d85aadcab9c5734f2d098c716c7b4ae29b04f0885f6e2364ac2a3eefa93aaf0b74d306215ff94cf1c4ce64aac93611dc9f2ab7ba5f6d2775c9376e13e90932671e08923fb5ae1930519a45d6dee398e4a9fdc87effa9800291ddc355a434aa4080bb5dade486f641f54b960067e007ecc660db1ec0b964b2a87a7d584895a53722e8670c7ab9a8e380960ac4443b3fd8776d1e283220503d0157be57863f89a038244b0d999ae6c074da1acf6b80fa3f0ab265dd3c964838efdb3c6c5f9d748f293c31667dc9fca9816bfb3a4c584b55f2cdda44937ae102cc66bb4b5c0de2c693e173f426b810aa3f44000037fb59e1bd167731c95e1f1ac946436bfc743e232cef94606490f23a5b6d251084608ca65f46b0dfa332789d713d5f6bac797b0b9fc9d86501bc452665ae6866750044c8561b8528d1df38a26ee1278135d7000eed7ce7c2e3836d010a1c38f1c6ca11ebe960d63666aff48a48ab1c27aa39899e5788724c1161afa0cfdbe46e03be69fbd9978bb31706b18e05595c0f8c477c755728310522af26a4f4d2688f59b5ac7f40799c0189321c5f31ab4ca4620d1311dcf9e0488938c29a4ac66bc36c13333910152415618b6672a1d30edb75a47e754fad98a4d905514727348ee880318d3af59e97439cba10d3bbd8944bba2139d0e3449dc88c6ea2e5479a5fc6ae393afa7b4e5d0a6cb5edf2ec3715905879a3b1fc9bf44b04b818ccd6d57849becd9dde8f4c06362935c61ba3224906206c00a1d6e0ed64460e39ca74aaa2d37377eb2e252e7386cef0f02bc3479c9e270f02e760821badac56a9bb5635563027e97f74663bb486a6b22d6c746be9e138c3f6f27c53f43403ab29792924c6a868412c1daa68c212daa1f8fc36c6b7a0a94e3150000de3859c470b57457b292b539fdecb824ab7a1b8b365d26b445712d909f8c5ca9b0fd6a7c235b7df0d9bdbf54970e335de3103a6ec53c9a86f5890399698c3eb51b1046c3cd2e9767d59868c554a53a162acdc9406e60c61279cdfbe91776a14e6364c551802dcb17fb3a8621bd2cc2b124dd9361b28a24baa586111f41bad5d7b51d74c4eed2fa7727d666e79ee1327eed6f7e7594c5fde7a02e31c1f85534a844bacdb1a63277b0177a4d14e14542281e224ae56ac34a119c22c15cd3b375a9141142a02ecc9d176ce1ab470852bfc30b438c9018e87f2b9f1879e3487ac00d7195bb919fb843c6f6886c2419c30888f7b7729e43f5b7121028ded0cb7abfc9bfc9ecf1ad946a1e3f11b73c9ae4044c13f525cc0dfa09a6ada9de54c17baf72feb8eb9e6719cea68e78cfae88d92a779a3b31c6f4273e6a31ce5752032c956b251341e298147d5603163bcc0eb2cf5af893e9a1c2dca1ba2bb8b27015b45e815a8aae5041640ae75288c06c3fd4196033bcfe018896f694ddaea218efed8a831d579fd5eedb9f6c03564a3313e43a8a9536877be783f32ca0bbfa8b338d751217a7903c7053acb56e457133f332012ec1af5b5acaf8174188ab696e75e4ab8c3009cadf6817cf232dbfca6da6fc753a8ed0c55f0393170d910d0a3c9121878449a14a3a8d382129928848fef1fbad7a23665cf44c606946af86a6cd1913369fdba8e1aab8d3ef07f030e181f1fc1abef78411a12541f35148e918c9907eede8f6da1e7aec5aee27accc9f9e477a207a6962a4f2a4771b98f4062e10501ea6e9508469e6c6e752dcec1e7475d54052a16b68dd8666ce1e09198dc2c02b70a666e11474a39bc5d39be95238bc3980d1e56610c0f2cd4cef66486bc9ae57304e806310c37552bf4ee9fd562583622e862901d39884be33c19e93d334552c7952845a33cf4e123981a76794b037f593b777199aeb2ec4a3b4a98e97512a78d99349eaca276d364c810d956b4315cc30413ac51a0bdf276eea1e0b0f7494e7094989dc29c1493c73bdb3ffddb0c6f1d9abd28fdbee9317e39a200c37a725b3f39d041d5b4fd432f38eb239126aa2dc40097b64728238f1c45b7dc21395a1f130995d5a93ef3f1343651eaf764a168f95f71c03c2ca430c75d2fa46bfc590b68278458b8865b16c57f35fe40b849e1f77002a6ba5a4972b6176e5b1c9f2027ce66240ba44dd1586b8ab8653b96001d0977aef1c00a4537fdbe008364e19cd0d4c79e96385292eb606117d43a8910540fb916d7df7225487cde2ba9f65fa93e52d00fc53e6548e7536dcac3f5b3226826f83872ba2e8ce5e16cbf3b6ddf8c8a504633ea8ecc0691b7cc3b7b99e26faef0b1e905e74eb7033ab3114e5312aaa6ca63bb57e7824ce6b716cd4d2091171560549e117df411e6681e89b8d2443640b7dcbecea1e5a3d2794c763bfe7f78e8b363ffa9d047032f6cf1286716ab7b3604857acebf5ac9253090368cf98f0ad05074e73b831f88430952b078a17622b3356e36560203ef37e0a0eea60692127d526512ba6d2be395dd2cc1660ee76528387aca27dc59fa74e73fd805cece530f2494d3c6f2430924741b8b2e0da33bacfb0829545a88ed6919b74b230566c8e751edb605efcb36ca05e8661fc62c2cc028172966ed6df857e973014fe2348d7d6d9a50a0739dc44ecd9e7a05498366ad4ceea886cee3191219579441dbf33b702965762e738067cb13e167cb8a1cfe9da1b0ac6a05a90590c8972840543391c72b5bf9ece7f79a483a0d4b0af5c13c71ed59862aa417d579263b19c95f66b4f8e70c1265472bacfa0dcf56ebefb9586bef5ce4fc6f2b1afa7635b54c5acac44b6b71f0f033d56a71f869644f386d392ad04455ae762c9f87ab5620759de0e1f56c539f915ea52c4692020b1742bb651d0e47d55d5a36a2f0afe5fd28330995a88b5874e21788a58e7c72836fddd24cdccc9e410b2c01ee5b50c794ceeb4153218b65bad4698fbdfb6815e141e1bd5ffe2ab62ce21bd8fd8ad32f969ea07d7f9edd2b96ce0ae4d9b395f744032662342196785061fcdeb25ce88feeb493400d4bb772cf8cc3175ed7f523018dae08c0fee1178b8ff8042267b830c561311371e9445cd6150d83aa2f8e134f5c895cac98b4c3b4c6bab52f4e90c8eaae162e2fd8b48e6fcb3efdf6cece39db35a52137cc3a84caffb9762025a1c56adaaa29b50448bb31a7209b78f18c122e11db101aa12ef850cf9230ee1d66cb4bfbe01f74888846d44c45fa272366496360002198315572675820fb60321562660487cda229e0a0980cd64ebb881ac5d583bd8c3584d38414e8c04365177995c6886823ce60aa2c7642d4f0a82b83f3c8420ab9b0a01704c478517d9dbaa03cc228a7796d6189e56e16c0989ead2d31a3e32141e7e4003f1a175d404bbb2ef8838689735369c8c6bde5059694d300defecaec133f7a19a74b88da1f8b939a62dcb7dd4fa916bd371a6c9ae75a595c7f23fe19140ab602fb3ee4d4afd19e74b2ba4b30d93d3de1f15da015e7bcf96825b42d13c09781367a29f310e2aae7de8b1586e09710a5edef74470a990ad72b775ba5588bc3235329834077c1b2773e98cfeac942e4b1adbc8a166f8d8b08156cd0f23869784a3918011d4ba81146fcca4575f829bded985776f6716162a783ea8bce9aa0286ca9acf5be254ff8d95210fb1c350f306bc4be0822151800440ccf1d7cdf1290d5e7fa4332dfa380448fffe15d77df0f0066e5fe792134d4e2d853e8c370943727e196663db88281f03ec3aa04e5d0efb9c0ce2cf93d918cab05157751952112d4dcbc847ef2447f95c64e91ba7d7a15c0ca545ff8c1831fb9fc90a93f3522e2aede6c29977d0453a39233083e7e4979c744459f854a8574f08c4efd163037f4f08ab693aa193fa22bb98d1af8b86f512d04abad3ee33887d5e0e5b0d202cc23e45b8f20f59190e19c858d3ab821115abb2e829d857dd88ce9147e144862830179deb2c179e735991d4bb0bee4b379301115dba26aa7c1546de1593bee977fc9eb014d097b3baf05b3da3ef8e2deb96b39d2f6173846afcc5436447eb661628fb47267b9046312c42ede8974558af03be1fe702ea2211bafc0aa23b2f3c9d64b0877930a8983eb26f61765b3e8471e00e46141e62ff2bdc334951290e71d043566c2d65e9a82b3bfbe10c6c031ffed687d2e169ae78d6f5bbddef9cc5cbeeb14f365a2a73876803210cc14073ed36fdec03ee17a3a2d535c2a1971ffe8b7adad208aacb1d064d0cdd8039e27540721294b479f155661c1a6a71aaaf9321494f4dceaabe058b86b7df8dbd3bc5cf89c56258d6956fcad0a2f718d8e5d6dd5166f2ec33e71483b78a791ebb9f93b2cc10b2b86163f870293eb6381e0a593fcd1bc1b673b0db7691beac25f83a2f18cda681d1cb43829b9853e09469e9052310c8b4f292706d528da39aea4b1f8029414838ab6fe0ec1ba5673292c38f9436155c665ec8c7493f62892fe77a3923b6a65a66d205ae3fbd7d7a3123e0953b8c2c2ecd97aea21dc5dac5f12526796e6fa90a096f46fd8fcd1271dd1f9634db1b7b481f880103d7408175bd971424b200ad7e6ef05e66e04f9737bc3c41473075eff7519378ed41bb22177ac037935fd14e0f2608dc3c2a1b59fcc25731bdf65eb6b5f253b7fb617f2670e0ffa1b17590b5072202918aa4691311c392bd5496be4d292a53a6ab2cad64645bec067a809f8f2b524c4b0688027b54fc143616d85ae5aa17431a5b9faa7a918a65b1b5df3a994779006818b7e90ae71ee89f1e9f4951760967ae152993f4c46d0fb6461daa841c676d2d3ede109ad65da3806c07faa5f80c42b8d4295553d8f8e62e65001efa040d5f26b21083d0a2251911b26e02b11464f441954e85cf9a46586cc77d6e9b228564d4b9751b97f4f49ec5eaabf7b37a2b6c45a641d6f8e188fe2265b29ea07078c6a1287b4c595f7ec78e37318efe059feeae8cf8eacf3b8d76b7a8bc169afdc0876be0767bff9f3e575e66c1cd296b5afb453b00b330dac370ac88817e6bcf044cab5b32e21475590d57fee13a9d4b6035da4696ff7807ccaad29ea45a573e21aa019ef96730ed88bd5dd89492692d678fd89a7dab185873834044f1019023ba528e0d78daa4e53db288b129c409b0e3734089adf261050f7fdecdc0d12e2251a784c15461a661bba958194ef1caca69d7eaef9052da25cd436324768dff972518925103cd4a705a9ca95e29daadaa57bcf7ccaef29464b1b321c0b07379410f70794b26dc6c86d488b3a486f2418ccdefb1a8584a5856430a6c25d6ce5fd28951118aef81a335d9fcce3e44bfd7006e0bab6091300fb9c9db93a19f2397d31054374415f40907a66dd033465faff23acf3ba76fc2364bac520fcc9939065aef8fd97a10ee155ced17d4f92055a3f5161c04b1f3eb4816090f673552260cbb2b2041d320e807932812f0bd7a32ce3b2b7ca86dc07f1772f7cac4adc4ed9743ebf91b13d39105eeefe2d3442f2249e449a1385d762c1870365c951adca1e9484ec356177b20d2526ca384d4250284e211d8e4f136197c030fae6c1ac55f1d6178eff9adfb9a2cb0bf553b73b1dc7c7db70fce688193b5b55cdefee5cc2590a6433951d83f73e00328e143539deb00d9403ba9db837145011a7032d7fa2f71e870450e265da0c0fcabcb422ce7167ee15dc9ff7ce11ae9371f036189ce0d45388e30f26b01760306905741489c07819f9eef6ed41303f226527e64e093c1f78955970e01a20446b26c35c35ee605e1b7823ef930cda3c041b621cc52eb42707e21942b3aef78d3b46c52b579f9ad11d1e54963fdbce40eb74eb52f6fda56f453fe5f47128488a080a1aff15462abee93523ec534be7fd83b7d4fd436bac6074c2a55305238bd4352d410c3e36e1cc53a2526a2f43d73b8bfdb247229d70f7bfb84d94cf8e228868eb7192ccd166af4dc425531950f291c026e7681076271a49f5ea97ba65e165e620df7e21bb316f7ce5948a9e13e27c3b147c09e3c6bed998e0c95a9b98ff7ad2ea7bc301dc8576e3bf893c3cee3b2e19c7e9d7262f8967ab01210e887f691d04d946816d2bf0bad8e055a46172feceaea128ee5807a98f8d278748a0965a3fc946be82365d9f71cf3d41874c8733d5227d75949d7452570129365d5e05d237e95f391899d924399d8cfb41adeba87085bab5ef34d8bf2c76cf44e8a0e8505e6d3f1d7c9df2309f20aaee0ece5dd462f36974f3c4a48b88e82a09c31e9a4ea0bf846ba5ce9bb54566902417ffe267a9aa0ae63f3c400632ce2e25e4b7c70ad3fbac3d16e7ae972c1e99da8c4745af3974308393d2c9f768eb947f1ad132e6220874056dfaca2e83c3536eacdee487a0baa1eafa677e86f9176080a2e42ad7dc4ae9311a54d8f6dfaa9f6636c4ad8fb961c91f55780de5b509769b701dab1e3124edbdcccd60d749b05b9906720dad02de56444a2400f4b3be25d610b69577318f6c5f9eb851f11f820493f13f4a5704ace7d7c1a0c677eb655a77dc499ce091c70bc66e4f823ef0d8c679eb8db119eefbcde4c4d2ac2adfe2e64a4b9c493f18c380c9ea27f9da6440ab86f0467f017ebdeac0eed567a84296450782e92875c5fba504651e9b869411378da101aa3da75b0f62374d74090afba235355f5a738fabe0cf03209098dd35ab87ccf3ee9b54ff1691eadfbdef2e356dae2d9235d5a3232d9a3e1f0c1f16647942af7fcabf30fdecff764c0df92024cb1c7e8d3df825b9a88da2bf2dde90cf69b5e98df375d6df63cbfb7286c5a11c75f6194513def197c1882136e55cfefb815d8ff568cada4162b6bac7d49d1d870477f33e3329bf5fd3274cd246ddaa8bf223a0eaa6f1a01ae73d4371263061707bbd59c67b5be1e67edbc33b8914cf6497464a9035bda35b34531d86b9fddbd9bee8be95cf413651ac08b51dc1db116779d0f0fc129b0523d7c508303a644a785eb220b52f5d37fa4e3fc9134877c460474e2d37b1277e077bd4b50424651e19139905ad3cb07b85d8719d4db98db19dd79bc7ad044474e73babe622efbb4b6af97f09c2a8c644a71e2407dc1ebde150673a0ffe8b22f407c6228bb994d300acd5557ac13fe60230717a188598838fdb23f4d684bc45cd30cec6f53ecb4cc40e275c3dc6591087a516e6a6994e84e5783680fcdf90f66a3f1121918bb23b136e8497fcecd0e6fbb2b22d77508a8d02e1b73c499a20aa547bf8e92ce1031b11f06e77038fec3d6b0e53347ef3ac29197218497925076dac450eec3ea83bf8efbf8bf8b3c5d3abf4082ae7badf8024456250275209de6c79212c00288e0c44adb6b22bb6ad2196e2ea2abbc2bd5e7046b5019e686fa2ae21b093fa7fa4870b5c8d191868cfe722ccc3fb5d86a063a8ade508ccb918f55e922c9f56cdf089804345626baae6636624b03dda335dc4ccf4bc30cde04a3182601ee6e64d2f981e49064f9fea2680f0b8762550cbb30c5af805eece4607e4bb00e9f3f7e0bbc94c357085f4a9a0cf4ae560648ea9aaa6b1603b4f96b1626c2961e1e5b0cb85f035f61fcf4f0169acf74fe17c7474f70d2fd246acc12da28d52ff4cd8c7c7edd5fa296024c48c9d4011ace210879216e3c373b92225a18aac2f73ac965c8d99832a6a7234e895d2983c56e4780b3c3015d2c6e4fb9a76cf90168f1218b52ee3efa10047b590db89eb92109946cb0f774bfbfb9895a944d8c57e2de793e6a64e036f6c8eb5645aa739aa4e44fd4064079fa434cb0ff38b7313f8df7acab78ee90eb234cc0e28dff9cdffd28865870e6606ab73c71a3735f4c4dc7cd7bc591a63d75d27f51a9409069c214bd7e10130ccf84355c80754561f697e0ee489e5ecac56ac64807aeceeb1e28d921d63bc96f9b6ebea3eff34ad3afa899800fd6749d9aebf8b5ff17e00a5cf3431f5ae14f1f7671964dc2fd4b3e015806ba6627cfb874899e548de1f4cc980b8f61b94f19219ccdd078761edd9fd9bf1048cd2e31b0e00fd014a5552c8e0c07fcdad49cacd4d23e309fc310a116b85fe489d2e25c3c4cd9b4d362be67f7f1d5617b60d45057c3f3e8d313163b1c219e7e2f4d7a1a0b0d5085d149490b52e18bd0bc62f72c0190c66e85585c1a24e0068a54efdbf4897a89807250f5f913706f8a151a2c260979479ce44fa5465e773a1874c737a89cf5b666e1b07e3f9bd789533bd4c6b8b13a4de9061506a3086e0049a015197bdb426dbe3f1ecc9f9e82f823daa08eb53a71c282dfec086a278f1a0bf00a8442cd7ed2f9ceeff7cc27bb262d54de61b5dc851a983f217437e669d511111606993ab32d44bc0dcbeec31f01c99439fe5a1a6c56253d346da8fde5c3a40e2606d968f0470646f71d3e1df7c7562cd8354f24f92655edb7b276876ed98ed7999650b3a57116ef66a33bdf5e3d05d6fbdf3c51d4bccdfdca806a1031dcdff368dd83dd5a4354ac325dab1805a7c5dbce5539963042fd46df6a3b625774c2a2229fc037bd9927ffe8afe437e5156729db0a862a52974c6baf3d14dc97cfcde5b59086781305dfbe8896e24e24f19dc8d187967257d548c8dbd85315dccbdad32e4d22eb201db285354987c70d2e15b9baf1a357172cc1329ae6244e199b48bebc49d18b013706136c9e8c6f4d16099e32e68c7c42f85f46cc8fff6e3325a464b2f9b74932f56c228a7d5f2074e5c874738630a69427d0854321b6ec3bc544c746c53d3f82793668d0ce7130ae2105e24cf307c5d6edcb070f8ad2ce669778359bb42e6fb4f73a0dddc01688f1b18dd95ed46e917aa34eff52e87603651b6468b85a451075ed74c9b3149089494b6079f46dea022f9a85e1c2da28cb2156134cc275b30b60c1fb442160c014187d6461d9706347432de068eae0a97a878602ec605e6062fbe904c62f06942eb5426fb53f539e5aab23a5641eecd87c2f247290aa2961dca0aaecb905d946cc658451ff590e90bff9a6ca3c0ce0b25c5aec4c16b6f3ebbd3f240b712a87395f520b07a314ad252ad006ff155be62a87e69cc8eba5bf898c567b0b0f2911fb6a693fd1e2222f9bf0b5107dd13950bd5c87143cbe678811e708721adacdadccbdfc92fc18375758eb5f760a6fe0bd2ffde78ee7544188e128fe19f98239d68b5637c2a8f5e422b1a0f3eb4a222003a10ccb839b15357877ada187dccf7e91aceb754878b1defcdc3c579f0a043709e2cf3543c733db974970844ad3f0abb2322cc97238728e7d573f1e63090fb0be8224e559473dfcd6da8f1e6374539b0c3fde7ba06ab9e75b277b2ec82019f977e6ed3722877a7ca0c7b556f78a3f21120602934cb68e493fca214a5e7055785cd84307449be348bc2c2dd342c1e4a06732ebdd8fac662a17d69538d700919e894c0baa19d5214cbc0da20ea221d26840dd8080ebac471b553fb32b410b2f7fd25bf67d48657dada236c42bdb1f07d3d79f0b3b744842fcea3b6963b77e4b6dfc74fa1bf5107ade805bcf4e6e06039feacaa5f651716c1e199532e77d93d6e619727f7cb1559318f1265e67db75bc15e2f4e31994f6e1e018754bfb2464dee1e7f06d5cce573c8ea23b2f71368b8c0cb98fa8bdf54c713743a7d810ea74552cbc406ebad63bed6283757df4fb5a65783d5865b18c4ee05a36be42ba55737b1865c7cf9c15740e436848afda98afbf1c33728af99aafc4369cf6433de817431252a964432f5fbb597114e272868274374f0c58b8a45f68f80777ee12f20acc6c42cecb4f799b7c83825761072631fb42e72d80719573224a98836c0670a0e69d479d6b5c17c2921f1cd944e280f631862cdae2c91f0c1b729a3d8b2f12d7ae73212df8e423dec4522ae7673047909dc3cc4eb5efbd90c52e114c53aecce0562afe8324ef8c7604005b6a8684189b1aaa07473520555e1b9152cac21c87f714ed46f7649fbb57e2f1a6dc7ec209a7a332556e0415f7d2e151a8688eee18feb73ec29fd82ea520ea1a010aba8509a5d7bad22efddadb9a7e1379f78b307dd6da6d7735e9c2737c97dea5f6a9a4a42453b353b6e43676c4f10fb8ed69d9c656f76d154be82dfff7f31578650665392751b9cdd8a01c1c322b1099d3067cf4ff592afd11c3ab1ec9e2bfcd10de90c8a7600495134517bcdad3fa6a4d92be3615335de22abb8131ac71f30737a1e9c7afb6735228a0d996dcf94d0af6a23b0437d48f1ea052053d1ff28955b7d138e473cb10bd591c01f952b144dea151b56db8658032e0901be1326079a9b223e3bf005e552aa072dfa96c406c02a9f7a7ac732008c599221e5528e580ea553d9bcc3b93b0f4ebb10f1447739d74e313c4867cffb7152e464d1535f478fd3951709aa572ad11fb51cf28815ad8881301137f5499ffee3d1480f98242f335fa2e3a6a21fdd5fe0bffd39dd68b06c9805284bb454b744d8c01028b9f2495626328637ce043768290c0ada32e7cd1a46917fc5bd6c0a5202eed6e615fe41d47578d500dc222829547ad138ee1e2c1f225f30daea3514e1b243966211fce679d09d962aa145574229ed8d6f6d1a7c87c84389f7e2329a6912140c3beea1f35bf6903472b0a53945ab82e22ecb68035fa87502d0e54ba3c62455b2881b0ede1c07479c6d6d669881c8a553792c4914d208d59fbd9912e1919f71dd9756ba3c5110e49a11a478654aa15b056a7c996a7aec0226c66cb7f6702ae40548499366d235d622ac01c95cbc4d5d3653fd18a764fb467b94813635b0e9f24f80ef79cc6dee7ddc508e114d5b5c15adc23b12212cf4b46eaf86bcc08b1b09c8bd34dba9641c2454f7b7f622068301ca7be0aba003e2b293dcf39e069036e76289db95f694869896992633df810022be96d74653db35dd72b6e1a92e5db1f00690017d4d255c5633e5cf1bdb95668ae160c1f1a294ad73cfa4415be117b49d044e5289361db2224131a237429233bbe78434430b36543def9033d8871d5db4cb1708bd204c1d48a15e93cc7e45a2be08679c7b44d6c2408129206973c6c6a35df8cf4c250d9302529865b3a2bde32013d87ca54829afc99066d6d1fc3eec47cf7874327def5056c7d40ac681c4451667c9da4c061316951d747b56f86d9c0cd2699a446d75e578d0630c119eb098ced46d3a7b637c424e3a6a231c7bffa3ca2edd80f0c1a5151391339059b07d269fd59f126488607c2eecb475832f0867df90389b658825a214b0b2d9b32ada40ce504f0d115ab3b537ff30c32c76a7136bf76faf29d7ce73d2302d2666faf828d75b9e2b6aabd92699cc32b78e39dd29fe5fc9f82d0fe04711238fdc2f72fc958d903885f7f7ec8dd339ee34175d2fed1ea1e9da63871d6f57a799a15b3b7085b064480c88e8682b2d173ed7d6aa8a79979d795c9686d88a250d900569b0eb9fef67d66dd5211bc2edc36633b5364adb202be49b6f777ae13eba12ee89d197930da08bf5a1463a0331f81fb11a5c2df07bb4cb93fcf5c87c659e4c3a0c22d18611d79ce41ad3c97a1fb1f77a5e2f064df429fb0b9ac13d7a8777438634eab34fdeccc8fc1139e539bc8bb38580053fe0589a77c899097787d50f172011f84f03f8d0d766252bfe33b75ff714fa1e5d5e48ce6f00806d16e657fa4ee23d8af3c5f4df3f11f1e36f646ae270bbc0fce4ac3b4a17f93a88bbf6e592cac3cacc6bad010ef3ece94a7b42c29b77b145d82d933bb946c16003c382058467ce54852c52377905e63a33259fa0674b38d4ddb769b57462ef7b81babe05f5549b2d52f6a0a68eca3ebe41692248d078ea981cb39cfdc76df93ad0f8775aed2f9c16a6bf475ae4307c65733d25052a4334af2aa677309220ec673230b83c62832724706f9edd3c0487fcb6d816144340435daff72febbb66550024563534bc12588d5de7e45a07c5764747e788c53cda94f77ce9ef8ca73345690b8f3bbb260a079ff98b0d8ce9a1d61b768790e406f0605606a85bbe711e33fd452e21840bb0ea5e75ac46ac68fabeb3250439364853a4c7b34b3ef484299149f58452fe12f721ad1826e85b63323ed9a07aa94052e1b28bbc047d2bf994699bf1e99d4a158c515eb1eecbee69d6bc173491772e635958e6262507c29a660ed100cf50fe960f450462a49ca543add90b83b5e5126c51153cdf6a04293b9dbc77ff45f1c71a47aaa0cabb9c2d4785d3085fcc7577c25b6664eb9c15fe305d7663190c4dd781e29fb34d792f15c79160402a9ceb261b4c1f54a579ea4b35bc2459de92bfb5afa6541f3b1b6a0f6d78dd8a086034c991af7b1b67fabd834b1ac6af47e01b5b412d626a4ee034c5389e746452b453ace39d6365a3200b9b85998373034b0caaae0a49220a4346e0215ad8761d5c1a35caf93658b2e60109947b9093ca572134fda39451da7d6dbfc577e1311453627945b983b3ca6d7da3a254835dbdbeb9aa92cd93add594a152d3b7b0470ac657e9e8b2962ff297ca3a374f02a1d339e1d79745b1d4d4d3220e2f1305291c7ec24f5d487f62b655a0be0c46522b80586fe007ab1d484887704950373b4a527ea35eb0350822088e126056e95642daee514cadd19f4d221f8d1908da5d9e6bf4858159accb1cd7ad9beb93dbc3e60acc245e82fb868df58f32f999934c58efe42ff0ac127d89c76a8456b27165871afc2d19829c27256d28e37895e0e54212a3f12366ef55534b3791ce18f3c8094df3e09c0eaf624fe2f41cb9bcc8f38ed5fac80ed925f2fc37df3d35cd101eb5f63fc1343adbc9cc880007c7ecdc66de777e06ff4b2a4d99635ed5047b4c025fb8c601027be4ffc883be870a05a02050e977816ebb73e2072c3484b492ed0f8dc10499647c85478a40fc7c39aa6555155cf5f6bc3bdb54ee92440a8fef3f62968da286209d9f3e29775865b6319d8aae55008323d9de601f1bdfccd9aeae4ff168a22cc25cf080fa01a068c2bdaeaa0f1a0f0d0f2ab2014932ac93dfbfe77b7d72b0d102018af77031c5f05f1b2bc28d273c9ca4ce031542aa65eda4e4c337d83ba4327d735073a6cb457511a2b16ab87f6cdb83a829872b1e97c62f43ca32a159a5af7a4a9ec9359db2635b0bd1cbeddb0f9af1abdb501f6bc17c2d73bd44c35dd76ad2a453900f9ad4616154d24541382d776cdeeb420b1c81aa2bac6930535227952aa61ec78d04909d470ac66f761c08f0add6cda62844ed1e8b712977c21eb45a751d0fdb4d2adb9aa390a4c70e037bb3ac7fced7b91bbc0ce6ad6403b58651125ab6c5d98c185a83a6ececf433434a11289ba71516f357540280a23e975f9dca533fd3c258cec4198a26d397e72b3ec363e2784519c21c39b69c7f95b06fc4d8f8f6cd421d32aadaf5d9cd43f8d73e449c01939bce6712af2fa35d0b7e3c16077185b577e19dce97a273f207448d36bf0d72ca86d3974046fa5a28b961a35391ac07e9b36c0aa79ecfffd9f5b340b1f5e1b94e3dd318b5644552a36b20078e6ddab80e3420c33f09129169df856895e8e587b13e1c68c7bdaeab70fa5cdd1eb802bcc54f4fb6a247bf8ebcf8df0fd9bb2b16ae7be40350f90cf69778dc76e121ab080ee462a8f08dcd04417d3f99b6e3ec0d93ed620366dfcacf546c86a352696ac1aa71bc5fa49e320db03ccaf2379f75b1ec9d762e2b65b099171a1331a13785e1430cda51f3e78b0eab471333e31ccdecc8630cd476cfa47f4fa1d1eb43847d4151d6ad367061ebf7b1bc602f60aef77494eb51b4bbba9a156d8f1b33834d84a09a77a08c9d022273579f593c9e7f885a3763a58c8f6b2597a5843a1968d139ee78d5596ba54d900a66792012cb82ccd1c94a0ebc437722b2c5a9da331c87ef1c59a4764e8f0f227fa87a3bacd35efb93be6ab0720ec077495f96a35fbfa604bdcde62be869dbcf5edffb46f83772b15b11ba4a4d70f3edc012356f57778b0bb0cc29fa6b27b52799811ac6a2f3c3fa7ae16b4136beb744a3a3390682ab747a9a619964396ed31f57d32b79b9d4c2114ba91614b6310e602a969a22b5174b02fd99fa4326beecbc23b1712e2b9c24b7d3f331b06760f7fd61019ad7fa13ec15a49b7fcb52366e9a0265d45859c6fea3ea22d1f549c6a7a62a65dd42299d186d585a558f2f0f0414fc7975d30ed422d7c4a32a98523a32fb30296423e28fbf8fcad2de2a9cc5ea836382d8648a3e5db8903b5f5b3352e371b485045c1cad98e665011ff643952291bccb06de6ebc849d2970f24f81bbf13e954866f35088abbbdc0faca7750bf644929eb98bbf5048de45bef0bf0a3f31bbb7417fd804ffdf16c6577ef8c74934a36db18c09eb4c10b389d9f244dfadec299a180f0c46fcafbd1bc60e1a1f81459a7a5bbf448239cd27711bf55ae53d497a3ec1730f4d82df9afa12832e872ebc8ed0141fdd16aa9fa0b11b70494948d7cf4b1556204e3a0ed246c9785709825c4d829479efabf776f74c3d6b57359f2a10350bc28f76cdd0257ad1eb118eb4181aa8098ee6ec98483cea3ca7b93a63c2dea44b71f3482bfe2127dad6c3ab1ef1c32fd3ffc6d8386b5b7ef1c53ebcf76ad87c8e61b0bb19871ef3851efc7d01efc897ba9b7a5f7bf5a3484427fc874049d771e5fcdb62e1382448b63fa35bf408f22cf47cd9a6a84b6bbe90159738a0fc92af2e4546207c7db8dedd2cceb7960bea8b0d65a890595f4867f6b193b8df53a11ee995be57c1cc2e5ae501d3409040af8ef7868116b65af66738dcf14d9c07896a160bd6cb71c4918328d43adf03fdafdcf1165ea5d8d0edca81b5ff797867a1f7cbe6b2edc361b573994053101177bd078f018c437a539966eaa5bbceb5c1a443a63daaa96602d358906b89b37767de8f6872510392b50134b24d7084c12bb65f2868f1020bef5d2baf635330ef2eb9595f132e31e1a8d83be42e9295a9dcdbf10464e0d8875a640f074cfdfd35eac3ba2066049dd67a265fd15f5b69483697a09bcd036aae6483ca7fe1862f5259790152293b4bb63d7ecb9d42dab2f55d2dac240f4ff2469dde5e9014c4160498bec17fb45caf2bacf19ccf3d94c4ebd056e298bfe36a3ebd6dd8df6ab6c89009ac028f1940659d34cd7e20b11eeaa8e25d12172dbc6f9c04043a0e6ac842a694bb4d00d1a1c3e6b061e3bba2ca670e6fa8aaceea66727a93728d292f18b05070e0b25a918924d39a0e5822494859b3762e3ebd7fe803dfb8938bc80a6179d771608c099aab52de3549eca184e155dbe02a34090a3028b812b130aa9f9ee7013be07516be77c1e28e63e2664bcb77ce286a66ecd27ec33cb3f85d51b4f2fadd2a955eca839e7c6b3061caa8bc3d489a1162071764ac2eb8f243f1be49ba9e2e4720a496ce8e00868ee2b24829146285c0d79e5d30e9597e8e6a06a37ac3b317517e383b683f7bcc4f50262618e35cf93f93dfe9e2bcccccbca6d764d3d31ef34262ece3a046ac0a216099a1ede27431ee060d29560a9d4c510e7fe60ac5be37a790d8baf7d34031900ee4f066e96621ef74d12ec5f3a54608b612426be1d7144355cfd4cba84c83d5601b7d4f8b4fc757f6df47590b67a059eb721defedf9987583750795e0f7abf684a49b93321f045602f4917eb4534625bf5a541e84df60546d5c2cb6ac4da2652dea4ec41a017cc90e71d8afb98d58e43e6e057f6c9b4cc4da296e94694215c6f24c0acd43cd581161c1d370fe6d4c6c9daa63abe2cd6f5636f64ee125b30a1c84ef8ca14b381bbd88d0699b1f189d73fe8fec5ee92aa51d714ea593cf25788fd31818e89cf138b8dc7348c0597c7be0807a638c07cbb7cfd7afdf5f3814c282cb46b1f570d700596484452568a0081b4c6223d9eee021bd73011000fb69f45e4b115d7ddfa6ba6a892d73c8dc2e1e537b6f37e841b5f49f2c4e9b344d93fb8eed0e56fbaf666bcae4628e34e34fba8c0dc2ab4c7a258e2a29cff184cf753fdbf75bae1d101f6dbd9f969ab64efde60c10ea96ce742cd7d6b14e93276a06057ae46850b1d699c0c9bc93c0942829219274c13e7b1fc7e6fbbda25553783a42b2df8bc1f097f7f070a549cf82207d0280c35e81613e5b0a3c4bd1fabc173a172c6fcf4aec525e3690dc3f7e6a3a270aefb5c8f1a76b8d736c7c0436542150ae3999bc2f84013162bc1dad950199ba9ba194c0f70b7a7f879decdbce9f58c2b8ffb1a95f354df4ae99a3b084646c5f777561ecdffcb817e4f3d422904f1d6925806695479d8e731757ea7ef058b4f3ef101c3c50d69301f3c21d2cf620f51f34cf2bb4abf8ef0701e8f60f6b7648f66d58aa9de00605185b9ae6bb50c2b46033df3c176ac192f20eb4b1ff1edc4b805ee74f466f3d66c85d8a40b7ffb0feac26f1fef2af78437a3cff531c835a88200c58fbb4c1cb92d92fbe1b5030e83099ec4902fa3b8f51789944f6fb3a3cf5f84b1bdcbbaf00e6e5512ed0cbc0e41f8c0958647cae57c8d57947f42b4ddaa8c1f06e2e2d3459412d8ee0450918afac57f4fd0ec88d08e8ab40375992464eee39b58d235d8512704f4cc710744dab87db461b23cd402fadc2d60ef87a0a565374765a84974238fb2a06883328a0c918cbacf8f6fbcc66953e3c5154bf6135e00d62acaae3e703bd85954569a788a74ec78adebf0dff7cb30d43937f7ef4edfbe4aca42dc7e99443ebe0df13a33219b3c393ac0c8b9813470be5007a1c94a91563ca0722dcac657629b9ae0241cb2fa28dc411367d7c7bb554c327480e54b6e70024336dd1a3dde934fd7434d58ad35f619ba08eaa420c317261c122dd735a7ca35d04c573752e5309feddc263f1f9dff5f6863455509739930040f03adfe3dd2daab14fc15b41d7bf8d45438e2460c45103842529b4ed47fe05fe5baf1c79e14fbb81c30713e28f7ecfa0cd098899da3fbd7a99be004aa7baabb44f27b6cbf98fdef912b67b0b805baf4ec4d9bfbaeae25450290784f8ff94192fd2686f292cd205f86a7ed478031ce108a3d5582b5175b86d73df57ced7e680d15254876311fdd2d06eace0884705d462076088aee417141a456c33d50f27dbdbcdb95c226be7e14e32b11697b85d05c51701c92f12d2631201aae2d234717403f68aa3983fdfa0f30005b9c4e6a8c41eedeacda20048478e19a7e110888036c4c0f79472a4b40e3639f3e386c6eac9e520351c889368228e61d65df07561edb7a4531adbb33aa0d7289fd2190808ea742d0e3a6af9608affe843dbd223518d45dfa39980ef2b3a4c6671b7c08fa17e04417b015da2ceb569888c36aa71da49dee63d2816c133038af943a0d172a04ce2b21ccdcec1a97a57230b281bae5e0cc1b2871b787cc7fa39640401aaf37ebad70b070369df01b5aabe47053e76ea246ed25c55100b59ba000c0f1b5d4ab2bb14796bd80018a74e8b2bcee6773911d248b09a5a91ad72b9ae9873793ff649b11e64b33e90851033ec42962ae249fe76442a877fe46013fefcde60d5a8b217850395aebcb02e8dcdf8db12b7fb0ef319443386e23f4a7a63c359d835099c44aee12bc1af3a6bccdd5b4770a9f0a6f454a9737d284ffe68b2961b2b2a1764ba14acb02cad9af2c750bb56c8ead8354228b63d92e098cd80a242670bd0416f366c8ee068ff78acae9adae02bcfb6e0d330b3f4542535c58a736894e0ac674f9e2870bda7a00b5f4aaf351423518e4a487bb643605a5d3d95f636155947295e6d9f525ec1aaff34cf915f2f00873a022ec10ff6297213a76d7c377e8c7ee49ef91b54cbf1afebf1404ad38f002122df6c356716818973c4b21ad2940f7c559dcaae70b42c9737d6429b1d37ac49e9427716e1d965eebdda8475343816303549b5030cfa6682af241056c1baec07e631c9a11788e586fa7913790cc4ae78fdb801ae1a97202b414149d3e61e7c7823c1dafd3b5991ffc5689964a53bd1caeef25c5b89de5ba94c25d6abc10ab2c836834d839c8b758e98b8cee928295a55d3d0aa38ef2814ae6069c632d5cf6ccf723ea898f8868ab3588449bde97b00dc152d17af1e12d10c6cb0e9fa4daeaa1e9c65c6cecd317ffdb588a40f850e49a4786a98cf5192455e95fb3ea9bcb344539873473f7ed52cab82fcc238dafdb9d78124bc8a42e117e9725d0507e33061962b63ed392effa7453bdf1aca75b06bdecfec0f135494d956efabd771d2ce8ed8a76a16fcfd061ef9fd60ff14208d23d49707e787f26112993cbfcd5f566b1a684da447d77ca7fb12624a0b30804c74ad0217531d7528f2837dc833b90a03aed128c34cb379d5866ea123c2b93aeaf96793785b7ef34ff4609998985d6add0b2bb337db74bbb918eb080180da147ca2c66def0ddb7a3187de695420bdffe2f72c94a7bc7016fe0022486f03e059e1c56b0997daf5de152d6903706dfcfcdd6f0ad9fc41703ee72ea538e9a813f1cc2f856cde0b2ff3adae11747a819b63b92f509515d87dccd8bc98a331790047ba7a264415095774667bf43b29e7817feddd90d4bf4f310cecbbae4f8d79e51e25cfdefa798d0951857cc0f218b0e9e2493737279702b35a8cf0b04bcea4959c08d7817873a54fcb3042a52b618b456e85230daffd8786f6a3a484d1bbd1c3f00fa54aad576ce4098a1fc2864662ea888d6fd2eedbea0320d68c31f68e432f638d093abb44429c5bd7ffb2062dd6c5234d9dc1944af001e4c1ccf39c92ba959fb4c652f7aedb690f2050f286c7f5e6ee9cda379ad376f88d36f794729c0a8548a3073a7b8f5bd191b1694eb1a444391669c14d6da88d424126631e83bdc477854b482dbe110f8b2b7a0a6df2469aa7966a4888a9782f35e7fcc883cb76e808489ab93b3cac37274ec219d178c07617a39c1a40af71e29d384efcdb74bfa956973d17665beef671b82f7ca84cf06c7fcb3cf107c60ca0c2b81d134c753788e4645f8581e0988cd0bb3c5ed8ddc1a9ae09c97340c82a8a21e617f9832e2a0009ab48e2ffa189f70fa4aa98e4ab51674b49ae731df4babecc9192d087defc624d5a1c12d239ed2bfb0b8b8a99df2f69883344c3dbfdbffc5bc9de1485d58bfeddf61f8aa85a4037f1b501435bcde551a6b2ab3e8be0b10ccf472e2550a8cd38494f6574709bdcc980ebe74077366323b6715e88a94cc87cb8593a3dc5d90af978dcf86500dd673de1866fde074d1c347c1463bfd0970794be1c3c96f8f6f8c8ab0fc5bb1bce26d6be1a2ac64a0ced42b418ba82118674a5dd589d8b8655002e85dfcd638399f32aadc1a61e6dc48803465a3667f48ae83f32de30524f53f8711c45b3d47515f66236a238b9dee6a6c71058cdb1b4a53ae7b210ea4d0bfdc209d0936ef3cef13572b104fb46226e5ce239de8afa57011f7b9973c31f00c45ac24bc83802ca5edd830d4a963c18dbf7cf77e56e584b4306d0286d875027bc2857c5645519a5096f8ec94bd6c4b8c1025d3475e792a65629253a5d8c46efa8c4601763fcc375e8771c2418bfd28e8b79ae7f08e4f0d6f2864e143694791a6164d19a8218c5983841ec9235cf61f35b044dab86d5fc50e86932c4753274806d77e704fbc27b821a0501e4a2045fd4164e38c9aaf5c6488021a5fa02cb38e6716b00f2d476d1a15d2ac96a62f1af5e5ebde8e41d22f2621d1ead70f6f1bef0988baa2fe9ef8caa5ace5b861844b3a7e49e8714f5661cd77ba0128be2b195e1c7d85c044c1e02b84b226afe756ab980a92f0c84e5c1cc1ebcf27578d539fe7ced3b84f6aaf2d843111b57b7b39c43583dde52e9b87c5652cf3366011d6f0dfe847353b16b71f38930f416908740d593bd7a67b3d24fc59d4dfc57e0ba47f0217a78270bc7b603984e7f79bcecdb8201d031304556611295e5d7a673a2e162ef8add7b57c7b2a0f49490b95492fc30b20faef168dcdad637ed377712038e9df9d46bad1e3b08ab982de067cc0756f6a278965b9b49bfabc55a2afd08d774a2f848cf818d3fee17aa15a8046e0ba47c8d33b9a0ad75fea18e41783da3de925c68ac2c5edf3066071040547b247f7028dc53a5a5c1fb34f9251f320edc47e625b4babd964cc9b5a486b7419605f0fa6fcb3e9749f3fe42dc0302d69c52fa0d339e66c43a57d42f17ceee267ddbafdee8776d8c7fe3fa99dd57169372d5352944ceddf63928277ad06d343a171f381b09deb6b6884801c9e43885ee1b82a2e1c67a7f37837231d6562fc900949122df16a61889e9089b4517ea76557789cc7fbd453f7c0a1364e0a22c547e49ae1db09bd07b30d3e4d11ca9a5c731bd7722bae41c65c15e33afaa66af2711a7c3fe163ad36ca9f4841124111a187a0d8da99fa2e60a3654d8039d73d2612dd0ca7f21a4b1b3f286c4f5bfadef414f903e934046aadb5325b60300d51338fcea274ac94d23900cb64a25065ea21122d79bed05ad9cf7fd8023e591f73d48b7b02a341ec09a10072981dfa7bea605eff60e73533afcdc1472244da9442de816c43271985dabdfbec5477c1b78aa40f350fb25158624358f82b56e5687f21f83b1729221631cbd0e5e3ecb22648399bc3c1eb36cbc2b19179369775db6e05a9042fb1bd28925a7c90248423afa9ed3a371c1f31026cdb9105e14159da205f0683fa1655b940a5651521e870d1917668cec7df6c574cb0148918e3c4c080807b978adf126e138f593b4708f4b93602c831010a87e460fd658b7dd62ca2e477c8f45eaecf39d4d5c83bbb7f0d6fc6f1f05ce7cd2933d901c0515297ce90b70abea5bca4bbe3d354c7712464fad50603737412b4d9ffb3f0a837f895afd73ed1539b34f795d2ab4925585e0d822237d0c43fd2ca89f7008637aaba6d1c2219a693511c534c135e54a6ed977da3e8c89287bb80d1bbfb3f34a06f4b557761d8722fd1e6b7e802104821bac0cbebe22f01bf3ca0ca90c946056540e2ece438f17f98a3cc70b010313e8a37e8c1fd4dda1df3cf53d3a967b1182c37ff1c92cfc25264b48bb2063df62894e635e8850799e44a94cd7a873578d8f26a1b42dac7527d04fc1d738254af9bac32da5b19e7e57bc9bfe29b6638b0b622ba7da54dd0e27c46bf1babf3a76ec872940cbf8e447a2e7d609bfab22fe4b540a915c4d359fb4b296094b288d847cf44429effc5336234170753c60ad679fdb8fd86a98720162abef13b4c499f022c572693a621817647d32180e28c8286415afd44af02a9bfe42b16db5f70f84eb66268970791d9576b7a4b3fed2a47105b270bd15f182d2cae70961be6eaeef00ecf229849d879b2a9d284b7e3e9dfc491ce1fb63e501186411c9d0d3fcd9fa9e3e86c4fe164cb7e185c589459554954a2a381f75a071b3bd06d255a92a63b213fafcc2dff98ae6aca261dd8881172125d8b84c2a77613615d3142d1222bd7cae785798f7cd8a332e14c3f7a4ddee670d7b1fe721a66a23d1e376c2efd640cb062f713f919ce48563445aad268e967838afcbae96d4d58c14161c6077a00e1822e7426607ef3b7925de27e35634ae3df45431979137b99e66d48724328ca3e861ef518224957f365a6f4fd6b04c39a0f26c41041592c7da5f5617ada6fdf71d826eaab94ed41054e429c9a83ed4a6f2c2fe742f490e6472c4d7418041b24e759ee69c4e4706a669de18241bac8acb0a110466620b8c0165d0ba38a86d4dd7b7bea486a78df31283ae67850f4b8f4c020b3862b15f3062ab00215a7c7230830c248bb9ffd6449c4e4128b9346d29839c6e3ee6c67bd7f0dceaa6376485800a06dba8845013d611cc00261aaefe2dc5803595d9d7fbfb553c32a8c5f91e01aa0a4c0f2b6367b5707c7765ad9f0e1ed6ac0f9335585f3dbc11a5a2869772835813be9126ea97a08119013bd80505402f096dcfb7995733d494a43861f086adde0a1182b81563be7c10811434882918077e1a34661220213d9aedeedd8fd6bb815d79970b2394b35efad21c6b847730bb4bbd6495c03e714eca7ad8f83287418f494ea327876fdfda9d74808f2df392f1a729b0d8476edf779f48f46957e389c319c9edb922b1221344fd7102d8384a678bd4bd8ce3b0810fc48c538c12845d58b188e1b020d2eebce95c3229f81f9f995d77e055598f669a2c3cee10e7aa18ebad624110c190509d5b4d4b6ab19f73d7bd4e3526aa0d418ac38041ccc93bd5655a74240d7e4528dcb4f537fb23554d44cdf43b09b03d28d609f106d012ecf08223a67f090d601dac8920c13a5f07dbd89f5901f7517862a8b3c85138082a5636995b2d8f0eea25b55f7db42add1f917bc317250c757818d40b2c51b70ece0e04d15349149141ec70b3389aa5fa6884c97ff3d1594024ce9521472090eda9af4f7668671fe7381f0f84e6670516d9553a1548c8888c5baaf611e03bd4b6c0d188165251a2da48842e8ce86dda697d3302cae350f2f317e9f05367477a6211e8b610d37e6d2f4cb6013d559745216c91732014126c5c5afc42927c9239acb7b3c951a2c59bad1e4993c40c1a5d31d837d35f4285281959c64c6b0108d435c6ca88bf3a775bd4eef83c22a8ec8f94790e9a7fc256b4b8111c30828f822b29088c313cfb7291f337cc04d533529db188ffd9543a7da5aa4e86dfb49b23eeeeda462e8c964bbd410d00aa88621603224bcd22505acd668e58c76d5684904c736a3d09f49db59ce0bdb8d2a40c80a0ffe497126d5b9604a2f87cc88c96ef0ab0dbcf83f8397260e0dcfb413e0068ad040fea948653043a67da92eb68dd03776e44e4e33e5201751181506fee819ed0b5074cb2026688e85fd8655d5e487eb1c481771e94c8409a17da15643309e5c4ee0a7db20d41ffd71e2b89b2fa995a1ba97b40e1525b66199cb89af2ccb564544905d5e58ec5e9d77f200ff7b7ac4be6dfd0dc6732a456d0142c60eeb29abc92b857acbf938462731b0d2dd72bcfbbcabe6d013607940a2c429e7095349a8860a489c8fcc31e746c005ce8c11c6275f9b28874f2916ad1aa3785cf366c147d1cceb9ae8391823692abdaa1b79b783bc4de7a0c0e9f07be4fd9a4caa25574ae38184e4b20f1335586a6efdf549879a926cfab0745f295273a40c7778ccae14b19c4e1772b70841d969f67b39e1692a805dea2c968c93f2d0b89f5fe973c00d38626f1f7267caafab33e3af5ed508ebcf2b25464e22e4dc75e99c32955b755e5677a3ca6b23dcd912dbcb46165d15963e429bdbca544657af4ef4761368d058480fbd3404c805545f256ed489f61a39dba20c5598f3dc4b7f14eaf65fdbc92812beb27284599628e5db94850cc8a0185b3f0ea6ad015abd2882a772eb201af7c52d512fd167ba8f3f8af15df5bc6531704ded3a9b06f4fbea1c22bda47a52fcbf0393c6ca61a490585d2185b79cf0d77aa69a67d4c139e43e615a6f6884845804ad889be9f12d2cd410b8b7bc71ec7b4d30cfe44ccc0ed9904dd731028119d183504d8f6081b6b62a909e802a8495164adff30f8f46a62ba33247013963ceda179c8facb351eeff67966543a5e9e8c69eea800ec1408743a79e5774454d827076c15969e5f8067b63cad1d2867b4aee578f7be914e418d641db2f84547ac1b0317bd7e6af3c68d633d528bae2ebe2038d08a6edb910cf9050a0979a3cb8b3b57e8a4e94ae6aec81141f90fdaecdc9b918f84845ccbda334077240868539bea9a2066f85f46a4542163373019c198f514b4999f0b92c088b96e4599e7d4e9f418f67dbaebbad18379cd852b8f9bf09c5a78b675d5f053171c423f034f1106afe810fbdd3ed4f56d5a8ac3152fc03c2d8e927ed9084e0a998b971f15404209bd99b63a11bbc044789400604d447d6ae0342ebfa3e956f74a54d8610a88c366fd4333fb58a0400f4cf51bb36ffd514e1c6878cc1151921ff6fca923044ac125b611055ad235c248bb0310c4d3b75c6fe5d4aa60e3314810cdacb16e738117bec63c7e4f5579b8cf82b6a8b28ad352f249276c5bdde550e5c5c8701156f014a4534cf987fb25be4e6f633fd2aa7797d47227e915fdec49ed60991c5c5af6cdec99fe80528abdcb2a1deb678c9863ff0df7f75b95c04115e2ec38bfcbfae589842d07795effae11f156b49b96107308504d531f660c0ef7c2b02feaf7f76cf5f5a4dd324158fbdfbcb8307d027b0901917640c0c45fe3386d620cb333b27df789ae98ba8ba9ebdae4908e97fe4b295dcbe7e06ff3f2b6f5cfa53292dcc9f563f17f616c8bee04fbf0508d07be775668b60e5aa521e8b673cd7c67a81c24c86a76ce86e196bcf1c98c330d11b82d64180d756dfbfda7117885a0675743d50da9800b9c827ebd0f11dc792811fa78b25d1e1da710d0f11633134d135dfe58a7b4421f805a4eb3c3bf0f28d3f080065a0d344acdda9239af41b2a29dfd75027ff2dcede8ba8c73b0c5aa47e2bd2b95724f243f3ec5ee7c95e01f1c008f50469b4f987066720e8faf6ec8b505f60795f2bb9bf6abdf4c8835e0d682b4975b0163520814266c8f70dbfe2d57435348bbdb3043d9ff70cfd573df03c5d9f846dc62d31866de11e30b13adbd1f516eec34662fea62db42ded539ab9c7e187b3f9c5dc82be4b206f56dd618a42886efd94811e6cddccda370173b1fcfe66ffe53c34e0ad8b0179bb0cd2cf552e0e54b6f69de29e15bb0ca3bf6563b30a471e179b1989c6ed2ca8195f6cac438fdd1bedc4975a3c71822c3007ad2835d9c68349df1dbfe588274352253ebf67b861569fd925ccdf5134fc24592fbe4d5e1d4cc04b11d2fdd3d9562a5f9d50fbb27391030491887de55b9c32e72267afa12952d87d15e661ef18a7cd24587cb598ec23fb226bf613b9be888a99b2035525399fb496f35fb996d67abec1af06bf68bb25f97bbbfc77067f624928862702072cdb6e79a207258a6277ba69b38fae61551e296d33d54fba0f4111d381710a3d412e1f84b9e40c714acc635201c20a93e555453d0434e1c5d87cd0d20ed9ceb24b72cde7fafd089fa3b59c44923112d16a823568343dca53bd41cc3860a356e80ca19598959d770f9d1a478c3a398dee66b8d8e7d817f453e9199b99b01484b3bc74c4d745cf8d5ebc299847057cce4a547f50047e48f41b34540cf94321b865417d8333f0b2e9d19bef9edd19300f1e9a8a2d5ab4ebde426d5797ee7c068fca68452969a69fa3631fad96de3b2472f43b30d12748765a16ecf515119755d07336d4528db987daa7a99f9598c990bb7e3c74357c1ebedef4bb2dfb908986abfe1cce424b3688da86869966f3bfe0e8605e66ef3396db470e87cb2731942f9987c93e53babe96205d9bbbefb06c1f19f8a8eb2042439e414ea36840684c309766c6bc063d4a682ea7bb47b9e9f4a1a8c1cc53790d0c9e690ab5518709ad32d1b31cbc9c5d313972d674d8fa3add3869e9d3a2e63b43980840a7b755d09b4c0ebfdc83e2b066f08207b7f4f5314f3e107957786d92d30430c6898ef881c9441c2afa3bd5ba0990f118ccd4ba89b05484ff823298525086302842bf2cc2b9217818396cbc3bc4723998e53a65e068640ea7c63370ed3969c9b68448e253454a672b45f829ad7adfb80d21a188dc6c8462499301e23f79f351cbe3c0bdfdfc2307f6e2dd45123f31ecc665ce7de18ec77bdee3f8f967df8ac8bb82035502691890897a785971f63de0bbc2a9d904b686c4d93e47ca33ac5a621d4618093d644616b9fbd6f4f0809f6f9363dfa749a26bc52d4c27fd11689bd3aa8503a50ff953e9441f793e44b594425c71926b494cdc847d7fa1d91595b817468337fdb7adbe0f6d86fed50cd9c5119ab626c4a06feb62b04acc7db88b2e337972573d02c980f29c60258351b8ed03116fbd8e9cf5ca016fcd51295f6a39b5a2cb120ba9b1ab5aa4c095720c79df30fe5aa113824a1ae3f204c4ce66fefa570281cf712471fcafdb7a6caef73c34c7fd7c791b14f3353eebb0ef53ab7da857516bf9002f53b58b7f7d44b0189250b93584f66a6bceba53d72231722cb2f2d4e2ed39e884a7927ba000f483256cf80ac6ee47720f6ee287765291ec199eb8d0f5121f1bf8c348b9b5e2f9ceedf7519e40128643388339e310f345a10c576288d37dfbef9539463058c08c02d16cacd789ef40d3b2cc3d5afd9cf1f925246caf37ce3a41562d22809fa21fdacdf15cc6cf5b8b53cf245e130cdb443d03964b2e8aa6988a6e4328d867ce8dc75237127e875da5b999d15c557b93883c62d56b6b6e45716c5591339480283adebbf0cd1ff61bc19d4c79123de0112700f065a5b7d1dc3ba3590ff3a3daf9db9e2598b9011472fca0553572fd345a4fd14712e48b62b43519e362760426a24d8267d4a4455f48eec51ff10d29a6a4ebd83ee70603f9ef4dda4aa0cc68d6b9a8b730de63477641bd11519f4f883b7096555419afc7371ab3c33a87ec547ebb0dc9c826b993d9518b05d15b8c5231842e42e1204f7b911ffd0e5f140e75e1bf0dda8342818d1061692c1596d73d8869b46298711cd850fc073fff79647dd441cc83a1a71b28e39932bf3a2f77f24d843434ee294ee418516169a58d618357b598e8eac214c6fbcbefc7fbdcf331db4072f1aae688b09bf4f8deaa9b5aed84efca62e211a4b4500c36af2bb3ba35e1094698317b062f87e9393ed7348635ac6df54212032a9bd7b6276164ce63a84e733337b0979e2f76f7d97660446597830faa171dfae138e7064bdb0dd497a56e3e689b98c7b9422a9cd7a37f34d964943457c6a6b362727160006ca20b51f0af459de91c6524be1876523d3929f5e18f329fc825cdbff2f9ffd8b284675b52eee9a07cea6e863d97a87341db92e534a47bebb637ccebaf89d50ce81cf878be06629dce6d915f91eaf5cd2ebda5220e36e8cfeb350e5922afe02a9ed84e2cf1bae06cf93890fbe8e73ecb2a51cd5801c33b090fd3b7f366f71fd7bf90295636078f98e487ae3ba3c03b739c674f6d256314890db84fba2dfda5f174f9ce905e98bfb484ed967af811ec3028188036a1f6267fcd6eefbaef0b1a2ecb818f43b8b30e4364dc54805b6fe08aad3a5b23c412aae7489bcc6572058443d17cb781a0f9d888c7547d4e3bf7cc725b638fe1b8dd171bfed07297e87a391e483742bfdc081e4a5f4b1e1b054692d16069ae1cfc2311b7e2d53215c86f29a0dbc4893aa79d3e28028531b7ac002998253b5bc67cccc9a658fb95dfd0afe893bab1ac96736cab4c34aea70c7559474510f62a3e8d98a24a1e30428368f469ea43ea7361b4cd1b79ad97c251fa1dcce0e1866920e6a46b0be10b2e7935b6ca172cff6d26d418e31f815a0b03ee21575d46722d2ff39a4f0de8d0dd884c70b981e855ddbd7194af32bb77975cb40558fdf43354a091f6f802583d7beb0cd237260e8a78fba19f64dff6761e425acb83e530109245cf49982e5676af50b5e017d086d1bec49845639b5bc32257bc36b4d2123c2d4152c544117551d77ba17cbf136a08f77ffe811ec71d811a005888179e50c40db321dc5fe29d63d7d77626c772ac697db80410450ec86d7b66ea282fcac93a3f074fbb1d599218f5b0838adac91112ee30c48a3bf705ed4e77c227b5ecb29050bd218f886a8ebb804291ddbdbeb0fa74fa43aae1acf19fd677b1860b4edfb6202feea805b14e7e076563b7b343cba832a6740bd5ad760dd1f6bf7b53432dc0dd2785a946cf41325475813dc5ad22413c5c94b5ca639fc71161bfec39bc9d470959da95cc919591dd2bf84665e6e34d2b8643afa85997c70470b05795993920c8af5b6e59a6287c9fd061c9720981f1633a08f9fc689d5d82b69e2e92e88a9dce62234abc14a70c3aaff94abd2ee4b44ba7620ee40f942adc11545a2145f3017c033586d3974035cef0b81e037d1aae36102108528650338d9eda72075e53cac38cb2df024b7b23dc7797c0d04bf87c15af9602dc13b48579e5cdaaf327c17c4464d7afd6f63fa8b9979e28bfc09f6480dd5752e9ed22bfb90a6a5b389661d0f0c7535037d82aa2d5f117f3d78001404403fed91abd443024b7693c9ca968c379e05bde327e8c4eac80a63d7683381ab3e059dfee69e88f4486310c9527365726aa5a2df9cafeefffd3c9832f956605167c443b5b1694182b7cbaddb0b1d6ab96efaf0a44097da4587076630be44af18f93b907ba78b68a8036fc87cad2548db9f0a3ed824c03c2716f0015a1943aa462ada413640399adbb54c88187c38c478601aaf0e37c22f11bef4eab4c5ddf2ecf4f6a06e397f0c1925e06766143f755ad8a974127609b75f27ca76f18d9ae8d3496ffb93d70315d55fa84e3bc5ca0b471eb7635ef5d4231df0b97d1d59b8973240b5fe93729b10ff01087ac24f6f4ab07203b20a23f0cce326cc874602215a79ca2dfca34f150c9c0c86e34f874d3791a86b8633d4b20d76db6a24d358b3b91f867d6b11ac260c45c48c4394efb8ee814987d2195edd86ec72e6257acc6bd9379f9eb1c0abce528b71da4239e01c71d489c9de4449df83d3d46bf509d2ccd8bbf6858aa394f899bc90ec697ee4749be8c53328227a0285728ccd933a8966d024254d6e9615c3785954464a3b00b3ce98a96a3f7d9e42b0953928a11cc7c1bd6c6d102385780a1b90052f3dad67429d76281c349e0493e6ef70e136911f9d9ac910ea5df5310783d0fee4d6a890c8aa36552f620948fc4d89495094204c0e5b2b2187d521cd0b0a344a3eb61948656c1cb3fd76c0a93d012342249feba2ef65950459586faee8408fe00420ae39793822e532129e0844b7c84e8531d1b2ec2282c1c1bd2fef6cc458f88bf81d12b33695dbf0ebe2000683d58b933358032a4012f026beca2db3a5ce6693713d70f66aac9228fa6da7ec96372ede65c21df38ded935b5bdc7bc8ba3cd829c43c1c357479dfa93c93e3d168280b757f7b769378c625929aab02710276d96b9ddda4e6fc4d6984a7ce67a0a0989bded5a46abe0d5672f3d3012f867c49ec871212059f09dc999dd37114efbd5e49f685e1ac8e634f0a8e00430a87be0878e5335286241900f01b886b922421bbf4309ed45905a9ff6d3df44e0ea6af61f71cebe457d9cb626c9116b6115fc178f762c72873aa6b6a67019d86731b5d6ff6cbc8ff689e6e1e9d743e13bbb57c9083c01abab88b52c839fbf2e12ea5b7527c124dce89d01a2f55e73de65723a0bcbb336920a0cb102bfc1ed02b6cf210c1b070d87716a7365aa143a9c3ba0189260db31e0793eae84cb3ea92a090120cb3249945c93e90118ba6bb423c7abeca1fa03c10c283d8e9133bd42316493c58a2478610a997d27983c39c672583497f4288c4de7759cd794edc16b60a370a178bdfe264762561ec21baecad1f916de5866fa0895d21a66a45e85e8489a2a994a894772a8f8ab449addf1814c656651872b6695cf0d8098a4e0b0fb522344f316007f4dd0fb393423237d1e0bcc353b1a29dda7fbb5f03e28b4d24f657ea1f69497b93bd8ef93e36b3de4c75944cc88fe9b365c13147472b69c7b3687895d79f2cd616a08aa28a43e5e0622923e0f4723d65afe5029dad6c361c03566f857636d5d165b713ac9470d19af1e95f97dc22fde51455b59a5b1009d1cf3d0827ad3b66a9a720a763d88c8236655ea30b603c4f752968da91a9e5d95d9fde0216d9d8a6ef6aa23e9fc7b48dbfd5c057d6818c41497fee0549a90d9575e5ed4eaf70784ff353de3cc1779f5f99de97e19a4989a3d7b62c3b14de8e813eec8e859fab961852a3a9f13a737410061edd74169b5f50899e70fecb6b67551a8c5839931d4b852ee5ff9f1b1e140e9dd9a3fee564155c53e6be25a0b1d932491d54c00f61efdf2e0b7e188c71f637b15d95fcac36c43d776d491724c7e63da4f1530f20ba23e4f37a36534080a475f3b6f86b5e2cd9032a386315fa2016c095ae07e872a3d772cc09f822e6e9e306b2abb4d13d2b16e3b9bd4d6f705e0fa0ab8f27545f9fd01795c4417a31f91334817540510208b0fc87de441247ea8a069ce49ef813df8b9be4fc89ff73103ecca0c94fd314a37787e76d36fcb74b88c89890a45054cf464c89700017ae9abc4e22464182c52330367306bde126e7ccc368b10fb74ccbee750e150b8659ffbe112d0bed864fb316fd4546898a14a33341aa237c5d8333b1f62550c78735a1ae26bdb79b73f932b5e0f679e6183516b2d24bac17b2e42e138ff4b980323e514f7ca04ddabb20a3cbd7d266168255c98622a56c74a9ca0c064834e8d6194f39a94db4553fcbe8a0d34f61a698517c6971a343e67a46cdf75b52f55ade7bf7c2b93fa29454b126b2cedd234b140bf03896364d613de4ec6998d66a502a219dfeb25365914dc2d766862cea1c35088b5390d7e13a02ed7b16c1be38aa59802357b2932b8436af0cbec8e0be8aa1fa8d5731baa35094e3138406b4cca30d8cb72b59c0d255b25763d73ec6fac0c8922ae90988ed1fa47598ad4537792b98cc0c2b8e2dae063556c1210fbdbafc1eaa1cd979707b8142c61c4e32806e0ebf9000a0b71b1659e19859e6087c8b70c58c0cc3e1a9ca14d7fb6d6557f6f451527b49d8f5397efdb21130f18553287d353efd7fb453e06fbfd1b288105444fac7445c6a98120506445244a66e2723c7a2267cb2f99343edb4b88a968eb2a7a968149fb84096a8b00e90ce7357d6dba738194921b7d8f85b68f69e615b827f89f243daccfaa6c8de0166be84540ccf96a25a92f34f47d0e0c36c25d8fe16d2a76c08493d6146946a025e67205eb7cefb15092dce177772ba8d5eec13be0c00bdb073e679beeae1f2fc3ca9d374756a22da058ef2e0ace9fe538b4c4b84a67ec5515c468a9983784452d147154198ec893b7c2f07e4b1a9d3fc502f461f78d9290cd1c261c31ea96ed41cdef1cf3c1ce4383e11b01d770fb239b814e1a45d43f7be8272b3103b70dec00dc2799d7b5b1fb6e938a295e0a2404e8339c2a3a9c635eca3d4928daf9f453576553a961a3cc5b9e3f79dae414cf08f3b56165280026823a82c0cdbc0a6398bbbd9e7c1aa9205d790bb9de9d0d9da7fc78ec5f51f8bcf73172e3b90779fd7649fad81b62dea2a58b9a6ebad43b4ed58fbcb1e0223ac64af115c9ff743b6f49e752d24b431fe3edd12895f15265e7a2263274210437a1ea0734d46baaa9e75450212c1f10cb8b5ae478e94d6c279f77f4f74775caa4f9136ca42843ce7a56821fc6fadf547b7dd65a5149ce7a5f1dfa1ede34717ea7afead49c27da79c969f19a9a61abb7b4d75c408b76db80b8b1c5949f2d48869fc093b2c9bd8d2be4605425f11f2db6a15cd95803ebce07cb9b5d18acb59b5f2d3dfcc6701393b684f29c935216f4b64313be714a5bf456cbe930c546351555ce405a4f51ae477d3f9d3e1a0600f156d82c7fc51989e1146402f24323910a19b29fab44bb4aef2e316f4e8c1959e409ec48ac8e6a08bbe102d9edf15d9063820783c2d21aed9248b5a59447e05282c7dee5d5ca8c225bc3a95d51f87183242dfac2de2f370c0278fc07dc5e7475ea83228932e29e1adbb60b1c51f6513f276e38ae17a280d083cf2ba7a7430d020600a7a5c2b5109d9ccf252ce97573d32b4139ef5dfdd19b0cb68ed8730701eb33d48a73bc2cbea8880307e082eee28681a74b8639a20b764b9c939c606fa487f359a6ca781aef8fdde03f0009c4e9e8d15bce7da48d33695abc74e51067d03daa40c571dcac08eff34f5d4214dcd8ea1c404970fa5fed1348418a41a5c46d7c1c8984ae4e502b6843f5dd72a8971cb4f6a85e65ea4a091b30a706a06ec68e22d5e988262c15f40b9f691e3b300d7b0f9cd4e41dbf71c303210a42a9e97d6e31d6628203f23d29f43da7442e5308d2ff53453dc5852467445b14ef3cbbbbfbf93d04be9c07f483941cda72e1210cabec336f6c9e594dc76b92142545160ab4dd7d3987640f5da17db2507252878c0110e14ff98a335fea904d17c163646352ed04b6e72fd5c6c6d95f7c0d4a219e2f48c7454568afbe9d61573458a3028ce65497ade794a70cca3745b7d2e8050308226f66a01fdba33fb5461bcdaad9e974a7fc7c9da0cbc5bad039b73e9bf3b470c3dde9acf52eda87392b7ff6ab9c4458aa86f91e235c3a25a5ad0283aa107468f3174bfd5626c645c3c0b22c8effca5e187691fec6c1640b4b2a6205806bf06440733d0f32382f8a710aed46c0822a7d8c9166c6fb17b89e6f7d040da99b4eacb2ba605540f09bcd51cce8fb9a2b4b31762be24a239af954f99bd786349d037d31f55bb6070146d57ef91b34683c05e7e2d7f0cad67864a609f9e70e6d40aa94961e85a829fd3c54db530e431208a7b99bf28d3e2150c433e498ac24bc9392ac34dc06df520e3d17ee6788861608f3c593f214962bbe929a39f0032cc2b913ce0173432d381d66d74bbc120876e460583da565085fae71c6c2f9664dd42559547a1529f207d469d665e3756be534eda13b7fe8a8b566bb0edfeb904affc3e2ac497d45f54bcfc9bf091e1b1f98be4ee83ebec813eccabaa94ac1220a40646f880bae5c00407804b5b867f3176bb8206ac58e6efb277640b4997720168527cc51dd80dbe29eff5a6a5a968f41c89fda26a7305f4ddf369dd85ccf5456b4028ec86016e9140a31219cf0a003ee6668434fd31a200465b3750d1a1b587e11837591a2cbee52d9555beacfc400ff1f03937caa6a711d5e0072f181e752366f69613b3bba83d427b7f7041fd2bda0c8d576619302beda50c55ff35122eba28928c5813fc8c051f7f69ba39a6108ed67889dac5ef32965f758aee530cbbdff9c13760e4c1b1885d5f1c26c3bd7cac12dd432253264a8ab1ff395c5c0e815075e18211642286e957e33311481a8b2806ac0372b07dc623002eff75d8fe13bf7b9710676c40ee98006e11c309dc39ba616c529bb51c780154dc2ced0b970b301317309e0c17843ab9265f191a4c7f2829c7148e620b0aec175046b234b17138a73070a3700fec4182099123b68125a368343ac3c6ac4e35c9358561a66387a78a200e2c22994be2a4b8129ca51fe2a047f7785c5de6e22913ef45657f08810b96f57a4e2145496ef595605b6800e363269fb1c666da9e5612db937cf5dc6f0d19a32a94ac143fe8ba580689a9532c889c0f9139cf9e2d8339ad0b1482e619f0fe9fad8a22bd5d4a040e4a7b6daa4274912592b99ddeb00f129855b5bc11f1b1042d76949f7ab351a390a87abb5167a9a52c2c67cff40bc8c517b51aaf82d75040d68764f830be8466a4dfa20390d02a3ea13610fed32970cac024d5f23af1893259c0abf6e6c9aa2f9caf56a205ba1d1c587f6f1d194e5de25378fd045cd2da9ff563dac7845d77b5f70de90d05d77a75891b02f13b5faea897d0ecc46d069f16dbd66353718a607c15c8bd679799c9f995a0895001487280c3f49c23dae1cf4f337e1d62779cd9efbaa7b142eea9eaef3b33a6c56b81cbcaaf9b97682de5bd2be06d8691071fe8ac34944df6278452eaac74e5a05716de66456623146aaf42f9f97979df477e3e67e4657ca85e69be2f5ecfe1088719c72b3be5e8b4980f5762439aa441fc5190006d8bb71f398fe8c2210a2834fa88d563e7ab07cfed4a9d338bdec21437a6849739742b72a91f524ba73be7875315b46d387b47fca0da195ed9fe6e13e5c2696aa19c99c90adefde775781e1ad3d0c87ccb164b724c1d1b9e4737bc618c1acd39985103f882101451435802639565b713dcf14169091f9873106da7b1133f34cb53625994824763681e364e4be1dfb24957e69bff3dd0240861a1e02c75f13257407cf005dfe0b107a8523ce3127df5b8cc7108c087848d2536c7a0ebb8b2a2786e44652e8aa1cf60e005d8b40742b1c0f28d4fbe5543bdc856255a9ab63da00ccb31b129309cf8e4393246463812ad26ada8e45e6ea7e5d96ec7a2314b073a22d0805370a80c0545298e8ac5509712aeb6d5e803a1addb125e3913e034fafcdda6ed77a52e50fa3423b335dfb7f0a8252ac55cc4cec15e022ce8f4fbb3c1c5b72afbc5a77aedb531cadd012f60cebd433273e81db171a401bff0d02021134f6f5635b931da9ba9bb494ab1fe7edfb88f340b1a18f0767791e7db28a3e5d6ad41994cd7bc98df53696e88d0d303be7c2ae1eacb21f80391beecba76ada5ea9abf65d5a959f1b5996999ca9bf30464e8db68f1c5495a4bc524fd3beaedacdacd9e46c256174d15b2043e5a4e99d8be2d44adc0f825d272461d349386015fe41bf5ad63e173ea0855baf60edb4c0181d3961426988cd93669b47eb0c5dcd363cae8d961c8a6eae66c061b33b378979ec356b934f2a37311b3c2bc3ecd7409f9d45a843185d69b9be74164fca4979451e95c286d7fab3a7dd0ec6c5ba37b42a7b21db4714725e7d7c8776bab53a3205c77acb7354d8ed90aa6d1cc610f3b683e8870bc4f13737fc9086c506f73220efb98376670354da34938473f986c1dd4aad5d17f767e5789075449f537034a6ddbdf1088dd594f964d2366a8f858bc2d162b8cab212580f57beac5a52aa49bce1baaf775a8ceb0305419045ba0555c2478a57a932e1d9f96b5ed144ea945626c54cb1aac9fb4082c8dcc5f372c98d4bb1140ad4bf0ff8d93580ccf461d458e8086a72bcad874b7fa14724d8766660e8ce2369591b5bdb53d7b5f5da65c0c6041311f0bcc3ecc5108d0c89e9a4f2766afb549de92d65713720e1b2bbf8cbaf7db4a34198a531dc918fa6bae979de5796b5732bcd38ba590235b7a30bb9e1cd138340f6ee7dfd8d40999716622e84817e6c787f0a403683af5aa36780ac64a6e0d892382d9d074b2842c08aba15001e27bee27df6f238e6d2b15241f442fc3078a3212053bfd97a6ee651662a255914fcdc3fa4cd4dee8dc9315c0784b82b666d75f19919f618bcbc9a3055845405c330373e6827002c60cc68f32d0160537995979e5f7a6f377eadc6849991af357d045b2bcafb1ab00f74af1700d9fdb1fc850ecd926441450d281d428bdf15aa6c3e1dc324f5487767b5a6e947c9c573ea06b912da7beecbcf720f87cb8d4129704b13790af1db6a3916e027b54bcca3ffce15be5fa7a433f58c18335a63a067d81d5989c8d9c11f60e863c468df9bc816c2ab5e713af38570c052e8819bfb22ae4bb90db650a5692c23ffe1f95ade6db6e1cda955713de9deefede17ab09e12e529b940661675bc0601a8549ea7732c01503dbbdc2f0be96f811c7f133ebbb72957d97b8207fca20cf0b4cd6dc35dcce765d130b65be9bac8ab92fdbd8498bb0a27f29552c0826951f9a1b012fee075ba71ea2afe01b4cad46104fa5d5743d5afddf37dedbe6fbd7dac581414aee95d8ea270841d0bda2173e29e4a99380f0dda4182733debe0144623e90afa9084f0ee00645eb27337d0b6f712e759b44b4131df1f6243d605ff7072bfc9946c5250a9f5b82ba8e3c3dc0bdf51924f79dcd333e5f9180a139eead0c7e07d75ef23c3c13a0a6a861c54108cb1e64dc9deee7c9b200f857eb42e58041d396a6aa1cb5d269cd5d8a860d1758336527a493a9420f8f68aafa8eb5ab9d79fde6eb1467a33db44a4b6f80d6210670c3fe2445f18cdaaf30a1839c0d284b0a5fde0ae6836a3ad297f5b8cabde14dc02fcbdd5c33a1e413c4941674b1e704b2bbf7cdb44ddc208db2f078692eae3a8a6c289f0aa7b79502c760616b3e73fa367602c4cd04f36b5f512f202c544a1141fd2ca147f020b90721ed21fecf4af393669e5dd0ffb2380f8bcfeb5dcef9f3279fcc36adc421f309544f1d45ff242713659ea0f951b620174cbc6c42bcf781a3cb0703ab1ddad9e038f8e4c0761a5215faa75513a04bc82e5878e8e1f0ffe1b09eaa9283e8df10ac71b860ce4c9d0c1da48a92c8ec28f16bb6b9f33dd9720e833bd3b62e792d559e367826788260c380347fff76d89abf51eb4cf218d0eca111a17533a1b420217282cf02a70cda50819e2b36aa1bbf311823e6097c4258426936597a8de6260d10ed2c1ba099678957c98ebffe951551b392027d3e2074d0fd9b2873be6ce1ca9bd1cef499bc190846860b405cd56e3a3105fa9fbe63fe9cf2e80c5830ff6eadc7c828a157e07378e31472a90248a124de0314485c6f0877461e01735388319e2db0c767502628fb90d1fa9177dadfdc957489c05a867acabcc56a127fd6b1db3adfb54754942d664361b1a52bd7ca06635d4b1da287feef7d00b41bcf84bb6f453ee3976f2d728135c8a1c1d3fd20c71b409b87889985afcec81045fb44cfe9aaeb69daed83ff7a1cf05072ccb757a4eb3c3e5e32d226a93a328dd7e398d1d330b6d293dc6d261706333ecfc83d98fc9b711f7760259c02d57b30356ec4a375e1a94cc0cb2d8d7835a2e90875c44b50be8b9cc3f43555569363fed41739cca32b1ad66b8523409621e41e9422326c186bd4e13e621f408e5e2c2fdad25e7ef4c1de514c8073b57ea74584bc844a9e8a1598002a5208f50908786164a7e6939a61643a0786ba52ca5a45620e1b3ec5b805d3e5cd4e893859d28c82d5a45b13659bfd52320e1464f7b79ff0e8828cdd5caa3b23e5db5658c67b0aa31c84f16b1de0d3e924e297d4443b5bacfad3ecd185e03c71b2c8819a74df94236eb7e68576bca7d3d0e9e429912a8f41474cc2a9c2474810234c666b378aa3cf4928406e146df026aeb83c6aa506e8e39cba2a17811d21ff11be017ef3cfaf030534a81274ef6136c1acb4b3d70b5d737fece9023e78d94a2134787f4262083e6fdf56efc009e7df4ad763ef7dfe231a03fefa331dfd2989bd3a56bcb5f321d5337c9efe1b14af502ab3b2083d81b4284d95be9b218fcfaeaa235015fc2d2c7f051752767391f94e285854c0de7dc47fa5770b7eefb865d3a575c331aa6ff5d9291c3f39f707eb8a414993629b3dfce3d0b5eacd9dca69d18ea5e73f9460a085366552029324d27d020bafa953373a237b39ed75cbe105cec4a0e7880028cf7b804fd85c9d2ae2f6ec80d63f9a216a24338c7a3e6233222be9bbee6848116a62139adf16531a25aae51a15fb6084bc882acbbacfa6b6a7a966c30638fabc01fcc87fdf134c9a6eb09a16ef3b5e906661b3dfe74f71cbda47526a84c8e6703790164a82be2884ed73d484cca373572025a5365929f1841be42fd248361ce2e2ef6e5333a4dc8e61d78abed5d207c383d8a7dd1fb876ab44e98b515b04d31ba0ac981906c6b0fd32b445ed0646837132ad0111b0e73613dea7bdf8f619f607eddf5e631a00b7670d67db02abb259a08323168480ce957afba32ac7d0410ac06408f3a3737f438b5f720a1563a2cdf5ac9597de6e61d646eb58b40ef5ff5f7514cdc16f8096c75b1c2e4e106c2a857bbbfdae7eaa820a55f839986364853de0b82d55ce94de8221f59586ba3f1386e89fbe83eebd6687b065bacc263771fb01e504fc8293cd309af004864bd758c0a9a19583fb3427873b6c2e420cc2872e3901d0802715a478d5eaee4129262280f4bb702583e9929c79b0c13d1af7c189379c540a5e8d663472479dce65bf650dffa60d5ed5a84f20c70cbb05beea650942d8c2d0d6a1377f1304ce8938e7e7ae3fc91cc20c31b5c18f14c70f649db0509b871d9de625b60d021f002b5f6531248e595640dcdaaef765a0fba0b08cffe93c2bd11c0de3bb3f919db071b2002486e18819a738f31eccdb8b6e148544f07bb4f342131bae7a5ab6e2b2480e6edf5e5b9bfb5613c3adcd0ad300270d318408a584b552c85f3897179ac9d441ba8028c23fdd59276c8293faf9be3250f479dd4486103aa3e96b669a757fc866029b5144bd6daf27ec753981475d619fa7ef71fc4595a9d5c143cf627c04d6d098283c615785866705321687867531148dfc3c4d9fb826b5adce570875e944b4dd3bbc6ba26c278038750383eca7c83ad8783f99633e4cf08a7fbba6140cbe626571719dfc72e80aadee2b10b423e7d01000cbc44ec8011631145c36b7ead58b49058b80e999cb2cc6196c94b6892f08f868dc320633586d4b5ec59e99a277adcee988946f4e06e8de4c2e5d3910ab040f1c15aa8960455f7c97e6959eb933bd0d72e2cbc68e868430ceb0956f8f90b372caa06125beda8d2eae37bfabe45f550133a3ccbba7cbf2404077d2e9f72ae5168612abe691f61ae9e86c39faa81f5e3606b54407d2b0369caca36abc839a8a67f4032f919d687168dc904a98b534b2a914e070b3105a12dc2dd0468dc975d3936094f681ab2eabd8f2e866bbc98deb4ed35ef6cedb377aa488342b8373c62f8854aeda48df5b52ae456a4da74bc24552cd5c88f58bfa8f76b54c044a070a1c451beb5bd16310e434984a60343f3ba917703827a474628bece86abeb31cb9bde46fe8532c53f38f29e5e7f592fa17bb2d104643462f161cf8a7b3786fa17d36f39798cc131fee1810c3c5742a713e27d36f3005fd12b83ea5b1c302578a962e65c9f3237a299a1170173c0642698cda060c46546f17102a998109a0f02e18e9b85d489a9cc56b876b2c1eae8f8c0788e11e2abadaf4b4a361fe764f3ca79073f5b8ddad645c6ed0978fc5653aec81d801ce899fec7e1f1861def02fd0881d5f41a5af933507f6bab19803ac693222a6da1f3c8b26b9c3105e09e58b2731e1911d451b3cc341ccc4e9f6c8f24cfe71e28f3630890b89eb944ccc7ac9d84ef4ec68b8389a1a53e54c40f5f0513b10ddeac8e4f4eaadda57e234a42a7c2dbc523345d498a47a58b184eb52d1ffbd345008f69a8a798ee225dd87fbb98b043eabd1da02accb76ce4550a6044aa3aeb64257312e290f29b9f3112c2e59213d006ff666fe605e0c5dabfc799311de7533ca5e60c6facf2b405650b290722756c985beaddae744101310b5087609ebc17046f5586846a165f49cb16fb2670f70eebbca95f580e8640cc3cff44ed97567c8aa2c207ae8c47e9638bb5b429e6c9aa008705f4568c99ee8240695ff1c896cec9c996ea1826622d0b4041e594cb26d1f00b04aaabb0add06a5611ca270337fb104ae9d743b1c54594904d8faa5f8584fc3d043abc0ef852ffe560e3cbe91651811bb664ff022c76692aac1375596f4d4abda1842a1b1a9dbe8069ae30342b6e9aa6a0aa53d030acbcd1a41b4a316724536e72ea6c05d1dbab322eab6cbf90da5543ec5e8a0211213320d5afed30658ce1a8f2c2f56a765a645cb7ba58cabeff73c039bee7c17c9b6869643db3eb0bc199a2cfc5bc9faea08bff30ab7425236745257b6c8dc9087fff893ebe96fc01ac02bb8e504d2ce1d37f626e0120908376ee2ce362b9449feaeb2086ac96d63209d7687d66deb321847293331ffdb7021fd6299054255447ff9c9ecfc91544b5d486b08059e5b9b149d1bc91e0b73f27160f1b2c6b6c024f085d026e422e39f7a5f70101949e60d09d5b8e82fc64b60661752c0446fed76478cee3f970785171ac487b221d70997b89bc67cff73259f98ef9ef7bfc16177124268b66c5fd3500f374dda342c979cde607e6c523f6235d6688c652bb4bac6a0881717dddb003a9133d6b442cb8b1123cdca3ee26ed39b3f5f764fb60dde2701f09c651070f3096859bdfb55733c1ab5f17feebdb972a8d28f02dbdcae49ec6e78582d465794027b1f6835662910dd82628dac6e87e96367379a4cb6380de1912a74ad4daef5aee5c8b484c372a2549e9e222f7b2ea743c1714db3c0920d07547b25d25fd3a37a78858d312e80a4d878a8dd51e2781ef25acfce4efe2172a803d17ea3880939c56a506382257d21721d42bb1a45c89a01486166a74a88491633aeed7e59b320cf2b3d973c341c20cd0804b065591d1cc4de3c724d1ed70e2eacf90656d57199fd547c6486c95bdbe51020840988c887b9b4e7afec7d21656792417abcdc6ce710267702500d84c06b44a1153029fc5019c42fbb25b6015d3c6ee2adc131fd72a36cfc29fe460884a584ee12d9da2135589eea8f76a0b4d90eddf55f4e12d2823e3268c589acf808130c71162c8ab3481274de0fd1ab069ce67613c7f7578ca88b586ec6022a6c17c7f0c14537c0b9e66de2f12742cbd1149b842190411e59e54f6d24d6c2e41d6684508a1a84e9b0b8d4f9aa5ce6e31438219929ad1514e46b7a681cda599fee09e3f3808bdb066fcad7102a50961886fdf095c66d437dc0de3792d77e5271d217093186f1bf0a5bda6facb41841a04b5ce73948fe6bababb4c1e285725fc0c57b8c2ff7f362dbae03b14eca46ff8a4e61c0ff9a97fed6a6cc6a25213b9eba558ad927b923d066b4fca94396fdd1ad261327536b6da9f3939022975cc539cf561125a66f4a8ac4f95823bb6164795a5672087eb9cdfa1bed1abc3b00c40941a9a01f55698d8f4485d9a1fea1c2f4014b2838aea77593344974b527510db7764bfac553b27b09ddb6e53c723a08d1f31ab1bcae2e802e9746c2cec90359510da813732d58e4b2a3446fa7678b70f01b21c912f03fce80a3d6b4198c1aceaff8ba6ef6f61c9cb712e741e29c14cb0f6b83516abd7d8cf6783e181ad4b30c85b690c1365880560ecd48ba399e7f36b86e7a5e7da0aa82bd3242b368b3b1334e342d858fc35f4ca053de24b06193954ba06eecce297edfe94b96baa8955ae6a67598d53231919632dfbb6e5b11ef1df61ba048dc638fd6a0967581a64e29295b7e59318f5ac17d5774163880620ffa096d2b20c595b2b5e6f683a0a1603946f3b2f691c50e50b5bfe1bf138822c36fd898ff6bf585348ff382c05b546d746954dbf7f695bd8ff648f27031c56de490f5116dd9e2b069b019b12a3e7cbe75a3ffe72b5e8be85aa6c87f7f6f537dbdbd0006ecd47a1c3af7f2b3fb5d37b5c2789fd98d0d3cdb0dcdc8eea65db9b14db553b2c2b5fa56abe843e20382a0b951d2e617114a6677c4cfc866d425ab41563a4aadd4d10367f912500515e112f05aee2bafe72e83e6c8897c95e37ffc5eaed492f195dac7189ac8493915e0fe1e070937fab4dfeba1dee0913fb4bc9b8db945d2800fa03b4de114596a00bc0e346d2b55811167206ec80f5f5ef2f425b5a264236870e7880e7127b15e0ded078bb4d35ce7c4f864e4d6f46b070027e17f0c423d7cf0dc2c85858ab40140c74a05ba11e300339f5db49232fb79249f9f91106b66ece2528f5168a3da2dbcce04be585a42617db004863ed1190bdc77ca34719df8d7016b2652c716e42177cf7138c2540a18837f25f7185604ce561e15f919e49d1eb30a5027fa2f5fd752be8a3b76d459fdb7d1c07d5223422811bf426b06df2c70e85ffab96a9cf096721ff7934baf9f318d9cc268b3dc30ac6566ba38fda786422bf74f8e75a928120bfa2693b75ddbd24d29bcf6051310f7b246957f9741cfc20e8b06f306b76e86baf076128c7b6a62e59903bc21c434220adc723faa5d03c796cef8f093e5e56793e75897f4472c53efb9353867c946c9014a198ad2426ee862496550e7c6118ae051c7898564691a742300b410757c0e374a0358b43532ee6d5150156a4b2e362773e376950f97ba6845df9a237c746ab251daffe4e881aa3a84ecf2e562ae40fbf20b7fa60b36ee52c69d470623a709ec1cecf651ef2dd3cee6026511323894dbd770578ca11e586794aa2785bd0a8307dd31bfafe92e07aff3f16bf4e316e1e9b7b496730cd26e7485db5ad45e3efdb8f88171c4fd6152d2e90601d37d3c893401bb6be594b8d68805de06f56883878e3d592f44221d2d5bf3be83da7d11e1e2d204aa38c980cd0d0723dfa9246375d5518190df8a38ffde22394dfe22f176b7e3086aa6a7dc36a7013af4d6ee4436bf6c762846a51e419fd6b5dbdd7eb8c5f65dc72321720e2c128af8726215495f1c2fd7bc87a6916f8562b89b6d4c2c8e3ec2b1f551e6981bc3438bba4b1e5fa3548a2daa833d364fc7161480be2f8f52bad3376bc6fdbddfc8b5c8c62c7691ae3e9c244ef5f0f25e00c1ac091d30055e8fbdcc2ab0c6474911db8d9e10e97a764da3e578b8c60f478c0227bda2b4f30df7687916ec8d4248ef9929765984da39f2b68f73ea5c58a7447c758f49d98e7a51ed5820ba64ef4333a44b4ea75759415c3920703784471078f8fa7a05786ee460b3e8464cd64177fccf942c6eb0956a8371dddcf50de269dfac73f5e7035173c1a89e52b10e65bb4f058d7b639886ce5b75f1a32b89774bb35c807b6b5c1eebd94473cbaad62c9fa18b9b1d7c5db2284eb1d2551cd029f8f455498f68ab5df72e04b34de16e1194a65f9730cb883028f3340cefb02394850bf28a7f7c5daa1d432d0eef50f20a3525a2d53bc5504f1a248ef58079a3817c58686acdef2d3b0ccce6097466ef6bfa52cbde07bd7e68426481e4fdbb8b2a95d54f31c0670b378fe7215ac8f1f8d0ba5aace74455510451eb71f2b7e5644cc1e698a9998910a27da7b99b890043e80e3674683e61ae43c1aa79dfff3475073a90b76c101319882cc8a40dee89a468602727c7821daa17c3c57aada2c2a6163246514ca9eba0a750a97d2522baa72e106b471e60cb5395493751b6599f708000635cd000883314ccb36de55505eba919c028f15b3ee7d5314b5af7c6562dcf011701e946e733bb541641f7be40c3199d9f1faea1470b6da5bc099efa5e8c0b8394ad57e03d6ab73d64cd41b39928f8e0aa302bb2086c611d54f6ac4ab0003c7496a693f20ed87182477026d1100eee1382c1a7be9b51f979de9fa787de76f904191a9a4bdc6b3df7315f9b4595435c42b98f404e5085f8f1076bca8770b5f7582d174270d7b7c2ef58c460bac97fc6e0bc750852c02e3b6ba74ef82b53c2f2f43db57d383639027c2a7f056be666b19d39717fa8179f5f1e99e7448a95232a1ea574b6b97aef4762351109b1194760e6c4c5a359628a4787422e8b446e1127ba20fe22c24161fa30c7d0602c5786dfa13a0408df0ca1f60c9c567a63bdd346a839d7a671f38082f313af94b755fc4fde8577dbccd1ae25a12887df611dc7e2286a038bc3f051257c9ac0e0193522974c6628a346ff62bab11c894d04beb7b191995ced270cf58cb7d9e2fb1ead7a8dd6ef4099ff70779583d9005ffba6bcd435bd9e8e7ad935b3060f325dab8c33ce02004cbf35eb498f8ddb54c0f299043151c57b4d18b173d664a5a05e16c69fd4d74e9b2d83c1c5caed10b1e9bd9d1d904aab9f23ff47c9c83b03c8475d8c3bee1c20369cd1dcf9c8ee09fd31bbe161e705ecfb20759a92292b476711288221bb1c378360db5ff0f6f70b8a2047681307a6d112cfffe57e4453dbaa78328f2a4427c12bf4a1a2ef94b6505b8c87360d6b2ed866b95a592919acca36075dafffef6e7799b1e88e64c1276afd778daab11a28662fdb1869abcebfdd8784ed768168f882fc027346c39b37b8c911c6cb89aebd0977aefd0450f63344a87158e8249b67949744121a64bab08b8e00802eece930c9de773924aae17935f4235aac0c4cb682b06a1cf85f9f78b9dc2892859eb24187664dffdcde9560cd776c9447422ef142cde2489e0c933933cb45da424bbbd87d165a4d44cdc5acb485d4ca6e7a51be068cb73d1bcb60ca0e05227acb894c585466d849899d6870e035d84cb52bde3a370bfbf57b57f80eaa1de664fd3a44b5995ea9e378d6524e22410f220a2c03aa80c13277cf25ee9f6d04171ca79d0d64f5ac5279ba6af2119fa8daa7660b629d153a2dc9ff2c29332ce386c4d70fe2b322c0a49784f0b43836effc46ea72d5be15db8875b654fd2f82a56418ce976cb4da182d281212da9f3af5e8f85748e248ed263afbb515761ac20bb3f20bb392711ed0e66add08efca96f7d8ccfc3e24f2daed61154a7e99208fa3037f88324428bd5efe75289ee579392deff64397b3a12179c0aeaa80d64a97cf3932a5b9b1f7bdc2adc83da96ad707582d4387c22b48f424386c557a7a2d83dfe9642ed027620e7392fec658c7b711d10615fba7ad963dc4499eafeaba74d158e8944773a5cb39db259df1fe357469f917c2028cc154ce9e6c3de62e36ff491b80eaeb90406d7dcdb68542ab76e08d2209b5deb364a8e5f813113bad6c5ed973ebaf910bfcf52314006ced372d0c1c12feeafb5202b5db0c48af3de6fe9583bb2fe140a1299c1bb8fefe37e74e37a28646477ed6b3068b4c47c97f160fe62154d59a77e1749d85f8fc38d0a72be7014c92bf573801fd21bea50770e65c36b044a6e8774ef6da97f19ce0e337f64235730739b9c2ac847e8444dc1fc8a10ce319bb754be5e0cf03b3b1892dcf10d92b28718dedc46bf28e9e203f69ab8a4b0cd3910202a4057ee58a7e18736a2e891485f62e3004d95d8d52e615f9c6dee418c621718af7baf852796e6813dd61cc93b805bb5900c104dbfd72bd7ecbe2d3700d251bfda5f3ce1186b76e548264671486cbc1944396cf2e5121b27b0a6bcec284463fa55ba8c42528090832dcf2a3438c1b25a32a4e8b0f3c27fc20ede6a19c33737c3a80e9af9a8beb5d4e2c8b3ca3a5b35dd5876047ad7d73d3e6e118835569df88f1319703125926d2bade835e5433ca3e46e57cf784a9f7e40696f2ec45558a749ff0835abaf24ce34f71c4eec2954fd4e0575be8253b04dcf712bbddd493c8a25f5470b25e16d535759019a8153eee6957e367b5a41545a83708d7ca87e890cf953da7eb6748d2911686ba6ae5ac0cf7c6af9c32a4ced88bd2e4e1784a141255cfb7987edd1c15836c13dca84a3984c0c61e07c4e67ad3b0d404ee53e0663a21edbf536e9c9f273fd73560d9fb31ec8dd92361c8988b8ad810a3df7bc53331b1b5c334de626d092d604e83dec6e643a7d22b5d7ed58abfba318e6786416a0c54f38cd5c73b04a3395a25fb2b4869dec4928e5531ea50c1bd7dd97ef723b92c66709c9cb39e2633fd57a5567ae2df4243856aa4d95af7b631807b03efdeb572fcc15e14e98aa4075dea5dc16625589cbfd785d3c2dd66e5f2a61a93fe35e2f459be733f2faf446b52ef9a53547b58c7577c514cd61e09d05f30b2d03d8c2c759d1cde723f1d458f35d19339279f21509492a9c4547ea3b57d82407dcfed6855cd59c17de530f6415db0a339ef44233100321c27c6f8774ba64ed968bbe1bee108b40ffa14b265958e85713d1d44dfe495f475b8e72164edb8dd7add6463138be368a51141754166a3f4bae481fb7a1b403cf45f518ad671e2a900c98035865f3cded1f8eff8a54005b6db2fe300bbd0a9f520051cb2a5fde2b0810939b6b9cb0535c776ae361359c44d19c6be2919630889e4f28b52bb570af8987cdf662a4826100ee6ec70f415b88828d75f40d569179e31acb3b4ff13e6d30a74d4ee7022dd00d475131ced4b72223bede2439a870746850a37d9dc0e25dabc6467fd6cb1581f3f5bd2ff9734a9381e78016d3c5445f584fa4a8aede2acdec21318be96efc3df04764f7177dbaf8769b884c9a304c0842f635b9f218aa6ae14aaf4a4198cb333f99e256cc68d9abd003dd0a7cb2a5e8a70fedd18204c89430e110fa2f1afcf33615ac79743527b52ef15f5de3a69908528b430681103044bfa35f7a4d43568dfea7f582dc537eaa776cfcd02fe83a8f306304212fa43eef047a522ca8c476c5c5b6a6b7b6c879cd7ca7e88f0511ba7b32a126141f319f805d96a991fd3258b8344ae0d77ddb94c97af4750257c594a088eb28079d1de2ba5d808c3eb7814c1efc65b94a44daeefd869c34bcf2f3f016e6987768752c1376a469026a6cde901bcd4c31d173be148e49b046a4758290a230272217d14d2a5a079131f39273d910bb0935cc643c04ec088b3cff17590999ebc0d34fc2dc6e4cc4b876edb146b7a4b41b0a98429ac6b184edd8c045a351f55b0fc2120ce7d016bd8e69c0e1c68f0b9113ca14ccbff320e945b1384491fc284d3c6adfe154937f1666d46a302fd6769f8b355a7c821d1ab57b35d3b92d34b2e55a705dcae031e3450c8118ff5af1e139fb2f745badafd7e7efe86039e9763b5ea8dc865347723ea23e04a90d432ef476e31b865d322cb9cf9ac76716c08db9a1560979f508cc1940aed277fa92ebda4f21dfaf1413b4ce35a91359e8128030d71c1399e50096ce31b268a272d07b32ffc84f57d312bbdfcae223c8aad47a302dc058f6315c1fb3f71704b2ccdb7ac222d3da9966eecd154a48ec0381f1241dac793daeef100013b821365be2299e7f739700ca1302eff1fe0f17fe512e11e477b097d795b01959f68cb62a26ac3e9efeafd6f0b83f6cf484df7e7c0b95253c6f77da6c4fa8beabe6d5a1f074356d9abb1f5803d5ea7477ffa1c471672a1a289ff23802f163bcd63ab6a211fd79bcf410a7888b8942c03d7edfb7262ec7c5fe1ff290e6ace6f9830e6c60a2b015ccc7e7eacfe763bd2918a1d9a5843ffa2a0579fac247369ab6f020df06b0c7df891776132fa840c73f341efd41f4aee60e6014db762d4463b77e90e16b531530edf202145d8d8a3fbf4a715e47b615821b9e319e9c266773c28da5445206cd194290e2b2a9e32652365d0819c7e5601dfe18c100bc5d3071b9774b586186a803c8926357e9ef608edac1207107ed3cc85b2cacb8e5290b1845e80246416937d6240c25b539389ccf304425bcbc6b6def0960b9c79a263e42ea98bdcda2047e226bbc448e5197f5a916828bd9ab71aad94ef7a96d44813637976f124f06fc819e22db5769b711c0faba5f27cd0319da8f09aa639e7558fe56132344911a581990069032f6e38a514a2ab49232ad837f39e5e79b16eba1d7ed5ce05294271d087359d88bf205a7035ca623ed833bddf60ad2d7ddc3aed56ace3321cdf40a5aa6ed8da53e3decafe9e05123b8a00ae41db274bc82e3bf098babcfffaa006984c1921572ae524e4115a415e6e27f990e04cd4a98b52421749175c96558a0b00b9a51bf48e371bdc68b620fb740dfd2e75556d656d18598fbc93af9fa82797974099a8641563095cd188032b910bcf6e8bb4596dd3d92e1466706199e1af9dfcc088e119d7dcd50b804cfad590bba410a0329aa25cf8321c1d56301a92ebfbc1a32469e71fea3ac7adb066abf18dd55c34c7e4a6484962c0e14b31e65a1052606373284bc5600766dc47991e9cf40930f978be3e6202dadf1d91054e29556edf65f9a8fb9dd8a882acef3571e876a1b0e2c795463b57f7d5cf2731414c08a4b77f04257a4d7f5fd1ccbbfd6349a1987e24b2dad4932d22b6c3f36434eed26e87873ecb08c3aec878b9fe2614e7d22329f18ef78d62780683a887797a0f0bd1a63a4b28f4fa363b2cfdd6cd6fa6786e2f53ef1012f8d519ce8161f5d5f7e620cdaa522492d9ed656782343905b1053e1fba822102468d5f49a1d29266f6af04117dc96edc34b0db9574fea55c00f75054425225cc11d6a57a3905d235b901d68db327b5d23536877d92600d60b20c7e3d8ef2cb06947622ff6749735c307d2bc883669bc06fd378ea41302e598d473cf3dbdd22419847d662a8b83188e94da00882336b92696077fd6470fc448ab8977ba9ee76b4fb6bf1ac6f1631d7c52d0ec9a526ef6904b413842bd67ee07feb0eadf1800c348050c0772c56c05479b41763d59be74a27b74fd267465a81d0611ea178f07c4462f5c9e881a9218bd52e3e67adac5aa647901646750e6e6f51c7ae0858bfe9d4d0d1b5db1b86448f4b5a8385ac06bb5dd704f86dc1a2961433c5a34e78c47eb5426268c98f8f1a503c0fd8289d13a12eb0981e5b224b2a1dea171f198117e87438689107aa8c8cc5a4d43ba6ade8b4bc1795ccd336c9ed4524213098820a7b7996526e1215f3e066a0b19f8932a188edcdaaab34c0b0805031733553ac1bb779dd06254ce8429e27cf560df7ad12383d3e742d6fd1324483edc2cfbc722d66792c10970dd7410dc6ac14376b34207244c1bb4078a01a621962dc3aae0d1ae7f1cf05a57dc01606c095c1445927fdea2bfa29f44a908ba4bb0584ee9708406901b73bbeb9d164c199f5ba9174588abf9cab777e089c0ffbddeb97a9b63a820816a1bfa9db149734da0cbcaf3705ae979ca889dbafbac96e7d31e0ef49979d305022bffcc530bcc4501042cfd827e4a30548b3e05a345e5363b983b8fdf39de40160bdd0e0d068641dbe0055f474e82998a438da72c44f8b85faea6985356aef14f38b103190b763d1d93b6f2791a2cc04f57ad535cf5560a2e809a238175ffb15a8754859fab998ccd3e4ed13c001d48ebc5b3482d3226ac15873fc1843457c52c0ce8e5f104c0afd91e906d5ca1b9823b67ea9eb1bd1e3a335cd7bcd35e07aa7eaad94121f0ee69dff578412f135a51b7103500c369885a13066da429a84600b23c2d1d6555954befb376c1865d52d4f1112cabf0d2776e2666e969cff073d2de7729208bf6261e257ccbb47ceb9ad3a02154e082e0c24407ecbf8e2254369da1360550025546907beb1c30238c40bff0ed6796ee7812aae13d2484fc4e58024201ab2d2020a0ea3d1a79fe228db6ccbcdc1ff39e62c742fcade4d51b5deae0e5c74d736ce660b2d64d56971dd0a55563a0143178652ace7386bb8ccacf07d01c54ddb6c2113d9f00c71513b7e6a545ed43527c5c542e82f96f74529731a766a22389cf11aca247bd162725c5d42c169cc8a1cc95940b635ed6db6976d8b21ff599c4c15ecac2a8da48a0b5495c63003d1d671c27abb7e58ca1e787accecd54057b42055864d987a0d4a1b540dd3c682757ebbd87ed92f872a0741d824184460bd5e4973aa3e2a9355d3e2a8117f8d2e6674a9b0f84596ccb8e590e899f62563992f6d7815fcdf2f8ce0e5dbc6313dccdf84987c8c52cb1a6c98278a00b5123ec756dbb7ad289a6e5f3119067e92a1d49fc9ddfd397962092a4b6bb78443163ea7fc04ac61eef3281689c024f123d5989fd403d6ec1a53bf8f5c0e7931a6e8c30e7697242ee5ca27abecb389828691dc5b57675a4f0335f28b5fa83c960a771debb7880382d8a77ef28a6545174b14f77e682ef9a3d5f635ae31ac62fa6e46d1dc728ed7922e475d0d5dc6e6f700202a4774fad0ddd464c43f5ccb2c0625ceaf98fac7c30fd7a8902516cfd5601f0f70c425a488ef639629ebe905a17430e35e6578929130d3227648b01e2d9637c37ee7402fb8ce5ce97aac03334c351035b388235c4e736ac213660557eebf2a4663a873a4cddd387a9ae86a662ffa799e69db8e41daadd9aa2d12b7c14359b9bf9e0e288d6971fbb7df370c28e40182612a42598f41fd176078786d47a1dfe1100ee41741e4835d3736ddbc76cc86d10b9559051be67473144a4ef34c91b04b083c040af68fa0c06a77df11a24446e59ca0347c42a63ddc1beb80d1fbd754a51cb16b3d41f3ca2386f05c4ef8d94fb6f38f4beb568d10694291708aff632366b4e66624b04f07c9ffa09ab881006c2afd6adbd2e4770b1f8ce1dca6e6727dc2a7d2c43b37dd8ddcec21ad8dc6bd0dcf417ffc540b8450c03e117195bfd8378d030c4a02951295f5a7b160bf26100974574994f31a4664b4de27f501c2e57aa247c9a818348eb9caf2d48ae415d79e23115b9f07fabdfacd01593afdb4336876bc6482c396e94a2b0c0f1313f78632fa8d5c8b4bf5ae12c096565081ba3399a5880b2682875dcb73e439263d433b9789967c777eca1a8e712a63ef911bd5df72ac446431d0ee824f0f10b635ebf689a247c511888ef5bf5f9980f2e7a3a94ea0c6527ceff9963ea9bc65fd29852dcf5756289e5c6aa4d14a7985dac5814eb36f5c470c21fd11eb84fe264d5bc1bb93eb8f28bc83e2807c2c443db833bc79b73331639ab16626f039c6fffc87b24f84fb6aa9c945f8bffef29b06e650a85f51a14455432a4fa7994c71d95b9ea60f458e687538a8eacf6041b29ec1cc701e168d1d44c971685f5685b2a9268361b40f4ca4fbdbacd74c5436198f22cc268e4fe54219c1927bc3a50f628968741cc47941e7897fce8c7fc8d8cc651c5e4edb1e819bf5c2e460414da39e62853363dcbb0e5902ed02c59486618a2a4ac18f0ed6480626f8d19b0cfed92cfa3e9e21aa153781bd165cc90b40aea90a1cfc48d499b28d5903fc602311255aa79f13b94791dd6906e25694771413eb25c1d53cd1df54e359949e807dd5cf2527f352aabbd284a06433779ba8c5903c38e196e8d677081e3448eb06d85d1366867442df6dd75b5fd01bddeff7d1fc05333ab822d4194f1a56efa7aa2d5dd2bc7afb0719ccfe5ce97d8fca345cde37e06399c4f617af434eb71f837620967a8f6286a4f094a007c67c7f84b125113bfa26e5a4e45d93a01f9c3a9c2f72181b93347d9e633df01c3d1483bd2b5058084a75afc3e23516314f722a4f109df0c9c61bb88323709ecbb90acd49e50752b97c390507d363d48c2f69efee6ec6e8ebe25cc38c8261ef8cb72e1df4fe36484d469728eead80dcc19480a9e35bb2c25398ea16ed48abfce45539cca23cc6dda1eeba258ecf50ae1431653d7a10c2c2aa20c65949532f71fc392271fb8202b15ab0bc28daa68a7bb176f591893b64179264d1449ba183c7f371171a17bcd156a872cfc347b5ca7f18dbbb544b2cbee329982339902ae2bf9378a29a0e27e209f3a976bb0e26f370e4f15782329ffd4724feeb3a979c994077e5a2e5be8118d3e92d4218405511a358308abe4b91c68d6abedaa08069e1ce6d1c99bc4dae94426154bbca04377f88fb44cf75229e9dcfe80d7b759aa48ca839da170b5967b1e8f3b58d45e4d40855a7dbf6733cb1234056a09d59ad73647e568bb3a2d9d2958c9e524aad3da07805d78d4d62fd117f404cde66b77cc2bd999494dd3025607ee53bc5003d94210a54174df9a3b2105e50ce812afe21deadd7295d803eff6e4788d0c1b0b8487f940ad079c09a8a0c63113060458d5367e88ac700a73c3fa987d64155eac6beed8d1393f9d54b8ad4b487ae13e11c1aea67ba89b638b158fe3a6e6d32ed4424cbc93ed2d96c075521897f7f95994f05d7af5ee1101d5b896bb87beef5a6b23004f6d4e2f19f9ce0d3754c9a1b5a4ea15384469076fdb4cf8a92a2b5723a6e2b60f6f758dc82463d80405817deb5d4c842728c1f12dc566f1ed38694b1cd1c9cb84f3c62d40b4e904e03889ea9231bb10e509ed3e6a5cc784cc6a7dd5a483546fde2c661e49e74f625ecf509dc0b042dff85dd86cbeb8e578b386fc865e1b416a72c39194a6d9c5f14c8d66f37bbca5f76b1b0a33bc3f2581cc5677d4ae3eedbc11b90ba7cd6011e8b58937b5865c6b438614571cab77712ff9a1af1d9d90e6782a09b9a95638b0c4a791a1eba3a286bd76f86144c0621b86ae4841c110fd2f6a3c91db14548a2abe96add92d138c69bf9c0fa656e4e104bc889eaad931dcf5a8adc383a6e45efac05b07ca92727009f993ffd80e0332ab040366391bf313d3ec88a1d5a0ec3f2d2a33d56ac39b67e4d5d154760eb75b28bd33b2795ea3682f862f18015e5e0e1376a7eb920591bb581a30f32b44c2a6bf2e39376b585295dfd5f27608fa4dc4c5f2855d38242bae23bf43de95a00be66a94139250dcdc2f049d981719d3d719eda68347b15fd6feab431292d110bdb87a802cf0f0153b671485ae480a5795116e9614226aa40602eaa18efbb4caaf257dd6094013e3499623f02a457ff6262f168c2617fc8a8f54d41b8b5f7abedc7bbfee8f04ff7aaf5190635fe383a1bf8d431bbd7e3f993dd40555df9e103a7856076a57ffa1adadd625b0eb788e1f58633a92e03cdd7870846dcb6b5ab0b59e75d9ff94b9d44c035f3f4b4ecb10f39f0a21c836f959af454ee8fa06f5ca178f80864214e53363012b578d3b5d63f03c7109810f4e420eb3f9e07b0c717236a20ba921e38a0b924ad316988fcc000d93daf56f07f21cd0b38a69f681c554963acb16fcddd460ed57713928fb4e988b9b59b0b78d865d8465e20405cfb0427f7edfde0f4a2324c4fa2e3adb38d3f7b39f5bef3fef2540b1913fb9721f2b8b46ab741f1a580bf1885d9bb9bfa9fd1c1220632e721cea349827d2f930977e5db641487c5cb267f4ef8d675a0c555dc1f33f5860cfcf305c62dc075f2e25169e5c6607b58d824659ca90d3841c873b0875b9b26c594ccd2aaadde17f187276c812c335d907a7805b8eca0ce4b046c0c3e36c57ec0e3d2379cef1908c2eaae7f9354c6021d49bd88fae89fc144f5a0bd2fa55333858c0586c2aae2ee3037ce99b7258fe40c8712c850c81a7da163bcd91c00b4b93378f83ec76764422b7b35fc315d21873831b199315457d4d91269bacbb06f7f07de420ca49eb2b14392c46dddb6a16cc3724e38222666d460124bb1f758481d7cf2ddc9df131db180997543d32552c7baecaaea9056f3b76eb77c948a6517f7ece07bd920714b51b0eb7f929f5b6faa41d84394570e103e8afb236d849e913dc5813ca5a583ed4e01c6c63fe76bccbd7b8a269740b5bdc79bd3ec61f4299be7118ac60245e8b1d3eff8a480f8d7b79050b7a0ea9e6a0ef1e2693395edb513c0d8174f5f62cd21af9b1b507713624b53fc74e6cacf09706984360f9735bf139ac2018c2953230b1a997058c2000f78e4ea81b018f523f878f445978b3a92bca81237174887bfa609c8340ba161f6ba8f795eabcb939e7b670f0e5ac47eaf61e46a7de8d36eaeb94833b26a230d210753e8cd860394b91d1f95e187d5baf58e247bca2790d77e2849f01b6e4ee9f3d8a5b67f0461aa0b072d81578d84b0d331a61e7a66e89bb32fb33d3c88b63afd10bb74f40716649f86669d1ea7008c71bfd4e99769935e340dc5a9d737af8be663819fc94c7544fbd73f39f6427b3fc0e840a7978a727388a89457e55424ff35f19b4ac7ff4e7ff97ba2502fec986f92f8d8d40ed42ca7e7f8d7b44061df4398c92585c633a44be91afd31d8c148bd46c18378142c5dc2b7267939ccf467fe118933d8ca26ea5f653073c20be7b85cf06370b712a7b2cf393769231584888e39ed818354638287eca6d2564e07fa60729083b7ea248e2b856ab57a68d3f897a8d84e5c4bec342cdd2d121afe6a7ca164dc915200f618fb28169c7ecd88d0caa2947d4b206bc9a5af3bccc9a210c422ed60342806f6e960184e2a011dde96b8ec42485f3016448247807f32f8ba94bb865f47a60d2e210f880e3ff005f0ee106b329116b1739786355c86c378d9f3d8bfe71d158875ddca4f00abaaae4c051e8c9674b7be323fda01458afed56d407e7d3daf58ab5aab02fde332f571e5a4133462c40ce1fec6192900989449d9b621756986bb83d89787620e78592d5c4ab5eb313eb00dbad5e31b7eff845d890ff4b3ef471eb1c26b3f7a99c2b2dac61d6e95bf171bea87165d627ebbc537f284df092dc979af15e013eb4ded07d6ca8e6d10f53ae16e91de28761e5e391925987422e63bed015375a66641d708e4be8f011ea66a6a29be4596675feddb66d14fe12a9b6400c24b095fbfd054103ebd1f6715c7b545d7c161fd059bdb0ed9b9c09045636c4e8957414283d9f3048d5c628e715a7d3180779ea4fc29a9c6451eb38129ed93cc424e509660d3499e8f0f126c0c059da07ad173f2186d350e4866889246ee84f6af4eb3c6cbd776be25fdcb61483e9f5bb5a069cf25361e162e05af03a629abd69337e0ac0a715e6cb94f2a21f28679f1c93bf89abf5e296955eaa601b2b2f408afd26cadef26e8d7292feb454ffe03fee9e92f7b8cf0dfe6a3f6db0a4c6e1feb170937f06e2570a1fda85d2f4cfc2203e6619dd240494cf4afcc7a413e7030db42c653436f5775761d9017fa2e5548ff90b83c39a1ae65670f81d0dae306d01bab4ee22494c3c9dd9c6bf458c8464ac2ab80bb051fe5df5e8ae06c626286c0012d4f8a18a4b6dc3a69ac109cf8939a55116689333f626c7df6e7d56d968ed3a7b3fee7e911e46695549e403f8d3a11aaa71384cfb2ae8f3f1061383463eef89d8f5a7fda4186e3c02841faaa3ad45f7bf5efbed67ad52456a136c9edb8a03d2e090209cdda98443720f966052f5ba4cef91a3ee99f5fb8a40a907e07f1d723f03ad465eb9f37f46d7cad505a848bdef9cc207375891d381243184544a1147bd04ebed5633db3489b8b92597042c88fc7531669638389699bdd6c835653ad1f273f01661fd93f3aa2c2c5a110d58bee7b6068c6b5052a15a8c1a4f6aa90ac622acbf888500c315fe077cc9eeb9d3a15d977de5384331561194f4cb57af0ed59ff7a1e25b2254e0215ff4d9f5059a072e3403e91703d77c57e8ba6ff81a9b6f32f607395d82239a901bfdb4a191b117e8333654b25e354c83fb3d66eeb55516ba090e1643d0d5541bfacebf736c3f1445ad81ef776cb498ea52035f7f70de276b5363dde238d5cc47eda41a7ac1c3510fc3ce04cd111c95cd3c92f9dddcf6fbff4480a71193322c5aa728fee18f1a93d193e4e0c235f15e92b812cb97c1238ccb51d3fd4179bff6139d4f9098e9750a2da18e958f1bc379fd58df7dfeec898f24128cef48705ef9ca56d974b612467cfda1a7b46bb2b9dc69e34e2ffc8c4fb5f536554e0b7d55cffaddf5987d0c5f1c35acb527621e9671d7fc9d22d3a2f65f1a50b9ab14b0646f4a247a447e9e33cca5fc8f360edc505b5e5cfc6ce08c45fee7ea2a5cb38e645edb9afedf67beed9722added8d35307dafce96b54fa224376f722c3632ebfb25e1db59f646aeefdbf2d3e23f8303241230808fedf6e042e43d2c2f6ba1b535796201d899032d426398c02a97472cf37a071c6aaa7cfc255133a4b4601f2d7cbc7871accb316aeebb81cf766b2607a432518da05a5cda1df1c980811f92a336dff101688dbab8c91ab25d23bec707f7a50a42caea11d55b58d4b4d8e817820764e94d16267227e463ae47c0c1f5e5f638ea406458027b08fc477055e7c24b920e4989e91528f9561b7c00ce8b3f56daea75065d423fa76023ec45eb548758b98b5525c9e2e0f0f0133b9f8220f4ae61a90cdc38a08ac4612b88e67a2b723012995a6e96a5370dad989fbb239eaf69b2abff309985f422c34e619ce33f03e63e9c4f53656090775e955cdbcc41a4da2f5fc8b34516258b718d5a39b20114bf988dd6b88f1fc62f72d61f9cd35a831cc946f720f617ba46b2e2f1e207df67b1d717330b197bb91d348a490426d5cb2e58c505ac6eea3163c9a5756af29be0fa3dc78f715c20ee32a0d63d4dda0847c28e1ba745adf80b25812733be652f5fa592e685977caafe886fa738e440b9614fabb3a37e9324ec7784498999d73de56b74f3e317140f2a3b78d0fa87db6602a1a7100d26e7308bf7308fe3634ff102e00acc145add91a952bb39f009fb847d626c121a601d5dca193cefef6f3ef46dd9d96c0cda584c3482a9124c5675e71b7b882f64b6876cba550fdf3531ab4a46463dca66a0f52477847192775e8d8a3e63be8c8add54397cd0b9f39001feeeac8d83fc4475b6ccb271c348857a9407f49bfc618d9226d8a88fe31c42cef2d94add612f083108d3dc4e41f91e15d4d2522cca5bd87e093f4e83e7ab28bc5cc83cdcf84291eb3a150a2780fd9cbcd2b94a0dc17e92cabc44cca3c6e1366d11acbb513eda0539ae2375c8c7568dce0af63a1855565724c78870120fb3d069f884d45dd2a5eceb511d9425e26ce429311d14f2ff455f440c415b0363d1d6aa00485d67a3a5e86be0ddc53596b29f7903970abbc3c1317418b423ac4037eb8199b90502698afa65276fad12dffafb2e896345ca8a091b2680ae0f7a11c66aac4bbfb6503f8e10bfeee4a55d5d820e257fcea8d30a958f5969e19d4943bad7a914b4e29db467462a2eb848d3a531e8781d6c735cfa118d75ec91fa58365f43e39a7e679dcf9e1eb247acaf2aa910b8f1cad05af8cbad46b72995c2ca69ff2ac23bae5613a4b3f70cb82ca402ea522eb32d09da62a85a7793afeecd75a6d532bd4219ced7d2c3fc87de03e6330555fb35014fd1563bdd0529a6c54f8d74c1ed0bf631a22a51069addf1adb7f4beec2a8875e07f307b5adccd1309f113e1c2a6532959ce3f55367a7a90a0c7b23071561baf6d4aeb8f2cb095b8cee1a8f46b20072241904e8fdb30a419389a357e84b24b322ddb3422f56acd3bbc2602b4c954436500fb2cbe243aad0999e776aaa58806eeb1e15042d6ab54c963489e8ea243c1fa5aadc40ffc422ee32f57754041ee3c657682a1688ae033a5fa98ebb0b401295f660327934c832c09d3705a661527517a597b9724d365ae6afd4e8506e003d368ce1d2a9fc71d6d7b93d2ce2d260121322f68a123d17783aad72b57c004ffd1445d3901bb2bb54128b7bc71731fb5e5b3fd4a779946b3ea883394d5fb54ea6f835e9dd4b580d074e3b8ce183cf39294e52ec9ff38de1e6207f5c9df47e08d145114a77154f78c7771f6dcafca54ffb26fd17e76048e5581081ddeb917771e7c3f453c641c588deb762fccb26142f1d4e2bee195c492c02be6ee39818c54dc58459d1cf92d204a36b21ae0ecbea6544614a8105eca1f01eca240847effea821a4bc4ce63d70e9fcbee6f496bbc9a76f4bbbcf7a36c28e94831b107f690a50fd90afc02b6e7039ba698a69a8d75433d917ac6c8108ae3ee701308990a19d5f99dec5f8d44a1f17e585af963ef4aa35a12149f370e380a304f65cd83dceac26f74a8416dd25f558aa1e5de2b44e1a94c22e2413bd55aae96ae5c2a29b1bdb1074f4b49cbe8c16ec0ecf01e13c62f19fb79dd514b99a8ce4ee4db28a15c97d9dd3eda3fecb85bdd12e2f9b70a98b2db9c01bbc62d8a78b1163b3dc57b110da4f0f626ef812233e160a5f8615421bbd4efa4ca5920168abb3719a6509f945e3c637dc8149ff0f613efed9457b3c4e0fdea3f7765f5a76de8b4a7a8433a74836cd35c95610c3279aa494004b2f32243d32402bd95de8ad97ef911e879eb5c21942b7183bad1ade0f545f5af045cd77e9df9aaf3415e2834575bdc756886d0a4ffbd57c5959df24716f494e3a0e9752366a2bf9f4d46cfe88e92e96d7f86b94020ec96fca95f863932f0238354fde84d8e403664e54073c4da253ff0a8850d43cb55a0570548671d97538b56a6aa2e26e00e2a4521fcc9f5ae4fb9fd243be83162a0051320cd34e64dea2ad789a869f7bf150fb74d6e1d6a8e7dd20cf2f7b6e130c00381fce75219f0062844737975ea7c8c052071120865f99078347b83565c3fafb0530e11d9d0177ef11b7fdad87ca55c27ba334b4bcc7352d8236f105dc215376fb7ae6cb7e1b39650f9f51d7f0bbba4ddfa4279c44cd27f89697363d713702aa42163e1fa9ac6237e36564870f5a40fce323e8ca50f7c9f7227fcd53bd36f25c0a048c0a0924af43b6e34b360e439d818487c1f0bfacce0cf2d2e456c560f8d29d23b427f76e8a2bdb7ff79760d987a84ba0a002a84d966f227b0b6f5e1e7101b9eb872af29e807762e38eb7a351b7031590c528eee36cf477faa413c949cc26447adc819bf85e807c6eb11cf379a6c5407dff2e4f27617aafcb1e0ce33119a91200d59fbd59c59e510ad598a4c46e31700d4946324ef4b0960da280116f3f22ff35eddc2cd4bb9a20395c49a606d32cbf341709932a81d911d49f01365b7d3f6e4f6e4889bd6d0b7344304c9e3a4a84d9c85e18e7810ae8ffd5215d24f05edf9298213feb6e719ccafbe269d5292bb66ba19cdaa0beb370f2601c9bb6e5b086801ccb77ccce45bb891e11a0fca9cac9f41747abd4f9d002e89765f6e4c23e47a5452811de8d922675335a081c1a9bd1ac19b55aecd8735bcd106f4631bea92395d1af2a8765f3734070c687c222d697c49795c83dcb12e547c9d11d9cf723fdb1f0a5d1ca3e331d7c6699e9c010beab91c3328fde514f7e47a9b2cc9791ede1667ee1b5488e5d1bd13b2aa0aa4e06d3852558b9cf63565042cf5970d4dc65b77e58d4444658a86e5e53ff34a0d8c4b6b32ee5257d052b07eaeb4f4d4457dc07f4413f1b63d763701806f594625ddf4e98b30b51cc0753f824713b75dfb8e031e5db992e47ebc5f81d21dc1e971a4c3f77ebaab10a5f9778f22d9c7facc4e8c336fe826b78f613ce9739a38d255b0fb5a035cace6f9d0604a020a66e56bf211a024aac25578dba7b31fa99e7754400c35fa46f640ada9065409601a0144e4d3ede375142bec39d74b25ff2ffd5a957612a51a89800fd1d34d01c8d78aac8716e8432c0bd0374523e2eada35a73d5ba9372b5d8e0571949c1fe152a1ee606a36983ebf16908fac36fe11478aad0eaa0c896f187c05294a7146a7ec0e5172d3dd0568dbf52a9cb7a9028a220b7efa2fb9bcf887a47c96dc8baa476056559bb00d5396480a029333ccc532484ece8e37579ef26762c336bf515828e4bd2fef2aea9f98aa6a073b575bce10dd3212d8d37ced469da180ec010a97894a5859c5c79f74db3877c97e37d19a0db084576f03d987a1378275439ca03443926c7dfd1c5c7bfcb03eba2ae4a1a6b22c6a0828bf785b2bd1fc823633844dba1bed219c49323a5d7c86d2b196a74f120babf50d2761814578c1b6390e9e3bbf4ab2f7dcceb7ab89f108b8fc2fdaa1bdf3b2a9f5093cb9f03f9e2a4c9bedfef922b9ef6705de64c8fe0c37af138247ed39bd4b3b8c9acf1dfa4f2c34eba49d105faa692ceb058504842dacde92b7524d41a62874cb84e77ee72abea4b7804a4d32eacae98ebabe5fc7385cdfd467f4fd1ec39d00a23db37b97df80609a7bed5330642965dfa6b546cb0d54ab28ef3a81a837746d63d68cbc2024e8404c3fa7ce970276811c06691b80748c7066e8a8ab4f14dae7848835c8db44ef7cf4c83d5c2ec4536779ff05b25eeb594426376495dbaa5751c5d1d75a484ffb41ff10add9159dca0748a27669fb0fd2aa8ae76dc7aa19e765fdc33d0b50c6281bcb0ff088156add749c38988f7a121de77254b57837c2d2b9f0857a22392b3984667a54f64bdcc15c504c52aa544c14e7c5e88a0d1188ceeef00ea05e5f1ebfce9cbefb5d61944f4d81f4d20d4b2333e7499313b46a96b75ce6179701b974cc5f1555b7e2b49c9decbb181f640bb9a02940ab47e31718ea19eeb0bd7f2b5e6e6a139ad40c8356b5636e5c94cb4dc3674be4cc726e66971ee01da698c307cb86a7a868fc487807ec588d91320f7447bc524b01f253db479c57f07400e72fe7fb758aa3320dc9eca97feef64fb95ff6ce4026f395faa5bff7b6550c4b663ac02a1691104ccbdf8dbd10913adc2093b6d526e4f6997842dd269a5323b745d7eaa2fdc58f51e187c0e8496946d8146f0b9d09e6bc9a6aabffc58d36d3c689646b755ffd2ee3f2fd454f2a099944d16a0a294fd59d6e17dc3f48fcf1be371badca0a02cda8e956734a79eca67d39df81d37879554ba660afb2f1f5a205d644e9655cb364bbef963fad235d903699c4c5278859e6ff4e49e2aee7e760cb3b8d01e629a3a0f26e50285e7f2480d6d5051a084bc35f1d22ea24871d8000b5013d6af5ed5158c1e96f500447e5ff8f8d3e01500723291abc78375e6399b363239c568622ecf94b05e2c139e0445c85f102fd7b2d1cbbeb536bf098cabafdd3ea01ce365d7474f78e084c1133d8923cdd6ec49447879911bd7a9f4dd03f5168bceb86f2d408fdf51d7dcc772d3d061d061ad1fbc405db81a1d2e673bcc629946755591ea16faca44427c787ec8bfd1d969906fb55509ada99a7a7ada7dbfae632f2f1832618c63db10a38765b67dafd2965298264e772c0ec52c623600bbe20b735f42fb303bbe4489bd49b4a3ba4dca3405a83b594862b8f55b39a5ed8284be17eded087745dfc1365836927d401e42d070ccdc2db084e509883e6eebd1aa877f5bc28c00f44957fd7e725e41724be0e5c23755b54c4b53285c4809d94d09ce995a9cba8fc0eaed61c94dac00f3bc0dd9cdda6315ac547126297ed5efde2d24fe55418bbed0c15a72325802e7b784530807719765f80693f38fcb63f39524b947ceea868976d3c248125e9e99ebbabd0545378d48b56bb7ccfc9c31dd3ea383c4b95ec6e6f0cffa0db59318975e94fb0f70fd1ea7f2451b741d92efc4cd4d3c79fdd25a47656becaee611eff59573d82cde8acedc0b2b71f6e162454eb1274383b6cdccad3313e21fc1612091ca7423c30357dd0a213f810ecf2af2cfa9b78ed55e8eaa9dc5143ce73b71ba54116efdf93b5fef124df04d6f1672b200de9a4decef2067d6549ade26928e1c7cc465e42572a389f98d485fdb9ef677e1d86a65b3f97b06b5045e9cbfec50f3c0f26648ffd587bbd8d5e21daa30110ca700e9d16821fa4a894da7e2a37da7e9719ca4c8897cd32c5b599a35c755e57a382b2214e533942349d2fc193e6f95b3c515943d5ab41c8d62aa6336dc6de3ce366acbb7b02d2288d9f0c87ee153d2ae1430e79c891e9f948c5a5c566d0d32c1ec1656c8b7efe2b1d3085c477165727d96fb9aafd736443f932915e20023d76a2f4dad171d87ef1f14f4358d4d525c1080a7faf04360b05dc7489f83d29ab0e435d7e063fd3089b195c5a0e290f801578a4c82a5feb9ec745780117044a3db7dc797d15d07d77b90b492edc427f2de4cd39c99ad2cff00bc6e7842ca5a5c84c6a521984be025979e72630d9b3dc7f1195d4526233ee90c2fb208239d75992fd9ea1cd371df518ea0b7603954154efd171947529cb2ed55fdd0979f6b39b0aada945a9b65e09f2da8d6cc8f5aa55e66ba03c9f8cdb4c881e104fcac8d7a0a8b929429480110540ff885ff8de48abbdf157d50214c16d04e076788ae7dfdb252a40b7b3b0626dcb855e703f03864274796116cfffb4b0ace073c58d6b4b5fd89967d58e6b633fe5578caa4e28f676f6f654a33cd019fe96c499ec21a93034587fa904b7a9407e55042209acb6cc79a15564403c352d6c9666c676b9d8591fdde1b9f277d1b704805e3846773744adc7b771aeb616a09b833d88bebe2fd4762da471b514a05d254d143db09f8e884cc7d335ee293012b675cd28b0b38ea92f49f36503893b2dce8e7e228b2c955f91c0c6071736b5f825097f62b2525fbc16082cdc8ccf82875c30b94c37fa413355281bde332de64a17d7968be7015281443c0894ea16137c3bdcc21e2e4edcd40441f3294eec0f9872c44db15c6a34d248eebd6a64ac81a4a4c43960641658bff53215c5f849e68a5b556e3664f6d2681e7d31c938fbb648bdf080ac6d07817a0423a86bed7a8fefd53a67da6dad30dd9e7cb8b9f6c9004e86238e365794721ae7e78f43bb512bbb49ab4dd0bee0984bbf0b337945306185ecc703d21bf2d3f7b1ae6130fcdd4f7e477e0874082fa65cf4ac6380daae3fb59059c5dea65fca1ca1d0ebe4115eb22c358bd26292419e843a92d4331da31dc1b632156f1c6ccca8ba8e4a26c98dd6203e33fe4527aa588ae832f3b3935376543b46d3933435816bcf9076b78081fa7928dce76a3952ef428343e325f78cb7f785b14b477450ea76cbc8121d4276dd4ce219585e9a1893d97f1d89f135d76fbfa18429efd11fb687455ae9ade732f12adfaf4ea93a140e9862a417c5618ccc3af3fd5a6317408c7a646394fd4166a8a15f7c375bc1ab69452c9c0b174a092cfc83f22fe48ce5821cdf12960f1d3d33b61afa0fab7c5f62c43655670ca12b900c5032ac13d0edc1b306bcbce81ce432d63ff549818c5f940e5321a41cf45fc3dcb0cc5d92a829cb2697d13271e5ad4afd7458e10bee2a7ad223ea7b74d321cc92dbf13352ef2a51fa7cf37da69a6bcda564f605439cff9164bfbf03975ebfbc4ea503f967e7feec444f4e0de5b6c720a905ad36a3363bd69085803d4a3e30d08fdf5abe9fd42d6a09d83fee2b063042c90ad21285263a2a85f61a68c53cf1bff687e60fe74677ebab50f4646fbd942cb5865465a398b03102c2ff634299a33c7b5c249b27e989a351067e9bb464296537ce1459058fedc167816df2f3d6227f298285d1cbe477cf1bf1ff466bda95fc90f8248220aef89781460866b84cd8bb9fc13607f8dd63804ae15473c028b8454d10011ad8f19d78e5ee32f0f5bcfd0ba8f8dd8575f288149af3ec0ca8638c9d443218d604b64d3511671487bd930e65ffb6c8cc703c9b9c0d2fd10ca8a1373331c1659672af3c7b745133901122bc96138322a6b49cf23dadcbbaf7323017145d0f910bab7f313a2cc3ebc37b3870cbe21f631f29d89f96cf43358aa19aa3487f9203770224384bc0609d8751b8f03ae4097950029fca45da164d2929772ed1e28c6cfa1658e41f659c33e42aad47f6b67e4f1f2e45599c0f3306c41fb47d46bfb4477dfdc8b37d0d5234821d45d5f1f30596b24218493f6897ad1ab1fdde503641aa72433253e7abc3063d79818629c55602c3fc51d14f0c1ee8d61687d2a7ccd615cd3dfcf7d54a89b1aba40bc29ba9d0700693ca71f8dbdc31adf3981329ec8c1015091249c6032a3eafd95428ad3eaa4ef986858e1e28b8b68a569caf053ad9432b3194c7fbe4f8d9fe48b1246548fb1d0779f61f94195174bfcb13dbf1bce7525f6997b38670e7b56a092d4b745d1a08834d8ea5b41d6ecdf4bae94a8dff2a0a61800c8f229c6a56ec0781f0337f1e23e88c1b0ff5334870a23f75862fa38a373f3e257c79625f99a6cb94356104553745e655192815e4fc1c39b1b683a992910681e9116f8247e566069a9ecb3e3b3fd34ec0c40ad7beecff122a22c1ed045b6e478ffa336a07eadddbf8c315a9491c2d02e0aa6791cbe6d040127793cd2a0efe3f7567655a0a1dbdfe05f08d751a208194fcd7cad4b30c8620347718ab7a66467e282c91faf44dd47a395227cf253622187d5aa52ea11122e562abf0515ccf9f1d3df5b8c8d3dfe890b9d6a71b0ab093b6e9fd9cd9064cce142e97b506232a93109a087fc62790ae2b09a0a162566d2a7eab78cb12e66cf0d1eae1afe71347f279a72b4a063f4d7b757f15f6f73b96dc713fb72264786c8d84113e322c4786d993402dd65c1e5c0386794be8d60a965c7a1089e08aa9a9cff31078d459447444d64c9c6b77313af357651ea73aa1b62fdf68237e5c5a1466ef6bd4fa7a6ef0488c646a20b930cd52c54aafe24037471ea54f7d8ad78957299ae845a4bd4a370ba6d039d1c659197781a03de1996b7aed8dd8333547fde3acc2a5d4fd830f404becc5429f46f886aa406267b3601164b8ead188fe3efd3493c1083b0fcb16da4bdc6d0a876e27604471b31a037ff0eef312b74c1546000d33cbe530b7403db0e1ddc4525bc11f0ecef1a515156e0cb1632fdf76458913255bdde9bf891063d07ad491c7b2b2466c6c1a4b03ff44348fd2653cf1329e9868fe593cd659ac5f7da41fa1df7f933ba7d3425921017f6516e456cac7dff0ea96ea185336a1b7bdc3fa39859ecdfc832923a0641192c4f3d811923ab12f114f9aaf163282647b9560d185aa65a6703e81d683eab7e160de834744d81bb3ff9496f4c4fa8e8f6df5456879341f04cad5b64c80a96c48282d66e0064aaffa94e9a3765fccca570f82c28574f1a4032c627a5d619afe3272f593deb70b727f9096ea49bcac4b1202bce7286ad206fdc4b7a0e09fc37a6808ee2b68427a7429581c9af16690c0085faa717fb50076956c35de61a56d2b7d760c2ae466268467166f16ff4737a215d13a6fb73040d82440bc039aa3ac5a675afea8bcc54144d1bbd98eccef1fa01f5b09fc75f57a6320d4e25438c12b3f8183462626b9c2e228d6890a660a29359a9d6fdce5ec00fe3cdac4b6b43aa2929bbac1d667614f774223de8701cc0509159306d65f34c30dd184a21da64708df012ffbf266bb3ea75546b26d7a552c24a101257a5fdaa3e7a1a6e42c831646e0d80ddbda6a30f9788181237196d17c6688c1f4ba3438578a6cfdbb9ded0c935c4dc3d581a38c37f8c47f0f06f372d1c1720a29d6a43495cf047885a13c3a87811de4ee98e7440f6dd03d4eb98da4d29b61c6cce3d01059e16d4570e336595f0e51ced8ca39a00c6f17cb1f2e8953853b55a001f84706375889dec763a15bd236f8b5dafc581e09ad3e9a00431898fa75ac325f74cc60991de533c23e014efc653086eeb32776f8594135df7ab3313cb009eed255f1d88fa056a6b63ac812a96ab484459d93005d92cad182150ffc78fba23f17dfeaffc2dfa1d5c33131f9ad3357279c8f1048773fbdf3fdae9badb3166c9b6a606f20595727e6221b71253cfeff937c45616fabc096b1ece0703a5264feb788541d95d7e7cf503145ee7d50893afb88351d4e9ab9c9b524df9775c418ef707ccd98cc9edf77258050396288d5cd89c881a109317ac8be8c0578252156f2e9c7fbaecd5c19d1757f67837a64515ed56c96bec66a2255929fbbf5de2ef267e45b8dc7b3c121ed2a9a579ba523f3cd43eefaa63ebc4f14a4bd193ce9a762f40f7cfb0a99a53ec433ce3154e0824116ac84e63c9602fc2868fe0e90cac2454f0407d898907d3ccf18f2bf828de15bf95131140ef384929fcc0f183ba5f811362f824aee1447a2743f3e66e1e3af15e5cf0f7b64b904266cd5316ccb11ac8940ffac7036a77f3956b9d29973c8a3a380438337fd7559522f11762a6d2d87ed5c1a565943af9f7f7b99af3adfcc2190eadf83cf2331f35363ce8b952ab124427f06d8edb0844ad30f0997ed989a946436a15f81b7674782fa56d83fd7c17ee2c27f1b068a3d109b8ae7fd2c0fc831dbfe586f2edf76e4233610a207d3756e94a1ac267a87257c19a36737acc3580870280fe0c814a6b68a6fe43e5faa28de52d3b2d07dc5fe10261943a81864949739476194154ffb3d3d1fa1bbdc1937bd6768e770c3eff67a08ff62ff6c7eba3081ab2531f4ecf8bae9bb1b6e6bba85eb7a2bcf0078c919071233050f05d486949b35f1cef5a2c92a4f79785d2f2763bccc92aebac9314876f324eebbf0242837d194dc135eeb912696f94d33fa880bd9cf8193e706f58463226e6133ced58a29a6f0ae0d3295a2e88c9127e436a7c29721182ffae981e33408227b6beebed0be851ffd2e03b2c24df752a678257e98beae2d18dd05c9926c64753ff4d0555e005c0387cec082a8144dae26697333ea71575e5ff023be9d33036968894d703c8fdbbd31318103e3a6fd73fa6786a243b3b047c564c9676947835faa39f5b59d0ab552a4843393d86bd1f1f7dd523ff6e33eb7b80a843de0cc29ed5061b84973f2ee5bc399c0a92ca30926566e39dbef4bba42c2a2bdddb96e3dd93c3d058cb1e2e2d75ea2f37f6ff7c7b4a594533e466a7d0bc9e4b064282c426feeb994afb9cac083ee69099eae0d80a0ef9bba950a9288d1ecd80e6cd2321fa611e59dca4384bc52880c881def882787f1066e838e87216e84b7b5b3bd7d243afe6d900173d3d93df522322091ce78c539d6a6e00a611bfcfc17274c5fde8718f46ae726f3462e0ee9e5c3bd6887f2a52659d3c5aaf760f0d5991a58954f9664fb571d7e77b8fcb5fcfee9ecb0c3ec529c71416ad8ed189d612f2d6872c504138df4a093a094e1cd77d800747a6e8ff8629097c933eb5c69134c66d0fb52d5fa2bee75be2e0dfe3512865bf12d8a3967c165f830aa5775edac2192e872a92c9e795e5397ae22d5a352bfed131c67769f5a083b25cc3ee0e9be8bf059e938ad52e80b07b62f4207633f68f5bc0a4e1f06e3d94be4331eaf61d357bad0eaac6a9071ec915ebe22973a32386dc19e897835aa8970352e416116142fa2e7ce55ff0ff8c0068540161de9b48ab27408d550f0ae2f7ea65163f2df7478c1253535daedf0abf0de41b89a82d10711b852a4e6f780f808c5d1a9294e3e0008750232a6a3d348beaabe857f4bb8a2d02ee548a0edd5931ddc2f52b2b07412b96bd96136be267d89dbef56503d80b214f124d4bf4b62ce7672a4fa4dfcf1cf874eba9f72964e950f1dd6db1e3d6db2e15021d86e5f199095b7aa9dc99264f9b007ccb7bb35187ccf71e5e6a3eaf592307a3bb5f233b50c40a51011ff0a133e933ed00ac105a5206cd912581b512611c58d6461428c9f0725ea0fec57bd7faf751e589026b4552e6a41364e844b8345e19c422d891eb647b7f446dc3be82e32467a225e4a508fb5e316891bd38bb348e76d5261e22aa96d526c1a2cd05c287ed34e11fd823d5aa82e0e537670bcfab33c89108863d497722b45b8399cebc4e9980e3910417aad69c34ac3a9cc849cec9fe1fe7b991682eee0cfdb65bc75369bae6b29c96796fe6079d0e37722772cbb68542460243712421cf8ee1837f72ebc4ba9e29dea007990e16e400650aae2119a7659ca9b759d811bad5541d5d32b7c83fbcb9fc74aaa06d508048ded694986cdfe29f4cb6ad17b0aeec69bd702c9d32ea7b4e1a9f4ed1765a7b326f0ece796dcddfcd0439993b2c73677b28314c06404ee8e1d8fc9008464ac576f74e96b3d5d831c7d44c1c46c73b00049cee3e5b83684b9a42775e1e6d71add54fb14f2982beb39402e9393a9400da466e6a138dc72cf38ef726c0f112cac4ab9baa5e41ae7c9f88bdf39925fd8cd3fc9bab56ff3c030f99342132edec3e6fabfdc6a860db514278f91813b3a12dc61611c646b7d16c772b21d81b72e7b19729c48e9d4935875179a4c1f2356c78066372a671c748ff056f11a06da9a544cade31700bd5e2049aa3aadff2fcc49a702ac0e4b1db2fa72a268aa462382d988db4f005ccd1229e92b8ae3f9b024778d2495f67c3277bc813afb2411963ced67001f6f0920b558d58ee9a65e0b0731ae58813eb3f49f51ef7312921ff93cda4da3c7efe29e800aebaedbefb6a3c2889e29de6beebc0c326a73f29802e817875f1de640b2d1dcfccf224a0ebc6594a988e500e70bf5b6e68499a93b4df74a6f2baea97fb94036e216e76827c44f6821d4de2a6937efeb49e26e34a51cc2c26f72c7f74052c10bbfa8e2de47012c0e849a375c91929362e6f496f991403da14bc57ef46738122f742ed37462fa558ce1cf7f100a3c61e0eae3a7e9ff18bec440fd2e6eeac83aa85088f4cf392a7de9834ba54bcd76cd626351e96f43770da233d5bee59f0ba5050cd2658bc4a3ec7cb1c01d40cfb38d7a46d56e538f20504781bd9e0d2d9694d83699bd0ae94cb8b34e13e491c5c3152ff139fab7539a497a549445136deba0b42a7f99171f861cbbc22488c20c10f51e6fa16a8edab4ad656cf6136f6030fefae99f1caaf02ab7036249de6bc517e50f960931378918831fc23fa1dec0b66119a50684522ce132ed0f3405cf31302c22a7f97b8c658dff061f7e42504104248d05cd5062b1cd9c0b872a98e3a89b6ceb3def05942aa271b04807112c3f2695e15d58ef81c1d4b773f325dd9d0d472cf7d8ed0445537ec1e9062ddf3e2b2b774292aad1d4c3d8e4ebc09d12d363c249e81f63120b32b42e6a2f6cd507e8cea7e4adaec9737aaaf32d6adef07ad59f334bec66f4bd6170c6a4a7177c95378c8592281648ee30d348d4203dcb79424c96678d88987c7f9576be158255c0d21b8c6906e997fc74172bbc6a86af6f01dc9ce99ef8a559f70bec6a318804acdc5dd3ae6b78bf8a2f20db6927c75ce3b4aee3e17f7438c126042946d312997efb4615c4cdccb8dfd3e9788ebc683b948f4c744f228b3d33eab3eb5bb92b8cdd49fa849c37dd40f265242536d3acd00647d08d9d7c3b97e5a3829237ff86ae70e75a3f0dda806609d8b1dad27b06eee71c2c3ec21ef773896eb7247bc9fd63e3c49bb065a58b1dfc34897a4a5e2c45a65a8db61ae7afb3b7cafd5f1239925cabdcd4033a13dc52efb9b89d5af6b4717e4ef039038c139414411cdc4af5ba77bcb645e88cab4bdc9508a451fc52f9dad589f5c2101f6aa250e87070961e5f186be9bf74c39c5ee640eae355de8838ff9c941bedcbbb847eda89bd761ed7306b85f92688be6fde7961ae4bbadb011b0b4c9cef5e1561f0783084e5e7337b67354b8c51905d1879742289888f9745c5d23dc0e5ed845bf9e731ca0fc8787c318eaeef023f92566586aa5f7628462bd822bfa68668356ec3b031a7cef657a9b160f94618d7aecd99ffacf5ad2d3f9fc11c2356674f8a459729fb6a453eee4bb9b9676e98ba900625c7f6e70e9c41bbe328688c65b28fd77a16c545f11ff84b40f9cf2770d83551717fad34112865f44b5641adaa3f5a1b705106824a5ebbedb495e1ac9f67b1bb9957c90e6f4ffa9833c3f881e2712cfcbd9c11a9c406b7b69c88211412c60a2cd5cb776e88d5642f2d391b97765a78c800d5905342f351c7a27395522697d4cd8312a6f5c818eeedfdeb67ebcc9ecd995fd2d697a0963a1f54a4b4330f20c88ae76121d750c27afcc9c8138984791f18ad36e90a528d935058cc873bbcfcdeb7de34a706df3a3740cbc9175b7fa09c71d679f47295935b6eb2d38165969a3b7df276ccc0e87fdf1477a05599f92cb4a5aa849ff7dfdfcfacd2bd94a3e14a4bbda0ba9a5db2d1f67416de8d4c8df37d1a820f39d62c983130c6655fd390de5f3f0c9276aa0a3375083c89aaa7de83c21e70c72a95f88b1d34cf6710fbe04cfbcb3ca861e213e9af58cad064a9fd01b676b5be0e00c712c751e1fcb630aa22c9846c895b9f5042643cfa156edb50bd2cfdce63d49c24c0d26e0dcb490f70a2a5f2bf2b720405e2a883bd96911cd3a448a4cb6645179a6fd3a7c6c839bcf38fe938f016ccf58814f6b94aa663c73dade51da6fd8a8e7996185b287b3f9b023eb398030665e69db89c348f9ffa4230323207a17bbbf745c71258ed3fb4d8ba5b3a7a42d11858293ce804058bbda1a5eb72c076a3437e69be9317419c310bafffac36b4307170da4814a5a0f184c4fc998e4ff39effca5e47949c0669a1e3991fd0b24b89af4c58fa11c2d26664ad3b3c4d91535ede22147cb6f5b00968dd7855d165b63db9f8f009980b2962798b9a50cc2173603d8287f875b4e7f69f3bd2bf3b26d4abe57f247a3e71b20daaa818f5fa731300cc3d681f1a00f5b5739922b955678ed61c21b8211cf5e2bad3c89181bc0d159257280ba2152f01feaf7dd63233af08d740a463c247cd3dacecf427d7d595e8aaf3e44f52e21231accb060371eb8ae1a011c4edcc76605c555f2048357f80512e43737432f036846b27697cd6ad949cee880a423e2aae531b1dfa3d2b8e79d5e3a9b07e967181fc726c5b1e250e1768662d4f125543bd8e930fe0e6f6947ca261cf2d52a56e866ea3479e8ec298efa4d989de4e174b5894c0f59b56179ee78e9589c1dc0034e117fce02905181b50210400a1b73167744dac3b04b1e2299f2673757022038f23f47348d17b036188cde13b510d9608b0ea984dbea4587ff59e0ce68398aa00d27c290d089c1d3ea1d566bdf77a656e2761d11c42101bb9e15d980952973336022306269289ec9224b4b97ad6c5f8f8820bc1c0513645576a79b4b7eae9231d443573d9a6282695bd9ecc06ecac06c9943d7f0590597bbaf680189f97b1e1df40e09e099230def3f627fa6f71270b621a4416ab93707abf2311cf0f7b77e4ef24b4b4a0720015fead997770bcb1f29205c66b024d8f2eb80588cf99d84c312e95f8c4532448ab712b79ca92ac356c0cf7b4e0bfb3dc58f2b061f93c9d5a3fd56f9e674e9d3eab2615b1b41ba0a097f590fe9ac581b73884a469a541774fd5033ba4457a508ee7efb6c7894b02cc5fc7d02b77271ded0359b330833713533b74b0b55e4674ef552e5564dfadc848268cefbbfda300b51eb99ff4250f71d88b9c4a9623f12c81ca5645854b2961261d5cec8c3cb010c15a5e2b4242b967281a69d17e197131300c74456007922ee2c393c0a8a421a26bd05e67ed460c0042052756ebedf91b2b0a79a5cd6122cff54ad953a17d61e36108141cd3b73818c3478ae0521fc783e5d4ad212db601cf9a4172e74614d6b5973d7c43108170e936d6640f87b344a17f99ad34586138783e154988325c919cc4160da9afa2a4a11ea42c9d1e0ef168e482c2b1f93dc3680418d4c20341fcf01f12a4742ca6086abce4996eeebca9b398a420591783ffed6f2089343e2702a747571dd12015065b6f56414f1dfbab625572b85b367a70c37f15409a550cf1df78a14e47f4a0960d90cf42a857c0ba1bb57229bcfd48faa1b129a909682f3c7ce232a6d1c31f6b43a06850054104f3ae0a546f75afd772cf82c0a72db7676b6972e85d46dbba7889a3a261bf55e2ea70c956bc4a27f8c7db41617f5e830e9748afae7eda936e483e2e027b35b23103739127910bbc553c9774a431494d000226285d084b7dcfa923a7bf72a2133a21329761a97aa4e879bc91829013b84ce31f5ff5dc55e10be0185bbcae9f0852b9dce4b32140b7002721c056f8690c46bf73794ddff3a4409239642734ca60d704cd071d299f428f1d45b1cd97d91bead9f24912575e57f9fc898b40dfa9f6298b138693a88339d13e15e26c51dbb5e9f691f907d6ea0986f1974055c9d22739d619a5679d182cd49d617cd4ad143bde275301332f4e5a632b1709f544f393db4566f4bc3cf657b9dcd1f709424104945848a51247fd9a8ff598362f4f7ba200b9092348132dce76f3d4899fe03715990e6de987074053bd9b3dd4c283496818631412b9da12cd7e8289d2a2230f2a6b95cd064c5f4c3d44a0b0133afceb3bf3bea8d08bde30bf60df4354f904ad4511ecda2aa527445591c9a6a647334df41f6e6df7b1db836cc858d635f16f092e0ac9b5b8511e9892c5ab180987fb5ce4be98a6a6f32fcb3003402bd989aa33e8da7725ccf275bdddb2f15346b9466451d62182fe97983f0cd20869e5ef4a37da3d6a394c6d91c3bf2f17a1948ded1fde90faec07666532f288229fd2fb2215c9d0d7d7cde28eb2884b332c3c027adc75e47b483f4d2f49995aedc6b57e27ba3c642e8d67b6f65f8d6bc2313291c2071391c872c4bdc791e0ce2c75681065230a11dca4c73877a13b85bd794a45f374134783c5e0b8d3561bd4283863f646bac51d79ad6c968c2deff220015166163d7d3976a8a66ca376b76475e18b4be0b604430134550ea73bfb01dd45b3e0bfff20f5fffb6a0abecd1b2e6dae9b72bb984e303b71b87aec4ad9d5ea44691428df5da196eaeada14066ff80cd3dcef4bd2cab47456df927c712271d2556a30f76b391ebc80edbcf988991d534d57fef9d0914591601015fd341f0392302094a875c4a73453d44f8c41b3f071150b4d1dfaba71f70dec91ceedd2501cff3d725e42e40b8377fff0e584e94ff02ebb22a95a4858aaa506876be52d55e4f4490b084c625a45f22eb8ac3b43303bc6352e12eb1f658576ac6787d250b620fc37ae4190dc8fe0f811f8deb43c58e2280c0dce8a2152cd4128e311222eaae4e49d228b89496d5b93ac1783adc0a35745c3f463ed521dd344240217b206c6fe66f7fcbb73ae1c35b285133584076b1894f1df47f5ae5e4b80a20900175ab3abf02f737d4a0466da07079b89af4fc997b9f4a1267c858c839fb4098ba14d784878636683fabfecf5431cd6db253b45521f9a323a00f54b7bea916035c42cecc9eaa30bad94b5f86e53e43745d860e35cde6ef474cff22f2df8968c29af284b5b3329d7aa551c68b875566c31c2fd21d771e4e6a943e2268578abae8b275c56a60588176aeef4780c2ef038cf43d40626823f29b04aeb52b0e0d79112ac81a60668277e8a80624ebf136f9a307b221c39446dd7ae203041f5e37240494aab7190dd37f90b21608f20350659aaa9273d520aa1e21372e99fe0ffe221d80cbf10f2f15bb7b31d8fb243032a5fec1395fddfa078e60167ec6cc5f817359a7da41100d2fdaa50df0f2ae3bcf2536a662441a881c56c91ccb3d89c698bfa3992c2039d29413dae6597d9349755ce6dc705d784932e8eb97c5fac70e6c0cfde0571aa0256653a69ee05e167791910bcff3d596e1e9835b8343836f257b4c429c4d59f7d972e0abb481c7caa3e57c2038976ab8870813108d44874978c6a059adde78f55ff8d4010cb12648c6a06e56266623dd29bc547a14fda26c6678750f063eb048f42f9d9b9c2819e8c6ed0887dcdc983edf85e1ede4f0cd5d08718cf407e25b1d457f37bc77b18edc5b5cab3e30579b0e91c9b218a32681fd3985e1f921e679cad3814b0182b28c66a2c641d47034e4a38041855d462e0010c99b734a33a7d1d6331224c611fa69382743f143b77a99bc700b38cc77b72e29ee3929f0c65ea51843941418389ca97252254b8925ebac41a739e9822a826687d3fbe87ae008a5d777865b2c7f3cdaa8678388caed85b828b756ebb9723db55aa0d800d873b18f8cc0b0d733072ccc570e0fb8dcdb5dab31cf046c6825ba8aea131ec93755ea3be6da7391167d7c7e453786b5a31d355859af7abe9e94958d32fd366cb04b029939adfcf8e4600a836607eca7aaf76d56a48405fa21fde8abf752ccb8f42ed01bf30184599f62285d1faff3c168020d9a7797123408528dfaa5d114006ecdd1764364d63a7e68c72a82c7e4e644399cebac9802b95a68759a2b83932ae45a4838d30c691f2e3fdaba2ea457756f903cc35dff96bad8ec5c1d92faf83a8377059c6aa133aa3471bf680f4faf52eadbd309dd3a55a0bb07d8d69bc9f66f8427304a60e259daa4603ec8fee881d81ef6d134d043d0166aef3a30eb19232e725690ef66f5d969f8ec2a179a685c86be1b61886d0f88b0037a70864f2fa8faa3cde3ae59b697c330bfa7936859b82905296c95616932b370e505cf347d440932bd6dc1e3e55d40c535a93fea41e6eede85a6fb84a40fe9c4a4fa624830c76e05d4d0ceaa918d58f44996250ad8b7e969f24ee4473f0446a68566285f82f7621a020132fed74a6f7ac9fc32d6058dbf01558fa742a1ec69efa4e02d702d00c42002c021c4fa60fe17202403ed104a523666cbcb7157d25f72286b37856558de799d1f30f425b67c98787e387ad62e723707fcd1bd214a5d874be1f16c7190afdd2c21f6057a10f10d58f2d18528ff398ecc904da3e74b7d5bfb595c33e5416884270daa4c2d0ae393d97da82401941b601af35ddebf377a976e2d99b520e6f1314169697f595f280ff8f456503458fbec2aa956eca4c26e9fa0650cecccaa2af8c457a6ec3e2ca9f4fa78a41d5700783554a90a26287433f79c8f68dce2f10206087b269912c5c89cfabc66ef2bf1e1f2164e7734a018a81b92df729ca75b1851f24ef534dcd563d66a84adb7d827bab5f4d5b846853bfcf7a5427da6677b7cbff9ef597f00eaf795b7f2d1d6fbe86cbcd3375baae801444e57c6a4137521d2c6c96f405411a2e60be3e1c19071ad16e0af8b7b2439c197cccbed0289bca1d4d01f741272898d809c5390159fca78dd661ff5deceb466aa4aa39c3b1a94ef57ebdea8db956047c0047a1c645b21ab8664e28a21f491500184b0d42c9caa54e7e488a01d8f4a98e8f22fb74e1d06e94d8c1d9bfbe8f8c5fb03c208a5a48e99e8ef5bb3483917894517fda3cd23e7ed738c38261b8646e5307cbf1bd964d4fb0e07ba9e3ca7ed5b5d3633e78e76c987bac0bfd7fa4c982e5a6e71ee736036fb7afb3dfbd8d7e1f6e484021e1d3498ec2b1366c2a7f7f102e1b9ec4802edb5ac17bc05ef93ecd4ba0556f12f84746330e40143eb24418001dfcbb04d7f55f5052c6741a34ed4bc09f297a9dca5af8aa5c21dcacc23017551f8329a5f05f672b438d4d3f3397bfc968837ddaf56b5f56efcd32d3f826f1dec5ea84c7447acae536ab993df35acb3d502c0db1724003244b3a40069696e8d55b0a15d254675f8d5b8dab007da3c665dacdd864f8054b3f5f7ebc208f41cc23ba8bbc90d0d4a04d2c010a1488c4acb28742cabcc3fff31586e9f25ea886bbf5ced229d2c4d79c89295aef0fb5cf67900278cfb4ec46c7b11bd30caa9db37b915a603f1e6d943ecb874e18760f04ce7639228145911cc69c31610ca54c87375b9fd670ae30b3a1506364cff2b2e16f11ba6f3342acab2d36c922ca5d2245e93529b719fe17ea90c6e1afb3e61c223fe3a9acdd13b4be428e04e4b66b568a1a40b8f644943e787666d096a545d65c82a194f52f23958470c6c3b0ead8a82e9a50377582f803cdc9b4580d69bdeaea1ddc497b36c58e2d1c9329dd2a9319591e7cc2fe5a167406367aff5f8939f46a3d62c141d2ef5e0de8835f942d45fc511fa50bdac7232b752f94f3532d56ccb33e16f174b3bdc6899104d5dc1f2ee18011145b76c1d8e32b80e5e727061baf88e6cdb64728c0e8d5eee64f58f4ec15398e79a9080cc0c1547e595348d3b5d5126feed65ebd5f23de5759dadd2de2cb7defb15472755bb14b16295e19d7761e0d45d1ca0af828a504f7ab74dda5518fa90bfa8efd18535693edb7a37d789e78560e9368e9950be3c3eeb123e936527ffb44716d9aa53d76f5c9dc2e1dcd2e3ddc44c29df74ea0ede7f1ef214bf2bfb5f89facdbeccb122b17f3b08ee955e94c06896a33c8b0bca1aa516d035d0bae3ea788d7e7b1126ee0e039336cbe3dbdb33e26ad5020af079737a1a87a10afee51d79df6b8aa78afcdf44d56456adae4b5c6f4ba8e141eaa09aa3ba6c34c3b069a05464e9c504e39a0ae7a4490410db174eb0bc0a3061027a3406e4ee45945e1d7d9d9307c657d14a04bc68729b5762cdfccdab320d522ddf1ebb022cca655823711180767506dc11d24cfd6a6727cdd03cde23d6a72029f021473f51b5470a5676991588ed4073a748cd53118375dbc1b1cda1bebdbf3bfb8580ff451720d480cc7ffc35d986a58d1b2134c902798b82fa1645f0cd051de872f8130b65bca1041efc47f7f0356d4c77cc03348a56d274771317ef76d9f4b440b9f229d02ce667702a6b6f800eaa79b81a5d572c4a9ea8130b1db63debad19334ac36b35c8ecda2d5a7c429a956688c71f69dd7999a1057ae8c05953f28606d11ade59af974bdcfdc0581f4792716213417c279e50c7f8bc5cfb096d1fbf3e9d896ae582fb4bca2eb0a747246ef090ad4822301699c7a5b217749b5e27732fd94aa73cd30d5f54d0a63e068c04930a7bfbe8cda85fdb7026ecc9b796381158c98811022691387e84782a6807c7989b1dfed1afc97f57a7bbab91df30f2ad0a830737f6863d14c61c7f637144ef0a19af588430240d037b3378548cba3ecda82b463e0b7a6cafd21ef59506d06079291a8b0cd0a3eb4e378cce79213844aa7d1d071e910a89f908b7be4b0b39349c26b5d30e2fa902eeee84e885eaef7c2375696ed4c286824934a9a7ecb82b6d0a95837b183a722b40a32a74ea1e1700c2c04fbb89f8f9834fe68c7e6ddbed4057dc892143c97124c7165f51019deb48d649dd857a579fad1c7d914243138d2e80952d23af5b7dff860b30db0d759c908f39aea5f8af7f1110fab541b110ab13c455d306536af5b500f609a3cf61b56d09f70595b939f9f271c197a3b3e6f0dcf771fba59aa2aca4c6297b78b1c63d1be0a64f7588fb545e721455a15c2cd5df034695ed4a5e39a0828c8a013453fb6f89c738d8109f274c8bd1d1424da20f322d254d63f6f530a5865cda42821e6f916e5c11eeb1378db3349272d813d92a9ab393619b770df13c54bb835236607bfd8d85192dd0983d96847cc483cf6b93b9daeeada8a881c7cfcaae6c532548c001e2cc146a96964367207733e61581385bf360f5137500be98cdd05587ae6fb1b22116ae57ab77a6d56f2f9584847e1c9fb8fa3f3b9a3be8ebd229bb614d50d6e4b84ecc9d835859fa3bfb649c08e228262660af020cf592d6fc47a28cc49375fffc2413a3bcc3ed1257ec54d6f3441d5a2055567e72cce008944a3188aabea11c22b75fca12350d72c711b216c89f52879ba7664d5a898b648f14bd587894dfd4289b329d647eaa64391e78954f40d83d1a1da15d90d56d53b524c05867756176383fcd3af617f372bb66291836c1fed691c1ae16254a0f5eaf01ccf2e420547ccceab6b2cf6569dea9ea4c142b58b779a3f5f45de2760bc4eac586b39a99b3e5c27f6292f76cf1dd6db6d4c8688cc861b491c499ab16e09b8493181418b14461e293ed7474339ed8b2c9d1e286b8c95fe83b89053ac4b6f3a739579f1e773916c5b0fa4e7d4cab4445e9f4df8ccab5f352c619535abe5cd61e268f58deeee54575f84590e20573260a1b575d4dbbf2a05e6d2e60c11a623485cb0be4736b86afd95938860a607482ef927df42ec33dc14639b1d0f596bcd9f8c8854b6a6d1bd6ba3320718712acec3076ef3c54dee4ddc48b8615aedfc27a157f238f372618d4f21223337fe76baea1469bcb936574bc7749fb66dea81bb1cb8a9303d7c59912d63e6ec4752bf9a42c227a33cc525550b6fffed969f9c02e06ea2a8311d91f3bd68cc3c7dc9a9ac0d69cab99b8e804e902ffe5cd59488e054e4ebbca2c4f65437252713ba3d09f9cce57b233365836963024940dc09e22887a1a0b263dfc38490a2df9ebc784eb9ce1254234f6363b67efcaa64df05f46af67d2fe14ee6e7224f156641cfff5da23d28bed62a10682f0bea8a74c8352f1200ef6e5425bfee24508cd028cd9afb93479684bc12b078cfa3e00d16f0e1fd0181c24b2c8cf683a2583790f68a5c9ab5d37f7ef5969cfb2923410797f581296729d91b380cb6507b5a8724e7370b8eaabeabf341b78418edda9a72ca626dbbb0099e6f87117f85bb56efe587c4440f43f4952552ab6290ef3cb1649c4ba831c5ec1b6ddf890b13fd8a9c0217b9234d71756016d1ff43b87505cfac843c56966acd482e13628045f93b83d58651f1e123149ce5afd868aebfe93362be2709a61db4ee395cdd22dedaccb0cdf429c08fdac555b1314210e8b1ea9bdd3d2d07ce719d3df240857601195b38c1d65af65dee16a1a8bba94e4b60ee3a55f6fe164a193b5d91d0656f1d4761b266154bbb4a4ad403d1765f1e586a0f4305851ceed752f4d1e73fea0bc59e8857b3c7316c2796f75b394562b7cb8e834cf5685e31e6c1e0df398c2d854e8dab41a334444dc1ebae650f639cc3238d8a71ae330aac74fa4fd0ea7b8bd9e2a3ee0cd24a2795e4f1fef056206946f00e31c8c236f0e1c3a373143eb8c5bbc929164754963e08c9cc9f6fc0cc750e96a0973af8a003e3d05a57f097aa0d9611875d77d411777f1cd0041ca3b6bc5f004d3e87db08c36d7df7a651c76573582f6ccdf64dde28f2e2a54ed0a50dfa9e7e0a220e91d73dad3c9fb298fe3ef836cac05ce5da1b695f8c3a83d7099baa4d191f8035c3aae4d46bad3a33c3681d593bcdd6e539c6a6a6d8c8ce5fa54a7b1293b31240411c5e8120694c79ca79769b03061e83aee6b98f22081c61bd6785b99feecee90df3b02e92c52e27356f42f091d662febd638f0242ebacb5c152d326da5e8bc244b7ee4efedda75eb12c7e63b66c4c7ec0df33023cec9a3cdec0dec81c453b34f77462c4c95ad081175e313362e530c32db971722e64a3e7576dc443c4a489604be6481d21427327aa277e3157a2bb5544dba402050eebbf6ed4d2ea0350d008b109c4f6a6146e553daddd29fc62f6016873d7245370e29153167c0be9f663b4938dceab0081deda9360e5899cee09cc8aa7b223215deb59361c259557d65824e939a81e0d942523d76b9ee0fa571f1aeca49bda1b6bb61d5bfaa7837326b167ae73dff2d0c965bcbdf97222a0b0084c7f848ed1487754722b559cf2d1491c19614fc3f0da07067138c7e423832a06c274f76e9287847557b03061e233cd19f812bfc609bf87b75d71ec95fbb7acf5ee60893de2757a657e528ea3180e02159d49b96b7c1b82c7cc15370bd78d177fe431747bd7f19af3923cacb59936889a549e3f96689485d332447a321e186c0ea0a45e003b0a857b4c0cfa707cd40f7297cbc26696c256177adf1d540ef8a47d7a2ef261ef6723d56c3a22a64eff6cbc20fbd738de569a77f10ab1489e419492f5c1dcbcac18eeff51b5d176d7225b327c0664550d3da20917757b0d25cd10743947db3f6dc02a481c4ee9976bd9b5e7589fe11bf89d8168b5435e5acc10a3df7cde3ac66da242261bb479bb2c4ab0b2542a14a24d7214867beed3773b5a7657ca43be1b2064f9a83501f3f6b5c12802946f629f7ffbecb7f08cf834b81d9472269f463a0875c16bf7f36ef0bb9161ddcd67240fb7d45f66f996586fd8eb775d7b43e7593d373c30f4c1d06f11d01dae3a3b6a7bc05c430c8f2838383965ec7ce98006101e1325426471ab6775254a82d53459de876fb580d53422a37e85b822344714096c43de006566dca025c2c73f51ca35a940af1796d0005680270a5042f54e70cb77054a13f5444a2a96d36b1a5cbfd518247584bb054bd6cb8446279740cd6030f8bde50af1293d47985a72602389e9cb4fe9e798fcb5e1ffa9388d82d83c4fd1d2f6e1bd58db53536d3965f1aaa16f123e4abc3afedc2a801e07ccec03bf4c98a01251ffe2c50370abd4cf57a981b1413d7e08b6fa9229b56cc4100c4a2e0db98efe883a5b19fd6b6d524445b6e465ba7d1bf846dad9507750b76fff1b6571c13142c4c735a136fd3e6e316e71f6b4a3c66cdd890aa073552894f35650277722fbf1af237b0fdbdf46f5210a8168549254278601a2007f84983accfca8e17027501134a8f8cdb910b847bbdee196a3efc46d6c9372b257759243f9a4a443f847ea6b9902671e68eafa72a8b66ae559f3d2cef6e28dfdc8e7f795b49e6b3ccd9b95e63ddf5146520ab460bc9e12c2e4fb09378277948d931051cbbcb4bb5cd5c7dc569304a26f72aa1bc3532811c1df21833c94b66f3664890d63d2c5d767a12ba11cb2814630964b02ac621b7a79f699d4a160134fa332d74467564fe78a98a5efe2190ba5dd1241ee68e1a524ef56fdf1a52b426bcdd2a529c4c11f3225bfb102d039249effc029b5344e66eb8321d3f0d9da34a9ba5fa5480f2ce415bc5708aff42ba92fa42db845aaa49ce85bc0c44dac6f9307742ec980b61e1da3203918dd5296f20686945ba4d35ec4c2c747b278f7b2031f36854b0d0e2c4c7afdbb473c689c3d449dc668cbd55ea7e5137818b28c1e92e6aad4a32969fe20b22e93fc97c8001c2b33e635266b313f5ae5493927426c294f6a110e86bba9b5e584e2772bbfd729cc6402dfc3cf73bb46928506ee8316d0b67231953879e261ce3db7119e189cb7aeed299b3f3248b64a7847734723ccd46e6b0119b1527f5eedd34e4d80c289b6a57e9750068704c472f07d3d43f0ab15999ebdd730cebd404c5df944ae429f4f809a9661b6b92669ce232e6cfd3a43eeb5fec211d63811241d0c758c022477a0ca3342276f80cb871178d165b2abcaae856bc2e5de425a3d3fc1f7d07f95e0b3c41b6f236260e410a0693aab141e290b3eb3621f71d54b56ce3c50875fcc146505096d5db2008857eac45b8676d410c4cbc9e446f7b2d49029dda31c54c592e5e969da53d2fe43bc706c3b5132ea502de1fc838f090e2da0ed0ac1ae041293132a3959ad1430b36e61b8ea096150c46953a2d55fc1bd16f0fe67eae7a325a1b8d2101a4fafb4b60513e25696128b2aa1efcd5788d4c3bfb39f7a51ce201016f7d35c4d0f40a458d0aeb5b920216e1e3e13790e7443d5d3bed701d1694af7f8cc402a4e7fb1087df8dc3024402196e73f51be4d9afbc6aa79314d702e67e3d9052220b13fca5cbb1f6dca6ddec656425eccf939cc0d8fb46529386421a850702aea0743e20bb2d5fd8bc424530e7183e5736895d76b001f36efdd3cde9e7c1e39a0e1a22c0d6d2955191ff7bd887678ff48c2e8df0d3766be575a6013dbf63ee55b49b4781bd432aa1815ded04492740d9f4455598d51ae89e2f32c2cd90a9ee8e82f6009cd8d771c888138e5293f0f929b9bc7f78018193390ba5828c588dc30f368a7e1ba2a498597845fe0b6a5573f953f5538dcf8f489115a6b91fd5ef50424e5ccb5d4be50a704d9631b1840525e09882c6444bb08a6fbf1bf8b96e78a0a9a8607a87b68070f5635541823e9d9245ec0ca0a699b31d5469cc3b508ddcd1483243f10867eed520f772756dfd475cf44886bf112255891e4f961a5c96a8b1dd507f5bc0cab111147e943ec22ee0bc0d3f0242880c097621f6374f9f0a746377d2120c7e6be804a4364c8e760e9b9051c8f1c4d7e0dee7783bf5b33209fc9c688e2c307a16bf10dfd357b9301e26f80fff179bf279e9e2c653d9f8857169913556301ea63e29d0dfdc0b798d2941ba83b3cb0265243a3d7af96b8aa88adae664edef343ae396187fe6a21a2f8e41a6e5cfe9734d4e5e909ee9cb27801ab9feae43c663ed8f1fcb62e8cc4ffed306c3140e8f5865948735a8afb000c0e4ba6fc571a1f10cd98dc28d2d6f7bb30e831cc9fea69e7e14ed12d623994b9cf19b574c03d8052a7cfd1f13265853c720be9cb646bd2b0fc85462999d02f83d495ac0990071a1b6873773594117c12e96ff5853f495a8ffe1e7723fa3f4efc0bd8c987c3c24210bbf592725afde2881199d143f81d24cc52664191889cb433d1a77259a51769852a921322b2930503cec4bfbf3f8e358c570c2449ea04e6b2f339cce1fb890b7a1fb90e4cb245936ae95e17c8a7ee7680a0b083369ecb63aeea78c350b1812a98150db1760a6a365e75ef14246d7e851798e78bdac91f55da1d148030bc29f842a1aac5ed2fd259c2a4422f0affd281f9f3056cb67125606648cbd09829970ce24e5537cfa84094f99a90f02c73a6f4d3ec613a7d3fcc5da5d5dc0d0726156c4c0320e0f67b33dfddcf1a411ccac95f94dc5adf870fadc4bdc0ec80664ba652bcf6d0fed16da7790ee83eeb18d0ddfa7fa596330ca3dd38d4a7c134f4951ec4160bd2e30f78622f87e3b6fead38987bdbdbbdd88068acf920bcbc219c7c6349c055ac443ddf6478eb82af0cfa085f4f4965c76dedc778dc5aceffe33d0c6aad826891bd82b759454691cd7721569ae975a47c1cf6ab605c31160a4dd9a280ebdcdd434e7998d351b03d8b925bd63151db8d63e4ae6e74bf504963693a5318448de892b9003a4be14fa6281454e54890100204a2a3b8797bfa8902a0abace37ebf4e0e38d104744fe2a3cc29dd05234ceab416a1836b909f4bf91e74224ab9942478ff7dabf9a437db03b6b04fb96eb5d790e88bfd34b987eb07787b450f01cf0f3d136a835c1dd0889ec8b6ab3dc674aaf6a124035bef8485aa5af6e19983d2eaae98dfa2bc658177e130980cbfd71be40caf999ece1be79b6664b2678fcaa679cc03926fb68ebf546b564b4f81a87855c167598d7e6396758b1eaad036ea6397dbbfe993a86dcc71d24f1db7fcc67d43727b36294c6f55d564cf9333e189a8af5e6d5c6994f654231272958f401a5073ed21e08b75f9f43c09ee6f1cf45ec796f7425afa3b9283951d7e28a272a0271f94cd79edcbd828fc876d07d9fc25314c3288c74dba5397cf17b4c6380fd783bfae2cd57d3a9f7c21c634f9dbfd4e426b81d329a786e969fa4e01728699666a69006318e53b1f538f317689045e4005d5fb10c864fe883637b5ba14ce237f2aac8e152c9b4836046a5e4ae6f2f3e5453ce42bfb199b1d53584cadd7871636f3d1c1b86a6e3816cfadc06b31acf50293baa154f0d92cfe4e1dd19ec95b30446c3f27e906fdefa3b4eb48370db2ad1a9a24f3052f73354d36ea8944315685a391327a5dfc7f35d1445206bbe2723d3b08206b4bdc2b1fbeab8306d6135d0bfa17cdf9e2dab94a3a002dd757ae7d499e81db0f355057cdd77363138f333e57d99f046582af901dccb391eee9bc42e863ba61eb808e2424f7cf9d84ec8a00794780fc96d3951968d697d976159d7caaa1fa01a01cc6d50ab56b90f7a281c34dd5731f5124d3c1e5b0b610025981e408ba71c07444b1b5f805a92ed7f08173871f51bace38716036381b6ca5be36e871ac27f447a7850479d84d66e50e40ff80db6f84fafe02276c62e01c734a087892da5d686a6bec3a45eafea3c40bf28e7834627336ba60b40e73f36b7ba4375258bfa7c0ea5c762175cd42906061f6d08c811a384db7b6453953f573bf99e4aaba0ce237d864fe49f86a75359915e311be9ec8f7e72ba6164cf197b9331214216efa8ea21e4d6d3021a16f31ec22a6271e5b639343676f42199a295127d6a868496cfecc204550d5e851d360e5800181e359e2f8ad4257740fe25bcb1cbacc19612e154921d676c9bb7bc580008fa1711128d6b31f318151a06024960976a04533e75502d77b458db13214edb9f37250d40a658e0920f8eda3fc0e0b8e565505fdafe7cf757248b521b8e5ff6af826b419108d9c727d462e182a8b590b8bfc99418f1c72327b2f04db00970724810fe4f934fb13fd6a9b85e580f310ebad574b96155860c1ab76981719814b2a9b0873c7dac8a3af988114729e58eb6b99fa5ca19738eb62aa6ddab34e21b7cbfd79d32b6638a60818f00a34ab5e309cb5feb38595fe5e8c61a8ecf8c38bb07710687e9ef201e610215688dd919e49264529817efb0feac14f14d5ab0f1c0472877f3558b9f52a8de3325285742bd3b67722ed32810cb190f4ea76941e7e8f11d39678155b7f3e464630e4ecf3f790574de56dbe749d1822c83451146eb6f4b49b360e33045b64ebcf59d95ae0ffda0711c53b2ae481c527c01da1ea439d0f068c5ac0455275b75628319121105a43d4cff3df0fba6ace2850d3f6b9207f0d627e216bcd61bc781a7ba0d596c719041577fa20a2fafee3b2276c0f7f297333e6e2f943cba1fb563612139626e9943101a46ed00a45bf8110f0e1792fe72ffc21b1e5f272fe33578996699e8ec4db732abe1e9272fddbfcba898d11b175db410644f21bd73161a2bc36936f6a6982f6ef7cb87c49626e75149f1ff46b6f4edd4cf2bf09ce6dd1ab38de1705e0037941296eafeeec71854b76d37a0b195605a8d8144fb4968d8eedcfad4d5ad9e0751fffd44591ac0fd2eff799baf7ef8163309f70b1a76543231e51a81d8000107f33c0ff3485d73852dcc77b02ea2411e5d84ea831ff0d18c65f3393d924feb38437acfac21bd6336fab1826f24c2a1a977acf0d18c31dda980a58b9a1f6bbd9b50ab5b50262bdebce15a9c90100fd078ab7c39207aa8213fb844005375970946e50bdf13de0431f2d9b23584baceab3d4773d757dbe73535a7ce213a533257f73448612b36a635ed3163392e958cfddb505c42f93dd150cc9acff9816798ef827f1d34fbb233568853056b913775f59cb3a089e062cd25f0b40ac84d48cfe880bf8a7fd891fce99f4065203dc0b562688fd7665102530ef0b8b187a828bd9d0ba9b27c59a88b8739af1bbe0cfd423122a1456e81d1b8004d8f72474fc58dfef7dc7c04ce30337145dfcf47ea8444372fb513f63fe5679edba4f44ae09282f38f63e22d019685b24095afaa743ee56b988537bf6ca61b01459758309f73640b9f01d9e21eb7a460643586f4c70dbd34aa221512869bacdade05905d17fc57dc957195ae99dc0e89c2beea5361783e4530f7fd6a348680bd2668a47198b35e3bb4b51effb14c0688e385d128c3931765c1fc90dc307f3922660db4aa2e12f495d0036fc7cd79074a2a9e17b51796710a056ae5a6677ac253bf4aa4bae89cbf40e42e6ca15d97ef433afa8062bb0afb9cfb7bada08d333247b4d77686bd5e2c83616fc413e01785bed0fbb0e9c3618e0f7c754b2ed2a3fac215bac5d60ce2526e4817ae5601dcdea0d81502db8bf830d313195868e418461cfc64d5a98886590ff7b27995d14a2065e0c87a6470c70fa78b8e4296c3985496136c94a87139a1d524ead699bc2eb380a2c01a9254ed17f2d77cab5b508b8ce7a3e897c7e74a06fd272a6b34e5e703283a482fd6939c00a8c41a3bfdbd6c4a39ee8f875933a998fe08a3857fb259553e58105f5d25a4811e8593d97e9b8e22ccc2ec0d9d3cfa6cfe11daaf31a2ca107a896c13af50a9ce3a1de28c99e3201d65a7de440173014abf278a69a16859b715c903df637f6334b570920e7be9576cb7018946b95bd57bb5a26ecfc6fd9a3caa58b882e5682c6ba119b99d8a8eff020026058f8d63c5328d414bd55ac9d1b01d54213b651f0043e66395e1fa98a554b7c6b448a66f9c33f15428787844f9b43dbac29bc61ae690714f916bce1219f8e0edbbbc95955106b783731e2a35c05a400efeffebeaf0a7a5a90da7f745471091c7055e993f987e9ad0fd23bb37a0d03d2cd2281d1f07b81ee2c280ca6025360a75b6fa1fbf1198de3fe21fc9cbb79d7cca5cd876df40ca9da9a2db826dc285c951552d10e2bae178dc29b547174bdcafec2788d489d7c43def51817fe83397bd14536eb6a6a87fab05ef9c8609faf29d25066625277b40e965e370b8426f1e2dedd5f9f4079768649085f05e003ecff2d5ad19f865360ce6e26893f7c3458efea5f806ee3231adeffe74997f1d73ef5722f83ec487e79aa3098e40127930d3e4b2b4417cb3e4bf39f20f2fee6dd145ec8ae21f238bb586205a83a7689df451af32d61ddb36a2ccc10e63eda2ec216e486a0e450b323bb8f29aea7d362d5554c63ad051df41fdb934d93ff1250ef296e36c81ebe62fd85052229c91e470edad5de74b4bec713fac5e8d700243db09bf993f21aca931476fb13e3985360016c9a0fde9f20fed0cad007a9ba2867123095a00eed8942d8424562f693c3613b08d5c0dd8cd3b839d2fae47e11b49d6de79ca9579f380fc859fcddbd45240ea02e8a613a4f68981b654f39eaf73bb2d8a4c0873272c4f036ecd91bfdc18df191696ca401939198ec7ab5022629ac1deed157d3f9a2d6a8294aad3b8d4ebe0172493299fdbf4bd4852d1fd3801d96c6aad4c0e92be0a6275688457b709b702ce209a3fcd5c31b361a0bf01b2563b83df828868566b49387e19f0bed3a493a248a2b20fd8b676f3cdc17118b9928c377a0b6c2fb8bc210c9cd75e1d835de350988ff8b45dfdf3fc213fcfdc78bc1a4f430e843944fba157de1366801d2cc0317b9d133f20a4d3a17cad36ed62572646f8c3045ecfb2389c26e0fa449a7eb3678e49e5bb147442e18d8fcf432b66bbfa7872f5244d7b44dabdb20ba3d324749d9d610612412771b58e0ca188a05b745b2bd1134e8690d1f0b0065918603e53b96e9dd6604405edcc47a33cebf4083542385142e8857a4fd5a96dd2dc6eecb36637f5b7803d84bd7a8d539453b67fbb076db5c28c973af6aeda547678bb89e71ead44971bdb1276bbc61b95385eeac2d57d0a3884222d369bb7ba79176274ec9c99ec6fc2de2c1d7663aa817ee17bb4b351c644d6addcaf382a12d7e9138e0acdda389b38b29facdb48423e00b81abb00d0e8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">输入密码视为你接受剧透,密码dirichilet</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>研distance——数据结构部分</title>
    <url>/thinklive/24155/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<h2 id="数据">数据</h2>
<ul>
<li><code>数据</code>：信息的载体，在计算机中是符号的集合</li>
<li><code>数据元素</code>：数据的基本单位，一个整体，由一些不可分割的数据项组成，例如一个学生档案</li>
<li><code>数据对象</code>：有相同性质的数据元素集合，是数据的子集</li>
<li><code>数据类型</code>：数据值的类型，和对这个类型特定操作的集合</li>
<li><code>数据结构</code>：相互之间存在特殊关系的数据元素的集合，这种特殊关系就是所谓的结构。</li>
</ul>
<p>数据结构包括三个方面</p>
<ul>
<li><code>逻辑结构</code>(数据的逻辑关系，和怎么存储在计算机中无关)</li>
<li><code>存储结构</code>(数据在计算机中的表示)
<ul>
<li><code>顺序存储</code>：元素存储在相邻的地址间，不需要额外索引，可以随机读写，但容易产生外部碎片</li>
<li><code>链式存储</code>：每个元素不仅存储值，还存储指向下一个元素的指针，不会产生碎片，但占用空间较大</li>
<li><code>索引存储</code>：建立一个外部索引表，利用索引表对数据进行读写，需要额外空间并管理表格</li>
<li><code>散列存储</code>：对每个元素用一个哈希函数计算其存储的地址，需要恰当的哈希函数</li>
</ul></li>
<li><code>数据的运算</code></li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231129144215.png" /></p>
<p><code>ADT</code>(抽象数据类型)构成一个完整的数据结构定义</p>
<span id="more"></span>
<h2 id="算法">算法</h2>
<p>算法是对指定输入的一系列指令 特性：</p>
<ul>
<li><code>有穷性</code>，执行时间和指令次数有穷</li>
<li><code>确定性</code>，指令有确定的含义，相同输入输出一定相同</li>
<li><code>可行性</code>，指令都是以及明确实现有定义的</li>
<li><code>输入</code>：有零个或者多个输入</li>
<li><code>输出</code>：有一个或以上的输出</li>
</ul>
<p>需要实现的目标：正确，可读，健壮(对于非法数据，也输出可控)，效率</p>
<p><code>复杂度</code>：略</p>
<h1 id="线性表">线性表</h1>
<p><code>定义</code>：有相同数据类型的n个数据元素的有限序列,元素直接存在前后关系，且只能线性前后排列,其中的元素都是数据元素，类型相同<br />
<code>类别</code>：逻辑结构，而非顺序表链表等存储结构<br />
<code>基本操作</code>：</p>
<ul>
<li>初始化</li>
<li>按值查找</li>
<li>按位查找</li>
<li>删除元素</li>
<li>输出(如输出到ostream)</li>
<li>求表长</li>
<li>销毁</li>
<li>判空</li>
</ul>
<hr />
<h2 id="顺序表">顺序表</h2>
<p><code>定义</code>:线性表的顺序存储是顺序表，用连续的地址存储表内元素，让逻辑顺序和物理顺序相同<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231130102600.png" /> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50     <span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType* data[Maxsize]; <span class="comment">//顺序表的元素</span></span><br><span class="line">	<span class="type">int</span> length;      <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;        <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">L.data=<span class="keyword">new</span> ElemType[InitSize]; <span class="comment">//动态分配</span></span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>插入操作</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(sqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) &#123;<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= Maxsize) &#123;</span><br><span class="line">    <span class="comment">//当前存储空间已满,不能插入  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--) &#123;</span><br><span class="line">    <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L.data[i<span class="number">-1</span>] = e; <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++; <span class="comment">//线性表长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均时间分析：</p>
<p><span class="math inline">\(\sum_{i=1}^{n+1}p_{i}(n-i+1)=\sum_{i=1}^{n+1}{\frac{1}{n+1}}(n-i+1)={\frac{1}{n+1}}\sum_{i=1}^{n+1}(n-i+1)={\frac{1}{n+1}}{\frac{n(n+1)}{2}}={\frac{n}{2}}\)</span></p>
<ol start="2" type="1">
<li>删除操作<br />
平均时间分析：</li>
</ol>
<p><span class="math inline">\(\sum_{i=1}^{n}p_{i}(n-i)=\sum_{i=1}^{n}{\frac{1}{n}}(n-i)={\frac{1}{n}}\sum_{i=1}^{n}(n-i)={\frac{1}{n}}{\frac{n(n-1)}{2}}={\frac{n-1}{2}}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,Elemtype &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;L.length; j++) &#123;</span><br><span class="line">    <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>] = L.data[j];  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>按值查找</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e) <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//下标为i的元素值等于e,返回其位序i+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出循环,说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均情况：假设pi是(pi=1/n)是查找的元素在第i(1&lt;=i&lt;=L.length)个位置上的概率</p>
<p><span class="math inline">\(\sum_{i=1}^{n}p_{i}\times i=\sum_{i=1}^{n}{\frac{1}{n}}\times i={\frac{1}{n}}{\frac{n(n+1)}{2}}={\frac{n+1}{2}}\)</span></p>
<div class="note warning"><ul>
<li>线性表的顺序存储结构是一种随机存取的存储结构,此处的顺序存取指的是只能线性遍历的数据结构，而顺序表可以随机存取</li>
<li>本书中的时间复杂度默认指渐进时间复杂度，即n默认趋近正无穷，而不是常数</li>
</ul>
<p>时间O(n),空间O(1)的删除表内一个值的算法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(SqList&amp; L, ElemType x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>;<span class="comment">//k记录值等于x的元素个数</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt; L.length) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L.data[i] == x) &#123;</span><br><span class="line">      k++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      L.data[i-k] = L.data[i];<span class="comment">//当前元素前移k个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.length = L.length - k;<span class="comment">//顺序表长度递减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<p>练习代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxsize = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sqList</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">20</span>]; <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="type">int</span> length;      <span class="comment">//顺序表的当前长度</span></span><br><span class="line">    <span class="built_in">sqList</span>(<span class="type">int</span> max):<span class="built_in">Maxsize</span>(max),<span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="comment">//L.data=new ElemType[InitSize]; //动态分配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(sqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) &#123;<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= Maxsize) &#123;</span><br><span class="line">        <span class="comment">//当前存储空间已满,不能插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--) &#123;</span><br><span class="line">        <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e; <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++; <span class="comment">//线性表长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(sqList L, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//下标为i的元素值等于e,返回其位序i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出循环,说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(sqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length) &#123;<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;L.length; j++) &#123;</span><br><span class="line">        <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletemin</span><span class="params">(sqList L)</span> </span>&#123;<span class="comment">//从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位置由最后一个元素填上</span></span><br><span class="line">    <span class="type">int</span> min =L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> min_index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i&lt; L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min&gt;L.data[i]) &#123;</span><br><span class="line">            min = L.data[i];</span><br><span class="line">            min_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;min is &quot;</span> &lt;&lt; min &lt;&lt;endl;</span><br><span class="line">    L.data[min_index] = L.data[L.length<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printql</span><span class="params">(sqList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        cout &lt;&lt; L.data[i]&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseql</span><span class="params">(sqList&amp; L)</span> </span>&#123;<span class="comment">//逆转线性表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp =L.data[i];</span><br><span class="line">        L.data[i] = L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">        L.data[L.length<span class="number">-1</span>-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after rev&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printql</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletex</span><span class="params">(sqList L, <span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;<span class="comment">//删除所有值为x的元素</span></span><br><span class="line">    <span class="type">int</span> xtimes=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x==L.data[i]) &#123;</span><br><span class="line">            xtimes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> values_except_x = L.length-xtimes;</span><br><span class="line">    <span class="type">int</span> new_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i]!=x)&#123;</span><br><span class="line">            L.data[new_index] = L.data[i];</span><br><span class="line">            new_index++;</span><br><span class="line">            values_except_x--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (values_except_x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = L.length-xtimes;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;after del&quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printql</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_orderedql_by_range</span><span class="params">(sqList L,<span class="type">int</span> i ,<span class="type">int</span> j)</span> </span>&#123;<span class="comment">//删除一定范围的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;=j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> lft =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt; L.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[lft] &gt;= i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lft++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lft&gt;=L.length<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> rht = lft+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (rht &lt; L.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[rht] &gt; j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rht++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = rht;index&lt;L.length;index++) &#123;</span><br><span class="line">        L.data[lft++] = L.data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=lft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_ql_by_range</span><span class="params">(sqList L,<span class="type">int</span> s,<span class="type">int</span> t)</span> </span>&#123;<span class="comment">//删除一定范围的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value_in_range;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s&lt;=L.data[i] &amp;&amp; L.data[i]&lt;=t)&#123;</span><br><span class="line">            value_in_range++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L.data[i-value_in_range]=L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length-=value_in_range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_unique</span><span class="params">(sqList L)</span> </span>&#123;<span class="comment">//删除相同值的元素</span></span><br><span class="line">    <span class="type">int</span> before = L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> same_values=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i]==before) &#123;</span><br><span class="line">            same_values++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            L.data[i-same_values] = L.data[i];</span><br><span class="line">            before = L.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length-=same_values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sqList <span class="title">mergesq</span><span class="params">(sqList L1, sqList L2)</span> </span>&#123;<span class="comment">//融合两个有序表</span></span><br><span class="line">    sqList result = *<span class="keyword">new</span> <span class="built_in">sqList</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1.length &amp;&amp; j &lt; L2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L1.data[i] &lt; L2.data[j]) result.data[k++] = L1.data[i++];</span><br><span class="line">        <span class="keyword">else</span> result.data[k++] = L2.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1.length) result.data[k++] = L1.data[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; L2.length) result.data[k++] = L2.data[j++];</span><br><span class="line">    result.length=L1.length+L2.length;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(sqList&amp; L,<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = L.data[i];</span><br><span class="line">    L.data[i]=L.data[j];</span><br><span class="line">    L.data[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(sqList&amp; L,<span class="type">int</span> lft,<span class="type">int</span> rht)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;(rht-lft)/<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(L,i+lft,rht-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sqList <span class="title">exchange</span><span class="params">(sqList L,<span class="type">int</span> m,<span class="type">int</span> n)</span> </span>&#123;<span class="comment">//位置互换</span></span><br><span class="line">    <span class="built_in">reverse</span>(L,<span class="number">0</span>,L.length);</span><br><span class="line">    <span class="built_in">reverse</span>(L,<span class="number">0</span>,n);</span><br><span class="line">    <span class="built_in">reverse</span>(L,n,L.length);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">middle_find_x</span><span class="params">(<span class="type">const</span> sqList&amp; L,<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//二分查找x</span></span><br><span class="line">    <span class="type">int</span> index =L.length/<span class="number">2</span>;<span class="type">int</span> lft=<span class="number">0</span>;<span class="type">int</span> rht=L.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lft&lt;=rht) &#123;</span><br><span class="line">        index=(rht+lft)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (L.data[index]==x) <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L.data[index] &lt; x) lft = index+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> rht=index<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lft;<span class="comment">//lft必然指向首个大于等于x的元素，rht则指向首个小于等于x的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_x</span><span class="params">(sqList L,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="built_in">middle_find_x</span>(L,x);</span><br><span class="line">    <span class="keyword">if</span> (i==L.length<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L.data[i]==x) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(L,i,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        L.data[L.length]=x;</span><br><span class="line">        L.length++;</span><br><span class="line">        <span class="built_in">swap</span>(L,i++,L.length<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;L.length;i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(L,i,L.length<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left_move</span><span class="params">(sqList L,<span class="type">int</span> p)</span> </span>&#123;<span class="comment">//左移p位</span></span><br><span class="line">    <span class="built_in">reverse</span>(L,<span class="number">0</span>,p);</span><br><span class="line">    <span class="built_in">reverse</span>(L,p,L.length);</span><br><span class="line">    <span class="built_in">reverse</span>(L,<span class="number">0</span>,L.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_middle_2</span><span class="params">(sqList L1,sqList L2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="type">int</span> lft=<span class="number">0</span>;<span class="type">int</span> rht=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;(L1.length+L2.length+<span class="number">1</span>)/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L1.data[lft]&lt;=L2.data[rht]) &#123;</span><br><span class="line">            middle =L1.data[lft];</span><br><span class="line">            lft++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            middle=L2.data[rht];</span><br><span class="line">            rht++;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_middle_best</span><span class="params">(sqList L1,sqList L2)</span> </span>&#123;<span class="comment">//寻找两个等长有序表的公共中位数</span></span><br><span class="line">    <span class="type">int</span> m1=L1.data[(L1.length+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> m2=L2.data[(L2.length+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> lft1,lft2,rht1,rht2;</span><br><span class="line">    lft1=lft2=<span class="number">0</span>;</span><br><span class="line">    rht1=rht2=L1.length;</span><br><span class="line">    <span class="keyword">while</span> (rht1-lft1&gt;<span class="number">1</span> || rht2-lft2&gt;<span class="number">1</span>) &#123;<span class="comment">//如果L1中位数小于L2，就舍弃L1较小边，L2较大边</span></span><br><span class="line">        <span class="keyword">if</span> (m1==m2) <span class="keyword">return</span> m1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m1&lt;m2) &#123;</span><br><span class="line">            lft1=(lft1+rht1)/<span class="number">2</span>;</span><br><span class="line">            rht2=(rht2+lft2)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rht1=(lft1+rht1)/<span class="number">2</span>;</span><br><span class="line">            lft2=(rht2+lft2)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m1=L1.data[(lft1+rht1)/<span class="number">2</span>];</span><br><span class="line">        m2=L2.data[(lft2+rht2)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L1.length%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">min</span>(m1,m2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(m1,m2);</span><br><span class="line">    <span class="comment">//两个等长序列，最后总长度必然是偶数位，m1,m2一个是中点位，一个是中点位+1,奇数情况下要取较大的，偶数取较小的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_key_of_sqL</span><span class="params">(sqList L)</span> </span>&#123;<span class="comment">//查找主元(出现次数大于长度的一半)</span></span><br><span class="line">    <span class="type">int</span> l=L.length;</span><br><span class="line">    <span class="type">int</span> vals[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        vals[i] =<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) &#123;</span><br><span class="line">        vals[L.data[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals[i]&gt;l/<span class="number">2</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_key_of_sqL_best</span><span class="params">(sqList L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到</span></span><br><span class="line"><span class="comment">    c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num,则计数加1,否则计</span></span><br><span class="line"><span class="comment">        数减1;当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1,开始新一</span></span><br><span class="line"><span class="comment">        轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。*/</span></span><br><span class="line">    <span class="type">int</span> i, c, count = <span class="number">1</span>;<span class="comment">//c用来保存候选主元素，count用来计数</span></span><br><span class="line">    c=L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> n=L.length;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == c) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                c = L.data[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)  <span class="keyword">for</span>(i =count = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//判断c中元素是否是真正的主元素</span></span><br><span class="line">            <span class="keyword">if</span>(L.data[i] == c) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min_Z</span><span class="params">(sqList L)</span> </span>&#123;<span class="comment">//查找最小的未出现正整数，可能的返回值只有[1,n+1]，超出这个范围不用考虑</span></span><br><span class="line">    <span class="type">int</span> n=L.length;</span><br><span class="line">    <span class="type">int</span> vals[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++) vals[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> (L.data[i]&gt;<span class="number">0</span> &amp;&amp; L.data[i]&lt;=n) vals[L.data[i]<span class="number">-1</span>]++;<span class="comment">//由于数组从0开始索引，需要进行转化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> (vals[i]==<span class="number">0</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xls_min</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;<span class="comment">//a是否是三个数中的最小值</span></span><br><span class="line">    <span class="keyword">if</span>(a&lt;=b&amp;&amp;a&lt;=c) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinofTrip</span> <span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> B [], <span class="type">int</span> m, <span class="type">int</span> C [], <span class="type">int</span> p)</span> </span>&#123;<span class="comment">//查找距离最小的三元组</span></span><br><span class="line">    <span class="comment">//D_min用于记录三元组的最小距离，初值赋为INT_MAX</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>,D_min=INT8_MAX,D;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n &amp;&amp; j&lt;m &amp;&amp; k&lt;p &amp;&amp; D_min&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        D=<span class="built_in">abs</span>(A[i]-B[j] )+<span class="built_in">abs</span>(B[j]-C[k] )+<span class="built_in">abs</span>(C[k]-A[i]); <span class="comment">//计算 D</span></span><br><span class="line">        <span class="keyword">if</span> (D&lt;D_min) D_min=D; <span class="comment">//更新 D</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">xls_min</span> (A[i],B[j],C[k])) i++; <span class="comment">//更新 a</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">xls_min</span>(B[j],C[k],A[i])) j++;</span><br><span class="line">        <span class="keyword">else</span> k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> D_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sqList* L_ptr = <span class="keyword">new</span> <span class="built_in">sqList</span>(<span class="number">50</span>);</span><br><span class="line">    sqList L =*L_ptr;</span><br><span class="line">    sqList L2 = *<span class="keyword">new</span> <span class="built_in">sqList</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">//int temp[8]=&#123;23,13,2,42,12,23,13,23&#125;;</span></span><br><span class="line">    <span class="type">int</span> temp[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">42</span>,<span class="number">67</span>&#125;;</span><br><span class="line">    <span class="type">int</span> temp2[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">22</span>&#125;;</span><br><span class="line">    <span class="type">int</span> temp3[<span class="number">6</span>] = &#123;<span class="number">-21</span>,<span class="number">-3</span>,<span class="number">14</span>,<span class="number">33</span>,<span class="number">35</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>(temp);i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(L,i+<span class="number">1</span>,temp[i]);</span><br><span class="line">        cout &lt;&lt; L.data[i]&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>(temp2);i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(L2,i+<span class="number">1</span>,temp2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//findMinofTrip(temp,8,temp2,5,temp3,6);</span></span><br><span class="line">    <span class="comment">//find_min_Z(L);</span></span><br><span class="line">    <span class="comment">//find_key_of_sqL_best(L2);</span></span><br><span class="line">    <span class="comment">//find_middle(L,L2);</span></span><br><span class="line">    <span class="comment">//left_move(L,2);</span></span><br><span class="line">    <span class="comment">//find_x(L,44);</span></span><br><span class="line">    <span class="comment">//exchange(L,8,3);</span></span><br><span class="line">    <span class="comment">//mergesq(L,L2);</span></span><br><span class="line">    <span class="comment">//make_unique(L);</span></span><br><span class="line">    <span class="comment">//delete_ql_by_range(L,6,43);</span></span><br><span class="line">    <span class="comment">//delete_orderedql_by_range(L,6,45);</span></span><br><span class="line">    <span class="comment">//deletex(L,23);</span></span><br><span class="line">    <span class="comment">//deletemin(L);</span></span><br><span class="line">    <span class="comment">//reverseql(L);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="链式表示">链式表示</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNodef</span> &#123; <span class="comment">//定义单链表结点类型</span></span><br><span class="line">	ElemType data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next; <span class="comment">//指针域</span></span><br><span class="line">&#125; ILNode,*LinkList;</span><br><span class="line"><span class="comment">//node是一个节点，Linklist是它的指针(即数组)</span></span><br></pre></td></tr></table></figure>
<p>一般会用一个<code>头结点</code>指向单链表，<code>头结点</code>的数据没有意义，空链表时指针是一个空指针<br />
<code>头指针</code>指向单链表的第一个节点，对有头指针的链表就是指向<code>头结点</code><br />
<code>头结点</code>的优点：</p>
<ol type="1">
<li>所有数据节点都可以用相同的办法处理</li>
<li>由于有<code>头节点</code>，<code>头指针</code>不会是一个空指针，空表和非空表也可以统一处理</li>
</ol>
<h3 id="基本操作">基本操作</h3>
<p>c++实现的一些基本操作： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;                              <span class="comment">// 定义单链表结点类型</span></span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;              <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>* next = <span class="literal">NULL</span>; <span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleLNode</span> &#123;                                     <span class="comment">// 定义双链表结点类型</span></span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;                     <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DoubleLNode</span>* prior = <span class="literal">NULL</span>; <span class="comment">// 指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DoubleLNode</span>* next = <span class="literal">NULL</span>;  <span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LNode* LinkList;</span><br><span class="line"><span class="keyword">typedef</span> DoubleLNode* DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历且打印链表,略过头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_linklist</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; i++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; L-&gt;data &lt;&lt; endl;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历且打印循环单链表,略过头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_loop_linklist</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList head = L;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != head) &#123;</span><br><span class="line">        cout &lt;&lt; i++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; L-&gt;data &lt;&lt; endl;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历且打印循环双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_linklist</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">    DLinkList head = L;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != head) &#123;</span><br><span class="line">        cout &lt;&lt; i++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; L-&gt;data &lt;&lt; endl;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组以尾插法生成链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">build_nodelist</span><span class="params">(LinkList&amp; L, <span class="type">int</span> lst[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    LNode* r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        LNode* s = <span class="keyword">new</span> LNode; <span class="comment">// 创建新结点</span></span><br><span class="line">        s-&gt;data = lst[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组以尾插法生成循环单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">build_loop_list</span><span class="params">(LinkList&amp; L, <span class="type">int</span> lst[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    LNode* r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        LNode* s = <span class="keyword">new</span> LNode; <span class="comment">// 创建新结点</span></span><br><span class="line">        s-&gt;data = lst[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组以尾插法生成循环双链表</span></span><br><span class="line"><span class="function">DLinkList <span class="title">build_loop_double_list</span><span class="params">(DLinkList&amp; L, <span class="type">int</span> lst[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    DoubleLNode* r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        DoubleLNode* s = <span class="keyword">new</span> DoubleLNode; <span class="comment">// 创建新结点</span></span><br><span class="line">        s-&gt;data = lst[i];</span><br><span class="line">        s-&gt;prior = r;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = r;</span><br><span class="line">    r-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法生成链表，即遍历顺序和输入顺序相反</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    LNode* s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入结点的值:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;                  <span class="comment">// 输入9999表示结束</span></span><br><span class="line">        s = <span class="keyword">new</span> LNode; <span class="comment">// 创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s; <span class="comment">// 将新结点插入表中,L为头指针</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入结点的值:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; x; <span class="comment">// 输入结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法生成链表，即遍历顺序和输入顺序一致</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    LNode* r = L;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入结点的值:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        LNode* s = <span class="keyword">new</span> LNode;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s; <span class="comment">// r指向新的表尾结点</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入结点的值:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; x; <span class="comment">// 输入结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找节点，不存在返回NULL</span></span><br><span class="line"><span class="function">LNode* <span class="title">LocateElem_byval</span><span class="params">(LinkList L, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) <span class="comment">// 从第1个结点开始查找data域为e的结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按序号定位结点，如果越界返回NULL</span></span><br><span class="line"><span class="function">LNode* <span class="title">LocateElem_byno</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入删除略,删除时要用delete回收内存！！！</span></span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">merge_list</span><span class="params">(LinkList head, LinkList tail)</span> </span>&#123;</span><br><span class="line">    LinkList temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) temp = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = tail-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>循环单链表表尾结点*r的next域指向L,故表中没有指针域为NULL的结点，判空条件是当前节点是否等于头指针<br />
有时对循环单链表不设头指针而仅设尾指针,若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，而若设的是尾指针r,r-&gt;next即为头指针，对在表头或表尾插入元素都只需要O(1)的时间复杂度<br />
循环双链表中，头结点的prior指针还要指向表尾结点,为空时，头结点的前后指针都指向自己</p>
<p>静态链表借助数组来描述线性表的链式存储结构,其指针是结点的相对地址(数组下标)，又称游标，需要预先分配一块连续的内存空间 <img src="/assets/resources/%7B0273A086-DB7E-4fb9-80BB-72F790BBE170%7D.png" /> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br></pre></td></tr></table></figure></p>
<p><strong>顺序表和链表的比较</strong>：</p>
<ol type="1">
<li>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素</li>
<li>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻</li>
<li>顺序存储需要连续空间，一旦溢出，动态分配成本较大，而链表更灵活，可以一直O(1)时间添加元素</li>
<li>链表存储密度更小，必然小于1，且实现更复杂</li>
</ol>
<p>练习代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;node_list.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.递归删除不带头结点链表值为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_by_val</span><span class="params">(LinkList&amp; L, <span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == x) &#123;</span><br><span class="line">        LinkList l = L;</span><br><span class="line">        L = L-&gt;next;  <span class="comment">// 这里L为调用该函数的外层L-&gt;next，故这里实现了L-&gt;next=L-next-&gt;next</span></span><br><span class="line">        <span class="keyword">delete</span> l;</span><br><span class="line">        <span class="built_in">del_by_val</span>(L, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">del_by_val</span>(L-&gt;next, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在带头结点的单链表L中，删除所有值为x的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_by_val_withhead</span><span class="params">(LinkList p, <span class="type">int</span> x)</span> </span>&#123;  <span class="comment">// p是先驱节点，最初是头结点</span></span><br><span class="line">    LinkList q = p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;  <span class="comment">// 循环检查后继结点的值是否是x</span></span><br><span class="line">        <span class="keyword">if</span> (q-&gt;data == x) &#123;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            LinkList temp = q;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.带头结点的单链表从尾到头反向输出每个结点的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_linklist_rev</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print_linklist_rev</span>(L-&gt;next);</span><br><span class="line">    cout &lt;&lt; L-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">remove_head</span><span class="params">(LinkList head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.在带头结点的单链表L中删除一个最小值结点(假设唯一)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_min_withhead</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkList prev = L;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    LinkList min_node, min_prev;</span><br><span class="line">    <span class="type">int</span> min_val = INT16_MAX;</span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;data &lt; min_val) min_node = L, min_prev = prev, min_val = L-&gt;data;</span><br><span class="line">        prev = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    min_prev-&gt;next = min_node-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> min_node;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除的节点值为:&quot;</span> &lt;&lt; min_val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.将带头结点的单链表就地逆置</span></span><br><span class="line"><span class="function">LinkList <span class="title">rev_insite_withhead</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList head = L, temp; <span class="comment">//暂存头结点</span></span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    LinkList p = L-&gt;next;  <span class="comment">//L和p分别是先驱后继节点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = p-&gt;next; <span class="comment">//暂存p之后的链表</span></span><br><span class="line">        p-&gt;next = L;  <span class="comment">//反转L和p</span></span><br><span class="line">        L = p;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*另一种解法</span></span><br><span class="line"><span class="comment">    LNode* p, * r;</span></span><br><span class="line"><span class="comment">    p = L-&gt;next;</span></span><br><span class="line"><span class="comment">    L-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">    while (p != NULL) &#123;</span></span><br><span class="line"><span class="comment">        r = p-&gt;next;</span></span><br><span class="line"><span class="comment">        p-&gt;next = L-&gt;next;</span></span><br><span class="line"><span class="comment">        L-&gt;next = p;//将P结点插入到头结点之后</span></span><br><span class="line"><span class="comment">        p = r;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return L;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*6.插入排序带头结点的单链表L</span></span><br><span class="line"><span class="comment">    1. 排序部分初始为头结点及其后续一个节点,未排序部分是head-&gt;next-&gt;next为首的链表</span></span><br><span class="line"><span class="comment">    2. 取一个未排序节点，遍历找到插入位置</span></span><br><span class="line"><span class="comment">    3. 插入节点，将leaft指向之前暂存的未排序部分首个结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList leaft = L-&gt;next;<span class="comment">//leaft是未排序部分的首个节点</span></span><br><span class="line">    LinkList remains = leaft-&gt;next;</span><br><span class="line">    leaft-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    leaft = remains;</span><br><span class="line">    <span class="keyword">while</span> (leaft != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        remains = leaft-&gt;next;</span><br><span class="line">        LinkList prev = L;</span><br><span class="line">        <span class="keyword">while</span> (prev-&gt;next != <span class="literal">NULL</span> &amp;&amp; leaft-&gt;data &gt; prev-&gt;next-&gt;data) prev = prev-&gt;next;</span><br><span class="line">        <span class="comment">//注意要先判断next是否为空，否则会访问空指针出现异常！！！</span></span><br><span class="line">        leaft-&gt;next = prev-&gt;next;</span><br><span class="line">        prev-&gt;next = leaft;</span><br><span class="line">        leaft = remains;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 删除无序带头结点单链表介于[x,y]内的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_val_inrange</span><span class="params">(LinkList L, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    LinkList p = L, q = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;data &lt; y &amp;&amp; q-&gt;data &gt;x) &#123;</span><br><span class="line">            LinkList temp = q;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*8.找出两个链表的公共结点</span></span><br><span class="line"><span class="comment">若有公共结点，则从其开始，两链表完全一致，因此必出现在距离尾部距离一致的地方</span></span><br><span class="line"><span class="comment">因此可以将较长的链表截断到较短链表长度，随后遍历寻找公共结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_of_list</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="function">LinkList <span class="title">find_public_node</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">len_of_list</span>(L1-&gt;next);</span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">len_of_list</span>(L2-&gt;next);</span><br><span class="line">    LinkList longer, shorter;</span><br><span class="line">    longer = (len1 &gt; len2) ? L1-&gt;next : L2-&gt;next;</span><br><span class="line">    shorter = (len1 &gt; len2) ? L2-&gt;next : L1-&gt;next;</span><br><span class="line">    longer = (len1 == len2) ? longer : <span class="built_in">LocateElem_byno</span>(longer, <span class="built_in">abs</span>(len1 - len2));</span><br><span class="line">    <span class="keyword">while</span> (longer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (longer == shorter) <span class="keyword">return</span> longer;</span><br><span class="line">        longer = longer-&gt;next;</span><br><span class="line">        shorter = shorter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_of_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.按递增次序输出单链表中各结点的数据元素，并释放结点,就地算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_and_del_sorted_list</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkList iter = L-&gt;next-&gt;next, min = L-&gt;next, prev = min, prev_min = L;</span><br><span class="line">    <span class="keyword">while</span> (iter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min-&gt;data &gt; iter-&gt;data) min = iter, prev_min = prev;</span><br><span class="line">        prev = iter;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev_min-&gt;next = min-&gt;next;</span><br><span class="line">    cout &lt;&lt; min-&gt;data &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> min;</span><br><span class="line">    <span class="built_in">print_and_del_sorted_list</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.将一个带头结点的单链表按奇偶分解成两个链表</span></span><br><span class="line"><span class="function">pair&lt;LinkList, LinkList&gt; <span class="title">tear_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> signal = <span class="number">1</span>;</span><br><span class="line">    LinkList L1head = <span class="keyword">new</span> LNode, L2head = L;</span><br><span class="line">    LinkList q = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkList temp = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (signal == <span class="number">1</span>) &#123;</span><br><span class="line">            signal = <span class="number">0</span>;</span><br><span class="line">            q-&gt;next = L1head-&gt;next;</span><br><span class="line">            L1head-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            signal = <span class="number">1</span>;</span><br><span class="line">            q-&gt;next = L2head-&gt;next;</span><br><span class="line">            L2head-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        q = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(L1head, L2head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//11.C= &#123;a1, b1,...,an,bn&#125;线性表，采用带头结点的单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A = (a1 a2,,,an&#125;, B= bn,,,b2,b1&#125;</span></span><br><span class="line"><span class="comment">//即一个头插法，一个尾插法</span></span><br><span class="line"><span class="function">pair&lt;LinkList, LinkList&gt; <span class="title">tear_list_rev</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList L1head = <span class="keyword">new</span> LNode, L1tail = L1head, L2head = L;</span><br><span class="line">    LinkList node = L-&gt;next;</span><br><span class="line">    L2head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkList temp = node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (signal == <span class="number">0</span>) &#123;</span><br><span class="line">            signal = <span class="number">1</span>;</span><br><span class="line">            L1tail-&gt;next = node;</span><br><span class="line">            L1tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            signal = <span class="number">0</span>;</span><br><span class="line">            node-&gt;next = L2head-&gt;next;</span><br><span class="line">            L2head-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        node = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    L1tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(L1head, L2head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12.递增有序的线性表去除重复元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_samepart_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList prev = L-&gt;next, q = prev-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = prev-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (prev-&gt;data == q-&gt;data) &#123;</span><br><span class="line">            prev-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*13.两个按元素值递增次序排列的单链表,归并为一个按元素值递增次序排列的单链表，不创造新节点</span></span><br><span class="line"><span class="comment">如果是递减版本，则需要使用头插法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">LinkList <span class="title">merge_and_sort</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LinkList l1node = L1-&gt;next, l2node = L2-&gt;next, l1tail = L1;</span><br><span class="line">    L1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1node != <span class="literal">NULL</span> &amp;&amp; l2node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkList temp;</span><br><span class="line">        <span class="keyword">if</span> (l1node-&gt;data &lt; l2node-&gt;data) &#123;</span><br><span class="line">            l1tail-&gt;next = l1node;</span><br><span class="line">            l1tail = l1node;</span><br><span class="line">            l1node = l1node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l1tail-&gt;next = l2node;</span><br><span class="line">            l1tail = l2node;</span><br><span class="line">            l2node = l2node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l1tail-&gt;next = (l1node == <span class="literal">NULL</span>) ? l2node : l1node;</span><br><span class="line">    <span class="keyword">delete</span> L2;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14.两个递增有序单链表，用其公共元素产生一个新链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">build_list_from_public</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LinkList prev1 = L1, prev2 = L2;</span><br><span class="line">    LinkList L3 = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="keyword">while</span> (prev1-&gt;next != <span class="literal">NULL</span> &amp;&amp; prev2-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev1-&gt;next-&gt;data == prev2-&gt;next-&gt;data) &#123;</span><br><span class="line">            LinkList new_node = <span class="keyword">new</span> LNode;</span><br><span class="line">            new_node-&gt;data = prev1-&gt;next-&gt;data;</span><br><span class="line">            new_node-&gt;next = L3-&gt;next;</span><br><span class="line">            L3-&gt;next = new_node;</span><br><span class="line">            prev1 = prev1-&gt;next;</span><br><span class="line">            prev2 = prev2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prev1-&gt;next-&gt;data &lt; prev2-&gt;next-&gt;data) prev1 = prev1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> prev2 = prev2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//15.两个链表分别表示两个集合，其元素递增排列，将其交集存放于A链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">list_intersection</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LinkList prev1 = L1, prev2 = L2, l1tail = L1;</span><br><span class="line">    <span class="keyword">while</span> (prev1-&gt;next != <span class="literal">NULL</span> &amp;&amp; prev2-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev1-&gt;next-&gt;data == prev2-&gt;next-&gt;data) &#123;</span><br><span class="line">            l1tail-&gt;next = prev1-&gt;next;</span><br><span class="line">            l1tail = prev1-&gt;next;</span><br><span class="line">            prev1 = prev1-&gt;next;</span><br><span class="line">            prev2 = prev2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prev1-&gt;next-&gt;data &lt; prev2-&gt;next-&gt;data) prev1 = prev1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> prev2 = prev2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    l1tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*16.两个链表分别是一个整数序列，判断B是否是A的子序列</span></span><br><span class="line"><span class="comment">1. 不断比较两个先驱指针的next</span></span><br><span class="line"><span class="comment">2. 若相等，同时后移</span></span><br><span class="line"><span class="comment">3. 若不等，有两种可能，</span></span><br><span class="line"><span class="comment">    1. 如果该节点是一个子序列的开始，则比较其后续节点与son的后续节点</span></span><br><span class="line"><span class="comment">    2. 否则，比较其后续结点和son的开始节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_sonlist</span><span class="params">(LinkList parent, LinkList son)</span> </span>&#123;</span><br><span class="line">    LinkList sonhead = son;</span><br><span class="line">    <span class="keyword">while</span> (parent-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (son-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;next-&gt;data == son-&gt;next-&gt;data) &#123;</span><br><span class="line">            parent = parent-&gt;next;</span><br><span class="line">            son = son-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;next-&gt;data == sonhead-&gt;next-&gt;data) &#123;</span><br><span class="line">            parent = parent-&gt;next;</span><br><span class="line">            son = sonhead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent = parent-&gt;next;</span><br><span class="line">            son = sonhead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//17. 判断带头结点的循环双链表是否对称</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_symmetry</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">    DLinkList lft = L-&gt;next, rht = L-&gt;prior;</span><br><span class="line">    <span class="keyword">while</span> (lft != rht &amp;&amp; lft != rht-&gt;next) &#123;<span class="comment">//边界有两种情况，偶数时，lft会跑到rht右边，奇数时，两者碰到一起</span></span><br><span class="line">        <span class="keyword">if</span> (lft-&gt;data == rht-&gt;data) &#123;</span><br><span class="line">            lft = lft-&gt;next;</span><br><span class="line">            rht = rht-&gt;prior;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//18.两个循环单链表,将链表h2链接到链表hl之后，要求链接后的链表仍保持循环链表形式</span></span><br><span class="line"><span class="function">LinkList <span class="title">merge_loop_list</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LinkList l1tail = L1, l2tail = L2;</span><br><span class="line">    <span class="keyword">while</span> (l1tail-&gt;next != L1) l1tail = l1tail-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (l2tail-&gt;next != L2) l2tail = l2tail-&gt;next;</span><br><span class="line">    l1tail-&gt;next = L2-&gt;next;</span><br><span class="line">    l2tail-&gt;next = L1;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//19.反复找出循环单链表中结点值最小的结点并输出，然后将该结点从中删除，直到单链表空为止，再删除表头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_and_del_minnode_loop</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList node = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node == L) <span class="keyword">return</span>;</span><br><span class="line">    LinkList min_node_prev = L, work_node = node;</span><br><span class="line">    <span class="keyword">while</span> (work_node-&gt;next != L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (work_node-&gt;next-&gt;data &lt; min_node_prev-&gt;next-&gt;data) min_node_prev = work_node;</span><br><span class="line">        work_node = work_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;del min_node:&quot;</span> &lt;&lt; min_node_prev-&gt;next-&gt;data &lt;&lt; endl;</span><br><span class="line">    LinkList temp = min_node_prev-&gt;next;</span><br><span class="line">    min_node_prev-&gt;next = min_node_prev-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    <span class="built_in">find_and_del_minnode_loop</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//20.判断单链表是否有环</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_has_cycle</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList slow = L, fast = L;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LNode* <span class="title">FindLoopStart</span><span class="params">(LNode* head)</span> </span>&#123;</span><br><span class="line">    LNode* fast = head, * slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next; <span class="comment">//每次走一步</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next; <span class="comment">//每次走两步</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>; <span class="comment">//相遇</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//没有环，返回NULL</span></span><br><span class="line">    LNode* pl = head, * p2 = slow;</span><br><span class="line">    <span class="keyword">while</span> (pl != p2) &#123;</span><br><span class="line">        <span class="comment">//分别指向开始点、相遇点</span></span><br><span class="line">        pl = pl-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pl; <span class="comment">//返回入口点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真题1.查找带头结点的链表中倒数第k个位置上的结点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_k_rev_node</span><span class="params">(LinkList L, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    LinkList prev = L, after = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (after == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        after = after-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (after != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        after = after-&gt;next;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the node is:&quot;</span> &lt;&lt; prev-&gt;data &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真题2.strl和str2分别指向两个单词所在单链表的头结点，找出由strl和str2所指向两个链表共同后缀的起始位置</span></span><br><span class="line"><span class="function">LinkList <span class="title">find_public_charnode</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1-&gt;next == <span class="literal">NULL</span> || L2-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">len_of_list</span>(L1-&gt;next), len2 = <span class="built_in">len_of_list</span>(L2-&gt;next);</span><br><span class="line">    LinkList longer = (len1 &gt; len2) ? L1-&gt;next : L2-&gt;next;</span><br><span class="line">    LinkList shorter = (len1 &gt; len2) ? L2-&gt;next : L1-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">abs</span>(len1 - len2);i++) longer = longer-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (longer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (longer == shorter) <span class="keyword">return</span> longer;</span><br><span class="line">        longer = longer-&gt;next;</span><br><span class="line">        shorter = shorter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真题3.用单链表保存m个整数,其绝对值均小于n,对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点</span></span><br><span class="line"><span class="function">LinkList <span class="title">remove_sameabs</span><span class="params">(LinkList&amp; L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> bucket[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) bucket[i] = <span class="number">0</span>;</span><br><span class="line">    LinkList prev = L;</span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[<span class="built_in">abs</span>(prev-&gt;next-&gt;data)] == <span class="literal">true</span>) &#123;</span><br><span class="line">            LinkList temp = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket[<span class="built_in">abs</span>(prev-&gt;next-&gt;data)] = <span class="literal">true</span>;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print_linklist</span>(L);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真题4.线性表L =(a1,a2,,an)采用带头结点的单链表保存,就地将其排序为(a1,an,a2,an-1,,,)</span></span><br><span class="line"><span class="function">LinkList <span class="title">resort_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList p = L, q = L, r;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span> &amp;&amp; q-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//寻找中点</span></span><br><span class="line">        q = q-&gt;next-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;next;<span class="comment">//令q为后半段第一个节点</span></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//断开前半段</span></span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;<span class="comment">//逆置后半段</span></span><br><span class="line">        r = q-&gt;next;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList prev;</span><br><span class="line">    prev = L-&gt;next;<span class="comment">//前半段第一个节点</span></span><br><span class="line">    q = p-&gt;next;<span class="comment">//后半段第一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;<span class="comment">//也可以是prev!=p</span></span><br><span class="line">        r = q-&gt;next;<span class="comment">//暂存的r是后半段链表下一个要处理的节点</span></span><br><span class="line">        q-&gt;next = prev-&gt;next;</span><br><span class="line">        prev-&gt;next = q;<span class="comment">//将n-i+1号节点插入到i号节点后</span></span><br><span class="line">        prev = q-&gt;next;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//最后形成的链表到p为止</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp[<span class="number">8</span>] = &#123; <span class="number">2</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">33</span>,<span class="number">54</span>, <span class="number">72</span>, <span class="number">83</span>, <span class="number">99</span> &#125;;</span><br><span class="line">    <span class="type">int</span> temp2[<span class="number">3</span>] = &#123; <span class="number">3</span>,<span class="number">17</span>, <span class="number">23</span> &#125;;</span><br><span class="line">    LinkList nodes = <span class="keyword">new</span> LNode;</span><br><span class="line">    LinkList nodes2 = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="built_in">build_nodelist</span>(nodes, temp,</span><br><span class="line">        <span class="built_in">sizeof</span>(temp) / <span class="built_in">sizeof</span>(temp[<span class="number">0</span>]));  <span class="comment">// 生成带头结点的测试链表</span></span><br><span class="line">    <span class="built_in">build_nodelist</span>(nodes2, temp2,</span><br><span class="line">        <span class="built_in">sizeof</span>(temp2) / <span class="built_in">sizeof</span>(temp2[<span class="number">0</span>]));  <span class="comment">// 生成带头结点的测试链表 </span></span><br><span class="line">    <span class="comment">/*     DLinkList doublelist = new DoubleLNode;</span></span><br><span class="line"><span class="comment">        build_loop_double_list(doublelist, temp, sizeof(temp) / sizeof(temp[0])); */</span></span><br><span class="line">        <span class="comment">//nodes2 = merge_list(nodes2, nodes);</span></span><br><span class="line">        <span class="comment">// del_by_val(nodes-&gt;next,22);//传入头结点的next就可以视为无头结点链表</span></span><br><span class="line">        <span class="comment">// del_by_val_withhead(nodes,22);</span></span><br><span class="line">        <span class="comment">// print_linklist_rev(remove_head(nodes));</span></span><br><span class="line">        <span class="comment">// del_min_withhead(nodes);</span></span><br><span class="line">        <span class="comment">//nodes = rev_insite_withhead(nodes);</span></span><br><span class="line">        <span class="comment">//insertsort_list(nodes);</span></span><br><span class="line">        <span class="comment">//del_val_inrange(nodes,10,30);</span></span><br><span class="line">        <span class="comment">//find_public_node(nodes,nodes2);</span></span><br><span class="line">        <span class="comment">//print_and_del_sorted_list(nodes2);</span></span><br><span class="line">    <span class="comment">/*     auto listpair = tear_list(nodes);</span></span><br><span class="line"><span class="comment">        print_linklist(listpair.first);</span></span><br><span class="line"><span class="comment">        print_linklist(listpair.second); */</span></span><br><span class="line">        <span class="comment">/*     auto nodespair = tear_list_rev(nodes);</span></span><br><span class="line"><span class="comment">            print_linklist(nodespair.first);</span></span><br><span class="line"><span class="comment">            print_linklist(nodespair.second); */</span></span><br><span class="line">            <span class="comment">//remove_samepart_list(nodes);</span></span><br><span class="line">        <span class="comment">//nodes = merge_and_sort(nodes2, nodes);</span></span><br><span class="line">        <span class="comment">//print_linklist(build_list_from_public(nodes,nodes2));</span></span><br><span class="line">        <span class="comment">//print_linklist(list_intersection(nodes,nodes2));</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;A is B&#x27;s parent?&quot; &lt;&lt; if_sonlist(nodes, nodes2) &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;symmetry? &quot; &lt;&lt; if_symmetry(doublelist) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//print_loop_linklist(merge_loop_list(build_loop_list(nodes, temp, sizeof(temp) / sizeof(temp[0])), build_loop_list(nodes2, temp2, sizeof(temp2) / sizeof(temp2[0]))));</span></span><br><span class="line"><span class="comment">//find_and_del_minnode_loop(build_loop_list(nodes, temp, sizeof(temp) / sizeof(temp[0])));</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;has a cycle?&quot; &lt;&lt; if_has_cycle(nodes) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//find_k_rev_node(nodes, 8);</span></span><br><span class="line">    <span class="comment">//find_public_charnode(nodes, nodes2);</span></span><br><span class="line">    <span class="comment">//remove_sameabs(nodes, 200);</span></span><br><span class="line">    <span class="built_in">print_linklist</span>(<span class="built_in">resort_list</span>(nodes));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print_linklist(doublelist);</span></span><br><span class="line">    <span class="comment">//print_linklist(nodes);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<hr />
<h1 id="栈队列矩阵">栈&amp;&amp;队列&amp;&amp;矩阵</h1>
<h2 id="栈">栈</h2>
<p>c++表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize]; <span class="comment">//存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top; <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Linknode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Linknode</span>* next; <span class="comment">//指针域</span></span><br><span class="line">&#125;* LiStack; <span class="comment">//栈类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MaxSize) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top--]; <span class="comment">//先出栈，指针再减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意进出栈对应修改data和top的顺序相反</strong><br />
链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。<br />
实现中规定链栈没有头结点，Lhead指向栈顶元素</p>
<p>两个顺序栈可共享一个连续数组框架，增长方向相对，一个栈底是0，一个是MaxSize-1,只当top1-top0==1时栈满</p>
<p>将中缀表达式转换为后缀表达式的算法思想如下：<br />
从左向右开始扫描中缀表达式；<br />
遇到数字时，加入后缀表达式；<br />
遇到运算符时：<br />
a. 若为<code>(</code>,入栈；<br />
b. 若为<code>)</code>，则依次把栈中的运算符加入后缀表达式，直到出现<code>(</code>，从栈中删除<code>(</code>；<br />
c. 若为除括号外的其他运算符，当其优先级高于除<code>(</code>外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或遇到了一个左括号为止。<br />
当扫描的中缀表达式结束时，栈中的所有运算符依次出栈加入后缀表达式。</p>
<h2 id="队列">队列</h2>
<p>先进先出的数据结构，但其顺序实现会产生难以判满的问题，即rear==MaxSize时，可能前有空槽</p>
<p><strong>循环队列</strong>：</p>
<ul>
<li>初始时：<code>Q.front=Q.rear=0</code></li>
<li>队首指针进1: <code>Q.front= (Q.front+1)%MaxSize</code></li>
<li>队尾指针进1: <code>Q.rear=(Q.rear+1)%MaxSize</code></li>
<li>队列长度:<code>(Q.rear+MaxSize-Q.front)%MaxSize</code></li>
</ul>
<p>可以约定以队头指针在队尾指针的下一位置作为队满的标志,即减少一个存储单元，此时：</p>
<ul>
<li>队满条件：<code>(Q.rear+1)%MaxSize==Q.front</code></li>
<li>队空条件：<code>Q.front==Q.rear</code></li>
</ul>
<p>或者增设<code>size</code>成员，<code>tag</code>成员,tag等于0时，若因删除导致<code>Q.front==Q.rear</code>,则为队空；tag等于1时，若因插入导致<code>Q.front==Q.rear</code>,则为队满<br />
增设一个tag的整型变量，进队时置tag为1,出队时置tag为0,以tag判断满空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>; <span class="comment">//初始化队首、队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//队空条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue&amp; Q, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize; <span class="comment">//队尾指针加 1 取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue&amp; Q, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//队空则报错</span></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front == (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针加 1 取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>链式队列</strong>：<br />
需要队头和队尾指针,front指向第一个节点，rear指向最后一个节点<br />
队空条件：<code>front==rear==NULL</code><br />
也可以设置一个头结点，统一插入和删除操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span>* next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    LinkNode* front, * rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = <span class="keyword">new</span> LinkNode; <span class="comment">//建立头结点</span></span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    LinkNode* s = <span class="keyword">new</span> LinkNode;</span><br><span class="line">    s-&gt;data = x; s-&gt;next = <span class="literal">NULL</span>; <span class="comment">//创建新结点，插入到链尾</span></span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    LinkNode* p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">        Q.rear = Q.front; <span class="comment">//若原队列中只有一个结点，删除后变空</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双端队列</strong>：<br />
允许两端都可以进行入队和出队操作的队列</p>
<ul>
<li>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入</li>
<li>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除</li>
</ul>
<p>栈被应用于:递归，前后缀运算符，括号匹配<br />
而队列应用于:按广度遍历，操作系统的任务调度</p>
<h2 id="数组与矩阵">数组与矩阵</h2>
<p>一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表，数组是定长的，在逻辑上有自己的维数和长度(但c与c++不检查是否越界)<br />
一维数组:<span class="math inline">\({\mathsf{L O C}}(a_{i})={\mathsf{L O C}}(a_{0})+i\times L\ \ (0\leq i&lt;n)\)</span><br />
二维数组(h1,h2分别是行列的最大值) 按行存储时：<br />
<span class="math display">\[{\mathrm{LOC}}(a_{i,j})={\mathrm{LOC}}(a_{0,0})+\left[i\times(h_{2}+1)+j\right]\times L\]</span><br />
按列存储时：<br />
<span class="math display">\[\mathrm{LOC}(a_{i,j})=\mathrm{LOC}(a_{0,0})+\bigl[j\times(h_{1}+1)+i\bigr]\times L\]</span></p>
<p>二维数组一般从0开始索引，矩阵一般从1开始<br />
矩阵可以用一些方法压缩</p>
<ol type="1">
<li>对称矩阵 ,元素下标之间的对应关系:<span class="math inline">\(k=\frac{i(i-1)}{2}+j-1,\qquad i\geqslant j(i&lt;j时两者互换)\)</span></li>
<li>下三角矩阵(上三角区元素都是常量)</li>
</ol>
<p><span class="math display">\[k=
\begin{cases}
\frac{i(i-1)}{2}+j-1,\qquad i\geq j \\
\frac{n(n+1)}{2},\qquad\qquad\qquad i&lt;j \\
\end{cases}\]</span></p>
<p><img src="/assets/resources/Pasted%20image%2020240330224100.png" /></p>
<p>按列存储且数组从1开始索引时： <span class="math inline">\(k=(j-1)(2n-j+2)/2+i-j+1\)</span></p>
<ol start="3" type="1">
<li>上三角矩阵，与下三角相反 <span class="math display">\[k=
\begin{cases}
\frac{(i-1)(2n-i+2)}{2}+(j-i)\qquad i\le{j}\\
\frac{n(n+1)}{2},\qquad\qquad\qquad\qquad i&gt;j \\
\end{cases}\]</span></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240330223751.png" /></p>
<p>按列存储且数组从1开始索引时： <span class="math inline">\(k=j(j-1)/2+i\)</span></p>
<ol type="1">
<li>三对角矩阵，对任意<span class="math inline">\(|i-1|&gt; 1\)</span>有<span class="math inline">\(a_{i,j}=0\)</span></li>
</ol>
<p><span class="math inline">\(i = \left\lfloor(k+1)/3+1\right\rfloor \qquad j = k-2i+3\)</span></p>
<p><img src="/assets/resources/Pasted%20image%2020240330224418.png" /></p>
<ol start="5" type="1">
<li>稀疏矩阵:非零元素远少于零元素的矩阵,用三元组(i,j,value)储存</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240330224753.png" /></p>
<p>也可以用十字链表(行单链表和列单链表)存储</p>
<hr />
<h1 id="树">树</h1>
<ul>
<li>树是递归定义的</li>
<li>一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度</li>
<li>度大于0的结点称为分支结点(又称非终端结点)；度为0 (没有子女结点)的结点称为叶结点(又称终端结点)</li>
<li>结点的层次从树根开始定义，根结点为第1层，它的子结点为第2层，以此类推。双亲在同一层的结点互为堂兄弟</li>
<li>结点的深度是从根结点开始自顶向下逐层累加的。</li>
<li>结点的高度是从叶结点开始自底向上逐层累加的。</li>
<li>树的高度(或深度)是树中结点的最大层数</li>
<li>路径长度是路径上所经过的边的个数</li>
<li>森林是树的集合</li>
</ul>
<p>基本性质：</p>
<ul>
<li>树中的结点数等于所有结点的度数之和加1(根节点)<code>n0+n1+...+nk = n1+2*n2+...+k*nk+1</code></li>
<li>度m的数第i层至多有 <span class="math inline">\(m^{i-1} 且 i\ge1\)</span></li>
<li>高度h的m叉树最多有 <span class="math inline">\((m^{h}-1)/(m-1)\)</span>个结点</li>
<li>n个结点的m叉树最小高度为 <span class="math inline">\(\lceil\log_{m}(n(m-1)+1)\rceil\)</span></li>
</ul>
<h2 id="二叉树">二叉树</h2>
<p>每个结点至多只有两棵子树的树，子树分左右，即使只有一个节点<br />
<img src="/resources/tree.png" /></p>
<p>基本性质：</p>
<ul>
<li>ni表示度i的节点数，则 <code>n0 = n2 + 1</code></li>
<li>非空二叉树第k层最多有 <span class="math inline">\(2^{k-1}\)</span> 个结点</li>
<li>高度h的二叉树至多有<span class="math inline">\(2^h-1个结点\)</span></li>
<li>对完全二叉树编号：
<ul>
<li>当i&gt;1时，结点i的双亲的编号为 <span class="math inline">\(\lfloor i/2 \rfloor\)</span> ，即当i为偶数时，其双亲的编号为i/2,它是双亲的左孩子；当i为奇数时，其双亲的编号为(i-1)/2,它是双亲的右孩子</li>
<li>当 <span class="math inline">\(2i \le n\)</span> 时，结点i的左孩子编号为2i,否则无左孩子</li>
<li>当 <span class="math inline">\(2i+1 \le n\)</span> 时，结点i的右孩子编号为2i+1,否则无右孩子</li>
<li>结点i所在层次(深度)为 <span class="math inline">\(\lfloor\log_{2}i\rfloor+1\)</span></li>
</ul></li>
<li>具有n个(n&gt;0)结点的完全二叉树的高度为 <span class="math inline">\(\lceil\log_{2}(n+1)\rceil\ 或 \lfloor\log_{2}n\rfloor+1\)</span></li>
</ul>
<p><span class="math display">\[2^{h^{-1}}-1\lt n\leqslant2^{h}-1\]</span></p>
<p><strong>存储结构</strong>：</p>
<ol type="1">
<li>顺序存储，一般从1开始索引，a[i]结点的左右子节点分别是a[2i],a[2i+1],父节点(如果存在)是a<a href="向下取整">i/2</a></li>
<li>链式存储,n个结点产生2n个链域，其中n-1个结点占据一个链域(除了根节点)，因此含有n个结点的二叉链表中，含有n + 1个空链域</li>
</ol>
<p>中序加任何一种其他顺序可以确定一颗二叉树，而只知道先后序列不行</p>
<p>基本操作的cpp实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取索引为 i 节点的左子节点的索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取索引为 i 节点的右子节点的索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取索引为 i 节点的父节点的索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; node-&gt;data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    queue&lt;TreeNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();              <span class="comment">// 队列出队</span></span><br><span class="line">        <span class="built_in">visit</span>(node);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非递归实现</span></span><br><span class="line"><span class="comment">思路是通过堆栈不断将优先级高的节点入栈</span></span><br><span class="line"><span class="comment">入栈到尽头时出栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历的非递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder2</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            S.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">visit</span>(p);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历的非递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder2</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p);</span><br><span class="line">            S.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历的非递归算法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">难点在于，首先要把所有左孩子入栈</span></span><br><span class="line"><span class="comment">直到第一个没有左孩子的结点入栈，但此时不能访问</span></span><br><span class="line"><span class="comment">必须确保先把该节点的右孩子(如果存在，且没有访问过)也访问了，再访问该节点</span></span><br><span class="line"><span class="comment">那么，visit有几种情况呢？</span></span><br><span class="line"><span class="comment">1. 叶节点，此时可以放心访问</span></span><br><span class="line"><span class="comment">2. 有右孩子，但右孩子访问过，此时也可以访问</span></span><br><span class="line"><span class="comment">只要确保只在这两种情况下visit，就是安全的后序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder2</span><span class="params">(LinkTree T)</span> </span>&#123;</span><br><span class="line">    LinkTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (T || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(T);</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        &#125;<span class="comment">//一路遍历到没有左孩子，此时可能有右孩子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            T = st.<span class="built_in">top</span>();<span class="comment">//读节点但不弹出</span></span><br><span class="line">            <span class="keyword">if</span> (T-&gt;right &amp;&amp; T-&gt;right != pre) T = T-&gt;right;<span class="comment">//如果有右孩子，且没有访问过，右孩子入栈</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                T = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">visit</span>(T);</span><br><span class="line">                pre = T;</span><br><span class="line">                T = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从数组构建链式树，如果值是INT_MIN则视为nullptr</span></span><br><span class="line"><span class="function">LinkTree <span class="title">build_tree_from_array</span><span class="params">(LinkTree T, <span class="type">int</span> values[], <span class="type">int</span> size, <span class="type">int</span> start = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    T-&gt;data = values[start];</span><br><span class="line">    T-&gt;left = (<span class="built_in">left</span>(start) &lt; size) ? <span class="built_in">build_tree_from_array</span>(<span class="keyword">new</span> TreeNode, values, size, <span class="built_in">left</span>((start))) : <span class="literal">nullptr</span>;</span><br><span class="line">    T-&gt;right = (<span class="built_in">right</span>(start) &lt; size) ? <span class="built_in">build_tree_from_array</span>(<span class="keyword">new</span> TreeNode, values, size, <span class="built_in">right</span>((start))) : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将值是int_min的节点设为空，并回收内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree_helper</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == INT16_MIN) &#123;</span><br><span class="line">        LinkTree temp = T;</span><br><span class="line">        T = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_tree_helper</span>(T-&gt;left);</span><br><span class="line">    <span class="built_in">build_tree_helper</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换给定节点的左右子树</span></span><br><span class="line"><span class="function">LinkTree&amp; <span class="title">exchange_lr</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    LinkTree temp = T-&gt;left;</span><br><span class="line">    T-&gt;left = T-&gt;right;</span><br><span class="line">    T-&gt;right = temp;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线索二叉树">线索二叉树</h3>
<p>n个结点的链式数有n+1个空链接，利用这些指针来存储前驱和后继节点<br />
规定若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点,并用两个tag标记前后驱节点是否启用<br />
tag==0时，表示节点是孩子节点，否则是前后节点<br />
线索二叉树的先驱后继是相对于一种遍历顺序的，例如先序线索时如图： <img src="/assets/resources/Pasted%20image%2020240406214612.png" /> 先序线索二叉树无法确定前驱节点，后序线索二叉树无法确定后继节点<br />
<img src="/assets/resources/Pasted%20image%2020240406220758.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">//数据元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>* lchild, * rchild; <span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="type">bool</span> ltag, rtag; <span class="comment">//左、右线索标志</span></span><br><span class="line">    <span class="built_in">ThreadNode</span>() &#123; lchild = rchild = <span class="literal">NULL</span>; ltag = rtag = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> ThreadTree = ThreadNode*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode* node)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; node-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用中序遍历线索化二叉树</span></span><br><span class="line"><span class="comment">//先序线索化中当ltag==0时才能对左子树先序列线索化,否则可能形成环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;lchild, pre); <span class="comment">//递归，线索化左子树</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p; <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p; <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;rchild, pre); <span class="comment">//递归，线索化右子树</span></span><br><span class="line">    &#125;<span class="comment">//if(p!=NULL)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用中序遍历建立线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatelnThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">//中序遍历的最后一个结点右孩子指针必为空,不需要判空</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求中序线索二叉树中中序序列下的第一个结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">Firstnode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild; <span class="comment">//最左下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求中序线索二叉树中结点p在中序序列下的后继</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">Nextnode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Firstnode</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1 直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不含头结点的中序线索二叉树的中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode* T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadNode* p = <span class="built_in">Firstnode</span>(T);p != <span class="literal">NULL</span>; p = <span class="built_in">Nextnode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;<span class="comment">//左子树</span></span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;        <span class="comment">//建立前</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;               <span class="comment">//标记当</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">PreThread</span>(p-&gt;lchild, pre);</span><br><span class="line">        <span class="built_in">PreThread</span>(p-&gt;rchild, pre);</span><br><span class="line">    &#125;<span class="comment">//if(p!=NULL)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;<span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T, pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(p-&gt;lchild, pre);</span><br><span class="line">        <span class="built_in">PostThread</span>(p-&gt;rchild, pre);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">    &#125;<span class="comment">//if(p!=NULL)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;<span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T, pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note warning"><ul>
<li>后向遍历可以输出子节点到祖先结点的路径</li>
</ul>
</div>
<h2 id="森林">森林</h2>
<p>可以表示任何树的方法：</p>
<ol type="1">
<li><p>双亲表示法：采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置,求结点的孩子时则需要遍历整个结构 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的双亲节点表示法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PTree</span> &#123;</span><br><span class="line">    PTNode nodes[MaxSize];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>孩子表示法，将每个结点的孩子结点都用单链表链接起来，每个结点都有自己的孩子链表(可以为空)，寻找双亲的操作需要遍历</p></li>
<li><p>孩子兄弟表示法,以二叉链表作为树的存储结构,即二叉树的左指针是孩子链表，右指针是兄弟链表，从当前结点查找其双亲结点比较麻烦，<strong>也是树和二叉树相互转化的方法</strong></p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CSNode</span> &#123;</span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span>* firstchild, * nextsibling; <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> CSTree = CSNode*;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/resources/Pasted%20image%2020240409132729.png" /> 任意一棵和树对应的二叉树的右子树必空 <img src="/assets/resources/Pasted%20image%2020240409133039.png" /> <img src="/assets/resources/Pasted%20image%2020240409133312.png" /></p>
<p>森林和二叉树的转化类似树和二叉树，每一棵树转化成二叉树，视为第一个树的兄弟，被连接至根节点的右侧</p>
<ul>
<li>树的遍历分为先根和后根，因为转化成二叉树时根节点只有左子树，所以不需要区分左右</li>
<li>森林的遍历则有先序和中序
<ul>
<li>先序指先访问第一棵树的根节点，然后递归访问其子节点与其他树</li>
<li>中序指先递归访问第一棵树的子节点，然后访问其根节点，最后递归访问其他树</li>
</ul></li>
</ul>
<p>森林的中序也可以理解成后序，因为对每棵树来说，根节点被最后访问</p>
<div class="note warning"><ul>
<li>转换为二叉树时，树的每个分支结点的所有子结点中的最右子结点无右孩子，根结点转换后也没有右孩子，因此，对应二叉树中无右孩子的结点个数=分支结点数+1</li>
</ul>
</div>
<h2 id="树的应用">树的应用</h2>
<p>从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的带权路径长度<br />
含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树,也称最优二叉树<br />
将一段文本的字符频率作为权值的哈夫曼树，则可以用来进行哈夫曼编码，实现文本的压缩传输，这也是cs106b的期末作业，代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作业其实都用的斯坦福自己的数据结构库，相比stl操作更简单</span></span><br><span class="line"><span class="comment">//todo:哪天用stl写一遍</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EncodingTreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    EncodingTreeNode* zero;</span><br><span class="line">    EncodingTreeNode* one;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cal_weightOfInternal</span><span class="params">(<span class="type">const</span> EncodingTreeNode* node , <span class="type">const</span> Map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; &amp;weight)</span></span></span><br><span class="line"><span class="function"><span class="comment">//计算中间节点的权值，weight存放的是文本字符的初始权值(频率)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;one==<span class="literal">nullptr</span>&amp;&amp;node-&gt;zero==<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight[node-&gt;ch];</span><br><span class="line">    &#125;</span><br><span class="line">    sum += <span class="built_in">Cal_weightOfInternal</span>(node-&gt;one,weight);</span><br><span class="line">    sum += <span class="built_in">Cal_weightOfInternal</span>(node-&gt;zero,weight);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EncodingTreeNode* <span class="title">huffmanTreeFor</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; weight;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s :str)</span><br><span class="line">    &#123;</span><br><span class="line">        weight[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(weight.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;<span class="built_in">error</span>(<span class="string">&quot;Should have at least two different character!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;EncodingTreeNode*&gt; PQ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s : weight)</span><br><span class="line">    &#123;</span><br><span class="line">        EncodingTreeNode* TN = <span class="keyword">new</span>  EncodingTreeNode;</span><br><span class="line">        TN-&gt;ch = s; TN-&gt;one = TN-&gt;zero = <span class="literal">nullptr</span>;</span><br><span class="line">        PQ.<span class="built_in">enqueue</span>(TN,weight[s]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(PQ.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> zero = PQ.<span class="built_in">peek</span>();PQ.<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="keyword">auto</span> one = PQ.<span class="built_in">peek</span>();PQ.<span class="built_in">dequeue</span>();</span><br><span class="line">        EncodingTreeNode* internal = <span class="keyword">new</span> EncodingTreeNode;</span><br><span class="line">        internal-&gt;zero = zero;internal-&gt;one = one;internal-&gt;ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">int</span> weightOfInternal = <span class="built_in">Cal_weightOfInternal</span>(internal,weight);</span><br><span class="line">        PQ.<span class="built_in">enqueue</span>(internal,weightOfInternal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> treeroot = PQ.<span class="built_in">peek</span>();</span><br><span class="line">    <span class="keyword">return</span> treeroot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EncodingTreeNode* <span class="title">huffmanTreeFor</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* generate the frequency chart */</span></span><br><span class="line">    PriorityQueue&lt;EncodingTreeNode*&gt; frequency;</span><br><span class="line">    Map&lt;<span class="type">char</span>, <span class="type">double</span>&gt; frequencyMap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> key : str) &#123;</span><br><span class="line">        frequencyMap[key] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (frequencyMap.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;There must be at least two different letters! &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; keys;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> key : frequencyMap) &#123;</span><br><span class="line">        EncodingTreeNode* node = <span class="keyword">new</span> EncodingTreeNode;</span><br><span class="line">        node-&gt;ch = key;</span><br><span class="line">        node-&gt;one = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;zero = <span class="literal">nullptr</span>;</span><br><span class="line">        frequency.<span class="built_in">enqueue</span>(node, frequencyMap[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (frequency.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">double</span> firstweight = frequency.<span class="built_in">peekPriority</span>();</span><br><span class="line">        EncodingTreeNode* firstchoice = frequency.<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="type">double</span> secondweight = frequency.<span class="built_in">peekPriority</span>();</span><br><span class="line">        EncodingTreeNode* secondchoice = frequency.<span class="built_in">dequeue</span>();</span><br><span class="line">        EncodingTreeNode* newNode = <span class="keyword">new</span> EncodingTreeNode;</span><br><span class="line">        newNode-&gt;zero = firstchoice;</span><br><span class="line">        newNode-&gt;one = secondchoice;</span><br><span class="line">        frequency.<span class="built_in">enqueue</span>(newNode, firstweight + secondweight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frequency.<span class="built_in">dequeue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeaf</span><span class="params">(EncodingTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;one == <span class="literal">nullptr</span> &amp;&amp; tree-&gt;zero == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRightPath</span><span class="params">(<span class="type">const</span> <span class="type">char</span> letter, EncodingTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLeaf</span>(tree) &amp;&amp; tree-&gt;ch == letter) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isRightPath</span>(letter, tree-&gt;one) || <span class="built_in">isRightPath</span>(letter, tree-&gt;zero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">decodeText</span><span class="params">(Queue&lt;Bit&gt;&amp; bits, EncodingTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    string origin = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!bits.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        EncodingTreeNode* curNode = tree;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isLeaf</span>(curNode)) &#123;</span><br><span class="line">            Bit label = bits.<span class="built_in">dequeue</span>();</span><br><span class="line">            <span class="comment">/* choose one branch*/</span></span><br><span class="line">            <span class="keyword">if</span> (label == <span class="number">1</span>) &#123;</span><br><span class="line">                curNode = curNode-&gt;one;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (label == <span class="number">0</span>) &#123;</span><br><span class="line">                curNode = curNode-&gt;zero;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* read only on leaves */</span></span><br><span class="line">        origin += curNode-&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue&lt;Bit&gt; <span class="title">encodeText</span><span class="params">(<span class="type">const</span> string&amp; str, EncodingTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Bit&gt; code;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> value : str) &#123;</span><br><span class="line">        EncodingTreeNode* curNode = tree;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isLeaf</span>(curNode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isRightPath</span>(value, curNode-&gt;zero)) &#123;</span><br><span class="line">                code.<span class="built_in">enqueue</span>(<span class="number">0</span>);</span><br><span class="line">                curNode = curNode-&gt;zero;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isRightPath</span>(value, curNode-&gt;one)) &#123;</span><br><span class="line">                code.<span class="built_in">enqueue</span>(<span class="number">1</span>);</span><br><span class="line">                curNode = curNode-&gt;one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集">并查集</h3>
<p>简单地说并查集就是用数组树来表示的集合，其基本操作如下 <img src="/assets/resources/Pasted%20image%2020240410171546.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> UFSets[MaxSize]; <span class="comment">//集合元素数组(双亲指针数组)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> S[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) <span class="comment">//每个自成单元素集合</span></span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//返回元素x的根(对应索引必然小于0)</span></span><br><span class="line">    <span class="keyword">while</span> (S[x] &gt;= <span class="number">0</span>) <span class="comment">//循环寻找x的根</span></span><br><span class="line">        x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//根的 S[]小于 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> </span>&#123;<span class="comment">//求两个不相交集合的并集</span></span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2) <span class="keyword">return</span>; <span class="comment">//要求 Root1 与 Root2 是不同的集合</span></span><br><span class="line">    S[Root2] = Root1; <span class="comment">//将根 Root2 连接到另一根 Root1 下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><ul>
<li>可用于实现克鲁斯卡尔算法(判断是否加入一条边之前，先查找这条边关联的两个顶点是否属于同一个集合)<br />
</li>
<li>可用于判断无向图的连通性,即整个图遍历后，连通分量一一对应集合</li>
<li>可用二叉树检查编码是否满足前缀不重复特性，即只有编码树的叶节点能对应被编码的一个字符</li>
</ul>
</div>
<p>练习题汇总： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.找到顺序存储二叉树的公共父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_public_parent</span><span class="params">(Arraytree T, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || j &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) i = <span class="built_in">parent</span>(i);</span><br><span class="line">        <span class="keyword">else</span> j = <span class="built_in">parent</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == j &amp;&amp; i &gt; <span class="number">0</span>) <span class="keyword">return</span> T.data[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.二叉树的自下而上、从右到左的层次遍历算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev_levelOrder</span><span class="params">(LinkTree T)</span> </span>&#123;<span class="comment">//相当于层次遍历的相反顺序，即用栈来存储队列遍历产生的结果</span></span><br><span class="line">    stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    queue&lt;LinkTree&gt; qe;</span><br><span class="line">    qe.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = qe.<span class="built_in">front</span>();</span><br><span class="line">        qe.<span class="built_in">pop</span>();</span><br><span class="line">        stack.<span class="built_in">push</span>(node);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            qe.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            qe.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(stack.<span class="built_in">top</span>());</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.递归求二叉树高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(LinkTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(T-&gt;left), <span class="built_in">height</span>(T-&gt;right)) + <span class="number">1</span>;<span class="comment">//优雅的两行实现，但不是尾递归？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.非递归算法求二叉树的高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height2</span><span class="params">(LinkTree T)</span> </span>&#123;<span class="comment">//层序遍历中存储每层最右侧指针，每次出队元素和最右侧指针相同时，高度++</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">    TreeNode* last = T;</span><br><span class="line">    queue&lt;LinkTree&gt; qe;</span><br><span class="line">    qe.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        LinkTree node = qe.<span class="built_in">front</span>();</span><br><span class="line">        qe.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) qe.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) qe.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node == last) &#123;</span><br><span class="line">            height++;</span><br><span class="line">            last = qe.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.先序遍历序列和中序遍历序列分别存于两个一维数组,构建二叉树</span></span><br><span class="line"><span class="function">LinkTree <span class="title">build_tree_from_pre_and_in</span><span class="params">(<span class="type">int</span> pre[], <span class="type">int</span> in[], <span class="type">int</span> pre1, <span class="type">int</span> pre2, <span class="type">int</span> in1, <span class="type">int</span> in2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pre1,pre2分别是先序的第一和最后一个节点下标</span></span><br><span class="line">    LinkTree root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    root-&gt;data = pre[pre1];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = in1;in[i] != root-&gt;data;i++);<span class="comment">//找到根节点来划分左右子树</span></span><br><span class="line">    <span class="type">int</span> left_len = i - in1;</span><br><span class="line">    <span class="type">int</span> right_len = in2 - i;</span><br><span class="line">    <span class="keyword">if</span> (left_len != <span class="number">0</span>) root-&gt;left = <span class="built_in">build_tree_from_pre_and_in</span>(pre, in, pre1 + <span class="number">1</span>, pre1 + left_len, in1, in1 + left_len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (right_len != <span class="number">0</span>) root-&gt;right = <span class="built_in">build_tree_from_pre_and_in</span>(pre, in, pre2 - right_len + <span class="number">1</span>, pre2, in2 - right_len + <span class="number">1</span>, in2);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.判别给定二叉树是否是完全二叉树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_complete</span><span class="params">(LinkTree T)</span> </span>&#123;</span><br><span class="line">    queue&lt;LinkTree&gt; qe;</span><br><span class="line">    qe.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        LinkTree node = qe.<span class="built_in">front</span>();</span><br><span class="line">        qe.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            qe.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            qe.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (qe.<span class="built_in">front</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                qe.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.求给定二叉树的所有双分支结点个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num_of_twinnode</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;<span class="comment">//优雅的递归</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;left &amp;&amp; T-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">num_of_twinnode</span>(T-&gt;left) + <span class="built_in">num_of_twinnode</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">num_of_twinnode</span>(T-&gt;left) + <span class="built_in">num_of_twinnode</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.交换所有结点的左右子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_lr</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">swap_lr</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">swap_lr</span>(T-&gt;right);</span><br><span class="line">        LinkTree L = T-&gt;left;</span><br><span class="line">        T-&gt;left = T-&gt;right;</span><br><span class="line">        T-&gt;right = L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.求先序遍历序列中第k个节点的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">preOrder_kth_node</span><span class="params">(LinkTree T, <span class="type">int</span>&amp; i, <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> INT32_MIN;<span class="comment">//输入不合理，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (k == i) <span class="keyword">return</span> T-&gt;data;<span class="comment">//由于每次递归i只+1,因此达到k时必然立刻返回</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;left) val = <span class="built_in">preOrder_kth_node</span>(T-&gt;left, ++i, k);<span class="comment">//存储对左子树遍历后的值</span></span><br><span class="line">    <span class="keyword">if</span> (i == k) <span class="keyword">return</span> val;<span class="comment">//如果遍历完左子树，且i==k,那么返回值必然是ith节点的data</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;right) <span class="keyword">return</span> <span class="built_in">preOrder_kth_node</span>(T-&gt;right, ++i, k);<span class="comment">//如果右孩子不空，才可以++i</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> INT16_MIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.对于树中每个元素值为x的结点，删除以x为根的子树，并释放相应的空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_val_x_node_helper</span><span class="params">(LinkTree&amp; T, <span class="type">int</span>&amp; x, LinkTree&amp; pre, <span class="type">bool</span> is_lft)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">del_val_x_node_helper</span>(T-&gt;left, x, T, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">del_val_x_node_helper</span>(T-&gt;right, x, T, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) &#123;</span><br><span class="line">        <span class="built_in">del_node</span>(T);<span class="comment">//递归删除T的所有子节点</span></span><br><span class="line">        <span class="keyword">if</span> (is_lft) pre-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> pre-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_val_x_node</span><span class="params">(LinkTree&amp; T, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) <span class="built_in">del_node</span>(T);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">del_val_x_node_helper</span>(T-&gt;left, x, T, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">del_val_x_node_helper</span>(T-&gt;right, x, T, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.打印值为x的结点的所有祖先，假设值为x的结点不多于一个</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">print_ancestor_helper</span><span class="params">(LinkTree&amp; T, <span class="type">int</span>&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_ancestor_of_xval</span><span class="params">(LinkTree&amp; T, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_ancestor_helper</span>(T, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">print_ancestor_helper</span><span class="params">(LinkTree&amp; T, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归返回true表示该节点的子节点中有x节点，因此可以打印，否则不能打印</span></span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> val1 = <span class="built_in">print_ancestor_helper</span>(T-&gt;left, x);</span><br><span class="line">    <span class="keyword">if</span> (val1 == <span class="number">1</span>) cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="type">bool</span> val2 = <span class="built_in">print_ancestor_helper</span>(T-&gt;right, x);</span><br><span class="line">    <span class="keyword">if</span> (val2 == <span class="number">1</span>) cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> val1 || val2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现用到栈，访问到值为x的结点时，栈中所有元素均为该结点的祖先，依次出栈打印</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//11.p和q分别为指向该二叉树中任意两个结点的指针,寻找其最近公共祖先</span></span><br><span class="line"><span class="comment">//祖先有两种可能：1.该节点左右子树各自存在pq 2.节点本身是p或q且其左子树或右子树有另一个孩子节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ancestor_helper</span><span class="params">(LinkTree tree, LinkTree&amp; p, LinkTree&amp; q, LinkTree&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> is_lft_son = <span class="built_in">ancestor_helper</span>(tree-&gt;left, p, q, res);</span><br><span class="line">    <span class="type">bool</span> is_rht_son = <span class="built_in">ancestor_helper</span>(tree-&gt;right, p, q, res);</span><br><span class="line">    <span class="keyword">if</span> ((is_lft_son &amp;&amp; is_rht_son) || ((tree-&gt;data == p-&gt;data || tree-&gt;data == q-&gt;data) &amp;&amp; (is_lft_son || is_rht_son))) &#123;</span><br><span class="line">        res = tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_lft_son || is_rht_son || (tree-&gt;data == p-&gt;data || tree-&gt;data == q-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkTree <span class="title">find_ancestor_root</span><span class="params">(LinkTree root, LinkTree p, LinkTree q)</span> </span>&#123;</span><br><span class="line">    LinkTree res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">ancestor_helper</span>(root, p, q, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12.求非空二叉树的宽度(结点数最多的一层的结点个数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width_of_tree</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_layer = <span class="number">1</span>;</span><br><span class="line">    queue&lt;LinkTree&gt; qe;</span><br><span class="line">    queue&lt;LinkTree&gt; next_qe;</span><br><span class="line">    qe.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            LinkTree t = qe.<span class="built_in">front</span>();</span><br><span class="line">            qe.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) next_qe.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) next_qe.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next_qe.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">        max_layer = <span class="built_in">max</span>(<span class="built_in">int</span>(next_qe.<span class="built_in">size</span>()), max_layer);</span><br><span class="line">        qe = next_qe;</span><br><span class="line">        <span class="keyword">while</span> (!next_qe.<span class="built_in">empty</span>()) next_qe.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//13.一棵满二叉树(所有结点值均不同),已知其先序序列为pre,求其后序序列post。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_post_from_pre</span><span class="params">(<span class="type">int</span> pre[], <span class="type">int</span> l1, <span class="type">int</span> h1, <span class="type">int</span> post[], <span class="type">int</span> l2, <span class="type">int</span> h2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> half;</span><br><span class="line">    <span class="keyword">if</span> (h1 &gt;= l1) &#123;</span><br><span class="line">        post[h2] = pre[<span class="number">11</span>];</span><br><span class="line">        half = (h1 - l1) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">find_post_from_pre</span>(pre, <span class="number">11</span> + <span class="number">1</span>, <span class="number">11</span> + half, post, <span class="number">12</span>, <span class="number">12</span> + half - <span class="number">1</span>); <span class="comment">//转换左子树</span></span><br><span class="line">        <span class="built_in">find_post_from_pre</span>(pre, <span class="number">11</span> + half + <span class="number">1</span>, h1, post, <span class="number">12</span> + half, h2 - <span class="number">1</span>); <span class="comment">//转换右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14.将二叉树的叶结点按从左到右的顺序连成一个带头结点单链表，表头指针为head，叶结点的右指针域来存放单链表指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_to_link_helper</span><span class="params">(LinkTree t, LinkTree&amp; tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right) &#123;</span><br><span class="line">        tail-&gt;right = t;</span><br><span class="line">        tail = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">tree_to_link_helper</span>(t-&gt;left, tail);</span><br><span class="line">        <span class="built_in">tree_to_link_helper</span>(t-&gt;right, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkTree <span class="title">tree_to_link</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    LinkTree head = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    LinkTree tail = head;</span><br><span class="line">    head-&gt;data = INT16_MIN;</span><br><span class="line">    head-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    head-&gt;right = tail;</span><br><span class="line">    <span class="built_in">tree_to_link_helper</span>(T, tail);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*15.判断二叉树是否相似，相似的定义：</span></span><br><span class="line"><span class="comment">T1和T2都是空的二叉树或都只有一个根结点；</span></span><br><span class="line"><span class="comment">或者T1的左子树和T2的左子树相似，且T1的右子树和T2的右子树相似</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_tree_similar</span><span class="params">(LinkTree&amp; T1, LinkTree&amp; T2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T1 &amp;&amp; !T2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!T1 || !T2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> if_tree_similar(T1-&gt;left, T2-&gt;left) &amp;&amp; if_tree_similar(T1-&gt;right, T2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//真题1.求出二叉树中所有叶结点的带权路径长度之和,需要权值乘层高</span></span><br><span class="line"><span class="comment">//视data为weight</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum_weight_helper</span><span class="params">(LinkTree t, <span class="type">int</span>&amp; sum, <span class="type">int</span> path_weight, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right) &#123;</span><br><span class="line">        sum += path_weight + t-&gt;data * depth;</span><br><span class="line">    &#125;</span><br><span class="line">    path_weight += t-&gt;data * depth;</span><br><span class="line">    <span class="built_in">sum_weight_helper</span>(t-&gt;left, sum, path_weight, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sum_weight_helper</span>(t-&gt;right, sum, path_weight, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_weight</span><span class="params">(LinkTree&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sum_weight_helper</span>(t, w, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16.在中序线索二叉树里查找指定结点在后序的前驱结点</span></span><br><span class="line"><span class="function">ThreadTree <span class="title">find_pre_node</span><span class="params">(ThreadTree&amp; t, ThreadTree&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在中序线索二叉树t中，求指定结点p在后序下的前驱结点q</span></span><br><span class="line">    ThreadTree q;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) <span class="comment">//若p有右子女，则右子女是其后序前驱</span></span><br><span class="line">        q = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>) <span class="comment">//若p只有左子女，则左子女是其后序前驱</span></span><br><span class="line">        q = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">        q = <span class="literal">NULL</span>; <span class="comment">//p是中序序列第一结点，无后序前驱</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//顺左线索向上找p的祖先，若存在，再找祖先的左子女</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;ltag == <span class="number">1</span> &amp;&amp; p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            q = p-&gt;lchild; <span class="comment">//p结点的祖先的左子女是其后序前驱</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q = <span class="literal">NULL</span>; <span class="comment">//仅有单支树(p是叶子)，己到根结点，p无后序前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<hr />
<h1 id="图">图</h1>
<p>图G由顶点集V和边集E组成，即G=(V,E)<br />
其中，E的组成是(u,v)<br />
可分为有向和无向图</p>
<ul>
<li>有向图的边用&lt;1,2&gt;表示</li>
<li>无向图的边用(1,2)表示</li>
<li>不存在重复边，没有连接自己的边的图是简单图</li>
<li>某两个顶点之间的边数大于1条，又允许顶点通过一条边和自身关联，则称图G为多重图</li>
<li>对无向图，任意两个结点都有边连接的无向图称为完全图，即n(n-1)/2条边，有向完全图的边数则是完全图边数的翻倍</li>
<li>V和E的子集构成的图(必须能构成图)，是原图的子图，若两者的V相等，则称为生成子图</li>
<li>极大连通子图是无向图的连通分量、极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。</li>
<li>无向图中，任意两个节点连通(存在路径)的图是连通图,无向图中的极大连通子图称为连通分量</li>
<li>在有向图中，如果有一对顶点V和W,从V到W和从W到V间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量</li>
<li>连通图的生成树是包含图中全部顶点的一个极小连通子图(n-1条边),减少一条边则不连通，增加一条边则形成环</li>
<li>无向图中顶点v的度是指依附于顶点v的边的条数，即TD(v)，无向图的全部顶点的度的和等于边数的2倍</li>
<li>有向图的全部顶点的入度之和与出度之和相等，并且等于边数</li>
<li>边有权的图称为带权图(网)</li>
<li>稀疏和稠密是相对概念，一般VlogV是分界点</li>
<li>若一个图有n个顶点，并且有大于n-1条边，则此图一定有环</li>
<li>顶点不重复出现的路径称为简单路径,除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路</li>
<li>两个结点间最短路径的长度是两者的距离，不连通时为无穷</li>
<li>一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树</li>
</ul>
<h2 id="存储">存储</h2>
<h3 id="邻接矩阵法">邻接矩阵法</h3>
<p>一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息<br />
<code>A[i][j]</code>可以表示边是否存在(1/0)，也可以表示权值(此时0/无穷表示不存在)<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> VertexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> EdgeType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix_Graph</span> &#123;</span><br><span class="line">    VertexType Vex[MaxVertexNum];</span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <img src="/assets/resources/Pasted%20image%2020240411170810.png" /></p>
<ul>
<li>对无向图来说，可以用上三角矩阵储存边，其第i行或列的边数量就是顶点i的度<br />
</li>
<li>对有向图来说，第i行非零元素的个数正好是顶点i的出度，第i列则是其入度</li>
<li>易于检测节点间关系，但边需要遍历</li>
<li>适合稠密图</li>
</ul>
<h3 id="邻接表法">邻接表法</h3>
<p>每个顶点V建立一个单链表，第i个单链表中的结点表示依附顶点Vi的边(对于有向图则是以顶点Vi为尾的弧)，这个单链表就称为顶点Vi的边表(对于有向图则称为出边表)<br />
同时需要顶点表存储顶点，与边表区分 <img src="/assets/resources/Pasted%20image%2020240411171623.png" /> <img src="/assets/resources/Pasted%20image%2020240411171432.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix_Graph</span> &#123;</span><br><span class="line">    VNodeType Vex[MaxVertexNum];</span><br><span class="line">    EdgeType Edge[MaxVNodeNum][MaxVertexNum]; <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VNode</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123; <span class="comment">//边表结点</span></span><br><span class="line">    VNode* adjvex; <span class="comment">//该弧所指向的顶点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span>* next; <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info; //网的边权值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VNode</span> &#123; <span class="comment">//顶点表结点</span></span><br><span class="line">    VNodeType no; <span class="comment">//顶点编号</span></span><br><span class="line">    ArcNode* first; <span class="comment">//指向第一条依附该项点的弧的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ALGraph</span> &#123;</span><br><span class="line">    VNode vertices[MaxVNodeNum]; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> GraphAdjList = ALGraph;</span><br><span class="line"><span class="keyword">using</span> Vertex = VNode;</span><br><span class="line"></span><br><span class="line"><span class="function">ALGraph <span class="title">build_graph</span><span class="params">(<span class="type">int</span> V[], pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; edges[], <span class="type">int</span> V_size, <span class="type">int</span> e_size)</span> </span>&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    G.vexnum = V_size;G.arcnum = e_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++) &#123;</span><br><span class="line">        VNode v;</span><br><span class="line">        v.no = i;</span><br><span class="line">        v.first = <span class="literal">nullptr</span>;</span><br><span class="line">        G.vertices[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.arcnum;i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> e = edges[i];</span><br><span class="line">        ArcNode* arc = <span class="keyword">new</span> ArcNode;</span><br><span class="line">        arc-&gt;adjvex = &amp;G.vertices[e.second];</span><br><span class="line">        arc-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> temp = G.vertices[e.first].first;</span><br><span class="line">        G.vertices[e.first].first = arc;</span><br><span class="line">        G.vertices[e.first].first-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_graph</span><span class="params">(ALGraph G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = G.vertices[i].first;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p-&gt;adjvex-&gt;no &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无向图的存储空间O(V+2E),有向图是O(V+E)</li>
<li>适合稀疏图</li>
<li>容易找到一个顶点的所有邻居，但难以判断给定两节点关系</li>
<li>求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表(逆邻接表相反)</li>
<li>链接次序任意，因此不唯一</li>
</ul>
<h3 id="十字链表">十字链表</h3>
<p><strong>有向图的存储结构</strong><br />
在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点,顶点结点之间是顺序存储的<br />
弧结点中：</p>
<ul>
<li>tailvex和headvex两个域分别指示弧尾和弧头这两个顶点的编号</li>
<li>hlink域指向弧头相同的下一个弧结点</li>
<li>tlink域指向弧尾相同的下一个弧结点</li>
<li>info域存放该弧的相关信息<br />
</li>
<li>弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上</li>
</ul>
<p>顶点结点中：</p>
<ul>
<li>data域存放该顶点的数据信息，如顶点名称</li>
<li>firstin域指向以该顶点为弧头的第一个弧结点</li>
<li>firstout域指向以该顶点为弧尾的第一个弧结点</li>
</ul>
<p>容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示确定一个图<br />
<img src="/assets/resources/Pasted%20image%2020240411172832.png" /> <img src="/assets/resources/Pasted%20image%2020240411172839.png" /></p>
<h3 id="邻接多重表">邻接多重表</h3>
<p><strong>无向图的存储结构</strong><br />
所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点,因此每个边结点同时链接在两个链表中</p>
<p><img src="/assets/resources/Pasted%20image%2020240411173500.png" /> <img src="/assets/resources/Pasted%20image%2020240411173625.png" /></p>
<h3 id="基本操作-1">基本操作</h3>
<ul>
<li>Adjacent (G, x, y):判断图G是否存在边(x,y)</li>
<li>Neighbors (G, x):列出图G中与结点x邻接的边</li>
<li>InsertVertex (G, x):在图 G 中插入顶点 x</li>
<li>DeleteVertex (G, x):从图 G 中删除顶点 x</li>
<li>AddEdge (G, x, y)：若无向边(x,y)或有向边<code>&lt;x,y&gt;</code>不存在，则向图G中添加该边</li>
<li>RemoveEdge (G, x, y):若无向边(x,y)或有向边<code>&lt;x,y&gt;</code>存在，则从图G中删除该边</li>
<li>FirstNeighbor (G, x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x,则返回-1</li>
<li>NextNeighbor (G, x, y):假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</li>
<li>Get_edge_value (G, x, y)：获取图G中边(x,y)或对应的权值</li>
<li>Set_edge_value (G, x, y, v):设置图G中边(x,y)对应的权值为v</li>
</ul>
<div class="note warning"><ul>
<li>有向图的邻接表存储结构中，<strong>顶点V在边表中出现的次数是顶点v的入度</strong>(题中的边表不包括顶点表,任何顶点u对应的边表中存放的都是以u为起点的边所对应的另一个顶点V)</li>
<li>邻接矩阵<span class="math inline">\(A^m\)</span>的i行j列节点的值，是i节点到j节点长度为m的路径数</li>
</ul>
</div>
<h2 id="遍历">遍历</h2>
<p>BFS/DFS中邻接表的时间复杂度是O(V+E),邻接矩阵的时间复杂度是O(<span class="math inline">\(V^2\)</span>)</p>
<ul>
<li>广度遍历是分层查找，需要使用队列
<ul>
<li>邻接矩阵查找每个结点的邻边需要O(V)邻接表为O(E)</li>
<li>使用BFS可以求解非带权图的单源最短路径问题</li>
<li>广度遍历的过程中可以得到一棵遍历树，称为广度优先生成树，其是否唯一取决于邻接表和矩阵存储表示是否唯一</li>
</ul></li>
<li>深度遍历需要使用栈或者递归
<ul>
<li>基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的</li>
<li>空间复杂度为O(V)</li>
<li>对连通图调用DFS才能产生深度优先生成树，否则会得到森林，这样的生成不唯一</li>
<li>DFS可以得到一个拓扑排序序列</li>
<li>可用于检测环，如果遍历时遇到已经访问的结点，则有环</li>
</ul></li>
</ul>
<p>很容易看出非连通图的遍历可能需要进行多次，一般通过循环实现<br />
hello-algo的比较规范的实现：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 广度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line"><span class="function">vector&lt;Vertex*&gt; <span class="title">graphBFS</span><span class="params">(GraphAdjList&amp; graph, Vertex* startVet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;Vertex*&gt; res;</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    set&lt;Vertex*&gt; visited = &#123; startVet &#125;;</span><br><span class="line">    <span class="comment">// 队列用于实现 BFS</span></span><br><span class="line">    queue&lt;VNode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(startVet);</span><br><span class="line">    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Vertex* vet = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();          <span class="comment">// 队首顶点出队</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(vet); <span class="comment">// 记录访问顶点</span></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">auto</span> adjVet = vet-&gt;first;</span><br><span class="line">        <span class="keyword">while</span> (adjVet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(adjVet-&gt;adjvex)) &#123;</span><br><span class="line">                adjVet = adjVet-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;            <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push</span>(adjVet-&gt;adjvex);        <span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">            visited.<span class="built_in">emplace</span>(adjVet-&gt;adjvex); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">            adjVet = adjVet-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历辅助函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ALGraph&amp; graph, set&lt;VNode*&gt;&amp; visited, vector&lt;VNode*&gt;&amp; res, VNode* vet)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(vet);   <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.<span class="built_in">emplace</span>(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">auto</span> adjVet = vet-&gt;first;</span><br><span class="line">    vector&lt;VNode*&gt; temp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (adjVet) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(adjVet-&gt;adjvex);</span><br><span class="line">        adjVet = adjVet-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> V : temp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">count</span>(V))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, visited, res, V); <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line"><span class="function">vector&lt;VNode*&gt; <span class="title">graphDFS</span><span class="params">(ALGraph&amp; graph, VNode* startVet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;VNode*&gt; res;</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    set&lt;VNode*&gt; visited;</span><br><span class="line">    <span class="built_in">dfs</span>(graph, visited, res, startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="应用">应用</h2>
<h3 id="最小生成树">最小生成树</h3>
<p>生成树是指一个图连接所有节点的，且边数为n-1的子图<br />
边的权值之和最小的生成树即为图的最小生成树，树形不唯一，但权值的和唯一(即所有权值不相等时树形也唯一)<br />
有多种算法，普遍思路是从最小边开始贪心</p>
<ol type="1">
<li>prim算法，由于用c++写出过于复杂，以下仅文字描述
<ol type="1">
<li>加入一个随机未访问节点</li>
<li>选取起始顶点已访问，指向顶点未访问的边中权值最小的，加入树</li>
<li>重复2.直到访问所有节点</li>
<li>时间复杂度O( <span class="math inline">\(V^2\)</span> ),适合密集图</li>
</ol></li>
<li>Kruskal算法
<ol type="1">
<li>初始化一个边集为空</li>
<li>从图取出权值最小的边，若两点不都被访问过，加入边集</li>
<li>重复2.直到边集有n-1条边</li>
<li>如果用最小堆实现，则复杂度O( <span class="math inline">\(E\log_{2}E\)</span> )，适合稀疏图</li>
</ol></li>
</ol>
<h3 id="带权图的最短路径">带权图的最短路径</h3>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html">演示地址</a></p>
<ol type="1">
<li>迪杰斯特拉算法(猎魔人那个)，属于一种贪心算法
<ol type="1">
<li>初始化dist和path数组,前者记录v0到vi的最短路径长，初始化为两者边长或无穷(出发点一般是0)；后者记录源点到顶点vi之间的最短路径的前驱结点</li>
<li>选出当前已知且未访问过的最短路径终点Vj,标记访问</li>
<li>进行所谓的放松操作，就是查看j的可达节点k，经过j的路径是否比dist数组中的<code>dist[k]</code>小，如果小就更新dist</li>
<li>重复2.3.一共n-1次，即访问所有节点</li>
<li>时间复杂度O(<span class="math inline">\(V^2\)</span>)</li>
<li>在加入的过程中，由于每次选最小边，总保持从源点v到已访问顶点集s中各顶点的最短路径长度不大于从源点v到未访问顶点集中任何顶点的最短路径长度，即s中顶点已经求到其最短路径，而负权值会打破这个条件</li>
</ol></li>
<li>Floyd算法
<ol type="1">
<li>设置矩阵序列A0~Ak,其中 <span class="math inline">\(A^{(k)}[i][j]\)</span> 表示元素i到j,考虑序号小于k的中间节点的最短路径长度，即迭代到n-1时得出整个图的最短路径(节点序号从0索引)，k=-1时表示i-&gt;j直接路径或正无穷</li>
<li>即每次迭代时k+1, <span class="math inline">\(A^{(k)}[i][j]=\mathrm{Min}\{A^{(k-1)}[i][j],\ A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},\quad k=0,1,\cdots,n-1\)</span> ，这样每次迭代就多考虑一个中间节点</li>
<li>时间复杂度为O( <span class="math inline">\(V^3\)</span>),但常数系数较小，输入中等规模时很有效，允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路；同样适用于带权无向图</li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240508204456.png" /></p>
<h3 id="拓扑排序">拓扑排序</h3>
<p>有向无环图DAG可以用于简化存储空间(dag表示的表达式不可能出现重复的操作数顶点) <img src="/assets/resources/Pasted%20image%2020240510115617.png" /></p>
<p>AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边<code>&lt;Vi,Vj&gt;</code>表示活动Vi必须先于活动Vj，则将这种有向图称为顶点表示活动的网络，记为AOV网.活动Vi是活动Vj的直接前驱，活动Vj是活动Vi的直接后继，这种前驱和后继关系具有传递性，且任何活动不能以它自己作为自己的前驱或后继</p>
<p>一个由DAG图中全部节点构成的无重复序列，且若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径，那么这个序列就是一个拓扑排序<br />
深度遍历会直接产生一个拓扑排序，此外的常见思路：</p>
<ol type="1">
<li>从AOV网中选择一个没有前驱的顶点并输出</li>
<li>从网中删除该顶点和所有以它为起点的有向边</li>
<li>重复1.和2.直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环</li>
</ol>
<p>cpp实现：<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G, <span class="type">int</span> indegree[])</span> </span>&#123;</span><br><span class="line">    vector&lt;VNode*&gt; res;</span><br><span class="line">    stack&lt;VNode*&gt; s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            s.<span class="built_in">push</span>(&amp;G.vertices[i]);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        VNode* i = s.<span class="built_in">top</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ++count;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ArcNode* p = i-&gt;first;<span class="comment">//将所有i指向的顶点的入度减1,并且将入度减为0的顶点压入栈S</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            --indegree[p-&gt;adjvex-&gt;no];</span><br><span class="line">            <span class="keyword">if</span> (indegree[p-&gt;adjvex-&gt;no] == <span class="number">0</span>) s.<span class="built_in">push</span>(p-&gt;adjvex);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于输出每个顶点的同时还要删除以它为起点的边，故采用邻接表存储时拓扑排序的时间复杂度为O(V+E),采用邻接矩阵存储时拓扑排序的时间复杂度为O(<span class="math inline">\(V^2\)</span>)</p>
<p>逆拓扑排序：</p>
<ol type="1">
<li>从AOV网中选择一个没有后继(出度为0)的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为终点的有向边。</li>
<li>重复1.和2.直到当前的AOV网为空</li>
</ol>
<ul>
<li>每个顶点有唯一的前驱后继关系时，拓扑排序的结果是唯一的</li>
<li>由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立</li>
</ul>
<h3 id="关键路径">关键路径</h3>
<p>带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销(如完成活动所需的时间)，称之为用边表示活动的网络，简称AOE网</p>
<ol type="1">
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li>
<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生</li>
<li>AOE网中仅有一个入度为0的顶点，称为开始顶点(源点)，它表示整个工程的开始；网中也仅存在一个出度为0的顶点，称为结束顶点(汇点)，它表示整个工程的结束</li>
</ol>
<p>从源点到汇点的所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为关键活动，关键路径代表完成整个工程的最短时间<br />
一些关键名词：</p>
<ol type="1">
<li><p>事件vk的最早发生时间ve(k)<br />
<span class="math inline">\(\nu e(k)=\mathrm{Max}\left\{\nu\mathrm{e}(j)+\mathrm{Weight}(\nu_{j},\,\nu_{k})\right\}\)</span><br />
vk是vj的任意后缀节点<br />
按从前往后的顺序进行，可以在拓扑排序的基础上计算</p></li>
<li><p>事件vk的最迟发生时间vl(k)<br />
在不推迟整个工程完成的前提下，即保证它的后继事件vj在其最迟发生时间vl(j)能够发生时，该事件最迟必须发生的时间<br />
<span class="math inline">\(\nu l(k)=\mathrm{Min}\left\{\nu l(j)-\mathrm{Weight}(\nu_{k},\,\nu_{j})\right\}\)</span><br />
设一个栈以记录拓扑序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列,可以逆拓扑序列进行vl的计算</p></li>
<li><p>活动ai的最早开始时间e(i),即该活动弧的起点所表示的事件的最早发生时间,若边<code>&lt;vk,vj&gt;</code>表示活动ai,则有e(i) = ve(k)</p></li>
<li><p>活动ai的最迟开始时间l(i),即该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边<code>&lt;vk,vj&gt;</code>表示活动ai,则有 <span class="math inline">\(l(i)=v l(j)-\operatorname{Weight}(\nu_{k},\,\nu_{j})\)</span></p></li>
<li><p>一个活动ai的最迟开始时间l(i)和其最早开始时间e(i)的差d(i)=l(i)-e(i)<br />
指该活动完成的时间余量,为0的活动需要立即完成，称为关键活动</p></li>
</ol>
<ol type="1">
<li>从源点出发，令ve(源点)= 0,按拓扑有序求其余顶点的最早发生时间ve()</li>
<li>从汇点出发，令vl(汇点)= ve(汇点)，按逆拓扑有序求其余顶点的最迟发生时间vl()</li>
<li>根据各顶点的ve()值求所有弧的最早开始时间e()</li>
<li>根据各顶点的vl()值求所有弧的最迟开始时间l()</li>
<li>求AOE网中所有活动的差额d(),找出所有d() = 0的活动构成关键路径</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240511113354.png" /> 关键路径上的所有活动都是关键活动,网中的关键路径并不唯一,加快那些包括在所有关键路径上的关键活动才一定能达到缩短工期的目的</p>
<div class="note warning"><ul>
<li>若一个有向图的顶点不能排成一个拓扑序列,则含有顶点数大于1的强连通分量</li>
<li>对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元全为零的充分必要条件是，该有向图可以进行拓扑排序</li>
</ul>
</div>
<hr />
<h1 id="查找">查找</h1>
<ul>
<li>在数据集合中寻找满足某种条件的数据元素的过程称为查找</li>
<li>用于查找的数据集合称为查找表,根据是否可以增加删除元素分为静态和动态</li>
<li>数据元素中唯一标识该元素的某个数据项的值是关键字</li>
<li>一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，定义为：<span class="math inline">\(\mathrm{ASL}=\sum_{i=1}^{n}P_{i}C_{i}\)</span></li>
<li>用于指示查找边界的特殊数据元素称为哨兵，例如数组末尾放置一个正无穷表示结束</li>
</ul>
<p>给定n个元素的线性表，定位第i个元素时,需进行<code>n-i + 1</code>次比较，设n是查找表的长度;Pi是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即Pi=1/n; Ci是找到第i个数据元素所需进行的比较次数,平均长度为:<br />
<span class="math inline">\(\mathrm{ASL}_{\mathrm{成功}}=\sum_{i=1}^{n}P_{i}(n-i+1)\)</span></p>
<p>每个元素查找概率相等时：<br />
<span class="math inline">\(\mathrm{ASL}_{成功}=\sum_{i=1}^{n}P_{i}(n-i+1)=\frac{n+1}{2}\)</span></p>
<p>不成功时，查找长度是n+1</p>
<h2 id="基本分类">基本分类</h2>
<h3 id="顺序查找">顺序查找</h3>
<p>查找成功的平均查找长度和一般线性表的顺序查找一样<br />
对有序表来说，查找失败的平均查找长度：<br />
<span class="math inline">\(\mathrm{ASL}_{不成功}=\sum_{j=1}^{n}q_{j}(l_{j}-1)={\frac{1+2+\cdots+n+n}{n+1}}={\frac{n}{2}}+{\frac{n}{n+1}}\)</span><br />
其中<span class="math inline">\(q_j\)</span>是到达第j个失败节点的概率，相等概率时为 <span class="math inline">\(\frac{1}{n+1}\)</span> <span class="math inline">\(l_j\)</span>是第j个失败节点所在判断树的层数<br />
可以是链式存储结构</p>
<h3 id="二分查找">二分查找</h3>
<p>概念略，其判断树是平衡二叉树，平均查找长度：<br />
<span class="math inline">\(\operatorname{ASL}={\frac{1}{n}}\sum_{i=1}^{n}l_{i}={\frac{1}{n}}(1\times1+2\times2+\cdots+h\times2^{h-1})={\frac{n+1}{n}}\log_{2}(n+1)-1\approx\log_{2}(n+1)-1\)</span><br />
最大查找长度： <span class="math inline">\(\lceil\log_2^{n+1}\rceil\)</span> 也是查找不成功时的比较次数 其中h是树高</p>
<h3 id="分块查找">分块查找</h3>
<p>分为彼此间有顺序关系，但内部无序的块，平均查找长度为索引查找和块内查找的平均长度之和<br />
将长度为n的查找表均匀地分为b块，每块有s个记录,等概率的情况下：</p>

$$ \mathbf{ASL}=L_{I}+L_{\mathrm{{S}}}={\frac{b+1}{2}}+{\frac{s+1}{2}}={\frac{s^{2}+2s+n}{2s}} $$  

<p><span class="math inline">\(s={\sqrt{n}}\)</span>时，取最小值 <span class="math inline">\({\sqrt{n}}+1\)</span></p>
<div class="note warning"><ul>
<li>折半查找过程所对应的判定树是平衡二叉树，左右子树高度相差最多为1</li>
<li>根据上一条可推断，查找失败时，比较次数最多相差1</li>
</ul>
</div>
<h2 id="使用树的查找">使用树的查找</h2>
<h3 id="bst">BST</h3>
<p>对二叉排序树BST进行中序遍历，可以得到一个递增的有序序列<br />
查找效率取决于是否平衡<br />
基本操作:</p>
<ol type="1">
<li>查找
<ol type="1">
<li>从根节点出发，根据当前节点与key大小关系向下前进</li>
<li>找到或进入空节点时，返回当前节点</li>
</ol></li>
<li>插入
<ol type="1">
<li>类似查找，但记录前驱节点</li>
<li>key和当前节点重合时，直接退出</li>
<li>正常应前进到空节点，此时根据key与pre节点的大小关系决定插入点</li>
</ol></li>
<li>删除(最复杂)
<ol type="1">
<li>类似查找，但记录前驱</li>
<li>查找无结果时，直接退出</li>
<li>找到后分两种情况
<ol type="1">
<li>0或1一个孩子，优先和存在的孩子交换，然后删除即可</li>
<li>2个孩子，遍历右子树的最左节点(相反也行)，和当前节点交换，然后(递归)删除交换后对应子树的待删除节点</li>
</ol></li>
</ol></li>
</ol>
<p>c++实现： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;data &gt; num)</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* cur = root, * pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data == num)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;data &lt; num)</span><br><span class="line">        pre-&gt;right = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre-&gt;left = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root, * pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 子节点数量 = 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> || cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点</span></span><br><span class="line">        TreeNode* child = cur-&gt;left != <span class="literal">nullptr</span> ? cur-&gt;left : cur-&gt;right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (cur != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;left == cur)</span><br><span class="line">                pre-&gt;left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre-&gt;right = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若删除节点为根节点，则重新指定根节点</span></span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点数量 = 2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        TreeNode* tmp = cur-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmpVal = tmp-&gt;data;</span><br><span class="line">        <span class="comment">// 递归删除节点 tmp</span></span><br><span class="line">        <span class="built_in">remove</span>(root, tmp-&gt;data);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur-&gt;data = tmpVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="平衡二叉树avlbalanced-binary-tre">平衡二叉树AVL(Balanced Binary Tre)</h3>
<p><a href="https://www.hello-algo.com/chapter_tree/avl_tree">平衡二叉树</a>的定义:</p>
<ul>
<li>一棵空树</li>
<li>具有下列性质的二叉树
<ul>
<li>它的左子树和右子树都是平衡二叉树</li>
<li>左子树和右子树的高度差的绝对值不超过1</li>
</ul></li>
</ul>
<p>定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* AVL 树节点类 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val&#123;&#125;;          <span class="comment">// 节点值</span></span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;     <span class="comment">// 节点高度(该节点到它的最远叶节点的距离)</span></span><br><span class="line">    TreeNode *left&#123;&#125;;   <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode *right&#123;&#125;;  <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="built_in">TreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> x)</span> : val(x)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rightRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;left;</span><br><span class="line">    TreeNode *grandChild = child-&gt;right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;right;</span><br><span class="line">    TreeNode *grandChild = child-&gt;left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="旋转">旋转</h4>
<ol type="1">
<li>右旋LL:失衡节点的左子树加入新节点高度+1，失衡因子达到2</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_rotate_with_grandchild.png" /></p>
<ol start="2" type="1">
<li>左旋RR:右旋的镜像</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_rotate_with_grandchild.png" /></p>
<ol start="3" type="1">
<li>先左旋后右旋LR: 失衡节点左倾，其子节点右倾</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_right_rotate.png" /></p>
<ol start="4" type="1">
<li>先右旋后左旋RL:LR的镜像</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_left_rotate.png" /></p>
<table>
<thead>
<tr class="header">
<th>失衡节点平衡因子</th>
<th>子节点平衡因子</th>
<th>旋转方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;1</td>
<td>≥0</td>
<td>右旋</td>
</tr>
<tr class="even">
<td>&gt;1</td>
<td>&lt;0</td>
<td>先左旋后右旋</td>
</tr>
<tr class="odd">
<td>&lt; -1</td>
<td>≤0</td>
<td>左旋</td>
</tr>
<tr class="even">
<td>&lt; -1</td>
<td>&gt;0</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png" /></p>
<h4 id="常见操作">常见操作</h4>
<ol type="1">
<li>插入:类似BST,唯一的区别在于，在 AVL 树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此从该节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡</li>
<li>删除:类似BST，在BST的删除节点方法的基础上，需要从底至顶执行旋转操作(或者从找到的第一个不平衡子树开始向上)，使所有失衡节点恢复平衡</li>
<li>构造:执行n次插入</li>
</ol>
<h3 id="红黑树">红黑树</h3>
<p>满足如下红黑性质的二叉排序树:</p>
<ol type="1">
<li>每个结点或是红色，或是黑色的.</li>
<li>根结点是黑色的.</li>
<li>叶结点(虚构的外部结点、NULL结点)都是黑色的。</li>
<li>不存在两个相邻的红结点(即红结点的父结点和孩子结点均是黑色的)。</li>
<li>对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。</li>
</ol>
<p><strong>性质</strong>:</p>
<ol type="1">
<li>从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的黑高（记为bh）,黑高的概念是由性质5确定的;根结点的黑高称为红黑树的黑高<br />
</li>
<li>从根到叶结点的最长路径不大于最短路径的2倍
<ol type="1">
<li>由5.从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成</li>
<li>由4.某条路径最长时，这条路径必然是由黑结点和红结点相间构成的</li>
</ol></li>
<li>有n个内部结点的红黑树的高度 h≤2 $ log_2^{n+1} $
<ol type="1">
<li>从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为h/2,因此 $ n≥2^{h/2}-1 $ (可以数学归纳法证明)</li>
</ol></li>
<li>新插入红黑树中的结点z初始着为红色，过程:
<ol type="1">
<li>若新插入结点z的父结点是黑色的，无须做任何调整，此时就是一棵标准的红黑树</li>
<li>若结点z是根结点，则将z着为黑色（树的黑高增1）</li>
<li>若结点z不是根结点，且z的父结点z.p是红色的:
<ol type="1">
<li>若z的叔结点y是黑色的，且z是一个右孩子:先左旋，再右旋</li>
<li>若z的叔结点y是黑色的，且z是一个左孩子:右单旋</li>
<li>若z的叔结点y是红色的:将z.p和y都着为黑色，将z.p.p着为红色;然后，把z.p.p作为新结点z来重复循环，指针z在树中上移两层</li>
</ol></li>
</ol></li>
</ol>
<p>红黑树任意一个结点左右子树的高度，相差不超过2倍(例如C++中的map和set;Java中的TreeMap和TreeSet用红黑树实现)</p>
<p><img src="/assets/resources/Pasted%20image%2020241111165247.png" /> <img src="/assets/resources/Pasted%20image%2020241111171032.png" /> <img src="/assets/resources/Pasted%20image%2020241111171040.png" /> <img src="/assets/resources/Pasted%20image%2020241111171051.png" /></p>
<h3 id="b树">B树</h3>
<p><img src="/assets/resources/Pasted%20image%2020241112103548.png" /></p>
<p>m阶B树是所有结点的平衡因子均等于0的m路平衡查找树<br />
一棵m阶B树或为空树，或为满足如下特性的叉树:</p>
<ol type="1">
<li>树中每个结点至多有m棵子树，即至多有m-1个关键字</li>
<li>若根结点不是叶结点，则至少有2棵子树，即至少有1个关键字</li>
<li>除根结点外的所有非叶结点至少有 <span class="math inline">\(\lceil m/2 \rceil\)</span> 棵子树，即至少有 <span class="math inline">\(\lceil m/2 \rceil -1\)</span> 个关键字</li>
<li>所有的叶结点.都出现在同一层次上，并且不带信息(可以视为外部结点或类似于折半查找判定树的失败结点，实际用空指针表示)</li>
<li>所有非叶结点的结构如下:</li>
</ol>
<table>
<thead>
<tr class="header">
<th>n</th>
<th>P0</th>
<th>K1</th>
<th>P1</th>
<th>K2</th>
<th>P2</th>
<th>……</th>
<th>Kn</th>
<th>Pn</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>其中:</p>
<ul>
<li>Ki为结点的关键字，且从K1至Kn递增</li>
<li>Pi(从0开始)为指向子树根结点的指针，即指针数为关键字数+1
<ul>
<li>P(i-1)所指子树中所有结点的关键字均小于Ki</li>
<li>Pi所指子树中所有结点的关键字均大于Ki</li>
</ul></li>
<li><span class="math inline">\(n\ \left(\lceil m/2\rceil-1\leqslant n\leqslant m-1\right)\)</span> 为结点中关键字的个数</li>
</ul>
<h4 id="常见操作-1">常见操作</h4>
<p>查找:</p>
<ol type="1">
<li>在B树中找结点(常在磁盘，找到后读入内存)</li>
<li>在结点内找关键字(常在内存)</li>
</ol>
<p>磁盘存取次数(高度): B树中的大部分操作所需的磁盘存取次数与B树的高度成正比<br />
若n≥1,则对任意一棵包含n个关键字、高度为h、阶数为m的B树：</p>
<ol type="1">
<li>若让每个结点中的关键字个数达到最多，则容纳同样多关键字的B树的高度达到最小
<ol type="1">
<li>关键字的个数满足 <span class="math inline">\(n\leq(m-1)(1+m+m^{2}+\cdots+m^{h-1})=m^{h}-1\)</span></li>
<li>h满足 <span class="math inline">\(h\geq\log_{m}(n+1)\)</span></li>
</ol></li>
<li>若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大
<ol type="1">
<li>对查找不成功的节点满足 <span class="math inline">\(n+1\geq2(\lceil m/2\rceil)^{h-1}\)</span></li>
<li>h满足 <span class="math inline">\(h\leq\log\lceil_{m/2}\rceil((n+1)/2)+1\)</span></li>
</ol></li>
</ol>
<p>插入:</p>
<ol type="1">
<li>查找算法找出插入该关键字的终端结点</li>
<li>每个非根结点的关键字个数都有范围 <span class="math inline">\([\lceil~m/2\rceil-1,~m-1]\)</span>
<ol type="1">
<li>若结点插入后的关键字个数小于m，可以直接插入</li>
<li>若结点插入后的关键字个数大于m-1，对结点进行分裂
<ol type="1">
<li>取一个新结点，在插入key后的原结点，从中间位置 <span class="math inline">\(\lceil m/2 \rceil\)</span> 将其中的关键字分为两部分,左半留在原结点，右半给新结点，中间位置结点插入原结点的父结点</li>
<li>若导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1</li>
</ol></li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020241112103600.png" /></p>
<p>删除:</p>
<ol type="1">
<li>被删关键字k不在终端结点中时,用k的前驱或者后继替代k，并在来源结点删除这个替代元素</li>
<li>被删关键字k在终端结点中时
<ol type="1">
<li>若k所在结点删除前的关键字个数 $ ≥m/2 $ ,则可直接删除该关键字</li>
<li>k所在结点删除前的关键字个数 $ =m/2 $, 该结点相邻节点关键字个数 $ ≥m/2 $,则借一个兄弟的结点过来(先父子换位，然后借一个兄弟给父结点)</li>
<li>k所在结点删除前的关键字个数 $ =m/2 $, 该结点相邻节点关键字个数 $ =m/2 $ ,将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020241112103610.png" /> <img src="/assets/resources/Pasted%20image%2020241112103620.png" /></p>
<p>若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点成为根;<br />
若双亲结点不是根结点，且关键字个数减少不满足要求，则向上递归直到满足要求</p>
<h4 id="b树-1">B+树</h4>
<p>B+树是应数据库所需而出现的一种B树的变形<br />
一棵m阶B+树应满足下列条件:</p>
<ol type="1">
<li>每个分支结点最多有m棵子树（孩子结点）</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有 <span class="math inline">\(\lceil m/2 \rceil\)</span> 棵子树</li>
<li>结点的子树个数与关键字个数相等</li>
<li>所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列,并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）</li>
<li>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针</li>
</ol>
<p>m阶B+树与m阶B树的主要差异:</p>
<ol type="1">
<li>在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有n+1棵子树</li>
<li>在B+树中，每个结点（非根内部结点）的关键字个数范围是[ <span class="math inline">\(\lceil m/2 \rceil\)</span> , m ] (非叶根节点是<code>[2,m]</code>) ;B树中，每个结点（非根内部结点）的关键字个数n的范围是 [ <span class="math inline">\(\lceil m/2 \rceil\)</span> -1 , m - 1 ] (根节点是<code>[1,m-1]</code>)</li>
<li>B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的</li>
<li>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有对应记录的存储地址。这样能使一个磁盘块存储更多的关键字，使得磁盘读/写次数更少，查找速度更快</li>
<li>在B+树中，用一个指针指向关键字最小的叶结点，将所有叶结点串成一个线性链表</li>
</ol>
<p>注: 非叶根结点指孩子不为空的根结点</p>
<p><img src="/assets/resources/Pasted%20image%2020241112103632.png" /></p>
<p>通常有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点;因此可以从最小关键字开始顺序查找或者从根结点开始多路查找<br />
B+树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止<br />
在B+树中，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径</p>
<h2 id="字符串匹配kmp算法">字符串匹配KMP算法</h2>
<p><a href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">参考链接</a></p>
<ol type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png" /></p>
<p>首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位</p>
<ol start="2" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050104.png" /></p>
<p>因为B与A不匹配，搜索词再往后移</p>
<ol start="3" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050105.png" /></p>
<p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止</p>
<ol start="4" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050106.png" /></p>
<p>接着比较字符串和搜索词的下一个字符，还是相同</p>
<ol start="5" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" /></p>
<p>直到字符串有一个字符，与搜索词对应的字符不相同为止</p>
<ol start="6" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050108.png" /></p>
<p>最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样可行，但效率很差，因为要把"搜索位置"移到已经比较过的位置，重比一遍</p>
<ol start="7" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" /></p>
<p>当空格与D不匹配时，我们知道前面六个字符是"ABCDAB"。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率</p>
<ol start="8" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" /></p>
<p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》(Partial Match Table)</p>
<ol start="9" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" /></p>
<p>已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：</p>
<blockquote>
<p>　　移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>
</blockquote>
<p>因为 6 - 2 等于4，所以将搜索词向后移动4位</p>
<ol start="10" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050110.png" /></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2("AB")，对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位</p>
<ol start="11" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050111.png" /></p>
<p>因为空格与A不匹配，继续后移一位</p>
<ol start="12" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png" /></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位</p>
<ol start="13" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050113.png" /></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索(即找出全部匹配)，移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" /> 前缀指除最后一个字符以外，字符串的所有头部子串；后缀指除第一个字符外，字符串的所有尾部子串;"部分匹配值"是"前缀"和"后缀"的最长的共有元素的长度<br />
如'ababa'的前缀{a,ab,aba,abab} ∩ 后缀{a,ba,aba,baba} = {a,aba},公共元素有两个，最长相等前后缀长度为3<br />
部分匹配值i号表项则是对<code>[0-i]</code>索引的字符串的部分匹配值</p>
<p>对前后缀匹配可以这样理解:</p>
<ol type="1">
<li>如果一位都不匹配，直接跳到下一个字符</li>
<li>匹配了n位时，相当于这n位子串是对的，而对这个子串来说的部分匹配值表示从后面数，有个子串和前缀这个匹配正确的子串一样，因此跳转到后缀子串肯定保留着n位匹配的性质。此时，移动位数 = 已匹配的字符数 - 对应的部分匹配值</li>
<li>当第n+1位匹配失败时，如果这时移动少于kmp规定的移动次数也能匹配上，那么就会与部分匹配表矛盾
<ol type="1">
<li>此时我们知道前n位匹配，第n+1位不匹配，若移动次数少于规定，那么肯定不会移到最大的公共前后缀上，也就是不会完全匹配上</li>
<li>使用反证法，假设移动次数少于规定还能完全匹配，那么字符串在最长公共后缀前的一个子串可以匹配前缀，这个匹配前缀的子串又成了新的最长公共后缀，与定义矛盾</li>
</ol></li>
</ol>
<p>将next数组右移一位，最左侧填-1，则匹配中每次右移位数=<code>j-1-next[j]</code>为了方便也可以+1<br />
求next数组可视为以下递归过程:</p>
<ol type="1">
<li>已知<code>next[j]=k</code>,即前j-1个元素中前k-1(next右移过一位且整体+1)个元素和后k-1个元素相同,j+1分为以下两种情况
<ol type="1">
<li>pk=pj,<code>next[j+1]=next[j]+1</code></li>
<li>pk!=pj,目前<code>p1~pj-1</code>部分已知有k-1长度的公共前后缀(因为next加过1)，但无法和pj匹配，因此在<code>1~k-1</code>找一个更小的公共前后缀(肯定要公共前后缀才能继续接上pj)，即<code>k=next[k]</code>，看这个更小的前公共子序列能否和pj组成更大的公共序列，如此重复
<ol type="1">
<li>也就是说，要求<code>next[j+1]</code>,当pj匹配不上pk时，查<code>next[j]</code>会得到j前面部分的公共前后缀长度<code>k-1</code>，下一个有可能匹配上的就是前面的公共前缀<code>[1~k-1]</code>后面第一个元素( <span class="math inline">\(p_{next[next[j]]}\)</span> 即 <span class="math inline">\(p_{next[k]}\)</span> )与pj,如果这次还匹配不上，就继续递归</li>
</ol></li>
</ol></li>
</ol>
<p>next的优化:由于每次右移<code>next[j]</code>,即下一个比较的一直是<code>p[next[j]]</code>，如果和<code>p[j]</code>相同，则这样的比较没有意义，因此对相等的<code>pj和p_next[j]</code>要不断将<code>next[j]修正为next[next[j]]</code>;更新后的数组命名为nextval</p>
<p>时间复杂度O是(m+n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string T, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//为了方便运算将next整体+!</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.<span class="built_in">at</span>(i) == T.<span class="built_in">at</span>(j)) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            next[i] = j; <span class="comment">//若 Pi=Pj，则 next [ j +1 ] =next [ j ] +1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">//否则令 j=next [ j ],循环继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(string S, string T, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.<span class="built_in">length</span>() &amp;&amp; j &lt;= T.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j -= <span class="number">0</span> || S.<span class="built_in">at</span>(i) == T.<span class="built_in">at</span>(j)) &#123;</span><br><span class="line">            ++i; ++j; <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">return</span> i - T.<span class="built_in">length</span>(); <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get__nextval</span><span class="params">(string T, <span class="type">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.<span class="built_in">at</span>(i) == T.<span class="built_in">at</span>(j)) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            <span class="keyword">if</span> (T.<span class="built_in">at</span>(i) != T.<span class="built_in">at</span>(j)) nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span> nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更好理解的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextval</span><span class="params">(<span class="type">char</span>* p, <span class="type">int</span>* next)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, len = <span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[next[i]])</span><br><span class="line">      next[i] = next[next[i]];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      next[i] = next[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="哈希">哈希</h2>
<p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr<br />
散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。<br />
应满足以下条件：</p>
<ol type="1">
<li>定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围</li>
<li>计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突</li>
<li>应尽量简单</li>
</ol>
<p>常见的哈希函数：</p>
<ol type="1">
<li>直接定址法,直接取关键字的某个线性函数值为散列地址:<span class="math inline">\(H(\mathrm{key})=a\times \mathrm{key}+b\)</span></li>
<li>除留余数法,取不超过且尽可能接近表长m的质数p,<span class="math inline">\(H(\mathrm{key})=\mathrm{key}\ \% p\)</span></li>
<li>数字分析法,选取r进制的r个数码分布较为均匀的若干位作为散列地址</li>
<li>平方取中法，取关键字的平方值的中间几位作为散列地址</li>
</ol>
<h3 id="冲突处理">冲突处理</h3>
<ol type="1">
<li>开放寻址，<span class="math inline">\(H_{i}=(H(\mathrm{key})+d_{i})\%m\)</span> 其中 <span class="math inline">\(d_i\)</span> 为增量序列，删除需要特殊标记(<strong>i从1开始</strong>),再散列方法(第一次散列失败后开始使用)如下:
<ol type="1">
<li>线性探测法，di为<code>[1,m-1](循环，但下一次循环从0开始)</code>，遇到连续元素时效率较低</li>
<li>平方探测法,di为 <span class="math inline">\(0^2,1^2,-1^2,……,-k^2\)</span> ,其中<code>k&lt;=m/2</code>,散列表长度m必须是一个可以表示成<code>4k + 3</code>的素数，又称二次探测法;可以避免出现“堆积”问题，缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元</li>
<li>双散列法,<span class="math inline">\(d_{i}=\operatorname{Hash}_{2}(key)\)</span>,即 <span class="math inline">\(H_{i}=(H(\mathrm{key})+i\times\mathrm{Hash}_{2}(\mathrm{key}))\ \% \,m\)</span> (i从0开始)</li>
<li>伪随机序列法,di为伪随机序列</li>
</ol></li>
<li>链接(拉链)法,映射相同哈希值的元素形成链表<br />
哈希表的装载因子α=n/m，影响平均查找和删除时间，假设均匀散列，插入元素(需要一次查找失败)至多期望1/(1-α)次查找</li>
</ol>
<div class="note warning"><ul>
<li>查找的初始情况由散列函数可能的哈希值决定，例如mod的分母</li>
</ul>
</div>
<hr />
<h1 id="排序">排序</h1>
<p>408设计的排序基本是将给定序列规律化。输入是线性表<br />
<strong>稳定性</strong>：若输入两元素key相等，输出序列若两者相对顺序不变，则该算法稳定，否则不稳定</p>
<ul>
<li>内部排序，是指在排序期间元素全部存放在内存中的排序</li>
<li>外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序</li>
</ul>
<h2 id="插入排序">插入排序</h2>
<p>介绍略</p>
<ul>
<li>空间复杂度O(1)</li>
<li>平均时间复杂度O( <span class="math inline">\(n^2\)</span> )</li>
<li>稳定，且同时适用顺序和链式 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Insertsort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++) <span class="comment">//依次将A[2] ~A[n]插入前面己排序序列</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123; <span class="comment">//若A[i]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i]; <span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>;A[<span class="number">0</span>] &lt; A[j];--j)<span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j + <span class="number">1</span>] = A[j]; <span class="comment">//向后挪位</span></span><br><span class="line">            A[j + <span class="number">1</span>] = A[<span class="number">0</span>]; <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="折半插入">折半插入</h3>
<p>在已排序部分找插入点时使用二分查找，性能相对更好但复杂度不变，稳定但只适用于顺序表<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort_byhalf</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, low, high, mid; <span class="comment">//依次将A[2]~A[n]插入前面的巳排序序列</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123; <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];</span><br><span class="line">        low = <span class="number">1</span>;high = i - <span class="number">1</span>; <span class="comment">//设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; A[<span class="number">0</span>]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>;j &gt;= high + <span class="number">1</span>;--j)</span><br><span class="line">                A[j + <span class="number">1</span>] = A[j]; <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">            A[high + <span class="number">1</span>] = A[<span class="number">0</span>]; <span class="comment">//插入操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="希尔shell排序">希尔(shell)排序</h3>
<ol type="1">
<li>将表内元素以步长d1分为d1组，各组内部进行插入排序</li>
<li>取一个<code>d2&lt;d1</code>,重复上述操作，直到取到一个步长为1</li>
<li>进行插入排序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//A[0]是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span></span><br><span class="line">    <span class="type">int</span> dk, i, j;</span><br><span class="line">    <span class="keyword">for</span> (dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk / <span class="number">2</span>) <span class="comment">//增量变化(无统一规定)</span></span><br><span class="line">        <span class="keyword">for</span> (i = dk + <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - dk]) &#123; <span class="comment">//需将A [i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>] = A[i]; <span class="comment">//暂存在 A[0]</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - dk;j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j];j -= dk)</span><br><span class="line">                    A[j + dk] = A[j]; <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j + dk] = A[<span class="number">0</span>]; <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>空间复杂度O(1),当n在某个特定范围时,希尔排序的时间复杂度约为O( <span class="math inline">\(N^{1.3}\)</span>),在最坏情况下希尔排序的时间复杂度为O( <span class="math inline">\(N^2\)</span> )</li>
<li>当相同关键字的记录被划分到不同的子表时，可能改变相对次序，因此不稳定</li>
<li>仅适用于顺序存储</li>
</ul>
<h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<p>正序或逆序开始，两两排序相邻两位，一趟可以确定一个最小(大)值,最多n-1趟就能排完</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j]) &#123; <span class="comment">//若为逆序</span></span><br><span class="line">                <span class="built_in">swap</span>(A[j - <span class="number">1</span>], A[j]); <span class="comment">//交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>空间复杂度O(1)</li>
<li>最坏情况下完全逆序，第i趟需要比n-i次，比较次数为 <span class="math inline">\(\sum_{i=1}^{n-1}(n-i)={\frac{n(n-1)}{2}}\)</span>,即时间复杂度O( $ N^2 $ )</li>
<li>稳定</li>
</ul>
<h3 id="快速排序">快速排序</h3>
<p>每次划分出以枢纽值为界的两个区间，并对左右分别递归<br />
枢纽值可以随机确定，或取三个元素中值来保证期望复杂度为nlogn，常用第一个元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123; <span class="comment">//一趟划分</span></span><br><span class="line">    ElemType pivot = A[low]; <span class="comment">//将当前表中第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123; <span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;</span><br><span class="line">        A[low] = A[high]; <span class="comment">//将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low;</span><br><span class="line">        A[high] = A[low]; <span class="comment">//将比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot; <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low; <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quicksort</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123; <span class="comment">//递归跳出的条件</span></span><br><span class="line">        <span class="comment">//Partition ()就是划分操作，将表A [low…high]划分为满足上述条件的两个子表</span></span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">Partition</span>(A, low, high); <span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">Quicksort</span>(A, low, pivotpos - <span class="number">1</span>); <span class="comment">//依次对两个子表进行递归排序</span></span><br><span class="line">        <span class="built_in">Quicksort</span>(A, pivotpos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>空间复杂度由于涉及栈，平均为logn，最坏O(N)</li>
<li>时间复杂度同理，但相对来说，最坏情况可能性较低，因此平均性能为内部排序算法最佳</li>
<li>划分时，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，因此不稳定</li>
</ul>
<h2 id="选择排序">选择排序</h2>
<h3 id="简单选择排序">简单选择排序</h3>
<p>每次选择第i小关键字和第i个元素交换，进行n-1次 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">//一共进行 n-1 趟</span></span><br><span class="line">        <span class="type">int</span> min = i; <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) <span class="comment">//在A[i~n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min]) min = j; <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) <span class="built_in">swap</span>(A[i], A[min]); <span class="comment">//swap()函数共移动元素 3 次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>空间复杂度O(1)</li>
<li>比较次数必为n(n-1)/2,时间复杂度固定O( <span class="math inline">\(N^2\)</span> )</li>
<li>在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同关键字元素的相对位置发生改变,因此不稳定</li>
</ul>
<h3 id="堆排序">堆排序</h3>
<p>极大(小)堆的概念略，以极小堆为例的基本操作：</p>
<ol type="1">
<li>向上维护：直到该节点大于等于父节点，不断将其与父节点交换</li>
<li>向下维护：直到该节点小于其两个子节点，与一个比它大的子节点交换</li>
<li>构建：对一个数组从中点开始到起点向下维护</li>
<li>删除顶部节点：顶部节点与数组最后节点交换，然后对交换后的顶部节点向下维护</li>
<li>插入节点：插入的节点到数组尾部，对其向上维护</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(ElemType A[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(ElemType A[], <span class="type">int</span> k, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数HeadAdjust将元素k为根的子树进行调整</span></span><br><span class="line">    A[<span class="number">0</span>] = A[k]; <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * k; i &lt; len; i *= <span class="number">2</span>) &#123;<span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len&amp;&amp; A[i] &lt; A[i + <span class="number">1</span>])</span><br><span class="line">            i++; <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>; <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = A[i]; <span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k = i; <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>]; <span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span>;i &gt; <span class="number">0</span>;i--) <span class="comment">//从 i = [n / 2]〜1, 反复调整堆</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(A, len); <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123; <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        <span class="built_in">Swap</span>(A, i, <span class="number">1</span>); <span class="comment">//输出堆顶元素(和堆底元素交换)</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, <span class="number">1</span>, i - <span class="number">1</span>); <span class="comment">//调整，把剩余的i-1个元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序就是不断移除首部节点的过程</p>
<ul>
<li>空间复杂度O(1)</li>
<li>建堆的时间复杂度为O(N)，每次移除top并维护平均需要logN复杂度，因此最好、最坏和平均情况下，堆排序的时间复杂度为O(Nlog2N)</li>
<li>进行筛选时，有可能把后面相同关键字的元素调整到前面，因此不稳定</li>
</ul>
<h2 id="归并排序">归并排序</h2>
<p>等长划分数组，然后排序，如此不断递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ElemType* B; <span class="comment">//辅助数组 B</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表A的两段A[low...mid]和A [mid+l...high]各自有序，将它们合并成一个有序表</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (k = low;k &lt;= high;k++)</span><br><span class="line">        B[k] = A[k]; <span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    <span class="keyword">for</span> (i - low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) <span class="comment">//比较B的左右两段中的元素</span></span><br><span class="line">            A[k] = B[i++]; <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) A[k++] = B[i++]; <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) A[k++] = B[j++]; <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>; <span class="comment">//从中间划分两个子序列</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A, low, mid); <span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A, mid + <span class="number">1</span>, high); <span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">        <span class="built_in">Merge</span>(A, low, mid, high); <span class="comment">//归并</span></span><br><span class="line">    &#125;<span class="comment">//if *</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就2路归并排序来说：</p>
<ul>
<li>空间复杂度O(N)</li>
<li>需要logn趟归并，每次O(N),因此时间复杂度是O(NlogN)</li>
<li>Merge()操作不会改变相同关键字记录的相对次序，因此稳定<br />
</li>
<li>比较次数的数量级与序列的初始状态无关</li>
</ul>
<p>对于N个元素进行k路归并排序时，排序的趟数m满足 <span class="math inline">\(k^{m}=N\)</span></p>
<h2 id="基数排序">基数排序</h2>
<p>根据r进制的每位数字，从高位或低位开始以此排序，最后就能得到有序数组<br />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">digit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num / exp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数排序(根据 nums 第 k 位排序) */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSortDigit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">digit</span>(nums[i], exp); <span class="comment">// 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d]++;                <span class="comment">// 统计数字 d 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        counter[i] += counter[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">digit</span>(nums[i], exp);</span><br><span class="line">        <span class="type">int</span> j = counter[d] - <span class="number">1</span>; <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i];       <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">        counter[d]--;           <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nums[i] = res[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基数排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    <span class="type">int</span> m = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 按照从低位到高位的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; exp &lt;= m; exp *= <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">        <span class="built_in">countingSortDigit</span>(nums, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>空间复杂度为O(r)</li>
<li>时间复杂度为O(d(N+r)),与序列的初始状态无关(d为趟数),与序列的初始状态无关</li>
<li>只要对相同位排序时使用的算法稳定，就稳定，除了常用的计数排序，也可以直接链接</li>
</ul>
<h2 id="内部排序小结">内部排序小结</h2>
<p><img src="/assets/resources/Pasted%20image%2020240511224819.png" /></p>
<ul>
<li>若n较小，可采用直接插入排序或简单选择排序</li>
<li>若初始状态基本有序，则选用直接插入或冒泡排序较好</li>
<li>若n较大,快速排序、堆排序或归并排序较好，需要稳定时只能使用归并</li>
<li>若n很大，记录的关键字位数较少且可以分解时，基数排序较好</li>
<li>比较排序的决策树是完全二叉树，因此高度h&gt;=lg(叶节点数),叶结点数是排列数量，即n!,因此下界是nlogn</li>
</ul>
<h2 id="外部排序">外部排序</h2>
<p>指待排序文件较大，内存无法完全存放，需存放在外存的文件的排序<br />
通常采用归并排序法，分为两步：</p>
<ol type="1">
<li>根据内存缓冲区大小，将外存上的文件分成若干长度为l的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串</li>
<li>对这些归并段进行逐趟归并，直至得到整个有序文件</li>
</ol>
<p><strong>外部排序的总时间=内部排序所需的时间+外存信息读写的时间+内部归并所需的时间</strong><br />
增加路数可以显著减少IO<br />
在k个元素中选择关键字最小的记录需要比较k-1次。每趟归并n个元素需要做(n-1)(k-1)次比较,则S趟归并总共需要的比较次数为：<br />
<span class="math inline">\(S(n-1)(k-1)=\left \lceil \log_{k}r\right \rceil (n-1)(k-1)=\left \lceil \log_{2}r \rceil(n-1)(k-1)/\lceil\log_{2}k\right\rceil\)</span><br />
为了使内部归并不受k的增大的影响，引入了败者树，k个叶结点分别存放k个归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的"失败者”，而让<strong>胜者往上继续进行比较</strong>，一直到根结点。<br />
若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数<br />
<img src="/assets/resources/Pasted%20image%2020240522232019.png" /></p>
<p>k个记录中选择最小关键字，最多需要 <span class="math inline">\(\lceil\log_2^{k}\rceil\)</span> 次比较(败者树深度为比较次数+1)。所以总的比较次数为：<br />
<span class="math inline">\(S(n-1)\left\lceil\log_{2}\!k\right\rceil=\left\lceil\log_{k}\!r\right\rceil(n-1)\left\lceil\log_{2}\!k\right\rceil=(n-1)\left\lceil\log_{2}r\right\rceil\)</span><br />
使用败者树时，内部归并的比较次数与k无关，只要内存空间允许，增大归并路数上将有效地减少归并树的高度，减少I/O次数，提高速度</p>
<h3 id="置换-选择排序">置换-选择排序</h3>
<p>用来产生更长的初始归并段，减少段个数r,从而减少归并趟数S<br />
设初始待排文件为FI初始归并段输出文件为FO,内存工作区为WA, FO和WA的初始状态为空，WA可容纳w个记录：</p>
<ol type="1">
<li>从FI输入w个记录到工作区WA</li>
<li>从WA中选出其中关键字取最小值的记录，记为MINIMAX记录(选择MINIMAX记录的过程用败者树实现)</li>
<li>将MINIMAX记录输出到FO中去</li>
<li>若FI不空，则从FI输入下一个记录到WA中</li>
<li>从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录(使用败者树)，作为新的MINIMAX记录</li>
<li>重复3.~5.直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到F0中去</li>
<li>重复2.~6.直至WA为空。由此得到全部初始归并段</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240522233010.png" /></p>
<h3 id="最佳归并树">最佳归并树</h3>
<p>将哈夫曼树的思想推广到m叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的I/O次数最少的最佳归并树<br />
若初始归并段不足以构成一棵严格k叉树时，需添加长度为0的"虚段"<br />
<img src="/assets/resources/Pasted%20image%2020240522234037.png" /><br />
设度为0的结点有n0个，度为k的结点有nk个，归并树的结点总数为n,则：</p>
<ul>
<li>n=nk + n0; n=k.nk + 1</li>
<li>对严格k叉树有 <span class="math inline">\(n_0=(k-1)n_k+1\)</span> ,由此可得 <span class="math inline">\(n_k=(n0-1)/(k- 1)\)</span><br />
</li>
<li>若 <span class="math inline">\((n_{0}-1)\%(k-1)==0\)</span>,则说明这n0个叶结点(初始归并段)正好可以构造k叉归并树。此时，内结点有nk个</li>
<li>若 <span class="math inline">\((n_{0}-1)\%(k-1)=u\ne0\)</span> ,则对于这n0个叶结点，其中有u个多余，不能包含在k叉归并树中,应在原有个nk内结点的基础上再增加1个内结点
<ul>
<li>添加的节点取代叶节点，加上k-u-1个空归并段可以构成一颗归并树</li>
</ul></li>
</ul>
<div class="note warning"><ul>
<li>每次冒泡排序后可以检查是否已经有序</li>
<li>对n个关键字进行快速排序，最多递归n次，最少logn次(二分)</li>
<li>取一大堆数据中的k个最大(最小)的元素时，优先采用堆排序</li>
<li>堆删除一个元素后，除了向下比较，还要比较左右两个子节点的大小关系，选择一个子树向下递归</li>
<li>将两个各有N个元素的有序表合并，最少比N次，最多2N-1次</li>
<li>带权连通图的任意一个环中所包含的边的权值均不相同时，其MST(最小(代价)生成树)唯一</li>
</ul>
</div>
]]></content>
      <categories>
        <category>考研笔记</category>
        <category>研distance</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>研distance——计算机组成部分</title>
    <url>/thinklive/47457/</url>
    <content><![CDATA[<h1 id="概论">概论</h1>
<p>历史： 电子管-&gt;晶体管-&gt;集成电路 比较成熟的集成电路出现于1972</p>
<p>冯诺依曼机：</p>
<ol type="1">
<li>采用“存储程序”的工作方式。程序和原始数据送入主存后才能执行，计算机自动逐条执行指令，直至执行结束</li>
<li>计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。
<ul>
<li>存储器分为主存和辅存，对应现在的内存和硬盘，由存储单元组成，存储单元可存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长</li>
<li>主存由地址寄存器MAR和数据寄存器MDR以及时序控制逻辑组成，MAR用于寻址，其位数对应着存储单元的个数，存放访问地址，需要译码才能定位到存储单元，MDR的位数和存储字长相等，暂存要从存储器读写的信息，时序控制逻辑产生操作的时序信号</li>
<li>运算器的核心是算术逻辑单元ALU，运算器包含若干通用寄存器，用于暂存操作数和中间结果，程序状态寄存器(PSW),也称标志寄存器用于存放运算中的一些状态信息</li>
<li>控制器由程序计数器(PC)、指令寄存器(IR)和控制单元(CU)组成
<ul>
<li>PC用来存放当前欲执行指令的地址，可以自增1来寻址到下一个指令</li>
<li>IR用来存放当前的指令，其内容来自主存的MDR，指令中操作码送到CU，地址码送至MAR</li>
<li>CU通过操作码产生需要的命令序列</li>
</ul></li>
</ul></li>
<li>指令和数据以同等地位存储在存储器中，形式上没有区别，CPU用<strong>指令周期的不同阶段</strong>区分他们</li>
<li>指令和数据均用二进制代码表示。指令由操作码和地址码组成，操作码指出操作的类型,地址码指出操作数的地址</li>
</ol>
<span id="more"></span>
<figure>
<img src="/assets/resources/Pasted%20image%2020240110161646.png" alt="" /><figcaption>主存的组成</figcaption>
</figure>
<p>运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器共同构成主机。其他设备 称为外部设备</p>
<p><img src="/assets/resources/Pasted%20image%2020240110162758.png" /></p>
<p>软件按其功能分类，可分为系统软件和应用软件。<br />
语言可分为：</p>
<ul>
<li>机器语言，二进制代码语言，计算机可以直接识别和执行的语言</li>
<li>汇编语言，用英文单词或其缩写代替二进制的指令代码，必须被汇编程序翻译为机器语言后，才可以执行</li>
<li>高级语言，现在使用的绝大部分编程语言，最后会被编译成汇编或者机器语言执行</li>
</ul>
<p>翻译程序可分为：</p>
<ul>
<li>汇编程序(汇编器)。将汇编语言程序翻译成机器语言程序。</li>
<li>解释程序(解释器)。将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。</li>
<li>编译程序(编译器)。将高级语言程序翻译成汇编语言或机器语言程序</li>
</ul>
<p>对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。这一等价性被称为软、硬件逻辑功能的等价性。例如浮点数运算</p>
<p><img src="/assets/resources/Pasted%20image%2020240110163330.png" /> 没有配备软件的纯硬件系统称为裸机。第3层〜第5层称为虚拟机，上层依赖于下层<br />
软件和硬件之间的界面就是指令集体系结构(ISA), ISA定义了一台计算机可以执行的所有指令的集合，ISA是软件能感知到的部分，也称软件可见部分</p>
<h2 id="工作原理">工作原理</h2>
<ol type="1">
<li>根据PC取指令</li>
<li>指令译码，INC PC</li>
<li>取操作数，执行</li>
<li>送结果</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240110164350.png" /></p>
<ol type="1">
<li>预处理，例如头文件插入程序文件</li>
<li>编译阶段产生一个汇编程序，每条语句都对应一个机器语言指令</li>
<li>汇编阶段，翻译成机器语言指令(二进制)</li>
<li>将可重定位文件与标准库函数合并成可执行文件</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240110165934.png" /></p>
<p>执行过程(以取数指令为例)</p>
<ol type="1">
<li>取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR<br />
根据PC取指令到IR。将PC的内容送MAR, MAR中的内容直接送地址线 ，同时控制器将读信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接收指令信息，并传送到IR中。<br />
</li>
<li>分析指令：OP(IR)-&gt;CU<br />
指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR中是取数指令，因此读控制信号被送到总线的控制线上。<br />
</li>
<li>执行指令：Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC<br />
取数操作：将IR中指令的地址码送MAR, MAR中的内容送地址线，同时控制器将读信号送读/写信号线，从主存中读出操作数，并通过数据线送至MDR,再传送到ACC中。每取完一条指令，还须为取下条指令做准备，计算下条指令的地址，即(PC)+1 -&gt; PC</li>
</ol>
<div class="note warning"><ul>
<li>冯•诺依曼机基本工作方式是控制流驱动方式</li>
<li>IR存放当前执行的指令代码，PC存放下一条指令的地址</li>
<li>地址译码器是主存的构成部分，不属于CPU(但一般现代cpu也集成)</li>
<li>速度上：寄存器＞Cache &gt; 内存</li>
<li>n位计算机表明计算机字长，与地址位数无关</li>
<li>由高级语言转化为汇编语言的过程称为编译，把汇编语言源程序翻译成机器语言程序的过程称为汇编</li>
<li>相联存储器既可以按地址寻址又可以按内容(通常是某些字段)寻址</li>
<li>CPU可以根据指令周期的不同阶段来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的是数据</li>
</ul>
</div>
<h2 id="性能指标">性能指标</h2>
<ul>
<li><strong>字长</strong>:计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数,一般等于寄存器大小，且是字节的整数倍<br />
</li>
<li><strong>数据通路带宽</strong>：数据总线一次能并行传送信息的位数(不是cpu内部的数据总线)<br />
</li>
<li><strong>主存容量</strong>：主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数x字长(如<code>512K*16位</code>)来表示存储容量。其中，MAR的位数反映了存储单元的个数，MDR的位数反映了存储单元的字长<br />
</li>
<li><strong>吞吐量</strong>：指系统在单位时间内处理请求的数量，主要取决于主存的存取周期<br />
</li>
<li><strong>响应时间</strong>：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括CPU时间与等待时间。操作系统有相同概念<br />
</li>
<li><strong>CPU时钟周期</strong>：通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位<br />
</li>
<li><strong>主频(CPU时钟频率)</strong>：机器内部主时钟的频率<br />
</li>
<li><strong>CPI (Cycle Per Instruction)</strong>：执行一条指令所需的时钟周期数，对一个程序来说，指的是平均值<br />
</li>
<li><strong>CPU执行时间</strong>：运行一个程序所花费的时间，即<span class="math inline">\(cpu时间周期数/主频=(指令条数*CPI)/主频\)</span><br />
</li>
<li><strong>MIPS (Million Instructions Per Second)</strong>：即每秒执行多少百万条指令:</li>
</ul>
<p><span class="math display">\[ MIPS =指令条数/(执行时间*10^6)=主频/(CPI*10^6) \]</span></p>
<ul>
<li>1ms 1毫秒=0.001秒=10-3秒</li>
<li>1μs 1微秒=0.000001=10-6秒</li>
<li>1ns 1纳秒=0.0000000001秒=10-9秒</li>
<li>1ps 1皮秒=0.0000000000001秒=10-12秒</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240113163128.png" /></p>
<ul>
<li><strong>基准程序(Benchmarks)</strong>:是专门用来进行性能评价的一组程序,对于不同的应用场合，应该选择不同的基准程序。<br />
</li>
<li><strong>固件</strong>:将程序固化在ROM中组成的部件称为固件</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240113172028.png" /></p>
<div class="note warning"><ul>
<li>存储字长等于MDR的位数，数据字长是数据总线一次能并行传送信息的位数，机器字长是CPU内部用于整数运算的数据通路的宽度，指令字长是一个指令字中包含的二进制代码的位数，且指令字长一般是存储字长整数倍</li>
<li>指令集更类似一个接口集合，或者说结构，相同指令不代表实现相同，接口是体系结构，实现则是计组</li>
<li>cpu的指令寄存器对用户是完全透明的</li>
<li>计算机“运算速度”指标的含义是每秒能执行多少条指令</li>
<li>cpu速度提高是通过提高频率实现的，也就是增加50%的cpu时间，相当于原来的时间除以1.5</li>
<li>机器字长一定等于CPU内部用于整数运算的运算器位数和通用寄存器宽度</li>
<li>全面代表计算机性能的是实际软件的运行情况</li>
<li>向后兼容是指时间上向后兼容，即新机器兼容使用以前机器的指令系统</li>
</ul>
</div>
<h1 id="数据">数据</h1>
<h2 id="数制与编码">数制与编码</h2>
<p>计算机使用二进制的原因：非1即0，在物理上容易区分，可以方便地转换成逻辑值，运算规则简单<br />
r进制数可以表示为：</p>
<p><span class="math display">\[
K_{n}r^{n}+K_{n-1}r^{n-1}+\cdots+K_{0}r^{0}+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_{i}r^{i}
\]</span></p>
<p>转换时高位补0，有倍数关系的进制可以若干位转换对应一位，否则一般使用基数乘除法<br />
对小数的进制转换，只需要分别对小数点前后的数字部分进行转换，然后拼接起来 ，但因为小数是离散的，所以不一定可以完全转化<br />
<img src="/assets/resources/Pasted%20image%2020240114164836.png" /> <img src="/assets/resources/Pasted%20image%2020240114164843.png" /> 符号“数字化”的数称为机器数，例如0表正， 1表负<br />
十位数字的4位二进制码叫BCD码</p>
<p>根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示,通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分， <img src="/assets/resources/Pasted%20image%2020240114172944.png" /></p>
<p>定点数编码表示法主要有4种：原码、补码、反码和移码</p>
<ol type="1">
<li>原码 首位是符号位，其他位与数值相等，不足字长的补零，小数尾部补零，整数头部补零，字长n+1时，小数表示范围是：</li>
</ol>
<p><span class="math inline">\({\mathrm{-}}(1-2^{-n})\leqslant x\leqslant1-2^{-n}\)</span><br />
整数范围是：</p>
<p><span class="math inline">\(-(2^{n}-1)\leqslant x\leqslant2^{n}-1\)</span><br />
原码简单直观，但0的表示不唯一，且运算较复杂</p>
<ol start="2" type="1">
<li>补码 正数的补码是他自己<br />
负小数的补码是其与+2的和，小数表示范围为：</li>
</ol>
<p><span class="math inline">\(-1\leqslant x\leqslant1-2^{-n}\)</span><br />
若字长是n+1负整数的补码相当于其与 <span class="math inline">\(2^{(n+1)}\)</span> 的和，表示范围是</p>
<p><span class="math inline">\(-2^{n}\leqslant x\leqslant2^{n}-1\)</span><br />
优点：零的补码唯一，相比原码可以多表示一个-2^n,补码运算规则比较简单，且符号位可以和数值位一起参加运算</p>
<ul>
<li>变形补码，又称模4补码，双符号位00表示正，11表示负，类似补码，区别只是负数加的是4</li>
<li>真值转换为补码：正数与原码一直，负数符号位取1，其他位由原码取反并加一得到</li>
<li>补码转换成真值：正数与原码一致，负数符号取负，其他位取反并加一</li>
</ul>
<ol start="3" type="1">
<li>反码，正数与原码一致，负数符号位不变，其他取反</li>
<li>移码，在真值上加上一个常数(偏置值)，通常这个常数取2^n
<ol type="1">
<li>移码中零的表示唯一,都是2^n</li>
<li>一个真值的移码和补码仅差一个符号位，符号位取反就能相互转化</li>
<li>移码全0时，对应真值的最小值<span class="math inline">\(-2^n\)</span>,移码全1时，对应真值的最大值<span class="math inline">\(2^n-1\)</span>。</li>
<li>移码可以反映数据原有的大小顺序</li>
</ol></li>
</ol>
<p><strong>无符号整数</strong>默认为正数，由于不需要符号位，表示的最大数更大 <span class="math inline">\(2^{n+1}-1\)</span></p>
<div class="note warning"><ul>
<li>二进制小数可以用十进制表示，反过来不行，因为相对于十进制，二进制小数是离散的</li>
<li>x补所有位取反加一就会得到(-x)补</li>
<li>N位的二进制小数可以表示的数的个数为 <span class="math inline">\(2^n\)</span> 而十进制小数能表示的数的个数为 <span class="math inline">\(10^n\)</span> ,意味着占比 <span class="math inline">\({0.2}^n\)</span> 的十进制小数可以用二进制精确表示</li>
<li>对负数的补码来说，数值部分越大，真值的绝对值越小，真值越大</li>
<li>H结尾一般表示16进制数</li>
<li>移码与补码表示的最小值绝对值比最大值绝对值大一，真值取反可能溢出</li>
<li>补码的符号位可以和数值部分一起参加运算</li>
</ul>
</div>
<h2 id="定点数值的运算">定点数值的运算</h2>
<h3 id="基本部件">基本部件</h3>
<ol type="1">
<li><p>一位全加器FA <img src="/assets/resources/Pasted%20image%2020240114230633.png" /> 和表达式：<span class="math inline">\(S_{i}=A_{i}\oplus B_{i}\oplus C_{i-1}\)</span><br />
进位表达式：<span class="math inline">\(C_{i}=A_{i}B_{i}+(A_{i}\oplus B_{i})C_{i-1}\)</span></p></li>
<li><p>串行进位加法器 把n个全加器相连可得到几位加法器，称为串行进位加法器,由于位数有限，高位自动丢失，所以实际是模2^n的加法运算<br />
<img src="/assets/resources/Pasted%20image%2020240114231045.png" /><br />
串行运算的效率会依赖于位数</p></li>
<li><p>并行进位加法器 <span class="math display">\[G_{i}=A_{i}B_{i},\;\;P_{i}=A_{i}\oplus B_{i},\]</span><br />
<span class="math display">\[C_{i}=G_{i}+P_{i}C_{i-1}\;\;\]</span></p></li>
</ol>
<p>称为<span class="math inline">\(A_iB_i\)</span>为进位产生函数，称<span class="math inline">\(A_{i}\oplus B_{i}\)</span>为进位传递函数<br />
G仅与Ai,Bi及最低进位C0有关，相互间的进位没有依赖关系</p>

$$\begin{array}{l}{{C_{1}=G_{1}+P_{1}C_{0}}}\\ {{C_{2}=G_{2}+P_{2}G_{1}+P_{2}P_{1}C_{0}}}\\ {{C_{3}=G_{3}+P_{3}C_{2}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}C_{0}}}\\ {{C_{4}=G_{4}+P_{4}G_{3}+P_{4}P_{3}G_{2}+P_{4}P_{3}P_{2}G_{1}+P_{4}P_{3}P_{2}P_{1}C_{0}}}\\ \end{array}$$


<p><img src="/assets/resources/Pasted%20image%2020240115000800.png" /><br />
随着加法器位数的增加，Ci的逻辑表达式会变得越来越长，这会使电路结构变得很复杂,可以分组，组内先行进位，组间串行进位，甚至组内组间都并行，通常采用两级或多级先行进位加法器。</p>
<ol type="1">
<li><p>带标志加法器 <img src="/assets/resources/Pasted%20image%2020240115195328.png" /></p></li>
<li><p>ALU(算术逻辑单元) 能进行多种算术运算和逻辑运算，核心是带标志加法器，同时也能执行“与” “或”“非”等逻辑运算<br />
其中A和B是两个n位操作数输入端，Cin是进位输入端，ALUop是操作控制端，用来决定ALU所执行的处理功能<br />
<img src="/assets/resources/Pasted%20image%2020240115195554.png" /></p></li>
</ol>
<h3 id="移位运算">移位运算</h3>
<p><strong>算术移位</strong></p>
<table>
<thead>
<tr class="header">
<th></th>
<th>码制</th>
<th>添补代码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>正数</td>
<td>原码补码反码</td>
<td>0</td>
</tr>
<tr class="even">
<td>负数</td>
<td>原码</td>
<td>0</td>
</tr>
<tr class="odd">
<td>负数</td>
<td>补码</td>
<td>左移添0，右移添1</td>
</tr>
<tr class="even">
<td>负数</td>
<td>反码</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>三种机器数算术移位后的符号位均不变。</p>
<p>双符号位的最高符号位代表真正的符号，而低位符号位用于参与移位操作以判断是否发生溢出，如01表示结果正溢出，10表示结果负溢出<br />
算术移位的情况下，补码左移不丢失精度的前提条件是其原最高有效位与原符号位要相同</p>
<p><strong>逻辑移位</strong> 将操作数视为无符号数，逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0。</p>
<p><strong>循环移位</strong> 分为带进位标志位CF的循环移位(大循环)和不带进位标志位的循环移位(小循环)<br />
<img src="/assets/resources/Pasted%20image%2020240115200514.png" /></p>
<h3 id="定点数的数学运算">定点数的数学运算</h3>
<p>定点数的实质是事先规定小数点位置，数据无需储存小数点，只关注具体运算</p>
<h4 id="加减">加减</h4>
<ol type="1">
<li>补码 符号位与数值位一起参与运算：<br />
<span class="math inline">\([A+B]_{\mathbb{补}}=[A]_{\mathbb{补}}+[B]_{\mathbb{补}}{\ \mathrm{(mod}\ 2^{n+1})}\)</span><br />
<span class="math inline">\([A-B]_{\mathbb{补}}=[A]_{\mathbb{补}}+[-B]_{\mathbb{补}}{\ \mathrm{(mod}\ 2^{n+1})}\)</span></li>
</ol>
<p>一个数真值的相反数的补码等于其补码所有位(包括符号位)取反并+1</p>
<p>其电路实现上，则相当于对Y和Y的取反进行一个选择，并对是否输入一个1进行选择，由一个sub控制端的0/1来决定，无符号整数的二进制表示相当于正整数的补码表示，因此，该电路同时也能实现无符号整数的加/减运算<br />
<img src="/assets/resources/Pasted%20image%2020240115201121.png" /> OF(Overflow Flag)溢出标志，用于判断带符号数加减运算是否溢出。OF=1 溢出；OF=0 未溢出<br />
<span class="math inline">\(\mathrm{OF}\equiv C_{\mathrm{n}}\oplus C_{\mathrm{n-1}}\)</span>符号位进位与最高数位进位的异或<br />
SF(Sign Flag)符号标志，用于判断带符号数加减运算结果的正负性。SF=1 结果为负；SF=0 结果为正<br />
<span class="math inline">\(\mathrm{SF}=\mathrm{S}_{n}\)</span>即运算结果最高位<br />
ZF(Zero Flag)零标志，用于判断加减运算结果是否为0。ZF=1 表示结果为0；ZF=0 表示结果不为0<br />
<span class="math inline">\(\mathrm{ZF}=\overline{S_{n}+\cdots+S_{2}+S_{1}}\)</span><br />
CF(Carry Flag)进位/借位标志，用于判断<strong>无符号数</strong>加减运算是否溢出。CF=1 溢出；CF=0 未溢出。无符号加减法，加法溢出必有(最高位)进位，减法溢出必有(最高位)借位<br />
<span class="math inline">\({\mathrm{CF}}=C_{\mathrm{out}}\oplus Sub\)</span> (Cout表示进位输出，即最高位进位，Sub是低位加法器的进位输入，为0表示加法运算，为1表示减法，被减数除了符号位取反，同时则作为低位进位实现补码加1的效果)</p>
<p>这些标志信息通常会被送入 PSW 程序状态字寄存器或者标志寄存器FR(Flag Register)<br />
<strong>溢出的判断</strong></p>
<ul>
<li>单符号位： 仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，例如正数之和符号位为1<br />
无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。<br />
设A的符号为As, B的符号为Bs，运算结果的符号为Ss，则溢出逻辑表达式为(0表示无溢出)</li>
</ul>


$$
V={A_{\mathrm{s}}}{B_{\mathrm{s}}}{\overline{{S_{\mathrm{s}}}}}+\overline{A_s}.\overline{B_{\mathrm{s}}}S_{\mathrm{s}}
$$  


<ul>
<li><p>双符号位(模4补码)： 运算结果的两个符号位Ss1Ss2相同，表示未溢出；运算结果的两个符号位不同，表示溢出<br />
Ss1Ss2的结果：</p>
<ul>
<li>00，正数无溢出</li>
<li>01，正溢出</li>
<li>10，负溢出</li>
<li>11，负数无溢出</li>
</ul></li>
</ul>
<p>进位情况:<br />
若符号位的进位Cs与最高数位的进位C1相同，则说明没有溢出，否则表示发生溢出。<br />
CS为0时是上溢，相反是负溢，类似双符号位<br />
溢出逻辑判断表达式为<span class="math inline">\(V=C_{s}\oplus C_{1},\)</span>，若V=0,表示无溢出；V=1,表示有溢出。</p>
<p>具体运算：</p>
<ol type="1">
<li><p>原码 加法：符号位相同的情况略，不同则用绝对值较大的减去较小的，取较大者的符号<br />
减法：转换成A与-B的加法</p></li>
<li><p>无符号整数<br />
加法略，减法将减数所有位取反再加一与被减数相加得到结果<br />
无符号数加法的溢出判断：最高位产生的进位=1时，发生溢出，否则未溢出。<br />
无符号数减法的溢出判断：减法变加法，最高位产生的进位=0时，发生溢出，否则未溢出</p></li>
</ol>
<h4 id="乘除">乘除</h4>
<ol type="1">
<li>乘法运算由累加和右移操作实现，可分为原码一位乘法和补码一位乘法。</li>
</ol>
<ul>
<li>原码一位乘法 <img src="/assets/resources/Pasted%20image%2020240115214143.png" /></li>
</ul>
<p>无符号数乘法运算电路，从低到高进行加法，每加一次就逻辑右移<br />
<img src="/assets/resources/Pasted%20image%2020240115215314.png" /></p>
<ul>
<li>补码一位乘法(Booth算法) <img src="/assets/resources/Pasted%20image%2020240115215614.png" /> <code>x*y=-0.10001111</code><br />
电路实现：每次从寄存器丫移出的最低位和它的前一位来决定是<code>-[x]补、+［x］补还是+0</code>。<br />
<img src="/assets/resources/Pasted%20image%2020240115220452.png" /></li>
</ul>
<ol start="2" type="1">
<li>除法 分为原码除法和补码除法</li>
</ol>
<div class="note info"><p>符号拓展：把低位整数转换成高位整数，但符号与真值不变<br />
正数的符号扩展非常简单，即符号位不变，新表示形式的所有扩展位都用0进行填充。<br />
负数的符号扩展方法则根据机器数的不同而不同。原码表示负数的符号扩展方法与正数相同<br />
补码表示负数的符号扩展方法：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1 (对于整数)或0(对于小数)进行填充。</p>
</div>
<ul>
<li><p>原码除法运算(不恢复余数法) <img src="/assets/resources/Pasted%20image%2020240116102453.png" /> <img src="/assets/resources/Pasted%20image%2020240116102504.png" /></p></li>
<li><p>补码除法运算(加减交替法) <img src="/assets/resources/Pasted%20image%2020240116102537.png" /></p></li>
</ul>
<p><span class="math inline">\([x/y]_{补}=1.0101\,,\ \ 余\ 0.0111\times2^{-4}.\)</span></p>
<p>电路实现： <img src="/assets/resources/Pasted%20image%2020240116102700.png" /> 寄存器RQ分别存放被除数的高位低位，每次计算时同步左移</p>
<p>原码加减交替法最多加减N+2次(最后不够减要恢复余数)，最后够减就是N+1次<br />
补码加减交替法最多加减N+1次，商末尾恒置1</p>
<h3 id="数据的存储与表示">数据的存储与表示</h3>
<div class="note info"><ul>
<li>同字长的类型，c语言中强制类型转换的结果保持位值不变，仅改变了解释这些位的方式，例如<code>short</code> 和<code>unsigned short</code></li>
<li>当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接截断，低位直接赋值</li>
<li>短字长到长字长的转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行零扩展，扩展后的高位部分用0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。(char类型为8位无符号整数，其在转换为int时高位补0)</li>
</ul>
</div>
<p>通常用最低有效字节(LSB)和最高有效字节(MSB)来分别表示数的低位和高位。例如，在32位计算机中，一个int型变量i的机器数为<code>01 23 45 67H</code>,其最高有效字节MSB = 01H,最低有效字节LSB = 67H<br />
现代计算机基本上都采用字节编址，即每个地址编号中存放1字节,多字节数据都存放在连续的字节序列中，排列方式可分为：</p>
<ul>
<li>大端方式按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面</li>
<li>小端方式按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面</li>
</ul>
<p>对于机器字长为32位的计算机，数据如果以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍<br />
数据不按边界对齐时，节省空间，但会增加访问地址的次数与连接不同数据的计算量<br />
<img src="/assets/resources/Pasted%20image%2020240115222444.png" /></p>
<div class="note warning"><ul>
<li>ALU是由组合逻辑电路构成的，最基本的部件是并行加法器</li>
<li>数据总线供ALU与外界交互数据使用，也是运算器部件</li>
<li>不带进位的循环左移将最高位进入最低位和标志寄存器C位</li>
<li>模4补码具有模2补码的全部优点且更易检查加减运算中的溢出问题</li>
<li>存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的</li>
<li>采用双符号位时，第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出，可用一个异或判断</li>
<li>补码一位乘法中，最多需要n次移位，n+1次加法运算。原码乘法移位和加法运算最多均为n次</li>
<li>补码乘法右移n次，因此结果长度为2N</li>
<li>原码不恢复余数虽然名字如此，但最后一步不够减时需要恢复余数</li>
<li>做减法时，低位进位为Sub,即为1(Sub决定多路选择器是否将y的各位取反，也就是说补码的话之后还需要用多路复用器mux+1)</li>
<li>c语言中short是半字，int是字，char是1B，在常见的32位计算机中，按边界对齐就是一个32位的字可以放两个short一个int四个char</li>
<li>乘法运算可以通过加法和移位来实现。编译器可以将乘法运算转换为一个循环代码段,在循环代码段中通过比较、加法和移位等指令实现乘法运算</li>
<li>阵列乘法器实现的乘法指令比使用ALU与位移器实现的快，只需要一个时钟周期</li>
<li>对无符号整数乘法，高n位都是0时，结果不会溢出</li>
<li>ALU生成标志位时只负责计算，而不管运算对象是有符号数还是无符号数，CF= 1表示当作无符号数运算时溢出，OF= 1表示当作有符号数运算时溢出</li>
</ul>
</div>
<h2 id="浮点数的表示和运算">浮点数的表示和运算</h2>
<p>浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动，一般表示为：<span class="math inline">\({\cal N}=(-1)^{S}\times M\times R^{E}\)</span><br />
S取值0或1,用来决定浮点数的符号；M是一个二进制定点小数，称为尾数，一般用定点原码小数表示；E是一个二进制定点整数，称为阶码或指数，用移码表示。R是约定好的基数<br />
阶码的值反映浮点数的小数点的实际位置；阶码的位数反映浮点数的表示范围；尾数的位数反映浮点数的精度。<br />
<img src="/assets/resources/Pasted%20image%2020240116204934.png" /> 浮点数的范围关于原点对称，超出范围会导致溢出，其中，下溢会被视为0</p>
<p><strong>规格化操作</strong><br />
指通过调整一个非规格化浮点数的尾数和阶码的大小,使非零的浮点数在尾数的最高数位上保证是一个有效值</p>
<ul>
<li>左规：当运算结果的尾数的最高数位不是有效位。左规时，尾数每左移一位、阶码减1 (基数为2时)。左规可能要进行多次</li>
<li>右规：当运算结果的尾数的有效位进到小数点前面时，需要进行右规。将尾数右移一位、阶码加1 (基数为2时)。需要右规时，只需进行一次。</li>
</ul>
<p>规格化浮点数的尾数M的绝对值应该满足<span class="math inline">\(1/R\leqslant|M|\lt 1,\)</span>对原码来说，其绝对值的上下界分别是<span class="math inline">\((1-2^{-n})\)</span>和1/2</p>
<p><strong>IEEE 754标准</strong></p>
<ul>
<li>短浮点数(单精度、float型)</li>
<li>长浮点数(双精度、double型)</li>
<li>临时浮点数 <img src="/assets/resources/Pasted%20image%2020240116215743.png" /> <img src="/assets/resources/Pasted%20image%2020240116215753.png" /> 规格化的浮点数最高位总是1，因此可以隐去，短浮点数与长浮点数都采用隐藏尾数最高数位的方法，因此可多表示一位尾数<br />
存储浮点数阶码之前，偏置值要先加到阶码真值上。<br />
eg.规格化的短浮点数真值为：<br />
<span class="math display">\[(-1)^{S}\times1.M\times2^{E-127}\]</span></li>
</ul>
<p>短浮点数E的取值为1〜254 (8位表示)，M为23位，共32位<br />
长浮点数E的取值为1〜2046 (11位表示)，M为52位,共64位。<br />
最值则分别在EM的同时最小与同时最大处取，分别是<span class="math inline">\(2^{-(偏置值-1)}\)</span>与<span class="math inline">\(2^{E_{max}-偏置值}*(2-2^{-M})\)</span><br />
<strong>IEEE 754格式的浮点数，阶码偏移量不是2^n，是固定值127与1023</strong><br />
阶码全0或全1时，有其特别的解释<br />
<img src="/assets/resources/Pasted%20image%2020240116221404.png" /></p>
<p>与定点数区别：</p>
<ul>
<li>相同字长时浮点数范围更大</li>
<li>相同字长时浮点数精度更低</li>
<li>浮点运算需要规格化，并运算阶码和尾码，更为复杂</li>
<li>定点数结果超出表示范围则溢出，浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。</li>
</ul>
<h3 id="浮点数的加减运算">浮点数的加减运算</h3>
<ol type="1">
<li>对阶，使两个操作数的小数点位置对齐，阶码相等。将阶码小的尾数右移一位(基数为2),阶加1,直到两个数的阶码相等为止，过程可能舍弃有效位影响精度</li>
<li>尾数求和，尾数按定点数规则运算</li>
<li>对结果进行规格化(左规一次相当于乘2,右规一次相当于除2)
<ol type="1">
<li>1.xxxx时，右规</li>
<li>0.0xx01xxxx时，左规</li>
</ol></li>
<li>在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将低位移出位保留下来，参加中间过程的运算，最后将运算结果进行舍入
<ol type="1">
<li>0舍1入法，舍入为最近的可表示数,正好中间时，则选择结果为偶数。这样可能会使尾数溢出，此时需再做一次右规</li>
<li>恒置1法，都把右移后的尾数末位恒置1。</li>
<li>截断法：直接截取所需位数，丢弃后面的所有位</li>
</ol></li>
<li>溢出判断，在尾数规格化和尾数舍入时，可能会对阶码执行加/减运算。这时可能指数溢出
<ol type="1">
<li>右规时数值很大的尾数舍入时，可能因为末位加1而发生尾数溢出，此时需要通过右规来调整尾数和阶，导致阶数加一，若右规后阶数全1则发生上溢</li>
<li>左规时类似前者，阶数全0则下溢</li>
</ol></li>
</ol>
<div class="note info"><p>C语言中的float和double类型分别对应于IEEE 754单精度浮点数和双精度浮点数。long double类型对应于扩展双精度浮点数.<br />
常见的类型转换中：</p>
<ul>
<li>char-&gt;int-&gt;long-&gt;double和float-&gt;double不会损失精度</li>
<li>int转换为float时，虽然不会发生溢出，但float尾数连隐藏位共24位，当int型数的第24〜31位非0时，无法精确转换成24位浮点数的尾数，需进行舍入处理，影响精度。</li>
<li>double-&gt;float可能损失精度或溢出</li>
<li>float或double转换为int时，只保留整数部分，且可能溢出</li>
</ul>
<p>用移码表示阶码的优点：</p>
<ul>
<li>浮点数进行加减运算时要比较阶码的大小，移码比较大小更方便</li>
<li>检验移码的特殊值(0和max)时比较容易，0时相当于分母无穷大，表示负无穷大，max表示指数正无穷大，但若max时尾数不为0，则表示运算错误</li>
</ul>
<p>浮点数舍入方法应该使误差尽可能对称，且高效</p>
<ul>
<li>就近舍入，舍入为最近可表示的数</li>
<li>正向舍入，取右侧的数</li>
<li>负向舍入</li>
<li>截取，取绝对值小的数</li>
</ul>
<p><strong>关于基数</strong><br />
现假设尾数(含符号位)用4位2进制存储，则某以2为基数的浮点数规格化后为:<code>0.101*2^(-1)</code><br />
如果换乘以4为基数，规格化后就是:<code>0.010(1)*4^0</code><br />
由于基数更大，就需要更长的尾数表达一个数，因此尾数越大，前面没必要存的0就越多，这些对精度没有任何贡献的0占据的位置越多，精度就越低<br />
基数不等于进制，基数越大精度越低，进制越大精度越高。<strong>本质上说基数与阶码相对，更大的基数会减少尾数的表达能力，但增加阶码即整个浮点数的表示范围</strong><br />
或者说，更大的基数，其阶码的变动就需要尾数更大幅度的变化，从而使表示的数变得稀疏</p>
<p><strong>关于溢出的总结</strong></p>
<ul>
<li>阶码上溢出。一个正指数超过了最大允许值时，浮点数发生上溢出(即向∞方向溢出)。若结果是正数，则发生正上溢出(有的机器把值置为+∞);若结果是负数，则发生负上溢出(有的机器把值置为-∞)<strong>右规和尾数舍入都可能引起阶码上溢(尾数溢出时结果不一定溢出)</strong></li>
<li>阶码下溢出。一个负指数比最小允许值还小时，浮点数发生下溢出。一般机器把下溢出时的值置为0 (+0或-0)。<strong>左规时可能引起阶码下溢</strong></li>
<li>尾数溢出。当尾数最高有效位有进位时，发生尾数溢出。此时，进行“右规”操作：尾数右移一位，阶码加1,直到尾数不溢出为止。此时，只要阶码不发生上溢出，浮点数就不会溢出</li>
<li>非规格化尾数。当数值部分高位不是一个有效值时(如原码时为0或补码时与符号位相同)，尾数为非规格化形式。此时，进行“左规”操作：尾数左移一位，阶码减1，直到尾数为规格化形式为止</li>
<li>对阶不会引起阶码上溢或下溢(阶码维持在与较大者一致)</li>
</ul>
</div>
<div class="note warning"><ul>
<li>可表示的数据个数取决于编码所采用的位数,编码位数一定，编码出来的数据个数就是一定的，浮点数和定点数没有不同(除非编码和值不是一一对应)</li>
<li>基数越大，范围越大，但精度变低(数变稀疏)，运算中尾数右移的可能性越小，运算的精度损失越小，规格化更少，运算速度也更高</li>
<li>补码规格化的尾数，符号位与尾数最高位相反</li>
<li>对阶是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减小、尾数左移的情况</li>
<li>采用规格化浮点数的目的主要是为了增加数据的表示精度</li>
<li>上下溢都是绝对值超出表示范围，和正负无关</li>
<li><code>IEEE 754</code>标准格式中，阶码全为0,尾数不全为0表示非规格化数，非规格化数可用于处理阶码下溢,上溢则只能报错(这种情况下尾数前不用补1,即实际数值为0.M,实际阶码固定为-126，用于表示绝对值极小的数)</li>
<li>浮点数舍入的情况有两种：对阶、右规格化，定点数不需要舍入</li>
<li>float保存24位整数，<span class="math inline">\(2^{24}\)</span>以内的整数int可以无损转换</li>
<li>浮点数的加减运算，右规不会超过一次，左规不会超过n次</li>
<li>阶码上溢可能出现于运算完的右规或尾数舍入，下溢可能出现于运算完左规</li>
</ul>
</div>
<h1 id="存储器">存储器</h1>
<h2 id="概念">概念</h2>
<p><strong>功能分类</strong></p>
<ul>
<li>主存，存放cpu计算需要的程序与数据可以和cache与辅存交换数据</li>
<li>辅助存储器，也就是外存，可以在寿命内长时间存放信息</li>
<li>高速缓冲存储器，cache，位于主存与cpu之间，通常和cpu集成</li>
</ul>
<p><strong>存取方式分类</strong></p>
<ul>
<li>随机存储器(RAM)</li>
<li>只读存储器(ROM),断电不会丢失数据</li>
<li>串行访问存储器，需按其物理位置的先后顺序寻址
<ul>
<li>顺序存取存储器，只能按某种顺序存取(磁带)</li>
<li>直接存取存储器，寻找到一定区域，在区域内顺序查找(磁盘，光盘)</li>
</ul></li>
</ul>
<p><strong>可保存性分类</strong></p>
<ul>
<li>易失性存储器，如RAM</li>
<li>非易失性存储器，如ROM、磁表面存储器和光存储器</li>
</ul>
<p><strong>指标</strong>：</p>
<ul>
<li>存储容量=存储字数X字长(1Byte=8bit)</li>
<li>单位成本：每位价格=总成本/总容量。</li>
<li>存储速度：数据传输率=数据的宽度/存取周期
<ul>
<li>存取时间(Ta)：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间</li>
<li>存取周期(Tm)：存取周期又称读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，也就是连续两次访问存储器之间所必需的最短时间间隔</li>
<li>主存带宽(Bm)：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量(B/s)</li>
</ul></li>
</ul>
<p>在读写操作之后，总要有一段恢复内部状态的复原时间,因此一般存取周期大于存取时间</p>
<p><img src="/assets/resources/Pasted%20image%2020240117165807.png" /> 上一层的存储器一般作为低一层存储器的高速缓存，Cache-主存层和主存-辅存层中，上层内容是下一层的一部分</p>
<div class="note info"><p>主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的<br />
而主存和辅存之间的数据调动则是由硬件和操作系统共同完成的，对应用程序员是透明的。</p>
<ul>
<li>存取时间是执行一次读操作或写操作的时间，分为读出时间和写入时间</li>
<li>存储周期是指存储器进行连续两次独立地读或写操作所需的最小时间间隔</li>
</ul>
</div>
<div class="note warning"><ul>
<li>1MB=<span class="math inline">\(2^{20}B\)</span></li>
<li>1s=<span class="math inline">\(10^3ms\)</span>=<span class="math inline">\(10^6\)</span>μs=<span class="math inline">\(10^9ns\)</span></li>
<li>速度排名：寄存器-Cache-主存-辅存</li>
<li>两个不同速度的存储器共同访问时，快者未命中时总访问时间是慢者时间，不同时访问则是两者时间之和</li>
<li>Cache主存系统的效率=访问Cache的时间/平均访存时间</li>
</ul>
</div>
<h2 id="主存储器">主存储器</h2>
<p>主存储器由DRAM实现，靠处理器的那一层(Cache)则由SRAM实现，它们都属于易失性存储器，只要电源被切断，原来保存的信息便会丢失。DRAM的每位价格低于SRAM,速度也慢于SRAM<br />
DRAM电容上的电荷一般只能维持1〜2ms,每隔一定时间必须刷新，通常取2ms,称为刷新周期。</p>
<ul>
<li>集中刷新：指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”。</li>
<li>分散刷新：把对每行的刷新分散到各个工作周期中。增加了存取周期，但没有死区</li>
<li>异步刷新：具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔。利用逻辑电路每隔时间t产生一次刷新请求。减少刷新次数，也能避免死区过多</li>
</ul>
<div class="note info"><ul>
<li>刷新对CPU是透明的，即刷新不依赖于外部的访问</li>
<li>动态RAM的刷新单位是行，由芯片内部自行生成行地址</li>
<li>刷新时不需要选片，即整个存储器中的所有芯片同时被刷新</li>
</ul>
</div>
<p><img src="/assets/resources/Pasted%20image%2020240117214529.png" /> <img src="/assets/resources/Pasted%20image%2020240117214601.png" /> 存储器芯片由存储体、I/O读写电路、地址译码和控制电路等部分组成。</p>
<ul>
<li>存储体(存储矩阵)。存储体是存储单元的集合,它由行选择线(X)和列选择线(Y)来选择所访问单元</li>
<li>地址译码器。用来将地址转换为译码输出线上的高电平，以便驱动相应的读写电路</li>
<li>I/O控制电路。用以控制被选中的单元的读出或写入</li>
<li>片选控制信号,访问某个字必须选中且只选中其所在芯片，因此需要信号加以控制</li>
<li>读/写控制信号。根据CPU给出的读命令或写命令，控制被选中单元进行读或写 <img src="/assets/resources/Pasted%20image%2020240117215030.png" /></li>
</ul>
<p><strong>只读存储器(ROM)</strong> 结构更简单，存储密度更高，且更可靠</p>
<ul>
<li>掩模式只读存储器MROM，制造时厂商写入，无法更改</li>
<li>一次可编程只读存储器PROM，可以用专门设备写入且只能写入一次</li>
<li>可擦除可编程只读存储器EPROM，可以多次写入，但次数有限，且写入时间较长</li>
<li>flash存储器，不加电可以长期保存信息，也可以快速擦除重写，且价格较便宜，集成度高,存储元由MOS管组成，是一种半导体存储器,采用随机访问方式，可替代计算机外部存储器</li>
<li>固态硬盘SSD，长期保存信息、快速擦除与重写，读写速度快、低功耗</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240117215509.png" /> <strong>主存储器(Main Memory, MM)</strong></p>
<ul>
<li>记忆单元，储存一个个0/1，构成存储矩阵的基本单位</li>
<li>编制单位，有相同地址的存储元件构成的单位，一般按字节编址</li>
</ul>
<p>指令访问主存的过程:</p>
<ol type="1">
<li>cpu将地址送到MAR，并通过地址线将其送到主存的地址寄存器</li>
<li>与1.同时,将读写信号送到主存的读写控制电路(通过控制线)</li>
<li>执行指令，读写期间MDR用于存放具体数据</li>
</ol>
<p>数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同，地址线位数会决定主存地址空间的寻址范围(从0开始索引)<br />
DRAM通常采用地址引脚复用技术，行地址和列地址通过相同的引脚分先后两次输入</p>
<p><strong>多模块存储器</strong><br />
多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体低位交叉存储器</p>
<ol type="1">
<li>单体多字系统,存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。
<ul>
<li>一个存取周期中，从同一个地址取m条指令，依次送到cpu,每隔1/m存取周期，CPU向主存取一条指令,提高效率，但不适用于非连续的指令或数据</li>
</ul></li>
<li>多体并行存储器,由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作
<ol type="1">
<li>高位交叉编址(顺序方式)，高位地址表示体号，低位地址为体内地址。把低位的体内地址送到由高位体号确定的模块内进行译码，访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，本质依旧是串行</li>
<li>低位交叉编址(交叉方式)，低位地址为体号，高位地址为体内地址。每个模块按“模加”交叉编址，模块号=单元地址% m，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽
<ul>
<li>通俗易懂地理解：存取周期包括数据的传送和存储器的恢复，总线周期r是单纯读取数据的时间，因此所有要读的字存在不同模块时，读完一个模块就可以去下一个模块读，读完剩下的模块后，第一个模块已经恢复，这样就可以一直读下去</li>
<li>设模块字长等于数据总线宽度，模块存取一个字的存取周期为T,总线传送周期为r,为实现流水线方式存取，存储器交叉模块数应大于等于<span class="math inline">\(m=T/r\)</span>,m称为交叉存取度。每经过r时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于等于m，以保证启动某模块后经过加<code>m*r</code>的时间后再次启动该模块时，其上次的存取操作已经完成(即流水线不间断)。</li>
<li>连续存取m个字所需的时间为<span class="math inline">\(t_{1}=T+(m-1)r\)</span>,远少于顺序读取时间mT</li>
</ul></li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240117221818.png" /> <img src="/assets/resources/Pasted%20image%2020240117222135.png" /> <img src="/assets/resources/Pasted%20image%2020240118225544.png" /></p>
<div class="note warning"><ul>
<li>芯片若是<span class="math inline">\({2^n}\times{x}\)</span> ，则说明需要n根地址线，x根数据线，此外还需要两条读写线和一条片选线</li>
<li>DRAM芯片的集成度高于SRAM</li>
<li>sram用两个稳定电路存储，dram用电容暂存，1是有电情况</li>
<li>使用地址复用时，地址线减半，增加两条行/列通选线，其中行通选线兼用于片选(仅用于DRAM)</li>
<li>随机存取与随机存取存储器(RAM)不同，支持随机存取的存储器不一定是RAM，如u盘基于flash，因此其实是ROM</li>
<li>DRAM刷新只需要一个存储周期</li>
<li>高位交叉存储器在单个存储器中的字是连续存放的，不满足程序的局部性原理(连续读出彼此地址相差一个存储体容量的字)；而低位交叉存储器是交叉存放,满足局部性原理</li>
<li>双端口存储器具有两套独立读/写口，具有各自的地址寄存器和译码电路,所以可以同时访问同一区间、同一单元</li>
<li>ROM较慢，不可用作Cache</li>
<li>根据历年408真题的描述, 交叉编址方式就是指低位交叉编址,这种情况下最低位<span class="math inline">\(\log_{2}m\)</span>决定体号</li>
<li>ROM写速度小于读速度(需要擦除)</li>
<li>可能发生访存冲突的情况：给定的访存地址在<strong>相邻的m次访问</strong>中出现在同一个存储模块内</li>
<li>一个存储周期可对所有芯片各读取相同位置的1字节，因此不是从0号芯片存取的<span class="math inline">\(m*n\)</span>位数据，需要n+1轮周期</li>
</ul>
</div>
<h2 id="主存储器与cpu的连接">主存储器与CPU的连接</h2>
<ol type="1">
<li>主存储器通过数据总线、地址总线和控制总线与CPU连接</li>
<li>数据总线的位数与工作频率的乘积正比于数据传输率</li>
<li>地址总线的位数决定了可寻址的最大内存空间</li>
<li>控制总线(读/写)指出总线周期的类型和本次输入/输出操作完成的时刻 <img src="/assets/resources/Pasted%20image%2020240119160205.png" /><br />
主存一般由多个芯片集成而成，通过总线与cpu相连<br />
<img src="/assets/resources/Pasted%20image%2020240119160435.png" /><br />
内存条插槽就是存储器总线，内存条主存中的信息通过内存条的引脚，再通过插槽内的引线连接到主板上，通过主板上的导线连接到CPU芯片</li>
</ol>
<p>有时需要对芯片字与位进行拓展，满足容量需求</p>
<ul>
<li>位拓展，CPU的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位，将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出，例如八片1位芯片并联，每片作为cpu数据线的一位(需要片选信号CS来进行这种全选)</li>
<li>字拓展，将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。每次片选信号只会选中一个芯片</li>
<li>字位同时扩展，结合两者，此时各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号或采用译码器设计连接到相应的芯片</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240119160847.png" alt="地址线A12〜A0、CS＞砺都分别连在一起" /> <img src="/assets/resources/Pasted%20image%2020240119161006.png" alt="D0〜D7和WE都分别连在一起。将A15A14用作片选信号" /> <img src="/assets/resources/Pasted%20image%2020240119161132.png" /> cpu选择存储芯片，称为片选，随后选择存储单元，称为字选<br />
片内的字选通常是由CPU送出的N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端(N由片内存储容量<span class="math inline">\(2^N\)</span>决定) 片选信号的产生则分为：</p>
<ul>
<li>线选法：除片内寻址外的高位地址线直接(或经反相器)分别接至各个存储芯片的片选端,，某条地址线为0时表示选中对应芯片，低位线A10~A0用于字选。这样不需要地址译码器，线路简单，地址空间不连续产生浪费。如以下表格所示</li>
<li>译码片选法：用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号，例如字选剩下的可用地址线不足时，剩下的若干位用于地址译码，即视作直接的二进制信号</li>
</ul>
<table>
<thead>
<tr class="header">
<th>芯片</th>
<th>A14~A11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0#</td>
<td>1110</td>
</tr>
<tr class="even">
<td>1#</td>
<td>1101</td>
</tr>
<tr class="odd">
<td>2#</td>
<td>1011</td>
</tr>
<tr class="even">
<td>3#</td>
<td>0111</td>
</tr>
</tbody>
</table>
<div class="note info"><p>若干注意点：存储芯片，地址，数据，读写命令，片选线：</p>
<ul>
<li>通常选用ROM存放系统程序、标准子程序和各类常数，RAM则是为用户编程而设置的</li>
<li>CPU的地址线数往往比存储芯片的地址线数要多。通常将CPU地址线的低位与存储芯片的地址线相连,用于字选，译码由存储芯片实现，而CPU地址线的高位则在扩充存储芯片时使用，用于片选，译码由外接译码器实现</li>
<li>cpu数据线数与存储芯片数据线数也可能不等，需要扩位</li>
<li>CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写，有时cpu会分为两条线，<span class="math inline">\(\overline{RD}\)</span>和<span class="math inline">\(\overline{WE}\)</span>，均为低电平有效，需要分别连接到存储芯片的允许读/写控制端</li>
<li>片选有效信号与CPU的访存控制信号<span class="math inline">\(\overline{MREQ}\)</span>(低电平有效)，为高是表示cpu正在访问内存</li>
</ul>
</div>
<div class="note warning"><ul>
<li>片选信号的译码器的输入地址线是去掉用于产生字数的位的首n根地址线</li>
<li>MAR的位数必须能访问整个主存地址空间，因此可以大于实际的物理空间</li>
</ul>
</div>
<h2 id="外部存储器">外部存储器</h2>
<p>磁盘存储器：</p>
<ol type="1">
<li>容量大，价格低</li>
<li>可重复使用</li>
<li>可长期保存不易丢失</li>
<li>非破坏性读出</li>
<li>存取相对较慢，且机械结构对环境有一定要求</li>
</ol>
<p>组成：</p>
<ul>
<li>磁盘驱动器
<ul>
<li>磁头组件</li>
<li>盘片组件</li>
</ul></li>
<li>磁盘控制器</li>
<li>盘片</li>
</ul>
<p>存储：一块硬盘有若干记录面，记录面有若干磁道，磁盘划分若干扇区，扇区是最小单位</p>
<ul>
<li>磁头数：对应记录面数</li>
<li>柱面数：对应磁道数，指不同盘片上垂直分布的各个磁道</li>
<li>扇区数</li>
</ul>
<p>原理：磁头与磁盘相对运动时，电磁转换产生信号<br />
指标：</p>
<ul>
<li>记录密度。记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积</li>
<li>磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁化单元总数，它由道密度和位密度计算而来；格式化容量是指按照某种特定的记录格式所能存储信息的总量。格式化后的容量比非格式化容量要小</li>
<li>平均存取时间。平均存取时间由寻道时间(磁头移动到目的磁道的时间)、旋转延迟时间(磁头定位到要读写扇区的时间)和传输时间(传输数据所花费的时间)三部分构成。</li>
<li>数据传输率。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。假设磁盘转数为r转/秒，每条磁道容量为N字节，则数据传输率为<span class="math inline">\(D_{r}=r N\)</span></li>
</ul>
<p>地址的常见格式(位数取决与需要编址的数量)：</p>
<table>
<thead>
<tr class="header">
<th>驱动器号</th>
<th>柱面号</th>
<th>盘面号</th>
<th>扇区号</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>硬盘的主要操作是寻址、读盘、 写盘。 每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。</p>
<p><strong>磁盘阵列</strong><br />
将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</p>
<ul>
<li>RAID0：无冗余和无校验的磁盘阵列。</li>
<li>RAID1：镜像磁盘阵列。</li>
<li>RAID2：采用纠错的海明码的磁盘阵列。</li>
<li>RAID3：位交叉奇偶校验的磁盘阵列。</li>
<li>RAID4：块交叉奇偶校验的磁盘阵列。</li>
<li>RAID5：无独立校验的奇偶校验磁盘阵列。</li>
</ul>
<p>ssd:基于闪存技术的存储器,与u盘原理相同，由一个或多个闪存芯片和闪存翻译层组成，翻译层翻译cpu请求<br />
一个闪存有B块，每块有P页，数据以页为单位读写，但写任何数量的页需要擦除整个块，因此写相对读更慢，且会消耗固态寿命<br />
<img src="/assets/resources/Pasted%20image%2020240119185327.png" /></p>
<div class="note warning"><ul>
<li>读一个扇区中数据所用的时间=找磁道的时间+找扇区的时间+磁头扫过一个扇区的时间。找磁道的时间是指磁头从当前所处磁道运动到目标磁道的时间,即寻道时间，可用移动1/2半径的时间估算；找扇区的时间是指磁头从当前所处扇区运动到目标扇区的时间，一般用转半圈的时间估算；磁头扫过一个扇区的时间一般用转一圈的时间除以磁道的扇区数估算</li>
<li>磁盘存储器的最小读写单位为一个扇区</li>
</ul>
</div>
<div class="note info"><p>考研无关：<br />
408(准确地说是王道)告诉我们，固态硬盘写入需要先擦除整块，因此比读更慢，实际测试一下的话，(在我的硬盘上)连续读写和多线程随机读写确实如此，但单线程就不对了，随机读比随机写慢了快一倍，这是为什么呢<br />
​这主要是因为王道写书的时候没有去固态硬盘吧看看，现在很多民用盘会给缓存，比如sn550就有slc缓存，写入可以直接写到缓存里，而随机读就很难缓存，当然这也无所谓，考试也不会考500预算有缓无缓盘买哪个<br />
​下一个问题是为什么多线程读就变好了，比较直观的猜想是，读可以并行或者流水线，写要阻塞很久才能进行下一次，不过这个大概只有专业人士才知道细节……</p>
</div>
<h2 id="高速缓冲存储器">高速缓冲存储器</h2>
<p><strong>程序访问的局部性原理</strong>(略)<br />
高速缓冲技术就是利用局部性原理，把程序中正在使用的部分数据存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而提高程序的执行速度。</p>
<h3 id="cache工作原理">Cache工作原理</h3>
<p>Cache位于存储器层次结构的顶层，通常由SRAM构成<br />
Cache和主存都被划分为相等的块，Cache块又称Cache行，每块由若干字节组成，块的长度称为块长(Cache行长) Cache块数要远少于主存中的块数.其替换过程由硬件实现<br />
CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cache块为单位<br />
对Cache的访问可以和主存同步或者异步进行，同步时，命中则主存访问终止，不命中则替换<br />
CPU欲访问的信息已在Cache中的比率称为Cache的命中率。设一个程序执行期间，Cache<br />
的总命中次数为<span class="math inline">\(N_C\)</span>，访问主存的总次数为<span class="math inline">\(N_m\)</span>,则命中率为 <span class="math display">\[H=N_{\mathrm{c}}/(N_{\mathrm{c}}+N_{\mathrm{m}})\]</span> <span class="math inline">\(t_ct_m\)</span>分别是命中与未命中的访问时间，平均访问时间为：<br />
<span class="math display">\[T_{\mathrm{a}}=H t_{\mathrm{c}}+(1-H)\,t_{\mathrm{m}}\]</span> <img src="/assets/resources/Pasted%20image%2020240122110823.png" /></p>
<ol type="1">
<li>数据查找。判断数据是否在Cache</li>
<li>地址映射。主存如何存放在Cache,如何进行地址转换</li>
<li>替换策略。</li>
<li>写入策略。保证数据一致性并提高效率</li>
</ol>
<h3 id="地址映射">地址映射</h3>
<p><strong>地址映射</strong>是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cache<br />
Cache中要为每块加一个标记，指明它是主存中哪一块的副本；说明Cache行中的信息是否有效，每个Cache行需要一个有效位。</p>
<p>地址映射方式：</p>
<ol type="1">
<li><p>直接映射，主存中的每一块只能装入Cache中的唯一位置，若这个位置已有内容，原来的块将无条件地被替换出去(块冲突概率最高，空间利用率最低), 即：Cache行号=主存块号mod Cache总行数<br />
假设Cache有<span class="math inline">\(2^c\)</span>行，主存有<span class="math inline">\(2^m\)</span>块，主存块号的低c位正好是它要装入的Cache行号。给每个Cache行设置一个长为<code>t = m - c</code>的标记，当主存某块调入Cache后，就将其块号的高t位设置在对应Cache行的标记中<br />
如图，主存地址去除t位的剩下c位，就会对应实际上的Cache地址(如果有效的话)<br />
访存过程：</p>
<ol type="1">
<li>根据c位行号找到对应Cache行</li>
<li>比较标记与主存高t位标记，若相等且有效位为1，则命中，根据主存的低位地址读取信息</li>
<li>不等或有效位0，从主存读出地址的信息，送到对应Cache行，有效位置1，标记设为地址中高t位，数据送到CPU <img src="/assets/resources/Pasted%20image%2020240122112021.png" /></li>
</ol></li>
<li><p>全相联映射<br />
主存中的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块,所以CPU访存时需要与所有Cache行的标记进行比较<br />
优点是比较灵活,Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的比较速度较慢，实现成本较高<br />
<img src="/assets/resources/Pasted%20image%2020240122113344.png" /></p></li>
<li><p>组相联映射<br />
将Cache分成Q个大小相等的组，每个主存块可以装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式<br />
如图，当Q=1时变为全相联映射，当Q=Cache行数时变为直接映射.假设每组有r个Cache行,则称之为r路组相联<br />
Cache组号=主存块号 mod Cache组数(Q) 选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。<br />
<img src="/assets/resources/Pasted%20image%2020240122133449.png" /> 地址结构：</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th>标记</th>
<th>组号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>访存过程：</p>
<ol type="1">
<li>根据组号找到对应的组，将对应Cache组中每个行的标记与主存地址的高位标记进行比较，若相等且有效位1，则命中</li>
<li>不命中时，从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲行中，将有效位置1并设置标记，同时将该地址中的内容送CPU。</li>
</ol>
<p><strong>总结</strong><br />
三种映射方式中，直接映射的每个主存块只能映射到Cache中的某一固定行；全相联映射可以映射到所有Cache行；N路组相联映射可以映射到N行。当Cache大小、主存块大小一定时：</p>
<ul>
<li>直接映射的命中率最低，全相联映射的命中率最高</li>
<li>直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长</li>
<li>直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大</li>
</ul>
<h3 id="主存块的替换算法">主存块的替换算法</h3>
<p>直接映射时，主存块对应唯一行，无需考虑替换算法，其他两种情况则需要考虑</p>
<ol type="1">
<li>随机算法：随机地确定替换的Cache块，实现简单，但不符合局部性原理</li>
<li>先进先出算法：选择最早调入的行进行替换，优缺点同上</li>
<li>近期最少使用算法(LRU)：选择近期内长久未访问过的Cache行作为替换的行。对每个Cache行设置一个计数器，用计数值来记录主存块的使用情况，计数值的位数取组大小的对数，规则如下：
<ol type="1">
<li>命中时，所命中的行的计数器清零，比其低的计数器加1,其余不变;</li>
<li>未命中且还有空闲行时，新装入的行的计数器置0,其余全加1</li>
<li>未命中且无空闲行时，计数值为3的行的信息块被淘汰，新装行的块的计数器置0,其余全加1</li>
<li>当集中访问的存储区超过Cache组的大小时，LRU命中率可能变得很低，这种现象称为抖动</li>
</ol></li>
<li>最不经常使用算法：将一段时间内被访问次数最少的存储行换出,每行设置计数器，每访问一次，被访问的行计数器加1，每次替换选择计数最小的一行，类似LRU <img src="/assets/resources/Pasted%20image%2020240122134549.png" /></li>
</ol>
<h3 id="写策略">写策略</h3>
<p>当对Cache中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致，分为：</p>
<ul>
<li>全写法(写直通法、write-through)：当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。实现简单且准确，但效率较低
<ul>
<li>写缓冲：为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲(Write Buffer)，CPU同时写数据到Cache和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，频繁写入可能溢出</li>
</ul></li>
<li>回写法(write-back)：当CPU对Cache写命中时，只把数据写入Cache,而不立即写入主存，只有当此块被换出时才写回主存。增加效率，但有可能有不一致问题
<ul>
<li>每个Cache行设置一个修改位(脏位)。1表示修改过，替换时需要写回主存，为0则相反 <img src="/assets/resources/Pasted%20image%2020240122135305.png" alt="写缓冲示意图" /></li>
</ul></li>
</ul>
<p>不命中时也有两种情况：</p>
<ul>
<li>写分配法(write-allocate)。加载主存中的块到Cache中，然后更新这个Cache块。更符合局部性原理，但可能开销更大，一般和回写法合用</li>
<li>非写分配法(not-write-allocate)只写入主存，不进行调块。一般和全写法合用</li>
</ul>
<div class="note info"><p>现代Cache往往使用指令数据分离的多级Cache<br />
假定设3级Cache,按离CPU的远近可各自命名为L1 Cache&gt; L2 Cache&gt; L3 Cache。 离CPU越远，访问速度越慢，容量越大。<br />
指令Cache与数据Cache分离一般在L1级，此时通常为写分配法与回写法合用。<br />
下图是一个含有两级Cache的系统，L1 Cache对L2 Cache使用全写法，L2 Cache对主存使用回写法，由于L2 Cache的存在,其访问速度大于主存，因此避免了因频繁写时造成的写缓冲饱和溢出。<br />
<img src="/assets/resources/Pasted%20image%2020240122134749.png" /></p>
<p>较大的行可以利用空间局部性增加命中机会，但会放大未命中损失，在项数层面减少命中率</p>
<p>取指令缺失时：</p>
<ol type="1">
<li>程序计数器恢复当前指令的值。</li>
<li>对主存进行读的操作。</li>
<li>将读入的指令写入Cache中，更改有效位和标记位。</li>
<li>重新执行当前指令。</li>
</ol>
</div>
<div class="note warning"><ul>
<li>标记位地址映射时需要加一个有效位，这个数字乘以Cache行数就是地址映射表大小</li>
<li>当CPU访存时，先要到Cache中查看该主存地址是否在Cache中，所以发送的是主存物理地址。只有在虚拟存储器中，CPU发出的才是虚拟地址</li>
<li>Cache行数 = Cache数据区大小/主存块大小</li>
<li>Cache位数 = 数据位 + tag位(根据映射方式决定，数值上等于主存地址位数-组号/行号-块内地址位) + 1(脏位，根据写策略决定) +1(有效位，必然存在)</li>
<li>对空间局部性良好的连续数据和代码，访问Cache时会把之后会使用的数据调入主存，因此，这次调入的n个数据只有第一个是不命中的</li>
<li>n路相联映射就会需要n个标记位数的比较器来并行比较</li>
<li>有安全性要求时，采用全写法</li>
<li>脏位和有效位独立于tag位存在</li>
<li>全相联Cache，按先后顺序从0开始分配Cache行</li>
<li>一次读突发传送总线事务包括一次地址传送和若干次数据传送，地址传送用一个总线周期，如果是低位交叉读数据，就需要一整个存储周期(第一个存储器读数据)+<code>存储体数量*总线时间周期</code>(传输数据)</li>
<li><code>Cache命中时的一条指令执行时间=Cache命中时的CPI * 时钟周期</code></li>
<li>一条指令执行过程中因Cache缺失而导致的平均额外开销=<code>平均访存次数*Cache缺失率*一次读突发传送总线事务时间</code></li>
<li>物理地址可以同时是页号+偏移量，以及Cache中的块号(标记)+行号+块内地址</li>
</ul>
</div>
<h2 id="虚拟存储器">虚拟存储器</h2>
<p>虚拟存储器将主存或辅存的地址空间统一编址，使用虚拟地址时不用关系具体的地址空间和其实现<br />
用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。实际的主存单元地址称为实地址或物理地址<br />
<img src="/assets/resources/Pasted%20image%2020240123125249.png" /> CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，如果在，则需要进行地址映射，否则需要调入，或者进行置换算法<br />
虚拟存储机制采用全相联映射，每个虚页面可以存放到对应主存区域的任何一个空闲页位置，在处理一致性问题时，采用回写法</p>
<p>虚拟存储器分为页式，段式，和段页式</p>
<ol type="1">
<li>页式虚拟存储器，便于利用空间，实现简单，但最后一页会产生碎片</li>
</ol>
<p>以页为基本单位。虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页、页框，虚存的页称为虚页。虚拟地址分为两个字段：虚页号和页内地址。<br />
虚拟地址到物理地址的转换是由页表实现的。页表是一张存放在主存中的虚页号和实页号的对照表，一般驻留内存中<br />
如图，有效位表示是否调入主存中，脏位表示是否修改过，为1时需要把修改写回磁盘；引用位配合置换算法<br />
<img src="/assets/resources/Pasted%20image%2020240123125834.png" /> 页表基址寄存器存放进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项</p>
<ul>
<li>若装入位为1,则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址；</li>
<li>若装入位为0,则说明缺页，需要操作系统进行缺页处理。</li>
</ul>
<p><strong>快表TLB</strong><br />
由高速缓冲器组成，根据局部性原理缓存一些表项。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。 <img src="/assets/resources/Pasted%20image%2020240123130334.png" /> 快表通常采用全相联或组相联方式。每个TLB项由页表表项内容加上一个TLB标记字段组成,TLB标记用来表示该表项取自页表中哪个虚页号对应的页表项<br />
TLB标记的内容在全相联方式下就是该页表项对应的虚页号；组相联方式下则是对应虚页号的高位部分，而虚页号的低位部分用于选择TLB组的组索引<br />
如图，Cache采用二路组相联方式，TLB采用全相联方式，cpu给出虚拟地址后，比较虚页号和TLB标记字段，命中则通过TLB地址转换，否则查询主存页表，并调入或置换TLB。完成地址转换后，Cache根据上节的步骤，根据物理地址找到对应Cache行，将数据取送cpu<br />
<img src="/assets/resources/Pasted%20image%2020240123130559.png" /> 查找时，快表和慢表也可以同步进行<br />
可能的缺失情况：</p>
<ul>
<li>TLB缺失，没有对应页表项</li>
<li>Cache，访问的主存不在Cache</li>
<li>Page缺失，访问的页面不在主存 <img src="/assets/resources/Pasted%20image%2020240123130618.png" /> 第1种组合，此时无须访问主存；第2种和第3种组合都需要访问一次主存;第4种组合需要访问两次主存；第5种组合发生“缺页异常”，需要访问磁盘，并且至少访问两次主存。<br />
Cache缺失处理由硬件完成；缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现；而TLB缺失既可以用硬件又可以用软件来处理</li>
</ul>
<ol start="2" type="1">
<li><p>段式虚拟存储器<br />
段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两部分：段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度<br />
<img src="/assets/resources/Pasted%20image%2020240123145932.png" /> 给出虚拟地址后，根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存，调入时将起始地址和段内地址相加就是实际地址<br />
段式存储器具有逻辑独立性，易于编译、管理、修改，保护，多道程序的共享，但容易产生碎片</p></li>
<li><p>段页式虚拟存储器<br />
把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页.每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍,段的起点必须是某一页的起点<br />
虚地址分为段号、段内页号、页内地址三部分。CPU根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址<br />
可以按段实现共享和保护,但两次查表的开销较大</p></li>
</ol>
<div class="note info"><p><strong>虚拟存储器与Cache</strong></p>
<ol type="1">
<li>相同之处
<ol type="1">
<li>最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度</li>
<li>都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大</li>
<li>都有地址的映射、替换算法、更新策略等问题</li>
<li>依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中</li>
</ol></li>
<li>不同之处
<ol type="1">
<li>Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量</li>
<li>Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明</li>
<li>对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大</li>
<li>CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信</li>
</ol></li>
</ol>
</div>
<div class="note warning"><ul>
<li>虚存需要通过对操作系统实现地址映射，因此对操作系统的设计者即系统程序员是不透明的,只对应用程序员透明</li>
<li>Cache和TLB命中必然page命中，其他情况下则没有制约</li>
<li>缺页是在地址转换时CPU检测到的一种异常，缺页处理完成后回到发生缺页的指令继续执行</li>
<li>Cache由SRAM组成；TLB通常由相联存储器组成，也可由SRAM组成</li>
<li>主存与Cache之间的信息调度功能全部由硬件自动完成</li>
<li>组相联的TLB，需要把虚页号拆分成低位组号与高位标记，分开计算</li>
<li>虚拟地址的后若干位是通用的偏移量，可以根据这部分信息算出Cache组号等信息</li>
</ul>
</div>
<h1 id="指令">指令</h1>
<h2 id="概念-1">概念</h2>
<p>指令(机器指令)是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是指令集体系结构(ISA)中最核心的部分<br />
ISA规定的内容主要包括：指令格式，数据类型及格式，操作数的存放方式，程序可访问的寄存器个数、位数和编号,存储空间的大小和编址方式，寻址方式，指令执行过程的控制方式等。</p>
<h3 id="基本格式">基本格式</h3>
<table>
<thead>
<tr class="header">
<th>操作码字段</th>
<th>地址码字段</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>指令的长度是指一条指令中所包含的二进制代码的位数。指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数,与机器字长没有固定的关系,可分为单子长,半字长等</p>
<ol type="1">
<li>零地址指令
<ol type="1">
<li>不需要操作数</li>
<li>堆栈计算机中，操作数隐式地从栈顶和次栈顶弹出，结果隐式地压入堆栈</li>
</ol></li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="2" type="1">
<li>一地址指令，按地址取操作数，运算结束后放回原处；可隐含约定另一个操作数由ACC (累加器)提供，运算结果也将存放在ACC中</li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th><span class="math inline">\(A_1\)</span></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="3" type="1">
<li>二地址指令，分别给出目的操作数和源操作数的地址,目的操作数的地址保存本次运算结果</li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th><span class="math inline">\(A_1\)</span></th>
<th><span class="math inline">\(A_2\)</span></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="4" type="1">
<li>三地址指令，</li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th><span class="math inline">\(A_1\)</span></th>
<th><span class="math inline">\(A_2\)</span></th>
<th><span class="math inline">\(A_3(结果)\)</span></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="5" type="1">
<li>四地址指令,<span class="math inline">\(A_4\)</span>是下一条将要执行指令的地址</li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th><span class="math inline">\(A_1\)</span></th>
<th><span class="math inline">\(A_2\)</span></th>
<th><span class="math inline">\(A_3(结果)\)</span></th>
<th><span class="math inline">\(A_4(下址)\)</span></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="6" type="1">
<li>定长操作码指令，在指令字的最高位部分分配固定的若干位(定长)表示操作码。一般n位操作码字段的指令系统最大能够表示<span class="math inline">\(2^n\)</span>条指令。</li>
<li>扩展操作码指令<br />
变长操作码：指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上<br />
常见的变长操作码方法是扩展操作码：操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码<br />
注意点：</li>
</ol>
<ul>
<li>短码不能是长码的前缀</li>
<li>操作码不能重复 如图，把<code>1111</code>作为一种前缀表示操作码拓展到下个非1111的四位 <img src="/assets/resources/Pasted%20image%2020240124111231.png" /></li>
</ul>
<h3 id="操作类型">操作类型</h3>
<ul>
<li>数据传送</li>
<li>算术和逻辑运算</li>
<li>移位</li>
<li>转移操作，无条件转移(JMP)、条件转移(BRANCH)、调用(CALL)、返回(RET)、陷阱(TRAP)等，转移操作不返回执行，与调用指令根据返回地址返回主程序不同</li>
<li>I/O操作</li>
</ul>
<div class="note warning"><ul>
<li>PC存放当前欲执行指令的地址，而指令的地址码字段则保存操作数地址</li>
<li>程序控制类指令主要包括无条件转移、有条件转移、子程序调用和返回指令、循环指令等</li>
<li>按字节编址时指令长度应该是8的倍数</li>
<li>运算器的进位等硬件部分与ISA无关</li>
<li>求拓展操作码指令数的最值可以根据地址数由大到小的顺序列方程求解</li>
<li>可能的指令格式:操作码-寻址特征-位移量/操作数</li>
<li>使用扩展操作码时，设地址位数为n,地址指令操作码每减少一个，就可以多构成<span class="math inline">\(2^n\)</span>条一地址指令操作码；一地址指令操作码每减少一个，就可以多构成<span class="math inline">\(2^n\)</span>条零地址指令操作码</li>
</ul>
</div>
<h2 id="指令寻址方式">指令寻址方式</h2>
<p>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法 指令中的地址码字段称为形式地址(A)，结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址(EA)。 <code>(A)</code>表示地址为A的数值</p>
<p>寻址方式可分为：</p>
<ul>
<li>指令寻址
<ul>
<li>顺序寻址，程序计数器加一形成下一条指令地址</li>
<li>跳跃寻址，下条指令地址由本条指令给出计算方式，修改PC值，根据修改后的PC定位指令</li>
</ul></li>
<li>数据寻址 ，用操作数地址通过某些方法得出地址</li>
</ul>
<h3 id="数据寻址的分类">数据寻址的分类</h3>
<p>指令格式：</p>
<table>
<thead>
<tr class="header">
<th>操作码</th>
<th>寻址特征</th>
<th>形式地址A</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol type="1">
<li><p>隐含寻址，在指令中隐含操作数的地址，例如使用累加器作为第二操作数地址<br />
有利于缩短指令字长；但需增加存储操作数或隐含地址的硬件。 <img src="/assets/resources/Pasted%20image%2020240125183517.png" /></p></li>
<li><p>立即数寻址，指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数，采用补码表示<br />
指令在执行阶段不访问主存，指令执行时间最短；但A的位数限制了立即数的范围</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th>立即寻址特征</th>
<th>立即数</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="3" type="1">
<li><p>直接寻址，指令字中的形式地址A是操作数的真实地址EA,即EA = A <img src="/assets/resources/Pasted%20image%2020240125183707.png" /> 指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址，但A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改</p></li>
<li><p>间接寻址，地址字段给出操作数有效地址所在的存储单元的地址，即EA=(A) <img src="/assets/resources/Pasted%20image%2020240125183803.png" /> 图中，主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为0时，表示取得的是操作数的地址<br />
可扩大寻址范围,便于编制程序(用间接寻址可方便地完成子程序返回);但指令在执行阶段要多次访存，相比寄存器间接寻址不常用</p></li>
<li><p>寄存器寻址，指令字中直接给出操作数所在的寄存器编号，即EA = Ri<br />
寄存器少所以指令可以较短，执行速度快，支持向量/矩阵运算；但寄存器个数有限</p></li>
<li><p>寄存器间接寻址，在寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(Ri) <img src="/assets/resources/Pasted%20image%2020240125184233.png" /> 与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存</p></li>
<li><p>相对寻址,PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA =(PC)+A,A是相对于当前PC值的位移量,补码表示 <img src="/assets/resources/Pasted%20image%2020240125184328.png" /> 操作数的地址随PC值的变化而变化,与指令地址之间总是相差一个固定值，因此便于程序浮动,适用于转移指令<br />
例如，对于转移指令JMP A,当CPU从存储器中取出一字节时，会自动执行(PC)+1-&gt;PC。<br />
若转移指令的地址为X,且占2B,在取出该指令后，PC的值会增2,即(PC) = X + 2,这样在执行完该指令后，会自动跳转到X + 2+A的地址继续执行</p></li>
<li><p>基址寻址,CPU中基址寄存器(BR)的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(BR)+A。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器 <img src="/assets/resources/Pasted%20image%2020240125184543.png" /> 基址寄存器内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变(作为基地址),形式地址可变(作为偏移量)。<br />
可扩大寻址范围(基址寄存器的位数大于形式地址A的位数)；用户不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序,但偏移量(形式地址A)的位数较短</p></li>
<li><p>变址寻址，有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，即EA =(IX) + A,其中IX为变址寄存器(专用)，也可用通用寄存器作为变址寄存器<br />
在程序执行过程中，变址寄存器的内容可由用户改变(作为偏移量)，形式地址A不变(作为基地址)。<br />
可扩大寻址范围(寄存器位数大于A位数，足以表示整个存储空间)，适合循环程序<br />
基址寄存器其值不可变，而执行中指令字中的A是可变的；变址寄存器的内容由用户设定，其值在程序执行中可变，而指令字中的A是不可变的<br />
<img src="/assets/resources/Pasted%20image%2020240125184736.png" /></p></li>
<li><p>堆栈寻址 <img src="/assets/resources/Pasted%20image%2020240125184742.png" /> 堆栈区由特定的寄存器——堆栈指针SP管理</p></li>
</ol>
<ul>
<li>寄存器堆栈又称硬堆栈，成本较高</li>
<li>主存划出一定区域作为堆栈是软堆栈</li>
</ul>
<p>使用堆栈的系统，一般指令无操作数，隐含使用堆栈的push,pop作为操作数</p>
<div class="note warning"><ul>
<li>采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间</li>
<li>以低字节为字地址的存放方式即是小端方式</li>
<li>进、出堆栈时对栈顶指针的操作顺序相反，如果进栈是先数据再指针，出栈就是先指针后数据</li>
<li>相对寻址中，由于取出本条指令时，PC会自增到下一条指令，因此偏移量加上下一条指令地址才是有效地址</li>
<li>跳跃寻址可以实现程序的条件或无条件转移</li>
<li>程序计数器(PC)给出下一条指令字的访存地址(指令在内存中的地址)，因此取决于存储器的字数；指令寄存器(IR)用于接收取得的指令，因此取决于指令字长</li>
<li>无符号减法中出现进位/借位表明被减数更大</li>
<li>sizeof (数据类型)，指的是占用的存储单元，也就是编址的单位</li>
<li>内存地址都是无符号数</li>
<li>相对寻址转移指令的转移范围取决于PC与偏移量范围的和(主存地址)，且必须&gt;=0</li>
<li>转移指令计算转移地址，需要对偏移量进行符号拓展,逻辑左移(看指令字长与编址关系)，并与自增后的PC相加得到转移地址，与标志位一起送到多路选择器进行转移的判断</li>
<li>除了用不同操作码，不同地址数的指令也可以把用不到的操作数地址位全部填0表示操作数个数 <img src="/assets/resources/Pasted%20image%2020240128210356.png" /></li>
</ul>
</div>
<h2 id="汇编">汇编</h2>
<p>x86处理器中有8个32位的通用寄存器，汇编指令一般有AT&amp;T与intel格式两类<br />
<img src="/assets/resources/Pasted%20image%2020240128214452.png" /><br />
八个32位通用寄存器EAX(4B)等可拆为AX(2B),AX可拆为AH,AL(1B)用：</p>
<ul>
<li>EAX(AX) 累加寄存器(Accumulator)</li>
<li>EBX(BX) 基地址寄存器 (Base Register)</li>
<li>ECX(CX) 计数寄存器(Count Register)</li>
<li>EDX(DX) 数据寄存器(Data Register)</li>
<li>ESI EDI 变址寄存器(Index Register)</li>
<li>EBP 堆栈基指针(Base Pointer)</li>
<li>ESP 堆栈顶指针(Stack Pointer)</li>
</ul>
<p><strong>常见名词</strong>：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;reg&gt;表示任意寄存器，形如&lt;reg32&gt;表示32位寄存器</span><br><span class="line">&lt;mem&gt;表示内存地址，包括一些简单表达式</span><br><span class="line">&lt;con&gt;表示常识，如&lt;con8&gt;表示8位常数</span><br><span class="line">[n]表示n对应内存地址的数据，其中n可能是寄存器的值,AT&amp;T使用()表示内存地址数据</span><br><span class="line">R[r]表示寄存器r的内容，M[addr]表示主存单元addr的内容</span><br></pre></td></tr></table></figure> x86中的指令机器码长度为1字节，对同一指令的不同用途有多种编码方式</p>
<h3 id="常见指令">常见指令</h3>
<p><strong>mov</strong>:复制数据，但不能用于直接从内存复制到内存 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line">mov &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">mov &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">mov &lt;mem&gt;, &lt;con&gt;</span><br><span class="line">mov &lt;reg&gt;, &lt;con&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">mov eax, ebx</span><br><span class="line">mov byte ptr [var] , 5 </span><br></pre></td></tr></table></figure></p>
<p><strong>lea</strong>:将一个内存地址(而不是其所指的内容)加载到目的寄存器</p>
<p><strong>pop</strong>:将push压入的操作数取出，然后(<strong>这里与push顺序相反</strong>)ESP+4<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push &lt;reg32&gt;</span><br><span class="line">push &lt;mem&gt;</span><br><span class="line">push &lt;con32&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">push [var]</span><br><span class="line">pop [ebx]</span><br></pre></td></tr></table></figure></p>
<p><strong>add/sub</strong>:运算结果均保存到第一个操作数<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add/sub &lt;reg&gt;, &lt;reg&gt; </span><br><span class="line">add/sub &lt;reg&gt;, &lt;mem&gt; </span><br><span class="line">add/sub &lt;mem&gt;, &lt;reg&gt; </span><br><span class="line">add/sub &lt;reg&gt;, &lt;con&gt;</span><br><span class="line">add/sub &lt;mem&gt;&lt; &lt;con&gt; </span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">sub eax, 10</span><br><span class="line">add byte ptr [var], 10    //10与var值指示的内存地址的一字节值相加，并将结果保存在var值指示的内存地址的字节中</span><br></pre></td></tr></table></figure></p>
<p><strong>inc/dec</strong>:自增/自减 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inc/dec &lt;reg&gt;</span><br><span class="line">inc/dec &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">dec eax</span><br><span class="line">inc dword ptr [var] //dword表示四字节的值</span><br></pre></td></tr></table></figure></p>
<p><strong>imul</strong>:带符号整数乘法,<strong>第一个操作数必须是寄存器</strong>,三操作数版本将后两者的乘积存入第一个操作数,可能溢出，溢出时OF置1<br />
<strong>idiv</strong>:有符号整数除法指令，唯一的操作数是除数，被除数则为edx:eax中的内容(共64位)，操作结果的商送到eax,余数则送到edx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">imul &lt;reg32&gt;, &lt;reg32&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;mem&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;reg32&gt;, &lt;con&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;mem&gt;, &lt;con&gt;</span><br><span class="line"></span><br><span class="line">idiv &lt;reg32&gt;</span><br><span class="line">idiv &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">imul eax, [var]</span><br><span class="line">imul esi, edi, 25</span><br><span class="line"></span><br><span class="line">idiv ebx</span><br><span class="line">idiv dword ptr [var]</span><br></pre></td></tr></table></figure>
<p><strong>and/or/xor</strong>:逻辑与，或，异或,用法一样，结果放到第一个操作数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and &lt;reg&gt;, &lt;reg&gt; </span><br><span class="line">and &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">and &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;, &lt;con&gt;</span><br><span class="line">and &lt;mem&gt;, &lt;con&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">and eax, 00H</span><br></pre></td></tr></table></figure></p>
<p><strong>not</strong>,对所有位取非;<strong>neg</strong>对值取负数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">not/neg &lt;reg&gt;/&lt;mem&gt;</span><br><span class="line">eg.</span><br><span class="line">not byte ptr [var]</span><br><span class="line">neg eax</span><br></pre></td></tr></table></figure></p>
<p><strong>shl/shr</strong>:逻辑移位，移动第一个操作数的位数是第二操作数的值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shl &lt;reg&gt;, &lt;con8&gt; / shr &lt;reg&gt;, &lt;con8&gt;</span><br><span class="line">shl &lt;mem&gt;, &lt;con8&gt; / shr &lt;mem&gt;, &lt;con8&gt;</span><br><span class="line">shl &lt;reg&gt;, &lt;cl&gt; / shr &lt;reg&gt;, &lt;cl&gt;</span><br><span class="line">shl &lt;mem&gt;, &lt;cl&gt; / shr &lt;mem&gt;, &lt;cl&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">shl eax, 1</span><br><span class="line">shr ebx, cl</span><br></pre></td></tr></table></figure></p>
<h3 id="控制指令">控制指令</h3>
<p><strong>jmp</strong>:跳转到label指示的地址的指令执行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp &lt;label&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>jcondition</strong>:根据cpu状态字条件转移 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">je &lt;label&gt; (jump when equal)</span><br><span class="line">jne &lt;label&gt; (jump when not equal)</span><br><span class="line">jz &lt;label&gt; (jump when last result was zero)</span><br><span class="line">jg &lt;label&gt; (jump when greater than)</span><br><span class="line">jge &lt;label&gt; (jump when greater than or equal to)</span><br><span class="line">j1 &lt;label&gt; (jump when less than)</span><br><span class="line">jle &lt;label&gt; (jump when less than or equal to)</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">cmp eax, ebx</span><br><span class="line">jle done  //eax&lt;=ebx时跳转到done</span><br></pre></td></tr></table></figure></p>
<p><strong>cmp/test</strong>:根据运算结果设置cpu状态字，其中cmp相当于不保存结果的sub,test对操作数进行逐位与运算<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp &lt;reg&gt;, &lt;reg&gt; </span><br><span class="line">cmp &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">cmp &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">cmp &lt;reg&gt;, &lt;con&gt; </span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">jz eax, eax #测试eax是否是0</span><br><span class="line">jz xxxx  #为零则置标志ZF为1,转跳到xxxx处执行</span><br></pre></td></tr></table></figure></p>
<h4 id="过程调用">过程调用</h4>
<p><strong>call/ret</strong>:call将当前指令地址入栈，随后无条件转移到label(保存调用之前的地址),ret用于返回到之前保存的指令地址(通过出栈原先指令的地址并无条件转移并执行) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call &lt;label&gt;</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p>
<p>过程P调用过程Q的执行步骤：</p>
<ol type="1">
<li>P将入口参数(实参)放到Q能访问到的地方。</li>
<li>P将返回地址存到特定的地方，然后将控制转移到Q。(<code>call</code>指令)</li>
<li>Q保存P的现场(通用寄存器的内容)，并为自己的非静态局部变量分配空间。</li>
<li>执行过程Q。</li>
<li>Q恢复P的现场，将返回结果放到P能访问到的地方，并释放局部变量所占空间。</li>
<li>Q取出返回地址，将控制转移到P。(<code>ret</code>)</li>
</ol>
<p>调用者和被调用者需共享(用户可见的)寄存器，规定：</p>
<ul>
<li>寄存器EAX、ECX和EDX是调用者保存寄存器，当P调用Q时，若Q需用到这些寄存器，则由P将这些寄存席的内容保存到栈中，并在返回后由P恢复它们的值</li>
<li>寄存器EBX、ESI和EDI是被调用者保存寄存器，当P调用Q时，Q必须先将这些寄存器的内容保存在栈中才能使用它们，并在返回P之前先恢复它们的值</li>
</ul>
<p>每个过程都有自己的栈区，称为栈帧，一个栈由若干栈帧组成,寄存器EBP指示栈帧的起始位置，寄存器ESP指示栈顶，栈从高地址向低地址增长,出入栈只更改ESP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leave指令功能相当于以下两条指令的功能：</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>
<h3 id="选择指令">选择指令</h3>
<p><strong>if-else</strong>: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(test expr) # test_expr是一个整数表达式，它的取值为0 (假)，或为非0 (真)</span><br><span class="line">then_statement</span><br><span class="line">else</span><br><span class="line">else_statement</span><br><span class="line"></span><br><span class="line">即过程：</span><br><span class="line">t=test expr;</span><br><span class="line">if (!t)</span><br><span class="line">    goto false;</span><br><span class="line">then_statement</span><br><span class="line">goto done;</span><br><span class="line">false:</span><br><span class="line">else_statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></p>
<h3 id="循环指令">循环指令</h3>
<p><strong>do-while</strong>和<strong>while</strong>: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">    body_statement</span><br><span class="line">    while(test_expr);</span><br><span class="line"></span><br><span class="line">while (test_expr) </span><br><span class="line">    body_statement</span><br><span class="line">#while与do-while的不同:第一次执行body_statement之前，就会测test_expr的值，循环有可能中止</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">do-while的过程:</span><br><span class="line">loop:</span><br><span class="line">body_statement</span><br><span class="line">t=test_expr;</span><br><span class="line">if (t)</span><br><span class="line">    goto loop;</span><br><span class="line"></span><br><span class="line">while的过程:</span><br><span class="line">t=test_expr;</span><br><span class="line">if (!t)</span><br><span class="line">    goto done;</span><br><span class="line">loop:</span><br><span class="line">body_statement</span><br><span class="line">t=test_expr;</span><br><span class="line">if(t)</span><br><span class="line">    goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></p>
<p><strong>for</strong>: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(init expr; test expr; update expr)</span><br><span class="line">    body statement</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">init expr;</span><br><span class="line">t=test_expr;</span><br><span class="line">if(!t)</span><br><span class="line">    goto done;</span><br><span class="line">loop:</span><br><span class="line">body_s tatement</span><br><span class="line">update expr;</span><br><span class="line">t=test_expr;</span><br><span class="line">if(t)</span><br><span class="line">    goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></p>
<h2 id="指令系统">指令系统</h2>
<ul>
<li>复杂指令系统计算机(CISC)，典型如x86架构
<ul>
<li>数量一般200以上</li>
<li>长度不定，格式，寻址方式较多</li>
<li>访存的指令不受限制</li>
<li>指令使用频度差别大，执行时间差别大，显示出二八定律，但也可以实现指令流水线</li>
<li>控制器大多用微程序控制</li>
<li>难以优化编译</li>
</ul></li>
<li>精简指令系统计机(RISC),典型的有ARM、MIPS架构的计算机
<ul>
<li>指令较简单，复杂功能需要组合，一般少于100</li>
<li>长度固定，格式更少</li>
<li>只有Load/Store指令可以访存，其他指令用寄存器进行</li>
<li>cpu的通用寄存器更多</li>
<li>必须实现指令流水线，指令时间较短</li>
<li>硬布线控制为主，少见微程序</li>
<li>重视编译优化</li>
</ul></li>
</ul>
<p>RISC的优点：</p>
<ul>
<li>更能充分利用VLSI芯片的面积，硬布线逻辑比微程序控制器占地更小</li>
<li>提高运算速度，(指令长度一致、按边界对齐存放、仅Load/Store指令访存便于形成流水线)</li>
<li>便于设计，成本低且可靠</li>
<li>利于编译程序代码优化</li>
</ul>
<h1 id="cpu">cpu</h1>
<h2 id="基本功能结构">基本功能结构</h2>
<p>中央处理器(CPU)由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令；运算器的功能是对数据进行加工。基本功能有：</p>
<ul>
<li>指令控制，即程序的顺序控制</li>
<li>操作控制，控制各个部件按指令的要求动作</li>
<li>时间控制(提供按时间顺序的控制信号)</li>
<li>数据加工，算术与逻辑运算</li>
<li>中断处理</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240128220028.png" /></p>
<h3 id="运算器">运算器</h3>
<ul>
<li>算术逻辑单元</li>
<li>暂存寄存器，寄存主存读来的数据(对应用程序员透明)</li>
<li>累加寄存器ACC，通用寄存器，可作为加法的输入，可暂存ALU运算信息</li>
<li>通用寄存器组，AX,BX,CX,DX,SP等，存放数据，其中SP是堆栈指针，指示栈顶地址</li>
<li>程序状态字寄存器PSW，存放溢出标志OF,符号SF,零ZF,进位CF</li>
<li>移位器，进行移位运算</li>
<li>计数器CT，控制乘除的操作步数</li>
</ul>
<h3 id="控制器">控制器</h3>
<p>指挥全机协调工作，基本功能是执行指令,指令的执行是由控制器发出的一组微操作实现的，分为硬布线与微程序控制器</p>
<ul>
<li>程序计数器PC，指出欲执行指令在主存的存放地址，可以自增</li>
<li>指令寄存器IR，保存当前正在执行的指令</li>
<li>指令译码器，对操作码字段译码</li>
<li>存储器地址寄存器MAR</li>
<li>存储器数据寄存器MDR</li>
<li>时序系统，产生时序信号，用统一时钟分频得到</li>
<li>微操作信号发生器，根据IR内容，PSW内容与时序信号，产生各种控制信号</li>
</ul>
<p>通用寄存器组、程序状态字寄存器，程序计数器对用户可见，且可编程<br />
存储器地址寄存器、存储器数据寄存器、指令寄存器对用户透明，不可对其编程</p>
<div class="note warning"><ul>
<li>CPU的位数n与数据总线线数相等</li>
<li>PC的值可以在cpu执行指令过程的取指周期修改</li>
<li>转移指令需要判断转移是否成功，不成功的话下一条指令依旧是自增地址</li>
<li>程序计数器存放指令地址，需要和存储器地址位数一致</li>
<li>指令寄存器可以被用户编程，不能由通用寄存器代替</li>
<li>间址周期结束时，CPU内寄存器MDR中的内容为操作数地址</li>
</ul>
</div>
<h2 id="指令执行过程">指令执行过程</h2>
<p>CPU从主存中取出并执行一条指令的时间称为指令周期，常用若干机器周期(cpu周期)来表示，一个机器周期又包含若干时钟周期<br />
每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等<br />
如果使用中断机制，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，又称中断周期<br />
<img src="/assets/resources/Pasted%20image%2020240130232317.png" /> 带有间址周期、中断周期的指令周期：</p>
<table>
<thead>
<tr class="header">
<th>取指周期</th>
<th>间址周期</th>
<th>执行周期</th>
<th>中断周期</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>其中，取指周期访存取指令，间址周期取有效地址，执行周期取操作数，中断周期保存程序断点<br />
为了区别不同的工作周期，在CPU内设置4个标志触发器FE、IND、EX和INT,它们分别对应取指、间址、执行和中断周期，并以“1”状态表示有效<br />
<em>中断周期中的进栈操作是将SP减1(堆栈都是向低地址增加)</em></p>
<p><strong>数据流</strong><br />
数据流是根据指令要求依次访问的数据序列。</p>
<ol type="1">
<li><p>取指周期 <img src="/assets/resources/Pasted%20image%2020240130232819.png" /></p></li>
<li><p>间址周期 例如一次间址中，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。<br />
间址周期的数据流向如下:</p>
<ol type="1">
<li>Ad(IR)(或MDR)①MAR②地址总线③主存。</li>
<li>CU发出读命令④控制总线⑤主存。</li>
<li>主存⑥数据总线⑦MDR (存放有效地址)。<br />
其中 ,Ad(IR)表示取出IR中存放的指令字的地址字段。<br />
<img src="/assets/resources/Pasted%20image%2020240130233021.png" /></li>
</ol></li>
<li><p>执行周期 取操作数，并根据IR中的指令字的操作码通过ALU操作产生执行结果</p></li>
<li><p>中断周期<br />
处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据<br />
断点 <img src="/assets/resources/Pasted%20image%2020240130233135.png" /></p></li>
</ol>
<p>指令执行方案：</p>
<ul>
<li>单指令周期。所有指令都选用相同的执行时间来完成，串行完成，每条花费一个时钟周期，因此时钟周期取决于时间最长的指令</li>
<li>多指令周期。不同类型的指令选用不同的执行步骤，称为多指令周期方案，串行执行，但可以用不同时钟周期来完成不同指令</li>
<li>流水线方案。指令可以并行执行，尽可能让每个时钟脉冲周期内完成一条指令的执行过程，让多条指令同时运行，但各自处在不同的执行步骤中</li>
</ul>
<div class="note warning"><ul>
<li>转移指令的原理是更改PC，因此指令地址总是PC的值</li>
<li>机器周期通常由存取周期(相对最长)确定</li>
<li>取指周期和操作只和指令字长(与存储字长的大小关系)有关</li>
<li>冯•诺依曼计算机根据指令周期的不同阶段来区分从存储器取出的是指令还是数据</li>
</ul>
</div>
<h2 id="数据通路">数据通路</h2>
<p>数据在功能部件之间传送的路径称为数据通路，包括数据通路上流经的部件<br />
<strong>基本结构</strong>：</p>
<ul>
<li>CPU内部单总线方式。将所有寄存器的输入端和输出端都连接到一条公共通路上，存在冲突问题，性能差</li>
<li>CPU内部多总线方式。将所有寄存器的输入端和输出端都连接到多条公共通路上</li>
<li>专用数据通路方式。根据指令执行过程中的数据和地址的流动方向安排连接线路，硬件多但效率高 <img src="/assets/resources/Pasted%20image%2020240131152608.png" /> 图中，字母加“in”表示该部件的允许输入控制信号;字母加“out”表示该部件的允许输出控制信号。<br />
内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存和各类I/O接口间互相连接的总线。</li>
</ul>
<p><strong>组成</strong>：</p>
<ol type="1">
<li>组合逻辑元件(操作元件)，任何时刻产生的输出仅取决于当前的输入。组合电路不含存储信号的记忆单元，也不受时钟信号的控制，输出与输入之间无反馈通路，信号是单向传输的,包括：
<ol type="1">
<li>加法器</li>
<li>ALU</li>
<li>译码器(操作码或地址码译码,n位输入转化成 <span class="math inline">\(2^n\)</span> 个输出)</li>
<li>多路选择器(控制信号<code>Select</code>来确定选择哪个输入被输出)</li>
<li>三态门(控制信号<code>EN</code>决定信号线的通断)</li>
</ol></li>
<li>时序逻辑元件(状态元件)：任何时刻的输出不仅与该时刻的输入有关，还与该时刻以前的输入有关，包含存储信号的记忆单元，在时钟节拍下工作。包括：
<ol type="1">
<li>通用寄存器组</li>
<li>PC</li>
<li>状态/移位/暂存/锁存寄存器</li>
</ol></li>
</ol>
<p><strong>过程</strong>：</p>
<ol type="1">
<li><p>寄存器之间的数据传送(在寄存器和总线之间有两个控制信号：Rin和Rout,in信号使总线向寄存器R输入数据，out信号让寄存器输出数据给总线)<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(PC) -&gt; MAR   //PCout 和 MARin 有效,PC内容-&gt;MAR</span><br></pre></td></tr></table></figure></p></li>
<li><p>主存与cpu的数据传送<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取指阶段：</span><br><span class="line">(PC) -&gt; MAR  //PCout 和 MARin 有效,PC 内容-&gt;MAR</span><br><span class="line">1 -&gt; R   //CU发读命令</span><br><span class="line">MEM(MAR) -&gt; MDR  (PC)+1-&gt;PC   //MDRin有效</span><br><span class="line">(MDR) -&gt; IR      //MDRout和IRin有效,现行指令-&gt;IR</span><br><span class="line"></span><br><span class="line">将数据写入主存:</span><br><span class="line">(R1) -&gt; MDR      //R1out 和 MDRin 有效</span><br><span class="line">(R2) -&gt; MAR        //R2out 和 MARin 有效</span><br><span class="line">MDR -&gt; MEM(MAR)   //MDRout有效，CU发出写命令</span><br></pre></td></tr></table></figure></p></li>
<li><p>算术或逻辑运算,alu没有存储功能，相加的两个数必须在ALU的两个输入端同时有效，所以需要暂存区Y<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(MDR) -&gt; MAR  //MDRout和MARin有效，操作数有效地址→MAR</span><br><span class="line">1 -&gt; R        //CU发读命令</span><br><span class="line">MEM(MAR) -&gt; MDR     //操作数从存储器→MDR</span><br><span class="line">(MDR) -&gt; Y      //MDRout和Yin有效，操作数→Y</span><br><span class="line">(ACC) + (Y) -&gt; Z    //ACCout和ALUin有效，CU向ALU发加命令，结果-&gt;Z</span><br><span class="line">(Z) -&gt; ACC      //Zout和ACCin有效，结果→ACC</span><br></pre></td></tr></table></figure></p></li>
</ol>
<div class="note warning"><ul>
<li>单总线数据通路将所有寄存器的输入输出端都连接在一条公共通路上，一个时钟内只允许一次操作,无法用于单周期处理器</li>
<li>内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存和各类I/O接口间互相连接的总线</li>
<li>一个时钟周期内控制信号并不会变化</li>
<li>数据通路包括ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑</li>
<li>ALU内部没有寄存器，需要计算时一般一个暂存器输入加上总线直接输入，并用一个控制信号来表示运算类型(Add,Sub等)</li>
<li>信号SRout所控制的部件是一个三态门，用于控制移位器与总线之间数据通路的连接与断开</li>
<li>总线可以通过一个二路选择器连接ALU的输入端，一个用来PC自增，一个用来输入ALU</li>
</ul>
</div>
<h2 id="控制器-1">控制器</h2>
<p><strong>主要连接关系</strong>：</p>
<ol type="1">
<li>运算器部件通过数据总线与内存储器，IO设备传送数据</li>
<li>IO设备通过接口电路与总线相连</li>
<li>存储器，IO设备与地址，控制，数据总线连接</li>
<li>控制器从数据线接受指令，从运算器接受指令转移地址，送地址到地址总线，并产生控制信号</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240201115435.png" /> 控制器的主要功能：</p>
<ol type="1">
<li>从主存取指令，并指出下一个指令的地址</li>
<li>对指令译码，产生控制信号</li>
<li>指挥主存，CPU，IO设备的数据流动方向</li>
</ol>
<p>根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器,两者的PC和IR相同</p>
<h3 id="硬布线控制器">硬布线控制器</h3>
<p><img src="/assets/resources/Pasted%20image%2020240201153814.png" /> CU的输入信号来源:</p>
<ol type="1">
<li>指令译码器译码产生的指令信息</li>
<li>时序系统产生的机器周期信号和节拍信号</li>
<li>来自执行单元的反馈信息,即标志。</li>
<li>系统总线(控制总线)的控制信号</li>
</ol>
<p>CU的输入来自操作码译码电路ID、节拍发生器及状态标志，其输出到CPU内部或外部控制总线上</p>
<p><strong>时序系统</strong>：</p>
<ol type="1">
<li>时钟周期，时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。</li>
<li>机器周期。机器周期可视为所有指令执行过程中的一个基准时间。通常以存取周期作为基准时间(从存储器读一个指令字)在一个机器周期里可完成若干微操作</li>
<li>指令周期</li>
<li>微操作命令分析，需要发出各种操作命令(控制信号)序列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取指周期：</span><br><span class="line">(PC) -&gt; MAR 现行指令地址-&gt;MAR</span><br><span class="line">1-&gt; R 命令存储器读</span><br><span class="line">M (MAR) -&gt; MDR 现行指令从存储器中读至MDR</span><br><span class="line">(MDR) -&gt;IR 现行指令-&gt;IR</span><br><span class="line">OP (IR) -&gt; CU 指令的操作码-&gt;CU译码</span><br><span class="line">(PC) + 1 -&gt; PC 形成下一条指令的地址</span><br><span class="line"></span><br><span class="line">间址周期:</span><br><span class="line">Ad(IR) -&gt;MAR 将指令字中的地址码(形式地址)-&gt;MAR</span><br><span class="line">1-&gt;R 命令存储器读</span><br><span class="line">M (MAR) -&gt; MDR 将有效地址从存储器读至MDR</span><br><span class="line"></span><br><span class="line">执行周期视指令而定</span><br><span class="line"></span><br><span class="line">如加法：</span><br><span class="line">Ad (IR)-&gt;MAR, 1-&gt;R</span><br><span class="line">M(MAR) -&gt; MDR</span><br><span class="line">(ACC) + (MDR)-&gt;ACC</span><br><span class="line"></span><br><span class="line">存数:</span><br><span class="line">Ad (IR)-&gt;MAR, 1-&gt;W</span><br><span class="line">(ACC) -&gt; MDR</span><br><span class="line">(MDR)-&gt;M(MAR)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>控制方式</strong>：</p>
<ul>
<li>同步控制，系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号,一般最长的操作序列为标准，使用相同的节拍为机器周期，电路简单但低效</li>
<li>异步控制，不存在基准时标信号，部件间用应答方式联络，速度快但电路复杂</li>
<li>联合控制，不同的指令大部分同步控制，少部分异步控制</li>
</ul>
<div class="note "><p><strong>设计步骤</strong>：</p>
<ol type="1">
<li>列出操作时间表，包括各个机器周期、节拍下的每条指令完成的微操作控制信号</li>
<li>微操作信号综合，根据时间表写出各个操作控制信号的逻辑表达式，如<code>微操作控制信号=机器周期^节拍^脉冲^操作码人机器状态条件</code></li>
<li>画出微操作命令的逻辑图,并用逻辑门电路实现。</li>
</ol>
<p>表中FE、IND和EX为CPU工作周期标志，T0〜T2为节拍，I为间址标志,指令若有表中所列出的微操作命令，其对应的单元格内为1<br />
取指周期的T2时刻,若测得I=1,则IND触发器置“1”，标志进入间址周期；若I= 0,则EX触发器置“1”,标志进入执行周期。同理，在间址周期的T2时刻，若测得IND = 0(表示一次间接寻址),则EX触发器置“1”，进入执行周期；若测得IND=1 (表示多次间接寻址)，则继续间接寻址。在执行周期的T2时刻，CPU要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则INT触发器置“1”，标志进入中断周期。<br />
<img src="/assets/resources/Pasted%20image%2020240201155051.png" /></p>
</div>
<h3 id="微程序控制器">微程序控制器</h3>
<p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，每条机器指令转化成为一段微程序并存入一个专门的存储器(控制存储器)中，微操作控制信号由微指令产生。</p>
<div class="note info"><p><strong>一些名词</strong></p>
<p>一条机器指令可以分解成一个<strong>微操作</strong>序列，<strong>微操作</strong>是原子化不可分的操作，微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为<strong>微命令</strong>，是构成控制序列的最小单位<br />
微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。<br />
可以同时产生的微命令是<strong>相容</strong>的，否则是<strong>互斥</strong>的，这是相互之间的关系，一个微命令可以和一些相容，一些互斥</p>
<p><strong>微指令</strong>是若干微命令的集合。存放微指令的控制存储器的单元地址称为<strong>微地址</strong>。执行一条微指令的时间称为<strong>微周期</strong>，一般是一个时钟周期<br />
微指令的构成：</p>
<ul>
<li>操作控制字段，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。</li>
<li>顺序控制字段，又称微地址码字段，用于控制产生下一条要执行的微指令地址。</li>
</ul>
<p><strong>主存储器</strong>用于存放程序和数据，在CPU外部，用RAM实现;<strong>控制存储器</strong>(CM)用于存放微程序，在CPU内部，用ROM实现。</p>
<p><strong>程序</strong>是指令的有序集合，用于完成特定的功能；<strong>微程序</strong>是微指令的有序集合，一条指令的功能由一段微程序来实现。<br />
微程序由微指令组成，用于描述机器指令，实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，对程序员透明。程序最终由机器指令组成</p>
<p>与MAR和IR对标的是<strong>微地址寄存器</strong>CMAR(存放控制存储器的读/写微指令的地址)与<strong>微指令寄存器</strong>CMDR/μIR(存放控制存储器读出的微指令)</p>
</div>
<p><img src="/assets/resources/Pasted%20image%2020240202151001.png" /></p>
<p><strong>基本组成</strong></p>
<ol type="1">
<li>控制存储器CM，存放微程序，用ROM构成</li>
<li>微指令寄存器，存放CM取出的微指令，位数等于微指令字长</li>
<li>微地址形成部件，形成微地址，保证其连续进行</li>
<li>微地址寄存器，接受地址形成部件送来的微地址</li>
</ol>
<p><strong>工作过程</strong></p>
<ol type="1">
<li>执行取微指令操作，将机器启动时，取指微程序入口地址(一般是CM的0号单元)送入CMAR，从CM读出微指令送入CMDR，取指微程序执行过程中，主存取出的机器指令会被存入IR</li>
<li>机器指令操作码通过微地址形成部件产生该指令对应的微程序入口地址，送入CMAR</li>
<li>CM逐条取出微指令执行</li>
<li>执行完一个微程序后，回到1.继续循环</li>
</ol>
<p>通常，一条机器指令对应一个微程序，取指令的微命令会被统一编成微程序，用于从主存取出指令送入IR，间址和中断周期也可以编成公共微程序，这三者和机器指令数的和就是总微程序数</p>
<p><strong>微指令的编码(控制)方式</strong><br />
指如何对微指令的控制字段进行编码，以形成控制信号</p>
<ol type="1">
<li><p>直接编码(控制)，微指令的微命令字段中每位都代表一个微命令，约定某位置0表示哪个微命令 <img src="/assets/resources/Pasted%20image%2020240202151110.png" /></p></li>
<li><p>字段直接编码，将微指令的微命令字段分成若干小字段，每个字段独立编码，每种编码代表一个微命令，且各字段编码含义单独定义,与其他字段无关</p>
<ol type="1">
<li>互斥性微命令分在同一段内，相容性微命令分在不同段内。</li>
<li>每段信息位较少</li>
<li>每段留出一个状态，表示字段是否不操作 <img src="/assets/resources/Pasted%20image%2020240202151345.png" /></li>
</ol></li>
<li><p>字段间接编码(隐式编码)，一个字段的某些微命令需由另一个字段中的某些微命令来解释,缩短微指令字长，但削弱了微指令的并行控制能力,一般用于辅助</p></li>
</ol>
<p><strong>微指令的地址形成方式</strong><br />
通电时第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向CMAR输入微指令的地址，这个地址即为取指周期微程序的入口地址。</p>
<ol type="1">
<li>基本类型
<ol type="1">
<li>断定方式，直接由微指令的下地址字段指出，微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址</li>
<li>根据机器指令的操作码形成。机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成</li>
</ol></li>
<li>其他方式
<ol type="1">
<li>增量计数器法，类似PC的自增1，适用于指令地址连续情况</li>
<li>根据各种标志决定</li>
<li>测试网络形成</li>
<li>硬件直接产生</li>
</ol></li>
</ol>
<p><strong>微指令格式</strong></p>
<ol type="1">
<li>水平型，指令字中的一位对应一个控制信号，有输出为1，否则为0。微程序短，指令执行时间短，可以并行操作；但指令长，编写困难</li>
<li>垂直型,设置操作码字段，由其规定指令功能，每个指令定义一种操作。指令较短，编写简单；但效率低，执行时间长，微程序长</li>
<li>在垂直型的基础上增加一些不太复杂的并行操作</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240202153841.png" /> <img src="/assets/resources/Pasted%20image%2020240202153846.png" /> <strong>控制单元的设计步骤</strong></p>
<ol type="1">
<li>写出对应机器指令的微操作命令及节拍安排,例如取指时和硬布线不同的是T2节拍将IR的OP送往微地址形成部件，硬布线则送往指令译码器；且多一条将下一条微指令地址送到CMAR的操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取指操作</span><br><span class="line">(PC)-&gt;MAR, 1-*R</span><br><span class="line">Ad (CMDR) -&gt;CMAR  //将微指令下地址字段送至CMAR</span><br><span class="line">M(MAR)-&gt;MDR, (PC) + 1-&gt;PC</span><br><span class="line">Ad (CMDR)-*&gt;CMAR</span><br><span class="line">(MDR)-&gt;IR</span><br><span class="line">OP (IR)-&gt;微地址形成部件-&gt;CMAR</span><br></pre></td></tr></table></figure></li>
<li>确定微指令格式</li>
<li>编写微指令码点</li>
</ol>
<div class="note info"><p>在一台微程序控制的计算机中，假如能根据用户的要求改变微程序,则这台机器就具有<strong>动态微程序设计</strong>功能,需要可写控制寄存器的支持例如EPROM<br />
在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制<br />
若硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的,这个第二级控制存储器就称为<strong>毫微存储器</strong>，直接控制硬件的是<strong>毫微微指令</strong></p>
</div>
<h3 id="总结">总结</h3>
<ul>
<li>硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快；缺点是由于控制逻辑用电路实现，难以额外修改</li>
<li>微程序控制器的优点是更规整灵活；缺点是采用存储程序，取指访存较为影响速度</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240202150944.png" /></p>
<div class="note warning"><ul>
<li>控制存储器中存放微指令</li>
<li>通常控制存储器采用ROM组成</li>
<li>指令周期是从一条指令启动到下一条指令启动的间隔时间，而CPU周期是机器周期，是指令执行中每步操作所需的时间</li>
<li>状态条件寄存器属于运算器</li>
<li>主存可以用RAM和ROM实现</li>
<li>微指令寄存器对汇编程序员是透明的</li>
<li>pc自增和取指，存IR和取IR操作码给Id可以放在同一个节拍(硬布线中)</li>
</ul>
</div>
<h2 id="异常和中断机制">异常和中断机制</h2>
<p>CPU内部产生的意外事件被称为异常，也称内中断，CPU外部的设备向CPU发出的中断请求被称为中断或者外中断</p>
<ul>
<li>异常是CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件；</li>
<li>中断是由外部设备触发的、与当前正在执行的指令无关的异步事件。</li>
</ul>
<p>一般来说，cpu检测到异常和中断时，打断当前程序，保护现场，然后处理异常，如果能处理完成，则回到程序的当前指令或下一条指令(可能刚执行完一个指令就触发异常)，否则终止程序</p>
<p><strong>异常与中断的分类</strong>：</p>
<ul>
<li>异常(按软硬件)
<ul>
<li>硬故障中断，硬连线异常引起</li>
<li>程序性异常(软件中断),cpu内部执行指令引起的错误，如除0，溢出等</li>
</ul></li>
<li>异常(按产生原因)
<ul>
<li>故障，引起故障的指令启动后、执行结束前被检测到的异常事件，如缺页，除0等，前者可以回到断点继续执行，后者必须终止程序。软件中断</li>
<li>自陷Trap，执行这种指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令(如果是转移自陷指令则返回转移地址)执行。软件中断</li>
<li>终止，执行指令时出现无法继续执行的硬件问题，只能中断来重启系统。硬件中断</li>
</ul></li>
<li>中断，外部I/O设备通过特定的中断请求信号线向CPU提出中断请求，CPU每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期
<ul>
<li>可屏蔽中断，通过可屏蔽中断请求线INTR向CPU发出的中断请求，可以选择屏蔽</li>
<li>不可屏蔽中断，通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，需要cpu立即处理</li>
</ul></li>
</ul>
<p><strong>中断响应</strong>：</p>
<ol type="1">
<li>关中断，通常通过设置"中断允许"(IF)触发器来实现，置0不响应中断</li>
<li>保存断点，将程序断点(返回地址)与状态字寄存器送入栈或寄存器中，一般是栈，便于嵌套处理</li>
<li>识别中断，转到相应处理程序
<ol type="1">
<li>软件识别，CPU设置一个异常状态寄存器，用于记录异常原因，操作系统按优先级顺序查询该寄存器，检测类型，先查到的先处理，转到内核对应处理程序，多用于异常</li>
<li>硬件识别(向量中断)，异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。在中断向量表中，中断类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序<br />
中断响应过程是原子化的，响应过程结束后，CPU就从PC中取出中断服务程序的第一条指令开始执行，直至中断返回，处理过程由软硬件协同实现</li>
</ol></li>
</ol>
<div class="note warning"><ul>
<li>CPU所执行指令的地址序列称为CPU的控制流。在程序正常执行时，通过顺序执行指令或转移指令得到的控制流称为正常控制流。在正常执行过程中，因遇到异常或中断事件而引起用户程序的正常执行被打断所形成的意外控制流，称为异常控制流</li>
<li>部分异常/中断的处理是硬件进行</li>
<li>外部中断请求信号的检测总是在一条指令执行完之后，取下一条指令之前,内部中断则在指令执行过程中出现</li>
<li>典型的外中断(外是相当于cpu和内存):定时器到达，网络数据包到达，IO相关，用户输入信号(如ctrl-c)，硬件相关</li>
<li>典型的内中断/异常:地址非法/越界，浮点数上溢(下溢就是0)，缺页，计算溢出，除0，用户程序执行特权指令，存取访问错误，切换到内核态，时间片到期</li>
</ul>
</div>
<h2 id="指令流水线">指令流水线</h2>
<p>指令流水线技术用于提高处理机并行性：</p>
<ul>
<li>时间上并行，将任务分解为不同子阶段，每个阶段在不同功能部件上并行执行，称为流水线技术</li>
<li>空间上并行，一个处理机内设置多个执行相同功能的部件，并行工作，称为超标量处理机</li>
</ul>
<p><strong>对应指令执行过程的分解</strong>：</p>
<ul>
<li>取指，从指令寄存器或者Cache取指令</li>
<li>译码/读寄存器：控制器对指令译码，从寄存器取操作数</li>
<li>执行/计算地址：执行运算操作或计算地址</li>
<li>访存：读写主存</li>
<li>写回：指令执行结果写回寄存器堆</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240203173011.png" /> 如图，第k+1条指令的取指提前到k条指令的译码，从而前者的译码与后者的执行阶段可以并行<br />
理想情况下每个指令用一个时钟周期完成，实际的流水线设计中，以最复杂操作的阶段数量与时间为准，也就是最长阶段的用时<code>*</code>阶段数量，这样流水线执行单条指令的耗时大于等于单周期处理机，但总时间大大减少</p>
<p>对指令集的要求：</p>
<ul>
<li>指令长度一致或近似，简化取指和译码的时间差别与译码难度</li>
<li>指令格式一致或近似，尽量使源寄存器位置相同，可以直接取寄存器减少用时</li>
<li>采用Load/Store统一访存，便于通过简化LS指令来减少周期数量</li>
<li>数据与指令对齐存放，减少访存次数</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240203173806.png" /></p>
<h3 id="基本实现">基本实现</h3>
<p><img src="/assets/resources/Pasted%20image%2020240203234024.png" /> <img src="/assets/resources/Pasted%20image%2020240205131527.png" /></p>
<ul>
<li>IF段包括程序计数器(PC)、指令存储器、下条指令地址的计算逻辑；</li>
<li>ID段包括操作控制器、取操作数逻辑、立即数符号扩展模块；</li>
<li>EX段主要包括算术逻辑单元(ALU)、分支地址计算模块；</li>
<li>MEM段主要包括数据存储器读写模块;</li>
<li>WB段主要包括寄存器写入控制模块。<br />
每个流水段后面都需要增加一个<strong>流水段寄存器</strong>，锁存处理完成的数据和控制信号<br />
各种寄存器和数据存储器均采用统一时钟CLK进行同步，每来一个时钟，就会有一条新的指令进入流水线IF段；同时流水段寄存器会锁存前段加工处理完成的数据和控制信号，为下一段的功能部件提供数据输入。<br />
即每两个相邻的流水段之间设置一个流水段寄存器，存放前一个流水段中产生的并需要传输到其后所有流水段的信息，包括各种数据(PC、指令、立即数、运算结果、寄存器号等)和控制信号两大类信息。每个流水段的功能不一样，所需传递的信息也不同，因此各流水段寄存器的长度也不同</li>
</ul>
<div class="note "><p><img src="/assets/resources/Pasted%20image%2020240205131918.png" /> <strong>流水线执行过程</strong>：</p>
<ol type="1">
<li>取指，取出PC值，计算PC+4送入PC输入端，通过PC值取指令字，PC+4与指令字(通过RD输出端)送入IF/ID流水寄存器，以备后续使用，时钟到来时将更新后的PC值和指令字锁存到IF/ID流水寄存器中；本条指令<span class="math inline">\(I_1\)</span>进入ID段，IF段取出下条指令<span class="math inline">\(I_2\)</span></li>
<li>译码/读寄存器ID，控制器通过流水寄存器生产后续需要的控制信号，例如读写寄存器，符号拓展指令字，多路选择器生成寄存器编号，这些数据与信号连同PC+4锁入流水寄存器。指令<span class="math inline">\(I_1\)</span>进入EX段，下条指令<span class="math inline">\(I_2\)</span>进入ID段，下下条指令<span class="math inline">\(I_3\)</span>进入IF段</li>
<li>执行/计算地址EX，功能由具体指令确定，不同指令经ID段译码后得到不同的控制信号，可用于生成访存，分支地址等。时钟到来后，数据和后段需要的控制信号都会锁存到EX/MEM流水寄存器中；指令<span class="math inline">\(I_1\)</span>进入MEM段，后续指令<span class="math inline">\(I_2I_3I_4\)</span>分别进入EX、ID、IF段</li>
<li>访存MEM，由具体指令确定功能，例如根据EX/MEM流水寄存器的访存地址进行读写。时钟到来后，这些数据和后段需要的控制信号都会锁存到MEM/WB流水寄存器中，EX/MEM的信号与数据也会一起送入；指令<span class="math inline">\(I_1\)</span>进入WB段，后续指令<span class="math inline">\(I_2I_3I_4I_5\)</span>分别进入MEM、EX、ID、IF段</li>
<li>写回WB，由具体指令确定功能，将MEM/WB流水寄存器中数据存储器读出的数据写回指定寄存器；时钟到来时会完成数据写入寄存器，指令<span class="math inline">\(I_1\)</span>离开流水线。此时，指令<span class="math inline">\(I_2\)</span>进入最后的WB段，指令<span class="math inline">\(I_3I_4I_5\)</span>分别进入MEM、EX、ID段，指令<span class="math inline">\(I_6\)</span>进入IF段</li>
</ol>
<h3 id="分类">分类</h3>
<ul>
<li>根据流水线使用的级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。
<ul>
<li>部件功能级流水就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。<br />
</li>
<li>处理机级流水是把一条指令解释过程分成多个子过程，如取指、译码、执行、访存及写回5个子过程。<br />
</li>
<li>处理机间流水是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。<br />
</li>
</ul></li>
<li>按流水线可以完成的功能，分为单功能多功能
<ul>
<li>单功能流水线指只能实现一种固定的专门功能的流水线；</li>
<li>多功能流水线指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线</li>
</ul></li>
<li>按同一时间内各段之间的连接方式，流水线可分为静态流水线和动态流水线。
<ul>
<li>静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</li>
<li>动态流水线指在同一时间内，不同的段可以进行不同运算，效率更高，控制更复杂</li>
</ul></li>
<li>按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。
<ul>
<li>线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</li>
<li>非线性流水线存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，适合进行线性递归</li>
</ul></li>
</ul>
</div>
<h3 id="冒险">冒险</h3>
<p>可能遇到一些情况使得流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象称为<strong>流水线冒险</strong></p>
<ol type="1">
<li>结构冒险，多条指令在同一时刻争用同一资源而形成的冲突，也称为资源冲突，解决方法：
<ol type="1">
<li>前一指令访存时，使后一条相关指令(以及其后续指令)暂停一个时钟周期</li>
<li>一个部件每条指令只能使用一次，且只能在特定阶段使用</li>
<li>单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行，如L1Cache将指令数据分离，避免这种问题</li>
</ol></li>
<li>数据冒险，下一条指令会用到当前指令计算出的结果，此时这两条指令发生数据冲突，分为：
<ol type="1">
<li>写后读RAW，当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据,否则读到的就是旧数据</li>
<li>读后写WAR,表示当前指令读出数据后，下一条指令才能写该寄存器,否则读到的就是新数据</li>
<li>写后写WAW,当前指令写入寄存器后，下一条指令才能写,否则寄存器的值就不是最新值</li>
<li>load-use问题，数据在mem阶段存入主存前就要被读出(涉及到主存无法用旁路解决，只能阻塞或者编译优化)</li>
<li>解决方案：
<ol type="1">
<li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为硬件阻塞(stall,根据指令流程分析耗时)和软件插入“NOP”(空)指令两种方法</li>
<li>设置相关专用通路，不经过寄存器，直接把前一条指令的ALU的计算结果作为下一条的输入数据开始计算过程，称为数据旁路技术</li>
<li>编译器对数据相关指令编译优化，调整到合理顺序</li>
</ol></li>
</ol></li>
<li>控制冒险，执行转移、调用或返回等改变原有顺序的指令时，会改变PC值，会造成断流，从而引起控制冒险。解决方法：
<ol type="1">
<li>延迟后续指令</li>
<li>对转移指令进行分支预测，尽早生成转移目标地址，分为简单(静态)预测(每次的预测结果一样,若总是预测条件不满足，跳过分支指令，直接执行后续指令)和动态预测(根据历史进行预测，准确率更高)</li>
<li>预取转移成功和不成功两个控制流方向上的目标指令。</li>
<li>加快和提前形成条件码</li>
<li>提高转移方向的猜准率</li>
</ol></li>
</ol>
<h3 id="性能指标-1">性能指标</h3>
<ol type="1">
<li><p>吞吐率，单位时间内流水线所完成的任务数量，或输出结果的数量。 <span class="math display">\[\mathrm{TP}={\frac{n}{T_{k}}}\]</span> n 是任务数，<span class="math inline">\(T_k\)</span>是处理完n个任务所用的总时间。设k为流水段的段数，Δt为时钟周期。<br />
在输入流水线中的任务连续的理想情况下，一条k段流水线能在上<code>k+n-1</code>个时钟周期内完成n个任务。<br />
<span class="math display">\[\mathbf{TP}={\frac{n}{(k+n-1)\Delta t}}\]</span></p></li>
<li><p>加速比，同样任务不使用流水线与使用流水线所用的时间之比</p></li>
</ol>
<p><span class="math display">\[s={\frac{T_{\mathrm{0}}}{T_{\mathrm{K}}}}\]</span></p>
<p><span class="math inline">\(T_0\)</span>是不用流水线的总时间，<span class="math inline">\(T_k\)</span>流水线所用的总时间</p>
<p><span class="math display">\[S={\frac{k n\Delta t}{(k+n-1)\Delta t}}={\frac{k n}{k+n-1}}\]</span></p>
<h3 id="高级流水线技术">高级流水线技术</h3>
<ol type="1">
<li><p>超标量流水线技术也称动态多发射技术，每个时钟周期内可发多条独立指令，以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件,<code>CPI&lt;1</code>,不能调整指令的执行顺序,配置多个功能部件通过编译优化技术，把可并行执行的指令搭配起来<br />
多数超标量CPU都结合动态流水线调度技术，通过动态分支预测等手段，指令不按顺序执行，这种执行方式称为乱序执行 <img src="/assets/resources/Pasted%20image%2020240205142318.png" /></p></li>
<li><p>超长指令字技术也称静态多发射技术，编译程序将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字(可达几百位)，需要多个处理部件</p></li>
<li><p>超流水线技术，划分更短的功能段与时钟周期，提高流水线主频，也就是级数来提升流水线性能，会增加寄存器开销，CPI依旧=1</p></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240205142507.png" /></p>
<div class="note warning"><ul>
<li>按序流动的流水线只可能出现RAW相关(某条指令要读取上一条指令所写入的寄存器)</li>
<li>非按序流动的流水线中，RAW,WAR,WRW都可能发生</li>
<li>吞吐能力是指单位时间内完成的指令数,稳定后的m段流水线和m个处理器cpu吞吐能力相同</li>
<li>译码和读寄存器通常在一个周期</li>
<li>数据通路不包括控制部件！！！</li>
<li>每访问一次内存数据就会查一次TLB,缺页后需要等调页后再重新访问</li>
</ul>
</div>
<h2 id="多处理器">多处理器</h2>
<p>基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类。</p>
<ol type="1">
<li>单指令流单数据流(SISD)结构，只有一个处理器一个存储器，处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干条指令，可以采用流水线技术，也可以设置多个功能部件使用多模块交叉方式的存储器</li>
<li>单指令流多数据流(SIMD)结构，一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。这种计算机通常由一个指令控制部件、多个处理单元组成。每个单元有自己的地址寄存器，也就是都有不同的数据地址，因此可以有多种组织方式</li>
<li>多指令流单数据流(MISD)结构不存在</li>
<li>多指令流多数据流(MIMD)结构，同时执行多条指令分别处理多个不同的数据，MIMD分为多计算机系统和多处理器系统，前者每个节点有私有存储器和主存地址空间，且相互隔绝，需要消息传递(消息传递MIMD)；后者共享地址空间，存取指令来访问所有存储器(共享存储MIMD)</li>
</ol>
<p>其中SIMD是一种数据级并行模式，而MIMD是一种并行程度更高的线程级并行或线程级以上并行计算模式</p>
<div class="note info"><p>向量处理器是SIMD的变体，是一种实现了直接操作一维数组(向量)指令集的CPU，将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器，适用于数值模拟等领域</p>
</div>
<p><strong>硬件多线程</strong><br />
硬件实现的多线程为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，提高效率</p>
<ol type="1">
<li>细粒度多线程，多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行，每个时钟周期都可以切换线程</li>
<li>粗粒度多线程，一个线程阻塞时才切换线程，流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，切换开销更大</li>
<li>同时多线程SMT，实现指令级并行与线程级并行，在同一个时钟周期中，发射多个不同线程中的多条指令执行。例如intel的超线程就是SMT，单核中线程有自己的状态组件(需要芯片组、操作系统和应用软件的支持) <img src="/assets/resources/Pasted%20image%2020240205152611.png" /></li>
</ol>
<p><strong>多核处理器</strong><br />
多个处理单元集成到单个CPU中，每个处理单元称为一个核，核一般都是对称的，并且共享主存储器，Cahe可独立可共用，因此多核属于共享存储的对称多处理器，可以实现真正的线程并行执行 <img src="/assets/resources/Pasted%20image%2020240205152802.png" /> 具有共享的单一物理地址空间的多处理器被称为<strong>共享内存多处理器(SMP)</strong>，可以通过存储器的共享变量实现通信，所有处理器都可以访问整个存储器，但可以通过虚拟地址空间独立运行程序</p>
<ul>
<li>统一存储访问(UMA)多处理器，访问时间与哪个处理器提出访存请求及访问哪个字无关，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器</li>
<li>非统一存储访问(NUMA)多处理器，访问请求直接有时间区别，处理器中不带高速缓存时，被称为NC-NUMA；处理器中带有一致性高速缓存时，被称为CC-NUMA</li>
</ul>
<p>早期计算机的cpu通过北桥芯片统一访存，但随后cpu数量增加，总线告急，因此每个cpu都要设置独立的内存控制器，连接一部分内存(本地内存)，访问非本地内存时再通过总线访问<br />
在操作共享变量时需要进行同步机制，例如加锁</p>
<div class="note info"><p>组合逻辑电路是具有一组输出和一组输入的非记忆性逻辑电路, 它的基本特点是任何时刻的输出信号状态仅取决于该时刻各个输入信号状态的组合，而与电路在输入信号作用前的状态无关。组合电路不含存储信号的记忆单元，输出与输入之间无反馈通路，信号是单向传输的。<br />
时序逻辑电路中任意时刻的输出信号不仅和当时的输入信号有关，而且与电路原来的状态有关，这是时序逻辑电路在逻辑功能上的特点。因而时序逻辑电路必然包含存储记忆单元。<br />
此外，组合逻辑电路没有统一的时钟控制，而时序逻辑电路则必须在时钟节拍下工作</p>
</div>
<div class="note warning"><ul>
<li>UMA构架由于所有CPU共享相同的内存，增加CPU路数会加大访存冲突，通常2或4路的性能最好，而NUMA理论上支持无限扩展</li>
<li>多核系统的Cache 一致性既包括Cache和内存之间的一致性，还包括各CPU的Cache之间的一致性,对内存同一位置的数据,即不同CPU的Cache不应该有不一致的内容</li>
</ul>
</div>
<h1 id="总线">总线</h1>
<h2 id="概念-2">概念</h2>
<p><strong>总线的定义</strong> 一组能为多个部件分时共享的公共信息传送线路</p>
<ul>
<li>分时：同一时刻只允许有一个部件向总线发送信息。若系统中有多个部件，则它们只能分时地向总线发信息</li>
<li>共享：总线可以挂多个部件，部件交换信息可以用总线分时共享</li>
</ul>
<p>总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种</p>
<ul>
<li>主设备：获得总线控制权的设备<br />
</li>
<li>从设备：被主设备访问的设备，它只能响应从主设备发来的各种总线命令</li>
</ul>
<p><strong>分类</strong>：</p>
<ol type="1">
<li>片内总线，芯片内部的总线，如寄存器，ALU之间或者相互的连接</li>
<li>系统总线，各个功能部件的连接线
<ol type="1">
<li>数据总线，双向传输，位数与机器字长和存储字长有关</li>
<li>地址总线，单向传输，用于访问主存和IO端口，位数与主存地址空间有关</li>
<li>控制总线，传输控制信息</li>
</ol></li>
<li>I/O总线，连接低速的IO设备，通过IO接口连接系统总线，如USB,PCI总线</li>
<li>通信总线，系统之间(包括非计算机的电子设备)的总线，也称外部总线</li>
</ol>
<p>也有同步/异步,并行/串行的分类</p>
<p><strong>结构(靠近CPU的总线速度较快)</strong>：</p>
<ol type="1">
<li>单总线结构，CPU、主存、I/O设备(通过I/O接口)都挂在<strong>一组</strong>总线上，允许I/O设备之间、I/O设备与主存之间直接交换信息，结构简单，成本低</li>
<li>双总线结构，一条是主存总线，用于在CPU、主存和通道之间传送数据；另一条是I/O总线，用于在多个外部设备与通道之间传送数据；需要增加通道等硬件设备</li>
<li>三总线结构，主存总线(cpu与主存)、I/O总线(IO与cpu)和直接内存访问(DMA)总线(内存和高速外设)；提高吞吐量，但任意时刻只能使用一种总线,效率较低</li>
</ol>
<div class="note "><p><strong>总线标准</strong>：国际上公布的互连各个模块的标准</p>
<ul>
<li>ISA(系统)</li>
<li>EISA(拓展前者)</li>
<li>VESA(视频)</li>
<li>PCI(外接设备显卡声卡等)</li>
<li>AGP(视频)</li>
<li>PCI-E(取代PCI,AGP，以上四者都是局部总线)</li>
<li>USB(IO)</li>
<li>IDE/ATA(磁盘接口)</li>
<li>SATA(硬盘)</li>
</ul>
</div>
<p><strong>性能指标</strong>：</p>
<ol type="1">
<li>传输周期，一次总线操作所需时间，包括申请，寻址，传输和结束</li>
<li>总线时钟周期，受到计算机时钟控制</li>
<li>总线工作频率，总线操作的频率，为总线周期倒数</li>
<li>总线时钟频率，与机器时钟频率相同</li>
<li>总线宽度(位宽)，通常是数据总线根数</li>
<li>总线带宽，总线最大数据传输率，字节/秒，总线带宽= 总线工作频率x(总线宽度/8)</li>
<li>总线复用，一种信号线在不同时间传输不同信息</li>
<li>信号线数，三种总线的线数和<br />
最主要性能指标为总线宽度、总线(工作)频率、总线带宽<br />
总线带宽=总线宽度x总线频率</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240205222012.png" /> <img src="/assets/resources/Pasted%20image%2020240205222956.png" /></p>
<p>桥接器用于连接不同的总线，具有数据缓冲、转换和控制功能。</p>
<div class="note warning"><ul>
<li>地址总线不仅可以指定主存单元，也可用来指定IO端口</li>
<li>地址总线是用于CPU到主存和I/O端口地址的单向总线,控制信息和状态信息也类似</li>
<li>CPU的控制总线提供的控制信号包括时序信号、I/O设备和存储器的响应信号等</li>
<li>PCI、EISA、ISA均是并行总线，USB是通用串行总线</li>
<li>突发(猝发)传输方式可以连续传送地址连续的数据，但需要先传一个地址</li>
<li>USB是一种连接外部设备的I/O总线标准，属于设备总线，是设备和设备控制器之间的接口。而PCI、AGP、PCIE作为计算机系统的局部总线标准，通常用来连接主存、网卡、视频卡等</li>
<li>PCI-Express总线采用串行数据包传输数据</li>
</ul>
</div>
<h2 id="总线事务与定时">总线事务与定时</h2>
<p><strong>总线事务</strong>：从请求总线到完成总线使用的操作序列</p>
<ol type="1">
<li>请求，主设备(cpu/dma)发出总线传输请求，获取总线控制权</li>
<li>仲裁，总线仲裁机构决定将下个周期的总线使用权交给某个申请者</li>
<li>寻址，主设备通过总线给出要访问的从设备地址和相关命令，启动从模块</li>
<li>传输，主从模块数据交互,分为寻址阶段、申请分配阶段、传输阶段</li>
<li>释放，主模块信息从系统总线上撤出，让出总线使用权</li>
</ol>
<div class="note info"><p>上升(下降)沿：数字电平从0(1)变为1(0)的一瞬间,可通过这两个信号规定总线连接设备操作的时间次序<br />
突发(猝发)传送方式能够进行连续成组数据的传送，其寻址阶段发送的是连续数据单元的首地址，在传输阶段传送多个连续单元的数据，每个时钟周期可以传送<strong>一个字长</strong>的信息，但是不释放总线，直到一组数据全部传送完毕后，再释放总线<br />
在某个总线周期内，总线上只有一个主设备控制总线，选择一个从设备与之进行通信(一对一)，或对所有设备进行广播通信(一对多)</p>
</div>
<p><strong>总线定时</strong>是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步和异步两种基本定时方式。</p>
<ul>
<li>同步定时方式，系统用统一的时钟信号协调发送接受方的传送定时关系，一个时钟周期构成总线周期，周期内发送接收方可以进行数据传送。速度快且控制逻辑简单，但可靠性交叉，适用于总线较短且部件存取时间相近的系统(高速部件会被拖累)</li>
<li>异步定时方式，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。没有固定周期，可靠性高，更复杂且低速,每个字符都要用开始位和停止位作为字符开始和结束的标志。根据“请求”和“回答”信号的撤销是否互锁，可分为：
<ul>
<li>不互锁，主设备请求后，一段时间没有接受则撤销，从设备也一样自动撤销</li>
<li>半互锁，请求必须在回答后才撤销，回答则可以自动撤销(隔一段时间后自动撤销“回答”信号)</li>
<li>全互锁，请求回答彼此都需要回复</li>
</ul></li>
<li>分离式：
<ol type="1">
<li>各模块均有权申请占用总线,包括接收方和发送方</li>
<li>采用同步方式通信，不等对方回答，每次发送都是单方向</li>
<li>各模块准备数据时，不占用总线</li>
<li>总线利用率提高,但控制复杂</li>
</ol></li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240206103615.png" /></p>
<div class="note info"><p>半同步通信总线既保留了同步通信的特点，又能采用异步应答方式连接速度相差较大的设备。通过在异步总线中引入时钟信号，其就绪和应答等信号都在时钟的上升沿或下降沿有效，而不受其他时间的信号干扰。<br />
例如从某个时钟开始，在每个时钟到来时，采样Wait信号，若无效，则说明数据未准备好，下个时钟到来时，再采样Wait信号，直到检测到有效再取数据</p>
</div>
<h1 id="io设备">IO设备</h1>
<h2 id="io接口">IO接口</h2>
<p>I/O接口(I/O控制器)是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换<br />
<strong>主要功能</strong>：</p>
<ul>
<li>地址译码和设备选择，译码cpu送来的外设地址码，选择指定的设备</li>
<li>主机和外设的通信控制，协调不同工作速度，时序的外设和主机之间交换信息</li>
<li>数据缓冲，为了协调速度，接口需要用寄存器暂存部分数据</li>
<li>信号格式转换，电平，数据格式的转换</li>
<li>传送控制命令和状态信息，负责启动关闭，中断等信息的传送</li>
</ul>
<p><strong>基本结构</strong>：<br />
I/O接口在主机侧通过I/O总线与内存、CPU相连。通过数据总线，在数据缓冲寄存器与内存或CPU的寄存器之间进行数据传送。同时接口和设备的状态信息被记录在状态寄存器中，通过数据线将状态信息送到CPU。CPU对外设的控制命令也通过数据线传送，一般将其送到I/O接口的控制寄存器。<br />
接口中的地址线用于给出要访问的I/O接口中的寄存器的地址，它和读/写控制信号(通过控制线)一起被送到I/O接口的控制逻辑部件<br />
接口中的I/O控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能。<br />
对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为I/O指令，I/O指令只能在操作系统内核的底层I/O软件中使用，它们是一种特权指令<br />
<img src="/assets/resources/Pasted%20image%2020240206124440.png" /></p>
<p><strong>接口类型</strong>：</p>
<ol type="1">
<li>按数据传送方式分
<ol type="1">
<li>并行接口(一个字/字节的所有位同时传送)</li>
<li>串行接口(一次传送一位)</li>
</ol></li>
<li>主机控制方式分
<ol type="1">
<li>程序查询接口</li>
<li>中断接口</li>
<li>DMA接口</li>
</ol></li>
<li>功能选择分
<ol type="1">
<li>可编程接口</li>
<li>不可编程接口</li>
</ol></li>
</ol>
<p><strong>IO端口</strong>：I/O端口是指接口电路中可被CPU直接访问的寄存器，主要有数据端口、状态端口和控制端口，若干端口加上相应的控制逻辑电路组成接口<br />
通常，数据端口可RW,状态端口只能R，控制端口只能W<br />
各个端口有自己的编号，对应一个端口地址，编址方式分为：</p>
<ul>
<li>统一编址，存储器映射方式，将IO端口当做存储器单元分配地址，可以用统一访存指令访问。编址空间较大，不需要专用指令，但占用存储器地址，且执行较慢</li>
<li>独立编址，IO映射方式，需要专门的IO指令访问IO端口，IO地址空间和主存独立。更清晰，但控制逻辑更复杂</li>
</ul>
<div class="note warning"><ul>
<li>I/O总线分为三类：数据线、控制线和地址线。数据缓冲寄存器和命令/状态寄存器的内容都是通过数据线来传送的；地址线用以传送与CPU交换数据的端口地址；而控制线用以给I/O端口发送读/写信号</li>
<li>IO指令格式和其他通用指令相比有所不同</li>
<li>磁盘驱动器是由磁头、磁盘和读/写电路等组成的，也就是我们平常所说的磁盘本身</li>
</ul>
</div>
<h2 id="io方式">IO方式</h2>
<p>常用的I/O方式有程序查询、程序中断、DMA和通道等</p>
<h3 id="程序查询方式">程序查询方式</h3>
<p>信息交换的控制完全由CPU执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器(数据端口)和一个设备状态寄存器(状态端口)<br />
IO操作时，先发出询问信号，再根据设备状态决定传送时间<br />
<strong>工作流程</strong>：</p>
<ol type="1">
<li>cpu执行初始化程序，预置传送参数</li>
<li>向IO口发出命令字，启动设备</li>
<li>从外设接口读取状态</li>
<li>cpu查询状态，直到就绪</li>
<li>传送数据</li>
<li>修改地址和计数器参数</li>
<li>若计数器不为0(传送未结束)则转3，否则结束</li>
</ol>
<p>结构最简单，但cpu需要忙等待，与io串行工作，效率低<br />
<img src="/assets/resources/Pasted%20image%2020240206154237.png" /></p>
<h3 id="程序中断方式">程序中断方式</h3>
<p>cpu启动io流程后，继续工作，直到io发送中断请求，再用中断服务程序处理(IO准备数据过快的话，可能来不及取就数据溢出)<br />
<img src="/assets/resources/Pasted%20image%2020240206155937.png" /> <strong>工作流程</strong>：</p>
<ol type="1">
<li>中断请求，一般每个中断源有中断请求标记触发器，置1为中断请求，触发器组成中断请求标记寄存器，可放置于cpu或中断源。请求分为可屏蔽(INTR线，关中断时不响应)，不可屏蔽(NMI线)，内部异常
<ol type="1">
<li>当 IF=1 时，若 INTR 保持高电平，则在当前指令执行完毕后就进入中断响应周期</li>
<li>NMI 中断不必检查 IF 标志位是否为 1,强制需要处理</li>
<li>INTA：中断响应(interrupt acknowledge)信号，输出。响应 INTR 输入。该引脚常用来选通中断向量码以响应中断请求</li>
</ol></li>
<li>中断响应判优，一般来说，不可屏蔽中断 &gt; 内部异常(硬件故障 &gt; 软件中断) &gt; 可屏蔽中断;DMA &gt; IO(高速设备&gt;低速设备，输入设备&gt;输出设备，实时设备&gt;普通设备)</li>
<li>响应中断的条件
<ol type="1">
<li>中断源有中断请求</li>
<li>开中断(异常和不可屏蔽中断不受限制)</li>
<li>指令执行完毕(异常不受此限制)，只有这时cpu会查询中断信号</li>
</ol></li>
<li>中断响应，中断服务程序由硬件直接实现的,称为<strong>中断隐指令(与指令系统的指令性质不同),隐指令引出中断服务程序</strong>
<ol type="1">
<li>关中断</li>
<li>保存断点，一般是PC,PSW内容保存在栈或者特定寄存器</li>
<li>中断服务程序，根据中断源选择合适服务程序，将服务程序入口地址送入PC</li>
</ol></li>
<li>中断向量，每个中断都有一个唯一的类型号，每个中断类型号都对应一个中断服务程序，其入口地址就是中断向量，一般中断向量表集中存于主存。(也可以软件查询法，使用向量法的中断称为向量中断)</li>
<li>中断处理过程，一般而言如下图，其中现场指的是用户可见的工作寄存器内容,图中如果不允许嵌套中断，中断服务前后的开关中断省去</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206161017.png" /> 若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，cpu暂停现行中断服务去处理新的中断，这种中断称为多重中断(中断嵌套)需要满足：</p>
<ol type="1">
<li>中断服务程序中提前设置开中断指令</li>
<li>优先级别高的中断源有权中断优先级别低的中断源</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206161514.png" /> 现代计算机一般使用中断屏蔽技术，每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。利用屏蔽技术可以动态调整优先级，否则处理和响应优先级相同(表示中断源自身的位置1)<br />
屏蔽字就类似于官僚系统，可以屏蔽的(即寄存器中的1)越多，其优先级越高</p>
<h3 id="dma">DMA</h3>
<p>在外设与内存之间开辟一条“直接数据通道”<br />
适用于磁盘、显卡等高速设备大批量数据的传送，硬件开销较大，中断的作用仅限于故障和正常传送结束时的处理</p>
<ul>
<li>主存和DMA接口之间有一条直接数据通路。IO访存无需经过cpu，与主机并行。</li>
<li>数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</li>
<li>主存中要开辟专用缓冲区，及时供给和接收外设的数据</li>
<li>传送速度快，且传送前需要程序预处理，结束时需要通过中断进行后处理</li>
</ul>
<p><strong>组成</strong>： 对数据传送过程进行控制的硬件称为<strong>DMA控制器(DMA接口)</strong>，控制器向cpu发出传送请求，响应后cpu让出整个系统总线，由DMA控制器接管总线传送数据</p>
<ol type="1">
<li>接受外设的dma请求，向cpu请求总线</li>
<li>cpu发出总线响应信号后，dma接管总线</li>
<li>确定传送数据的地址与长度(由设备驱动程序设置传送参数)</li>
<li>规定数据传送方向，发送读写等控制信号进行传送</li>
<li>结束后向cpu报告</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206164528.png" /></p>
<p><strong>传送方式</strong></p>
<ol type="1">
<li>停止cpu访存,与上文一致</li>
<li>周期挪用(窃取)；IO请求时如果cpu正在访存，则等到存取周期结束；IO请求如果与cpu访存请求同时，则IO(优先级更高)挪用若干存取周期，传送一个数据就立刻释放总线</li>
<li>DMA和cpu交替访存，CPU的工作周期比主存存取周期长时，可以将cpu周期分为dma和cpu分别的访存周期，分时控制</li>
</ol>
<p><strong>传送过程</strong></p>
<ol type="1">
<li>预处理,CPU完成一些必要的准备工作。测试设备状态，设置传送方向，寄存器等，随后cpu执行原有程序，直到IO就绪请求DMA</li>
<li>数据传送,可以以单字节(或字)为基本单位，也可以以数据块为基本单位(DMA控制器用循环实现)</li>
<li>后处理，DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验数据是否正确，传送是否出错等</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206161445.png" /></p>
<p><strong>与中断的区别</strong>：</p>
<ol type="1">
<li>中断需要保护恢复现场；DMA方式不中断现行程序，无需保护现场，除了预处理和后处理不占用cpu</li>
<li>cpu只在指令结束时响应中断；但任意周期结束时都可以响应DMA请求,<strong>即每个机器周期结束时都可以响应</strong></li>
<li>中断需要cpu干预，DMA不需要且更加高效</li>
<li>DMA请求优先级高于中断</li>
<li>中断可以处理异常，DMA只用于传送数据</li>
<li>中断通过程序层面传送数据，DMA则是硬件层</li>
</ol>
<div class="note warning"><ul>
<li>中断向量是中断服务程序的入口地址，中断向量地址是内存中存放中断向量的地址，即中断服务程序入口地址的地址</li>
<li>内部异常都是不可屏蔽的内中断，外部中断区分NMI,INTR</li>
<li>cache等硬件错误不属于中断</li>
<li>浮点数上溢，表示超过了浮点数的表示范围，属于内中断(下溢是0不需要处理)</li>
<li>CPU会在每个存储周期结束后检查是否有DMA请求</li>
<li>中断优先级由高至低为访管-&gt;程序性-&gt;重新启动</li>
<li>允许中断触发器置0表示关中断，在中断响应周期由硬件自动完成，即中断隐指令完成;恢复现场和屏蔽字时，由关中断指令完成</li>
<li>中断屏蔽标志的一种作用是实现中断升级，即改变中断处理完成的次序(中断响应次序由硬件排队电路决定)</li>
<li>与中断不同，DMA请求的响应时间可以发生在每个机器周期结束时，只要CPU不占用总线</li>
<li>指令寄存器IR和标志寄存器FR的输出信号会连到控制部件的输入端</li>
<li>关中断; 保存断点;识别中断源由硬件完成，现场保护恢复与开中断由中断服务完成</li>
<li>外部设备通常不能发出不可屏蔽中断</li>
<li>CPU检测不到处理优先级更低的中断请求信号,检测到中断请求信号，则说明其处理优先级更高</li>
</ul>
</div>
<h1 id="杂项">杂项</h1>
<p><strong>透明性总结</strong>:</p>
<ol type="1">
<li>所有用户可见
<ol type="1">
<li>pc</li>
<li>psw</li>
<li>通用寄存器(组)</li>
<li>ACC</li>
</ol></li>
<li>汇编程序员可见
<ol type="1">
<li>中断字寄存器(相应优先级是硬件写死的，屏蔽字可以更改，置1表示屏蔽)</li>
<li>基址寄存器</li>
<li>变址寄存器</li>
<li>虚拟存储空间</li>
</ol></li>
<li>所有用户不可见
<ol type="1">
<li>MDR</li>
<li>MAR</li>
<li>IR</li>
<li>微程序相关寄存器</li>
<li>Cache</li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206161017.png" /></p>
<ul>
<li>I/O总线分为三类：数据线、控制线和地址线。数据缓冲寄存器和命令/状态寄存器的内容都是通过数据线来传送的；地址线用以传送与CPU交换数据的端口地址；而控制线用以给I/O端口发送读/写信号</li>
</ul>
]]></content>
      <categories>
        <category>考研笔记</category>
        <category>研distance</category>
      </categories>
      <tags>
        <tag>研distance</tag>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>研distance——计算机网络</title>
    <url>/thinklive/52285/</url>
    <content><![CDATA[<h1 id="概论">概论</h1>
<h2 id="概念">概念</h2>
<p><strong>主流定义</strong>：以能够相互共享资源的方式互连起来的自治计算机系统的集合</p>
<ol type="1">
<li>从组成部分上看，一个完整的计算机网络主要由硬件、软件、协议三大部分组成。其中硬件主要由主机(也称端系统)、通信链路(如双绞线、光纤)、交换设备(如路由器、交换机等)和通信处理机(如网卡)等组成<br />
</li>
<li>从工作方式上看，计算机网络(这里主要指Internet,即因特网)可分为边缘部分和核心部分,边缘系统是由用户主机组成用于通信和资源共享；核心系统为边缘部分提供互联服务<br />
</li>
<li>从功能组成上看，计算机网络由通信子网和资源子网组成。通信子网由各种传输介质、通信设备和相应的网络协议组成，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合,向网络用户提供共享服务。</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240303102036.png" /><br />
<img src="/assets/resources/Pasted%20image%2020240303101219.png" /></p>
<span id="more"></span>
<h3 id="功能">功能</h3>
<ol type="1">
<li>数据通信：用于实现联网计算机之间的信息传输<br />
</li>
<li>资源共享：包括软件数据和硬件的共享<br />
</li>
<li>分布式处理：将计算任务分配给网络的其他计算机主机，从而提高系统利用率<br />
</li>
<li>提高可靠性：网络中的不同主机可以互为替代<br />
</li>
<li>负载均衡</li>
</ol>
<h3 id="分类">分类</h3>
<ol type="1">
<li>按分布范围
<ol type="1">
<li>广域网WAN(远程网)：提供长距离通信，通常覆盖直径几十到几千千米区域；通信容量较大<br />
</li>
<li>城域网MAN:城域网的覆盖范围可以覆盖一个城市，通常直径5~50km。<br />
</li>
<li>局域网LAN:用微机或者工作站相连，通常直径几十米到几千米区域。<br />
</li>
<li>个人区域网PAN:个人将消费电子产品相连的网络，通常覆盖10m左右<br />
</li>
</ol></li>
<li>按传输技术
<ol type="1">
<li>广播式网络，一台计算机利用共享通信信道发送报文分组时。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组，多用于局域网<br />
</li>
<li>点对点网络，每条物理线路连接一对计算机。若通信的两台主机之间没有直接连接的线路 ，则它们之间的分组传输就要通过中间结点进行接收、存储和转发，直至目的结点<br />
</li>
</ol></li>
<li>拓扑结构分类
<ol type="1">
<li>总线形，用一条总线连接所有计算机，建网容易，但效率低，可靠性差<br />
</li>
<li>星形,中央设备点对点连接所有终端，便于集中管理，但成本高<br />
</li>
<li>环形,计算机设备连成一个环，其中信号单向传输，可以单环可以双环<br />
</li>
<li>树状，根节点负责传到子节点，直到叶节点，用于某些多级交换网络<br />
</li>
<li>网状,可靠性高，但结构复杂,多用于广域网<br />
</li>
</ol></li>
<li>使用者分类
<ol type="1">
<li>公用网，向电信公司交费即可使用<br />
</li>
<li>专用网，对外封闭<br />
</li>
</ol></li>
<li>交换技术分类
<ol type="1">
<li>电路交换网络：在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段,如电话网络。
<ol type="1">
<li>时间延迟低，但线路利用率低，不便于管理<br />
</li>
</ol></li>
<li>报文交换网络(存储-转发网络):用户数据加上源地址、 目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。
<ol type="1">
<li>报文先传送到相邻节点，完全存储后转发到下一个结点。更加灵活，但增加资源，控制上的开销与缓冲时延，缓冲难以管理<br />
</li>
</ol></li>
<li>分组交换网络(包交换网络)：数据分为较短的定长数据块，数据块加上目的地址等信息组成分组(包)，在此基础上类似存储转发，包的平均时延更小，网络占用的平均缓冲区更少；更易于标准化；更适合应用，现在应用最广泛<br />
</li>
</ol></li>
<li>传输介质分类
<ol type="1">
<li>有线，双绞线，同轴电缆等<br />
</li>
<li>无线，蓝牙，微波等</li>
</ol></li>
</ol>
<h3 id="性能指标">性能指标</h3>
<ol type="1">
<li>带宽：类似计组的带宽(b/s)<br />
</li>
<li>时延：数据从网络一端传到另一端需要的总时间，为以下部分之和
<ol type="1">
<li>发送(传输)时延：发送报文或分组的第一个比特到最后一根比特发送完需要的时间 <span class="math inline">\(发送时延=分组长度/信道宽度\)</span><br />
</li>
<li>传播时延：电磁波在信道传播一定距离需要的时间，一个比特从链路一端传播到另一端所需时间 <span class="math inline">\(传播时延=信道长度/电磁波在信道上的传播速率\)</span><br />
</li>
<li>处理时延：数据在交换节点为存储转发进行的处理花费的时间<br />
</li>
<li>排队时延:分组在进入路由器后要在输入与输出队列排队等待处理<br />
</li>
</ol></li>
<li>时延带宽积：发送端第一个比特即将到达终点时，发送端已经发出了多少比特: <span class="math inline">\(时延带宽积=传播时延\times信道带宽\)</span><br />
</li>
<li>往返时延RTT:发送端发出一个短分组，到发送端收到接收端的确认，经过的时延<br />
</li>
<li>吞吐量Throughput:单位时间内通过某个网络(信道/接口)的数据量，吞吐量受网络带宽或者网络额定速率的限制，理想情况下N条链路的每个链路平均吞吐为1/N<br />
</li>
<li>速率Speed：连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据传输速率、数据率或比特率，单位为 b/s<br />
</li>
<li>信道利用率，某个信道有百分之多少时间有数据通过 <span class="math inline">\(信道利用率=有数据通过时间/总时间\)</span></li>
</ol>
<div class="note info"><p>三网：电信网络，有线电视网络，计算机网络，有不同的标准协议等<br />
目前逐渐向计算机网络统一<br />
OSI中通信子网一般指下三层，资源子网一般是上三层</p>
</div>
<h2 id="网络结构">网络结构</h2>
<p>出于工程上的考虑,通常对计算机网络的体系结构以分层的方式进行建模。计算机网络的各层及其协议的集合称为网络的体系结构,也就是是计算机网络中的层次、各层的协议及层间接口的集合<br />
每层实现一种相对独立的功能，提供清晰的接口，上层单向使用下层服务<br />
第n层中的活动元素通常称为第n层实体,实体是个逻辑上的概念，可以是硬件或者软件，不同机器上的同一层称为对等层，同一层的实体称为对等实体。第n层实体实现的服务为第n+1 层所利用<br />
在计算机网络体系结构的各个层次中，每个报文都分为两部分：数据部分SDU ;控制信息部分PCI, 它们共同组成PDU<br />
服务数据单元(SDU )：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元一记为n-SDU<br />
协议控制信息(PCI)：控制协议操作的信息。第n层的协议控制信息记为n-PCI<br />
协议数据单元(PDU)：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据单元记为n-PDU<br />
在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，数据链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文段<br />
n+1层收到的PDU作为n层的SDU，加上n层的PCI，成为第n层的PDU<br />
<img src="/assets/resources/Pasted%20image%2020240303113854.png" /><br />
得出关系<br />
n-SDU+n-PCI=n-PDU=(n-1)-SDU<br />
<strong>层次结构的含义</strong>:</p>
<ol type="1">
<li>每层向上一层提供的服务，是自己与下层提供服务的总和<br />
</li>
<li>最底层只提供服务，最高层给用户提供服务<br />
</li>
<li>无法跨层调用，且下层的实现细节对上层透明<br />
</li>
<li>主机通信时，对等层在逻辑上有直接信道，可以不经过下层传送数据</li>
</ol>
<h3 id="常见概念">常见概念</h3>
<ol type="1">
<li><p>协议:规则的集合，规定交换数据的格式与相关的同步问题<br />
网络协议特指为网络中数据交换建立的规则，其中交换的几个实体都是对等的，也就是只有对等层之间有协议存在<br />
由语法，语义，同步三部分组成；其中语法规定传输数据的格式，语义规定要完成的功能(行为)，同步规定了其顺序，条件等<br />
一个完整的协议通常应具有线路管理(建立、释放连接)、差错控制、数据转换等功能</p></li>
<li><p>接口<br />
同一结点内<strong>相邻</strong>两层间交换信息的连接点，这两层的实体通过服务访问点SAP交互，服务通过SAP提供给上层使用，第n层的SAP就是第n+1层可以访问第n层服务的地方。<br />
SAP是逻辑接口，不等于硬件接口</p></li>
<li><p>服务<br />
下层为紧邻上层提供的功能调用，是垂直的，但服务不是一层的全部功能<br />
上层使用下层服务时，需要与下层交换命令，这些命令称为服务原语，可分为：</p></li>
<li><p>请求，服务用户发给服务提供者<br />
</p></li>
<li><p>指示，服务提供者发往服务用户<br />
</p></li>
<li><p>响应，服务用户发往服务提供者，响应指示<br />
</p></li>
<li><p>证实，服务提供者发往服务用户，证实请求</p></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240303133702.png" /><br />
<img src="/assets/resources/Pasted%20image%2020240303133828.png" /></p>
<p>服务可分为以下几类：</p>
<ul>
<li>面向连接与无连接，前者需要先建立连接，如TCP；后者可以直接发送，但不保证可靠性，如IP,UDP<br />
</li>
<li>可靠服务和不可靠服务，前者可以纠错，应答；后者其可靠性由用户保证，用户需要验证信息正确性，如果错误可以要求纠正或重发<br />
</li>
<li>有应答服务和无应答服务，前者接收方收到数据后需要给出应答，由传输系统实现，如文件传输服务；后者如www服务，客户端收到页面后不应答</li>
</ul>
<h3 id="参考模型">参考模型</h3>
<p><strong>OSI参考模型</strong><br />
国际标准化组织(ISO )提出的网络体系结构模型，称为开放系统互连参考模型(OSI/RM )<br />
自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。低三层统称为通信子网,高三层是资源子网<br />
<img src="/assets/resources/Pasted%20image%2020240303134614.png" /></p>
<ol type="1">
<li><p>物理层<br />
传输单位是bit，在物理媒体上传输原始比特流<br />
主要定义数据终端设备(DTE)和数据通信设备(DCE)的物理与逻辑连接方法，所以物理层协议也称物理层接口标准。通信技术的早期阶段，通信规则称为规程(Procedure),因此物理层协议也称物理层规程<br />
主要规定通信链路与结点的电路接口，传输的信号意义与电子信号等，使用的物理媒体可称为第0层</p></li>
<li><p>数据链路层<br />
数据链路层的传输单位是帧，将网络层传来的IP数据报组装成帧，提供点到点的传输服务<br />
传输时可能产生错误，数据链路层可以丢弃错误信息；或者协调不同速度的节点；同步共享问题等<br />
典型的协议有SDLC,HDLS,PPP,STP</p></li>
<li><p>网络(网际/IP)层<br />
传输单位是数据报，将网络层的协议数据单位从源端送到目的端，为分组交换网进行路由选择，以及各种通信服务。例如选择数据传输路径，流量控制、拥塞控制、差错控制和网际互连等<br />
因特网的主要网络层协议是无连接的网际协议(Internet Protocol, IP ) 和许多路由选择协议，因此因特网的网络层也称网际层或IP层<br />
协议有 IP、IPX、ICMP、IGMP、ARP、RARP 和 OSPF 等</p></li>
<li><p>传输层<br />
传输单位是报文段(TCP)或用户数据报(UDP)，为端对端连接提供可靠的传输服务，包括流量控制、差错控制、服务质量、数据传输管理等<br />
传输层的端到端通信，指的是不同主机的两个进程，通过端口号标识来通信，与数据链路层的点对点(主机到主机)不同<br />
传输层具有复用和分用的功能。</p></li>
</ol>
<ul>
<li>复用指多个应用层进程可同时使用下面传输层的服务<br />
</li>
<li>分用指传输层把收到的信息分别交付给上面应用层中相应的进程。<br />
传输层的协议有TCP、UDP</li>
</ul>
<ol start="5" type="1">
<li><p>会话层<br />
会话层允许不同主机上的各个进程之间进行会话。会话层利用传输层提供的端到端的服务，为表示层实体或用户进程建立连接并在连接上有序地传输数据，即会话，也称建立同步(SYN)<br />
会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步</p></li>
<li><p>表示层<br />
两个通信系统中交换信息的表示方式<br />
采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示变换功能。</p></li>
<li><p>应用层<br />
OSI参考模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问 OSI参考模型环境的手段。<br />
最为复杂，有最多的协议，例如传送文件的FTP,电子邮件的SMTP,万维网的HTTP</p></li>
</ol>
<p><strong>TCP/IP</strong><br />
<img src="/assets/resources/Pasted%20image%2020240303141020.png" /><br />
网络接口层的功能类似于OSI参考模型的物理层和数据链路层,表示与物理网络的接口,从主机或结点接收IP分组，并把它们发送到指定的物理网络上<br />
网际层 (主机-主机)是 TCP/IP体系结构的关键部分。和OSI参考模型的网络层在功能上非常相似。将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责,定义了分组格式与协议(IPv4与IPv6)<br />
传输层(应用-应用或进程-进程)的功能,和OSI参考模型中的传输层类似，即使得发送端和目的端主机上的对等实体进行会话。主要使用两种协议：</p>
<ul>
<li>传输控制协议(TCP)面向连接，数据传输的单位是报文段，能够提供可靠的交付<br />
</li>
<li>用户数据报协议(UDP)无连接，数据传输的单位是用户数据报，不保证提供可靠的交付</li>
</ul>
<p>应用层(用户-用户)包含所有的高层协议，如虚拟终端协议(Telnet)文件传输协议(FTP)、域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)</p>
<p><img src="/assets/resources/Pasted%20image%2020240303141657.png" /></p>
<ul>
<li>OSI参考模型精确地定义了三个主要概念：服务、协议和接口<br />
</li>
<li>OSI没有偏向于任何特定的协议,TCP/IP则以协议为主，迎合已有协议<br />
</li>
<li>TCP/IP模型在设计之初就考虑到了多种异构网的互连问题，并将网际协议(IP)作为一个单独的重要层次<br />
</li>
<li>OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信 。而 TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式</li>
</ul>
<p>常用的结构模型：<br />
<img src="/assets/resources/Pasted%20image%2020240303142105.png" /></p>
<div class="note warning"><ul>
<li>局域网接入广域网主要是通过路由器实现的。<br />
</li>
<li>ISO/OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅支持面向连接的通信；TCP/IP模型在网络层仅有无连接的通信，而在传输层支持无连接和面向连接的通信</li>
</ul>
</div>
<hr />
<h1 id="物理层">物理层</h1>
<p>物理层是体系结构的第一层，由于规定了电气特性，因此能够识别所传送的比特流。<br />
有时称传输媒体为0层,在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么<br />
规定物理媒体的各种特性</p>
<ol type="1">
<li>机械特性，接口形状，线脚数量等<br />
</li>
<li>电气特性，电压范围等<br />
</li>
<li>功能特性，各种电平的含义<br />
</li>
<li>规程特性，操作的顺序</li>
</ol>
<h2 id="通信基础">通信基础</h2>
<p>数据是指传送信息的实体。信号则是数据的电气或电磁表现，是数据在传输过程中的存在形式</p>
<ul>
<li>连续变化的数据(或信号)称为模拟数据(或模拟信号)<br />
</li>
<li>取值仅允许为有限的离散数值的数据(或信号)称为数字数据(或数字信号)</li>
</ul>
<p><strong>码元</strong>：用一个固定时长的信号波形(数字脉冲)表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位<br />
1 码元可以携带若干比特的信息量。例如，在使用二进制编码时，只有两种不同的码元(0/1)<br />
<strong>数据通信</strong>：数字计算机与其他数字终端的通信，可以分为信源(数据源，发出后先通过变换器转换成适合信道传输的信号)，信道(逻辑部件，往往一条发送信道与接收信道组合)，信宿(传输终点，接受信道信号前需要反变换器转换成原始信息)三个部分。<br />
<img src="/assets/resources/Pasted%20image%2020240309102157.png" /><br />
信道可以分为模拟/数字，无线/有线<br />
信道上的信号分为基带信号和宽带信号：</p>
<ul>
<li>基带：发出的直接表达了要传输的信息的信号，数字信号01用不同电压表示，在数字信道上传输<br />
</li>
<li>宽带：将基带信号调制后形成频分复用模拟信号，随后放到模拟信道上传输，把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输</li>
</ul>
<p>三种基本交互方式：</p>
<ul>
<li>单向通信，只有一个方向的通信，只需要一个信道(电视广播)<br />
</li>
<li>半双工通道，双方都可以接收发送，但其中一方同一时间只能接收或者发送<br />
</li>
<li>全双工通道，双方都可以同时发送接受</li>
</ul>
<p>信道的极限容量是指信道的最高码元传输速率或信道的极限信息传输速率</p>
<p>速率也称数据率，指的是数据传输速率，表示单位时间内传输的数据量：</p>
<ul>
<li>码元传输速率(波特率):单位时间内通信系统传输的码元个数，单位是波特(Baud,数字通信系统每秒传输一个码元)<br />
</li>
<li>信息传输速率。又称信息速率、比特率等，它表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特/秒(b/s)</li>
</ul>
<p>带宽表示单位时间内从网络中的某一点到另一点所能通过的最高数据率(b/s)</p>
<p>同步传输:数据的传送以一个数据区块为单位，又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据<br />
异步传输：将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位</p>
<h2 id="通信定理">通信定理</h2>
<p>信道中一些高频分量会衰减，导致接收时失真，这称为码间串扰<br />
<strong>奈奎斯特(Nyquist)定理</strong>又称奈氏准则，它规定：在理想低通(没有噪声、带宽有限)的信道中，为了避免码间串扰，极限码元传输速率为2W波特，其中W是理想低通信道的带宽。若用V表示每个码元离散电平的数目(码元的离散电平数目是指有多少种不同的码元，比如有 16.种不同的码元，则需要4个二进制位，数据传输速率是码元传输速率的4 倍 )，则极限数据率为<br />
理想低通信道下的极限数据传输速率= <span class="math inline">\(2W\log V\)</span>(b/s)</p>
<p>可以推出的结论：</p>
<ol type="1">
<li>任何信道的码元传输速率都有上限<br />
</li>
<li>信道频带越宽，传输速率可以越高<br />
</li>
<li>码元的比特量(对应多少二进制位)不受限制</li>
</ol>
<p><strong>香农定理</strong>：带宽受限且有高斯白噪声干扰的信道的极限数据传输速率<br />
信道的极限数据传输速率= <span class="math inline">\(W\log_{2}(1+S/N)\)</span><br />
W为信道的带宽，S为信道所传输信号的平均功率，N 为信道内部的高斯噪声功率<br />
S/N为信噪比，即信号的平均功率与噪声的平均功率之比，信噪比单位db= <span class="math inline">\(10\log_{10}(S/N)\)</span></p>
<p>可以得出的结论：</p>
<ol type="1">
<li>信噪比越大，极限传输速率越高<br />
</li>
<li>一定的带宽和信噪比，可以确定信息传输速率上限<br />
</li>
<li>只要信息传输速率低于信道的极限传输速率，就可以实现无错传输<br />
</li>
<li>实际传输速率会低于极限速率<br />
</li>
<li>香农定理考虑信噪比，因此码元的比特数是有限的<br />
</li>
<li>若给出码元的信号数，最高信息传输速率受两个公式的共同限制</li>
</ol>
<h2 id="编码与调制">编码与调制</h2>
<p>把数据变换为模拟信号的过程称为调制，把数据变换为数字信号的过程称为编码</p>
<ol type="1">
<li>数字信号编码成数字信号<br />
<img src="/assets/resources/Pasted%20image%2020240309111503.png" /></li>
</ol>
<ul>
<li>归零编码RZ：高电平表1，低表0，每个时钟周期的中间跳到低电平，接收方根据该跳变调整时钟基准(影响速率)<br />
</li>
<li>非归零编码NRZ:不用归零，但难以同步，需要双方有时钟线<br />
</li>
<li>反向非归零编码NRZI:信号翻转表示0，信号不变表示1，既能传输时钟信号，又能尽量不损失系统带宽，用于USB2.0<br />
</li>
<li>曼彻斯特编码，将一个码元分成两个相等的间隔，前一个间隔为高电平而后一个间隔为低电平表示码元1 ; 码元0的表示方法则正好相反，跳变同时作为数据和同步信号，占用宽度是原始基带宽带两倍,用于以太网<br />
</li>
<li>差分曼彻斯特编码: 码元为1，则前半个码元的电平与上一码元的后半个码元的电平相同；若码元为0 , 则情形相反,每个码元的中间都有一次电平的跳转，可以实现自同步,多用于局域网<br />
</li>
<li>4B/5B编码:将欲发送数据流的每4位作为一组，然后按照4B/5B编码规则将其转换成相应的5位码。5位码共32种组合，但只采用其中的16种对应16种不同的4位，其他16种作为控制码(帧的开始和结束、线路的状态信息等)或保留</li>
</ul>
<ol start="2" type="1">
<li>数字信号调制成模拟信号
<ol type="1">
<li>幅移键控(ASK):通过改变载波信号的振幅来表示数字信号1和0,容易实现，抗干扰能力差<br />
</li>
<li>频移键控(FSK):通过改变载波信号的频率来表示数字信号1和0,而载波的振幅和相位都不改变。容易实现，抗干扰能力强，目前应用较为广泛<br />
</li>
<li>相移键控 (PSK)。通过改变载波信号的相位来表示数字信号1和0,而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。<br />
</li>
<li>正交振幅调制(QAM):在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。设波特率为B, 采用m个相位，每个相位有n种振幅，则 该 QAM技术的数据传输速率R为 <span class="math inline">\(R=B\log_2{(mn)}\)</span></li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240309112504.png" /></p>
<ol start="3" type="1">
<li><p>模拟信号编码成数字信号<br />
在通信领域，带宽是指信号最高频率与最低频率之差，单位为Hz<br />
采样是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。<br />
根据采样定理，当采样的频率大于或等于模拟数据的频带带宽(最高变化频率)的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据<br />
量化是把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。<br />
典型的例子就是对音频信号进行编码的脉码调制(PCM)</p></li>
<li><p>模拟信号调制成模拟信号<br />
可以使用频分复用技术，电话机和本地局交换机采用模拟信号传输模拟数据的编码方式，模拟的声音数据是加载到模拟的载波信号中传输的</p></li>
</ol>
<h2 id="交换方式">交换方式</h2>
<h3 id="电路交换">电路交换</h3>
<p>传输前，两个结点间先建立一条专用的物理路径(可能有多个结点)，在数据传输期间必须一直独占<br />
优点：</p>
<ul>
<li>时延小<br />
</li>
<li>数据有序<br />
</li>
<li>无冲突，不会争用物理信道<br />
</li>
<li>适用于模拟与数字信号<br />
</li>
<li>可以实时通信，没有存储转发的耗时<br />
</li>
<li>控制简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>建立连接时间长<br />
</li>
<li>效率低，一个信道只能双方使用<br />
</li>
<li>灵活性差，可靠性低<br />
</li>
<li>难以规格化，双方可能规格完全不同</li>
</ul>
<h3 id="报文交换">报文交换</h3>
<p>数据交换的单位是报文，报文携带有目标地址、源地址等信息。报文交换在交换结点采用的是存储转发的传输方式</p>
<p>优点：</p>
<ul>
<li>无须建立连接<br />
</li>
<li>动态分配线路<br />
</li>
<li>可靠性强，有多条备选线路<br />
</li>
<li>提高线路利用率<br />
</li>
<li>提供多目标服务</li>
</ul>
<p>缺点：</p>
<ul>
<li>存储转发会产生各种时延<br />
</li>
<li>不限制报文大小</li>
</ul>
<h3 id="分组交换">分组交换</h3>
<p>限制每次传输数据块大小的上限，加上控制信息，构成分组</p>
<p>优点：</p>
<ul>
<li>在报文的基础上，简化存储管理(可以固定缓冲区大小)；分组可以并行传输<br />
</li>
<li>减少出错概率与重发数据量，且时延更短</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要额外的控制信息<br />
</li>
<li>采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时 ，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240309133716.png" /></p>
<h4 id="数据报">数据报</h4>
<p>分组交换根据其通信子网向端点系统提供的服务，还可进一步分为面向连接的虚电路方式和无连接的数据报方式。这两种服务方式都由网络层提供<br />
作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据报分组(即网络层的PDU)中间结点存储分组，找到最佳的路由后，尽快转发每个分组<br />
过程 ：</p>
<ol type="1">
<li>主机A将分组逐个发往交换结点，结点存储分组<br />
</li>
<li>结点查找转发表，为每个分组选择下个结点<br />
</li>
<li>重复2.直到到达终点</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240309133856.png" /><br />
数据报服务无需连接，不保证可靠也不保证有序；每个分组都有发送接收端完整地址，可以独立传输；交换结点不约束时延，也可能丢弃分组；</p>
<h4 id="虚电路">虚电路</h4>
<p>将数据报方式与电路交换方式结合起来，在分组发送之前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。<br />
端系统建立虚电路时，分配一个唯一的虚电路号，传输时分组需要加上虚电路号，每个结点也需要为何应该虚电路表(包括接收和发送链路的虚电路号，前后结点)<br />
建立时，主机A发送呼叫请求分组，若B同意连接，则发送呼叫应答分组；建立后，可以双向发送数据，最后主机A可以用释放请求分组来释放虚电路，逐段断开连接</p>
<ul>
<li>建立拆除虚电路有时间开销<br />
</li>
<li>建立连接时选择并确定一个路由<br />
</li>
<li>通信可靠且有序<br />
</li>
<li>某个结点故障会导致整个虚电路故障<br />
</li>
<li>分组不需要包含地址，只要虚电路标识符，开销更小<br />
虚电路是逻辑概念，每条虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务,其实际路由可以不同<br />
<img src="/assets/resources/Pasted%20image%2020240309135408.png" /><br />
<img src="/assets/resources/Pasted%20image%2020240309134420.png" /></li>
</ul>
<div class="note warning"><ul>
<li>TDM方式复用需要相同频率的信号<br />
</li>
<li>分组交换中，要将传送的长报文分割为多个固定有限长度的分组，因此传输时延较报文交换要小<br />
</li>
<li>在出错率很高的传输系统，数据报更合适<br />
</li>
<li>虚电路可以是永久的</li>
</ul>
</div>
<h2 id="传输介质">传输介质</h2>
<h3 id="双绞线">双绞线</h3>
<p>双绞线是最常用的古老传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。绞合可以减少对相邻导线的电磁干扰<br />
一定长度内，圈数越多的双绞线传输速率越快,带宽也取决于铜线的粗细和传输的距离<br />
双绞线的外面加上一层金属丝编织成的屏蔽层且内部加上接地线构成屏蔽双绞线(STP)，否则是非屏蔽双绞线(UTP)<br />
距离太远时，对于模拟传输，要用放大器放大衰减的信号；对于数字传输，要用中继器将失真的信号整形</p>
<h3 id="同轴电缆">同轴电缆</h3>
<p>50Ω同轴电缆主要用于传送基带数字信号，又称基带同轴电缆，它在局域网中应用广泛；75Ω同轴电缆主要用于传送宽带信号，又称宽带同轴电缆，主要用于有线电视系统<br />
有内导体，绝缘层和塑料壳构成，有良好抗干扰特性，相比双绞线同轴电缆具有更高的屏蔽性，同时有更好的抗噪声性，传输距离更远且更贵</p>
<h3 id="光纤">光纤</h3>
<p>利用光导纤维(简称光纤)传递光脉冲来进行通信。有光脉冲表示1, 无光脉冲表示0 。<br />
频率高，速率快，光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，只要入射角大于某个临界角度，就会出现全反射，即光线碰到包层时就会折射回纤芯<br />
利用光的全反射特性，可以将从不同角度入射的多条光线在一根光纤中传输，这种光纤称为多模光纤,有一定失真问题，只适用于短距离<br />
光纤的直径减小到只有一个光的波长时，光纤就像一根波导那样，可使光线一直向前传播，而不会产生多次反射，即单模光纤，适合远距离传输<br />
特点：传输损耗少，适合远距离，抗电磁干扰，保密性好，体积小</p>
<h3 id="无线介质">无线介质</h3>
<ol type="1">
<li>无线电波，如SLAN等，向所有方向散射，简化连接<br />
</li>
<li>微波，红外线，激光，有方向性，其中微波通信的频率较高，频段范围也很宽,但直线传播需要中转站;三颗120度的卫星基本可以实现全球通信，容量大距离远，但保密性差</li>
</ol>
<p>物理层考虑的是如何在连接到各种计算机的传输媒体上传输数据比特流，而不指具体的传输媒体。网络中的硬件设备和传输介质的种类繁多，通信方式也各不相同。物理层应尽可能屏蔽这些差异，让数据链路层感觉不到这些差异，使数据链路层只需考虑如何完成本层的协议和服务<br />
包括机械，电气，功能，过程特性。<br />
常用的物理层接口标准有EIARS-232-C、ADSL和 SONET/SDH等</p>
<h2 id="物理层设备">物理层设备</h2>
<h3 id="中继器">中继器</h3>
<p>将信号整形并放大再转发出去，进而扩大网络传输的距离<br />
中继器有两个端口，数据从一个端口输入，再从另一个端口发出。端口仅作用于信号的电气部分，而不管是否有错误数据或不适于网段的数据<br />
使用中继器连接的几个网段仍然是一个局域网。中继器若出现故障，对相邻两个网段的工作都将产生影响。中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。</p>
<div class="note info"><p>如果某个网络设备具有存储转发的功能，那么可以认为它能连接两个不同的协议；如果该网络设备没有存储转发功能，那么认为它不能连接两个不同的协议,例如中继器<br />
放大器和中继器都起放大作用，只不过放大器放大的是模拟信号，原理是将衰减的信号放大，而中继器整形数字信号，原理是将衰减的信号整形再生。</p>
</div>
<p>网络标准中对信号的延迟范围做了具体的规定，中继器只能在此规定范围内进行有效的工作 ，否则会引起网络故障。</p>
<h3 id="集线器">集线器</h3>
<p>集线器(Hub)实质上是一个多端口的中继器。一个端口接收到数据信号后，hub将其整型放大，转发到其他所有工作端口，没有定向传送功能，是共享设备<br />
Hub主要使用双绞线组建共享网络，在交换式网络中，Hub直接与交换机相连,将交换机端口的数据送到桌面上，由Hub组成的网络是共享式网络,有一个中心结点管理所有相连工作站，但逻辑上仍是一个总线网。<br />
Hub的每个端口连接的网络部分是同一个网络的不同网段，同时Hub也只能在半双工状态下工作，网络的吞吐率因而受到限制<br />
集线器在一个时钟周期中只能传输一组信息,其连接的n个设备，每个的带宽是集线器的1/n</p>
<div class="note info"><p>可以不经过调制就在信道上直接进行的传输方式称为基带传输。它通常用于局域网,最简单的方法是用两个高低电平来表示二进制数字<br />
用数字信号对特定频率的载波进行调制(数字调制)，将其变成适合于传送的信号后再进行传输 ，这种传输方式就是频带传输<br />
借助频带传输，可将链路容量分解成两个或多个信道，每个信道可以携带不同的信号，这就是宽带传输。宽带传输中所有的信道能同时互不干扰地发送信号<br />
中继器或集线器有"543规则”，其中"5"表示5个网段，"4”表示4个中继器或集线器,"3"表示3个网段为主机段。也就是说，在一个由中继器或集线器互连的网络中，任意发送方和接收方最多只能经过4个中继器、5个网段。</p>
</div>
<hr />
<h1 id="数据链路层">数据链路层</h1>
<p>将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</p>
<h2 id="功能-1">功能</h2>
<p><strong>对网络层提供的服务</strong>：</p>
<ul>
<li>无确认无连接服务(发送数据帧不需要建立连接，收到后也无需确认，丢失不负责重发，适用实时通信)<br />
</li>
<li>有确认的无连接服务，原机器一定时间没收到确认信号就重传，适用无线通信等误码率较高信道<br />
</li>
<li>有确认的面向连接服务，每一帧收到后都要确认，收到确认才发送下一帧</li>
</ul>
<p><strong>链路管理</strong>：数据链路层连接的建立、维持和释放过程<br />
链路两端的结点要进行通信，必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号初始化，然后才能建立连接，在传输过程中则要能维持连接，而在传输完毕后要释放该连接。<br />
在多个站点共享同一物理信道的情况下(如在局域网中)如何在要求通信的站点间分配和管理信道也属于数据链路层管理的范畴<br />
<strong>帧</strong><br />
两台主机之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。将一段数据的前后分别添加首部和尾部，就构成了帧。<br />
首尾有很多控制信息，且为帧定界，帧同步指接收方可以从接收到的比特流中区分帧的首尾，如图的HDLC协议，此外，每个数据链路层协议都规定帧的长度上限(最大传送单元MTU)<br />
<img src="/assets/resources/Pasted%20image%2020240309151715.png" /><br />
如果数据中有相同的定界符组合，就需要专门处理<br />
<strong>流量控制</strong><br />
限制发送方的数据流量，使其发送速率不超过接收方的接收能力。很多层提供类似功能，对于数据链路层来说，控制的是相邻两结点之间数据链路上的流量<br />
在OSI体系结构中，数据链路层具有流量控制的功能。而在 TCP/IP体系结构中，流量控制功能被移到了传输层。<br />
<img src="/assets/resources/Pasted%20image%2020240309154704.png" /></p>
<p><strong>差错控制</strong><br />
位错：部分位出错，常采用循环冗余校验(CRC)方式发现位错，通过自动重传请求(Automatic Repeat reQuest. ARQ)方式来重传出错的帧:发送方将数据帧附加一定CRC冗余验错码，发现错误则丢弃<br />
帧错：帧的丢失，失序等错误，在数据链路层引入定时器和编号机制，能保证每一帧最终都能有且仅有一次正确地交付给目的结点<br />
<strong>透明传输</strong>：<br />
对链路层来说，没有无法传输的特定比特序列，也就是对控制用的序列需要进行一定处理</p>
<h2 id="组帧">组帧</h2>
<p>为了使接收方能正确地接收并检查所传输的帧，发送方必须依据一定的规则把网络层递交的分组封装成帧(称为组帧)<br />
帧是传输的最小单位，因此需要首尾定界，而分组是数据分布，不需要尾部</p>
<ol type="1">
<li>字符计数法:在帧头部用一个计数字段表示其字符数，问题是对计数字段依赖性过强<br />
</li>
<li>字符填充的首尾定界符法:用特定字符来定界一帧的开始与结束，可在数据部分特殊字符前面填充一个转义字符(ESC)来加以区分且转义字符自己也可以被转义，收到后取出转义字符得到原始数据<br />
</li>
<li>零比特填充的首尾标志法:使用一个特定的比特模式，即01111110来标志一帧的开始和结束,为了避免误判，发送方在数据的5个1后添加一个0，接收方则将其逆操作，容易硬件实现，性能更好<br />
</li>
<li>违规编码法，将编码方法的违规方法作为定界符号，只适用于采用冗余编码的特殊编码环境<br />
由于字符计数法中计数字段的脆弱性和字符填充法实现上的复杂性与不兼容性，目前较常用的组帧方法是零比特填充法和违规编码法</li>
</ol>
<h2 id="差错控制">差错控制</h2>
<p>线路本身会产生随机噪声，可以通过加大信噪比解决；传输过程中，外界因素可能引起冲击噪声，可以通过编码技术解决<br />
主要有两类：自动重传请求ARQ和前向纠错FEC</p>
<ul>
<li>在 ARQ 方式中，接收端检测到差错时，就设法通知发送端重发，直到接收到正确的码字为止。<br />
</li>
<li>在 FEC 方式中，接收端不但能发现差错，而且能确定比特串的错误位置，从而加以纠正<br />
因此，差错控制又可分为检错编码和纠错编码</li>
</ul>
<h3 id="检错编码">检错编码</h3>
<ol type="1">
<li>奇偶校验码：由n-1位信息元和1位校验元组成，如果是奇校验码，那么在附加一个校验元后，码长为n的码字中1的个数为奇数，相当于检验帧所有位的异或值(奇偶性),对奇校验来说只能检验处奇数个错误(改变了奇偶性),成功率50%<br />
</li>
<li>循环冗余码(多项式码)，对m bit的帧，生成一个r bit的帧校验序列FCS，双方约定一个多项式G(x)，其位数为k bit,其阶数r=k-1 且其最高最低位为1，带校验码的帧可以被G(x)整除，可整除则无差错;有纠错功能，但该层不使用，检错过程由硬件实现
<ol type="1">
<li>加0，若G(x)阶r,帧低位加r个0<br />
</li>
<li>模2除法，G(x)对应数据串除1.中计算出的数据串，其余数位冗余码(r位，不可省略0)<br />
</li>
<li>模2运算规则，加法不进位，减法不借位，相当于对应位进行逻辑异或运算</li>
</ol></li>
</ol>
<h3 id="纠错编码">纠错编码</h3>
<p><strong>海明码</strong>:设信息位D4D3D2D1(1010),共4位,需要3位校验码<br />
两个合法编码(码字的对应比特取值不同的比特数称为这两个码字的海明距离(码距))，一个有效编码集中任意两个合法编码(码学的海明距离的最小值称为该编码集的海明距离(码距))。"纠错”d位，需要码距为2d+1的编码方案；"检错”d位，则只需码距为d+1</p>
  
  
$$\begin{array}{l l l l l l l}{{H_{7}}}&{{H_{6}}}&{{H_{5}}}&{{H_{4}}}&{{H_{3}}}&{{H_{2}}}&{{H_{1}}}\\ {{D_{4}}}&{{D_{3}}}&{{D_{2}}}&{{P_{3}}}&{{D_{1}}}&{{P_{2}}}&{{P_{1}}}\end{array}$$  
  

<ol type="1">
<li>确定位数，n为信息位数，k为校验位数，则需要 <span class="math inline">\(n+k&lt;=2^k-1\)</span> 检查一位错(两位需要k+1)<br />
</li>
<li>确定校验位的分布，校验位 <span class="math inline">\(P_i\)</span> 在海明位号 <span class="math inline">\(2^{i-1}\)</span><br />
</li>
<li>分组形成校验关系，被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和，如D1放在H3上，由P1P2校验<br />
</li>
<li>校验位取值，Pi的值是第i组由该校验位校验的数据位所有位的异或</li>
</ol>
  
$$\begin{array}{l}{{P_{1}=D_{1}\oplus D_{2}\oplus D_{4}=0\oplus1\oplus1=0}}\\ {{P_{2}=D_{1}\oplus D_{3}\oplus D_{4}=0\oplus0\oplus1=1}}\\ {{P_{3}=D_{2}\oplus D_{3}\oplus D_{4}=1\oplus0\oplus1=0}}\end{array}$$  

<p>1010对应的海明码为101<strong>0</strong>0<strong>10</strong></p>
<ol start="5" type="1">
<li>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成上个校验方程</li>
</ol>
  
$$\begin{array}{l}{{S_{1}=P_{1}\oplus D_{1}\oplus D_{2}\oplus D_{4}}}\\ {{S_{2}=P_{2}\oplus D_{1}\oplus D_{3}\oplus D_{4}}}\\ {{S_{3}=P_{3}\oplus D_{2}\oplus D_{3}\oplus D_{4}}}\end{array}$$  

<p>若S3S2S1的值为"000"，则说明无错；否则说明出错，且这个数就是错误位的位号，如 S3S2S1 = 001,说明第1位出错，将该位取反<br />
<img src="/assets/resources/Pasted%20image%2020240317101511.png" /></p>
<h2 id="流量控制和可靠传输机制">流量控制和可靠传输机制</h2>
<p>为了避免缓冲区溢出，需要接收方控制发送方速率</p>
<ol type="1">
<li>停止等待协议:发送方发出一帧后需要等待接收方应答，才可以继续发送，效率较低<br />
停止-等待协议相当于发送窗口和接收窗口大小均为1的滑动窗口协议<br />
差错：</li>
</ol>
<ul>
<li>数据帧丢失<br />
</li>
<li>帧被破坏，检测出差错后，丢弃帧，发出方超时后重传<br />
</li>
<li>数据帧正确，但确认帧破坏，接收方会连续收到相同序号数据帧，前后发送多次确认帧。<br />
发送方和接收方都须设置一个帧缓冲区。发送端在发送完数据帧时，必须在其发送缓存中保留此数据帧的副本，这样才能在出差错时进行重传。只有在收到对方发来的确认帧ACK时，方可清除此副本。<br />
<img src="/assets/resources/Pasted%20image%2020240317112506.png" /></li>
</ul>
<ol start="2" type="1">
<li><p>滑动窗口控制<br />
发送方一直维持一组连续的允许发送的帧的序号，即发送窗口，接收方维持一组连续的允许接收帧的序号，即接收窗口<br />
发送窗口大小 <span class="math inline">\(W_r\)</span> 代表未收到应答时，还可以发送多少数据帧，接收窗口控制是否接收帧，只有落在窗口内的帧，才算接收<br />
发送方收到确认后，就滑动一个帧，没有可以发的帧时(没有已发送的被确认)，就会停止发送，直到收到接收方的确认帧使窗口移动<br />
接收方收到后，将窗口前移一个位置，发回确认帧，若落不到窗口则丢弃<br />
注意：传输过程中窗口大小固定<br />
<img src="/assets/resources/Pasted%20image%2020240317103705.png" /></p></li>
<li><p>可靠传输机制</p></li>
</ol>
<ul>
<li>确认：无数据的控制帧，可以伴随回复帧中发出(捎带确认)<br />
</li>
<li>超时重传：发送方发出后启动计时器，超时则重发数据帧<br />
</li>
<li>自动重传请求(ARQ)：接收方请求发送方重传出错的帧，一般分为停止-等待,后退N帧(发送窗口&gt;1,接收窗口=1),选择性重传(两种窗口都大于1)</li>
</ul>
<p>数据链路层中可靠传输与流量控制是合一的</p>
<p><strong>后退N帧GBN</strong>: 发送方可以连续发送，但接收方顺序接收，出错后要求重发最后一个正确的帧后的帧；发送方的某帧超时后，从该帧开始重发。<br />
接受方可以发送一个确认帧可以确认该帧前的所有帧，避免频繁确认的开销,也可以发送数据时捎带确认之前收到的帧(累积确认)<br />
图中,ATKn表示对第n帧的确认<br />
如果用n bit编号帧，发送窗口大小需要 <span class="math inline">\(&lt;=2^n-1\)</span></p>
<p><img src="/assets/resources/Pasted%20image%2020240317113936.png" /></p>
<p><strong>多帧滑动窗口与选择重传协议SR</strong><br />
加大接收窗口，先收下发送序号不连续但仍处在接收窗口中的数据帧，等收到缺失部分的数据帧再一并提交<br />
选择重传协议的窗口大小通常满足 <span class="math inline">\(W_{Tmax}=W_{Rmax}=2^{n-1}\)</span>否则，窗口大小大于序号范围一半，丢失部分确认帧时，接收方无法分辨新的数据帧和重传数据帧<br />
即新收到的帧编号为真实编号对 <span class="math inline">\(2^n\)</span> 的模，与之前的冲突</p>
<p><img src="/assets/resources/Pasted%20image%2020240317133425.png" /><br />
可以避免重复传一些正确到达的帧，但需要缓冲区的开销，接收端接收窗口范围内的帧，因此缓冲区大小只需要等于窗口大小</p>
<div class="note info"><p>信道效率(信道利用率)：有多种定义，例如发送方在一个发送周期内，有效发送数据的时间占整个发送周期的比率<br />
信道吞吐量= <span class="math inline">\({信道效率}\times{发送方发送速率}\)</span></p>
</div>
<div class="note warning"><ul>
<li>在后退N帧的协议中，序列号个数不小于MAX_SEQ+1<br />
</li>
<li>对于回退N帧协议，发送窗口的大小可以等于窗口总数-1, 因为它的接收窗口大小为1,所有的帧保证按序接收。因此对于窗口大小为n的滑动窗口，其发送窗口大小最大为n-1,即最多可以有n-1帧已发送但没有确认<br />
</li>
<li>后退N帧的最大传输速率=min{<code>信道带宽，窗口大小*帧大小/发送第一个帧到接收到它的确认的时间</code>}</li>
</ul>
</div>
<h2 id="介质访问控制">介质访问控制</h2>
<h3 id="信道介质">信道介质</h3>
<p>为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制(MAC)子层<br />
需要通过多路复用(不同信号在同一条物理信道传输)将N个输入通道整合到复用通过，再输出端再分成N路<br />
<img src="/assets/resources/Pasted%20image%2020240317134543.png" /></p>
<ol type="1">
<li>频分复用FDM，将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号，子信道综合带宽不超过总信道，并且需要直接的保护频带避免干扰<br />
</li>
<li>时分复用TDM，分成若干时间片，多路信号各自占据时间片；
<ol type="1">
<li>统计/异步时分多路复用(STDM),STDM帧按需动态分配时间片<br />
</li>
</ol></li>
<li>波分复用WDM，用于光纤，波长(频率)不同的光可以互不干扰的传输<br />
</li>
<li>码分复用CDM，用不同编码区分信号种类，即码分多址,主要用于无线通信<br />
其原理是每个比特时间再划分成加个短的时间槽，称为码片,通常加的值是64或128。每个站点被指派一个唯一的m位码片序列。<br />
发送1时，站点发送它的码片序列；发送0时，站点发送该码片序列的反码。当两个或多个站点同时发送时，各路数据在信道中线性相加。为从信道中分离出各路信号，要求各个站点的码片序列相互正交,即码片向量的规格化内积为0<br />
令向量S表示A站的码片向量，令T表示B站的码片向量<br />
<span class="math inline">\(S.T\equiv{\frac{1}{m}}\sum_{i=1}^{n}S_{i}T_{i}=0\)</span><br />
任何一个码片向量和该码片向量自身的规格化内积都是1，任何一个码片向量和该码片反码的向量的规格化内积是-1<br />
两个向量到了公共信道上线性相加,到达C站后，进行数据分离，如果要得到来自A站的数据，C站就必须知道A站的码片序列，让S与S+T进行规格化内积,其他站点的信号都在内积的结果中被过滤掉了，内积的相关项都是0 , 而只剩下A站发送的信号</li>
</ol>
<h3 id="随机访问介质">随机访问介质</h3>
<p>用户随机发送信息，占用整个信道，多个用户同时发送时，产生碰撞，常用的协议有ALOHA协议、CSMA协议、CSMA/CD协议和CSMA/CA协议,称为争用型协议，需要争抢获得信道 ，但不需要共享空间或者时间，对双方来说是一种点对点信道</p>
<ol type="1">
<li><p>ALOHA协议,任何一个站点发送数据时，可以不检测发送，但需要确认和定时重发,发送方接受不到确认则需要等待随机时间重发<br />
<img src="/assets/resources/Pasted%20image%2020240317141134.png" /><br />
如果碰撞，各方都随机等待一段时间，再重传，重复到成功,吞吐量较低</p></li>
<li><p>时隙ALOHA协议,各站同步时间，分为等长时隙(slot)，只有<strong>每个时隙开始时</strong>可以发送帧，每个帧在到达后，一般都要在缓存中等待一段小于时隙长度的时间，然后才能发送出去。在一个时隙内有两个或两个以上的帧到达时，在下一个时隙将产生碰撞,碰撞后依旧随机等待，吞吐量是原版本2倍<br />
</p></li>
<li><p>载波监听多路访问CSMA协议,发送前通过载波监听装载监听共用信道</p>
<ol type="1">
<li>1-persistent CSMA:发送数据前监听信道，忙则监听到空闲再发送，如果冲突，随机等待一定时间再开始监听
<ol type="1">
<li>传播延迟会产生影响，如某结点开始发送数据，其信号在延迟中，另一节点检查到信道空闲，也发出，导致冲突<br />
</li>
<li>多个结点同时监听，空闲时同时发出也会冲突<br />
</li>
</ol></li>
<li>Non-persistent CSMA:与1.不同的是，首次监听时若信道忙，放弃监听等待随机时间再重复，增加延迟时间，但提高了信道利用率(减少上述1.2.问题)<br />
</li>
<li>p-persistent CSMA:用于时分信道，信道忙，则到下个时隙监听，若信道空闲以概率p发送数据，1-p推迟到下一个时隙，重复整个过程，如果信道忙，则等待一个时隙再监听，是前两者的折中方案<br />
</li>
</ol></li>
<li><p>载波监听多路访问/碰撞检测(CSMA/CD)协议是CSMA协议的改进方案，适用于总线形网络或半双工网络环境(全双工不会冲突):先听后发，边听边发，冲突停发，随机重发<br />
Carrier Sense Multiple Access with Collision Detection(载波监听指“边发送边监听”)<br />
<img src="/assets/resources/Pasted%20image%2020240317144040.png" /><br />
载波监听:每个站点在发送前和发送中都必须不停地检测信道，在发送前检测信道获得发送权，在发送中检测信道从而及时发现发送的数据是否发生了碰撞。 站点要发送数据前先监听信道，只有信道空闲才能发送<br />
碰撞检测:边发送边监听，如果监听到了碰撞,则立即停止数据发送，等待一段随机时间后，重新开始尝试发送数据<br />
<img src="/assets/resources/Pasted%20image%2020240317145509.png" /><br />
τ为单程传播时延，端点发送帧后最多2τ时间，两端就都就知道帧有没有碰撞，2τ称为<strong>争用期</strong>，经过争用期未检测到碰撞时，才能确定这次发送没有碰撞<br />
过于小的帧发送完也无法检测到碰撞，因此以太网规定了一个最短帧长(争用期内可发送的数据长度)。在争用期内如果检测到碰撞，站点就会停止发送，此时已发送出去的数据一定小于最短帧长，长度小于这个最短帧长的帧都视为由于冲突而异常中止的无效帧<br />
<span class="math inline">\(最小帧长=总线传播时延\times数据传输速率\times2\)</span><br />
归根到底，争用期长度的规定由物理线路的物理特性(长度除电信号传输速率)等决定<br />
对10Mb/s的以太网，则最小是64B。发送更小的需要填充,还规定了帧间最小间隔为9.6μs<br />
<img src="/assets/resources/Pasted%20image%2020240514214647.png" /><br />
要提高以太网的信道利用率，就必须减小以太网单程端到端时延和帧的发送时间之比</p></li>
</ol>
<p>通过阶段二进制指数退避算法解决碰撞问题：</p>
<ol type="1">
<li>确定基本退避时间，如争用期长度2τ</li>
<li>定义k，相当于min{重传次数,10}</li>
<li>自然数0~ <span class="math inline">\(2^k-1\)</span> 中随机取数r，退避时间即2rτ</li>
<li>重传16次也失败时，抛弃帧且向高层报错</li>
</ol>
<p>算法执行顺序：</p>
<ol type="1">
<li>准备发送：适配器从网络层获得一个分组，封装成帧，放入适配器的缓存。<br />
</li>
<li>检测信道：若检测到信道空闲，开始发送这个帧。若检测到信道忙，就持续检测直至信道上没有信号，然后开始发送这个帧。<br />
</li>
<li>在发送过程中，适配器仍持续检测信道。这里只有两种可能：
<ul>
<li>发送成功：在争用期内一直未检测到碰撞<br />
</li>
<li>发送失败：在争用期内检测到碰撞，此时立即停止发送，适配器执行指数退避算法，等待一段随机时间后返回到步骤2. 若重传16次仍不能成功，则停止重传并向上报错。</li>
</ul></li>
</ol>
<p><strong>CSMA/CA协议</strong>:<br />
在无线网中，接收信号强度往往远小于发送信号强度，且强度变化大，难以实现碰撞检测；且存在隐蔽站<br />
为此,CA(collision avoidance)协议将碰撞检测改为碰撞避免,尽可能降低碰撞概率,使用确认重传方案，确认后才能发送下一帧<br />
802.11规定，所有站发送后，等待一段很短时间，才能继续发送，这段时间是帧间间隔IFS，其长度取决于帧的类型：</p>
<ul>
<li>SIFS，最短的IFS，分割一次对话的各帧,使用SIFS的帧类型有ACK帧、CTS帧、分片后的数据帧，以及所有回答AP探询的帧等<br />
</li>
<li>PIFS点协调IFS，中等长度，用于PCF<br />
</li>
<li>DIFS分布式协调IFS，最长的IFS，用于异步帧竞争访问的时延</li>
</ul>
<p>退避算法：<br />
信道从忙态变为空闲态时,任何一个站要发送数据帧，不仅都要等待一个时间间隔，而且要进入争用窗口，计算随机退避时间以便再次试图接入信道，因此降低了碰撞发生的概率。<br />
当且仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时，才不使用退避算法。其他所有情况都必须使用退避算法，具体为：①在发送第一个帧前检测到信道忙；②每次重传；③每次成功发送后要发送下一帧。</p>
<ol type="1">
<li>若站点最初有数据发送(非重传)，且信道空闲，等待DIFS后，发送<br />
</li>
<li>否则，执行退避算法，选择随机回退值，即设置一个退避计时器，从信道空闲时开始倒计时<br />
</li>
<li>计时器到0时，发送帧并等待确认<br />
</li>
<li>发送站若收到确认，则发送的帧被接受，如果仍需要发送从2.开始<br />
若发送站在规定时间(由重传计时器控制)内没有收到确认帧ACK ,就必须重传该帧，再次使用CSMA/CA协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送</li>
</ol>
<p>隐蔽站问题：站A和B都在AP的覆盖范围内，但A和B相距较远，彼此都听不见对方。当A和B检测到信道空闲时，都向AP发送数据，导致碰撞的发生。<br />
802.11允许发送站对信道进行预约。源站要发送数据帧之前先广播一个很短的请求发送RTS(Request To Send)控制帧，它包括源地址、目的地址和这次通信(含相应的确认帧)所持续的时间，该帧能被其范围内包括AP在内的所有站点听到。<br />
若信道空闲，则AP广播一个允许发送CTS(Clear To Send)控制帧，它包括这次通信所需的持续时间(从RTS帧复制)，该帧也能被其范围内包括A和B在内的所有站点听到。<br />
B和其他站听到CTS后，在CTS帧中指明的时间内将抑制发送。CTS帧有两个目的：①给源站明确的发送许可；②指示其他站点在预约期内不要发送。<br />
RTS与CTS有一定开销<br />
<img src="/assets/resources/Pasted%20image%2020240317161023.png" /></p>
<p>CSMA/CD与 CSMA/CA主要有如下区别：</p>
<ol type="1">
<li>CSMA/CD可以检测冲突，但无法避免；CSMA/CA发送数据的同时不能检测信道上有无冲突，本结点处没有冲突并不意味着在接收结点处就没有冲突，只能尽量避免。<br />
</li>
<li>传输介质不同。CSMA/CD用于总线形以太网，CSMA/CA用于无线局域网802.11 a/b/g/n等。<br />
</li>
<li>检测方式不同。CSMA/CD通过电缆中的电压变化来检测；而 CSMA/CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式。<br />
</li>
<li>CD发送前监听，边发送边监听，一旦碰撞就停止发送;CA发送前广播其他结点，让其避免冲突</li>
</ol>
<h3 id="轮询访问令牌传递协议">轮询访问：令牌传递协议</h3>
<p>轮询访问中，用户不能随机地发送信息，而要通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配。当某结点使用信道时，其他结点都不能使用信道<br />
该通路是逻辑上的环，与物理结构无关<br />
典型的轮询访问介质访问控制协议是令牌传递协议，它主要用在令牌环局域网中, 令牌(Token)沿着环形总线在各结点计算机间依次传递,令牌是控制帧，用于控制信道使用。不含信息<br />
一个站点希望传送帧时，必须等待令牌。一旦收到令牌，站点便可启动发送帧，发送完一帧后，释放令牌<br />
令牌在网环上是按顺序依次传递的，因此对所有入网计算机而言，访问权是公平的</p>
<p>流转过程:</p>
<ol type="1">
<li>网络空闲时，只有令牌循环传递<br />
</li>
<li>传到需要发送的站点时，修改令牌标志位，在其中添加数据，使其变成数据帧发出<br />
</li>
<li>数据帧沿着环路转发，沿途站点查看目的地址，如果是自己则复制该帧作为接收<br />
</li>
<li>数据帧传回源站点，停止转发，同时校验该帧查看是否出错，错则重传<br />
</li>
<li>源站重新产生一个令牌，传给下一站，交出信道控制权</li>
</ol>
<p>适合负载很高的广播信道,实际上是在随机介质访问控制的基础上,限定了有权力发送数据的结点只能有一个<br />
通过介质访问控制机制可以使广播信道逻辑上变为点对点的信道，逻辑上看，数据链路层都是点到点的通信</p>
<div class="note warning"><ul>
<li>FDM适合于传输模拟信号，TDM适合于传输数字信号<br />
</li>
<li>二进制回退算法中,在达到10次冲突后，随机数的区间固定在最大值1023<br />
</li>
<li>令牌环网各站轮流使用令牌发送数据，无论网络负载如何，都无冲突产生<br />
</li>
<li>令牌有持有时间上限，无法一直持有，即使在发送数据<br />
</li>
<li>减少的往返时延= 减少的发送时延<br />
</li>
<li>帧的传输时延至少要两倍于信号在总线中的传播时延<br />
</li>
<li>最终序列与对应站点的码分向量相乘，规格化内积为1表示1，为-1表示0<br />
</li>
<li>CSMA/CD信号传播延迟趋近0时，信道利用率趋近100</li>
</ul>
</div>
<h2 id="局域网">局域网</h2>
<p>指在一个较小的地理范围,计算机(逻辑上的)互连形成的网络。</p>
<ul>
<li>范围和站点数有限<br />
</li>
<li>所有站点共享较高的总带宽<br />
</li>
<li>时延和误码率较低<br />
</li>
<li>各站平等<br />
</li>
<li>可以广播或者组播</li>
</ul>
<p>主要特性：拓扑结构，传输介质，<strong>介质访问控制方式</strong><br />
局域网的介质访问控制方法主要有CSMA/CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网。</p>
<p>三种常见的局域网拓扑实现如下：</p>
<ol type="1">
<li>以太网(目前使用范围最广的局域网逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构)<br />
</li>
<li>令牌环(IEEE 802.5)逻辑拓扑是环形结构，物理拓扑是星形结构<br />
</li>
<li>FDDI(光纤分布数字接口，IEEE 802.8)。逻辑拓扑是环形结构，物理拓扑是双环结构</li>
</ol>
<p>将数据链路层拆分为两个子层：逻辑链路控制(LLC)子层和媒体接入控制(MAC)子层。<br />
IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，将数据链路层拆分为两个子层：逻辑链路控制(LLC)子层和媒体接入控制(MAC)子层。</p>
<ul>
<li>LLC:与传输媒体无关，为帧确认编号，向网络层提供无确认无连接，面向连接，带确认无连接，高速传送4种服务，逻辑上更上层<br />
</li>
<li>MAC:向上屏蔽对物理层的差异，提供对物理层的统一访问接口，包括：组帧拆卸帧，差错检测，透明传输功能</li>
</ul>
<p>以太网占据绝对主流，MAC远远比LLC更流行</p>
<h3 id="以太网802.3">以太网802.3</h3>
<p>IEEE802.3标准是一种基带总线形的局域网标准，它描述物理层和数据链路层的MAC子层的实现方法，与以太网严格定义不同，但通常将802.3局域网简称为以太网<br />
以太网逻辑上采用总线形拓扑结构，信息以广播方式发送,使用CSMA/CD方式对总线进行访问控制,是最为主流的局域网技术<br />
<img src="/assets/resources/Pasted%20image%2020240318191137.png" /><br />
每块网卡中的MAC地址也称物理地址；MAC地址长6字节,权威机构给厂家分配前 3 个字节，后三个字节厂家分配<br />
以太网MAC帧格式有两种标准：DIX Ethernet V2 标准(以太网V2标准)和IEEE 802.3标准<br />
组成：</p>
<ul>
<li>前导码:用于使接收端与发送端时钟同步，前7B用来快速同步MAC帧；最后1B是MAC帧<br />
</li>
<li>地址：48位<br />
</li>
<li>类型：2B,802.3帧格式与DIX 以太帧格式的不同之处在于用长度域替代了DIX帧中的类型域(0-1500可用作长度，更大值作为类型标识)<br />
</li>
<li>数据:46~1500B，包含协议信息，最小总长64B来源于争用期限制，可以被填充<br />
</li>
<li>校验码(FCS):从目的地址段到数据段的末尾，采用32位循环冗余码(CRC)</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240318195152.png" /><br />
<img src="/assets/resources/Pasted%20image%2020240318204042.png" /></p>
<p><img src="/assets/resources/Pasted%20image%2020240318194418.png" /></p>
<h3 id="无线局域网802.11">无线局域网802.11</h3>
<p>可分为两大类：有固定基础设施(通信基站)的无线局域网和无固定基础设施的移动自组织网络</p>
<ol type="1">
<li><p>有固定基础设施无线局域网：802.11使用星形拓扑，其中心称为接入点(Access Point, AP) , 在MAC层使用CSMA/CA协议。使用802.11系列协议的局域网又称Wi-Fi。<br />
无线局域网的最小构件是基本服务集BSS(Basic Service Set,BSS)一个基本服务集包括一个接入点和若干移动站。各站在本BSS内之间的通信，或与本BSS外部站的通信，都必须通过本BSS的AP。<br />
AP在安装时分配不超过32字节的服务集标识符(ServiceSetIDentifier，SSID)与一条信道<br />
一个基本服务集覆盖的地理范围称为一个基本服务区 (Basic Service Area, BSA),无线局域网的基本服务区的范围直径一般不超过100m<br />
基本服务集可以是孤立的，也可通过AP连接到一个分配系统(Distribution System, DS)构成了一个扩展的服务集(Extended Service Set, ESS)<br />
DS对上级屏蔽ESS与BSS的差异，ESS可以通过Portal (门户,一种设备)为无线用户提供到有线连接的以太网的接入<br />
<img src="/assets/resources/Pasted%20image%2020240318211621.png" /></p></li>
<li><p>无固定基础设施移动自组织网络<br />
由一些平等状态的移动站相互通信组成的临时网络,各结点之间地位平等，中间结点都为转发结点，因此都具有路由器的功能。有自己特定的路由选择协议，并且可以不和因特网相连</p></li>
</ol>
<h4 id="帧的组成与收发">帧的组成与收发</h4>
<p>分为数据，控制，管理帧<br />
数据帧由以下三大部分组成：</p>
<ol type="1">
<li>MAC首部，共30B<br />
</li>
<li>帧主体，帧的数据部分，不超过2312B<br />
</li>
<li>帧检验序列FCS:4B</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240319093036.png" /></p>
<ol type="1">
<li>BSS中的站A向站B发送数据帧,控制字段10,地址1是AP地址，地址2是A地址，地址3是B地址<br />
</li>
<li>AP接收到数据帧后，转发给站B,控制字段01，地址1是B地址，地址2是AP地址，地址3是A地址</li>
</ol>
<p>如果AP通过路由器(网络层，通过IP地址转发)相连，路由器向站A发送数据：</p>
<ol type="1">
<li>路由器从IP数据报获知A的IP地址，并使用ARP获取站A的MAC地址，路由器接口R1将其封装成802.3帧(源是RA1地址，目的是A地址)<br />
</li>
<li>AP收到802.3帧后，将其转换成802.11帧，控制字段01</li>
</ol>
<p>站A向路由器接口R1发送数据:</p>
<ol type="1">
<li>A生成802.11帧，控制字段10，<br />
</li>
<li>AP收到后转换成802.3帧，源地址字段是A的MAC地址，目的地址字段是R1的MAC地址</li>
</ol>
<h3 id="vlan虚拟局域网">VLAN虚拟局域网</h3>
<p>一个较大的局域网分割成一些较小的与地理位置无关的逻辑上的VLAN,而每个VLAN是一个较小的广播域<br />
VLAN建立在交换技术基础上，以软件方式实现逻辑分组与管理，VLAN中的计算机不受物理位置的限制。当计算机从一个VLAN转移到另一个VLAN时，只需简单地通过软件设定。同一个VLAN的计算机不一定连接在相同的物理网段，它们可以连接在相同的交换机上，也可以连接在不同的局域网交换机上，只要这些交换机互连即可<br />
802.3ac标准定义了VLAN的帧，在以太网帧中插入一个4B标识符，使以太网最大帧长变为1522B<br />
<img src="/assets/resources/Pasted%20image%2020240319102510.png" /><br />
VLAN标签的前两个字节置为0x8100,后两个字节中后12位是该VLAN的标识符VID,唯一标识改帧属于的VLAN<br />
VID字段的值由交换机管理员设定,对各主机透明，主机与交换机之间传输标准以太网帧<br />
可以通过交换机端口,IP地址，网卡地址划分VLAN<br />
<img src="/assets/resources/Pasted%20image%2020240319104437.png" /><br />
跨VLAN号的通信属于第三层服务，需要路由器或者有专用芯片的交换机</p>
<div class="note warning"><ul>
<li>以太网采用无连接的工作方式；不对发送的数据帧编号，也不要求接收方发送确认<br />
</li>
<li>只有当以太网工作于半双工方式下时，才需要CSMA/CD协议来应对冲突问题<br />
</li>
<li>通常情况下，网卡是用来实现以太网协议的,实现的功能主要在物理层和数据链路层<br />
</li>
<li>以太网上总线上的所有结点(包括发送结点)都能收到发送结点发送的数据信号</li>
</ul>
</div>
<h2 id="广域网">广域网</h2>
<p>广域网通常是指覆盖范围很广(远超一个城市的范围)的长距离网络。广域网是因特网的核心部分，其任务是长距离运送主机所发送的数据。<br />
<img src="/assets/resources/Pasted%20image%2020240318204229.png" /><br />
广域网由一些结点交换机(与路由器不同的是，它只在单个网络中存储转发分组)及连接这些交换机的链路组成，但为了提高网络的可靠性，通常一个结点交换机往往与多个结点交换机相连。<br />
<img src="/assets/resources/Pasted%20image%2020240318204418.png" /><br />
路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组通过转发表进行转发<br />
常见协议：</p>
<h3 id="ppp点对点协议">PPP点对点协议</h3>
<p>使用串行线路通信的面向字节的协议，用在直接连接两个结点的链路上<br />
有三个组成部分：</p>
<ol type="1">
<li>链路控制协议(LCP)一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。<br />
</li>
<li>网络控制协议(NCP)。PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。<br />
</li>
<li>将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元(MTU)的限制</li>
</ol>
<p>PPP帧的前3个字段和最后2个字段与HDLC帧一样，标志字段为7E(01111110), 前后各占1字节<br />
<img src="/assets/resources/Pasted%20image%2020240319104937.png" /></p>
<ul>
<li>当 PPP 用在异步传输时，使用字节填充法<br />
</li>
<li>当 PPP 用在同步传输链路时，采用零比特填充法</li>
</ul>
<p>PPP帧的前3个字段和最后2个字段与HDLC帧一样，标志字段为7E(01111110), 前后各占1字节,对信息字段的7E需要转义<br />
地址字段(A)占1字节，规定为0xFF,控制字段(C)占1字节，规定为03(历史遗留问题)<br />
FCS检验区包括地址字段、控制字段、协议字段和信息字段，但不提供纠错功能，也不使用序号和确认机制<br />
当线路处于静止状态时，不存在物理层连接。当线路检测到载波信号时，建立物理连接。此时，LCP开始选项商定，商定成功后就进入身份验证状态<br />
身份验证通过后，进入网络层协议状态。采用NCP配置网络层，配置成功后，进入打开状态，然后就可进行数据传输。当数据传输完成后，线路转为终止状态。载波停止后则回到静止状态<br />
<img src="/assets/resources/Pasted%20image%2020240319230827.png" /><br />
PPP只支持点对点的全双工链路，面向字节，但两端可以运行不同的网络层协议，透明传输时，若PPP用在异步线路(默认)，则采用字符填充法；若PPP用在SONET/SDH等同步线路，则协议规定采用硬件来完成比特填充(和HDLC一样)</p>
<div class="note info"><p>高级数据链路控制(HDLC)协议是面向比特的数据链路层协议。对比PPP没有协议字段，使用了编号和确认机制，能够提供可靠传输</p>
</div>
<div class="note warning"><ul>
<li>广域网是单一的网络，通常使用结点交换机连接各台主机,与路由器不同的是，后者可以联系不同类型的网络</li>
</ul>
</div>
<h2 id="设备">设备</h2>
<ol type="1">
<li>网桥，将数个以太网连接成更大的以太网，并且各网段相对独立，网桥转发跨网络的数据帧，丢弃收发地址是同一个网络的数据帧<br />
</li>
<li>交换机，实质上是多端口网桥，每个端口连接一个主机或另一个交换机，通常全双工工作<br />
N个端口的交换机，总容量是 <span class="math inline">\(端口数\times端口带宽\)</span><br />
交换机即插即用，将网络分成较小冲突域，为每个工作站提供更高的带宽(以太网交换机独占传输媒体的带宽)，通过记忆机制维护一个查找表，将数据帧的源和目的地址不断记忆下去，根据表送到目的端口<br />
<img src="/assets/resources/Pasted%20image%2020240514220430.png" /><br />
<img src="/assets/resources/Pasted%20image%2020240514220643.png" /><br />
利用以太网交换机可以实现虚拟局域网 VLAN, VLAN不仅可以隔离冲突域，而且可以隔离广播域,可根据以下条件划分：</li>
</ol>
<ul>
<li>交换机端口<br />
</li>
<li>计算机网卡的 MAC 地址<br />
</li>
<li>基于协议类型<br />
</li>
<li>基于 IP 子网地址<br />
</li>
<li>基于高层应用或服务</li>
</ul>
<p>以太网交换机主要采用两种交换模式：</p>
<ul>
<li>直通式交换机，只检查帧的目的地址，这使得帧在接收后几乎能马上被传出去。<br />
</li>
<li>存储转发式交换机，先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，确认无误后通过查找表转换成输出端口将该帧发送出去。如果发现帧有错，那么就将其丢弃 。</li>
</ul>
<p>决定一个帧是应该转发到某个端口还是应该将其丢弃称为过滤。决定一个帧应该被移动到哪个接口称为转发。交换机的过滤和转发借助于交换表(switch table)完成。交换表中的一个表项至少包含：①一个MAC地址；②连通该MAC地址的交换机端口。交换表中的每个表项都设有一定的有效时间，过期的表项会自动删除</p>
<div class="note info"><ul>
<li>中继器工作在物理层，用来连接两个速率相同且数据链路层协议也相同的网段<br />
</li>
<li>集线器(Hub)相当于一个多接口的中继器，任何时刻都只能有一个结点通过公共信道发送数据<br />
</li>
<li>网桥工作在数据链路层，可以互连不同的物理层、不同的MAC子层及不同速率的以太网<br />
</li>
<li>交换机工作在数据链路层，相当于一个多端口的网桥<br />
</li>
<li>利用交换机可以实现虚拟局域网(VLAN),VLAN不仅可以隔离冲突域，而且可以隔离广播域<br />
</li>
<li>路由器连接的网络，物理层、数据链路层、网络层协议可以不同，而网络层以上的高层协议必须相同<br />
<img src="/assets/resources/a27179bfce9d1b92abe4cbbbc5fd0a33.png" /></li>
</ul>
</div>
<div class="note warning"><ul>
<li>软件实现的分发往往比硬件慢，因此从数量级上看，如果局域网交换机的传输时延为几十微秒，那么网桥的传输时延为几百微秒，而路由器的传输时延为几千微秒<br />
</li>
<li>集线器的每个端口都具有收发功能，当某个端口收到信号时，立即向所有其他端口转发；因此其传输时延最小<br />
</li>
<li>物理层设备集线器不能分割碰撞域，数据链路层设备交换机和网桥可以分割碰撞域，但不能分割广播域，而网络层设备路由器既可以分割碰撞域，又可以分割广播域<br />
</li>
<li>对于10Mb∕s的半双工端口，端口带宽为10Mb/s,总容量则是端口数×带宽/2<br />
</li>
<li>直通交换只检查帧的目的地址</li>
<li>交换机当交换表Miss时广播不会涉及发送方的端口</li>
</ul>
</div>
<h1 id="网络层">网络层</h1>
<p>网络层的向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务，主机进程间的可靠传输由更上的传输层提供<br />
网络互连是指将两个以上的计算机网络，通过一定的方法，用一些中间设备(又称中继系统)相互连接起来，以构成更大的网络系统。根据所在的层次，中继系统分为以下4种</p>
<ol type="1">
<li>物理层：转发器，集线器<br />
</li>
<li>数据链路层：网桥或交换机<br />
</li>
<li>网络层：路由器(有时也叫网关)<br />
</li>
<li>网络层以上：网关</li>
</ol>
<p>物理层或数据链路层的中继系统时，扩充后仍是一个网络，网络层以上才会有网络互连<br />
TCP/IP体系在网络互连上采用的做法在网络层采用标准化协议,但相互连接的网络可以是异构的，可以视为虚拟IP网络(IP协议屏蔽异构细节)<br />
<img src="/assets/resources/Pasted%20image%2020240324103707.png" /></p>
<p><strong>路由器</strong>主要完成两个功能：</p>
<ol type="1">
<li>路由选择，按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由(根据算法计算出路由表)<br />
</li>
<li>分组转发，根据转发表(由路由表得出)将用户的IP数据报从合适的端口转发出去。</li>
</ol>
<p><strong>SDN</strong><br />
网络层可划分为数据平面(也称转发层面)和控制平面，转发是数据平面实现的功能，而路由选择是控制平面实现的功能。<br />
转发指的是输入链路到输出链路，路由指的是寻找下一跳地址<br />
软件定义网络(SDN)采用集中式的控制平面和分布式的数据平面，两个平面相互分离。控制平面利用控制-数据接口对数据平面上的路由器进行集中式控制<br />
路由器之间不再相互交换路由信息，远程控制器拿握各主机和整个网络的状态，为每个分组计算出最佳路由，通过Openflow协议(也可以通过其他途径)将转发表(在SDN中称为流表)下发给路由器<br />
SDN提供的编程接口称为北向接口，提供充足API,SDN控制器和转发设备建立双向会话的接口称为南向接口,通过不同的南向接口协议(如 Openflow), SDN控制器就可兼容不同的硬件设备，同时可以在设备中实现上层应用的逻辑<br />
SDN控制器集群内部控制器之间的通信接口称为东西向接口，用于增强整个控制平面的可靠性和可拓展性<br />
优点：性能，可编程，分离式架构降低成本<br />
缺点：控制器可能是性能瓶颈，集中管理有安全风险<br />
<img src="/assets/resources/Pasted%20image%2020240324104134.png" /><br />
<img src="/assets/resources/97c5f5c08e40e69a3b111d902bfbe34f.png" /></p>
<p><strong>拥塞控制</strong>：出现过量的分组而引起网络性能下降的现象称为拥塞<br />
如图，对带宽占用较高时，吞吐量会骤降，平均时延趋近无限大<br />
<img src="/assets/resources/Pasted%20image%2020240324105240.png" /><br />
拥塞控制的作用是确保子网能够承载所达到的流量，这是一个全局性的过程，涉及各方面的行为：主机、路由器及路由器内部的转发处理过程等，与流量控制不同的是，后者只关心发送端速率是否高于接收端速率<br />
方法包括：</p>
<ul>
<li>开环控制，设计网络时，统筹总体，之后不再修改<br />
</li>
<li>闭环控制，用监测网络系统实时监控，实时调整系统</li>
</ul>
<h2 id="路由算法">路由算法</h2>
<ul>
<li>静态(非自适应)路由算法:手动设置路由表，形成路由<br />
</li>
<li>动态(自适应)路由算法:相互连接的路由器交换信息，动态计算出路由表</li>
</ul>
<h3 id="距离-向量算法">距离-向量算法</h3>
<p>所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点，包括路径目的地与其距离(一般定义为经过的路由器数量,如RIP算法)<br />
得到一个新路由，或是收到路由信息包含一个更优路由时，更新路由表，在复杂的系统中，这种更新复杂度很高,且可能有环路问题</p>
<h3 id="链路状态算法eg.-ospf">链路状态算法(eg. OSPF)</h3>
<p>每个参与该算法的结点都具有完全的网络拓扑信息，每个节点都测试邻接结点(共享一条链路的结点)的状态；且定期将链路状态传播给其他所有结点<br />
每个结点都用这种方式从网上所有其他的结点接收包含直接链路状态的路由选择信息,每当链路状态报文到达时，结点更新自己的视野，一旦链路状态发生变化，结点就对更新的网络图利用Dijkstra最短路径算法重新计算路由，从单一的源出发计算到达所有目的结点的最短路径</p>
<ol type="1">
<li>向所有路由器发送信息时，通过所有端口向所有相邻的路由器发送信息。而每个相邻路由器又将此信息发往其所有相邻路由器(但不再发送给刚刚发来信息的那个路由器)</li>
<li>"链路状态"指说明本路由器与哪些路由器相邻及该链路的度量(距离等)</li>
<li>当链路状态发生变化时,路由器才向所有路由器发送此信息</li>
</ol>
<p>易于查找故障，其报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路由结点数目无关，可以用于大型的或路由信息变化聚敛的互联网环境</p>
<h3 id="层次路由算法">层次路由算法</h3>
<p>整个互联网划分为若干较小的自治系统(一个自治系统中包含很多局域网),自治系统有权自主地决定本系统内应采用何种路由选择协议</p>
<ul>
<li>自治系统内部所使用的路由选择协议称为内部网关协议(IGP), 也称域内路由选择(RIP/OSPF)<br />
</li>
<li>自治系统之间所使用的路由选择协议称为外部网关协议(EGP), 也称域间路由选择,在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径(BGP)</li>
</ul>
<p>使用层次路由时，OSPF将一个自治系统再划分为若干区域(Area), 每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构。能够用于规模很大的自治系统中</p>
<h2 id="ipv4">IPv4</h2>
<p><img src="/assets/resources/Pasted%20image%2020240324112858.png" /></p>
<ul>
<li>首部长度以32位为单位，最大值为60B,最常用的首部长度是20B,此时不使用任何选项(即可选字段)<br />
</li>
<li>总长度单位是B，包括首部和数据，即数据报最大长度65535B,但其总长度无法超过以太网帧最大传送单元1500B<br />
</li>
<li>标识每产生一个数据报+1，标记数据报，分片时共享标识号<br />
</li>
<li>标志，标志字段的最低位为MF,MF=1表示后面还有分片，MF=0表示最后一个分片。标志字段中间的一位是DF,只有当DF= 0时才允许分片。<br />
</li>
<li>片偏移指出某片在原分组中的相对位置,以8个字节为偏移单位(13位和16位差了3位，<span class="math inline">\(8=2^3\)</span>)<br />
</li>
<li>生存时间：数据报在网络中可通过的路由器数的最大值，防止环路，路由器在转发分组前，TTL减1,收到时若ttl为0则丢弃<br />
</li>
<li>协议：其中值为6表TCP ,值为17表示UDP<br />
</li>
<li>首部校验和:只校验分组的首部<br />
</li>
<li>源地址字段标识发送方的IP地址<br />
</li>
<li>目的地址字段标识接收方的IP地址</li>
</ul>
<h3 id="分片">分片</h3>
<p>链路层的最大传送单元MTU由于物理条件限制，远小于IP数据报的最大大小，对一个报文可以分片<br />
片在目的地的网络层重新组装，目的主机使用IP首部的标识，标志，片偏移字段来重组片</p>
<ul>
<li>属于相同报文的片有相同的标识号；<br />
</li>
<li>标志位的后两位分别是MF,DF,DF=0时才可以分片，MF=0表示该报是最后一片<br />
</li>
<li>片偏移字段确定片应放在原始IP数据报的哪个位置,以8B为单位(<strong>即片的数据长度必须是8的倍数</strong>)</li>
</ul>
<p><img src="/resources/Pasted%20image%2020240325185309.png" /></p>
<h3 id="地址">地址</h3>
<p>IPv4地址(32bit):<br />
<img src="/resources/Pasted%20image%2020240325185541.png" /></p>
<p>特殊地址：</p>
<ul>
<li>主机号全0表示网络本身<br />
</li>
<li>主机号全1表示网络的广播地址<br />
</li>
<li><code>127.*.*.*</code>表示环回自检地址，表示任意主机自身<br />
</li>
<li>0.0.0.0表示本网络的本主机<br />
</li>
<li>255.255.255.255表示整个网络的广播地址(受限广播地址)，实际使用会被路由器隔离为本网络的广播地址</li>
</ul>
<p><img src="/resources/Pasted%20image%2020240325185934.png" /></p>
<p>points:</p>
<ul>
<li>IP地址管理机构只需要分配网络号，路由器转发时也只需要考虑网络号。<br />
</li>
<li>当一台主机同时连接到两个网络时，该主机就必须同时具有两个相应的IP地址，每个IP地址的网络号必须与所在网络的网络号相同，且这两个IP地址的主机号是不同的<br />
</li>
<li>转发器或桥接器(网桥等)连接的若干LAN仍然是同一个网络(同一个广播域)，因此该LAN中所有主机的IP地址的网络号必须相同,但主机号必须不同<br />
</li>
<li>在同一个局域网上的主机或路由器的IP地址中的网络号必须是一样的。路由器总是具有两个或两个以上的IP地址，路由器的每个端口都有一个不同网络号的IP地址<br />
</li>
<li>所有分配到网络号的网络(无论是LAN还是WAN)都是平等的</li>
</ul>
<h3 id="nat">NAT</h3>
<p>网络地址转换(NAT):</p>
<p>将专用网络地址转换成公用地址，从而对公网屏蔽内网细节,划出部分IP地址作为私有地址，需要通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet<br />
所有路由器，对目的地址是私有地址的数据报一律不进行转发<br />
具体包括：</p>
<ul>
<li>A:10.0.0.0‒ 10.255.255.255<br />
</li>
<li>B: 172.16.0.0‒ 172.31.255.255<br />
</li>
<li>C: 192.168.0.0‒ 192.168.255.255</li>
</ul>
<p>NAT路由器至少有一个有效公网IP。NAT路由器使用NAT转换表进行本地IP地址和全球IP地址的转换，典型转换表如下：</p>
<table>
<thead>
<tr class="header">
<th>WAN(公网地址和端口号)</th>
<th>LAN(私有地址和端口号)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>138.23.12.4, 5001</td>
<td>192.168.0.2, 2233</td>
</tr>
</tbody>
</table>
<p>普通路由器在转发IP数据报时，不改变其源IP地址和目的IP地址,也不涉及端口号。而NAT路由器在转发IP数据报时，一定要更换其IP地址，并需要查看转换端口号</p>
<h3 id="子网">子网</h3>
<p>子网划分出现在IP协议之后，将两级结构变成三级，即网络号:子网号:主机号，但对内网外透明<br />
从其他网络发送给本单位某台主机的IP数据报，先找到路由器，路由器找到子网，交付目的主机<br />
全0或全1主机号有特殊含义,全0的地址为子网的网络号，主机号全1的地址为子网的广播地址<br />
子网掩码(与地址等长)用于和IP地址<code>and</code>运算，得出其所在子网的网络号，路由器在相互之间交换路由信息时，必须把自己所在网络(或子网)的子网掩码告诉对方，路由表中的每个条目也要给出该目的网络的子网掩码<br />
points:</p>
<ul>
<li>现在的因特网标准规定：所有的网络都必须使用子网掩码。如果一个网络未划分子网，那么就采用默认子网掩码(ABC类对应123个255)<br />
</li>
<li>主机在设置IP地址信息的同时，必须设置子网掩码<br />
</li>
<li>属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码<br />
</li>
<li>路由表中，所包含信息的主要内容有目的网络地址、子网掩码、下一跳地址</li>
</ul>
<p><strong>CIDR</strong>:在变长子网掩码的基础上提出的一种消除传统A 、B 、C 类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分方法<br />
CIDR 使用"网络前缀”的概念代替子网络的概念,其位数可变，即ip=网络前缀+主机号,也使用斜线记法，即IP地址/网络前缀所占比特数<br />
CIDR不涉及子网，但可以组织内划分，如20位前缀，可以主机位的前三位作为子网号，子网前缀则是23位<br />
网络前缀都相同的连续IP地址组成"CIDR地址块”。一个CIDR地址块可以表示很多地址，这种地址的聚合称为路由聚合，或称构成超网<br />
<img src="/resources/Pasted%20image%2020240326110741.png" /><br />
如图的两个网络聚合成206.1.0.0/16</p>
<p>一把来说CIDR地址块的地址数是 <span class="math inline">\(2^N-2\)</span> (需要减去全0和全1)<br />
在查找路由表时可能会得到不止一个匹配结果。应从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块就越小，因而路由就越具体</p>
<h3 id="转发分组">转发分组</h3>
<p>路由表的常见组成：(目的网络，下一跳地址)<br />
由于CIDR优先匹配最长网络前缀，可以将最长前缀的表项排序在前(如果不这么做就需要遍历)<br />
转发表中的特殊路由：</p>
<ul>
<li>主机路由：对特定主机IP专门指定一个路由，子网掩码为32位(32位掩码只用于转发表)<br />
</li>
<li>默认路由:0.0.0.0/0表示默认路由，全0掩码和任何目的地址与运算，结果必然全0，目的网络不在转发表中时使用</li>
</ul>
<p>算法过程：</p>
<ol type="1">
<li>从IP首部提取目的地址<br />
</li>
<li>匹配到特定主机路由时，按这条转发，否则继续查找<br />
</li>
<li>进行掩码与运算，若匹配本行前缀，则查找结束，发给下一条；否则若转发表还有下一行，则重复3，否则执行4<br />
</li>
<li>若转发表中有一个默认路由，则把分组传送给默认路由；否则，报告转发分组出错<br />
</li>
<li>得到下一跳路由器的IP地址后，将该IP地址转换成MAC地址(通过ARP),将此MAC地址放到MAC帧首部中，然后根据这个MAC地址找到下一跳路由器,不同网络传输过程中，MAC的收发地址改变(网桥转发不改变源地址)</li>
</ol>
<h3 id="部分协议">部分协议</h3>
<p>网络层只使用IP地址来完成寻址,而在局域网的链路层，只能看见MAC帧，IP分组在每个网络中都被路由器解封装和重新封装，其MAC帧首部中的源地址和目的地址会不断改变，到达目标网络后，在其LAN中通过MAC帧寻址</p>
<h4 id="arp">ARP</h4>
<p>地址解析协议(ARP):进行IP地址到MAC地址的映射,每台主机都设有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表<br />
arp不仅可以用于一个局域网内两个主机的相互定位，也可以跨局域网定位其他主机，这是通过路由器转发实现的，也就是跨网的arp，发起者只需要定位路由器，由路由器代理完成剩余工作<br />
每台主机有自己的ARP高速缓存，动态维护<br />
对与跨网络的映射问题，则需要通过中间路由器进行<br />
工作过程：</p>
<ol type="1">
<li>主机A准备发给主机B数据报，在缓存中查找B的IP地址
<ol type="1">
<li>如果有，根据表项的MAC，编写并发出MAC帧<br />
</li>
<li>若没有，使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求分组，主机B发出ARP响应分组，主机A将其写入缓存，并发送MAC帧</li>
</ol></li>
</ol>
<p>应用场合：<br />
<img src="/assets/resources/Pasted%20image%2020240327150605.png" /></p>
<ul>
<li>网1的H1用ARQ找到H2的MAC<br />
</li>
<li>H1用ARQ找到R1，由R1发给H3<br />
</li>
<li>R1在网2用ARP找到目的主机H3的硬件地址<br />
</li>
<li>R1在网2用ARP找到与网2连接的路由器R2的硬件地址,转发给H4</li>
</ul>
<h4 id="dhcp">DHCP</h4>
<p>动态主机配置协议(Dynamic Host Configuration Protocol DHCP) 是<strong>应用层的基于UDP</strong>的协议，常用于给主机动态地分配IP地址<br />
使用C/S模式，需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就成为DHCP客户。本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文<br />
DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。DHCP服务器的回答报文称为提供报文<br />
交换过程:</p>
<ol type="1">
<li>客户机广播"DHCP发现"消息,找到DHCP服务器。信息的源地址为0.0.0.0,目的地址为255.255.255.255<br />
</li>
<li>服务器收到"发现"消息后，广播"DHCP提供"信息，包括提供给DHCP客户机的IP地址，源地址是服务器地址，目的地址全1<br />
</li>
<li>客户机收到"提供"消息,如果接受该地址，广播"DHCP请求"消息，向服务器请求提供IP地址。信息的源地址为0.0.0.0,目的地址为255.255.255.255<br />
</li>
<li>服务器广播"DHCP确认"消息，将IP地址分配给DHCP客户机。源地址为DHCP服务器地址，目的地址为255.255.255.255。</li>
</ol>
<p>DHCP允许网络配置多台服务器，对发现信息的应答，客户机一般挑选最先到达的<br />
客户机只能在有限时间内使用被分配的IP地址，称为租用期<br />
确认IP地址前，交互只能通过广播+UDP方式进行(TCP需要确定的IP)</p>
<h4 id="icmp">ICMP</h4>
<p>网络层使用网际控制报文协议(Intemet ControlMessage Protocol, ICMP )来让主机或路由器报告差错和异常情况<br />
ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去<br />
ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文<br />
<strong>差错报文类型</strong>：</p>
<ol type="1">
<li>终点不可达:无法交付数据报时向源点发送<br />
</li>
<li>源点抑制:拥塞丢弃数据报时，向源点发送，让其暂缓发送<br />
</li>
<li>超时:收到TTL为0的数据报，丢弃时向源点发送。终点在规定时间内未收到全部数据报片时，也丢弃数据报片并发送<br />
</li>
<li>参数问题:数据报首部字段不正确时丢弃并发送<br />
</li>
<li>改变路由:让主机知道下次应将数据报发送给另外的路由器</li>
</ol>
<p>不应发送ICMP差错报告报文的情况：</p>
<ol type="1">
<li>对ICMP差错报告报文不再发送ICMP差错报告报文<br />
</li>
<li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文<br />
</li>
<li>对具有组播地址的数据报都不发送ICMP差错报告报文<br />
</li>
<li>对具有特殊地址(如 127.0.0.0或 0.0.0.0)的数据报不发送ICMP差错报告报文</li>
</ol>
<p>询问报文有4种类型：回送请求和回答报文(测试目的站是否可达)、时间戳请求和回答报文(时钟同步和时间测量)、地址掩码请求和回答报文、路由器询问和通告报文，最常用的是前两类。<br />
PING(应用层)使用了ICMP回送请求和回答报文，Traceroute (Tracert,跟踪分组经过的路由，网络层)使用了ICMP时间超过报文</p>
<div class="note warning"><ul>
<li>IP分组头中与分片和组装相关的字段是：标识、标志与片偏移<br />
</li>
<li>如果分组长度超过MTU,那么当DF=1时，丢弃该分组，并且要用ICMP差错报文向源主机报告<br />
</li>
<li>没有对应转发表项时，nat路由器直接丢弃分组</li>
<li>路由器的路由表使用最长前缀匹配原则</li>
<li>由于全0或全1不可作为主机号,主机号至少2位</li>
</ul>
</div>
<h2 id="ipv6">IPv6</h2>
<p>地址从IPv4的32位增大到了128位,拓展性，灵活性，安全性更强，简化了分组头(更多配置可选)首部长度固定40B<br />
其目的地址可以是一台或多台主机，也可以是新增的任播(目的站是一组计算机，交付时只交付任意一台)；只有源主机才能分片<br />
地址中的每4位用一个十六进制数表示，并用冒号分隔每16位,可以缩写每个域内开头的0，但每个域必须有一位数字,相邻的0域可以用<code>::</code>缩写，且这种缩写一个地址限一次<br />
IPv6数据报由两部分组成：基本首部和有效载荷（也称净负荷）</p>
<p>基本首部中各字段的含义:</p>
<ol type="1">
<li>版本:4位，指明协议的版本，对于IPv6该字段的值是6</li>
<li>通信量类:8位，区分不同的IPv6数据报的类别或优先级</li>
<li>流标号:20位，IPv6提出流的抽象概念,指互联网上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音/视频传输），而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有相同的流标号</li>
<li>有效载荷长度:16位，指明IPv6数据报除基本首部以外的字节数（所有扩展首部都算在有效载荷之内）。这个字段的最大值是65535（单位为字节）</li>
<li>下一个首部:8位，相当于IPv4首部中的协议字段或可选字段。当IPv6没有扩展首部时，其作用与IPv4的协议字段一样，指明数据报的数据是何种协议数据单元；当IPv6带有扩展首部时，它就标识后面第一个扩展首部的类型</li>
<li>跳数限制:8位，类似于IPv4首部的TTL字段。源点在每个数据报发出时即设定某个限制值（最大为255）。路由器每次转发时将其值减1,减为零时就将该数据报丢弃</li>
<li>源地址和目的地址:128位，是数据报的发送端/接收端的IP地址</li>
</ol>
<p>目的地址的三种基本类型：</p>
<ol type="1">
<li>单播</li>
<li>多播,一点对多点的通信，数据报发送到一组计算机中的每一台。</li>
<li>任播,IPv6增加的一种类型。只交付一组计算机的其中一台计算机</li>
</ol>
<p>地址类型(/n表示地址位数为n)：</p>
<ol type="1">
<li>未指明地址(:: /128):不能用作目的地址，只能用于还未配置IPv6地址的主机作为源地址</li>
<li>环回地址(::1 /128):作用与IPv4的环回地址相同，但仅此一个</li>
<li>多播地址(FF00 /8):和IPv4的一样,这类地址占IPv6地址空间的1/256</li>
<li>本地链路单播地址(FE80::/10):类似于IPv4的私有IP地址</li>
<li>全球单播地址(上述地址以外的地址):格式为<code>全球路由选择前缀/48 - 子网标识符/16 - 接口标识符/64</code>,其中全球路由选择前缀用于路由选择;子网标识符用于构建子网;接口标识符，用于指明主机或路由器的单个网络接口，相当于v4的主机号</li>
</ol>
<p>过渡策略：</p>
<ul>
<li>双协议栈:在一台设备上同时装有IPv4和IPv6协议栈,同时可以使用两种协议通信; 使用应用层的域名系统（DNS）获知目的主机采用的是哪种地址</li>
<li>隧道技术的要点是在IPv6数据报要进入IPv4网络时，把整个IPv6数据报封装到IPv4数据报的数据部分，使IPv6数据报在IPv4网络的隧道中传输,离开IPv4网络时转化成v6数据报运输</li>
</ul>
<div class="note warning"><ul>
<li>IPv6支持QoS,以满足实时、多媒体通信的需要,Qos(QualityofService，服务质量)指个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制，是用来解决网各延迟和阻寒等问题的一种技术<br />
</li>
<li>IPv6取消了校验和字段,不允许分片，因此如果路由器发现到来的数据报太大而不能转发到链路上，那么丢弃该数据报，并向发送方发送一个指示分组太大的ICMP报文<br />
</li>
<li>首部长度是不可变的因此不需要首部长度字段</li>
</ul>
</div>
<h2 id="自治系统">自治系统</h2>
<p>自治系统 (Autonomous System, AS)：单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同的度量来确定分组在该AS内的路由，同时还使用一种AS之间的路由选择协议来确定分组在AS之间的路由，其内部的所有路由器互相连通<br />
自治系统内部的路由选择称为<strong>域内路由选择</strong><br />
自治系统之间的路由选择称为<strong>域间路由选择</strong></p>
<ul>
<li>内部网关协议IGP:自治系统内部使用的路由选择协议，如RIP,OSPF<br />
</li>
<li>外部网关协议EGP:自治系统边界的协议，如BGP-4</li>
</ul>
<h3 id="路由信息协议rip">路由信息协议RIP</h3>
<ol type="1">
<li>每个路由器都要维护从它自身到其他每个目的网络的距离，记为距离向量，规定从一个路由器到直接连接网络的距离(跳数)为1，每经过一个路由器，距离(跳数)加1<br />
</li>
<li>一条路径最多只能包含15跳，16时表示网络不可达<br />
</li>
<li>默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表<br />
</li>
<li>在RIP中不支持子网掩码的RIP广播，所以RIP中每个网络的子网掩码必须相同</li>
</ol>
<p>与OSPF相比：</p>
<ul>
<li>仅和相邻路由器交换信息<br />
</li>
<li>交换全部路由表<br />
</li>
<li>交换时间间隔固定</li>
</ul>
<p>算法步骤：</p>
<ol type="1">
<li>对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目：把"下一跳”字段中的地址都改为X,并把所有"距离"字段的值加1<br />
</li>
<li>对报文的每个项目：
<ol type="1">
<li>原来的路由表中没有目的网络N时，把该项目添加到路由表<br />
</li>
<li>原来的路由表中有目的网络N,且下一跳路由器的地址是X时，用收到的项目替换原路由表中的项目<br />
</li>
<li>原来的路由表中有目的网络N , 且下一跳路由器的地址不是X时,若其中距离d小于路由表中距离，用收到的项目替换原路由表中的项目<br />
</li>
</ol></li>
<li>如果180秒(默认超时时间)还没有收到相邻路由器的更新路由表,标记其为不可达路由器，距离设为16</li>
</ol>
<p>RIP是基于UDP的应用层协议，实现简单，开销小，选择最少路由器的路径；但限制网络规模，且开销随着规模迅速增长，网络故障时慢收敛，更新慢</p>
<h3 id="开放最短路径优先ospf">开放最短路径优先OSPF</h3>
<p>OSPF是网络层协议，是使用分布式链路状态路由算法的典型代表，也是内部网关协议(IGP)的一种</p>
<ul>
<li>仅当链路状态变化时，向本自治系统中的所有路由器发送信息,信息包括与本路由器相邻的所有路由器的链路状态(路由器和哪些路由器相邻及该链路的"度量")<br />
</li>
<li>OSPF对不同的链路可根据IP分组的不同服务类型(TOS)而设置成不同的代价,更有灵活性<br />
</li>
<li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径(多路径间的负载平衡)<br />
</li>
<li>OSPF路由器之间需要鉴别，保证安全<br />
</li>
<li>支持可变长度的子网划分和无分类编址CIDR<br />
</li>
<li>每个链路状态都带上一个32位的序号，序号越大，状态就越新</li>
</ul>
<p>本质上说，所有路由器建立起一个链路状态数据库，在全网内一致(链路状态数据库的同步)，每个路由器根据这个全网结构图，使用Dijkstra最短路径算法计算从自己到各目的网络的最优路径,但表内只存储下一跳<br />
OSPF将一个自治系统再划分为若干更小的范围，称为区域,减少广播的开销,处在上层的域称为主干区域，负责连通其他下层的区域，并且还连接其他自治域，主干区域中，用于连接主干区域和其他下层区域的路由器称为区域边界路由器。只要是在主干区域中的路由器，就都称为主干路由器，主干路由器可以兼作区域边界路由器</p>
<p><strong>分组类型</strong>：</p>
<ol type="1">
<li>问候分组，用来发现和维持邻站的可达性<br />
</li>
<li>数据库描述分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息<br />
</li>
<li>链路状态请求分组，向对方请求发送某些链路状态项目的详细信息<br />
</li>
<li>链路状态更新分组，用洪泛法对全网更新链路状态<br />
</li>
<li>链路状态确认分组，对链路更新分组的确认</li>
</ol>
<p>路由器启动时，OSPF让每个路由器使用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息,随后各自请求一些缺少状态项目的信息。通常每隔10秒 ，每两个相邻路由器要交换一次问候分组，以便知道哪些站可达<br />
<img src="/resources/Pasted%20image%2020240329162021.png" /><br />
规定每隔一段时间(如30分钟)就刷新一次数据库中的链路状态。由于一个路由器的链路状态只涉及与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此，当互联网规模很大时，OSPF要比RIP好得多，而且OSPF协议没有"慢收敛"的问题<br />
OSPF协议使用ip数据报<br />
用UDP传送是指将该信息作为UDP报文的数据部分，而直接使用IP数据报传送是指将该信息直接作为IP数据报的数据部分，RIP报文是作为UDP数据报的数据部分</p>
<h3 id="边界网关协议bgp">边界网关协议BGP</h3>
<p>基于TCP的应用层协议，不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议，不要求找到最佳路由<br />
流程如下：自治系统管理员选择至少一个路由器(其内部依旧运行自己的网关协议)作为BGP发言人，与其他系统的发言人交换路由信息(通过TCP连接，即BGP报文是TCP报文的数据部分),通过交换能得出到达各个系统的较好路由<br />
在BGP刚运行时，BGP的邻站交换整个BGP路由表，但以后只需在发生变化时更新有变化的部分<br />
<img src="/resources/Pasted%20image%2020240331102142.png" /><br />
BGP简化了寻找路由的成本，且支持CIDR，路由表包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列<br />
BGP使用4种报文：</p>
<ol type="1">
<li>打开Open,与相邻的BGP发言人建立关系<br />
</li>
<li>更新Update,发送某一路由的信息，或者发送要撤销的路由<br />
</li>
<li>保活Keepalive,确认打开报文，和邻站连接<br />
</li>
<li>通知Notification,发送检测到的差错</li>
</ol>
<p><img src="/resources/Pasted%20image%2020240331105510.png" /></p>
<div class="note warning"><ul>
<li>rip的距离可以超过16，只要超过就表示不可达<br />
</li>
<li>收敛，是指当路由环境发生变化后，各路由器调整自己的路由表以适应网络拓扑结构的变化，最终达到稳定状态(路由表与网络拓扑状态保持一致)</li>
</ul>
</div>
<h2 id="ip组播">IP组播</h2>
<p>一些网络应用需要组播机制，让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被它们正确接收<br />
组播仅应用于UDP,有更高的效率,其目的地址是组播地址，网络可以将其发给组内每个主机(主机可以同时属于多个组)<br />
IP组播也使用组播组的概念，每个组都有一个特别分配的地址，要给该组发送的计算机将使用这个地址作为分组的目标地址。<br />
在IPv4中，这些地址在D类地址空间中分配，而IPv6也有一部分地址空间保留给组播组</p>
<p><img src="/resources/Pasted%20image%2020240331112739.png" /><br />
主机使用一个称为IGMP (因特网组管理协议)加入组播组。主机通过该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组的愿望。通过扩展路由器的路由选择和转发功能，可以在许多路由器互连的支持硬件组播的网络上面实现因特网组播。<br />
主机只需要发出一份数据，路由器(能够运行组播协议的路由器称为组播路由器)负责对多个分叉转发</p>
<h3 id="地址-1">地址</h3>
<p>D类IP地址:前四位是1110，范围是 224.0.0.0-239.255.255.255<br />
与一般IP数据报不同，组播数据报使用D类IP地址(但不是任何D类地址都可以使用)作为目的地址，且首部的协议字段值为2，表示使用IGMP<br />
组播数据报不保证可靠，不产生ICMP差错报文(无法PING),组播地址只能用于目的地址<br />
以太网组播地址的范围是从01-00-5E-00-00-00到 01-00-5E-7F-FF-FF,即23位，和D类地址的23位一一对应，而D类IP一共有28位可分配，5位需要丢弃<br />
在 48 位的多播地址中，前 25 位都固定不变，只有后 23 位可用作多播<br />
组播IP地址与以太网硬件地址的映射关系不是唯一的，因此收到组播数据报的主机，要在IP层利用软件进行过滤,把不是本主机要接收的数据报丢弃<br />
<img src="/resources/Pasted%20image%2020240331114257.png" /></p>
<h3 id="算法">算法</h3>
<p>连接到局域网上的组播路由器还必须和因特网上的其他组播路由器交流，以将组播数据报用最小代价传送给所有组成员,即需要组播路由选择协议<br />
IGMP让连接到本地局域网上的组播路由器知道本局域网上是否有主机参加或退出了某个组播组,但不知道具体主机数量，也不知道这些成员都分布在哪些网络上<br />
IGMP的工作流程：</p>
<ol type="1">
<li>当某台主机加入新的组播组时，该主机应向组播组的组播地址发送一个IGMP报文 ，声明自己要成为该组的成员。本地的组播路由器收到IGMP报文后，将组成员关系转发给因特网上的其他组播路由器<br />
</li>
<li>本地组播路由器周期性地确认组的成员状态，一个组在经过几次的探询后仍然没有一台主机响应时，则不再将该组的成员关系转发给其他的组播路由器</li>
</ol>
<p>组播路由选择实际上就是要找出以源主机为根结点的组播转发树，其中每个分组在每条链路上只传送一次。不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树<br />
因特网组播时，主要有三种路由算法：第一种是基于链路状态的路由选择；第二种是基于距离-向量的路由选择；第三种可以建立在任何路由器协议之上，因此称为协议无关的组播(PIM)<br />
特殊机制：<br />
<div class="note info"><ul>
<li>分散响应：在 IGMP 的询问报文中有一个数值N指明一个最长响应时间，收到询问时，主机在 0 到 N之间随机选择发送响应所需经过的时延。若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送<br />
</li>
<li>抑制机制：同一个组内的每一个主机都要监听响应，只要有本组的其他主机先发送了响应，自己就不再发送响应了</li>
</ul>
</div></p>
<h2 id="移动ip">移动IP</h2>
<p>移动站以固定的网络IP地址实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变<br />
定义了三种功能实体：移动节点、本地代理(也称归属代理)和外地代理</p>
<ul>
<li>移动节点:有永久IP地址的移动站<br />
</li>
<li>本地代理:连接在归属网络(原始连接到的网络)上的路由器<br />
</li>
<li>外地代理:连接在被访网络(移动到另一地点所接入的网络)上的路由器</li>
</ul>
<p>每个移动站有一个永久地址(或归属地址),原始连接的网络称为归属网络，归属代理在应用层上完成<br />
移动后接入的网络则是被访网络，需要外地代理(连接被访网络的路由器)<br />
外地代理为移动站创建一个临时地址，称为转交地址,及时把移动站的转交地址告诉其归属代理</p>
<p>基本流程：</p>
<ol type="1">
<li>归属网络时，按传统的TCP/IP方式进行通信<br />
</li>
<li>漫游到外地网络时，向外地代理进行登记，以获得一个临时的转交地址,外地代理向移动站的归属代理登记移动站的转交地址<br />
</li>
<li>归属代理构建一条通向转交地址的隧道,将截获的发送给移动站的IP分组进行再封装，通过本地代理发送给被访网络的外地代理<br />
</li>
<li>外地代理把收到的封装的数据报进行拆封，恢复成原始的IP分组，然后发送给移动站<br />
</li>
<li>移动站在被访网络对外发送数据报时，仍然使用自己的永久地址作为数据报的源地址,此时数据直接通过被访网络的外部代理发送</li>
<li>移动站移动到另一外地网络时，在新外地代理登记后，然后新外地代理将移动站的新转交地址告诉其归属代理。无论如何移动，移动站收到的数据报都是由归属代理转发的<br />
</li>
<li>移动站回到归属网络时，移动站向归属代理注销转交地址</li>
</ol>
<p>简单地说，移动到其他网络时，该网络路由器分配一个临时的移交ip地址，用于和原来的网络通信，且维持原先的ip地址,对外界网络发送时则直接使用代理服务器发送(地址依旧是最初地址)</p>
<h2 id="网络层设备">网络层设备</h2>
<ul>
<li><strong>冲突域</strong>是指连接到同一物理介质上的所有结点的集合，这些结点之间存在介质争用的现象(OSI中只出现在第一层,第二层开始的设备可以划分冲突域)<br />
</li>
<li><strong>广播域</strong>是指接收同样广播消息的结点集合(OSI中被视为第二层设备，路由器等3层设备可以划分广播域)</li>
</ul>
<p>路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接不同的网络(连接异构网络)并完成路由转发 ,路由器用来连接多个广播域<br />
主机发送数据报时，路由器负责按照路由表转发目标主机不在网络中的数据报(间接交付)，同一个网络中则是直接交付<br />
<img src="/resources/Pasted%20image%2020240331144643.png" /><br />
路由选择部分也称控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断更新和维护路由表<br />
分组转发部分由三部分组成：交换结构、一组输入端口和一组输出端口,输入端口从物理层的比特流中提取数据链路层帧，再提取网络层数据报，输出相反，交换表进行转发表的管理，查找，选取合适的输出端口发出；<br />
有三种常用的交换方法：通过存储器进行交换、通过总线进行交换和通过互联网络进行交换。交换结构本身就是一个网络<br />
路由器主要完成两个功能：一是分组转发，二是路由计算。前者处理通过路由器的数据流，关键操作是转发表查询、转发及相关的队列管理和任务调度等;后者通过和其他路由器进行基于路由协议的交互，完成路由表的计算<br />
与网桥不同，路由器会根据不同层次的协议进行不同操作,路由器有能力对下三层协议的控制信息进行识别、分析以及转换</p>
<h3 id="路由表">路由表</h3>
<p>标准的路由表有4个项目:目的网络IP地址、子网掩码、下一跳IP地址、接口<br />
<img src="/resources/Pasted%20image%2020240331145111.png" /><br />
转发表基于且简化路由表，一般只包括分组目的地址与其下一跳(MAC),可以设置优先级最低的一个默认路由<br />
<img src="/resources/Pasted%20image%2020240331145119.png" /><br />
路由表是许多路由器协同工作的结果,转发表只包括下一跳,分组的实际转发是靠直接查找转发表</p>
<h1 id="传输层">传输层</h1>
<p>传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层<br />
应用进程之间的通信又称端到端的逻辑通信,传输层工作在主机中，提供这种通信<br />
其中：</p>
<ul>
<li>复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据<br />
</li>
<li>分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程</li>
</ul>
<div class="note info"><p>网络层也有复用分用的功能，网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议</p>
</div>
<p>传输层对报文进行差错检测(首部和数据部分),网络层只检查IP数据报首部，不检验数据部分是否出错</p>
<p><strong>端口</strong>：传输层服务访问点(TSAP),数据链路层的SAP是MAC地址，网络层的SAP是IP地址<br />
硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用软件端口。</p>
<p><strong>端口号</strong>:端口号16位，能表示65536个数据，表示各个进程，分为：</p>
<ul>
<li>服务器端使用的端口号
<ul>
<li>0-1023的常用端口号，IANA (互联网地址指派机构)把这些端口号指派给了 TCP/IP最重要的一些应用程序<br />
</li>
<li>1024-49151的其他应用，必须在IANA登记<br />
</li>
</ul></li>
<li>客户端使用的端口号:49152-65535,称短暂端口号(也称临时端口)</li>
</ul>
<p><strong>套接字</strong>:端口号拼接到IP地址即构成套接字Socket。在网络中采用发送方和接收方的套接字来识别端点,唯一地标识网络中的一台主机和其上的一个应用(进程)<br />
套接字Socket=(IP地址:端口号)<br />
主机A发给主机B的报文段包含目的端口号和源端口号，源端口号是"返回地址”的一部分，即当B需要发回一个报文段给A时，B到A的报文段中的目的端口号便是A到B的报文段中的源端口号<br />
<img src="/resources/Pasted%20image%2020240331150800.png" /></p>
<div class="note warning"><ul>
<li>点对点是主机到主机，端对端是进程到进程</li>
<li>同一台计算机中TCP和UDP分别拥有自己的端口号，它们互不干扰</li>
</ul>
</div>
<h2 id="udp">UDP</h2>
<p>在IP之上仅提供两个附加服务：多路复用和对数据的错误检查,远程主机的传输层收到UDP报文后，不需要确认<br />
使用UDP的应用主要包括小文件传送协议(TFTP)、DNS、SNMP和实时传输协议(RTP)<br />
开销小于TCP(如首部只需要8B)没有拥塞控制，因此网络中的拥塞不会影响主机的发送效率<br />
<strong>处理过程</strong>：发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，一次发送一个报文，既不合并，也不拆分;接收方UDP对IP层交上的UDP数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文<br />
报文长度由应用程序控制</p>
<p>UDP首部有8B,由4个字段组成，每个字段的长度都是2B</p>
<ol type="1">
<li>源端口号，不需要时全0，需要回信时填充<br />
</li>
<li>目的端口号<br />
</li>
<li>长度，最小值是8<br />
</li>
<li>校验和，可选，可以全0表示不使用</li>
</ol>
<p>传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程,如果接收方UDP发现目的端口号对应的程序不存在，则丢弃报文，ICMP发送端口不可达差错报文</p>
<h3 id="校验">校验</h3>
<p>在UDP数据报之前增加12B的伪首部,得到临时UDP数据报，不会像上下层传递<br />
伪首部机制检查源端口号、目的端口号和UDP用户数据报的数据部分以及IP数据报的源IP地址和目的地址<br />
发送方首先把全零放入校验和字段并添加伪首部，然后把UDP数据报视为许多16位的字串接起来。若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾填入一个全零字节(但此字节不发送)。然后按二进制反码计算出这些16位字的和，将此和的二进制反码写入校验和字段，并发送。接收方把收到的UDP数据报加上伪首部(如果不为偶数个字节，那么还需要补上全零字节)后，按二进制反码求这些16位字的和。当无差错时其结果应为全1,否则就表明有差错出现，接收方就应该丢弃这个UDP数据报<br />
校验时，若UDP数据报部分的长度不是偶数个字节，则需填入一个全0字节,错误数据可以附上错误报告后交付<br />
<img src="/resources/Pasted%20image%2020240331161759.png" /><br />
<img src="/resources/Pasted%20image%2020240331161809.png" /></p>
<div class="note warning"><ul>
<li>UDP数据报首部长度是固定的8B,所以没有必要再设置首部长度字段</li>
</ul>
</div>
<h2 id="tcp">TCP</h2>
<ul>
<li>TCP连接是逻辑上的，点对点连接<br />
</li>
<li>提供可靠服务，无差错无丢失，不重复且有序<br />
</li>
<li>提供全双工通信，允许双方任何时间发送数据，即双方都有发送接收缓存
<ul>
<li>发送缓存：
<ol type="1">
<li>发送应用程序传送给发送方TCP准备发送的数据；<br />
</li>
<li>TCP已发送但尚未收到确认的数据<br />
</li>
</ol></li>
<li>接收缓存
<ol type="1">
<li>按序到达但尚未被接收应用程序读取的数据；<br />
</li>
<li>不按序到达的数据<br />
</li>
</ol></li>
</ul></li>
<li>面向字节，把应用程序交下来的数据仅视为一连串的无结构的字节流， 报文长度则根据接收方给出的窗口值和当前网络拥塞程度来决定</li>
</ul>
<h3 id="报文段">报文段</h3>
<p>TCP传送的数据单元称为报文段。TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答<br />
<img src="/resources/Pasted%20image%2020240414111323.png" /></p>
<p>首部最短为20B，后有4N字节可选字段：</p>
<ol type="1">
<li>源端口和目的端口，各占2B<br />
</li>
<li>序号占4B，即 <span class="math inline">\([0,2^{32}-1]\)</span> 编号的对象是整个连接传输的字节流中的字节,序号字段的值指的是本报文段所发送的数据的第一个字节在字节流中序号<br />
</li>
<li>确认号占4B，期望收到对方下一个报文段的第一个数据字节的序号，可连带确认之前的数据报<br />
</li>
<li>数据偏移，占4位，表示首部长度，即数据段离报文起始地址的长度，其单位是4B,即最大首部长度为60B<br />
</li>
<li>保留位6位，置为0<br />
</li>
<li>紧急位URG，为1时表示有紧急数据，与紧急指针配合使用，第一个字节到紧急指针所指字节是紧急数据<br />
</li>
<li>确认位ACK，为1时确认字段生效，在建立连接后才可以且必须启用<br />
</li>
<li>推送位PSH，为1时需要立即交付，不可等待缓存区满<br />
</li>
<li>复位位RST,为1时表示连接出现差错，需要释放<br />
</li>
<li>同步位SYN,为1时表示连接请求或接受报文(此时ACK=0表示是请求报文，否则是接收报文)<br />
</li>
<li>终止位FIN，为1时表示(发送方)数据传完，需要释放连接<br />
</li>
<li>窗口，占2B，表示允许对方发送的数据量，即接收方剩余缓存大小,单位为B<br />
</li>
<li>校验和，2B，分首部和数据，类似UDP添加12B伪首部(UDP伪首部的协议字段的17改成6,UDP长度字段改成TCP长度，其他的和UDP一样)<br />
</li>
<li>紧急指针，2B，与URG搭配，指出紧急数据有多少字节(紧急数据在报文段数据的最前面)<br />
</li>
<li>选项，如最大报文段长度MSS(数据字段最大长度)<br />
</li>
<li>填充，确保首部长度是4B整数倍</li>
</ol>
<h3 id="连接管理">连接管理</h3>
<p>每个TCP连接都有三个阶段：连接建立、数据传送和连接释放</p>
<ul>
<li>每一方都知道对方存在<br />
</li>
<li>可以协商参数<br />
</li>
<li>能够对运输实体资源进行分配</li>
</ul>
<p>TCP连接的端口即为套接字(Socket)或插口，每条TCP连接唯一地被通信的两个端点(即两个套接字)确定<br />
建立采用客户/服务器模式。主动发起连接建立的应用进程称为客户(Client), 而被动等待连接建立的应用进程称为服务器(Server)</p>
<p><strong>三次握手建立连接</strong>：</p>
<ol type="1">
<li>服务器进程进入LISTEN状态<br />
</li>
<li>客户机发送连接请求报文段，其SYN置1，并选取一个初始序号seq=x，该报文段不携带数据；客户进程进入SYS-SENT状态<br />
</li>
<li>服务器收到请求，发回确认，为连接分配缓存，确认报文段中,把SYN位和ACK位都置1,确认号是ack=x+1,选取一个初始序号seq=y,TCP服务器进程进入SYN-RCVD状态<br />
</li>
<li>当客户机收到确认报文段后，还要向服务器给出确认,为该TCP连接分配缓存和变量，确认报文段的ACK位置1,确认号ack=y+1,序号seq=x+1,该报文段可以携带数据，不携带则不消耗序号;客户进程进入ESTABLISHED (已建立连接)状态<br />
服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击</li>
</ol>
<p><img src="/resources/Pasted%20image%2020240414114449.png" /></p>
<p><strong>四次握手释放连接</strong>：</p>
<ol type="1">
<li>客户机发送连接释放报文段(FIN=1，序号seq=u，即最后一个数据字节的序号+1)，停止发送数据，客户进程进入FIN-WAIT-1状态<br />
</li>
<li>服务器收到连接释放报文段后发出确认，确认号ack=u+1,seq=v(最后一个发送数据字节的序号+1)，服务器进入CLOSE-WAIT状态，此时客户机不会继续发数据，但服务器可以单向连接客户机<br />
</li>
<li>服务器发完数据后，发出FIN=1的连接释放报文段。设该报文段的序号为w，需要重复确认号ack=u+1,服务器进入LAST-ACK状态<br />
</li>
<li>客户机收到连接释放报文段后，必须发出确认。把确认报文段中的确认位ACK置1,确认号ack=w+1,序号seq=u+1,计时器设置的最大长报文段寿命的两倍时间后，客户机正式关闭连接</li>
</ol>
<p><img src="/resources/Pasted%20image%2020240414114522.png" /></p>
<div class="note info"><p>连接的标志位情况如下</p>
<p><strong>连接建立</strong>:</p>
<ol type="1">
<li>SYN = 1, seq = x<br />
</li>
<li>SYN = 1, ACK = 1, seq = y, ack = x + 1<br />
</li>
<li>ACK = 1, seq = x + 1, ack = y + 1</li>
</ol>
<p><strong>释放连接</strong>:</p>
<ol type="1">
<li>FIN = 1, seq = u<br />
</li>
<li>ACK = 1, seq = v, ack = u + 1<br />
</li>
<li>FIN = 1, ACK = 1, seq = w, ack = u + 1<br />
</li>
<li>ACK = 1 , seq = u + 1 , ack = w + 1</li>
</ol>
</div>
<h3 id="可靠传输">可靠传输</h3>
<p>保证接收方进程从缓存区读出的字节流与发送方发出的字节流一样</p>
<ol type="1">
<li>校验机制与UDP校验一样<br />
</li>
<li>序号，编号的对象是传送字节流，而不是报文段，字段的值是指本报文段所发送的数据的第一个字节的序号<br />
</li>
<li>确认，确认号字段值是期望收到对方的下一个报文段的数据的第一个字节的序号，发送方缓存区会继续存储已发送但未收到确认的报文段，以备重传<br />
</li>
<li>重传，分两种情况
<ol type="1">
<li>超时，发送报文段后，有计时确认机制，确认超时就要重传；报文段发出的时间与收到相应确认的时间之差称为报文段的往返时间RTT，TCP会保留RTT的一个加权平均往返时间RTTs，计时器时限RTO应当略大于RTTs<br />
</li>
<li>冗余确认，冗余ACK:再次确认某个报文段的ACK,TCP规定每当比期望序号大的失序报文段到达时，就发送一个冗余ACK,<strong>规定发送方收到对同一个报文段的3个冗余ACK时</strong>，就可以认为跟在这个被确认报文段之后的报文段已经丢失,这时发送方A 可以重传序号最前的未确认帧，这种技术通常称为<strong>快速重传</strong></li>
</ol></li>
</ol>
<h3 id="流量控制">流量控制</h3>
<p>依然是使用窗口限制过快的发送速率,接收方根据自己缓存大小，调整发送方发送窗口大小，称为<strong>接收窗口rwnd</strong>(接收方允许连续接收的最大能力，单位是B),即调整报文段首部的<code>窗口</code>字段，同时发送方也可以自己估计窗口值，称为<strong>拥塞窗口cwnd</strong>(根据估算的网络拥塞程度而设置的窗口值)<br />
发送方以最新的rwnd，作为未确认数据量的阈值<br />
<img src="/resources/Pasted%20image%2020240421102135.png" /><br />
与数据链路层不同的是，后者定义两个中间的相邻结点的流量控制，前者定义端到端的流量控制，且窗口可以动态变化大小</p>
<h3 id="阻塞控制">阻塞控制</h3>
<p>防止过多的数据注入网络，保证网络中的路由器或链路不致过载，往往表现为通信时延增加<br />
主要指标有：</p>
<ol type="1">
<li>由于缺少缓存空间而被丢弃的分组的百分数</li>
<li>平均队列长度</li>
<li>超时重传的分组数</li>
<li>平均分组时延</li>
<li>分组时延的标准差</li>
</ol>
<p>假设接收方缓存足够，发送窗口决定拥塞程度，发送窗口的上限值应取rwnd和cwnd中较小值</p>
<ol type="1">
<li><p>慢开始，先令拥塞窗口cwnd=1,每收到一个对新报文段的确认后，将cwnd加1;由于每次加1次数即是cwnd数，因此会指数增长，一般达到一个阈值ssthresh后改用拥塞避免<br />
</p></li>
<li><p>阻塞避免，每经过一个RTT，将cwnd加一，无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(未按时收到确认)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半，cwnd置0 <img src="/resources/Pasted%20image%2020240421113612.png" /><br />
慢开始阶段的指数不会跨过阈值(本质是加一累积起来)，一旦碰到阈值就会变成拥塞避免算法</p></li>
<li><p>快重传,发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时<br />
</p></li>
<li><p>快恢复,当发送方连续收到三个冗余ACK(即重复确认)时,把慢开始门限ssthresh设置为此时发送方cwnd的一半(此时可能没有严重拥塞，只需要减慢窗口增长速率)并令cwnd减半，跳过了cwnd从1起始的慢开始过程，所以被称为快恢复</p></li>
</ol>
<p><img src="/resources/Pasted%20image%2020240421114342.png" /></p>
<p>在TCP连接建立和网络出现超时时，采用慢开始和拥塞避免算法；当发送方接收到冗余ACK时，采用快重传和快恢复算法,以上基于cwnd足够的假设，实际的发送窗口大小是由rwnd和cwnd中较小值</p>
<div class="note warning"><ul>
<li>序号的单位是B<br />
</li>
<li>SYN,FIN段不能携带数据，但要消耗一个序号</li>
<li>必须使得迟到的TCP报文段的序号不处在新连接所用的序号范围之中,因此，不同的TCP连接不能使用相同的初始序号<br />
</li>
<li>服务器端进入CLOSED状态需要经过3次报文段的传输时间,即1.5RTT<br />
</li>
<li><strong>tcp连接建立和释放过程，除了第一次报文，其他都附带ack，尤其是释放阶段，服务器端需要两次发送相同ack号的报文</strong></li>
</ul>
</div>
<h1 id="应用层">应用层</h1>
<h2 id="应用模型">应用模型</h2>
<ol type="1">
<li>C/S模型，客户/服务器(C/S)模型中，服务器始终接收请求，等待客户机发出请求后，进行相关处理并返回结果,客户机相互之间不直接通信<br />
</li>
<li>P2P模型，去中心化，任意一对计算机(对等方peer)，相互通信，拓展性强，但相对来说，效率更低</li>
</ol>
<p><img src="/resources/Pasted%20image%2020240421103240.png" /></p>
<h2 id="域名系统dns">域名系统DNS</h2>
<p>将易于记忆的网址转化为IP地址，采用客户/服务器模型，其协议运行在UDP之上，使用53号端口<br />
域名，也就是俗称的网址(但不完全等于)，是层次树状的，其英文不区分大小写，除了<code>-</code>不可使用其他标点，每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符，从左到右级别递增，如github.com，github低于com<br />
顶级域名一般分为：</p>
<ol type="1">
<li>国家(地区)顶级域名(nTLD)国家和某些地区的域名，如".cn”表示中国，".us"表示美国，".uk"表示英国<br />
</li>
<li>通用顶级域名(gTLD)常见的有“.com”(公司)、".net"(网络服务机构)、".org"(非营利性组织)和".gov" (国家或政府部门)等<br />
</li>
<li>基础结构域名。这种顶级域名只有一个，即arpa, 用 于 反向域名解析，因此又称反向域名<br />
<img src="/resources/Pasted%20image%2020240421104056.png" /></li>
</ol>
<h3 id="域名服务器">域名服务器</h3>
<p>域名解析实际是通过域名服务器进行，每个域名服务器管理一个<code>区</code>，这些服务器以层次方式组织，一个区中的所有节点必须是能够连通的且区可以小于域，分为：</p>
<ol type="1">
<li>根域名服务器，最高层次的域名服务器，每个根域名服务器知道所有顶级域名服务器ip地址，因特网上有13个根域名服务器(实际上是集群)，如果本地无法解析，首先求助根服务器，根服务器给出下一步应当找哪一个顶级域名服务器进行查询；根域名服务器采用任播机制，客户请求时只需要得到最近一台服务器响应<br />
</li>
<li>顶级域名服务器，可以给出具体ip，也可以转交下级<br />
</li>
<li>授权/权限域名服务器，负责一个区，每台主机都必须在授权域名服务器处登记，一台主机最好至少有两个授权域名服务器，授权服务可以把管辖的主机名直接转化为Ip地址，若无法给出回答，则转交一个可以给出回答的授权服务器<br />
</li>
<li>本地域名服务器，当一台主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</li>
</ol>
<p><img src="/resources/Pasted%20image%2020240421135221.png" /></p>
<h3 id="域名解析">域名解析</h3>
<p>把域名映射成为IP地址或把IP地址映射成域名的过程,分别叫正向和反向解析<br />
客户端需要域名解析时，通过本机的DNS客户端构造一个DNS请求报文,以UDP数据报方式发往本地域名服务器<br />
查询可分为递归和迭代，但递归消耗较大一般不用<br />
<img src="/assets/resources/Pasted%20image%2020240421141332.png" /><br />
比较典型的查询过程：</p>
<ol type="1">
<li>客户机向其本地域名服务器发出DNS请求报文(递归查询)<br />
</li>
<li>本地域名服务器收到请求后，查询本地缓存，若没有该记录，则以DNS客户的身份向根域名服务器发出解析请求报文(迭代查询)<br />
</li>
<li>根域名服务器收到请求后，判断该域名属于.com域，将对应的顶级域名服务器dns.com的IP地址返回给本地域名服务器。<br />
</li>
<li>本地域名服务器向顶级域名服务器dns.com发出解析请求报文(迭代查询)<br />
</li>
<li>顶级域名服务器dns.com收到请求后，判断该域名属于abc.com域，因此将对应的授权域名服务器dns.abc.com的IP地址返回给本地域名服务器<br />
</li>
<li>本地域名服务器向授权域名服务器dns.abc.com 发起解析请求报文(迭代查询)<br />
</li>
<li>授权域名服务器dns.abc.com收到请求后，将查询结果返回给本地域名服务器<br />
</li>
<li>本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</li>
</ol>
<p>dns广泛使用缓存(有一定生命周期)</p>
<div class="note warning"><ul>
<li>多个IP地址，多个主机可以映射到同一个域名上<br />
</li>
<li>dns可以视为一个联机分布式数据库系统</li>
</ul>
</div>
<h2 id="文件传输协议ftp">文件传输协议FTP</h2>
<p>提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限,支持异构网络中的任意计算机之间传送文件<br />
功能可分为：</p>
<ol type="1">
<li>提供不同种类主机系统(硬 、软件体系等都可以不同)之间的文件传输能力<br />
</li>
<li>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力<br />
</li>
<li>以匿名FTP的方式提供公用文件共享的能力</li>
</ol>
<p>一个FTP服务器进程可同时为多个客户进程提供服务,有一个主进程，负责接收新的请求 ：另外有若干从属进程，负责处理单个请求<br />
过程如下：</p>
<ol type="1">
<li>打开21端口，等待接收连接<br />
</li>
<li>启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止<br />
</li>
<li>返回等待状态</li>
</ol>
<p>FTP服务器必须在整个会话期间保留用户的状态信息,追踪用户在远程目录树上的当前位置</p>
<p>FTP在工作时使用两个并行的TCP连接：即<strong>控制连接(服务器端口号21)和数据连接(服务器端口号20)</strong><br />
<img src="/assets/resources/Pasted%20image%2020240421143410.png" /></p>
<ol type="1">
<li><p>控制连接：用来传输控制信息(如连接请求、传送请求等)，并且控制信息都以7位ASCII格式传送,但不直接传送文件，整个会话常驻打开<br />
</p></li>
<li><p>数据连接：服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建“数据传送进程”和"数据连接"<br />
数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行</p></li>
<li><p>主动模式(PORT):</p>
<ul>
<li>客户端连接到服务器的21端口;<br />
</li>
<li>登陆成功后，客户端随机开放一个端口,并告知服务器该端口号;<br />
</li>
<li>服务器通过20端口连接到客户端开放的端口,发送数据。<br />
</li>
</ul></li>
<li><p>被动模式(PASV):</p>
<ul>
<li>客户端发送PASV命令给服务器;<br />
</li>
<li>服务器在本地随机开放一个端口,并告知客户端该端口号;<br />
</li>
<li>客户端连接到服务器开放的端口,接收数据。<br />
</li>
</ul></li>
<li><p>区别:</p>
<ul>
<li>主动模式是服务器连接到客户端的端口;<br />
</li>
<li>被动模式是客户端连接到服务器的端口;<br />
</li>
<li>选择哪种模式的权利在客户端。</li>
</ul></li>
</ol>
<p>anonymous,即匿名用户,被用作默认的ftp用户名</p>
<p>FTP与网络文件系统NFS的区别:</p>
<ol type="1">
<li>FTP使用分离的控制连接,控制信息是带外传送(使用独立于常规通道或连接的专门通道进行数据传输,一般用于加急信息)的;<br />
</li>
<li>修改服务器文件时,需先传到本地,修改后再传回服务器,效率低;<br />
</li>
<li>NFS允许直接打开远程文件,在特定位置开始读写数据,即NFS可复制大文件中的小片段,无需复制整个文件,效率高。</li>
</ol>
<h2 id="电子邮件">电子邮件</h2>
<p>邮件是一种典型异步通信<br />
三个最主要的组成构件:</p>
<ul>
<li>用户代理(User Agent),用户与电子邮件系统的接口,如微软的outlook<br />
</li>
<li>邮件服务器，收发邮件，同时充当客户和服务器<br />
</li>
<li>电子邮件使用的协议，如 SMTP、POP3 (或 IMAP)等，可分为发送(smtp)和读取(pop3)</li>
</ul>
<p><img src="/resources/Pasted%20image%2020240421105559.png" /><br />
典型步骤：</p>
<ol type="1">
<li>发信人调用用户代理来撰写和编辑要发送的邮件用户代理用SMTP把邮件传送给发送端邮件服务器<br />
</li>
<li>自发送端邮件服务器将邮件放入邮件缓存队列中，等待发送<br />
</li>
<li>运行在发送端邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，就向运行在接收端邮件服务器的SMTP服务器进程发起建立TCP连接<br />
</li>
<li>TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。当所有待发送邮件发完后，SMTP就关闭所建立的TCP连接<br />
</li>
<li>运行在接收端邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取。<br />
</li>
<li>收信人打算收信时 ，调用用户代理，使用POP3(或IMAP)协议将自己的邮件从接收端邮件服务器的用户邮箱中取回(如果邮箱中有来信的话)</li>
</ol>
<h3 id="格式">格式</h3>
<p>一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分。邮件内容的首部包含一些首部行，每个首部行格式类似<code>key: value</code>有些关键字是必需的，有些则是可选的。 最重要的关键字是To和Subject<br />
<code>To</code>后填入若干个收件人的地址(邮箱名@邮箱所在主机的域名)<br />
<code>From</code>一般邮件系统自动填入</p>
<p>多用途网际邮件扩充(MIME)沿用SMTP的7位ascii码，但用其来展示其他语言字符集，包括：</p>
<ol type="1">
<li>5个新的邮件首部字段，包括MIME版本、内容描迷、内容标识、传送编码和内容类型<br />
</li>
<li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化<br />
</li>
<li>定义了传送编码，可对任何内容格式进行转换,而不会被邮件系统改变<br />
<img src="/assets/resources/Pasted%20image%2020240421151429.png" /></li>
</ol>
<h3 id="常用协议">常用协议</h3>
<ol type="1">
<li>SMTP，控制两个相互通信的SMTP进程交换信息，SMTP使用TCP连接，端口号为25
<ol type="1">
<li>发件人的邮件发送到发送方邮件服务器的邮件缓存中,smtp客户定时扫描，发现有待发送邮件后，与接收方服务器建立tcp连接<br />
</li>
<li>接收方SMTP服务器发出220 Service ready ( 服务就绪)。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名<br />
</li>
<li>MAIL命令发送邮件,若 SMTP服务器已准备好接收邮件，则回答<code>250 OK</code><br />
</li>
<li>SMTP客户端发送一个或多个RCPT (收件人recipient的缩写)命令,每个命令服务器返回250 OK或550 无此用户<br />
</li>
<li>OK后，客户端就使用<code>DATA</code>命令，表示要开始传输邮件的内容。正常情况下，SMTP 服务器回复的信息是 <code>354 Start mail input; end with &lt;CRLF&gt;,&lt;CRLF&gt;, &lt;CRLF&gt;</code>表示回车换行。此 时 SMTP客户端就可开始传送邮件内容，并用<code>&lt;CRLF&gt;&lt;CRLF&gt;</code>表示邮件内容的结束。<br />
</li>
<li>客户应发送QUIT命令。SMTP服务器返回的信息是221 (服务关闭)，释放连接<br />
</li>
</ol></li>
<li>POP3，采用Pull通信方式，用户代理向邮件服务器发出请求，拉取邮件;在传输层使用TCP,端口号为110。接收方的用户代理上必须运行POP客户程序，而接收方的邮件服务器上则运行POP服务器程序，两种工作方式：
<ol type="1">
<li>下载并保留方式，邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上<br />
</li>
<li>下载并删除方式，邮件一旦被读取，就被从邮件服务器上删除<br />
</li>
</ol></li>
<li>因特网报文存取协议(IMAP)，维护了会话用户的状态信息，提供创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件等联机命令，允许用户代理只获取报文的某些部分<br />
</li>
<li>基于万维网的电子邮件，如 Hotmail、Gmail等。用户浏览器与Hotmail或 Gmail的邮件服务器之间的邮件发送或接收使用的是HTTP,而仅在不同邮件服务器之间传送邮件时才使用SMTP</li>
</ol>
<h2 id="万维网www">万维网WWW</h2>
<p>万维网(World Wide Web,WWW)是一个分布式、联机式的信息存储空间,俗称的网页，被称为资源，可以通过统一资源定位符(URL)访问，并通过超文本传输协议(HTTP)传给用户<br />
准确的说有三个组成部分：</p>
<ol type="1">
<li>统一资源定位符(URL),全网范围内标识资源,一般格式:＜协议＞://＜主机 ＞:＜端口 ＞/＜路径＞<br />
</li>
<li>超文本传输协议(HTTP)，使用TCP进行传输的应用层协议<br />
</li>
<li>超文本标记语言(HTML)一种文档结构的标记语言</li>
</ol>
<p>流程可以被概括如下：</p>
<ol type="1">
<li>Web用户使用浏览器(指定URL)与Web服务器建立连接，并发送浏览请求<br />
</li>
<li>Web服务器把URL转换为文件路径，并返回信息给Web浏览器<br />
</li>
<li>通信完成，关闭连接</li>
</ol>
<h3 id="http协议">HTTP协议</h3>
<p>HTTP定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器 ,是应用层协议<br />
域名解析后,浏览器和服务器建立TCP连接，浏览器发送HTTP请求，服务器进行回应,例如返回一个html，浏览器显示这个网页<br />
HTTP有两类报文：请求报文(从Web客户端向Web服务器发送服务请求)和响应报文(从Web服务器对Web客户端请求的回答)<br />
<img src="/assets/resources/Pasted%20image%2020240505102729.png" /><br />
HTTP基于TCP，但自身不需要另外的连接；HTTP无状态，服务器无差别提供服务，但可以通过本地存储的cookie在请求时携带cookie得到个性化服务<br />
HTTP既可以使用非持久连接，也可以使用持久连接(HTTP/1.0使用非持续连接，而HTTP/1.1的默认方式为持续连接)</p>
<ul>
<li>非持久连接，每个网页元素对象的传输都需要单独建立一个TCP连接,开销较大<br />
</li>
<li>持久连接，是指万维网服务器在发送响应后仍然保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求和响应报文
<ul>
<li>非流水线方式，客户在收到前一个响应后才能发出下一个请求<br />
</li>
<li>流水线方式(HTTP/1.1的默认方式)，客户每遇到一个对象引用就立即发出一个请求，因而客户可以逐个地连续发出对各个引用对象的请求。如果所有的请求和响应都是连续发送的，那么所有对象的传输共计经历1个RTT延迟+各自传输时间<br />
<img src="/assets/resources/Pasted%20image%2020240505104319.png" /><br />
HTTP面向文本，报文中的每个字段都是一些ASCII码串，并且每个字段的长度不确定,分为请求和响应报文<br />
<img src="/assets/resources/Pasted%20image%2020240505104746.png" /><br />
报文的组成：</li>
</ul></li>
</ul>
<ol type="1">
<li>开始行：区分是请求报文还是响应报文,在请求报文中的开始行称为请求行，而在响应报文中的开始行称为状态行(三个字段空格相隔，<code>CR</code>和<code>LF</code>分别表示回车和换行)，其中请求行分为：方法，请求资源URL,HTTP版本<br />
</li>
<li>首部行：说明浏览器、服务器或报文主体的一些信息<br />
</li>
<li>实体主体：不常用，部分响应报文使用<br />
<img src="/assets/resources/Pasted%20image%2020240505104900.png" /><br />
<img src="/assets/resources/Pasted%20image%2020240505104947.png" /></li>
</ol>
<p>每次进行TCP三次握手时，前两次握手消耗一个RTT,第3次握手的报文段如果捎带客户对HTML文件的请求,那么建立连接和获取第一个html花费两个RTT</p>
<p>协议 HTTP/2：</p>
<ol type="1">
<li>服务器可以并行发回响应<br />
</li>
<li>允许客户复用 TCP 连接进行多个请求<br />
</li>
<li>不发送重复的首部字段</li>
</ol>
<p>状态码：</p>
<ul>
<li>1xx 表示通知信息，如请求收到了或正在进行处理。<br />
</li>
<li>2xx 表示成功，如接受或知道了。<br />
</li>
<li>3xx 表示重定向，表示要完成请求还必须采取进一步的行动。<br />
</li>
<li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。<br />
</li>
<li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li>
</ul>
<p>万维网使用 Cookie 跟踪在 HTTP 服务器和客户之间传递的状态信息<br />
常见的HTTP请求报文方法：</p>
<table>
<thead>
<tr class="header">
<th>方法(操作)</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OPTION</td>
<td>请求一些选项的信息</td>
</tr>
<tr class="even">
<td>GET</td>
<td>请求读取由 URL所标志的信息</td>
</tr>
<tr class="odd">
<td>HEAD</td>
<td>请求读取由 URL所标志的信息的首部</td>
</tr>
<tr class="even">
<td>POST</td>
<td>给服务器添加信息(例如，注释)</td>
</tr>
<tr class="odd">
<td>PUT</td>
<td>在指明的 URL下存储一个文档</td>
</tr>
<tr class="even">
<td>DELETE</td>
<td>删除指明的 URL所标志的资源</td>
</tr>
<tr class="odd">
<td>TRACE</td>
<td>用来进行环回测试的请求报文</td>
</tr>
<tr class="even">
<td>CONNECT</td>
<td>用于代理服务器</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="附录">附录</h1>
<p>以太网帧头部格式:</p>
<table>
<thead>
<tr class="header">
<th>6B</th>
<th>6B</th>
<th>2B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目的 MAC 地址</td>
<td>源 MAC 地址</td>
<td>协议类型</td>
</tr>
</tbody>
</table>
<p>IP 头部格式:</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 6%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 10%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>4 bits</th>
<th>4 bits</th>
<th>8 bits</th>
<th>16 bits</th>
<th>16 bits</th>
<th>3 bits</th>
<th>13 bits</th>
<th>8 bits</th>
<th>8 bits</th>
<th>16 bit</th>
<th>32 bits</th>
<th>32 bits</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>版本</td>
<td>头部长度</td>
<td>服务类型</td>
<td>总长度</td>
<td>标识</td>
<td>标志</td>
<td>片偏移</td>
<td>生存时间</td>
<td>协议</td>
<td>校验和</td>
<td>源 IP 地址</td>
<td>目的 IP 地址</td>
</tr>
</tbody>
</table>
<p>TCP 报文格式:</p>
<table>
<thead>
<tr class="header">
<th>14B</th>
<th>20B</th>
<th>2B</th>
<th>2B</th>
<th>4B</th>
<th>4B</th>
<th>4bit</th>
<th>6bit</th>
<th>6bit</th>
<th>2B</th>
<th>2B</th>
<th>2B</th>
<th>可变</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>以太网帧头部(14B)</td>
<td>IP 头部(20B)</td>
<td>源端口号</td>
<td>目的端口号</td>
<td>序列号</td>
<td>确认号</td>
<td>数据偏移</td>
<td>保留</td>
<td>标志位</td>
<td>窗口大小</td>
<td>TCP 校验和</td>
<td>紧急指针</td>
<td>数据部分</td>
</tr>
</tbody>
</table>
<figure>
<img src="/assets/resources/Pasted%20image%2020240518210650.png" alt="" /><figcaption>udp</figcaption>
</figure>
<p>UDP 用户数据报格式:</p>
<table>
<thead>
<tr class="header">
<th>14B</th>
<th>20B</th>
<th>2B</th>
<th>2B</th>
<th>2B</th>
<th>2B</th>
<th>可变</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>以太网帧头部(14B)</td>
<td>IP 头部(20B)</td>
<td>源端口号</td>
<td>目的端口号</td>
<td>UDP 长度</td>
<td>UDP 检验和</td>
<td>数据部分</td>
</tr>
</tbody>
</table>
<p>基于UDP的协议:DNS,DHCP,RIP,组播(IGMP)<br />
基于TCP的协议:BGP,FTP,HTTP,SMTP,POP3</p>
]]></content>
      <categories>
        <category>考研笔记</category>
        <category>研distance</category>
      </categories>
      <tags>
        <tag>研distance</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>pdfs</title>
    <url>/thinklive/23089/</url>
    <content><![CDATA[<span id="more"></span>
<div class="pdf-container" data-target="/assets/中国计算机学会推荐国际学术会议和期刊目录-2022.pdf" data-height="1500px"></div>
]]></content>
  </entry>
  <entry>
    <title>基于vue文档的笔记</title>
    <url>/thinklive/6217/</url>
    <content><![CDATA[<h1 id="前置知识">前置知识</h1>
<h2 id="es">ES</h2>
<p>ES modules 是原生 JavaScript 提供的模块功能，逐渐被更多的浏览器支持<br />
形如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">&lt;!-- something --&gt;    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">import &#123; x,y &#125; from &#x27;./module.js</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="vue基础">vue基础</h1>
<h2 id="应用">应用</h2>
<p>每个 Vue 应用都是通过createApp函数创建一个新的应用实例，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;<span class="title class_">App</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件，最后得到一个树状结构</p>
<h2 id="模板">模板</h2>
<p>当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板<br />
模板中可以使用<a href="https://cn.vuejs.org/api/built-in-directives">指令</a>，指令由 v- 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute,指令最常用的功能是绑定html属性到某个元素<br />
双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，需要使用 v-html 指令：<br />
<code>&lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt;</code></p>
<p>想要响应式地绑定一个 attribute，应该使用 v-bind 指令<code>&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt;</code><br />
简写语法为：<code>&lt;div :id="dynamicId"&gt;&lt;/div&gt;</code> 同名简写(3.4以上版本):<code>&lt;div :id&gt;&lt;/div&gt;</code> js表达式支持:<br />
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;&#123; number + <span class="number">1</span> &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? <span class="string">&#x27;YES&#x27;</span> : <span class="string">&#x27;NO&#x27;</span> &#125;&#125;</span><br><span class="line">&#123;&#123; message.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) &#125;&#125;</span><br><span class="line">&lt;div :id=<span class="string">&quot;`list-$&#123;id&#125;`&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="响应式">响应式</h2>
<p>选项式api使用data 选项来声明组件的响应式状态。此选项的值应为返回一个对象的函数<br />
在 Vue 3 中，数据是基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">JavaScript Proxy</a> 实现响应式的,也就是通过一个代理来更新对象状态，vue3中原始对象不会变成响应式代理<br />
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在其他方法或是生命周期中也可以调用方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">increment</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> Vue 自动为 methods 中的方法绑定了<strong>永远指向组件实例</strong>的 this,且嵌套的对象变化也能相应，也就是类似json的格式可以随意修改<br />
当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次</p>
<p>创建有自己状态的方法：<br />
如果需要多个有独立状态的方法，则要在created期间创建这样的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 每个实例都有了自己的预置防抖的处理函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">debouncedClick</span> = _.<span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">click</span>, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 最好是在组件卸载时</span></span><br><span class="line">    <span class="comment">// 清除掉防抖计时器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">debouncedClick</span>.<span class="title function_">cancel</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">click</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// ... 对点击的响应 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常用api">常用api</h2>
<p><a href="https://cn.vuejs.org/api/built-in-directives#v-model">vue内置指令</a> 常用的用v-bind,v-model,v-if,v-for等，语法都很符合直觉 在组合式 API 中，通过setup脚本块来初始化需要的数据和函数(包括响应式状态)，常用 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref"><code>ref()</code></a> 函数来声明响应式状态：<code>const count = ref(0)</code> 脚本中访问count的值需要解包，即通过<code>count.value</code>访问，但在模板块中可以自动解包(只有顶级的 ref 属性才会被解包，被包裹在一个列表中的ref不会解包)</p>
<div class="note info"><p>vue3提供两种声明响应式变量的方法，reactive和ref，由于响应式都是通过某种代理变量的方法实现的，因此不严谨地说,ref的代理能力更强一点，这包括：</p>
<ul>
<li>ref支持基本数据类型 + 引用数据类型(对象和数组) ;reactive只支持引用数据类型</li>
<li>ref重新分配一个新对象不会失去响应;reactive会</li>
<li>还有其他一些场合reactive会失去响应……</li>
</ul>
<p>因此现在的官方文档中更推荐使用ref</p>
</div>
<p>要在组件模板中访问 ref，需要从组件的 <code>setup()</code> 函数中声明并返回它们：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// `setup` 是一个特殊的钩子，专门用于组合式 API。</span></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ref 暴露给模板</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算属性 ref</strong>：形如以下的ref，<code>computed()</code> 方法期望接收一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description">getter 函数</a>，返回值为一个<strong>计算属性 ref</strong>，用法类似数据的ref，与function的区别是能追踪响应式状态，且响应式状态不改变就不会重新计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> publishedBooksMessage = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> author.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&#x27;Yes&#x27;</span> : <span class="string">&#x27;No&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="路由">路由</h2>
<p>创建： <code>history</code> 选项控制了路由和 URL 路径是如何双向映射的,详见<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html">不同的历史记录模式</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createMemoryHistory, createRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeView</span> <span class="keyword">from</span> <span class="string">&#x27;./HomeView.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AboutView</span> <span class="keyword">from</span> <span class="string">&#x27;./AboutView.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">HomeView</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">AboutView</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createMemoryHistory</span>(),</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>路由作为一个插件被使用： <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure> 组合式api中，用<code>useRouter() ;useRoute()</code>两个函数获取路由器实例和当前路由；组件 <code>RouterView</code> 和 <code>RouterLink</code> 都是<a href="https://cn.vuejs.org/guide/components/registration.html#global-registration">全局注册</a>的，可以直接调用，最简单地做法是APP.vue直接整个渲染当前路径的<code>RouterView</code> routes可以使用参数或者正则匹配，详见官网文档</p>
<h2 id="pinia"><a href="https://pinia.vuejs.org/zh/">Pinia</a></h2>
<p>Pinia 是 Vue 的专属状态管理库,可以帮助我们管理共享状态，也就是一些我们希望定义在组件外部，全局可用的状态<br />
引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>一些剧情向游戏杂谈</title>
    <url>/thinklive/36218/</url>
    <content><![CDATA[<p>本文是对游戏杂谈的一个汇总</p>
<hr />
<h1 id="thinklive的游戏簿">thinklive的游戏簿</h1>
<p><code>|</code>表示续作或dlc,<code>||</code>表示同作者或同系列 <span id="more"></span></p>
<h2 id="神作">神作</h2>
<p>神作的认定标准为同时满足以下123条件或者满足4条件：</p>
<ol type="1">
<li>有非常吸引本人，或非常引发本人共鸣的某种或某些特质</li>
<li>除了1.提及的特质以外，以当时同类型业界的普遍研发水平来说，没有过于明显的短板</li>
<li>制作组在制作和发行游戏的<code>时刻</code>不应当违反普世道德，发行后则不受此条管辖</li>
<li>一般情况下，不应该只取部分为神作</li>
<li>如果有颠覆整个业界级别的功绩，或者有历史上及其特殊的地位，可以无视以上规定</li>
</ol>
<p>一句话简评环节：</p>
<ol type="1">
<li>质量效应2：高质量的队友塑造和任务，最后的自杀任务也非常经典，可谓rpg史上电影化叙事的殿堂作</li>
<li>异域镇魂曲：有趣的世界观，丰富的文本量，让人牵挂的史诗故事，尽管后期完成度欠佳，但仍有个令人回味的结局</li>
<li>极乐迪斯科：写给<del>数据删除</del>的一曲哀歌，在这个时代回望别有一番风味</li>
<li>去月球 | 去月球海滩篇 || 寻找天堂：探讨人心的作品，正是欲望和缺憾塑成了现在的我们</li>
<li>博德之门2 || 龙腾世纪起源：自由度，队友塑造，战斗系统，世界观铺陈都几乎无可挑剔的西式魔幻神作</li>
<li>猎魔人 2 | 3：choice and consequence，选择与后果式rpg的杰出代表</li>
<li>black souls 1 | 2：献给挚爱的你的不可思议的梦之国度的故事</li>
<li>不予播出 | 生活点滴 | 时间循环：荒诞，新奇，充满娱乐性的英式政治讽刺喜剧</li>
<li>史丹利寓言——艾迪芬奇的记忆：什么是游戏，什么是交互，什么是叙事？探讨游戏本质的游戏的游戏</li>
<li>诺科：迷幻的来自失落故乡的旧梦</li>
<li>428被封锁的涩谷：在4月28日的涩谷，扮演一天的命运女神，将命运纺织起来吧</li>
<li>隐迹渐现：深入历史其中，然后体会自己的无力</li>
<li>寒蝉鸣泣之时：没有什么比未经过真金火炼的道德更脆弱，相反的是，经过鲜血试炼的善良才会产生真正的善行</li>
<li>海猫鸣泣之时 出题篇：啊啊啊，吾最爱的魔女，贝阿朵莉切…………</li>
<li>ever17(可可线)：打越式诡叙与整个电子游戏界诡叙的最高水平代表，虽然这么说，但前中期实在难熬，只有解谜篇值回票价，根据4.规则破例只将诡计和解谜部分算为神作<br />
</li>
<li>remember11:推理的公平性上略逊于e17,一口气抛出来一堆科幻设定比较仓促，没有解谜篇也比较麻烦，大部分人设不讨喜，但悬疑感的塑造远超e17,trick的震撼程度，应该说疯狂程度可以算是所有avg大类的top级</li>
<li>冥界狂想曲：娓娓道来似醇香的拿铁，适合在黄金般的午后享用这个以死亡为表，以生命为底的作品</li>
<li>恩达瑞尔：结合了杯赛与黑曜石等经典rpg所长而诞生的洞悉了rpg精髓的作品，尽管在引导上依旧有不少问题</li>
<li>命运石之门 || chaos child:(门)综合来看优秀的人设，文笔，节奏，以及核心谜题的想象力;(chaos)独属于信息爆炸时代的寓言，可以载入acg文化史的作品<br />
</li>
<li>There Is No Game: Wrong Dimension:天马行空的谜题，剧情和玩法，可以看出作者对游戏的热爱，游戏的游戏也首先是一款游戏，这或许就是作者想表达的</li>
<li>装甲恶鬼村正:善即是恶，恶无大小</li>
<li>forest:然而童话不会就此死去。而是在你所不曾知晓的地方，继续生长</li>
<li>离去的人们 | zero dive1: 掌控不住右手，世界就要终结</li>
<li>灵魂献祭: 完成度极高的邪典风剧本</li>
<li>银色事件 25区: kill the past</li>
</ol>
<h2 id="佳作">佳作</h2>
<p>佳作的认定只需要同时满足以下条件：</p>
<ol type="1">
<li>有比较优秀且能吸引本人或引发本人共鸣的某种或某些特质(如是因为某个部分尤其突出选入会进行注明)</li>
<li>不同于神作标准，游戏的一部分可以视为佳作</li>
<li>制作组在制作和发行游戏的<code>时刻</code>不应当违反普世道德</li>
</ol>
<p>简评：</p>
<ol type="1">
<li>不可思议的幻想乡:抛开同人作的身份也是完成度很高的肉鸽like</li>
<li>红弦俱乐部:探讨虚假的幸福与真实的痛苦的作品中比较有趣的一部</li>
<li>幻想乡萃夜祭：精美的像素美术风格</li>
<li>东方年代记:在开始后结束，又在结束后引来开始</li>
<li>赛博朋克2077 | 往日之影：在电影化+脚本演出式方面投入不菲，对rpg未来的一种探讨</li>
<li>瓦尔哈拉：科技下的末世是如此冰冷，但人心因此显得更加温暖</li>
<li>生化奇兵无限：很疯狂但有趣的剧本，但受限于不适合叙事的fps题材(剧本部分)</li>
<li>遗忘之城：完成度尚可的时空轮回式故事</li>
<li>新手指南：探讨游戏，作者以及评论者的关系</li>
<li>旁观者1 | 2：完成度尚可的反乌托邦作品</li>
<li>亲爱的艾斯特：节奏尚可的实验性步行模拟器</li>
<li>不要喂食猴子：玩法上有创新之处的反乌托邦作品</li>
<li>无主之地2 | 无主之地传说:fps和rpg的融合代表，人设和演出就fps来说相当不错</li>
<li>战神4:不错的动作系统和演出效果</li>
<li>GTA4 | 5：荒诞而黑色的犯罪演绎</li>
<li>杀手三部曲：no one is untouchable.</li>
<li>空洞骑士: 完整度相当不错的恶魔城like</li>
<li>影子工厂:价值观很积极向上的探讨虚无主义的作品</li>
<li>武士零</li>
<li>荒野大镖客1 | 2：完整且波澜壮阔地展示西部题材</li>
<li>天壤的暴风雨：打击感很不错的东方act小品</li>
<li>王权的陨落：典型猎魔人式的苦涩选择，打牌玩法不错，但后期太重复了</li>
<li>帕斯卡契约</li>
<li>东方月神夜</li>
<li>伊森卡特的消失</li>
<li>逆转裁判三部曲 || 大逆转裁判2</li>
<li>僚机计划:扮演天空之王，捕猎眼前的猎物</li>
<li>渎神</li>
<li>时钟机关的key-line 黄昏|残影|朝雾</li>
<li>赤痕夜之仪式</li>
<li>红色警戒3</li>
<li>悲情法典；内容和机制极其丰富的地牢rougelike</li>
<li>无敌号</li>
<li>看火人</li>
<li>纪念碑谷</li>
<li>极限脱出</li>
<li>Ai梦境档案</li>
<li>控制</li>
<li>疯人院</li>
<li>海沙风云 || 梦灯花(美术部分)</li>
<li>行尸走肉第一季</li>
<li>漫长的旅途</li>
<li>史莱姆少女 || 来自边境 || yes my lord</li>
<li>it was a human</li>
<li>杀戮尖塔</li>
<li>遗迹余痕</li>
<li>npc之梦</li>
<li>与狼同行</li>
<li>犹格索托斯的庭院(美术部分)</li>
<li>兔耳冒险谭 || 梅卡妮可</li>
<li>人狼村之谜</li>
<li>重返蓝鲸岛(番外怪谈部分)</li>
<li>无声尖啸</li>
<li>hello hello world || noir noah:用真实创造了虚假，又用虚假谱写真实</li>
<li>艾尔登法环</li>
<li>剧透过于激烈的RPG：利用设定来诡叙的杰出代表</li>
<li>枪声与钻石:谈判部分作为重点有接近逆转系列的紧张激烈感，搜查部分由于主角作为警方权限更高，信息量也很大，非常优秀的(泛)推理游戏</li>
<li>巫师2mod: 白狼的告别</li>
<li>东方冰之勇者</li>
<li>辐射 新维加斯</li>
<li>巴别号漫游指南</li>
<li>命运石之门0 | 线性拘束的表征图</li>
<li>幻恋夜宴</li>
<li>闪避刺客</li>
<li>海市蜃楼之馆 | 纯真安魂曲</li>
<li>六角疑云 || 邪恶冥刻</li>
<li>暗之部屋</li>
<li>CROSS † CHANNEL</li>
<li>夏夜梦话</li>
<li>幻想游园剧demo</li>
<li>天鹅之歌</li>
<li>severed steel</li>
<li>拔作岛2</li>
<li>demons root | king exit</li>
<li>素晴日(前三章)</li>
<li>slay the princess</li>
<li>只狼 影逝二度</li>
<li>ultrakill</li>
<li>狂野西部:枪手</li>
<li>使命召唤4|6|8(战役模式)</li>
<li>近畿霊務局</li>
<li>2236 A.D.(hime线)</li>
<li>秘封祭</li>
<li>无冬之夜2资料片 背叛者的面具</li>
<li>逐光: 致监星官</li>
<li>都市传说解体中心</li>
<li>噩梦摇篮:献花与你</li>
<li>Lost in Random</li>
<li>双人成行 | 双影奇境</li>
<li>斯坦达尔的警戒者</li>
<li>你好夏洛特</li>
<li>记忆边境</li>
<li>匹诺曹的谎言 | 序曲</li>
<li>银色事件 | killer 7 | 英雄不再 1 | 2 | 3</li>
<li>魔法少女的魔女审判</li>
</ol>
<h2 id="to-do-list">To Do List</h2>
<ol type="1">
<li>格林茉莉最终版</li>
<li>超越瑞驰最终版</li>
</ol>
<h2 id="出必玩">出必玩</h2>
<ol type="1">
<li>.45 PARABELLUM BLOODHOUND</li>
<li>BS2同人DLC：风与追忆之旅</li>
</ol>
<h2 id="期待">期待</h2>
<ol type="1">
<li>晕晕电波症候群</li>
<li>废都物语重制版</li>
<li>死月妖花重制版</li>
<li>巫师1重制版</li>
</ol>
<h1 id="龙腾世纪">龙腾世纪</h1>
<h2 id="dao">dao</h2>
<p>你可能曾因为好奇去搜过cdpr的发家史，也就是从卖盗版游戏到引进游戏并本土化赚到了第一桶金，这个引进的游戏是博德之门，博德之门的开发商是生软。<br />
这里插一句，波兰人的首秀巫师一在开发阶段几乎遇到了一个新游戏能想到的所有问题，这时生软仗义地扶了波兰人一把，才有了巫师一的面世，遂成rpg界一段佳话，不过后来二者先后拉了（<br />
龙腾世纪本来在定位上是博德之门的替代品，因为版权问题生软不能继续开发博德之门，于是便做出了龙腾世纪起源，这一项目立项在02年，但直到07年得到了EA的支持才在09年把这一“神作”做了出来，直到这时EA还是带善人的形象，并没有露出狰狞的獠牙，而在生软的黄金时代打磨了7年的起源，我可以毫不夸张地说，哪怕今年推出这款游戏，它依然是年度最佳候选级别的神作。<br />
我先说说，我为什么要做这个视频，其实在一开始，dao在我的心中的地位还没有要我做一个视频出来的程度，但在玩了龙腾世纪的后两作后，DAO在我心中地位飙升，可见对比的力量，这个杂谈系列会讲完我对龙腾世纪整个系列的感受，当然是纯个人感受，我不是什么rpg遗老，只是一个当代rpg爱好者而已，如有不同意之处，反正我也不会改的。</p>
<p>当你打开dao建立存档时，你可以选择三个种族，三个职业，在种族内甚至有平民和贵族的区别，根据职业和种族的不同，光开头剧情就有六种，由此开始，玩家就能感受到dao的超高自由度。<br />
当然，对于rpg来说，自由度并不是什么稀奇的东西，但dao的自由度是有其独特之处的，以自由度出名的上古卷轴五，它的自由度体现于扮演的角色的多样性，龙裔，战友团成员，冬堡法师等等，这几种身份并没有交集，是独立的，而起源的自由度体现在行为的自由，自由度再高的游戏也不能完全模拟现实，但高自由度的游戏只需要模拟到玩家一时间能想到或者能让他们觉得有趣的所有选项就够了，DAO做到了这点，举例来说，当你接到了调查黑恶势力的任务，你可以当个正义的使者把邪恶势力端了，也可以接受贿赂，甚至可以献祭奴隶来提高自己的力量，你可以与邪教合作玷污圣物，也可以屠杀邪教，杀死恶龙，扮演被选召的勇士，很多时候当你背叛道德时得到的奖励反而更好，高道德的行为除了增加部分队友的好感度并没有太多作用，与巫师类似，起源遵循着成人的价值观，尽管选择大部分时候不像巫师那么残酷，而且起源中后悔也是很容易的一件事，相对削弱了选择的分量。</p>
<p>我们再来说说提高起源代入感的另一个设计——队友系统，独身在一个苍茫浩瀚的魔幻世界冒险难免会感到孤独，巫师的解决方式是让杰洛特和爱人与亲友保持时不时的联系，上古卷轴的解决方式，嗯，我没感到有什么解决方式，至少本体没有，当然如果装了随从mod肯定就完全不一样了。在龙腾世纪起源中你绝不会感到孤独，相比其他知名rpg，生软最显著的优点应该就是队友塑造了，dao的队友大部分有着讨喜且有深度的人设，这是由海量的工作量撑起来的，在冒险时会随机出现队友间的闲聊，几乎所有队友两两组合都有为数不少的对话，或八卦，或正经或取笑，这让人感到队友都是活生生的人，同时也可想而知其中的工作量，单个角色的对话文字量往往都要以万为单位，此外，在营地和队友闲聊也能通过一些选项增减好感度，所有队友都有为数不少的对话树，并且随着好感度的增减还会解锁额外选项。<br />
队友间除了友情也能发展出爱情，这就不得不提我认为在魔幻rpg中最有魅力的女角色——莫瑞甘，她是个荒野女巫的女儿，，价值观完全是混乱中立甚至偏邪恶的，你做好事她嫌你磨叽，做坏事说不定夸你有魄力，好感度低时会邀请你滚床单并声明只是玩玩，好感度高起来了反而不愿继续亲近——“明明说了只是玩玩，怎么你当真了呢”在游戏的结局莫瑞甘会不可避免地离去，而在一个（拿感情骗钱的）的dlc里沃顿却能不远万里追踪到正欲逃走的她，最终让莫瑞甘也承认了爱情的存在，不得不说我真被这段爱情所感动了，这种细腻的感情戏其实不输我们以感情线为特色的双剑系列（当然续作就没这么顶了）<br />
代入感之外，起源的战斗系统也是极有意思的，多有意思呢，大概比巫师三好几十个上古卷轴五吧（不是）起源的系统在今天看也不算过时，采用一种可以随时暂停的即时战斗系统，同时可以为队友ai设置战术，选项极为详细，大佬光靠设置ai应该就可以全自动战斗，我这种咸鱼打boss还是要几步一暂停，很明显这是一种重策略轻即时的系统，不设技能栏上限让法师成为了团队灵魂，控制，辅助，aoe，单体爆发应有尽有，可以说带够蓝药，法师就是无敌的（大部分Boss远程攻击弱于近战），即便职业平衡不是那么好，但队友是可以随意搭配的，丰富的技能树，转职，加点策略，装备系统让起源的战斗和养成充满乐趣，当然大型迷宫各种怪潮难免会腻烦，不过比起后面两作真的是让我体验最好的战斗系统了。<br />
最后我们来说说起源的剧情和任务设计，大恶魔苏醒，黑潮突起，作为临危受命的灰袍守护者，沃顿利用古老盟约集结联军，手刃大恶魔，可以说是一个很俗套的故事，怎么把这种看起来很俗的故事讲好呢，答案是独立的小故事相加辅以大量填充细节和设定，起源的几条线，法师，矮人，精灵，伯爵都是相对独立的故事，套路很简单：求援——当地陷入危机——解决危机——得到援助，期间夹杂背叛者洛根使绊的故事线，每个地方引出了一部分的世界观设定，起源有着极其繁杂的文本，尽管套路类似，但每条线提供的信息量都是复杂且独特的，同时也有着世界观内各个势力特有的风貌，安教的圣洁，矮人的森严都得到了体现，即使很想比较，龙腾世纪的世界观也是独特且复杂的，当然，相比起源的主线，支线反而比较一般，不乏收集的填充式支线，当然，队友的支线还是很有趣的，也有一些补充世界观的有趣支线。<br />
说了这么多，应该基本说完了起源的特点，当然也有很多具体内容我并没有提及，事实上起源并不是没有缺点，比如优化太差，自带防沉迷，玩几个小时就会卡顿到没完继续，只能重启，此外，敌人种类稀缺，也存在强行推动剧情而忽略合理性的情节，甚至有手刃大恶魔实力的主角有的时候莫名其妙就当垫脚石了，但起源仍然是神作，作为一个玩惯了10年后游戏的人，我玩起源没有感到任何系统在恶心我，可见制作组对玩家体验的重视，这是龙腾世纪的续作都未能做到的，，这也是我为龙腾世纪和生软感到可惜的原因，下一期我会叙述我对两部续作的看法，当然批评为主，，，<br />
出道即巅峰的起源全平台销量不过470w，或许正是这样的销量驱使着生软不惜与老玩家对立也要向着主机倾斜，只可惜了龙腾世纪成为了开幕即巅峰，出场即绝唱的一个悲剧……</p>
<h2 id="da2">da2</h2>
<p>今天我们来说说龙腾世纪二，，龙腾世纪二是系列中一部很，额，很独特的作品，他刚发售时的风评，作为后来人我不是很清楚，不过就现在来看，da2的风评呈现一种两极分化的形势。<br />
这里插一句奥，我个人感觉rpg游戏的受众是个很宽容的群体，我这种认为2077是款好游戏的人放一些地方可能被叫孝子了，但对现在龙腾世纪的粉丝来说这可能都不算事，举个例子吧，写文案的这天龙腾世纪吧有个直接辱骂起源人气角色的，甚至没什么人骂回去，这放在其他单机游戏圈子里是难以想象的，所以对于龙腾世纪二这样极其赶工的，大部分玩家评价起来基本没什么戾气，当然事实上我很喜欢这一点，也是这点造成了da2并没有招致较为深入的批评，今天我会详细地阐述这部作品的缺点，当然是以我的角度，同时我也不会带有什么负面情绪，我个人其实很喜欢这个系列，二代我也不是那么讨厌，但它的问题确实是露骨的，毕竟太温和往往就意味着圈子的自净能力不够，对一些问题往往就不能看的那么透彻。<br />
我之前说了da2是一部赶工明显的作品，有多赶工呢，2077和它相比那都不算事，生软甚至没有给二代一个后缀名……<br />
我们先从系统性的问题说起<br />
首先作为一个rpg游戏，da2从头到尾（一共三章）几乎一直在重复利用十几个地图，一样的别墅，一样的山洞（还Tm贼亮）等等，这也是所有玩家都承认的一个问题，考虑到14个月的工期，这点可能也是难以避免的，不过这个问题实际上并不止这么简单，因为地图的数量太少，各种任务线又要在不停阶段换来换去，这就给玩家造成了一个两难的问题——如果按任务线推不得不忍受一个又一个重复度极高的地图，如果以最高效率的原则一个地点一个地点地清，又会错失现状的任务叙事，这种矛盾是稀缺的地图造成的，也是da2在叙事上的一个根本性的缺点<br />
然后，整个战斗系统可以说在da2迎来了史诗性的大改，或许是制作组没有力气做大规模的技能，所以被官方钦定为法师的霍克技能远远没有一代多，对一个技能你要投至少两个点数进去才能强化到底，更别提一个系的被动build需要投入更多，法师的技能树相比战士盗贼完全没有优势，还有那个攻击动作，法师舞得和金箍棒似的，搞act化不能这么搞啊，怕不是设计师想起自己做《翡翠帝国》（生软以前的东方题材rpg）曾经看过的西游记，把法杖当金箍棒设计……然后是二代的刷兵机制，科克沃是个小城市，但在本作中你可以看到如同下饺子一样天降的敌人杂兵——分批次有顺序地入场，先不说不集结优势兵力在战术上有多不明智，二代的aoe法术是大削过的，我基本上要带两个输出法师才能确保范围伤害足够…… 然后是Boss战的秘之设计，堆血加流程化战斗，什么意思呢，举个例子，在最后一章有个杀龙的支线，Boss血贼厚，而且打一会它就会飞走留一堆小杂兵，自己在打不到的高台上放冷箭，有一说一，不难打，但确实恶心，我记得贴吧有个最高难度的老哥打了一小时，我估计啊，制作组对赶工做的boss没信心，所以用这种机制来给玩家提供“紧张感”<br />
本作队友的战术槽给得更多了，这是个好事，但相应的队友的装备系统反而被砍了（武器能换）也就是当霍克捡到非自己职业的装备时，这就是垃圾，还有本作的dlc装备，又多又杂……steam上的全dlc装备过了100件，而且大多是毕业装备的水平，当然本来装备系统也没什么收集的乐趣，dlc出了应该也是破罐子破摔……<br />
当然成功的革新也不是没有，队友的感情线是得到了深化的，高对立和高友好都能得到buff和对应技能树，这有利于玩家不顾及队友好感度地遵循本心去做选择，也增加了build的多样性以及跨职业的连击，不过相应的礼物系统和营地闲聊也砍了……（但我个人还是更喜欢起源的策略性战斗）……<br />
随后的一大麻烦就是剧情，da的小格局剧情在魔幻rpg中应该算少见，虽然这种选择多半也是因为无奈，很多玩家或许是因为新奇而觉得这样的叙事很有意思，确实，不能说da2的故事无聊，但是缺点和漏洞也很明显，我们先把剧情大纲给复习一遍。<br />
枯潮来袭，叛教法师之子霍克与家人逃难到科克沃，在一次矮人矿坑冒险中发家致富，几年后解决了库纳利人的叛乱成为捍卫者，最终面临圣法矛盾的激烈化，并在安德斯的一次恐怖袭击后解决了发布灭法师环令的圣殿骑士领导者梅疯子，圣法大战的时代就此拉开序幕。<br />
只看大纲其实生软的编剧还是有点东西的，有转折，有历史大势，有多方势力的牵扯，看起来很好，是吧，但如果你抛开糟糕的跑任务体验去仔细审视这个故事，你就会发现很难立得住脚。<br />
我猜想啊，14个月的工期一给，编剧拍脑子一想，咱做个小格局故事，矛盾层层激化，来点刺激的，然后开始考虑怎么让角色对号入座，为什么这么说呢，因为da2的故事是典型的情节推动型，霍克从始至终跟着情节走，不是说这么不好，不过da2处理得相对不太行，同年的巫师二也是分三章的小格局叙事，但他们着眼点是主角，杰洛特的立场很明确，找老婆顺便寻回过去记忆，政治那是附带的，他被牵着走，被逼着站队，很合理，互相利用嘛；da2有所不同，霍克从始至终都是城里有排面的人物，就是第一章也是和城里卫队小队长有裙带关系的王牌佣兵，他不能一直被动吧，你da招牌式的自由度呢？<br />
我们来按顺序捋一下故事线，第一章用一些小任务引出了血法师与激进派圣殿骑士两大毒瘤作为引子其实还行，不过霍克听了瓦里克几句忽悠就要下坑道了略显仓促，当然瓦叔是一代口才点满那种人物，系列里忽悠谁谁信，不过下坑道不带安德斯霍克的弟弟就会死着实是个离谱的安排，奥尔加过后大家应当都知道对一个重要人物的出退场不能那么仓促，但奥尔加死的仓促是因为不这么做编不下去，da2是图什么？沃顿和队友杀了不知道多少暗裔，就没受过伤？怎么就你卡沃毒抗负数，你要说是为了霍克成长也不现实，da这种强调主角就是自己的游戏是不会有主角成长的需要的，只能说这段是真的迷惑，除了让卡沃有机会当沃顿没有任何意义<br />
然后进入第二章，这一章的主线是库纳利人线，这段剧情其实写得不错，库纳利人的塑造很有趣，但问题在于二代本就是个内容不足的游戏，着力想展现的圣法之争和库纳利人一点关系也没有，这段想抬升霍克地位的意图实在是明显过头了，再加上一大段剧情给了库纳利人，分散了玩家注意力不说，让圣法大战本就不足的铺垫和描写雪上加霜，当然第二章也有支线，支线讲了什么呢，全讲了血法师是怎么毒害大众的，事实上本作除了第一章有几个法师卖惨，其他的戏份几乎全给了血法师以及安德斯这种激进派，这就导致了一个很搞笑的问题，你说法师不能迫害，但梅疯子一开始也没杀人，你这城市逢一个法师十有八九练血魔法不管你管谁呢？其实圣法之争的核心问题很简单——法师到底多容易堕落，在一代中一个法师用血魔法能屠大半个法环，很危险，但召唤恶魔者本来就是个危险分子，血魔法对他来说只是工具，你要说恶魔诱惑法师有多容易就很难说，同是老血法师的莫姐不就啥事没有，这个问题不挑明，法师的存废很难有定论。<br />
我们再来说说全游戏的高潮——第三章，da2的剧情呈现一个很神奇的现象，你要说层层递进那确实是这样，但递进的未免比较太快了，纵观全游戏你基本看不到什么温和派——无论圣法，对编剧来说激进派确实好用啊，超快节奏推剧情，但对玩家就会感到憋屈。全游戏最激进的梅疯子，她疯吧，但面对霍克这个叛教法师之子，公然的血魔法使用者她一点也不刁难你，霍克还有个顶着精灵和血法师双重debuff的梅丽尔，她也不管，霍克既然这么有面子，那联合一下城里的势力反对她不难吧，结果没给选项，更神奇的是圣殿和法师还有有识之士站出来想把梅疯子杀了，这时候编剧又觉得梅疯子真被保守派刀了结局没得放了，于是让这些人绑架了霍克的家人，这也算了，真密会了还有血法师跳出来把温和派圣殿杀了，你们搞秘密集会成员审查就这水平？放进来个血法师不说还在关键时刻内讧，真的可以，事实上你在游戏里遇到的法师不是莫名其妙疯了就是几乎没有塑造，情节推着所有角色在走，再举一个例子，蕾莉安娜这种间谍头子怎么着也是雷厉风行的实战派了吧，科城的局势像在火上烤，教皇把蕾莉安娜这种重量级角色派来，你猜派来做什么，派来劝现任主教快走，那科克沃怎么办呢，蕾妹连句懂得都懂都没和霍克说<br />
几边都这么随波逐流，主线怎么推进呢，于是安德斯直接开始搞起来恐怖袭击，不得不说这段真的是异常生硬，安德斯前几章还一副弱受的样子没一点铺垫直接搞恐怖主义了，而且搞完还一副为大义牺牲的样子，问题的根源不解决，法师永远会被歧视，这样的情节有什么意义呢，要在魔幻世界观谈政治本就是件很难圆的事情，更别提生软还处理得这么生硬<br />
可能有人会说这样神转折也很震撼啊，但正如我之前说的，奥尔加之死也是神转折，但没有足够铺垫的生硬转折在剧本创作里肯定是要避免的，可以说二代编剧本来应该想写出霍克身为科克沃捍卫者也对历史大势卷携着无能为力的剧本，但实际效果呢，是各路代表不了大势的牛鬼蛇神作死，而我们的霍日天在一边看着准备收拾残局。<br />
我一直坚持在文艺创作领域风格和水平要分开看，就比如我知道二代有很多拥护者，但他们可能大部分是喜欢这种以小见大的叙事风格，而不是充满漏洞的叙事水平，da2虽然我说了他的很多缺点，但生软的剧本虽然很难跻身一流，但保持二流水平还是可以的，剧情演出的信息量能淹没很多人对不合理处的关注便是明证。<br />
Da2故事上的失败很大部分要归因于赶工和工期的匮乏，这一游戏的大部分问题皆来自于此，至于一个世界观宏大的rpg讲小格局故事是否明智，从后见之明的角度看，da2在作为da3的引子方面还算是成功的，但无可否认da2在设定上根本没什么进展，我们要知道dao在世界观构建上只是刚刚展开，还没到成熟的地步，直接在这种半成品框架下讲故事对完善世界观有所期待的玩家肯定不会满意<br />
大部分da2的玩家应该都为这款游戏感到可惜，如果再有一年的时间可能以上的问题能解决个大半，但奈何生软摊上ea这么一个急功近利的老板，而在下一作，生软带给我的就更多是愤怒，而不是惋惜了……to be continued<br />
以下是个人的碎碎念<br />
一代赶路神技加速术居然砍成限时Buff了,而且这游戏强调同性恋是不是有点过了，安德斯动不动一脸弱受的样子，而且那啥院居然还有不问你性取向直接调情的男妓……这算性骚扰了吧，伊莎贝拉一代可没那么黑啊，这是在海上漂了几十年人种都换了？生软搞zzzq真的由来已久</p>
<h2 id="dai">dai</h2>
<p>今天我们要介绍的这款游戏，于2014年以压倒性优势赢得了tga年度最佳，没有任何一个竞争者是与它同一个量级的，gta5，最后生还者为了避其锋芒不得不选择在13年发售，巫师三被吓得跳票到15年，在得知14年有这款游戏后，宫崎英高慌得只得把黑魂三继续打磨到16年，它就是古往今来最强的rpg游戏——龙腾世纪审判！！！<br />
对审判的评价有个很神奇的现象，刚推出的年份似乎风评尚可，但随着时间推移，评价越来越差，这似乎意味着这是一款开创先河的游戏，无论是填充式的开放世界，还是泛滥的政治正确，都在这款14年的游戏中得到了体现，当然我不怀疑生软的目的，毕竟制作组高层就有同性恋，甚至现在看来惨不忍睹的开放世界当初的生软可能真的觉得很好（虽然被第二年的巫师三干碎了）<br />
审判在我心中一直是一部很独特的作品，如果你让我说明da系列的优点，一代的优点不胜枚举，二代我至少可以说风格很独特，三代就比较神奇，它的优点，额，藏得比较深<br />
那我们不妨就先说说它的优点，审判在世界观和时间上的推进上有巨大的建树，我的意思是，填了几个坑的同时挖了更多的坑，生软在下一盘很大的棋，无论是揭开奥莱斯的帷幕，教会的黑暗过去，亦或是把古代精灵的设定全部推倒，都能让我们感受到生软在剧本上的用心，确实，理论上讲，dai的剧情是很有看头的，但生软把自己的缺点推向台前，把优点深藏幕后，让我在玩的时候频频破防，也是真的厉害<br />
我们还是先从系统问题说起，不知道是什么给了制作组勇气，本作的引擎换成了做战地的寒霜，这个引擎对rpg的适配性极差，为了实现存档生软就不得不对其做了大量魔改，乃至系列核心功能的存档继承还要通过一个网站实现（没有中文支持哦），不知道是不是为了照顾主机，即时演算cg还是锁30帧的，配合僵硬的人物动作，让我感觉在看ppt，审判还有一种极为奇妙的油腻效果，你要用在植被景物上我就当做油画风格了，但奈何人物也是这个样子，个个都像青春期几个月不洗脸一样满脸反光，在这里我澄清一下啊，有黑子造谣叫索拉斯“蛋头”，索拉斯什么时候配碰瓷我们鸡蛋了，你家鸡蛋反光到这种程度？<br />
审判主打一个开放世界，什么叫开放世界呢，每个地图给你一堆无聊的收集式支线，跑断腿去吧，此外，除了某些装备词条，审判官没有任何提高那慢的像残废一样的移速的手段，偏偏生软还恶趣味地把地图做的很大，收集式支线的收集品路线拉得很长，如果不修改游戏速度，或者有什么特殊癖好我觉得是撑不下去的，顺便一提也基本没有什么像样的奖励，生软不会真的觉得这种任务能留得住玩家吧，就算14年大家还没有被育碧的填充式开放世界搞得审美疲劳，也不会对这种设计甘之若饴吧<br />
当然了，也有人反驳，又没有强迫你做，不喜欢大可不做，首先呢，为了推主线总归是要做支线积攒势力点的，其次，这也涉及到游戏设计的一个问题，一个叙事向游戏，最根本的是什么，我认为就是像玩家提供信息，一个优秀的的叙事游戏必须在游玩过程中高密度同时高质量的提供给玩家信息，同时这个过程必须是有导向性的，要将玩家的注意力导向最能给予他们信息的方向，因此任务日志里主线永远要在c位，即使是巫师三这种支线质量领先业界的作品，也有粗制滥造纯跑腿的任务，但这些任务流程不会长，也就是，虽然提供不了什么和世界观塑造或者叙事相关的信息，但由于时间短，这段时间的信息密度并没有低到无法忍受，我们看看dai是怎么处理的，首先支线在基本没有信息量的同时，极度磨叽，当然这也就算了，毕竟不喜欢可以不玩嘛，但制作组自作聪明地把这些制作水平极度粗糙的支线，给塞在了日志里，一打开日志界面就是密密麻麻的0/X，我相信但凡是个正常人都会感到烦躁，这就是很失败的一点，它将玩家的注意力导向了最错误的方向，是个极度离谱的设计<br />
同样是为了照顾主机，本作的技能栏进一步精简到了8个技能，8个技能，战士和盗贼都没有过这么吃紧的技能栏，你让法师玩什么？虽然是个人喜好问题，但这种革新是不是有点太过分了一点呢？说实话dai我是一点玩法师的欲望也没有，不是说强度有多少削弱，而是策略选择的灵活性没有了，说到策略，本作更迷惑的一点是取消了战术设定，可以说是向即时act全面转进，da系列每代都有极大的革新，我也不知道是图个什么，我们就当是因为商业利益不得不妥协了吧。<br />
再说剧情和人设的问题，只看大纲，审判的剧情和一代很像，都是主角临危受命杀死大魔王拯救世界的故事，区别也是有点，审判的格局宏大的多，看得出编剧很有野心，一代的费罗登和仅仅提及过的奥莱斯都是本作的舞台，但问题在于呈现的方式，极度草率，我之前说dai是开放世界，其实这不完全准确，因为只有地图和任务是开放的，能去的地方其实就几个，而且大多是荒郊野外，根本不足以展示末日将临下两国的反应，当然生软也想了个办法，就是决策桌系统，说实话这就是个挂机文字游戏，而且频繁进出还很浪费时间，尽管事件很丰富，但寥寥几语文字提供不了多少信息量，一代通过支线我起码看出了点费罗登人应对枯潮的绝望与恐惧，审判恕我直言，完全没什么感觉，当然我不否认主线的几个大事件做的不错，但相应的小格局叙事的空缺让我感觉到这场灾难的苍白，试想一下，审判团之外判官直接接触过什么组织什么人，没几个，是吧。<br />
再说人物，本作的大反派，考爷，不得不说异常苍白，一代的反派洛根虽然傲慢愚蠢但至少性格是有几个侧面的，考爷有什么呢，纯粹的邪恶与野心，其实这样也行，我一向认为刻画人物有两条路，一条是通过各种细节展示其多面性或者成长与突变，一种就是把一个性格特质发挥到极致，比如jojo福音的田最环，就是个坏人，但他诡计多端会演戏，文能严刑逼供心理施压，武能压着吉良和仗助打，这就是把恶这一性格写到极致，但考爷两边都不沾，风头全被我们男判官的好兄弟，女判官的好情人索光头抢走了，真的是惨。<br />
反观入侵者dlc可以说才是真的点睛之笔，回过头来想想，几乎整个审判本体都在给这个dlc作铺垫，不得不说这个dlc确实让我感受到了生软最后的实力<br />
再说队友，其实dai的队友一直给我一种神奇的疏离感，但本着科学严谨的态度，我思考了好一阵为什么会有这种感觉，在这里和大家分享一下<br />
首先是身份上的疏离，一二代的队友都各有各的不同，但总归是人类，精灵，矮人三个基本分类，而且归属上都是费罗登的人，审判就比较神奇，铁牛是库纳利人，科尔是个灵体，其他队友从费罗登奥莱斯两对头，到遥不可及的德凡特，都有，当然这只是最浅显的一点，但身份的疏离明显加大了队友间的隔阂<br />
其次，考虑一下一二代与三代主角的不同，一二代都是有所谓初始剧情的，因此他们都有自己的死忠与初始势力，一代的沃顿初始有同事A哥和受了母亲命令的莫姐两大死忠才开始招募队友的旅程，二代的霍克不仅有弟弟/妹妹还有艾芙琳的支持，更重要的是，加入的队友大部分是孤家寡人，都是孤身投奔梁山的类型，而审判就不同了，初始就有自己势力的卡姐，率部投奔的萨拉，间谍铁牛，法师领袖薇薇安，瓦里克还是霍克的死忠（十年老交情不可能完全站在判官这边）导致判官严格来说甚至没有可以信任的亲信，相反，还要应付各怀异心的队友<br />
最后，对于角色的塑造来说，一共有三个过程，不成熟，成熟，升华，举例来说，一代鲜有不成熟的角色，成熟的利己人格莫姐最后接纳了爱情这是对其人设的升华，成熟的温奶最后决定牺牲自己造福世人，这也是一种升华，一代是不缺少有自己成熟价值观的人物的，看着傻白甜的蕾妹实际上早就身经百战了，而三代不成熟人格就多起来了，卡姐看着霸气，实际上被瓦里克骗了很久，而且天真的没有意识到圣殿骑士膨胀的权力必然导致的对法师的压迫，科尔更不必说，黑墙直到赎罪后才形成了成熟的人格<br />
再说一些其他方面的问题，我是指，政治正确，不知何时起gayware的游戏已经成了同性恋人群的狂欢处了，在尊重同性恋的同时我能请生软尊重一下异性恋吗，队友里能推的只有卡姐？生软塑造女性角色的功底可以说在倒退了，相反的，光头倒颇有一代莫姐的风采，然后是黑人姐姐薇薇安，据我所知龙腾世纪并没有任何关于人种肤色的设定，但我们的薇薇安姐姐就这么不羁地出现在我们眼前，似乎不认为自己在满世界的白皮人中有任何特殊之处，更神奇的是这位姐姐的人设还是交际高手，我很好奇奥莱死的权贵们难道真能把薇薇安当同族看待？据我所知一个明显与交际圈所有人都不同的人，被排挤才是正常操作吧，而我们的薇薇安姐，不仅顶着异于常人的肤色，还有着其貌不扬的一张脸，能成为帝国圈内炙手可热的交际花也是相当励志了。顺便一提，有人说叠buff拿年度最佳是美末二首创，其实是dai玩剩下的，从这点看可以说是非常有创造性的一作了<br />
总的来说，虽然定位上dai是一部中兴之作，但这部作品在最底层的设计逻辑上存在很大的问题，整个路都走错了，如果生软把做开放地图和低质量支线的精力拿来做出一代那种不乏少数有趣支线的线性地图，把决策桌换成各种小任务，那么呈现出的效果必然会好很多，同时，恼人的政治正确，油光满面的建模，浮夸的网游式特效，让审判在外观上都显得不讨喜，我由衷的希望da4里生软能认清自己，摆脱这些乱七八糟的问题。</p>
<h1 id="巫师">巫师</h1>
<p>熟悉我的朋友都知道，我本人是巫师系列的死忠，如果让我给rpg游戏做一个排行，我会把巫师放在第一位，有的人可能会说，巫师固然是rpg佳作，但在浩如烟海，名作辈出的rpg里可未必排的上号，又有的人可能会说，说这么多不过是“情怀党”的矫情而已。<br />
不错，巫师系列对我来说不只是一个游戏，如果说每个人最大的爱好都有一个启蒙物，那么可以说正是巫师，将我带进了那些着重于叙事的游戏的坑。不过与大部分人不同的是，我初次接触巫师系列是巫师的二代。<br />
那是一个普通的暑假，我费力地思考着，家里残破的笔记本电脑到底能玩点什么游戏，这时我突然想到，听说有个叫巫师三的游戏挺有名，我不如试试它的前作好了。就这样我搜到了巫师一二，巫师一画面陈旧，操作蹩脚，我毫不犹豫地排除了它，但二代却有着在那个年代来说不错的画质，于是我找到了它的资源，试着玩了起来。<br />
听到这里可能大家觉得我无非在说一些陈词滥调，但我想说的是，巫师二即使以我现在不知道涨了多少的阅历来看，依旧是一款特立独行的游戏。在此之前我也玩过不少游戏，但我从来没有见过一个没有政治诉求纯粹为了自己的利益行动的主角，我从来没有见过一个每个人都栩栩如生，有自己行事逻辑的世界，我从来都没有见过，一个以阴暗的政治冲突，种族歧视为背景的游戏，即使以rpg来说，巫师二也是个很有勇气的游戏，在巫师二不长的序章过后，就会面临两个截然不同的分歧，并且这两条分支路线的重复内容并不多，如此大的分支毫无疑问是不多见的。现在回想起来，巫师二可能是我唯一一个一点也没有碰支线的rpg游戏，固然因为当时我懵懂无知，但其波澜壮阔的主线确实无比吸引我，<br />
是的，这是一个非常有突破性的游戏，可谓是cdpr写政治戏码的巅峰，但是，很神奇的是，这又是一个被遗忘的游戏，不仅是被引流来的巫师三玩家遗忘，就连cdpr好像也忘了它，巫师三和二代基本没有什么关系，可能有人会反驳我，巫师三的开头就要模拟二代抉择，但事实上，对一个强调选择的rpg游戏来说，重要的不仅是选择，更是选择带来的后果，而巫师二那些惊心动魄的选择，在三代中几乎都成了定局，无论上亚甸是否赢得了独立，最后的区别不过是沦陷在亨赛特的军队下还是尼弗嘉德军队下而已。无论是否救回泰莫利亚最后的王室血脉，罗契都只能带着他的兄弟们再度流亡。更神奇的是二代最成功的女性角色，龙女居然不知所踪，事实上龙女和伊欧菲斯在巫师三曾有过一个现在沦为废案的任务，但因为赶工期被砍掉了。我们对比一下同样三部曲的龙腾世纪，一代的诸多队友都会在二代亮相，甚至还能在三代中当重要角色。而巫师三部间的关联则少得可怜，一代的女主角夏妮在石之心才出场，也就雷索与罗契在三代的戏份多一点，这无疑大大削弱了巫师中选择的分量。当然，我也能理解cdpr，三代是系列中唯一重启主线的一部，与更像外传的一二部有着极大的区别，并且这一作有着不小的制作规模，必须放弃前作壁垒，放低身段吸引新玩家，种种考量下，三代注定是相对独立的一作，更何况在二代一番精心算计下，事线固然优秀，但已经形成了逻辑闭环，也很难找到延续的办法。而三代为了种种考量，强行让南北形成均势，更破坏了延续巫师二剧情的可能性，尽管可惜，但巫师二作为一个完整的故事，也可以称得上优秀。<br />
接下来我们就来讨论一下一款游戏。<br />
首先，依照惯例，巫师二的系统，巫师二的画面在当年算得上不错，但毕竟此时的cdpr并没有太大经验，因此整部游戏的一些地方仍然显得很生涩，比如说，巫师二是没有跳跃功能的，只能让玩家去寻找攀爬点才能上下移动，而这些攀爬点则都做的很隐蔽，配合拙劣的导路功能，跑图体验难言理想，随后巫师二的战斗相比巫师三繁琐不少，同样分为三种流派，近战，炼金和法印，法印有单独的储备槽，能随着时间恢复，这点有点像dnd，近战则有和三代近似华丽但破绽很大的剑术，并且翻滚是没有无敌帧的，也就是说翻滚途中被攻击打断是常用的事。药剂和炸弹都是一次性用品，众所周知，rpg游戏的一次性用品就是不打最终boss能不用就不用的东西，因此虽然炼金流算得上强力，但由于合成的琐碎以及造价昂贵，走这条线的并不算多。总的来说巫师的战斗系统基本都是在及格线上徘徊的水平，实在没有多少意思。<br />
而论起剧情，就很有的说了<br />
巫师二的叙事有什么特点呢？<br />
第一，选择<br />
巫师二依旧采取了巫师系列道德困境式的抉择，有不少人批评说这种列车难题式的道德抉择千篇一律，然而，我很好奇的是，他们指望在一个商业游戏里看到怎么样的抉择设定呢？巫师的抉择可能算不上精巧，但在rpg可以说是独树一帜的有分量，重要人物的生死，一个王国的命运，巫师二充斥着各种意义上的抉择，甚至包括第二章两个截然不同的路线。放眼整个rpg史，我敢说有如此大主线分歧的也是寥寥无几，而这样独特的设计，其实与巫师二的剧情结构有不少关系。<br />
第二，双线叙事<br />
我们的杰洛特一向对政治敬而远之，而巫师二构思巧妙之处在于，让一个对政治最没有兴趣的人成了北境局势的关键人物，在游戏中，双线并进的结构被广泛的运用。杰洛特的态度是模糊的，归根到底他不过是想洗脱罪名并寻回自己的记忆，这两大主线目标，前者为主线后者为暗线，都被牵扯到了同一个人身上——雷索。而对于雷索的刺杀行动而言，女术士集会所的阴谋浮现在明处，而隐藏最深的则是尼弗伽德入侵的阴谋。对于游戏中涉及的北境势力而言，两大对抗者，上亚甸和科德温，杰洛特在游戏中任选其一作为明线，另一方便会成为暗线穿插其中。几条剧情路线互相交叉，且彼此间都有说不清道不明的关系，可以说巫师二颇有些戏剧的风格，重要人物算不上多，但却有着极为复杂的人物关系，整个故事都十分耐人寻味。<br />
第三，演出水平<br />
巫师在剧情演出上向来不遗余力，这点倒是颇有生软的师传，巫师二增强版的开场cg对一个11年的游戏来说可以说无比华丽，而在随后的剧情中，也有不少制作不错的cg的即时演出，更有趣的是，不知道是不是为了赶时髦，巫师二还做了两个系列中少有的巨型boss战，在11年来说，这样的演出效果可以说相当不错了，说到这里不得不佩服cdpr的勇气，只做过一部巫师一就敢砸这么多钱到一个前景不明的项目去。<br />
第四，政治阴谋<br />
大部分宫廷政治故事都是肮脏的，巫师二也不例外，开篇我们就能看到为了自己和妹妹的私生子发动王国内战的妹控王，要说这妹控王也是个有勇有谋之辈，但把自己荒淫无度的行径公开到整个国家民众面前的行为，着实是让人叹为观止。如果你觉得这已经很毁三观了，那么我可以负责任地告诉你说，福尔泰斯特在北境执政者里是道德楷模级别的存在，整部游戏里你碰到的政治家，浮港的总督是个没有下限的人渣，亨赛特是个粗暴蛮横的野心家，此时看上去正常的拉多维德对待自己的恩师也是“无微不至”，就连浓眉大眼的斯坦尼斯王子，都能为了上位一脸坦荡地毒害龙女。<br />
当然了，也有萨奇亚这种浑身坦荡的完美领袖，上亚甸是巫师中难得直接描写非人种族抗争的一段剧情，十分正能量和主旋律，算是难得地调剂了巫师阴暗冷酷的风格，巫师对“义军”的描写并没有落入俗套，龙女一身正气但是并不迂腐，伊欧菲斯虽然仇恨人类，但并不是不择手段之辈，他会对萨奇亚动心，会对救了他的命的杰洛特予以回报，矮人往往看上去豪放，却不失狡诈和算计，而义军中也有斯坦尼斯王子和菲丽芭这种野心家。Cdpr对上亚甸线是很上了些功夫的，多种族混杂的特点被个性迥异的npc完美地体现了出来。可以说，在有政治戏码的rpg中，巫师二绝对是一部水准上的作品。<br />
稍微扯开一点话题，巫师二的最终boss雷索，我个人认为是rpg游戏设计得最成功的反派人物之一，雷索的人物志在b站就有，在此不做赘述，纵观其生平，不得不说无论是公事还是私德上，雷索都是一个近乎完美的角色，公事上为了复兴自己的学派，雷索完美执行了恩希尔大帝的命令，他的刺杀行动无不是计划周详，下手果断，善后的处理的也无可挑剔，甚至面对女术士集会所的谋划，将计就计把北境的大部分术士架上了火刑架，要知道，让术士吃这种大亏，这恐怕是猎魔人历史上都没几个人能做的壮举，更可贵的是雷索在做这些事的时候完全秉持公事公办，各为其主的态度，他没有因为杰洛特是福尔泰斯特的护卫就下手迟疑，也没有把自己兄弟的死记在杰洛特头上，他始终清楚地认识到自己不过是尼弗伽德的一把刀这个事实，即使三代中被恩希尔背刺了一刀，也很难说他会有多么吃惊，而在私德方面，为了答谢杰洛特的救命之恩，他跟着杰洛特去迎战几乎没有胜机的狂猎大军，保护叶奈法，甚至在最后把特莉丝从大屠杀中救了出来，而在整场游戏中，他一次也没有对杰洛特下死手。这种文能算计整个北境的术士，武能压制失忆期杰洛特的全能型人才，实在是比工具人白狼不知道高到哪里去了。可能每个巫师系列的粉丝都对巫师四有自己的想法，不过如果是我的话，我是很希望能有以雷索为主角的一部游戏，这个人设实在是太强了。<br />
上述是我个人认为巫师二的优点，不过如果你要问我有没有缺点，那我也可以很明确的说，有的，而且还很明显，并且这个缺点贯穿了整个巫师系列。<br />
我们知道，rpg的意思就是角色扮演游戏，意思就是可以让玩家扮演一个虚拟角色在一个虚拟世界中做出种种行为，巫师系列是21世纪rpg的一大系列，但巫师却并不是一个完全标准的rpg，为什么呢？因为杰洛特是有性格的，杰洛特大体的性格是，外冷内热，自尊心强，外表冷酷无情，内心深处其实是一个傲娇老好人，这样问题就来了，你杰洛特都有性格了，那玩家怎么做选择，cdpr的回答是，尽量把所有选择都做成两难式的，即使是杰洛特本人来选也会犹豫的那种，这也是为什么cdpr总是喜欢这种两难抉择的原因，但还有问题，总有一些真正的杰洛特不会犹豫的选择，比如说真正的杰洛特必然是椰奶的舔狗，而面对这种选择，玩家只能扮演自己，这就让巫师的剧情流程也有了一种割裂感，你是要扮演杰洛特还是扮演自己，这是在你打开巫师游戏前要先做出的选择。当然，两种选择都无可厚非，但这也必然会造成一些矛盾性的情况，像巫师二里，无论哪条线路，不去救特莉丝都会都会对游戏的重要角色大有益处，作为玩家，如果你查了攻略，你就会知道好兄弟雷索会帮你把萌特救出来，然而如果真让杰洛特选他绝对不会放弃自己的情人，也就意味着，要么玩家放弃选择权，要么就要忍受杰洛特的ooc（人设崩塌）。<br />
我个人觉得这是个不大不小的问题，只要做好心理准备还是能忍受的，毕竟一个小说改游戏，碰到这种问题也是难免的，cdpr其实已经把平衡性做的挺好了，没必要太苛求。额，如果这也算孝子那就算吧，不狡辩。<br />
回过头去看，巫师二确实是一部难得的rpg佳作，但它未必是一个合格的承上启下之作，巫师二讲了一个太过精彩的故事，导致接下来不怎么好编了，尼国平推北方顺理成章却很无趣，北方反攻又是天方夜谭，导致巫师三的政治形势显得十分强行，迪胖和拉多维德其实都像开了挂一样，要知道，历史是没有个人英雄主义的，区区一个统治者就能逆转尼弗伽德和北方天堑一般的差距吗？这多少有点机械降神了。这么说来巫师二某种意义上近乎把故事讲死了，不过如果我是cdpr估计也会很无奈，小说基本已经写到恩希尔大帝快一统天下的地步了，巫师由于以杰洛特这种政治无关人士作为主角，搞点宫廷刺杀已经是政治戏的极限了，还能怎么编呢？<br />
写到这突然想到，巫师三里曾经对雷索喊打喊杀的杰洛特也成了“国王刺客”，这可真是，人终将活成自己最讨厌的样子。</p>
<h1 id="影子工厂">影子工厂</h1>
<p>我本以为影子工厂会如简介说的一样，会是杂糅诸多风格的悬疑风，故事的一开始也的确如此，时间穿越配合豪宅血腥谋杀的经典模式别有一番风味，不过结合前传一贯的发展，不难想象出而在这之后又回到了我们熟悉的时间轴环节，比较特殊的是，这次高瞰老师罕见地采用了正叙的方式，而且此次的故事出奇的平淡，尽管感情上依旧无比细腻，但几乎没有什么出乎意料地发展。<br />
而事实上，高瞰老师擅长的叙事诡计只是换了一种方式呈现在我们面前，这是一个一位身患绝症的女性在生活和事业中苦苦挣扎，在经历了孩子的夭折后，最后选择了事业的故事，尽管这个故事占了整部游戏大半的流程，但其实它本身并不是重点，因为在开头，影子工厂的主线就被堂而皇之地摆在了我们的面前，豪宅层出不穷的死亡案件，于是，在历览了女主的人生后，真相的追寻才真正开始，当然了，故事如何这里就不赘述了。<br />
当然，相比前两作选材的独特，和层出不穷的叙事诡计，影子工厂显得平淡的多，正如lynri所说，昆西相比两位博士不过是一个观察者而已，他对于挚爱的lynri无能为力，面对自己不过是模拟的数据也无能为力，他的一生没有什么狂乱幻想，也没有多么丰富的内心世界，尽管他的内心是强大的，不过依旧没有什么意思。当昆西历览lynri的记忆时，我们会发现相比博士的聒噪，大部分时候他不过沉默地接受着，评价这一环节是在这段记忆中缺少的。而让这段记忆，一个不是最重要的故事占据叙事的大部分是可以的，但问题在于这一部分必须要穿插主线，否则会产生严重的割裂感，而就影子工厂来说，很难说这一部分和主线有着多大的关系，是否手术的分歧导致了之后的一切，但要拼凑出真相，我们需要知道的除了这个世界不是真实的以外，还有分歧点在于保大还是保小，以及lynri的姓氏，而这两点都没有结合进这个过程。抛开叙事结构，如果我们只看这个故事本身，昆西的爱情故事虽然不能说不好，但比起前作的惊艳未免显得俗套。可以说，如果把这个故事大刀阔斧地砍几笔，也不会有多大的差别，当然，就故事的首尾而言依旧是很有趣的。<br />
不过即便如此，我也要说影子工厂是一部水准上的作品，它有着层层递归的脑洞，优秀的人物塑造，最重要的是，它还展示了高瞰老师填坑的一点点意愿，虽然到最后我们也不会知道两位博士之后到底会怎么发展。而对于系列中虽然重要但没有认真探讨过的记忆编辑技术，影子工厂也表明了一种态度，就是尽管这可能看上去虚无的，但就我们个人所及的知识与眼见来看，只有有过美好的时刻，它就是有意义的，这是一种积极向上的态度，尽管这只是一种态度，但对于虚无与否的讨论大部分时候都只能取决于我们的态度。能以合适的形式传达出这样的观点，就是一部很好的作品了。</p>
<h1 id="不予播出">不予播出</h1>
<p>吉姆哈克：当一个国家走在下坡路上，必须有一个给它踩一脚油门。<br />
你生活在一个贫富差距分化严重，外部国家敌意渐升的民主国家，而在此危难关头，一个名为先进党的政党，凭借集体主义的价值观，以及消灭富人扶持穷人的竞选纲领上了台，时代变换的帷幕在你面前缓缓拉开，这时，你能做什么呢？<br />
<!-- more --> 这大概就是不予播出想呈现的故事，这个游戏是我认为近年zz题材最出彩的一部独立游戏。<br />
我们先从游戏的形式说起<br />
它选取了一个很少见的视角——电视台导播，也就是在电视内容被播放前负责镜头切换与简单后期音效处理的一个职位，这是一个虽然默默无名却十分重要的职位，制作组对此的选择非常高明，在这个位置上你能接收到一切媒体信息，同时决定哪些内容会被最后播出。<br />
游戏的背景设定是魔改版的80年代英国，想想就知道在这个电视台的黄金时代这个职位意味着什么。<br />
在我们这个娱乐至死的年代，恐怕我们的印象中很难会有什么凭良心的办事的媒体人，但在游戏中，随着举足轻重的影响力而来的同样还有巨大的责任，我们可以看到游戏的封面是一个被操控的提线木偶端坐于导播台前，这似乎预示着你不过是政党口中的喉舌，事实上，面对zz大势，大部分时候你确实是无力的，但总有一些事是你可以做的。游戏中，你能做的包括切换各种机位设置，添加后期音效这些普通的工作，你也可以转而接收反对党的信号，甚至在暗中支持他们。<br />
可以说这样的玩法绝对算不上丰富，但是，为了这些内容制作组拍摄了极为大量的采访，节目，等等实景拍摄，这些作品的文案，演出水平都极为突出，也就是说，让你去观看这些节目，决定他们如何被呈现于观众面前，才是它的核心玩法。<br />
于是，我们可以说说它的剧情了。<br />
我为不予播出的剧情概括了一些特点，首先是荒谬性<br />
国家晚间新闻，是一家有不少zz性的电台，在游戏的一开始，作为新上任的导播，我们的第一次工作就见证了前文提到的先进党的上台，在游戏的一开始我们能感受到强烈的荒谬感，就拿先进党举例，该党的带头人是一对夫妇，丈夫粗俗不堪，而妻子却圆滑世故，这样一对其貌不扬的夫妇在自己上任的第一天就大声向“富人”宣战，我们知道，如果对这些拥有大量资产的人过于苛刻就会造成大量资产外流，对此这对夫妇甚至采用强制手法禁止他们出境，这对一个“民主”国家而言恐怕很难想象，更为魔幻的是这样的举措确实赢得了大众为他们叫好，收归民有资产为国有，强制推行福利政策，提倡集体主义，一副宏伟的蓝图就这样在我们面前展开，即使对民粹主义者来说，这样狂野的改革恐怕也有些吓人，而这些种种举措以极快的速度在游戏中发生了，并且让你切实的体会到厉害之处——也就是游戏中各种惊慌失措的小资产阶级。如果你问大资产阶级咋样了，就有限的情报来说，似乎他们在与国家合作后过得很好。<br />
这是一家很有煽动性的政党，但如果你细细去看他们做了什么，建立国家养老机构（把老人送进去就可以不管了）成立青少年队伍（洗脑从娃娃抓起）半强制推行政党性而不是国家性的身份卡（很明显，只是后续动作的开始）甚至把反对的国家的个别城市用特工安置的核弹统统炸上天。<br />
很荒谬，不是吗？但这些事情确实如此发生了。</p>
<p>如果你很好奇对此的政治评论是怎样的，那么我们很快就会见识到该游戏另一个厉害之处——现实性的缺席。<br />
在游戏的一开始国家晚间新闻是一家较为严肃的新闻频道，但随着游戏的进程，娱乐性的报道和节目越来越多（而且不乏先进党资助的无聊作品），这次过程中有着不少精妙的讽刺，例如领着先进党资助大搞政治正确的校园舞台剧组合，光明正大搞热水器的女明星等等，此时在早期的一些政治性节目中，也有不少让人啼笑皆非的人物，例如奉行白人至上主义，热爱sm的警察局局长，似乎几个小丑粉墨登场就能谈起国家大事。作为理应为公众揭露真相的媒体，自己就陷入了娱乐至死的泥潭<br />
不过他们又能怎么办呢？对于一个奉行强权政治的政党，让一个电视台说不了真话简直太容易了。所以我们在游戏中看到的趋势是，节目变得越来越无聊，又臭又长，当批评声变得刺耳，那么连赞扬得不够卖力也成了罪责。<br />
但游戏中依然有着保存着良心的媒体人，杰里米的爆发大概处于游戏中期，他挟持了摄像头，指责所有人都失去了说话的勇气，随后自绝于心爱的镜头前。这段的演出可以说全游戏最大的一个亮点，荒诞的现实与理想的缺席构成了极大的对比，将游戏荒谬而现实的矛盾感体现得极为突出。<br />
然后，我们要说到极端意识形态题材作品的一体两面——压迫与反抗<br />
哪里有压迫，哪里就有反抗，对于极端意识形态题材而言，对其的呈现与对反抗的呈现是一枚硬币的两面，与其他反乌托邦作品伟光正的反抗者不同，不予播出的反对者仅仅是走向了另一个极端。在游戏中有一个明确的反对者——打断组织，这个组织是什么样的呢？很大程度上可能由一些小资产阶级与无产阶级组成，面对集权，他们选择了暴力，游行，破坏，暴动甚至军事政变，我们很难说打断是一个多好的选择，事实上他们根本没有提出什么解决方案，似乎只是因为自己的利益受到了侵犯而已，在游戏的结局我们可以看到打断组织不过是军方扶持的傀儡，用完即扔。<br />
再说回先进党，这一党派在游戏的中期收到全世界的敌视与孤立，不得不进行完全的内循环经济，究其原因，或许是对有产阶级的镇压并不符合经济全球化的要求，从而招致了其他国家的敌视，随后，他们向全世界部分国家的城市引爆核弹，建立起核威慑。 试问，如果你是一位普通人，你能做出什么样的选择呢？<br />
说到这里，就不得不说不予播出另一个有趣的机制——在导播工作的间隙你将以视觉小说的形式看到作为普通人的自己如何在政治的漩涡中生活。与电视上光鲜亮丽的报道不同，即使作为被济的穷人，你也不过是从一贫如洗走向负债累累而已。<br />
恐怕根本没有什么更好的选择。<br />
最后，我们应该回归这部游戏贯穿始终的特点——讽刺性和娱乐性<br />
可以说，这部游戏最终呈现的是一个荒谬的世界，在政治领域极端，疯狂，暴力构成了它的底色，这也是我称其为极端意识形态大乱斗的原因<br />
你要问这样的构建是否过于疯狂而丢失了真实性，而且想要展现这样的世界观一个导播的视角也远远不够，可能的确是这样，但我认为这样极端之间的碰撞反而能增加不少的戏剧性。<br />
可能根本不会有这么极端的政党，可能如此极端的政党根本得不到如此多的武力支持，或许吧，但说到底，这不过是个讽刺性游戏而已，用夸张的手法实属正常。<br />
而在政治以外的社会领域呢？滑稽，疯癫，娱乐才是它的主题，你可以看到收藏大粪为乐的清洁工，无法控制肠道蠕动放出气体的“病患”等等极为魔幻的人物登上荧幕，可以说，游戏中所有的人物都是经过夸张化和娱乐化的，即使抛开政治性，你也可以当笑话看。这是我很欣赏不予播出的一点，它并不完全正经，但绝对有趣。</p>
<p>最后，做一个总结吧，根据关键节点的选择不同，游戏一共有14种结局，有一家独大，有天下大乱，也有非极端派兴起，这些结局有的因你而起，有的不过是大势所趋。不予播出从一个导播的小人物视角出发，呈现了一个极端意识形态偏向的荒谬社会的百态，有戏剧性的加工，也有对真实世界的化用与讽刺。<br />
说实话，政治讽刺题材的乐趣不正是在此吗？</p>
<h1 id="步行模拟器">步行模拟器</h1>
<p>步行模拟器，在本视频中取操作只局限于步行和一些简单动作，主要获取信息的途径为阅读和观察的游戏，这是一种颇为先锋，也颇为小众的游戏类型，在其中有一些火到出圈的佳作，也有缺点明细的庸作，但都有着共性在其中，今天，我就用一个业余爱好者的身份来浅析一下这类游戏。<br />
我们先从步行模拟器的历史说起，由于我不是专业人士，也不是什么老玩家，所以只能大概地说说。<br />
溯及这类游戏的根源是一件很难且没有必要的事情，所以我们只把目光放在本世纪好了，在2007年，一个传奇的年份，当时的游戏界见证了巫师一，质量效应一，刺客信条一等传奇系列首作的诞生，也有一些人注意到一款名为《亲爱的艾斯特》的奇异游戏，对一个原教旨主义者来说它可能算不上游戏，玩家操控着一位失去妻子的男人在孤岛上步行，整部游戏唯一的信息来源就是沿途的风景，壁画，以及男人的自言自语，某种意义上这带来了一种推理小说式的体验，你需要在文本中领略事件的来龙去脉，同时体验它压抑深沉的环境氛围。<br />
亲爱的艾斯特取得了意想不到的小范围成功，本作为免费游戏的它在12年发布了付费版，并取得了80万的销量，可以说，近十年的步行模拟器很大程度上是由它启蒙的。<br />
因此，以12年为分水岭，逐渐涌现出不少的步行模拟器游戏。<br />
13年亮相的是著名的meta游戏史丹利的寓言和较为平庸的到家（gone home）<br />
14年问世的是解密风的伊森卡特的消失<br />
15年艾斯特的工作室发行了同类型的万众狂欢<br />
16年则有看火人与弗吉尼亚出现<br />
而在17年，此类型的集大成者，艾迪芬奇的记忆横空出世，成为了此类型至今为止的最优者<br />
可能不少对此类游戏毫无兴趣的玩家会好奇，步行模拟器的卖点到底在哪?<br />
在这个媒体资源空前丰富的时代，每个人都能输出自己的思想，因此思想的输出变得极为廉价，而接受者的地位却会被拔高，因此，门槛越高的思想输出方式就有着越大的不被接受的风险，导致晦涩隐喻的内容就会不受待见。尽管如此，这些晦涩的思想与表达依旧是存在的，步行模拟器就是一种方式。<br />
事实上，接受他人的思想表达一直都有很大的风险，只要作者多加一点私货，或者在莫名其妙的地方整个活，接受者的思想就会收到极大的冲击，例子我就不举了，懂得都懂。所以很多人都会倾向于不去接受，晦涩的作品他们根本不会碰，也有的人沉迷于此类快感，不顾风险地追寻自己认为好的输出者，这两种选择没有高下之分，但体现在游戏上，我们就会发现后者经常会成为所谓的小众游戏爱好者，这并不意味着他们很优越，相反，他们可能已经踩过不知道多少雷了。<br />
为此前的论述做一个总结，步行模拟器可以作为一个高门槛的思想输出方法，因此能吸引一些喜欢此类体验的玩家。事实上，它和同样强调探索的avg可能存在一些关系，但由于我对此没有足够的知识，就不献丑了。<br />
在此基础上，我们来分析此类游戏的一些特性。<br />
首先，第一个问题是，为什么要用步行模拟器这种形式，毫无疑问这种游戏的互动性基本不是很强，也没有刺激官能的要素，然而，正是因为这种自断一臂式的操作，让它能够把自己的叙事能力提高到大部分游戏所不能及的程度，玩法单一也就意味着玩家的注意力会完全集中于一点，制作者只要专注于此方面，就能高频度地向玩家提供信息，而不会让人一头雾水，因为这样的特点，相比大部分游戏，步行模拟器可以聚焦于很多与众不同的题材，可以选用不同的叙事方式，<br />
另一个优点是，较小的游戏规模与如今相对成熟的游戏工业，让制作者能以较为低廉的成本做出不同的场景，美术效果和环境在步行模拟器中有很大的作用，我之所以这么说，不仅是因为它有着渲染气氛的作用，在很多此类游戏中，环境本身就承担着叙事的任务，尤其以艾迪芬奇的记忆而言，环境在这款游戏中达到了当代游戏的新高度，不同的房间布置在无言中传达了房间主人的个性，甚至在一些细节中暗示了主人的命运。可以这么说，在很多步行模拟器中，环境有着超越装饰的作用<br />
步行模拟器还有一个特点，那就是它是第一人称的，你可能单纯地觉得这是为了提高代入感，但事实上，因为互动性的匮乏，步行模拟器往往更趋向于探索和体验，而不是扮演，更形象的说法是，在步行模拟器中看到的是别人的故事，因此在我看来，第一人称更多的意义是类似侦探小说的叙述主体，也就是说，以这个故事而言，第一人称对应的角色就是最适合展现故事全貌的人，同时，这个主体具体的身份也可以是一个谜题，伊森卡特的消失，艾迪芬奇的记忆都在这方面上做了文章，非常有趣。<br />
上述特点事实上还是很笼统的，实际上的步行模拟器在风格和题材上都是各具特色，特点也不尽相同，但由于到目前为止出名的步行模拟器实在不多，所以我们就用穷举的方法来说说这些步行模拟器。<br />
先从最早的亲爱的艾斯特说起<br />
在所有步行模拟器中，艾斯特应该是互动性最低的一个，你能做的只有控制一个喃喃自语的男人在孤岛上乱走，然而，艾斯特依然是一部很优秀的游戏，优秀的文本质量和环境建模完美地融合在了一起，配合迷雾重重的故事，与四个风格迥异的场景与种种细节，成功营造出了一种哀伤中透着迷幻的气氛。虽然选取了悼念亡妻的题材，但艾斯特并没有直接表现哀伤，叙事主体的男子呈现的态度是思辨的，其文本很有些深度，艾斯特的氛围塑造与文本水平，我个人认为是步行模拟器中最优秀的之一，并没有被后来者超越，甚至也没有被他们自己超越。<br />
史丹利的寓言<br />
这游戏很难归类，它更为众人所熟悉的标签是meta游戏，举个不恰当的例子，meta游戏和游戏的区别就像文学批评和文学的区别，很难说史丹利的目的是对游戏这一创作形式进行批判还是呈现一段故事。<br />
这游戏几乎是靠作者一个人的天才撑起来的，即便在meta游戏中有史丹利寓言这么强烈批判属性的游戏，据我所知也是不存在的，它很有创设性的给予了游戏四个视角两个阵营，呈现者阵营的游戏系统（游戏作者？）与旁白，接受者阵营的史丹利与玩家本人，史丹利的故事几乎都是两个阵营间不同角色的互动，它实现了大部分游戏都做不到的一点，即让玩家直接与游戏的底层逻辑对话。<br />
现代游戏互动性的本质是什么，无非不过是选择而已，拟真度高的游戏也不过是多提供了一些选项，史丹利抓住了这个底层逻辑，因此哪怕是步行模拟器这一形式只要用好“选择”，就不会缺少互动性。<br />
这样的策略让史丹利显得不是那么“步行模拟器”，但实际上这还是一部叙事游戏，只不过它的故事千变万化，且富有批判意味，而且它的叙事有着“选择”的成分，因此它包含了十几个不同的故事。<br />
归家<br />
归家是一部很有实验意义的作品，如果你情商比较高的话，应该就知道我的意思是这游戏有着不少的缺点，归家的故事发生在20世纪末的一个美国家庭，一个暴风雨之夜，家中的姐姐回到家中，发现妹妹离家出走，于是开始寻找原因，归家的核心机制是拾取/查看物体触发回忆，核心谜题则是揭开妹妹的下落，然而这游戏的故事非常简单，简单到什么程度呢？在触发前三个回忆后你基本上就能猜到故事的梗概了——没错，一个俗套的恋爱被父母反对然后私奔的故事，稍微有些不同的是，主角是两位女同性恋，此外，游戏中有一些不怎么明显的机关且缺乏提示的机关，总体感觉实在是索然无味，尽管某种意义上它为有核心谜题的步行模拟器树了一个榜样，但论其素质十分乏善可陈，最大的优点可能是还算有20世纪风格的家居布置。<br />
值得一提的是ign给了归家9.5的超高分，对ign来说这种分数是很少见的，我们之前提到的艾斯特得到了8分，史丹利寓言得到了8.8分，而品质平平的到家则得到了9.5分的超高评价，并且编辑的评论是没有缺点，联系其故事题材，此件原因令人深思，因为涉及敏感话题，我就不多说了<br />
伊森卡特的消失<br />
这是一部很有风格的作品，在场景建模上制作组创作性的采用了结合实景照片的做法，因此画质显得极为真实，配合微恐怖的风格，代入感极强，游戏的内容是一个有着回溯犯罪现场能力的侦探应伊斯卡特的邀请调查一个据说有着不可名状怪物的地区的系列凶杀案，抛开几乎为0的地图指引，游玩过程中你会觉得这似乎就是一个普通的解谜游戏，虽有称道之处，但综合来看质量一般，然而，这款游戏最值得称道的一点是，制作组为了一个有极大反转的结局在流程中埋了不少伏笔，因此伊森卡特的结局在我看来在叙事游戏中算最优秀的一档，当然实际上这也是见仁见智的一件事，或许也有不少人觉得铺垫不足。<br />
在步行模拟器中悬疑风格的作品伊斯卡特应该可以说是最成功的。<br />
万众狂欢<br />
这是一部和亲爱的艾斯特风格迥异的作品，它没有叙事主体，玩家以超然的眼光去回顾一座村庄全员蒸发的惨剧，我认为这是一部失败的作品，为什么呢。作为一个拼凑出故事全貌的游戏，万众狂欢很不幸的选择了把最大的悬念放在开头——凶手是形似光球的不可名状生物，而游戏的过程则是目睹居民怎么一步步迈向死亡，整个过程中的互动，只有不如不做的触发回忆过程有——跟着手柄按QTE。具体到故事，恕我直言是很无聊的，寥寥几语的场景中大部分缺少让人身临其境的氛围营造，整部游戏有着浓郁的宗教风格，因此部分场景会有种神圣感，但也就仅此而已了，没有悬念，没有细腻的情感，没有复杂精彩的故事，更没有氛围的营造，万众狂欢在我看来是一部平庸的游戏<br />
看火人<br />
在众多步行模拟器中，看火人是极其冷门的纯写实题材，它选取了森林看护员这一冷门的职业视角来叙述故事，然而它的美术风格却是抽象的大色块风格，这造就了看火人实中有虚的奇妙质感，不论看火人的故事如何，这样的题材与美术创新是优秀的且值得鼓励的。<br />
主角亨利在爱妻患病后心灰意冷，因为酗酒被妻子家人排挤的他最后来到了荒无人烟的森林公园成为了火情瞭望员，我们可以看到，游戏的主题几乎已经确定为心灵的救赎，但看火人的呈现方式是特别的，因为职业的特殊性，从始至终能与亨利交流的只有一位名为黛利拉的女性，在一片孤独的瞭望塔中这似乎是亨利唯一的情感支柱，事实上，看火人最大的优点就是情感的细腻，整个游戏几乎就是亨利与黛利拉互相的情感激励与救赎，最后这场类似柏拉图之恋的关系随着因为火情观察员撤离而收尾。<br />
值得一提的是，看火人神奇的在游戏中夹杂了不少悬疑的成分，这让看火人的基调显得有些奇怪，由一开始的悠闲巡逻转到紧张的解密，随后又在急转直下后收尾，尽管不算无聊，但前后依旧有割裂感。<br />
尽管如此，凭借细腻的情感描写，看火人依旧是一部优秀的游戏。<br />
弗吉尼亚<br />
这是一款很奇特的游戏，即使在步行模拟器里，它也是交互性最差的一类，它使用了一种极为抽象的风格，整个游戏由很多不明所以，充斥着象征的片段组成，而将这些片段串联到一起不过是一些点触的操作，坦白的说，我只能分离地去欣赏这些场景，单从象征的角度来说这些场景单独拿出来还挺有意思的，但你很难把这些片段连起来，事实上不让你把他们连起来可能正是这游戏的目的，此外，该游戏使用了很罕见的古典风格配乐，配合上本就很魔幻的内容产生了一种难以言喻的奇特的氛围。总的来说，这真的是一个很难评价的游戏，如果你有些猎奇心的话倒可以尝试一下<br />
艾迪芬奇的记忆<br />
艾迪芬奇的记忆是一款很优秀的游戏，但它的意义不仅如此，可以说在对互动性的新尝试方面，艾迪芬奇是游戏界最前沿的一个，游戏在叙事上最大的优势就是互动性，大部分游戏选择了剧情分支，qte之类的通解，而艾迪芬奇的记忆则在此基础上作出了创新，单论最简单的字幕，往往只被放置在屏幕底部用于阐释信息，而艾迪芬奇则将它放置在了场景之中，伴随着主角的前进逐渐浮现在路边，如此一来字幕甚至兼任了指引的作用。<br />
依我看来，艾迪芬奇的主基调可以用魔幻二字来概括。随着艾迪依次探索旧宅，我们进入了一个个家族成员死前的景象中，但我们透过屏幕看到的不仅仅是一个个纪录片式的景象，还有情绪的具象化，例如令人啧啧称奇的操纵漫画中的角色一段，操纵角色在悬疑漫画的分镜中行走，这是一种崭新且绝妙的传递恐惧感的方式，艾迪芬奇的互动形式总是新颖的，角色伴随着开罐头喃喃自语，在切鱼的流水线上展开与工作融为一体的幻想，手柄的两遥感分别控制现实与幻想世界，此类新颖的设想，艾迪芬奇有近十种，可以这是一款极为奢侈的堆砌创意的游戏。<br />
艾迪芬奇的家族大都耽于幻想，他们的幻想往往与现实融为一体，以此呈现出的情景显得分外的魔幻，以游戏的形式来叙述这样的故事，这一模式提供了一种特别的审视真实世界与内心世界的视角，这样类似魔幻现实主义的创作手法可以说极为前卫和有趣。<br />
毫无疑问艾迪芬奇的互动性与创意是它最耀眼的闪光点，在此的映衬下，艾迪芬奇的剧情似乎显得暧昧不清，多个家庭成员的死亡都没有得到明确交代，尽管在一个个情景中我们能在画面中感知到情绪的具象化，尽管艾迪芬奇家族一向有着早死的诅咒，但艾迪芬奇没有，至少没有直接透露任何家庭成员对于死亡的看法，在一部探讨死亡的作品中这点显得很奇怪，似乎它只想将死亡本身呈现出来，却不想对此发表任何议论，我们很难说艾迪芬奇有什么主旨，在死亡这个主题上，制作组显得分外的冷漠，只留下玩家在原地回味。Steam上艾迪芬奇的商店页面有这样一句差评，艾迪芬奇的记忆有着美化死亡的嫌疑，这对那些有自杀倾向的人来说似乎太不友好了。这并不是没有道理。<br />
总结<br />
步行模拟器始终是个小众的品类，它固然有着一些创作上的优点，但成本和受众的因素始终制约着这一类型，导致作品寥寥无几，但在步行模拟器其实不乏对游戏这一创作形式的革新，作为新时代的叙事向avg游戏与独立游戏的一大阵营，步行模拟器的身上其实或多或少蕴含着电子游戏未来的一大方向，即作为有才能的作者表达自己的一种方式，对此我报以极大的期待。</p>
<h1 id="杀手47">杀手47</h1>
<p>2022年一月份，杀手3将解除一周年的独占，登录steam，而早在21年初，杀手3就成了一款有点话题性的游戏，这是因为游戏的一张重庆的地图，这一地图因为缝合了赛博朋克，老大哥等元素被指责有乳制品嫌疑。<br />
在仔细讨论这件事前，让我们先来看看这是一个什么样的游戏。平心而论，作为一个系列续作，杀手3可以说还算合格，虽然刺杀方式上有缩水，但看得出制作组在氛围营造上投入了不少努力，有很多截一帧就是壁纸的远景或者特写。杀手系列可以说是一个好游戏，甚至可以说是刺杀游戏这一细分品类的霸主，但ioi是纯纯的懒狗，犯下了版本混乱，高价低质量dlc，违背承诺种种重大错误，ioi并不是一个好开发商，如果你骂ioi，我举双手赞成，但对杀手三3有没有乳，我认为还是要谨慎讨论。<br />
我所好奇的是，杀手是不是一个拟真的游戏？<br />
我想只要你玩过这个游戏，你就会知道答案是否定的，即便是游戏的核心——刺杀系统，也有很多方案并不具有现实可行性。，如果说起其他设定，就更没有真实性了，杀手三部曲的反派是一个势力遍及全球，由“社会精英”组成的阴谋论组织，我并不认为这样的组织有什么现实可行性，如果我们这种普通人都能知道这样的组织，那只有两个可能，1这样的组织情报保密工作很烂，那它早该被拿下来了2它故意泄露的，实际上我们对它一无所知，那就让我们一切的想法都成了臆测，阴谋论是一些无法质疑的假设，这样的假设我可以提出几百个。<br />
当然，我们没必要对一个游戏上纲上线，即便涉及到阴谋论，也只能说杀手并不是一个拟真的游戏。那么，作为一个涉及到多个国家刺杀目标的游戏，杀手对其中的国家是怎么描写的呢？<br />
摩洛哥在杀手里被描绘成政府软弱无能被军阀控制，甚至准备发动政变，我们且不论这是不是真的，无论如何这都不是什么很友好的描写，我们提到过的阴谋论组织的一位高层在法国有一个大葡萄酒厂，很符合我们对法国的刻板印象吧，然而这位律师有私人武装，甚至包括一队直接听命的狙击手，我想法国不会放任私人权利到这个地步。孟买的街头扛着步枪的武装士兵到处走，北欧的高端别墅区一栋不算特别大的别墅有十几个全副武装的保镖，这些对我一个中国人来说都觉得不合理，可见杀手这个系列根本没有多少写实性。<br />
我们可以做一个总结了，无论从什么角度看杀手都不是一个贴近现实的游戏，特别是在zz方面，尤其口无遮拦，什么都编的得出来。<br />
那让我们再看看重庆这张图，这张图有什么呢，赛博朋克+老大哥，大量的监控摄像头，华人街一样的街道和餐馆，秘密暗杀组织的不人道实验，改造人类街头的流浪汉，我们之前也说了，杀手的地图里编的成分很大，更何况设定上ICA最重要的实验室就在这里，与其说ioi想还原什么地方，倒不如说估计是他们看到一些关于重庆很赛博朋克的新闻，然后觉得可以蹭一下人设。试问这些元素有多少是真正不合适的呢，脑子正常的人都不会觉得现在有技术能操控人的思想或者改造人类吧，既然你不会觉得这些情节是真的，你为什么会觉得这座城市是真的这样呢？<br />
当然，事实上这样的论述也是有模糊性的，你可以说不够还原就是不够尊重，也可以说法国，美国的图比中国的还原是歧视，在国际矛盾激化的今天，会在这样的事上比较敏感可以理解，但我想说，我希望并呼吁大家在至少在文娱领域多一些宽容，不要泛政治化，能疑罪从无就不要恶意去揣测。<br />
47的目标有很多罪不至死，为了一己私欲杀死无罪者，这难道不是宣传不良价值观吗？但恐怕没人这么批评，为什么我们会在道德上对文娱作品这么宽容，在政治上却那么草木皆兵呢？<br />
我很希望大家能多一些宽容，我也希望文娱作品无论何时都应该是一片不被zz过分染指的净土</p>
<h1 id="被封锁的涩谷">408被封锁的涩谷</h1>
<p>希腊神话将命运女神履行职能的过程写作织网，这无疑是一种极为贴切的比喻，对网状结构来说，在中心处的轻轻一拨，边缘处就是极大的震动，越是深入核心，就越是复杂，但所有分支无论看上去多么没有规律，最后都会收束到中心网点，我想这就是428的编剧想实现的叙事结构。 这样的结构需要极致的严谨和巨大的工作量，正如正统的本格派推理一样丝丝入扣，同时还要维持各个部分的信息量尽量均布，各个网点处都有关键悬念留待读者，但，他们做到了，7位主角的命运与城市里大大小小配角的命运，就这样纠缠在一起，并收束到了一个巨大的阴谋上，更令人称奇的是，尽管使用了这样的结构，制作组仍然做到了悬念的均布，几乎没有出现信息量失衡的情况。<br />
于是，玩家得以在4月28日的涩谷当一天的命运女神，只要在一个个节点上轻轻拨正些许紊乱的蛛丝，蛛丝就会自然而然地化为网状，事实上没有我说的这么轻松，因为这些命运的线条起初似乎是绕成一团，理清它们的过程也少不了误解和错误。<br />
为了确保这个过程的顺畅，85个bad end大部分都有提示，以每一小时为节点，只有理清一小时内的所有事件，命运才能向前推进，起初似乎是一些不成规律的线，但逐渐就开始交错，纠缠，而作为有着神力的玩家，只需要制造一些偶然，改变一两个小小的决定就能够造成一连串的蝴蝶效应。<br />
对这种操控命运的讨论很容易回到一些宿命论的思潮上来，幸运的是428的编剧在这个方面却有着很积极的态度，于是在结局，命运的线条汇聚在一起，无数偶然交错下，产生的必然却孕育着希望，尽管多少有些日式的大团圆味道，但流露出的价值观确实积极的。<br />
如果说这样精巧的叙事结构有没有问题，那么当然也是有的，叙事必须依靠逻辑的支撑，如此庞大的网状结构，逻辑当然不可能天衣无缝，事实上依然有很多巧合和偶然，为了配合结构的需要，甚至部分主角也免不了当工具人，但你很难对此苛责什么，通过有限的角色实现如此复杂的剧本，不免要让一些角色承担过多的推进剧情的作用，相对来说编剧已经做得很不错了。<br />
此外的问题是大部分日式游戏难免的幼稚气，叙事结构是精巧且充满悬念的，但一些抒情节点，以及一些过度夸张以至于模板化的人物性格，依然为其减色不少。不过我也能理解编剧，毕竟这种精密的结构确实很难填补完全恰如其分的内容<br />
总的来说428在叙事结构方面可以说是当今电子游戏的最高峰水平，尽管它的其他部分可能只是优秀或者不错的程度，依旧是一款剧情类的神作</p>
<h1 id="the-longest-journey">the longest journey</h1>
<p>​无尽的旅途是一部好游戏，限于时代演出不是那么优秀，但在我看来这是一个堪比dao的开始，嗯，或许稍微差一点，但梦陨就比较令人无语，这游戏似乎试图用超过十小时的游戏时间做一个预告片，你可能觉得这时长对avg来说不算少，但如果我告诉你这游戏大胆地用了三个主角，并且交织得并不紧密呢？<br />
顺便一提，这三个主角，其中一个是大杀四方的前作主角，但这作一直在低迷期，最后没顿悟出什么来还疑似4了，其中一个是半路插进来的肌肉兄贵，戏份比较迷的同时，最后的高光戏决定背叛自己的邪恶阵营，结果当场被关进大牢了，最后一个是戏份最多的本作主角，最后成为植物人，她的主线任务寻找前男友和阻止大boss一个也没完成，前作结尾的坑一点没填，又挖出了两三个新坑，甚至开头到结果贯彻始终，类似于where is alice 这样的主线问题都没回答<br />
如果这还不能让你深恶痛绝的话，最后还有一个事实，续作在10年后，而且结尾不算高明(据说)<br />
总之，我很怀疑avg能不能用好类似rpg的宏大世界观与对应的多线叙事，因为avg的核心是冒险，或者说类似的线性叙事结构的故事，你一般不会想在冒险的时候读上几十万字的设定文档，顺便卷进一个无数分叉的复杂故事线，就算有天才编剧能兼顾冒险感与宏大复杂的世界观，开发经费也未必能支持这个想法，最后，很可能的结果是，做一个大型预告片出来</p>
<h1 id="冥界狂想曲">冥界狂想曲</h1>
<p>在某种程度上，冥界狂想曲一直作为avg的代表与异域镇魂曲齐名，当然说实话古早的操作和谜题对我来说着实难适应，所以我只是云了一下，但也幸好，古早的avg大部分是单线叙事，因此不是自己玩在剧情上也没什么区别。<br />
总之，游戏的开场对我来说就很有意思，这指的是贯彻始终的颇有异域风味的冥界，我听说这是墨西哥的神话？先不管这个，虽然主题是死亡，但冥界狂想曲一直保持了一直诙谐的幻想风格，就连这些死者的再一次死亡也是用了开花这种充满生命力的方式表现，这给了整个游戏一种独特的风味或者说氛围，更不用说风趣且很有领导魅力的曼尼，与他同样有趣的哥们了。 一点小小的遗憾是，我想相对于主角二人组的丰满，反派npc的塑造就比较呆板，还有女主也没什么存在感，不知道怎么就开始感情线了。但其实其他npc倒也很风趣，所以总得来说，在角色塑造上是可以说优秀的。<br />
此外，剧情不是那么严肃，但结构工整，伏笔与回收上也很巧妙，虽然涉及了一些政治戏码，但表现得方式是揶揄讽刺而不是说教，这很好，可以看出编剧无意在此深入，而是停留在一种人文主义上的关于善良与勇气的故事，这丝毫无损冥界狂想曲的格调，一个让人沉迷其中的好故事，作为玩家不应该要求其他的东西。<br />
总得来说，我认为冥界狂想曲确实可以和异域镇魂曲同台竞技，它就像一部醇香的老电影，没有rpg式的沉浸扮演与纠结的选择，但作为一个故事就很精彩，游戏的形式也不是完全多余的，额，至少对喜欢解谜的人来说不算，其实，我倒认为gameplay上的乐趣主要是这个有趣的世界观。<br />
rpg的乐趣来自于选择和扮演，以一个角色的立场自己去选择，然后承担后果，这很好，但avg则有所不同，avg的重心是体验，这个故事一直在那里，只是你能以某种方式见证它的开始的结束，这种微妙的差别恐怕在当代已经接近消失了，但在avg的黄金时代，这种不同还是很明显的，你可能会觉得这就是个故事绘本，毕竟去参加还是不参加，故事都会以一样的方式开始与结束，但一个好的故事总是会有为之入迷的听众，正如冥界狂想曲的结局曼尼所言<br />
Nobody knows what's gonna happen at the end of the line, so you might as well enjoy the trip.</p>
<h1 id="hello-hello-world">hello hello world</h1>
<p>我很喜欢hello hello world对循环的处理，打比方的话就像是莫比乌斯环，通过正面来到了背面，又通过背面来到了正面，有点像年代记的true end，用真实创造了虚假，又用虚假谱写真实，这样的感觉</p>
<h1 id="海沙风云">海沙风云</h1>
<p>​rpg游戏的主角是什么人呢，是可以死无数次的人，又或者是可以做出无数次选择的人，我们都知道现实生活中你报了土木然后录取了，是不可能后悔，改去报汉皇法帝的，但游戏就不算事，回个档就行了，当然也有不让存档的，但归根到底，只要是跑在冯诺依曼架构计算机上的游戏，就要存储数据才能执行程序，要么在硬盘要么在内存，而有存储就能sl大法，众所周知，不受此限制的什么量子计算机，生物计算机就是造出来了，现在也没开发商能在这些架构上做游戏<br />
这样我们就能得到一个有趣的结论，主角不是人，也不是角色，他是若干有不同命运角色的集合，这取决于游戏给了多少选项，要是一个游戏每个角色都可以被操作，那么主角就是游戏角色的全集<br />
如此立论，主角必然是一定程度上模糊的，不透明的，但有意思的是，虽然我这么说，但玩家选项构成的主角又必然是主角的子集，但对玩家来说这就是主角，这样有意思的地方就出现了，这个子集可以只有一个元素，也就是说主角对玩家可以是单个角色<br />
说来说去好像这只是选择不同，但我发这些议论的原因在于，这种选择也可以是一种叙事，意思是，有的开发商会耍小聪明，他说所有世界线的主角都是一个人，他在不同时间线跳来跳去，最后回归到一个true end，就像用一个递归函数去解决问题，解决中用到了复数个函数，但这些函数都是一个函数，因此其实只用了一个函数，这样一来主角又是复数的又是单数了，让游戏分类学的爱好者们头疼不已(当然这个学说是我瞎编的)</p>
<p>​我和制作组一样对国产极乐迪斯科的说法不太认同，至少目前不太认同，首先很明显迪斯科的完成度高的多，而海沙虽然还不能盖棺定论，但某些不可言说的原因就觉得了制作组不可能在内核上有和迪斯科重合的地方，如果有人不同意以上观点，请比较一下两款游戏的开场画面文本不同之处<br />
港式警匪片也没什么不好的，我的建议是商业作品大家乐呵乐呵得了，要是哪个东欧哥一看chinese disco?玩了发现别说xx,xx尺度都没到，这多尴尬</p>
<h1 id="海猫与推理avg">海猫与推理avg</h1>
<p>在我看来巧舟是个有着很明显才气的作者，但是这种才气并不能支撑他到完美的地步，这就是说逆转里bug和牵强的地方不少，但1-4部总得来说打完还是会觉得不错，大逆转里这种特点就更明显了，主角团和很多角色都很有意思，但前期的法庭部分依旧无聊，此外，就悬疑作品来说，巧舟在平衡谜题和人物塑造上做得很好，这也是逆转系列目前有不小同人热度的原因<br />
打越我只玩过极限脱出和梦境档案那两部，在我看来就像一个以奇取胜的作者，并且在这点上非常偏执，揭晓谜底的时候确实很震撼，但倒过去看人物行为怎么看怎么不对，巧舟笔下的人物大部分是有可以理解目的的，现实人物也可能做一样的事，打越笔下的人物，配合那些神神叨叨的设定，就非常的，难以理解，甚至有前作主角在续作打酱油的神秘操作<br />
小高我懒得评价，我只能说他的诡计等设置只有在浓度比较高的二次元才成立，客观来说谜题还行，但玩小游戏推理太逆天了<br />
然后就是最近接触的龙骑士07，这位很难说写的是不是推理剧，毕竟以上三位不会让你在主角视角看到幻觉，最多掩盖一些主角能看到的事情，但寒蝉和海猫确实是可以推理的，就像海猫明说的一样，你要迎合出题者的规则和提示去推理，并且重点也不完全是推理，否则真相都知道了，打败真凶大部分作品都是结局几笔的事，不会像07一样化身爱的战士来个全员大决战，我觉得07的意图是这样的，大部分我这样的观众对how和who都非常关注，因此用这部分把我引进来，然后对我灌输why才是最重要的这个大道理，总的来说我对此持保留态度，我承认海猫的世界观下why比较重要，但现实世界还得who和how，这种太明显的说教，我不是很喜欢，但考虑到综合质量，海猫还是可以评个佳作起步的<br />
这个世界有王道，就会有邪道，随后会有看似邪道的王道和看似王道的邪道，总的来说，王道的意思是，在地狱中奋战寻求生路这样一路向上的故事，为什么可以看似邪道，就是说这个地狱可以奇形怪状，像克苏鲁神话之类的故弄玄虚，但最后依旧是一路奋战到达某个终点，或者壮烈成仁<br />
​邪道就是非王道，比较典型的就是原来都是一场梦式的结局，海猫无疑可以说是看似王道的邪道，因为大部分笔墨大书特书推理剧，诺克斯十戒，伪装成王道的寻求真相的推理故事，随后急转直下，原来是人格分裂+身份诡计，意思是百分之80的玩家视角都是虚假，这个角度讲，无疑是失败的推理剧</p>
<p>​但作为推理的推理倒是很有趣，也就是推理这个故事到底值不值得推理，是不是能推理，什么是推理，视读者评价的是推理部分还是推理的推理部分，评价就会两极分化，这无疑也是作者那么喜欢猫箱理论的缘由</p>
<h1 id="天问">天问</h1>
<p>PST是一种少见的天问式游戏，从头到尾都在复读那句“什么可以改变人的本质?”，理所当然的这个问题没有答案，根据游戏流程来看，答案可能是痛苦，悔恨，爱，没有答案……这些选项中的一个，但其实重要的是回答问题的人，而不是答案<br />
这可以说就是废话和故弄玄虚，也是我觉得pst不能说是什么哲理游戏的原因，并且很明显，这种天问如果没有令人满意的解答，整个剧本就完蛋了，因此很少有游戏敢用天问<br />
当然也还是有的，bs2的“爱丽丝在哪?”多少有点天问的意思，但不完全是，爱丽丝是个存在，这是具体的，因此这多少是个具体的问题<br />
生化奇兵无限的抛硬币也让我有这种感觉，正面，还是反面?这个问题很抽象，但非常模糊，让人对怎么回答毫无头绪，更像是对平行世界的引子,此外，我没记错的话，这个问题也没有问到海葬<br />
最后一个候选者是巫师三的石之心，石之心没有问题，但我觉得结合浮士德原著，可以概括出一个问题:“灵魂可以出卖吗？”这个问题由杰洛特卖了自己开始，由镜子大师收取代价而结束，问欧吉尔德，问爱丽丝，也问杰洛特和玩家，卖出灵魂是一场豪赌，这种快感让一切都变得无趣，即使面对不公的命运，这种堕落也是值得的吗？最后的选择权交给了玩家，这就是一场标准的天问<br />
2077的无名小卒和名扬天下似乎也首尾呼应，但到了dlc才给了无名小卒选项，未免拉得太长，所以也不行</p>
<h1 id="十三机兵">十三机兵</h1>
<p>​十三机兵的trick，虽然好像也不怎么想藏，和零时困境倒颇有相似之处，不过剧情的复杂度和合理性上水平很高，虽然我对青春校园题材实在没什么兴趣，但十三个人物交织的处理着实是多线叙事和网状叙事的教科书<br />
其实最后搞点大逆转也不错，虽然有13个视角确实很难藏点东西到最后，总得来说这部作品的故事线像在炫技，但揭露真相却无比老实，因此离r11e17这种所谓神作差了点野心，所以说悬疑题材的爱好者是一种很神奇的生物，越是骗他们感情的作品就捧得越高，像r11的结局就像给玩家闷头一棍——你以为结束了，其实才开始，你以为你在玩游戏，其实游戏在玩你；从开始到结束的所有努力都是无用的，不过是个陷阱罢了，所谓的神作气质莫过于此<br />
说回13机兵，其实这部作品和428也很有相似之处，都是一团乱麻逐渐理出来主线，只不过这游戏有13条主线，这是夸张的说法，其实基本每对cp有一样的目的，所以可能就六七条主线，这种结构有一个技巧，逐渐理出头绪时是最有意思的，一股绳了就无聊了，因此需要一个简短有力的结局，以及逐渐加速的节奏；但是十三机兵这个战棋玩法着实拖时间，还有日系游戏经典的数值深坑，这是十三机兵离神作最远的地方</p>
<h1 id="古诺西亚">古诺西亚</h1>
<p>先说结论：部分人设比较有意思，结局挺让人感动的，但过程太折磨了，总得来说建议玩个开头熟悉一下流程，然后云到结局<br />
以下是对缺点的详细阐述：</p>
<ol type="1">
<li>玩法创新是有的，但整个系统和ai支撑不起合格的狼人杀体验，人物条目的解释条件过于苛刻，可以说完全就是拖时间，看了一些评测和流程视频都在100loop以上才能进真结局，其实纯剧情流程也就最多50个loop上下</li>
<li>剧情有些水平，但基于1，节奏可以说一塌糊涂，和同类，例如人狼村比，完全没有紧张刺激感，，而且文本量，估算的话最多已经人狼村的一半，个人体验上最多和人狼村打平</li>
<li>第二点是说的主线流程，但本作有15个人物，大部分和主线无关，而且文本量太小，例如一个角色条目和其教育经历有关，那么这个教育体系有什么特点，和这个人物现在的性格有什么关系，都没有拓展，此外，真结局其实只涉及个位人物，却需要解锁所有角色条目，这个条件虽然和某个设定有关，但还是很强行</li>
</ol>
<p>总的来说，这个游戏剧本质量是有的，但体量和完整度上过于匮乏，在我看来80%左右的好评率是更合理的</p>
<h1 id="be">be</h1>
<p>有一种典型的be或者ne是：奋战后什么也没有改变<br />
这个类型也有细分，比如最后虽然功败垂成，但主角得到了救赎，这种属于be中的he,还有最后不过是回到了原点，这种是ne，还有奋战后结果更差的，这种属于搞人心态的be中的be<br />
第一种其实还挺多的，例如jojo6，当然新世界大概也算改变……<br />
第二种的例子是jojo7，最后乔尼不过是回到了原点，或者极乐迪斯科，到头来除了金的友谊，不过也是回到糟糕的原点；以及东方年代记的te，从幻想乡的毁灭回到幻想乡的诞生，而且这两者其实是一回事<br />
第三种例子就很难找，个人观点me3的绿光结局应该算，全银河系变成融合怪，还不如毁灭了；又或者东方年代记的ce，苟延残喘还不如来个痛苦；蝴蝶效应应该也算，<strong>或者说蝴蝶效应的结局很难这么分</strong></p>
<h1 id="辐射新维加斯">辐射:新维加斯</h1>
<p>新维加斯的网状叙事和蝴蝶效应，确实是rpg史上的奇迹，不过这样让我非常患得患失，也就是典型的过高的自由会让人无所适从，这也是为什么近年的rpg不会这么强调网状了，能树状就不错了<br />
话说结局是字面意义上的ppt也是挺难绷的，还不能跳过人生，这也是个微妙的点，要是后果太强，就会影响整个所谓的开放世界，要是没有后果，那选择就没有意义，因此只能用ppt这种微妙的展示方法显示选择的影响，信使的选择到底有影响吗，如有<br />
当我们讨论rp时，我们在讨论什么？<br />
在大部分rpg游戏里，把口才点满，可以与大部分没完全疯的boss交涉，嘴炮避免战斗，把逻辑或者感知点满，就可以观察到绝大部分角色的明显谎言或者自相矛盾，我们称之为rp，因为我们选择了把角色培养成演讲家，侦探……我们必然得到这样的后果<br />
但是，过程在哪里呢？福尔摩斯是怎么推理出矛盾的，口才大师是怎么挑选言辞的，这些很难展现，就算展现了也没什么人会买，这么一来文本量能翻一倍<br />
同理，我们在black souls把能看到的npc全图了，这是结果，为什么图，用什么方式图，则无法控制<br />
这是一个本质性的矛盾，玩家不等于角色，你捏一个大侦探出来，现实里没几个推理小说能猜到凶手，所以我们要rp一个在rp的玩家，这才是rp的本质 辐射可能是近年唯一一个集齐两个“大厂”的ip，你可能想说博德之门，但博得12早没几个人知道了，当代生软和老生软也完全不是一回事，并且博得12没那么多变性人和男女同性恋，和现在的生软死忠粉不重合<br />
这就导致一个很幽默的现象，你不能用辐射粉这个标签定义这个ip的受众，因为可分为三个阵营，遗老，黑曜石正统派和杯赛正统派，如果你问可不可以都喜欢，很遗憾，由于大家最爱的Mr陶德把fnv的设定一口吃了，阵营选择上前两派和杯赛派完全是水深火热之势<br />
更有意思的是什么呢，这两个b字头厂现在都在微软旗下，也就是说他们应该，大概，是一家人，结果演了一出典中典的兄弟内斗,应了那句经典的<br />
wars, wars never change<br />
我的猜测是这样的，微软虽然财大气粗，但在游戏界只是小打小闹，经费就那么多，陶德要去追他的nasa朋克梦，就得要微软大爹出米，大家都是旗下工作室，零和博弈，那不给黑曜石这边踩一脚，毕竟不说商业上不错的辐射4，76居然实现了玩家一边骂一边抢着掏钱的神秘现象，陶德的口才点了多少想必不用多说，拿捏个办公室政治简直手到擒来，遗老随便骂吧，骂完辐射76别忘了氪金，星空dlc别忘了买</p>
<h1 id="巴别号">巴别号</h1>
<p>我不知道该不该这么说，优秀到初步印象不会觉得是国产的独游，因为在我印象里国游很少有天马行空的幻想世界观，要么是武侠修仙这种成熟题材，要么有什么现实原型，或者新瓶装旧酒，巴别号初步印象对我来说就像日本近年很火的新本格在游戏上的体现；话说上一个让我怀疑是不是国产的还是帕斯卡契约，不过类魂毕竟也是个成熟类型，而巴别号几乎没有先行者，玩法是经典avg，有点微创新，而设定上我是想不到类似的前辈，这种独游基本是奔着大亏去的，国内毕竟发展中国家，这种纯为了理想的独游很难不支持</p>
<h1 id="陶德">陶德</h1>
<p>​老滚5的某个纪念版叫特别版，为什么不叫一些更具体的名字呢，我猜是陶德这小子也拉不下脸了，因为你会发现这个版本只有一种特别——bug特别多<br />
大概一两个重要支线卡进度无法触发，你可能会说还有万能的控制台，然而我在贴吧搜到了同款bug，然后学着试了试控制台调进度或者重置，还是没用，npc像4了一样一动不动，很难想象一个纪念版会有这种情况<br />
近年bug出名的游戏有什么呢，无疑是首发2077，但2077我还真没遇到重要支线无法触发的bug，大部分bug体现在显示层面，要是分开客观打分，我会说2077初版完成度更高，至少我能体验完所有主支线，而这，就是我们世纪神厂杯赛的含金量，我不是说游戏不行，但态度太差了，甚至至今steam的天际特别版都没有官中和创意工坊，人家恩达瑞尔还要单开个游戏页面</p>
<h1 id="命运石之门">命运石之门</h1>
<p>“欺骗世界”确实是e17首创，而且在我看来揭晓答案的一瞬间比石头门还惊艳，但缺点是白开水一样的节奏以及人设，石头门我看评论都说什么前期节奏慢，但对经历e17洗礼的我来说前期简直跌宕起伏<br />
但不说这些了，毕竟做e17的时候经费和年代限制比较大，单论诡计的话，毫无疑问的e17更加复杂精巧，登场角色几乎人人一个trick，但在时间线的复杂度上石头门无意抓住了“欺骗世界”这个点进行了拓展，e17里“欺骗世界”是灵机一动想出来的，一个出彩的收尾，但在石头门里是贯穿全剧本的主线，有无数的铺垫，无数次苦苦求索，跨越了无数次的牺牲和努力，情感力度上远超e17这个前辈<br />
这算一种微妙的差别，打完e17会有一种惊艳感，石头门没有那么多惊艳感，我以前都吐槽打越式伪科学，这波科学adv着实更胜一筹，如果是e17里是新本格式的设定式推理，石头门就是探讨规则或者说设定的纯实验，因为不知道完全的规则，推理无从谈起，取而代之的是一种感动，这种感动一是历经劫波终于he的感动，二是做了那么多次实验，终于理清了世界线理论是个什么东西<br />
不过我不是搞科研的，至少还没开始搞，所以应该胸针寻找跳线的方法应该类比我debu更感同身受，这点来说确实是"科学adv”，科研里痛苦和快乐的比例大概正如凶真经历的be世界线和he世界线比例</p>
<h1 id="梦">梦</h1>
<p>如何反驳“这一切都是xx角色的一场梦”之类的说法<br />
其实很无聊，因为延续下去可以说“这个世界也是我的一场梦，其他所有人都是我幻想出来的”，然后双方都无法证否对方的说法，陷入死循环，计算机学科里叫循环等待</p>
<p>一切都是梦，这是个假说，不具备可证伪性，也就是恶魔的证明，这样的命题我可以提一千个，但是没有意义，不可证伪的命题不是科学，非科学的讨论只是浪费时间，因为讨论就是为了说服对方，而且是用逻辑上的证明，无法证明就无法讨论</p>
<h1 id="文字游戏">文字游戏</h1>
<p>我玩文字游戏基本都在快进，比较典型的是石头门，不啰嗦，但大部分是平铺直叙，很好猜人物行为，加上lab全是老面孔，看到发生什么事就能猜到人物行为了<br />
比较啰嗦的是寒蝉和海猫，出题篇还好，只有一些日常要量子速读，解题就麻烦了，07的核心诡计就一两个，差不多猜到之后就只能快进了，寒蝉后期初中生大战雇佣兵，海猫则是大段感情戏，和文字描写的魔法大战……有点汗颜了。还有十三机兵，节奏其实挺快，但我实在不想看高中生谈恋爱……<br />
处理的比较好的是打越巧舟，巧舟不说了，除了搜查部分节奏都飞快，打越好在谜题层出不穷，除了e17也没有日常，坏处是玩起来很累，但基本不用快进，解题部分还得想半天，但最近的ai系列又开始卖人设了，特别是涅槃那部，实在太old school，梦回上世纪的gal人设，可以说从头快进到尾。人狼村也不错，男主油滑又聪明，基本每步都是最优解。<br />
最教科书的是428，基本每一个小时都有反转或者小高潮，堪称节奏控制之王，感情戏也不长，几乎没用跳过，但文字显示速度感人，ce开了三倍速</p>
<h1 id="梦灯花">梦灯花</h1>
<p>优缺点很明显的作品<br />
优点:美术质量高，世界观有新意且较为完整，没有日式二次元不死人的团团圆圆风气，基调偏严肃，故事总体是完整的，现在史低+捆绑包50块还送设定集，畅玩15-20小时左右，性价比可以</p>
<p>缺点:战斗系统充其量4399水平，战力也很奇妙，此夜说是普通光使出身，好像天赋也不如绚夜，怎么回到现实后还是第一梯队战力，没人奇怪吗，至少可以提一嘴祝福之花吧<br />
角色太多，塑造不够虽然立绘好看，但明显戏份不够分，有最后支线草草了事的，又用来关键时刻死掉渲染气氛的工具人，最后下来我没几个印象深刻的角色，而且主角组个人感觉也塑造一般，对比前作科罗莎行动力超强，每条线都在c，主角组大部分时间用在光使内斗和找各种人帮忙上，战力和前辈基本是平手或者略胜，贤者是不如的，智谋上也没多大体现，总不能烧点粮草就智将了吧，那你们为什么能当主角呢？当然如果你打完了，就会发现最难忍的是绽夜的塑造，主塔官僚主义固然不对，但绽夜自己也毫无建树，还和同门姐妹内斗，暗兽潮来了还满脑子内斗，完全就是匹夫之勇<br />
部分发展强行，篇幅分配不当比如黑辉夜，封面c位，怎么也该和白辉夜差不多戏份吧，结果现实篇失踪了，无夜立绘这么精美，结果就一两句台词，古光使是什么社会形态，为什么社会矛盾不可调和了呢？现实篇里白辉夜的心路历程是怎样的，四个古代贤者的过去都是咋样的，塑造都很少，根本原因是这个任务机制过于割裂了，把剧情切得很碎，难以长篇大论地讲宏大的东西，角色又多，完全来不及一个个塑造，这点比起海沙绝对是退步的<br />
最后稍微提一下虐主问题，核心视角是此夜这是肯定的，而此夜可以说是最惨角色之一了，姐姐保护过度，被逼放弃梦想泯然众人，天赋又比不上绚夜，现实里两边都背叛了，里外不是人，说是双人组但其实她不过是队长的“搭档”，也就是陪衬人，我是此夜也想着入梦了，她身边的人也太不做人了，绚夜不是好朋友吗，至少为此夜正个名，说此夜不只是“搭档”啊，玩下来想代入的人肯定非常痛苦，说实话，我打的最爽结局就是黑化<br />
说是轻百，事实上就像东方的秘封组一样轻，就是说完全打不了lgbtq的tag，河豚倒也没必要冲着这个来……</p>
<h1 id="装甲恶鬼村正">装甲恶鬼村正</h1>
<p>英雄篇的主旨就像巫师三的猎杀怪物cg，evil is evil，杀一个救100个人并不比杀100个人救一个人更善良，都是邪恶，恶无大小<br />
然而杰洛特还是选择了杀一个人来救更多的人，所以他从不会把自己当做英雄<br />
经常有人说，只要杀人都是恶，这种想法三观不正<br />
不过还有更好的方法吗？杀了一个人的人就必须死?如果过失杀人呢？故意杀人必须死?如果被杀人曾害杀人者妻离子散呢？没有仇怨杀人必须死?如果被杀者身上有传染病，不烧掉尸体就会让周边化为地狱呢？杀好人必须死?如果好人只是伪装，私底下男盗女娼呢？<br />
无论如何都很难归纳出绝对正确的可以杀人的场合，因此只能这么说，只要行动，就会有犯下罪孽的可能性，即使什么都不做也是一样，归根到底，道德议题都会是虚无的，只有圈定一个前提，才能讨论一个局部解，那么不同群体的局部解又会不同<br />
因此，只要杀人都是罪，这种观点未必对也未必错，无法证实也无法证伪，只是一个观点，如果说这种观点错，同样也可以否定其他观点，这就是为什么人类文明发展到现在也依旧有无数的罪恶</p>
<p>复仇篇的发展远比英雄篇好猜，正义，英雄，这种概念是人类社会出现后才慢慢成型的事物，复仇则在更早之前就会出现<br />
证据就是，我小时候收养了流浪狗，不服管教被我妈追着打过，因此它一看到我妈就夹着尾巴，这是恐惧，畏惧，但到了适当的时候就会产生仇恨，仇恨就是这样一种原始的感情，例如农村的狗对着闯进领地的人狂叫，也是对侵占领地这种行为的“复仇”<br />
复仇只要伴随着生物本能就可以完成，这样的简单粗暴让其很多时候都不符合道德标准，正义更无从谈起，但作为人性中残留的兽性，这是必不可少的<br />
因此，复仇没什么好绕的，只要去杀戮就行了，但为什么哈姆雷特这样的人会犹豫呢?这不过是因为他当了太久的人，忘了怎么当裸猿，也就是说复仇很简单，复不复仇才是麻烦的地方，脱下人皮经典，再穿上又难了</p>
<p>我是很不擅长阅读理解的那类人，语文很难考到平均分，因此我一般也看不出作者有什么私货，除了硬塞lgbt，黑龙也是龙这种太夸张的，因为我懒得猜作者到底什么意思，所以反而是最宽容的一类读者，对我来说作者写完的一瞬间，作品的解释权就被我这个读者垄断了，作者想要解释作品也只能以一个读者的身份来<br />
因此我倒不觉得村正反战败，我看出的是反杀人，杀任何人都有可能杀错，所以不要杀比较好，这种说法很极端，因为别人打不过了的话难道不反抗吗？所以这个说法还有补丁，心怀大爱的人就不要反抗，以肉饲鹰，没有这么高尚的人以牙还牙也无所谓，只是不要觉得自己就是对的。这样说完了还是很极端，难道世界上不存在正义的战争，怎么就不能觉得自己是正义的?但是还有补丁，这是从宏观视角看的，因为缺少前提的情况下，恶人的一命和善人的一命没有方法裁量，善与恶也难以分辨，这个前提取决于不同的人和不同的价值观，也就是换一个朴素正义感的视角，善人杀恶人就是天经地义的正义。<br />
这就绕了个大圈子回到了现实世界，为什么要这么麻烦呢，或者说为什么要这么极端呢？因为村正是为了醋包饺子，世界观下平民几乎没有半点希望，单人的武力可以灭国，毫无节制的强，你杀我我杀你，没几轮地球上就没人了，在这种特定情况下，很难说需不需要社会的存在，也很难说什么是道德准则，武力的使用会产生冲突，稍微多冲突几次地球就没人了，你以一个平民的视角看，不要使用任何武力也是个不错的结果，平民和那些超能力者已经不是同类了<br />
绕到这种程度还是很极端，为什么就要因噎废食，说不定在地球没人前，正义的超人们把邪恶方杀完了，又可以建立一个天国。这当然也可以，唯一的问题是会死人，死掉很多无辜的人，也未必能成功，对那些，比如流弹打死的人来说，正义又成了邪恶<br />
到最后我们就会发现一个朴素的道理，好人一次也不能出错，否则就成了恶人，村正部分角色的观点是，好人难做，那就什么都不做好了，或者以当恶人的觉悟去做好事<br />
论证到这个结论，还是很极端，因为好心干了坏事的好人也可以认为还是好人，好人战斗死的人很可能比不战斗死的人少，更何况可能真的有超人，永远好心干好事，这样的论证逐渐开始虚无了，因为这样的假设可以无数次做下去<br />
因此以上的一切只会是观点，无法像数学证明题一样完美的QED，同理，认为有私货的人也只是观点，我也可以假设作者的所想和我这些观点一样几乎等于什么都没说，因为换个类似现实的世界观一切就不同了</p>
<p>所有人都绝对不使用武力的世界，这就像石头门里真由理死去的世界线一样，虽然看上去像乌托邦一样完美，实则是没有选择的和平美好。互相加害与和平共处同样是人类的本能，禁止一切武力，或许只是一个死气沉沉到想让人紫砂的世界吧</p>
<h1 id="forest星空流星">forest(星空流星)</h1>
<p>在我看来在原作意义上，forest继承了爱丽丝原著的思想，就是少了点数学梗，换成文学梗了。而在魔女幻想上，在我看来比海猫更胜一筹，胜在简短有力<br />
不过也不能完全这么说，毕竟海猫一直把幻想和真实分开，魔女和戏法非此即彼，在打开猫箱后见分晓，而在forest有无限的可能，把现实部分全去掉，这个故事也成立，幻想也可以去掉，但更自然的想法是现实与幻想纠缠融合，海猫里六轩岛无人生还是确定的，forest说什么都没发生都可以<br />
可能大部分人会觉得这什么虚无主义，但寥寥几语很难说清，就像爱丽丝梦游仙境一样，可能仙境也不存在只是梦，但不能说这本童话就不好看，用07的话说没有爱就看不见，如果有对故事的爱，那么forest里发生的故事就是存在且不虚无的，这不过这个故事是幻想故事还是现实故事可以随便理解</p>
<h1 id="cc">c+c</h1>
<p>c+c讲的孤独是没错，但一群未成年精神病人的孤独多少会有点难懂，我这种连时尚单品玉玉症都没有的人大部分都难以理解<br />
不如说，虽然精神疾病不好受，但江苏的高三那种令人窒息的氛围，堪比精神病制造机，痛苦程度也不遑多让。被无所事事地隔离也不算差了，要换个农村，或者发展中国家，无法适应主流社会的人都是自生自灭的，很多直接就夭折了，或者家里弃养，大部分人生活在无暇顾及有没有精神病的环境中，这才是可悲的现实啊。<br />
能烦恼自我意识和他人意志的碰撞，这是非常奢侈的，没有钱，权，地位的话，别人说什么，你就得做什么，因此，自我意识越薄弱反而越幸福，太有自我家境又不好的就被送到豫章书院肉体改造了。所以难怪这作品冷门了，家里没几套房的怎么共情</p>
<h1 id="爱丽丝">爱丽丝</h1>
<p>东方文化学刊有一期讲了爱丽丝形象在二次元的演变，旁征博引了不少，从那几年很火的爱丽丝vtb,到做兰斯那个alicesoft，期间还介绍了一下洛丽塔情结，比较限制级，最后是东方的爱丽丝。<br />
其实东方的爱丽丝偏离原作算比较远了，虽然旧作和新作的爱丽丝角色曲挺符合氛围的，正直者之死倒是很黑童话，但怎么看都更像无人生还，bs和forest的爱丽丝在我看来是比较还原原著的，夏梦夜话听说也有爱丽丝，但还没玩，童话安魂曲也有爱丽丝，但听说也就7分作还有牛不太想玩<br />
这个话题其实很有意思，我也想抽空研究一下二次元到底有多少比较有代表性的爱丽丝，也就是不只是外形或者名字致敬，而是对原著有自己阐述的爱丽丝<br />
话说原著的内核是什么呢，这点可以有无数种阐述，但最常见的理解是，易碎的美好，对此又有两种常见的处理，将时间冻结让其永远美好，以及让其在最美好的时候凋零，因此不必忍受缓慢的溃烂。<br />
那为什么不能慢慢迎来长大呢，因为大家都不喜欢在虚拟世界寻找现实，也就是这种展开太现实了，没什么意思，卖不出去<br />
闲的没事搞个爱丽丝指数玩玩，一共分5个维度，原作情节（设定）匹配度，狂气程度，幻想程度（主要指天马行空的设定或剧情），爱丽丝形象匹配度，配角匹配度，满分为5<br />
东方的爱丽丝:<br />
情节匹配1（算正直者之死与旧作的话）<br />
狂气4（正直者之死比较狂，部分二设可以算5）<br />
幻想5<br />
形象匹配3<br />
配角匹配0</p>
<p>black souls的爱丽丝:<br />
情节匹配3（魔改太多了只有框架一样）<br />
狂气5<br />
幻想3（总的来说还是个冒险故事）<br />
形象匹配度5<br />
配角匹配度4（有魔改）</p>
<p>forest的爱丽丝:<br />
情节匹配3（和bs各有千秋）<br />
狂气3（虽然也狂但没什么精神污染）<br />
幻想5<br />
形象匹配4（立绘不同但设定相似）<br />
配角匹配度2（极少配角匹配）</p>
<h1 id="结构">结构</h1>
<p>比起内容，我更喜欢结构有新意的作品，像一些猎奇作，死法和虐法是一个比一个创新，但归根到底就是起承转合的线性故事，打完没什么印象<br />
一些结构有趣的作品则会化为一个图形留在我的脑中，比如极限脱出是经典的环形，善死与零时更进一步有换了花样的多重环，ai2是炫技但人设烂完的双重螺旋<br />
bs是三层嵌套，最底层内有着不断的轮回，428是一团乱麻融合为一条线，十三机兵是十三条线版的428，forest像树状的克莱因瓶，从最低的叶子一步步跳到树冠，然后化作当初长成此树的种子落回土壤，e17,腐姬则是两种环的融合<br />
寒蝉和海猫都算是不断上升的螺旋线，也是个经典图形，只不过海猫上升到一个点后就进入了黑箱</p>
<h1 id="濑户口">濑户口</h1>
<p>​某种意义上我挺好奇濑户口的原生家庭，还是说他曾经在什么特殊儿童教育机构任职过，每次选题都这么聚焦家庭和成长历程。<br />
关于这个话题我自以为和濑户口有差不多的立场，原生家庭与社会的规训可以决定一个人，这么说好像就是东亚文化圈，尤其是日本的老一套，这种说法好像完全否定了人的主体能动性，正所谓农村也能飞出金凤凰，我个人的父母就是进城第一代，对此是毫不怀疑的<br />
但飞出个金凤凰和农村里经常有的傻子疯子一样说明不了什么，我个人认为说原生家庭不能把基因排除出去，一对智商普通的夫妇可以生出天才的儿童，这种基因突变也没什么奇怪的，所以原生家庭决定论在这点上依旧能成立。<br />
还是说回正题吧，现代生活下，大部分穷人也不用24小时为了吃饱饭奔波，这不是美化苦难，因为碳水管饱确实是最低工资也能做到的消费，哪怕每天有半小时时间能躺着坐着休息一下，就不得不面对自己，全球有70亿人，怎么能不在人海中湮灭掉自己这个主体呢？概括的说，要么特立独行，要么融入一种身份认同，但前者需要自己有一定的相对优势，后者至少要能被接纳。<br />
这两种条件，都需要在童年开始培育，如果童年就把主体性碎掉了，就会产生一种失能螺旋，只能自我保护式地萎缩，而一些恶劣的家庭，就会产生这样的悲剧，狂欢节中男孩是被自己的母亲否定，父亲抛弃，未成熟的自我被撕裂成无数碎片；女孩则戴上小大人的面具，这个面具是个有用的主体，唯一的问题是不是她自己培育的，因此名为面具，其实是限制自我成长的囚笼，看似早熟，其实没发育。<br />
这样残缺的主体怎么在成年后再自救，我是想不到方法，我看濑户口也想不到，所以be了，作为理工科学生，我觉得心灵破碎到这种程度，不如埋头在数学，编程之类的纯粹理性中度过余生，就像用事业逃避家庭悲剧的中年人一样</p>
<p>其实天鹅之歌让我有点失望，如果说原生家庭，校园霸凌之类的悲剧，当事者理论上还能做点什么的话，人类灭绝的末世下就没什么能做的了，设定下没有了生产能力，严寒，交通条件也丧失，丧尸片里至少还能种地，而这种情况下会发生什么用小脑思考就知道了，我觉得此时he就是在药店找到足够的安眠药，大家嗑了一起躺在雪地里安逸一晚上<br />
用俗话来说，这辈子有了<br />
这样的悲剧是虚无的，否定了选择，虽然这么说就太绝对了，不过这种末世下很难说选择有什么用，我是觉得再乐观的人都不会能坚持下去，除非信仰宗教<br />
有意思的是剧中唯一有选择的就是非人的少女芦荟，她是天才，或者说能够自己阐述世界的人，在这个荒诞的世界下，她可以将其阐述，甚至构建为乌托邦，又或者是毫无意义的随机乱码?至少剧里的人物中，她是唯一一个不会觉得这里是地狱的人，我觉得作者本人也写不出她眼中的世界。<br />
所以我说的选择意思也很简单，这个游戏从头到尾没有公正的上帝视角，全部是主观视角，如果所有视角都给芦荟，故事就完全不同了，那么为什么视角不能给随便一个狂信徒呢？因为他们脑子太空了，用这种视角只能写出一堆呓语，而不是故事<br />
这么说我自己也觉得诡辩，不过娱乐作品没必要太认真<br />
话说te也是够敷衍的</p>
<p>顺便一提我对抗虚无的方式是算一遍1+1等于几，然后和2对比看一下是否一致<br />
比我聪明的人可以算一算微积分，微分方程，或者证明一遍毕达哥斯拉定理之类的<br />
和我一样不太喜欢文史哲唠叨的人可以参考一下，1+1=2，就算全世界的人死光了也成立，不是很美好的事情吗，能意识到这个定理的我肯定就不是虚无的了</p>
<h1 id="离去的人们">离去的人们</h1>
<p>被创造者相对于创作者是残缺的，这是无数meta作品的母题，这句话以字面意思说很简单，也挺无聊的，也就是傀儡在作家的笔下起舞，但这就像作家在出版社与房租月供的压力下起舞一样。如果说造物没有自由，作家也没有自由，作家也不过是社会，家庭，基因，生物本能的造物<br />
在层层创造与被创造关系中，作家比造物高一层，这是残缺性的由来，但让我们把计算机网络拿出来，高层依赖低层的服务，但交流电，或者wifi的电磁波，这些是所有层面都要依赖的介质或者说物理规律，无法剥离，因此，层级关系并不是绝对的，因为所有层总有公用的无法剥离部分<br />
在创作领域，无法剥离部分就是逻辑，语法等等，拿函数举例，对一个f(x)可以做无数定义，但每个有定义的一个特地x，绝对地只有一个函数值，这是绝对的，上层者无法决定下层者的部分，也是两者的交汇处<br />
正如老板再怎么压榨不能让一个农民手工种几亿亩地，创作者再怎么开脑洞也不能写 a apple, many shoe，这种不符合语法的东西，并声称这是英语，即使是下层存在也会有自己的绝对规则，无法被完全否定，可以视为一种尊严<br />
同理，造物仇恨自己的作者，就像孩子仇恨自己的父母与家庭一样，也否定着自己与上层公用的部分<br />
我倒是觉得和平相处也挺好，但是不破不立这样的想法也不错，事实上在函数式编程里，各种嵌套递归调用很常见，上下层反转也毫不奇怪</p>
<p>残缺渴望着完整，无法自拔地渴望，然而这种渴望只会加重残缺。<br />
个体渴望着独立，也就是不依托于其他个体的存在，这就是一种完整，然而没有客体的情况下是无法证明自己存在的，没有镜子的情况下怎么看到自己的脸呢，即这种对独立的渴望反过来加重了对集体的需求。<br />
十种精神病各自是一种残缺，可以视为隐喻，也可以单单视为特例，但不管怎么说这些存在由于内心世界极度膨胀，甚至歪曲了对现实的认知，她们(为什么是她们我就不知道了,可能是因为养育子女时母性往往比父性可靠，所以更能象征人类精神的发育)面临的困境也就愈发痛苦。<br />
完整是不可能的，一般来说正常人会阉割掉自己对完整的病态渴望，但游戏中这些精神病人无法这么骗自己，所以就需要一种离去的方法，也就是标题《离去的人们》，离去的可以是欲望，可以是自己的存在，但总之要么逃要么自我毁灭。<br />
接下来的问题是离去的方法，这方面非常模棱两可，我姑且提出一种猜想，十种精神病人是虚构角色，她们的痛苦似真非真，因创作而痛苦就也可以因创作而救赎，男主是没有自我，或者把整个世界视为自我的人，这是什么意思，就是说他是作品，创作者之类高位存在的某个视角或者傀儡云云，在他的介入下，精神病人们就可以通过续写故事的方法离去，为什么要这样一个角色来帮忙呢，因为这是一个故事的故事，要写这样的故事需要一定的高维度权限。<br />
于是越到后面这个故事就愈发不知所云，晦涩难懂，角色也一个比一个怪异地离去了，也就是从故事退场了，故事要有起承转合要有逻辑才是故事，剧情发展愈发挑战是否算故事的极限，终于在极限处达到了无法理解的虚无，于是实现了离去。<br />
这个离去可以有无数种理解，比如没有读者能看懂，从读者的理性中离去，比如作者写嗨了，圆不回来，从作者的笔下离去；又或者终于不用再渴望完整了，从病态的欲望离去。这种离去和更普通的故事有什么区别？我个人觉得区别只是这种离去晦涩难懂，因此更贴近虚无而已，用郭子的话说如离。<br />
如果想虚无为什么不直接贴一堆乱码？这我觉得是作者固执地想写一个无法成为故事的故事，故事应该可以被理解，而非故事无法被理解，因此逐渐让可理解的故事崩坏到不可理解，在分界线处就实现了存在到虚无的过渡，既是故事也不是故事，就像1/x这个函数，0.00……01处都有极限存在，但在0点没有极限，那么如果0点是离去，这个故事就是从1写到了一个无法测量的非常小的值，几乎可以视为离去了</p>
<p>此外，精神病人们是一种蜂群思维，感情互通，既是十几个个体，又是一个整体，当然这个整体依旧是残缺的整体，为什么男主一来，病人们就无人生还了呢？我想是因为男主作为高维度存在，是残缺也是完整的，可以旁观，反射(简称男凝)病人们的存在与残缺，让她们无法忍受镜子中的自己，在最渴望完整的歌穗计划下，最像正常人，也是创作力担当的晶子画出了巴里虎这个什么都可以隐喻的幻想生物，直接导致了所有人的离去，病人们临死的那一刻，是完整的破灭，也是残缺的补全，在这种矛盾中归于虚无，又或者像道家的说法，物极必反，虚无之后就是完整。为什么她们渴望的离去如此痛苦？因为残缺者渴望的并不是幸福，而是补全，只有补全后真正拥有自我后才能感受幸福，这对一个个残缺的个体来说当然是痛苦的，就像吃一种有副作用的药物，肝脏固然痛苦，但整个人体是受益的<br />
那么爱丽丝的突然出现也很好解释，爱丽丝是混沌的，黑箱中的世界意志的化身，离去，要去的地方就是爱丽丝所在的那侧，能听到爱丽丝的声音就说明离去计划进行顺利，但能离去的只是病人而已<br />
男主是观测这个故事的视角，他永远不可能到爱丽丝那里去，即使听到爱丽丝的声音，也无法承认，因为读这个故事的人是不能真正听到爱丽丝声音的，除非读者也有妄想症</p>
<h1 id="脏翅膀">脏翅膀</h1>
<p>我觉得脏翅膀最大的亮点就是那个幻想着和野男人私奔的娼妇，她自己也知道不过是在骗自己，还是沉迷其中，这倒是很真实<br />
大部分人无法选择自己的出身，以及自己的命运，没有人喜欢卖身，我估计着也没人发自内心地喜欢做题，这两者区别没有那么大，当然前者更痛苦，反正都不是什么让人喜欢的事，对娼妇来说，不卖身就是死，对我来说，不做题要么进厂当三和大神，要么就是当蹲哥爆家里金币，不至于死但也难说多高兴。<br />
违心的事做多了就会开始骗自己，娼妇想有个人为自己赎身或者一起私奔，做题家幻想的就多元化了，从被富婆看上，到读博发文章当杰青，进大厂年薪百万，都是幻想没什么区别<br />
这是一种堕落，但是也没办法，有谁真坚强到从不骗自己吗？到这里为止都是所谓的庸俗人性论，但我觉得救赎也是存在的。向内心看去，自我是污秽不堪没什么希望的，但向外部的世界看去，所有人的存在都源源不断地对外界产生影响，或好或坏，但这种影响是全局性，持续性的，因此，自我的存在会投射到世界中继续存在下去，就比如说，虽然大部分人无法青史留名，但就算只是一句“岁饥，人相食”，也能刻画出当时动荡不安情状的一个缩影</p>
<h1 id="ke-dr">ke dr</h1>
<p>如果说kedr和bs有什么共同点，那就是永不放弃的基调，也就是标准的正剧，如果我们开始经典的比惨大会，路易斯肉体被各种凌辱，但没几次致命伤，格林不死人死不了，什么死法都经历过了，肉体上惨得多。精神上路易斯可能更惨，字面意义上家破人亡，虽然我不知道3w身经百战的老兵是怎么一起被骗死的。格林也不轻松，但也就死了几十个同伴，还大部分不算死透了，数量上输了，多人格和精神污染难以量化先不谈。<br />
其实比惨大会没什么意思，也没有真放一堆r18g图出来，没什么实感，最关键的是向读者传达这种百折不挠的精神<br />
众所周知现在业界废萌当道，这其实算一种周期变化，再往前死火海这些长篇热血漫也很火，但是长篇到最后必然热不起来，一是虚拟世界的牺牲迟早让人觉得没有实感，二是多来几次类似的场景会迅速审美疲劳，让读者容易猜发展，所以要热血，中篇是比较好的，kedr这种游戏就好在篇幅合适，在读者腻味前燃尽，这点比少年漫强多了<br />
ke和dr的剧情，结合在一起就非常奇怪，dr本可以大团圆，就算突然废除奴隶制以及魔族的统治影响，有洋葱和章鱼魔族在至少可以居中调停，把鸽派全杀了，直观上想只会全面大战，为什么要这么做，因为预言书写了这么做死的人最少，为什么信预言书?因为到目前为止都应验了。<br />
这是非常标准的机械降神，石头门还搞了一套说法论证自己的时空观，dr里对预言是环形时间观（预言导致大战，大战导致预言被送回过去）都不知道，古伊奈就相信了这个说法，引爆人魔大战，直接导致无数生命死去。 因此矛盾出现了，如果相信这种预言就相当于完全否定自由意志，选择绝对的宿命论，那如果所有人都是命运的傀儡，救这些傀儡有什么意义</p>
<p>此外这么一搞，魔族至少发动复仇战争是百分百的正当，由此显得ke里这个救世主身份非常奇怪，就算dr里是if线，古伊奈也是会为了预言去刺杀魔族鸽派的人物，多少有点太极端了</p>
<h1 id="电波">电波</h1>
<p>当我们看电波系的时候我们在看什么<br />
所谓的电波系，一般来说，都有相当一部分的剧情是妄想或者被妄想歪曲的“现实”，但这个现实是故事里的现实，故事的全貌只有作者知道，读者只知道他写出来的部分，因此这个现实也不是完全的现实，妄想部分只是又加了一层故事而已，一般来说，我们看毒电波的时候，主要任务就是把这两层故事分清楚<br />
也就是说，虽然直观地看电波系的魅力在于现实与虚假的辨别，但幻想和幻想的幻想都是幻想，两者是虚假和虚假的关系。那么任务反而变成了分清两层故事的逻辑，规律，设定等等属性，两层都可以是真的，因为他们都是虚构的故事，没有故事比其他故事更真实</p>
<h1 id="da4">da4</h1>
<p>我现在就等着看da4笑话了，盘算了一下，真没什么利好因素<br />
第一个笑话是2024年有没有官中，这个是最基本的了，2077国区销量至少三四百万，黑猴更不说了，首周破千万。如果生软想和中国玩家和好，那至少dao应该搞个官中来预热一下，因此我看大概率没有，没有的话也省事了，你da4什么质量值得我用非母语去玩？笑话我也不看了，直接弃<br />
第二个笑话是彩虹旗，主角团七个人要是全是彩虹阵营，那这就不是da了，是欧美版葫芦娃，我顺直凑什么热闹，让lgbt玩去<br />
第三个笑话是坑怎么填，me珠玉在前，欧美暴躁老哥是真寄刀片，da4做到一半标题都改了，我只能说不太相信时至今日生软的填坑能力，而且已经隔了正好十年了，上一个隔了近十年出新作的还是杯赛，星空算不算大成功我也不多说了<br />
第四个笑话是“开放世界”，dai 的开放世界我只能说玩得下去的都神人了，我常年杯赛黑，但说句公道话，生软对大世界的理解不如杯赛一根毛，连巫师三都比不上，要是再复刻找路捡瓶盖，man what can i say? 总之，我先放好香槟在这里，等生软解散了就开一瓶</p>
<h1 id="wrpg">wrpg</h1>
<p>对比同样是典中典的辐射，博德之门的新老交替就没什么火药味，如果wrpg做一个势力系统，拉瑞安和所有厂友好度都得是友好以上，甚至作为近十年的两颗新星，和cdpr都没什么摩擦。<br />
当然l和c的风格基本是背道而驰的，没什么摩擦也正常，但杯赛和黑曜石风格也完全不同，为什么关系这么差呢？这只能怪新老辐射风格相差太大了，这还不算完，又找来和老辐射风格又不完全相同的黑曜石做fnv，当然得天天打架。<br />
博德版权方不是游戏厂商，博德3也没有180度转弯，隔得时间也长，平稳过渡并不奇怪<br />
单机界玩家间虽然分阵营攻讦不休，同类型厂商间还真是友商，能玩100小时的就是大制作了，只要隔三个月以上玩家时间就不冲突。wrpg里面，cdpr算是比较离经叛道的，搞电影化叙事。<br />
拉瑞安是唯一一个比较正统且大火的，算是引了一大波新血，黑曜石作为老博德的另一个继承者可以考虑蹭个热度，黑石头要么这几年要么叫好不叫座，要么不叫好也不叫座，虽然还没沦落到被喝倒彩，但多少有点缺少生气了</p>
<p>wrpg玩家的美梦:老生软的队友塑造，黑曜石的网状叙事，黑岛的主线，杯赛的大世界探索，cdpr的dlc，拉瑞安的玩法和运营，zaum的文笔和深度，猫头鹰的阵营<br />
wrpg玩家的噩梦:新生软的建模，杯赛的优化，cdpr的首发……<br />
最要命的是什么呢？没错，就是zaum的boss，当然生软的boss也很逆天，但至少生软还活着</p>
<h1 id="永恒之柱">永恒之柱</h1>
<p>柱子算是粉丝向游戏典范了，老粉基本满意，新玩家也不会被引进来。为什么说是典范呢，因为新老粉都不满意的粉丝向游戏太多了，稳定发挥已经算不错了。柱子其实就像去掉了爽文剧情的2d版新维加斯，因为没那么爽文展开，只剩下lore和细致的阵营系统了，不那么吸引人。<br />
比起看上去延续柱子风格的宣誓，我倒更希望黑曜石去做pentiment like，小而美，并且开头就吸引人，几乎从头到尾悬念拉满，题材还非常少见(有勇气和能力认真考据历史的编剧，特别是游戏行业是很少见的),单周目10h卖个148左右，设定集稍微贵点，我倒是愿意入首发支持一下。<br />
虽然我不喜欢lgbt，但生软相比黑曜石来说最大的问题是，抛弃了基本盘。要是dai有dao的综合质量，就算全是变性人我也能给个好评，问题是做成了育碧式开放世界，当然这么说乳育碧了，rpg化的ac我没玩，但截止大革命，没有一部刺客信条能比dai还公式化，甚至一贯来说任务设计的重点，队友任务，都有极高的收集含量。这种对收集，清问号的极端强调，博德之门12没有，异域镇魂曲没有，质量效应没有，dao没有，巫师12没有，上古卷轴没有，新维加斯也没有。也就是说，这么做没有任何粉丝基础，包括绝大部分wrpg类型粉丝。<br />
相反，黑曜石截止目前是相当忠于粉丝的，对粉丝来说只能吐槽一下优化逆天，没什么创新点，或者美术没什么亮点之类的，生软要是不搞公式化开放世界，虽然综合看水平还是普通，至少不会像现在这样蒸蒸日上</p>
<p>破除人类中心主义是个没什么人提的政治正确，我估计大部分人和我一样扮演精灵，矮人，甚至半身人，或者种族混血时会很难代入，简单地处理，辐射或者巫师之类的游戏锁死人类主角，故事也是人类中心，老滚5之类的游戏虽然有异族可以选，但流程中区别也不大，也没有背景故事，认真处理的游戏不多，我印象里只有神原2和dao对异族做了专属背景故事融入整个流程，所以说dao真是个很有野心的游戏，居然做了两个矮人背景，很难想象有多少人会选矮人主角<br />
当然人类中心主义还不只是主角问题，还涉及到异族是否是背景板，人类是否歧视迫害异族，是否可以帮助异族对抗人类云云。这个问题看上去很扯淡，虚拟种族为什么要平权，但如果虚拟世界种族平等无所谓，为什么现实世界的三观为什么要影响虚拟世界呢？</p>
<h1 id="meta">meta</h1>
<p>meta一般有两种可能，一是实现角色和玩家的对话，二是实现作者和玩家的对话，本作其实是采用后者思路的meta游戏<br />
当然，说是对话，但作者只是单向说，玩家只能听，所以新手指南巧妙地使用了某种错位机制，让玩家代入半个作者半个读者，也就是那位过于热心的旁白先生的视角去看待作者的表达，然后揭示了一个简单朴实的道理——你不能同时当作者和玩家，自我审视自我创作的自我审视的自我创作……那样会在无穷无尽的递归中疯掉，用计算机领域的话说就是stack overflow<br />
在我第一次玩史丹利时，也就是4年前左右，我觉得自己和其中讽刺的“成就党”没什么关系，不过四年过去，很多事改变了，在我看来做成就的推动力不再是似乎与其直接对应的成就感，而是不做成就带来的焦虑感，假设一个人打开硬盘里的某个游戏，没日没夜地玩，然后玩腻了就不管了，当他删除硬盘里的游戏后，他投入的时间和心血就失去了证明。过去的自己真的存在吗，只是现在的我幻想出来的吗？会有这样的想法也很正常吧<br />
为了对抗虚无感，人脑需要不停赋予各种事情意义，最好能符号化，量化，规律化，可以无数次地验证审视，成就，不管是游戏里的成就，还是现实里的银行账户余额都是这种需要的产物<br />
总之，按一万次按钮换一个成就看上去很蠢，但做一万道题目换一个学历也不怎么高明，前者我没太大执念，但后者这样的蠢事倒是一直在干。所以说，游戏里也不算是讽刺，如果按无数次按钮有什么意义，那样也不错</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>wrpg</tag>
        <tag>龙腾世纪</tag>
        <tag>巫师2</tag>
        <tag>影子工厂</tag>
        <tag>不予播出</tag>
        <tag>步行模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>研distance——操作系统部分</title>
    <url>/thinklive/26286/</url>
    <content><![CDATA[<h1 id="概论">概论</h1>
<p><code>操作系统</code>：控制管理计算机的硬件，协调控制资源分配，并为应用程序和用户提供接口以供使用</p>
<h2 id="基本特征">基本特征</h2>
<p><code>操作系统</code>的基本特征包括并发，共享，虚拟和异步</p>
<ol type="1">
<li><p>并发<br />
<code>并发</code>是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。这是通过类似时间片轮转的机制实现的。<br />
<code>并行性</code>是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的动作，需要相关硬件的支持,如多流水线或多处理机硬件环境</p></li>
<li><p>共享<br />
<code>共享</code>：系统内的某些资源可以供并发的不同进程使用，分为以下几种方式<br />
<span id="more"></span></p>
<ol type="1">
<li>互斥共享<br />
规定在一段时间内只允许一个进程访问该资源，系统分配该资源前，必须确保没有其他进程正在使用它，分配后，在进程访问并释放该资源后，其他进程对资源的申请才会被操作系统允许。<br />
这种一段时间内只能被一个进程占有的资源被称为<strong>临界资源</strong><br />
大部分硬件，某些软件的栈，变量等都属于<strong>临界资源</strong><br />
</li>
<li>同时访问<br />
某些系统资源可以在同一时间段内被多个进程同时访问，例如文件系统，这种同时访问可能是交替进行。<br />
互斥共享要求一种资源在一段时间内(哪怕是一段很小的时间)只能满足一个请求，同时访问通常要求一个请求可以分时间片间隔地完成，效果和连续完成相同</li>
</ol></li>
</ol>
<p>并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件：</p>
<ul>
<li>资源共享是以程序的并发为条件的：若系统不允许程序并发执行，则自然不存在资源共享问题<br />
</li>
<li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，其至根本无法并发执行。</li>
</ul>
<ol start="3" type="1">
<li><p>虚拟<br />
<code>虚拟</code>是指把一个物理上的实体变为若干逻辑上的对应物。<br />
虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务<br />
把一个物理cpu虚拟成多个虚拟cpu,称为虚拟处理器<br />
虚拟技术可以在时间或者空间上进行相应的现实虚拟转换</p></li>
<li><p>异步<br />
虽然进程可以并发进行，但推进速度，时间等是不确定的，操作系统必须确保，相同环境下相同操作的进程得到相同的结果，不论时间多久</p></li>
</ol>
<h2 id="功能">功能</h2>
<ol type="1">
<li>管理系统资源
<ol type="1">
<li>处理机(进程)的管理，包括创建，调度，死锁检测和恢复等<br />
</li>
<li>存储器管理，即内存的分配和管理<br />
</li>
<li>文件管理，即操作系统的文件系统空间，目录，格式等<br />
</li>
<li>设备管理，处理用户的I/O请求<br />
</li>
</ol></li>
<li>提供用户接口操作硬件和程序<br />
</li>
<li>命令接口
<ol type="1">
<li>联机命令接口(交互式命令接口，适用于实时或分时系统)：用户通过终端实时输入命令与操作系统交换，输入一条，操作系统解释并执行一条，然后才可以输入下一条(shell)<br />
</li>
<li>脱机命令接口(批处理命令接口,适用于批处理系统)：用作业控制命令写成一本作业说明书，操作系统读取说明书，逐条解释执行(脚本)<br />
</li>
</ol></li>
<li>程序接口：有一系列系统调用组成，用户在程序中使用这些系统调用命令来让操作系统提供相应服务，例如GUI界面(严格的说gui界面只是使用了操作系统提供的图形相关的系统调用)<br />
</li>
<li>实现了对计算机资源的扩充</li>
</ol>
<h2 id="历史">历史</h2>
<ol type="1">
<li>手工操作阶段<br />
缺点：1，cpu利用不充分。2，计算机资源利用率低下<br />
</li>
<li>批处理阶段
<ol type="1">
<li>单道批处理系统：操作系统一次只执行一个程序，依次处理，特征：
<ol type="1">
<li>自动性，磁带上的作业可以自动依次进行<br />
</li>
<li>顺序性，作业有明确顺序依次进入内存<br />
</li>
<li>单道性，内存中只有一个程序运行，任务完成或异常后才调入下一个<br />
问题：任务间隔等待下一个调入时，I/O效率低下<br />
</li>
</ol></li>
<li>多道批处理程序，内存中可以有多个程序共享系统资源，交替运行，避免I/O期间的算力浪费，特点是：
<ol type="1">
<li>多道，内存存放多道程序<br />
</li>
<li>宏观上并行，内存中的程序都处于运行状态<br />
</li>
<li>微观上串行，程序交替使用cpu<br />
问题：处理器资源，内存资源和I/O的分配，以及如何组织处理大量的程序和数据<br />
在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。</li>
</ol></li>
</ol></li>
</ol>
<ul>
<li>优点：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用：系统吞吐量大，CPU和其他资源保持“忙碌”状态。<br />
</li>
<li>缺点：用户响应的时间较长：不提供人机交互能力，用户既不能了解自已的程序的运行情况，又不能控制计算机。</li>
</ul>
<ol start="3" type="1">
<li><p>分时操作系统<br />
将处理器的运算分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。时间片内不能完成的作业等到下个周期继续进行，时间片很短，因此对用户来说几乎实时。<br />
分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰，同时有较快的交互速度<br />
特性：</p>
<ol type="1">
<li>同时性，允许多个用户同时使用一台计算机(多终端)<br />
</li>
<li>交互性<br />
</li>
<li>独立性，各个用户相对独立，不会互相影响<br />
</li>
<li>及时性，对用户请求用较快的速度回应</li>
</ol></li>
<li><p>实时操作系统<br />
一些特殊场合(比如飞行器系统)，对操作的时限有硬性要求(或者软性要求)，这样的操作系统叫做实时操作系统<br />
其中绝对无法违反时限的是硬实时系统，偶尔可以违反的是软实时系统<br />
特点：</p></li>
</ol>
<ul>
<li>及时性<br />
</li>
<li>可靠性</li>
</ul>
<ol start="5" type="1">
<li><p>其他<br />
网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效地使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。<br />
分布式计算机系统是由多台计算机组成并满足下列条件的系统：</p>
<ul>
<li>系统中任意两台计算机通过通信方式交换信息：<br />
</li>
<li>系统中的每台计算机都具有同等的地位，即没有主机也没有从机：每台计算机上的资源为所有用户共享：<br />
</li>
<li>系统中的任意台计算机都可以构成一个子系统，并且可以重构；<br />
</li>
<li>任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。<br />
用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。</li>
</ul></li>
<li><p>个人计算机操作系统<br />
个人计算机操作系统是目前使用最广泛的操作系统，常见的有Windows、Linux和Macintosh等。</p></li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231204211804.png" /></p>
<h2 id="运行环境">运行环境</h2>
<p>cpu一般执行两种程序，一种是操作系统内核程序，另一种是用户程序，因此对cpu指令需要做区分</p>
<ul>
<li>特权指令，是指不允许用户直接使用的指令，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。<br />
</li>
<li>非特权指令，是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。<br />
在具体实现上，将CPU的运行模式划分为用户态(目态)和核心态 (又称管态，内核态)</li>
</ul>
<h3 id="内核机制">内核机制</h3>
<ol type="1">
<li>时钟管理，提供计时功能，是时间片轮转，实时系统的截止时间等功能的基础<br />
</li>
<li>中断机制，操作系统的大部分功能都依赖中断，可以说现代操作系统是中断驱动的，中断机制只有一小部分属于内核，负责保护和恢复现场等<br />
</li>
<li>原语，操作系统的底层小程序，有以下特点
<ol type="1">
<li>最底层，最接近硬件<br />
</li>
<li>操作有原子性，不可分割<br />
</li>
<li>运行时间短，调用频繁<br />
</li>
</ol></li>
<li>系统控制的数据结构和处理,常见操作有
<ol type="1">
<li>进程管理<br />
</li>
<li>存储器管理<br />
</li>
<li>设备管理</li>
</ol></li>
</ol>
<h3 id="中断和异常">中断和异常</h3>
<p>由于用户态的某些操作需要核心态的一些功能，需要中断和异常机制，来让cpu从用户态进入核心态(这通过硬件实现，比如一个特殊寄存器)<br />
<code>中断</code>(Interruption)也称外中断，是指来自CPU执行指令外部的事件，通常用于信息输入/输出，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等<br />
<code>异常</code>(Exception)也称内中断，是指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。异常不能被屏蔽，一出现，就应立即处理。<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231204215335.png" /><br />
二者的分类如图，其中：<br />
故障(Fault)通常是由指令执行引起的异常，如非法操作码，缺页故障、除数为0、运算溢出等。<br />
自陷(Trap)是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序。<br />
终止(Abort)是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。</p>
<p>故障异常和自陷异常属于软件中断(程序性异常)，终止异常和外部中断属于硬件中断。</p>
<p>中断处理流程：操作系统发现中断请求或者异常后，打断当前程序，调转到中断或者异常的处理程序，如果程序能解决问题，就再次回到现场继续执行，如果是致命错误，则终止程序</p>
<h3 id="系统调用">系统调用</h3>
<p>一般涉及对系统资源的请求，都需要系统调用，系统调用可以视为一种特殊的公共子程序<br />
常见类型：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。<br />
</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。<br />
</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。<br />
</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。<br />
</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能</li>
</ul>
<p>用户程序可以执行陷入指令(又称访管指令或trap指令)来发起系统调用，此时相当于cpu使用权被交给内核，来让cpu进入核心态执行特权指令，最后结果和cpu返还给程序<br />
当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序：也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。<br />
管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231204220927.png" /></p>
<p>执行系统调用的过程如下：正在运行的进程先传递系统调用参数，然后由陷入(trap)指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核态服务程序，最后返回用户态。</p>
<div class="note warning"><ul>
<li>由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的,此外，这个转变是硬件完成的，核心态到用户态则是操作系统完成<br />
</li>
<li>访管指令在用户态使用，因此不是特权指令<br />
</li>
<li>输入输出这种涉及到中断机制的指令，必须在核心态执行<br />
</li>
<li>命令解释这种与用户交互的程序在用户态执行，而进程调度则需要核心态(单个用户不应能影响进程这样的全局状态，否则就可以只让自己的进程优先执行)<br />
</li>
<li>外部中断时，通用寄存器由操作系统保存，PC(程序计数器)则由中断指令自动保存<br />
</li>
<li>时钟中断后，服务程序应当更新内核中时钟变量的值,当前进程占用CPU的时间,当前进程在时间片内的剩余执行时间等全部时钟相关的数据<br />
</li>
<li>操作系统通过提供系统调用避免用户程序直接访问外设<br />
</li>
<li>当CPU检测到中断信号后，由硬件自动保存被中断程序的断点(即程序计数器PC)，之后，硬件找到该中断信号对应的中断向量，中断向量指明中断服务程序入口地址(各中断向量保存PSW、保存中断屏蔽字、保存各通用寄存器的值，并提供与中断信号对应的中断服务，中断服务程序属于操作系统内核)<br />
</li>
<li>能在内核态下执行。常见的特权指令有：
<ul>
<li>有关对IO设备操作的指令<br />
</li>
<li>有关访问程序状态的指令<br />
</li>
<li>存取特殊寄存器的指令<br />
</li>
</ul></li>
<li>通道技术和中断技术结合起来就可实现CPU与I/O设备并行工作，即CPU启动通道传输数据后便进行其他程序的计算工作，而通道则进行输入输出操作；通道工作结束后，通过中断让cpu进行处理，处理完再各自进行对应的工作</li>
</ul>
</div>
<h2 id="结构">结构</h2>
<ol type="1">
<li><p>分层法<br />
最底层为硬件，最高层为用户接口，每个高层只能调用它向下单层的功能和服务<br />
优点：</p>
<ol type="1">
<li>便于调试和验证，由于每层都相对独立，可以隔绝问题，在单层定位问题<br />
</li>
<li>易于扩充维护，只要确保层间接口不便，就可以随意修改单层内的模块</li>
</ol></li>
</ol>
<p>问题：1，难于定义各层。2，由于有时需要跨多层调用，额外开销较大，效率较低</p>
<ol start="2" type="1">
<li><p>模块化<br />
将操作系统定义成各种有自己接口的模块，各模块通过接口进行组合和通信<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231205144922.png" /><br />
这样的结构需要保证模块之间的独立性，即：</p>
<ul>
<li>内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。<br />
</li>
<li>耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。<br />
模块化的优点：①提高了操作系统设计的正确性、可理解性和可维护性：②增强了操作系统的可适应性：③加速了操作系统的开发过程。<br />
模块化的缺点：①模块间的接口规定很难满足对接口的实际需求。②各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。</li>
</ul></li>
<li><p>宏内核<br />
宏内核，指将系统的主要功能模块作为整体运行在核心态，从而为用户程序提供高性能的系统服务。各管理模块之间共享信息，性能较高；但同时有更高耦合性，一个模块故障可能波及整个系统<br />
主流操作系统都使用了宏内核，但事实上也在逐渐引进微内核技术，成为一种混合结构</p></li>
<li><p>微内核<br />
微内核构架，是指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。<br />
一般可以分为两个部分：</p></li>
</ol>
<ul>
<li>微内核,实现操作系统最基本核心功能的小型内核
<ul>
<li>与硬件紧密相关的功能<br />
</li>
<li>基本功能<br />
</li>
<li>客户和服务器的通信<br />
</li>
</ul></li>
<li>多个服务器</li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231205151119.png" /><br />
为了实现高可靠性，只有微内核运行在内核态，其余模块都运行在用户态，一个模块的错误不会影响整个系统<br />
微内核的功能：</p>
<ul>
<li>进程(线程)管理：进程的通信，切换，调度，多处理器的同步等都应该放入微内核，但进程分类，优先级确定等不涉及机制的功能可以放入进程管理服务器<br />
</li>
<li>低级存储器管理：比如页表机制和地址变换机制，而虚拟存储器的管理，页面置换算法等则由存储器管理服务器管理<br />
</li>
<li>中断和陷入处理，捕获相关事件，进行中断响应处理，然后发送给相关服务器来处理</li>
</ul>
<p>优点：</p>
<ul>
<li>拓展性和灵活性<br />
</li>
<li>可靠性和安全性<br />
</li>
<li>可移植性(和硬件有关的都在微内核中，其他服务器和硬件无关)<br />
</li>
<li>分布式计算，通信采用消息传递机制，很好的支持分布式系统和网络系统</li>
</ul>
<p>微内核结构的主要问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。</p>
<ol start="5" type="1">
<li>外核<br />
不同于虚拟机克隆真实机器，另一种策略是对机器进行分区，给每个用户整个资源的一个子集。在底层中，一种称为外核(exokernel)的程序在内核态中运行。它的任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机有自己的操作系统，但资源是受限制的<br />
外核机制的优点是减少了映射层。在其他的设计中，每个虚拟机都认为它有自己的磁盘，这样虚拟机监控程序就必须维护一张表格以重映像磁盘地址，有外核就不需要维护这个表格了，并且实现了各个虚拟机之间的安全划分，没有冲突</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240208095549.png" /></p>
<h2 id="引导">引导</h2>
<p>操作系统引导过程：</p>
<ol type="1">
<li>激活CPU。激活的CPU读取ROM中的boot程序，将指令寄存器的内容置为BIOS(基本输入/输出系统)的第一条指令，即开始执行BIOS的指令。<br />
</li>
<li>硬件自检。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止：如果没有故障，屏幕会显示CPU、内存、硬盘等信息。<br />
</li>
<li>加载带有操作系统的硬盘。硬件自检后，BIOS开始读取BootSequence(通过CMOS里保存的启动顺序，或者通过与用户交互的方式)，把控制权交给启动顺序排在第一位的存储设备，然后CPU将该存储设备引导扇区的内容加载到内存中。<br />
</li>
<li>加载主引导记录MBR。硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统。<br />
</li>
<li>扫描硬盘分区表，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区(活动分区)。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。<br />
</li>
<li>加载分区引导记录PBR。读取活动分区的第一个扇区，这个扇区称为分区引导记录(PBR)，其作用是寻找并激活分区根目录下用于引导操作系统的程序(启动管理器)<br />
</li>
<li>加载启动管理器。分区引导记录搜索活动分区中的启动管理器，加载启动管理器<br />
</li>
<li>加载操作系统</li>
</ol>
<p>简单来说，是指计算机利用CPU运行boot程序(例如焊在主板上的rom中)，先进行自检，然后识别硬盘，找到有系统的硬盘(多系统则需要指定顺序)，由于硬盘分区且操作系统以区为单位存放，因此需要通过MBR中的分区信息寻找活动分区，最后通过分区内特定的引导程序启动操作系统</p>
<h2 id="虚拟机">虚拟机</h2>
<p>虚拟机是一台逻辑计算机，是指利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。有两类虚拟化方法。</p>
<ol type="1">
<li>虚拟机管理程序作为唯一运行在最高特权的程序，在裸机上运行并且具备多道程序功能。管理程序向上层提供若干台虚拟机、这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。</li>
</ol>
<div class="note info"><p>虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统认为自已运行在内核态(实际上不是)，称为虚拟内核态。虚拟机中的用户进程认为自已运行在用户态(实际上确实是)<br />
当虚拟机操作系统执行了一条CPU处于内核态才允许执行的指令时，会陷入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。</p>
</div>
<ol start="2" type="1">
<li>类似一个依赖宿主机的普通进程，操作系统安装到虚拟磁盘上(其实只是宿主操作系统中的一个文件)。客户操作系统安装完成后，就能启动并运行。 此时，虚拟机管理程序伪装成一台计算机(比如vmware)</li>
</ol>
<p>有的教材将第一类虚拟化技术称为裸金属架构，将第二类虚拟化技术称为寄居架构</p>
<div class="note warning"><ul>
<li>通常可以从四个方面来描述微内核OS：①内核足够小；②基于客户/服务器模式；③应用“机制与策略分离”原理；④采用面向对象技术。<br />
</li>
<li>常驻内存的只是操作系统内核，其他部分仅在需要时才调入。<br />
</li>
<li>操作系统的引导程序位于磁盘活动分区的引导扇区中。引导程序分为两种：一种是位于ROM中的自举程序(BIOS的组成部分)，用于启动具体的设备；另一种是位于装有操作系统硬盘的活动分区的引导扇区中的引导程序(称为启动管理器)，用于引导操作系统<br />
</li>
<li>CPU激活后，会从最顶端的地址FFFF0H获得第一条指令来执行，这个地址仅仅只有16字节，放不下一段程序，所以是一条JMP指令，以跳到更低地址去执行BIOS程序。BIOS程序在内存最开始的空间构建中断向量表和相应服务程序,在后续POST过程中要用到中断调用等功能。然后进行通电自检POST (Power-on Self Test)以检测硬件是否有故障。完成POST后，BIOS需要在硬盘、光驱或软驱等存储设备搜寻操作系统内核的位置以启动操作系统<br />
</li>
<li>BIOS将控制权交给排在首位的启动设备后，CPU将该设备主引导扇区的内容(主引导记录MBR)加载到内存中，然后由MBR检查分区表，查找活动分区，并将该分区的引导扇区的内容(分区引导记录PBR)加载到内存加以执行<br />
</li>
<li>机制是指实现某一功能的具体执行机构。策略则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。在传统的OS中，将机制放在OS内核的较低层中，把策略放在内核的较高层中。而在微内核OS中，通常将机制放在OS的微内核中。正因如此，才可以将内核做得很小<br />
</li>
<li>处于用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，访管中断处理程序将按系统调用的操作数和参数转到相应的例行子程序。完成服务功能后，退出中断，返回到用户程序断点继续执行。</li>
</ul>
</div>
<hr />
<h1 id="进程和线程">进程和线程</h1>
<h2 id="进程">进程</h2>
<p>为了更好的控制并发的多个程序，引入了进程(process)的概念<br />
进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位(<strong>但不是最小的</strong>)。进程是一个动态的、过程性的概念,而程序则是静态的二进制码<br />
对每个进程必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block, PCB),PCB是对进程的唯一标志</p>
<p>特征：</p>
<ul>
<li>动态性<br />
</li>
<li>并发性，多个进程实体同时存在于内存，在一段时间内并发执行<br />
</li>
<li>独立性，进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位<br />
</li>
<li>异步性，进程推进的速度不可预知，因此需要相应的同步策略</li>
</ul>
<p>状态(前三个是基本状态)：</p>
<ol type="1">
<li>运行态，在处理机上运行<br />
</li>
<li>就绪态，进程得到了处理机外的所有资源，就绪的进程一般用就绪队列管理<br />
</li>
<li>阻塞态，进程正在等待某个事件或者资源，一般会用多个阻塞队列管理这样的进程<br />
</li>
<li>创建态，进程正在创建，还没进入就绪态，比如没有足够分配的资源时创建进程<br />
</li>
<li>终止态，结束进程时先设置成终止态，随后进行资源释放等工作</li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231206201905.png" /></p>
<h3 id="组成">组成</h3>
<ol type="1">
<li><p><strong>PCB</strong><br />
PCB是进程实体的一部分，是进程存在的唯一标志，也被用于存储进程状态，断点的恢复和保存<br />
<div class="note info"><p>当操作系统欲调度某进程运行时，要从该进程的PCB中查出其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB；当进程由于某种原因而暂停运行时，又需将其断点的处理机环境保存在PCB中。在进程的整个生命期中，系统通过PCB对进程进行控制</p>
</div><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231206202831.png" /><br />
PCB的组成如图，其中寄存器值一般用于切换进程时保护现场，以备之后从断点执行，这些信息也被称上下文。<br />
对进程的管理一般通过对PCB进行组织来进行，一般可以分为链表和索引两种组织方式，不同进程状态对应不同索引或队列(链式队列)</p></li>
<li><p><strong>程序段</strong><br />
程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可被多个进程共享，即多个进程可以运行同一个程序。<br />
进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为<strong>原语</strong></p></li>
<li><p><strong>数据段</strong><br />
一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p></li>
</ol>
<h3 id="控制">控制</h3>
<ol type="1">
<li><p><strong>创建</strong><br />
子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，通常也会同时撤销其所有的子进程。<br />
操作系统创建一个新进程的过程如下(创建原语)：</p>
<ol type="1">
<li>为新进程分配一个唯一的进程标识号，并申请一个空白PCB (PCB是有限的)。若PCB申请失败，则创建失败。<br />
</li>
<li>为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等(在PCB中体现)。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足(如内存)，则并不是创建失败，而是处于创建态，等待内存资源。<br />
</li>
<li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。<br />
</li>
<li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行</li>
</ol></li>
<li><p><strong>终止</strong><br />
引起进程终止的事件主要有：</p>
<ul>
<li>正常结束，进程的任务己完成并准备退出运行。<br />
</li>
<li>异常结束，进程在运行时，发生了某种异常事件，如存储区越界、I/O故障等。<br />
</li>
<li>外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止</li>
</ul></li>
<li><p><strong>阻塞和唤醒</strong><br />
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败等，进程便通过调用阻塞原语(Block),使自己由运行态变为阻塞态。</p></li>
</ol>
<p>阻塞原语的执行过程如下：</p>
<ol type="1">
<li>找到将要被阻塞进程的标识号对应的PCB<br />
</li>
<li>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。<br />
</li>
<li>把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程</li>
</ol>
<p>当被阻塞进程所期待的事件出现时，如它所期待的I/O操作已完成或其所期待的数据已到达，由有关进程调用唤醒原语(Wakeup),将等待该事件的进程唤醒。</p>
<p>唤醒原语的执行过程如下：</p>
<ol type="1">
<li>在该事件的等待队列中找到相应进程的PCB<br />
</li>
<li>将其从等待队列中移出，并置其状态为就绪态。<br />
</li>
<li>把该PCB插入就绪队列，等待调度程序调度。</li>
</ol>
<div class="note info"><p>就像c++的new和delete一样，阻塞和唤醒必须成对进行，否则就会出现"睡美人"</p>
</div>
<h3 id="通信">通信</h3>
<p>进程通信是指进程之间的信息交换</p>
<ol type="1">
<li><p><strong>共享存储</strong><br />
在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换,此时需要PV等机制来进行同步。<br />
共享存储又分为两种：</p>
<ul>
<li>低级方式的共享是基于数据结构的共享<br />
</li>
<li>高级方式的共享则是基于存储区的共享<br />
<div class="note info"><p>进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的</p>
</div></li>
</ul></li>
<li><p><strong>消息传递</strong><br />
在消息传递系统中，进程间的数据交换以格式化的消息(Message)为单位。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。 这种方式公开透明，简化了程序的设计，因此应用比较广泛<br />
在微内核操作系统中，微内核与服务器之间的通信就采用了消息传递机制。由于该机制能很好地支持多处理机系统、分布式系统和计算机网络，因此也成为这些领域最主要的通信工具。<br />
分为：</p>
<ol type="1">
<li>直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息<br />
</li>
<li>间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中。</li>
</ol></li>
<li><p><strong>管道通信</strong><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231206213642.png" /><br />
管道通信允许两个进程按生产者-消费者方式进行通信,生产者向管道的一端写，消费者从管道的另一端读。<br />
数据在管道中是先进先出的。只要管道非空，进程就能从管道中读出数据，若数据被读空，则读进程阻塞，直到写进程往管道中写入新的数据，再将读进程唤醒。<br />
只要管道不满，写进程就能往管道中写入数据，若管道写满，则写进程阻塞，直到读进程读出数据，再将写进程唤醒。<br />
为了协调双方的通信，管道机制必须提供三方面的协调能力：互斥、同步和确定对方的存在。<br />
<div class="note info"><p>实例：<br />
在linux中，管道是一种文件，准确的说是一个固定大小(4KB)的缓冲区，写满时自动阻塞，直到部分数据被读取，被读空时，则对读操作阻塞，直到有新的内容写入</p>
</div><br />
管道只能由创建进程所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并使用它来与父进程进行通信</p></li>
</ol>
<h2 id="线程和多线程模型">线程和多线程模型</h2>
<h3 id="概念">概念</h3>
<p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。<br />
线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。<br />
一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。<br />
<div class="note info"><p>线程也有就绪、阻塞和运行三种基本状态<br />
进程是除CPU外的系统资源的分配单元，而线程则作为处理机的分配单元。</p>
</div></p>
<p><strong>和进程的比较</strong>：</p>
<ol type="1">
<li>调度，引入线程后，线程才是独立调度的基本单位，而线程切换的代价远低于进程,同一进程的线程可以随意切换，而避免较大的上下文切换开销<br />
</li>
<li>并发，引入线程后，一个进程的线程，以及不同进程的线程都可以并发执行，提高了系统的资源利用率和吞吐量<br />
</li>
<li>拥有资源，进程是拥有系统资源的最小单位，线程除了极少必要资源不占有资源，同一进程的线程有相同的地址空间，可以共享该进程资源<br />
</li>
<li>独立性，进程之间相互独立，除了共享资源无法互相访问，线程则可以共享资源和地址空间<br />
</li>
<li>系统开销，由于避免创建PCB，分配资源，切换上下文，通信等开销,线程开销更小<br />
</li>
<li>支持多处理器系统，一个进程的不同线程可以用多个处理器同时运算</li>
</ol>
<h3 id="属性和状态">属性和状态</h3>
<ol type="1">
<li>每个线程都有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。<br />
</li>
<li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。<br />
</li>
<li>同一进程中的各个线程共享该进程所拥有的资源。<br />
</li>
<li>线程是处理机的独立调度单位,可以并发执行。在单CPU的计算机系统中，各线程交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU,若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。<br />
</li>
<li>一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li>
</ol>
<ul>
<li>执行状态：线程己获得处理机而正在运行。<br />
</li>
<li>就绪状态：线程已具备各种执行条件，只需再获得CPU便可立即执行。<br />
</li>
<li>阻塞状态：线程在执行中因某事件受阻而处于暂停状态</li>
</ul>
<div class="note info"><p><strong>线程的组织与控制</strong></p>
<ul>
<li>线程控制块通常包括：①线程标识符；②一组寄存器，包括程序计数器、状态寄存器和通用寄存器；③线程运行状态，用于描述线程正处于何种状态；④优先级；⑤线程专有存储区，线程切换时用于保存现场等；⑥堆栈指针，用于过程调用时保存局部变量及返回地址等。<br />
</li>
<li>各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。<br />
</li>
<li>用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后，将返回一个线程标识符<br />
</li>
<li>通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行</li>
</ul>
</div>
<p><strong>分类</strong></p>
<ol type="1">
<li><p>用户级线程(ULT)<br />
用户级线程的所有管理都在用户空间进行，和内核无关，通常应用从单线程开始，运行中可以随意创建删除线程<br />
优点：</p>
<ol type="1">
<li>不需要切换到内核空间，减少开销<br />
</li>
<li>调度算法可以各个进程专用，便于灵活选择<br />
</li>
<li>不会影响到操作系统层，所有线程只是应用程序，比较稳定</li>
</ol></li>
</ol>
<p>缺点：</p>
<pre><code>1. 一个线程发起系统调用时，所有同进程的线程都要阻塞  
2. 不能发挥多处理机优势  </code></pre>
<ol start="2" type="1">
<li>内核级线程(KLT)</li>
</ol>
<p>线程管理在内核空间进行，由内核分配线程管理块，加以管理</p>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231207185300.png" /><br />
优点：</p>
<pre><code>1. 发挥多处理机优势，多个线程可以并行    
2. 一个线程被阻塞，同进程的其他线程依然可以被调度    
3. 内核支持的线程会占用更小的空间，并有更小的开销    
4. 内核也可以使用多线程，更加灵活地调度线程    </code></pre>
<p>缺点：</p>
<pre><code>1. 对同一进程的线程切换，由于需要切换到内核态才能切换，会产生较大开销     </code></pre>
<ol start="3" type="1">
<li>组合方式</li>
</ol>
<p>内核和用户空间各自可以创建线程，一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。同一进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞</p>
<div class="note info"><p><strong>线程库</strong>(thread library)是为程序员提供创建和管理线程的API。实现线程库主要的方法有如下两种：</p>
<ul>
<li>在用户空间中提供一个没有内核支持的库。这种库的所有代码和数据结构都位于用户空间中。这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用。<br />
</li>
<li>实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个API函数通常会导致对内核的系统调用。</li>
</ul>
<p>目前使用的三种主要线程库是：POSIX Pthreads、Windows APL Java., Pthreads作为POSIX标准的扩展，可以提供用户级或内核级的库。Windows API是用于Windows系统的内核级线程库。Java线程API允许线程在Java程序中直接创建和管理。由于JVM实例通常运行在宿主操作系统之上，Java线程API通常采用宿主系统的线程库来实现，因此在Windows系统中Java线程通常采用Windows API来实现，在类UNIX系统中采用Pthreads来实现。</p>
</div>
<h3 id="多线程模型">多线程模型</h3>
<ol type="1">
<li>多对一模型，多个用户线程(一般属于同一进程)映射到一个内核线程,线程管理在用户空间进行，需要内核访问时，挂载到一个内核线程(每次只能一对一映射)<br />
优点：用户空间管理进程效率较高<br />
缺点：无法多处理机运行，挂载内核线程时线程堵塞则整个进程堵塞<br />
</li>
<li>一对一模型,一个用户线程映射一个内核线程<br />
优点：当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。<br />
缺点：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。<br />
</li>
<li>多对多模型。将n个用户线程映射到m个内核级线程上，要求n&gt;=m。克服了多对一模型并发度不高的缺点，也克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。但实现较复杂。</li>
</ol>
<div class="note warning"><ul>
<li>程序这种静态概念难以描述程序的并发执行，因此需要进程这样的动态概念<br />
</li>
<li>引入线程后，进程仍然是资源分配的单位。内核级线程是处理器调度和分派的单位<br />
</li>
<li>PCB内所含的数据结构内容，主要有四大类：进程标志信息、进程控制信息、进程资源信息、CPU现场信息<br />
</li>
<li>唯有进程中某线程的栈指针(包含在线程TCB中)是属于线程的，属于进程的资源可以共享，属于线程的栈指针是独享的，对其他线程透明<br />
</li>
<li>父进程可与子进程共享一部分资源，<strong>但不能共享虚拟地址空间</strong>，在创建子进程时，会为子进程分配资源，如虚拟地址空间等<br />
</li>
<li>执行一条命令或运行一个应用程序时，进程和程序之间形成一对一的关系。进程在执行过程中可以加载执行不同的应用程序，从而形成一对多的关系；以不同的参数或数据多次执行同一个应用程序时，形成多对一的关系；并发地执行不同的应用程序时，形成多对多的关系<br />
</li>
<li>父进程与子进程同时执行(并发)。主程序调用子程序后，主程序暂停在调用点，子程序开始执行<br />
</li>
<li>主要的进程通信方式：共享内存，共享文件，管道，消息传递<br />
</li>
<li>二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时使用的变量在数据栈段</li>
</ul>
</div>
<h2 id="处理机调度">处理机调度</h2>
<p><code>处理机调度</code>是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231207212550.png" /></p>
<p><strong>调度的层级</strong></p>
<ol type="1">
<li>高级调度(作业调度)，从外存的后备队列中作业中选取一个调入内存，并分配资源，建立进程。多见于多道批处理系统<br />
</li>
<li>中级调度(内存调度)，把暂时不能运行的进程调到外存等待，进程进入挂起态，等内存有所空余时调入进入就绪态的进程进入内存，修改成就绪态，入队就绪队列<br />
</li>
<li>低级调度(进程调度)，从就绪队列选取一个进程交给处理机，最常见最频繁的调度</li>
</ol>
<p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。<br />
挂起指的是进程被调到外存，是内存调度的工作，可分为就绪挂起和阻塞挂起，与阻塞不同的是，阻塞只是暂时无法获得cpu，但进程还在内存中</p>
<p><strong>调度的目标</strong></p>
<ol type="1">
<li>CPU利用率(cpu有效工作时间/(有效工作时间+等待时间))<br />
</li>
<li>系统吞吐量，单位时间内cpu完成作业的数量<br />
</li>
<li>周转时间，作业完成时间-作业提交时间。
<ol type="1">
<li>平均周转时间<br />
</li>
<li>带权周转时间(作业周转时间/作业实际运行时间)<br />
</li>
<li>平均带权周转时间，带权周转时间的平均值<br />
</li>
</ol></li>
<li>等待时间，进程等待时间之和<br />
</li>
<li>响应时间，用户提交需求到系统首次响应需要的时间，对交互式系统是一个重要指标</li>
</ol>
<p>以上指标不可能兼顾，必须有所取舍</p>
<h3 id="实现">实现</h3>
<p>用于调度和分派CPU的组件称为调度程序，一般由三部分组成</p>
<ol type="1">
<li>排队器，把系统内部的就绪进程排列成一个或者多个就绪队列<br />
</li>
<li>分派器，根据调度程序选择的进程，把指定进程从队列中拉出，分配cpu<br />
</li>
<li>上下文切换器，需要进行两个上下文操作
<ol type="1">
<li>保存当前程序的上下文到其PCB,装入分派程序的上下文<br />
</li>
<li>移出分派程序的上下文，将其PCB内的cpu现场信息装入cpu的寄存器</li>
</ol></li>
</ol>
<p>通常采用两组寄存器，其中一组供内核使用，一组供用户使用。这样，上下文切换时，只需改变指针，让其指向当前寄存器组即可<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231208111859.png" /></p>
<div class="note info"><p><strong>不能立刻进行调度的特殊情况</strong>：</p>
<ol type="1">
<li>处理中断时，理论上中断是系统级工作，不应被进程影响<br />
</li>
<li>进程在系统内核临界区，由于此时一般进程被加锁，解锁前不应切换进程(普通临界区则可以)<br />
</li>
<li>其他需要屏蔽中断的原子操作</li>
</ol>
<p><strong>需要进行调度的情况</strong>：</p>
<ol type="1">
<li>发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。属于非剥夺调度。<br />
</li>
<li>中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。属于剥夺方式的调度</li>
</ol>
<p>现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p>
<p>有一种特殊的闲逛进程，在没有就绪进程时被处理机运行，一旦有就绪进程就被抢占</p>
</div>
<p>进程调度分为两种：</p>
<ul>
<li>抢占调度(剥夺方式)，一个进程在处理机执行时，允许暂停该进程分配处理机给另一个进程<br />
</li>
<li>非抢占调度(非剥夺方式)，在进程运行完成或者进入阻塞态前，不允许其他进程获得它的处理机</li>
</ul>
<p>线程调度：</p>
<ul>
<li>用户级线程，调度和内核无关，交给进程调度<br />
</li>
<li>内核级线程，内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。</li>
</ul>
<h3 id="调度算法">调度算法</h3>
<ol type="1">
<li><p><strong>FCFS先来先服务</strong>(非抢占)<br />
进程先进先出地进入队列，算法每次都选取最先进入就绪队列的进程运行，直到完成或阻塞才释放<br />
相对利好长作业和cpu密集作业</p></li>
<li><p><strong>SJF短作业优先</strong>(非抢占)<br />
从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机<br />
所有进程都几乎同时到达时，SJF调度算法的平均等待时间、平均周转时间最少,但会产生饥饿问题，且没有考虑优先级，依赖的估计也未必准确<br />
抢占式的短作业/进程优先调度算法(最短剩余时间优先, SRNT算法)的平均等待时间、平均周转时间最少</p></li>
<li><p><strong>优先级调度</strong></p></li>
</ol>
<p>调度算法按照优先级从就绪队列调入进程给处理机，可分为抢占与非抢占<br />
根据优先级是否改变，也可以分为静态和动态优先级<br />
优先级设置的可能原则：</p>
<ul>
<li>系统进程&gt;用户进程<br />
</li>
<li>交互进程&gt;非交互进程<br />
</li>
<li>I/O密集大于cpu密集</li>
</ul>
<ol start="4" type="1">
<li>高响应比优先</li>
</ol>
<p>响应比Rp=((等待时间+要求服务时间)/要求服务时间)<br />
等待时间相同时类似SJF，要求服务时间相同时类似FCFS，但解决了饥饿问题</p>
<ol start="5" type="1">
<li>时间片轮转调度</li>
</ol>
<p>主要适用于分时系统，按时间片以此选取进程运行</p>
<ol start="6" type="1">
<li>多级队列调度</li>
</ol>
<p>设置多个就绪队列，每个队列有不同的调度策略</p>
<ol start="7" type="1">
<li>多级反馈队列调度</li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231209141033.png" /></p>
<ul>
<li>设置多个就绪队列，优先级依次递减，优先级越高的队列，时间片越短<br />
</li>
<li>对一个新进程来说，首先进入第一个队列末尾，如果在第一个时间片内成功则撤离，否则进入第二个队列末尾，这样依次进行，最后一级队列按时间片轮转调度<br />
</li>
<li>只有前面的队列为空，才会轮到下一级的队列，如果有更高优先级的进程来到，可以抢占低优先级或者说低层的进程，被抢占的进程放到该队列末尾</li>
</ul>
<p><code>上下文切换</code>：切换进程时,保存上一个进程的状态，并恢复另一个进程的状态<br />
<strong>上下文切换的过程</strong></p>
<ol type="1">
<li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器<br />
</li>
<li>更新PCB信息<br />
</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列<br />
</li>
<li>选择另一个进程执行，并更新其PCB<br />
</li>
<li>跳转到新进程PCB中的程序计数器所指向的位置执行<br />
</li>
<li>恢复处理机上下文</li>
</ol>
<ul>
<li>上下文切换对系统来说意味着消耗大量的CPU时间。有些处理器提供多个寄存器组，这样，上下文切换就只需要简单改变当前寄存器组的指针<br />
</li>
<li>用户态和内核态之间的切换称为模式切换，而不是上下文切换，因为没有改变当前的进程。上下文切换只能发生在内核态，它是多任务操作系统中的一个必需的特性<br />
</li>
<li>一般来说，先有资源的调度，然后才有进程的切换</li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231209141146.png" /></p>
<div class="note warning"><ul>
<li>当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，就不会影响处理机的调度<br />
</li>
<li>一般来说，因为I/O操作需要及时完成，I/O型作业的优先权高于计算型作业的优先权<br />
</li>
<li>0时刻的调度也计入调度次数<br />
</li>
<li>一般来说cpu密集型作业相对较长</li>
</ul>
</div>
<h2 id="同步与互斥">同步与互斥</h2>
<p>为了协调进程之间的相互制约关系，引入了进程同步的概念</p>
<ol type="1">
<li><strong>临界资源</strong>:一次仅允许一个进程使用的资源，对其的访问可分为
<ol type="1">
<li>进入区，需要在此检查是否可以进入，在进入后设置标志，阻止其他进程进入<br />
</li>
<li>临界区，进程访问临界资源的代码<br />
</li>
<li>退出区，将对临界资源的访问标志清除<br />
</li>
<li>剩余区，代码剩余的部分<br />
</li>
</ol></li>
<li><strong>同步</strong>,进程之间由于次序关系产生的等待，传递信息的制约关系<br />
</li>
<li><strong>互斥</strong>，也称间接制约关系，一个进程使用临界资源时，另一个进程必须等待</li>
</ol>
<p>同步机制应该遵守以下准则：</p>
<ol type="1">
<li>空闲让进，临界区空闲时允许进入<br />
</li>
<li>忙则等待,有进程在临界区内，其他进程必须等待<br />
</li>
<li>有限等待，对所有请求进程，应该保证有限时间内能进入临界区<br />
</li>
<li>让权等待，进程不能进入时，应该释放处理器防止忙等待</li>
</ol>
<h3 id="实现互斥的方法">实现互斥的方法</h3>
<p><strong>软件实现</strong>：</p>
<ol type="1">
<li>单标志法</li>
</ol>
<p>设置标志turn,若turn = 0,则允许P0进程进入临界区<br />
两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区,违反了<strong>空闲让进</strong>原则</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">//p0进程  </span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="cf">while</span>(turn!=<span class="dv">0</span>); <span class="co">//进入区  </span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>critical section; <span class="co">//临界区  </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>turn=<span class="dv">1</span>; <span class="co">//退出区  </span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>remainder section;   </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="co">//p1进程  </span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="cf">while</span>(turn!=<span class="dv">1</span>); <span class="co">//进入区  </span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>critical section; <span class="co">//临界区  </span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>turn=<span class="dv">0</span>; <span class="co">//退出区  </span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>remainder section; <span class="co">//剩余区  </span></span></code></pre></div>
<ol start="2" type="1">
<li>双标志法先检查</li>
</ol>
<p>在每个进程访问临界区资源之前，先查看临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。<br />
设置数组flag,如第i个元素<code>flag[i]</code>为FALSE,表示Pi进程未进入临界区，如为TRUE,表示Pi进程进入临界区。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">//Pi进程  </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="cf">while</span>(flag[j]);   </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>flag[i]=TRUE;  <span class="co">//进入区  </span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>critical section; <span class="co">//临界区  </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>flag[i]=FALSE; <span class="co">//退出区  </span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>remainder section; <span class="co">//剩余区  </span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>  </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span class="co">//Pj进程  </span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="cf">while</span>(flag[i]);   </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>flag[j]=TRUE;  <span class="co">//进入区  </span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>critical section; <span class="co">//临界区  </span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>flag[j]=FALSE; <span class="co">//退出区  </span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>remainder section; <span class="co">//剩余区  </span></span></code></pre></div>
<p>在检查对方的flag后和切换自己的flag前有一段时间，有可能都检查通过,例如双方近乎同时检查了，随后就会一起进入临界区<br />
违反<strong>忙则等待</strong>原则</p>
<ol start="3" type="1">
<li>双标志法后检查</li>
</ol>
<p>先将自己的标志设置为TRUE,再检测对方的状态标志，若对方标志为TRUE,则进程等待；否则进入临界区。<br />
当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，结果导致都无法进入的饥饿问题,违背空闲让进与有限等待</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">//Pi进程  </span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>flag[i]=TRUE;   </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="cf">while</span>(flag[j]);   </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>critical section;  </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>flag[i]=FALSE;   </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>remainder section;   </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="co">//Pj进程  </span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>flag[j]=TRUE;  </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a><span class="cf">while</span>(flag[i]);  </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>critical section;  </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>flag[j]=FALSE;  </span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>remainder section;  </span></code></pre></div>
<ol start="4" type="1">
<li>Peterson's Algorithm</li>
</ol>
<p>每个进程在先设置自己的标志后再设置turn标志。这时，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">//Pi进程  </span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>flag [i] =TRUE; turn=j ;   </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="cf">while</span>(flag[j]&amp;&amp;turn==j);  </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>critical section;  </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>flag[i]=FALSE;  </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>remainder section;  </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="co">//Pj进程  </span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>flag [j] =TRUE; turn=i ;   </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="cf">while</span>(flag[i]&amp;&amp;turn==i);  </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>critical section;  </span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>flag[j]=FALSE;  </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>remainder section;  </span></code></pre></div>
<p>flag表示进入意愿，turn表示优先级，如果对方想进入且更优先，则自己要忙等待，利用flag解决临界资源的互斥访问，而利用turn解决"饥饿”现象，因为需要忙等待，违背了<strong>让权等待</strong>原则</p>
<p><strong>硬件实现</strong></p>
<ol type="1">
<li>中断屏蔽方法</li>
</ol>
<p>一个进程进入临界区后直接禁止中断的产生，这种方法有损处理机运行效率，且有中断不被再次启用的风险，且只适用于系统内核的进程</p>
<pre><code>关中断；  
临界区；  
开中断；  </code></pre>
<ol start="2" type="1">
<li>硬件指令方法</li>
</ol>
<p>lock表示资源的两种状态：true表示正被占用，初值为false。进程在进入临界区之前，利用TestAndSet检查标志lock,若无进程在临界区，返回值为false,可以进入，关闭临界资源，把lock置为true,使任何进程都不能进入临界区；若有进程在临界区，则循环检查，直到进程退出。<br />
这样的方法依旧让其他进程会忙等待<br />
Swap类似TSL(Test and Set Lock),只是改用交换的方式检查标志</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>boolean TestAndSet(boolean *lock) &#123;<span class="co">//原子指令,设置某个标志为真，并读出旧标志  </span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    boolean old;  </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    old=*lock;  </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>    *lock=<span class="kw">true</span>;  </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    <span class="cf">return</span> old;  </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>&#125;  </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>Swap(boolean *a, boolean *b) &#123;  </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    boolean temp;  </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    temp=*a;  </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>    *a=*b; .  </span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>    *b=temp;  </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>&#125;  </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a><span class="co">//testandset实现互斥  </span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a><span class="cf">while</span> TestAndSet(&amp;lock) ;  </span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a><span class="co">//进程的临界区代码段；  </span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>lock=<span class="kw">false</span>;  </span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a><span class="co">//进程的其他代码；  </span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a>  </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a><span class="co">//用swap实现互斥  </span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a><span class="dt">bool</span> key=<span class="kw">true</span>;  </span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true"></a><span class="cf">while</span>(key!=<span class="kw">false</span>) Swap(&amp;lock, &amp;key);  </span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true"></a><span class="co">//进程的临界区代码段；  </span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true"></a>lock=<span class="kw">false</span>;  </span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true"></a><span class="co">//进程的其他代码；  </span></span></code></pre></div>
<p><strong>硬件实现的优点</strong></p>
<ul>
<li>适用于任意数目的进程，而不管是单处理机还是多处理机；<br />
</li>
<li>简单、容易验证其正确性。<br />
</li>
<li>可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量</li>
</ul>
<p><strong>硬件实现的缺点</strong></p>
<ul>
<li>进程等待进入临界区时要耗费处理机时间，不能实现让权等待。<br />
</li>
<li>从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致"饥饿”现象</li>
</ul>
<h3 id="互斥锁">互斥锁</h3>
<p>解决临界问题的有效机制是<code>互斥锁</code>，进程进入临界区前得到锁，退出时释放锁</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>acquire()&#123;<span class="co">//原子  </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="cf">while</span>(!available); <span class="co">//忙等待  </span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    available=<span class="kw">false</span>; <span class="co">//获得锁  </span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    &#125;  </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>release()&#123;<span class="co">//原子  </span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    available=<span class="kw">true</span>; <span class="co">//释放锁  </span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>适用于多处理器系统，不适用于单处理器，这种需要忙等待的锁称为自旋锁，通常硬件实现，TSL也是此类<br />
以上所有方法都无法实现让权等待，因此需要信号量机制</p>
<h3 id="信号量">信号量</h3>
<p>另一种有效机制是信号量,它只能被两个标准的原语wait(P)和signal(S)访问，也可记为“P操作”和"V操作”(首字母来源于荷兰语)<br />
<a href="https://zhouhaoran.notion.site/9a9a88d8d507460690d12220cfb74fc0">信号量例题</a></p>
<h4 id="分类">分类</h4>
<ol type="1">
<li>整型信号量</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>wait(S)&#123;  </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span class="cf">while</span>(S&lt;=<span class="dv">0</span>);  </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    S=S-<span class="dv">1</span>;  </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>&#125;  </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>signal(S)&#123;  </span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    S=S+<span class="dv">1</span>;  </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>只要信号量S&lt;=0,就会不断地忙等待。因此并未遵循“让权等待”的准则。</p>
<ol start="2" type="1">
<li>记录型信号量</li>
</ol>
<p>除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L,用于链接所有等待该资源的进程</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span>&#123;  </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="dt">int</span> value;  </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="kw">struct</span> process *L;  </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>&#125; semaphore;  </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="dt">void</span> wait (semaphore S) &#123; <span class="co">//相当于申请资源  </span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    S.value--;  </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>    <span class="cf">if</span>(S.value&lt;<span class="dv">0</span>) &#123;  </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>    <span class="co">//add this process to S.L;  </span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    block(S.L);  </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>    &#125;  </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>&#125;  </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a><span class="dt">void</span> signal (semaphore S) &#123; <span class="co">//相当于释放资源  </span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>    S.value ++;  </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>    <span class="cf">if</span> (S. value&lt;=<span class="dv">0</span>) &#123;  </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>    <span class="co">//remove a process P from S.L;  </span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>    wakeup(P);  </span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>    &#125;  </span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>这样一来信号量的value值，若是自然数表示剩余资源，若是负数，其绝对值就是阻塞的进程数量</p>
<h4 id="基于信号量的同步">基于信号量的同步</h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>semaphore S=<span class="dv">0</span>; <span class="co">//初始化信号量  </span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>P1() &#123;  </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    x;  </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    V(S);<span class="co">//告诉进程P2,语句x巳经完成  </span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>&#125;  </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>  </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>P2() &#123;  </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>    <span class="co">//其他操作  </span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    P(S);<span class="co">//检查语句x是否运行完成  </span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>    y;<span class="co">//检查无误，运行y语句  </span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>y想要运行必须得到X释放的信号量，由此实现了同步</p>
<h4 id="信号量实现互斥">信号量实现互斥</h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>semaphore S=<span class="dv">1</span>; <span class="co">//初始化信号量  </span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>P1() &#123;  </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    P(S);<span class="co">//加锁  </span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="co">//临界区  </span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    V(S);<span class="co">//解锁  </span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>&#125;  </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>  </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>P2() &#123;  </span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>    <span class="co">//其他操作  </span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>    P(S);<span class="co">//加锁  </span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>    <span class="co">//临界区  </span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>    V(S);<span class="co">//访问结束，解锁  </span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>当没有进程在临界区时，任意一个进程要进入临界区，就要执行P操作，把S的值减为0,然后进入临界区；当有进程存在于临界区时，S的值为0,再有进程要进入临界区，执行P操作时将会被阻塞，直至在临界区中的进程退出，这样便实现了临界区的互斥。<br />
互斥问题中，P, V操作要紧夹使用互斥资源的那个行为，中间不能有其他冗余代码。</p>
<h4 id="信号量实现前驱关系">信号量实现前驱关系</h4>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>semaphore a1=a2=b1=b2=c=d=e=<span class="dv">0</span>;  </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>Sl() &#123; <span class="co">//初始化信号量  </span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    V(a1); V(a2); <span class="co">//S1已经运行完成  </span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>&#125;  </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>S2() &#123;  </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    P(a1); <span class="co">//检查S1是否运行完成  </span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>    V(b1);V(b2); <span class="co">//S2已经运行完成  </span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>&#125;  </span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>S3() &#123;  </span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>    P(a2); <span class="co">//检查S1是否己经运行完成  </span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>    V(c); <span class="co">//S3己经运行完成  </span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>&#125;  </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>S4() &#123;  </span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>    P(b1); <span class="co">//检查S2是否已经运行完成  </span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a>    v(d); <span class="co">//S4已经运行完成  </span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>&#125;  </span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>S5() &#123;  </span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a>    P(b2); <span class="co">//检查S2是否已经运行完成  </span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true"></a>    V(e); <span class="co">//S5已经运行完成  </span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true"></a>&#125;  </span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true"></a>S6() &#123;  </span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true"></a>    P(c); <span class="co">//检查S3是否已经运行完成  </span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true"></a>    P(d); <span class="co">//检查S4是否已经运行完成  </span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true"></a>    P(e); <span class="co">//检查S5是否已经运行完成  </span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true"></a>    <span class="co">//其他  </span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>也就是说，互斥操作是先P在V，同步时，前面的进程先V，后面的进程P操作才不会阻塞</p>
<h3 id="管程">管程</h3>
<div class="note info"><p>利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为<code>管程(monitor)</code>。</p>
</div>
<p>管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。<br />
<strong>管程的组成</strong>:</p>
<ol type="1">
<li>名称<br />
</li>
<li>管程内部的共享数据结构说明<br />
</li>
<li>对该数据结构操作的一组过程<br />
</li>
<li>对管程内部共享数据设置初值的语句</li>
</ol>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>monitor Demo&#123; <span class="co">//1.定义一个名称为“Demo”的管程  </span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>    <span class="co">//2.定义共享数据结构，对应系统中的某种共享资源  </span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="co">//共享数据结构 S;  </span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    <span class="co">//4.对共享数据结构初始化的语句  </span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    init_code() &#123;  </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>        S=<span class="dv">5</span>; <span class="co">//初始资源数等于5  </span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    &#125;  </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    <span class="co">//3.过程1:申请一个资源  </span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>    take_away()&#123;  </span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>        对共享数据结构x的一系列处理；  </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>        S --; <span class="co">//可用资源数-1  </span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>        <span class="co">//其他  </span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>    &#125;  </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>    <span class="co">//3.过程2；归还一个资源  </span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>    give_back() &#123;  </span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>        <span class="co">//对共享数据结构x的一系列处理；  </span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>        S++; <span class="co">//可用资源数+1  </span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>        <span class="co">//其他  </span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>    &#125;  </span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<ul>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享资源<br />
</li>
<li>每次只允许一个进程进入管程，如果多个进程想进入，只能依次进行</li>
</ul>
<p><strong>条件变量</strong><br />
将阻塞原因定义为条件变量condition，在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即wait和signaL<br />
x.wait：当x对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。<br />
x.signal： x对应的条件发生了变化，则调用x.signal,唤醒一个因x条件而阻塞的进程</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>monitor Demo &#123;  </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>    <span class="co">//共享数据结构S;  </span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    condition x; <span class="co">//定义一个条件变量x  </span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    init_code()&#123;<span class="co">/*其他*/</span> &#125;  </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    take_away()&#123;  </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>        <span class="cf">if</span> (S&lt;=<span class="dv">0</span>) x.wait (); <span class="co">//资源不够，在条件变量x上阻塞等待  </span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>        <span class="co">//资源足够，分配资源，做一系列相应处理：  </span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    &#125;  </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>    give_back() &#123;  </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>        <span class="co">//归还资源，做一系列相应处理；  </span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>        <span class="cf">if</span> (<span class="co">/*有进程在等待*/) x.signal () ;//唤醒一个阻塞进程  </span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a><span class="co">    &#125;  </span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a><span class="co">&#125;  </span></span></code></pre></div>
<p>与信号量不同的是，条件变量不需要记录剩余资源数，这个部分由管程的共享数据结构记录</p>
<h3 id="同步问题实例">同步问题实例</h3>
<h4 id="生产者-消费者">生产者-消费者</h4>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源；它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>semaphore mutex=<span class="dv">1</span>; <span class="co">//临界区互斥信号量  </span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>semaphore empty=n;<span class="co">//空闲缓冲区  </span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>semaphore full=O;<span class="co">//缓冲区初始化为空  </span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="co">/*信号量mutex作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量初值为1;信号量full用于记录当前缓冲池中的满缓冲区数，初值为0。信号量empty用于记录当前缓冲池中的空缓冲区数，初值为n*/</span>  </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>producer() &#123;<span class="co">//生产者进程  </span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>    <span class="cf">while</span> (<span class="dv">1</span>) &#123;  </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>        <span class="co">//produce an item in nextp;生产数据  </span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>        P (empty);<span class="co">//获取空缓冲区单元  </span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>        P (mutex);<span class="co">//进入临界区  </span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>        <span class="co">//add nextp to buffer;//将数据放入缓冲区  </span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>        V (mutex);<span class="co">//离开临界区，释放互斥信号量  </span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>        V(full);<span class="co">//满缓冲区数加1  </span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>    &#125;  </span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>&#125;  </span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>  </span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>consumer() &#123;<span class="co">//消费者进程  </span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a>    <span class="cf">while</span>(<span class="dv">1</span>)&#123;  </span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>        P(full);<span class="co">//获取满缓冲区单元  </span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>        P(mutex);<span class="co">//进入临界区  </span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>        <span class="co">//remove an item from buffer;从缓冲区中取出数据  </span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a>        V(mutex);<span class="co">//离开临界区，释放互斥信号量  </span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a>        V(empty);<span class="co">//空缓冲区数加1  </span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a>        consume the item;<span class="co">//消费数据  </span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a>    &#125;  </span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>必须确保先获取一个缓冲区单元再进入临界区，否则缓冲区满时，由于临界区已经锁住，只能无限等待对方释放空/满缓冲区，陷入死锁</p>
<p><strong>更复杂的变种</strong>：</p>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231212105100.png" /><br />
桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出<br />
两个生产者和两个消费者被连接到大小为1的缓冲区上。爸爸妈妈互斥，爸爸女儿，妈妈儿子是同步关系</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>semaphore plate=<span class="dv">1</span>, apple=<span class="dv">0</span>, orange=<span class="dv">0</span>;  </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="co">/*首先将信号量plate设置互斥信号量，表示是否允许向盘子放入水果,初值为1表示允许放入，且只允许放入一个。  </span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="co">信号量apple表示盘子中是否有苹果，初值为0表示盘子为空，不许取，apple=1表示可以取。  </span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="co">信号量orange表示盘子中是否有橘子，初值为0表示盘子为空，不许取，orange = 1表示可以取。*/</span>  </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>dad () &#123; <span class="co">//父亲进程  </span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>    <span class="cf">while</span> (<span class="dv">1</span>) &#123;  </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>        <span class="co">//prepare an apple;  </span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>        P(plate); <span class="co">//互斥向盘中取、放水果  </span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>        <span class="co">//put the apple on the plate; //向盘中放苹果  </span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>        V(apple); <span class="co">//允许取苹果  </span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>    &#125;  </span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>&#125;  </span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>mom() &#123; <span class="co">//母亲进程  </span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>    <span class="cf">while</span> (<span class="dv">1</span>) &#123;  </span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>        <span class="co">//prepare an orange;  </span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>        P(plate); <span class="co">//互斥向盘中取、放水果  </span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a>        <span class="co">//put the orange on the plate; //向盘中放橘子  </span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a>        V(orange); <span class="co">//允许取橘子  </span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a>    &#125;  </span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a>&#125;  </span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a>son() &#123; <span class="co">//儿子进程  </span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a>    <span class="cf">while</span>(<span class="dv">1</span>) &#123;  </span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a>        P(orange); <span class="co">//互斥向盘中取橘子  </span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true"></a>        <span class="co">//take an orange from the plate;  </span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true"></a>        V(plate); <span class="co">//允许向盘中取、放水果  </span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true"></a>        <span class="co">//eat the orange;  </span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true"></a>    &#125;  </span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true"></a>&#125;  </span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true"></a>daughter() &#123;<span class="co">//女儿进程  </span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true"></a>    <span class="cf">while</span>(<span class="dv">1</span>) &#123;  </span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true"></a>        P(apple); <span class="co">//互斥向盘中取苹果  </span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true"></a>        <span class="co">//take an apple from the plate;  </span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true"></a>        V(plate); <span class="co">//允许向盘中取、放水果  </span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true"></a>        <span class="co">//eat the orange;  </span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true"></a>    &#125;  </span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<h4 id="读者-写者问题">读者-写者问题</h4>
<p>有读者和写者两组并发进程，共享一个文件，读进程并行执行没有问题，写进程和其他进程同时访问共享数据时则可能导致数据不一致的错误。<br />
<strong>要求</strong>：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作<br />
</li>
<li>只允许一个写者往文件中写信息<br />
</li>
<li>任意一个写者在完成写操作之前不允许其他读者或写者工作<br />
</li>
<li>写者执行写操作前，应让己有的读者和写者全部退出</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="dt">int</span> count=<span class="dv">0</span>; <span class="co">//用于记录当前的读者数量  </span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>semaphore mutex=<span class="dv">1</span>;<span class="co">//用于保护更新count变量时的互斥   </span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>semaphore rw=<span class="dv">1</span>;<span class="co">//用于保证读者和写者互斥地访问文件  </span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="dt">void</span> writer() &#123;  </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>  <span class="cf">while</span> (<span class="dv">1</span>) &#123;  </span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    P(rw); <span class="co">//互斥访问共享文件  </span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    writing;  </span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>    V(rw);  </span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>  &#125;  </span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>&#125;  </span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>  </span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a><span class="dt">void</span> reader()&#123;<span class="co">//读者进程   </span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>  <span class="cf">while</span> (<span class="dv">1</span>) &#123;  </span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>    P(mutex);<span class="co">//互斥访问count变量  </span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>    <span class="cf">if</span>(count==<span class="dv">0</span>)<span class="co">//互斥访问count变量  </span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>      P(rw);<span class="co">//阻止写进程写    </span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>    count++; <span class="co">//读者计数器加1  </span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>    V(mutex); <span class="co">//释放互斥变量count  </span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>    reading; <span class="co">//读取  </span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a>    P(mutex); <span class="co">//互斥访问count变量  </span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>    count--; <span class="co">//读者计数器减1    </span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>    <span class="cf">if</span>(count==<span class="dv">0</span>) V(rw); <span class="co">//当最后一个读进程读完共享文件后允许写进程写释放互斥变量count  </span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>    V(mutex);<span class="co">//释放互斥变量count  </span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>  &#125;  </span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>以上是一种读进程优先的情形，只要读进程存在，就会一直阻塞写进程<br />
若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到己在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。增加一个信号量并在上面程序的writer,和reader。函数中各增加一对PV操作，就可以得到写进程优先的解决程序</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="dt">int</span> count=<span class="dv">0</span>;<span class="co">//用于记录当前的读者数量  </span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>semaphore mutex=<span class="dv">1</span>;  <span class="co">//用于保护更新count变量时的互斥  </span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>semaphore rw=<span class="dv">1</span>;<span class="co">//用于保证读者和写者互斥地访问文件   </span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>semaphore w=<span class="dv">1</span>;<span class="co">//用于实现“写优先”  </span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>writer() &#123;<span class="co">//写者进程  </span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="cf">while</span> (<span class="dv">1</span>)&#123;  </span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>   P(w);<span class="co">//在无写进程请求时进入  </span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>   P(rw); <span class="co">//互斥访问共享文件  </span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>   writing;   </span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>   V(rw); <span class="co">//释放共享文件  </span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>   V(w); <span class="co">//恢复对共享文件的访问  </span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>  &#125;  </span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>&#125;  </span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a>  </span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a><span class="dt">void</span> reader() &#123;<span class="co">//读者进程  </span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a>  <span class="cf">while</span> (<span class="dv">1</span>) &#123;  </span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a>    P(w); <span class="co">//在无写进程请求时进入  </span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a>    P(mutex); <span class="co">//互斥访问count变量  </span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a>    <span class="cf">if</span> (count==<span class="dv">0</span>)<span class="co">//当第一个读进程读共享文件时  </span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true"></a>        P(rw); <span class="co">//阻止写进程写  </span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true"></a>    count++;<span class="co">//读者计数器加1    </span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true"></a>    V(mutex); <span class="co">//释放互斥变量count  </span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true"></a>    V(w); <span class="co">//恢复对共享文件的访问  </span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true"></a>    reading;<span class="co">//读取  </span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true"></a>    P(mutex);<span class="co">//互斥访问count变量  </span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true"></a>    count--;<span class="co">//读者计数器减1  </span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true"></a>    <span class="cf">if</span> (count==<span class="dv">0</span>)<span class="co">//当最后一个读进程读完共享文件  </span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true"></a>        V(rw);<span class="co">//允许写进程写  </span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true"></a>    V(mutex);<span class="co">//释放互斥变量count  </span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true"></a>  &#125;  </span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<h4 id="哲学家进餐问题">哲学家进餐问题</h4>
<p>当哲学家饥饿时，尝试拿起左、右两根筷子(一根一根地拿起)。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，进餐完毕后，释放筷子。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>semaphore chopstick[<span class="dv">5</span>] =&#123;<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>&#125;; <span class="co">//定义信号量数组 chopstick[5],并初始化  </span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="co">/*定义互斥信号量数组chopstick[5]=(1, 1, 1, 1, 1),用于对5个筷子的互斥访问。哲学家按顺序编号为0〜4,哲学家i左边筷子的编号为i，哲学家右边筷子的编号为(i + 1)%5*/</span>  </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>Pi() &#123;<span class="co">//i号哲学家的进程  </span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    <span class="cf">do</span>&#123;  </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>        P(chopstick[i]); <span class="co">//取左边筷子  </span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>        P(chopstick[(i+<span class="dv">1</span>)%<span class="dv">5</span>]); <span class="co">//取右边筷子  </span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>        eat(); <span class="co">//进餐  </span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>        V (chopstick[i]); <span class="co">//放回左边筷子  </span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>        V(chopstick[(i+<span class="dv">1</span>)%<span class="dv">5</span>]);<span class="co">//放回右边筷子  </span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>        think();  </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a>    &#125; <span class="cf">while</span>(<span class="dv">1</span>);  </span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<p>该算法存在以下问题：当5名哲学家都想要进餐并分别拿起左边的筷子时(都恰好执行完wait(chopstick[i]);)筷子已被拿光，等到他们再想拿右边的筷子时(执行wait(chopstick[(i + 1)%5]);)就全被阻塞，因此出现了死锁。<br />
为防止死锁发生，可对哲学家进程施加一些限制条件，</p>
<ul>
<li>至多允许4名哲学家同时进餐；<br />
</li>
<li>仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子(令取两只筷子这个行为互斥，这样只有左右都有筷子时才能获取成功)；<br />
</li>
<li>对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边的筷子，而偶数号哲学家刚好相反。</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>semaphore chopstick[<span class="dv">5</span>] = &#123;<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>&#125;;  </span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>semaphore mutex=<span class="dv">1</span>;  </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>Pi() &#123;<span class="co">//当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子  </span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>    <span class="cf">do</span>&#123;  </span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    P(mutex);<span class="co">//在取筷子前获得互斥量  </span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    P(chopstick[i]);  </span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    P(chopstick[(i+<span class="dv">1</span>)%<span class="dv">5</span>]);  </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    V(mutex);<span class="co">//释放取筷子的信号量  </span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>    eat;  </span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>    V(chopstick[i]); <span class="co">//放回左边筷子  </span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>    V(chopstick[ (i+<span class="dv">1</span>) %<span class="dv">5</span>] ) ; <span class="co">//放回右边筷子  </span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>    think; <span class="co">//思考  </span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>    &#125; <span class="cf">while</span> (<span class="dv">1</span>);  </span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<h4 id="吸烟问题">吸烟问题</h4>
<p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉己完成，此时供应者就会将另外两种材料放到桌上，如此重复(让三个抽烟者轮流地抽烟)。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="dt">int</span> num=<span class="dv">0</span>;  </span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>semaphore offer1=<span class="dv">0</span>;   </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>semaphore offer2=<span class="dv">0</span>;  </span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>semaphore offer3=<span class="dv">0</span>;  </span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>semaphore finish=<span class="dv">0</span>;  </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>  </span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="co">/*信号量offerl, offer2, offer3分别表示烟草和纸组合的资源、烟草和胶水组合的资源、纸和胶水组合的资源。信号量finish用于互斥进行抽烟动作。*/</span>  </span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a><span class="dt">void</span> P1()&#123;  </span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>  <span class="cf">while</span>(<span class="dv">1</span>)&#123;  </span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>    num++;  </span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>    num=num%<span class="dv">3</span>;  </span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>    <span class="cf">if</span>(num==<span class="dv">0</span>)   </span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a>      V(offer1);  </span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>    <span class="cf">else</span> <span class="cf">if</span>(num==<span class="dv">1</span>)    </span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>      V(offer2);  </span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a>    <span class="cf">else</span>  </span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a>      V(offer3);  </span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a>    P(finish);  </span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a>  &#125;  </span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a>&#125;  </span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a>  </span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a><span class="dt">void</span> P2()&#123;  </span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a>  <span class="cf">while</span>(<span class="dv">1</span>)&#123;  </span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a>    P(offer3);    </span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true"></a>    <span class="co">//拿纸和胶水,卷成烟,抽掉  </span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true"></a>    V(finish);   </span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true"></a>  &#125;  </span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true"></a>&#125;  </span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true"></a>  </span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true"></a><span class="dt">void</span> P3()&#123;  </span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true"></a>  <span class="cf">while</span>(<span class="dv">1</span>)&#123;  </span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true"></a>    P(offer2);  </span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true"></a>    <span class="co">//拿烟草和胶水,卷成烟,抽掉  </span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true"></a>    V(finish);  </span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true"></a>  &#125;    </span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true"></a>&#125;  </span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true"></a>  </span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true"></a><span class="dt">void</span> P4()&#123;  </span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true"></a>  <span class="cf">while</span>(<span class="dv">1</span>)&#123;  </span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true"></a>    P(offer1);  </span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true"></a>    <span class="co">//拿烟草和纸,卷成烟,抽掉  </span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true"></a>  &#125;  </span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true"></a>&#125;  </span></code></pre></div>
<h3 id="总结">总结</h3>
<p>为了协调进程之间的相互制约关系，引入了进程同步的概念。<br />
同步是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。<br />
互斥是指当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
<div class="note warning">
</div>
<h2 id="死锁">死锁</h2>
<p><strong>死锁的原因</strong></p>
<ol type="1">
<li>系统资源的竞争<br />
</li>
<li>进程推进顺序非法<br />
</li>
<li>信号量配置错误</li>
</ol>
<p><strong>必要条件</strong></p>
<ol type="1">
<li>互斥，一段时间内某资源只能被一个进程占用<br />
</li>
<li>不抢占<br />
</li>
<li>请求并占有<br />
</li>
<li>循环等待，存在一个进程集合，其资源分配图存在循环</li>
</ol>
<p><strong>处理策略</strong></p>
<ol type="1">
<li>预防，破坏必要条件<br />
</li>
<li>避免，防止资源分配导致的死锁<br />
</li>
<li>检测和解除，允许死锁，发现后解除死锁</li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231212215501.png" /></p>
<h3 id="预防">预防</h3>
<ol type="1">
<li>互斥，允许资源共享，但对某些特定资源很难做到<br />
</li>
<li>不抢占，一个持有不可被抢占资源的进程申请资源时必须释放已有资源(有损运行效率)<br />
</li>
<li>占有并等待，运行前进程必须申请到需要的所有资源(浪费资源)<br />
</li>
<li>循环等待，给资源编号，必须按递增顺序申请，同类资源一次申请完，(在这种机制的实现上会有麻烦)</li>
</ol>
<p>总的来说，预防死锁要么难以实现，要么极大损失性能</p>
<h3 id="避免">避免</h3>
<ol type="1">
<li><p><strong>系统安全状态</strong><br />
系统在进行资源分配之前，应先计算此次分配的安全性，如果不安全，则不分配资源<br />
安全状态，是指系统能按某种进程推进顺序(P1,P2,……,Pn)为每个进程Pi分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称P1,P2,…，Pn为安全序列。只要在前的进程结束后归还资源时，剩余资源满足后面的进程需要，那么就是安全的</p></li>
<li><p><strong>银行家算法</strong></p></li>
</ol>
<p>把操作系统视作银行家，进程运行前声明最大需求量，运行时分配的总资源不超过这个需求量，此外，如果申请时资源超过系统能分配的资源，就暂时推迟分配</p>
<p><strong>数据结构</strong></p>
<ul>
<li>可利用资源向量Available：含有m个元素的数组，其中每个元素代表一类可用的资源数目。<code>Available[j] = K</code>表示系统中现有Rj类资源K个。<br />
</li>
<li>最大需求矩阵Max：<code>n*m</code>矩阵，定义系统中n个进程中的每个进程对m类资源的最大需求。 简单来说，一行代表一个进程，一列代表一类资源。<code>Max[i,j]=K</code>表示进程i需要Rj类资源的最大数目为K<br />
</li>
<li>分配矩阵Allocation： <code>n*m</code>矩阵，定义系统中每类资源当前已分配给每个进程的资源数。<code>Allocation[i,j]=K</code>表示进程i当前已分得Rj类资源的数目为K<br />
</li>
<li>需求矩阵Need: <code>n*m</code>矩阵，表示每个进程接下来最多还需要多少资源。<code>Need[i,j]= K</code>表示进程i还需要Rj类资源的数目为 K<br />
</li>
<li>上述三个矩阵间存在下述关系： Need = Max- Allocation</li>
</ul>
<p><strong>运行步骤</strong></p>
<ol type="1">
<li>若<code>Request_i[j]&lt;=Need[i,j]</code>则转到2. 否则进程要求资源超过Max<br />
</li>
<li><code>Request_i[j]&lt;=Available[j]</code>,则转到3.，否则系统资源不足<br />
</li>
<li>预分配资源，且修改数据结构<br />
</li>
</ol>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co">//Request_i表示i请求的各种资源  </span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>Available = Available- Request_i;  </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>Allocation[i, j] = Allocation[i, j] + Request_i[j];  </span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>Need[i,j] = Need[i, j] - Request_i[j]；  </span></code></pre></div>
<ol start="4" type="1">
<li>确认分配后系统安全，然后分配资源，否则放弃，让进程等待(安全性算法)</li>
</ol>
<p><strong>安全性算法</strong></p>
<p>设置工作向量Work,有m个元素，表示系统中的剩余可用资源数目。在执行安全性算法开始时，Work = Available</p>
<ol type="1">
<li>初始时安全序列为空。<br />
</li>
<li>从Need矩阵中找出符合下面条件的行：该行对应的进程不在安全序列中，而且该行小于或等于Work向量，找到后，把对应的进程加入安全序列；若找不到，则执行步骤4.。<br />
</li>
<li>进程R进入安全序列后，可顺利执行，直至完成，并释放分配给它的资源，因此应执行<code>Work = Work + Allocation[i]</code>,其中<code>Allocation[i]</code>表示进程 Pi代表的在 Allocation 矩阵中对应的行，返回步骤2.<br />
</li>
<li>若此时安全序列中已有所有进程，则系统处于安全状态，否则系统处于不安全状态。</li>
</ol>
<p>简单来说，类似放贷，先放出能借出的钱，这时总资产就可以把所有借款归还后的本金和利息算入，在这样的基础上继续放贷，如果最后这样计算下来能满足所有借贷需求，就视作资金安全</p>
<h3 id="检测和解除">检测和解除</h3>
<h4 id="检测">检测</h4>
<p><strong>资源分配图</strong><br />
用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，因此用框中的一个圆代表一类资源中的一个资源。从进程到资源的有向边称为请求边，表示该进程申请一个单位的该类资源；从资源到进程的边称为分配边，表示该类资源已有一个资源分配给了该进程<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231213132737.png" /></p>
<p><strong>检测方法</strong></p>
<ol type="1">
<li>找到不阻塞且不孤立的进程Pi(与其连接的资源边，申请数量少于系统空闲资源)，这样的进程必然可以完成，因此消去其的边<br />
</li>
<li>消除第一步的进程的新图继续按1.中的方法消去边，如果最后所有进程孤立，则该图可完全简化</li>
</ol>
<p>资源分配图不可完全简化是死锁的充要条件(死锁定理)</p>
<h4 id="解除">解除</h4>
<ol type="1">
<li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。<br />
</li>
<li>撤销进程法。强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。<br />
</li>
<li>进程回退法。让一(或多)个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺。要求系统保持进程的历史信息，设置还原点</li>
</ol>
<div class="note warning"><ul>
<li>死锁检测不需要知道系统总资源数<br />
</li>
<li>当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态</li>
<li>绝对不会死锁的情况：设k个进程需要的最大资源数为xk,对每个临界资源来说，其总数≥<code>sum(x_1-1,x_2-1,……x_k-1)+1</code>，即至少一个进程能得到需要的所有资源</li>
</ul>
</div>
<hr />
<h1 id="内存管理">内存管理</h1>
<h2 id="概念-1">概念</h2>
<p><strong>内存管理包括</strong></p>
<ul>
<li>内存空间的分配与回收<br />
</li>
<li>逻辑地址和物理地址的转换<br />
</li>
<li>通过虚拟技术扩充内存空间<br />
</li>
<li>内存共享，允许多进程共享内存空间<br />
</li>
<li>存储保护，维护各个作业地址空间的独立</li>
</ul>
<p><strong>程序的链接和装入</strong></p>
<ul>
<li>编译，将源代码编译成若干模块<br />
</li>
<li>链接，链接编译出的各个模块
<ul>
<li>静态链接，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，需要修改相对地址，并且变换外部调用符号为相对地址(编译后所有目标模块都是0开始的相对地址)<br />
</li>
<li>装入时动态链接，装入内存时，边装入边链接，便于修改更新<br />
</li>
<li>运行时动态链接，程序执行时才会链接目标模块，执行用不到的模块就暂时不会被链接(节省空间优化性能)<br />
</li>
</ul></li>
<li>装入，把模块装入内存运行
<ul>
<li>绝对装入，只适用于单道环境，装入到装入程序提供的绝对地址，且此时的逻辑地址和实际内存地址相同，且地址可以手动指定<br />
</li>
<li>可重定位装入，装入时对目标程序中指令和数据地址进行修改(该过程叫做重定位),这样的变换一般在装入进程时一次完成，因此叫做静态重定位<br />
</li>
<li>动态运行时装入，也称为动态重定位，装入模块装入内存后，在程序执行时才把相对地址转换成绝对地址(需要重定位寄存器支持)，这样对地址的使用灵活，且便于程序段共享</li>
</ul></li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231213202033.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231213220222.png" /></p>
<div class="note info"><p>编译后，每个目标模块都从0号单元开始编址，这称为该目标模块的相对地址(或逻辑地址)。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间(或虚拟地址空间).进程在运行时，看到和使用的地址都是逻辑地址<br />
对于32位系统，逻辑地址空间的范围为<code>0~2^32-1</code></p>
<p>物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。<br />
操作系统通过内存管理部件(MMU)将进程使用的逻辑地址转换为物理地址。进程使用虚拟内存空间中的地址，操作系统在相关硬件的协助下，将它"转换”成真正的物理地址。逻辑地址通过页表映射到物理内存，页表由操作系统维护并被处理器引用。</p>
</div>
<p><strong>进程的内存映像</strong></p>
<ul>
<li>代码段：即程序的二进制代码，代码段是只读的，可以被多个进程共享。<br />
</li>
<li>数据段：即程序运行时加工处理的对象，包括全局变量和静态变量。<br />
</li>
<li>进程控制块(PCB)：存放在系统区。操作系统通过PCB来控制和管理进程。<br />
</li>
<li>堆：用来存放动态分配的变量。通过调用malloc函数动态地向高地址分配空间。<br />
</li>
<li>栈：用来实现函数调用。从用户空间的最大地址往低地址方向增长。</li>
</ul>
<p>代码段和数据段在程序调入内存时就指定了大小，而堆和栈动态管理空间</p>
<p><img src="/assets/苏大linux_ppt/c_memory.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231213220912.png" /></p>
<p><strong>内存保护</strong><br />
操作系统需要维护每个进程有独立的内存空间，与系统和其他进程隔绝，也就是内存保护</p>
<ul>
<li>cpu设置上下限寄存器，存放用户作业的地址上下限，用来判断访问是否越界<br />
</li>
<li>使用重定位寄存器(基地址寄存器)和界地址寄存器(限长寄存器)，前者有最小的物理地址，后者存放逻辑地址最大值</li>
</ul>
<p>加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这两个存储器。<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231213221340.png" /></p>
<p><strong>内存共享</strong><br />
可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。但在实际执行时，也可以为每个进程配以局部数据区，把在执行中可能改变的部分复制到该数据区，这样，程序在执行时只需对该私有数据区中的内存进行修改，并不去改变共享的代码区。</p>
<h2 id="内存的分配方式">内存的分配方式</h2>
<h3 id="连续分配管理">连续分配管理</h3>
<p>为一个用户程序分配一个连续的内存空间</p>
<ol type="1">
<li>单一连续分配，分为系统区和用户区，分别供系统和单一用户程序使用。这种方法无外部碎片，但只用于单用户单任务系统<br />
</li>
<li>固定分区分配，用户内存空间分成若干分区，每个分区只用于装载一个作业。如果分区大小不等，就需要建立使用表格来分配。容易产生内部碎片，或者划分空间太小<br />
</li>
<li>动态分区分配，进程装入内存时根据其需要分配空间，容易产生外部碎片，并且需要确定内存块分配算法，比如
<ol type="1">
<li>首次适应，容易在低地址处产生碎片,综合最好<br />
</li>
<li>邻近适应，首次适应的基础上从上次查找结束的位置继续查找，容易在尾地址产生碎片，且导致大碎片匮乏<br />
</li>
<li>最佳适应，找到满足要求的最小分区，产生最多外部碎片<br />
</li>
<li>最坏适应，找到满足要求的最大分区，导致空间匮乏</li>
</ol></li>
</ol>
<p><strong>回收内存</strong><br />
系统根据回收分区的始址，从空闲分区链中找到相应的插入点</p>
<ol type="1">
<li>回收区与插入点的前一空闲分区相邻，将这两个分区合并，并修改前一分区表项的大小为两者之和；<br />
</li>
<li>回收区与插入点的后一空闲分区相邻，将这两个分区合并，并修改后一分区表项的始址和大小；<br />
</li>
<li>回收区同时与插入点的前、后两个分区相邻，此时将这三个分区合并，修改前一分区表项的大小为三者之和，取消后二分区表项；<br />
</li>
<li>回收区没有相邻的空闲分区，此时应为回收区新建一个表项，填写始址和大小，并插入空闲分区链。</li>
</ol>
<p>基于索引搜索的分配算法,大、中型系统中往往采用索引,根据其大小对空闲分区建立索引，按需要的大小分配:</p>
<ol type="1">
<li>快速适应算法，索引表中找到能容纳需要的最小空闲分区链表，从链表中取出第一块进行分配。内部碎片小，但需要频繁回收合并</li>
<li>伙伴系统。规定所有分区的大小均为2的k次幕，对需求n，取其上界大小的分区，若不存在，则对半拆分若干次更大的分区(拆分后多余的大小填入分配索引表)</li>
<li>哈希算法。构建一张以空闲分区大小为关键字的哈希表以及恰当的哈希函数，根据哈希函数计算结果分配</li>
</ol>
<h3 id="分页存储管理">分页存储管理</h3>
<p>把内存分为若干固定大小的块，进程根据需要申请一定数量的块，只有最后一块会产生内部碎片<br />
进程中的块称为页或页面(Page),内存中的块称为页框或页帧(Page Frame)外存也以同样的单位进行划分，直接称为块或盘块(Block)。</p>
<table>
<thead>
<tr class="header">
<th>页号</th>
<th>页内偏移量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P</td>
<td>W</td>
</tr>
</tbody>
</table>
<p>地址结构包含两部分：前一部分为页号P,后一部分为页内偏移量W,地址长度为32位，其中0〜11位为页内地址，即每页大小为4KB； 12〜31位为页号，即最多允许2^20页<br />
页表记录页面在内存中对应的物理块号，一般也放在内存(PCB)<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231214220550.png" /></p>
<h4 id="地址变换">地址变换</h4>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231214220737.png" /><br />
地址变换机构将逻辑地址转换成内存中的物理地址，借助页表实现<br />
系统中通常设置一个页表寄存器(PTR),存放页表在内存的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当进程被调度执行时，才将页表始址和页表长度装入页表寄存器中。</p>
<p>页面大小为Z,逻辑地址A到物理地址E的变换过程：</p>
<ol type="1">
<li>计算页号P=A/L，页内偏移量W=A%L<br />
</li>
<li>比较页号和页表长度M，如果P&gt;=M，则产生越界中断<br />
</li>
<li>P对应页表地址=<code>页表始址F+页号P*页表项长度</code>，该项内容b就是物理块号。//页表项长度指页地址占多大的存储空间<br />
</li>
<li><code>E=b*L + W</code>，得出物理地址并访问内存</li>
</ol>
<div class="note info"><p><strong>页表项大小怎么确定</strong><br />
逻辑地址空间大小/页大小得到页数，页表项大小的位数就要确保能表示这个页数，其位数需要大于等于对页数取的对数<br />
一般用字节作为地址单位，所以对这个位数除8并向上取整得到需要的字节数</p>
</div>
<p>问题：</p>
<ul>
<li>需要确保地址转换足够快<br />
</li>
<li>页表不能太大，否则会浪费空间，降低内存利用率</li>
</ul>
<h4 id="快表">快表</h4>
<p>在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器一一快表，又称相联存储器(TLB),用来存放当前访问的若干页表项，以加速地址变换的过程，相对应的，主存中的页表称为慢表  <br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231215084116.png" /><br />
<strong>地址变换过程</strong></p>
<p>1. 逻辑地址给出后，页号送入高速缓存寄存器，与快表中的所有页号比较<br />
2. 如果快表中有存储，直接取出页框号，算出物理地址<br />
3. 否则访问慢表，并将最后得出的页表项送入快表，如果已满则推出原有一项</p>
<h4 id="两级页表">两级页表</h4>
<p>鉴于大量页表不仅占用极大的连续空间，并且很可能真正使用的内存并没有这么多页，需要引入二级页表  <br />
顶级页表最多只有一个页面  <br />
需要在系统中增设一个外层页表寄存器（也称页目录基址寄存器）.用于存放页目录始址。将逻辑地址中的页目录号作为页目录的索引，从中找到对应页表的始址：再用二级页号作为页表分页的索引，从中找到对应的页表项,由于最后需要一次取内存块操作，N级页表一次读写需要N+1次访存<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231215084415.png" /></p>
<h3 id="分段存储管理">分段存储管理</h3>
<p>按照用户进程划分段，段内要求连续，段间不要求连续，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。  <br />
每个进程都有一张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项记录该段在内存中的始址和长度<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231215103851.png" /><br />
段表寄存器，用于存放段表始址F和段表长度M  </p>
<p><strong>地址变换过程</strong>  </p>
<p>1. 从逻辑地址A取出段号S和段内偏移量W<br />
2. 确保<code>S&lt;M</code>,否则越界中断<br />
3. 段号S对应段表项地址=<code>段表始址F+段号S*段表项长度</code>，取出表项中的段长C，并确保<code>段内偏移量&lt;C</code><br />
4. 取出段表项中的始址b，E=b+W,用E访问内存</p>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231215103916.png" /><br />
<strong>共享与保护</strong><br />
段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的，这产生了一个读者写者问题，读者在读，写者就不能写<br />
可重入代码(不能修改的代码)和不能修改的数据可以共享，可修改的代码和数据不能共享</p>
<p>段的保护分为存取控制保护和地址越界保护<br />
越界保护确保段号小于段表长度且段内偏移量小于段长</p>
<h4 id="段页式管理">段页式管理</h4>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231215103647.png" /><br />
在段页式系统中，作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每段分成若干大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位  <br />
作业的逻辑地址分为三部分：段号、页号和页内偏移量  <br />
段表只有一个，而页表可能有多个。<br />
进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最后形成物理地址，是一种二维地址<br />
分段对用户是可见的，编程需要指定段号，段内地址，而页的所有部分对用户透明<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231215103659.png" /><br />
<img src="https://s2.loli.net/2024/02/15/XuzRLBrWVjIt4KG.png" /></p>
<div class="note warning"><ul>
<li>整个系统中设置一个重定位寄存器(放程序在内存中的始址),运行不同程序时更换内容<br />
</li>
<li>段式存储管理方式，主要是为了满足用户的下列要求：方便编程、分段共享、分段保护、动态链接和动态增长<br />
</li>
<li>对主存的访问以字节或字为单位,分配则是区，页，段等划分<br />
</li>
<li>每个进程有自己的页表，进程未执行时，页表的始址和页表长度存放在本进程的PCB中，执行时调入内存的页表寄存器<br />
</li>
<li>一个页目录能放下的表项是页面大小/表项大小，表项数量总和必须等于虚拟地址的页面数<br />
</li>
<li>最佳适应算法最容易产生内存碎片<br />
</li>
<li>计算有效存取时间要考虑快表查询是同时还是在先</li>
</ul>
</div>
<h2 id="虚拟内存">虚拟内存</h2>
<div class="note info"><p>其他内存扩充方法：</p>
<ul>
<li>覆盖：程序或进程分为固定区与覆盖区，固定区常驻内存，覆盖区可以不断交换给其他进程，基本过时<br />
</li>
<li>交换：进程被调度程序调入调出内存(需要外存提供单独的交互区)</li>
</ul>
</div>
<p>如果作业一次性全部装入内存，且在完成前无法换出,其实会造成内存空间的浪费，因此就需要虚拟内存技术<br />
<strong>局部性原理</strong>：</p>
<ol type="1">
<li>时间局部性。程序中的某条指令一旦执行，不久后该指令可能再次执行<br />
</li>
<li>空间局部性,程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令和数据通常是顺序存放、顺序执行的</li>
</ol>
<p>基于局部性原理，内存中可以只存放部分程序需要的页面或者段，其他部分留在外存，需要时再调入，这种机制叫做虚拟存储器<br />
虚拟存储器有以下三个主要特征：</p>
<ol type="1">
<li>多次性。是指无须在作业运行时一次性地全部装入内存，而允许被分成多次调入内存运行，多次性是虚拟存储器最重要的特征。<br />
</li>
<li>对换性。是指无须在作业运行时一直常驻内存，在进程运行期间，允许将那些暂不使用的程序和数据从内存调至外存的对换区(换出)，待以后需要时再将它们从外存调至内存(换进)<br />
</li>
<li>虚拟性。是指从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量。这是虚拟存储器所表现出的最重要特征，也是实现虚拟存储器的最重要目标。</li>
</ol>
<p>连续性内存分配不支持逻辑上的扩容，因此虚拟内存只有三种实现方式：</p>
<ul>
<li>请求分页存储管理。<br />
</li>
<li>请求分段存储管理。<br />
</li>
<li>请求段页式存储管理</li>
</ul>
<p>虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的<br />
同时需要内外存，页表机制，中断，地址变换等硬件支持</p>
<h3 id="请求分页管理方式">请求分页管理方式</h3>
<p>基于分页系统的虚拟内存是最常见的<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231217203821.png" /><br />
为了解决区分访问页面在不在内存中而增加的<strong>页表项</strong>字段：</p>
<ul>
<li>状态位F。用于指示该页是否已调入内存，供程序访问时参考。<br />
</li>
<li>访问字段A,用于记录本页在一段时间内被访问的次数，或记录本页最近己有多长时间未被访问，供置换算法换出页面时参考。<br />
</li>
<li>修改位M,标识该页在调入内存后是否被修改过，以确定页面置换时是否写回外存。<br />
</li>
<li>外存地址。用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li>
</ul>
<p><strong>缺页中断</strong><br />
每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞(调页完成唤醒)，若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项，若此时内存中没有空闲块，则要淘汰某页(若被淘汰页在内存期间被修改过，则要将其写回外存)<br />
缺页中断属于内中断(内部异常)的故障fault</p>
<p><strong>地址变换</strong><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231217204555.png" /></p>
<ol type="1">
<li>检索快表，如果找到要访问的页，修改访问位，利用表项的物理块号和页内偏移量算出物理地址<br />
</li>
<li>找不到页表项则到内存查找页表，对比状态位P，看页是否已经调入内存，若调入则该页的页表写入快表，快表已满则替换，若未调入，则产生缺页中断，从外存调入</li>
</ol>
<h3 id="页框分配">页框分配</h3>
<p>对进程分配物理页框也是需要操作系统需要考虑的问题，这会影响主存的多道程度，进程的缺页率等<br />
一般来说有以下几种策略：</p>
<ol type="1">
<li>固定分配局部置换,每个进程物理帧数量固定，缺页时在固定的框中选一个置换，缺点是难以确定合适数量的帧<br />
</li>
<li>可变分配全局置换，分配一定数量的物理块，运行期间动态增减，缺点是可能会盲目增减<br />
</li>
<li>可变分配局部置换，与1.类似，但如果频繁缺页则会分配更多物理块，直到缺页率正常，若缺页率低也会适当减少物理块</li>
</ol>
<p><strong>物理块调入算法</strong>：</p>
<ol type="1">
<li>平均分配，所有物理块均分给进程<br />
</li>
<li>按比例分配，按进程大小比例分配<br />
</li>
<li>优先级分配，优先级高的进程有更多物理块</li>
</ol>
<p><strong>调入页面的时机</strong>：</p>
<ol type="1">
<li>预调页，预测可能被访问的页，提前调入内存，也可以由程序员指定<br />
</li>
<li>请求调页，需要的页不在内存时再调入，易于实现，但I/O开销较大</li>
</ol>
<p><strong>调入页面的区域</strong><br />
请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘I/O速度比文件区的更快</p>
<ol type="1">
<li>对换区空间足够，则全部由对换区调入<br />
</li>
<li>对换区空间不足，不需要修改的文件都从文件区调入，可能修改的则先调到对换区，需要时通过对换区调入<br />
</li>
<li>UNIX方式。与进程有关的文件都放在文件区，因此未运行过的页面都应从文件区调入。曾经运行过但又被换出的页面，由于是放在对换区，因此在下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入</li>
</ol>
<div class="note info"><ul>
<li>快表有的页面必然在内存中，如果一个页调出内存，需要同时删除其快表项(如果有的话)<br />
</li>
<li>只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数<br />
</li>
<li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中</li>
</ul>
<p>当进程所访问的页面不在内存中时(存在位为0),便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘I/O,将所缺页调入内存，并修改页表。如果内存已满，则先按某种置换算法从内存中选出一页准备换出；如果该页未被修改过(修改位为0),则无须将该页写回磁盘；但是，如果该页己被修改(修改位为1),则必须将该页写回磁盘，然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址</p>
</div>
<h3 id="页面置换算法">页面置换算法</h3>
<ol type="1">
<li>最佳置换(OPT),换出最长时间内不再被访问的页面，以便保证获得最低的缺页率，无法真正实现，只能用于其他算法的评价参考<br />
</li>
<li>FIFO,淘汰最先进入内存的页面，会产生所分配的物理块数增大而页故障数不减反增的异常现象，称为Belady异常，只有FIFO会有这种异常<br />
</li>
<li>最近最久未使用(LRU)置换,该算法为每个页面设置一个访问字段，用来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。性能较好，但开销较大且需要硬件支持<br />
</li>
<li>时钟(CLOCK)置换算法，为每帧设置一位访问位A，当某页首次被装入或被访问时，其访问位被置为1，所有帧视为循环队列，有一个从第一个帧开始的指针，替换时循环检查，访问位若是1置0且指针后移，若是0则替换，替换后指针后移一位,最多需要两轮<br />
</li>
<li>改进后的clock算法,换出页面时，修改过的页额外需要写回磁盘，有更高的性能代价，除考虑页面使用情况外，还增加了置换代价一一修改位M。在选择页面换出时，优先考虑既未使用过又未修改过的页面。
<ol type="1">
<li>寻找第一个<code>A==M==0</code>的页面，这次扫描不改变A<br />
</li>
<li>第二轮扫描，寻找第一个<code>A==0 &amp;&amp; M==1</code>的页面，这次扫描到的页面A置0<br />
</li>
<li>指针复位，所有帧访问位置0，重复1.2.直到找到一个符合要求的页<br />
</li>
<li>最多四轮扫描就能找到一个置换页(所有页<code>A==M==1</code>时才需要四轮)</li>
</ol></li>
</ol>
<h3 id="抖动和工作集合">抖动和工作集合</h3>
<p>刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存，这种频繁的页面调度行为称为抖动或颠簸。<br />
抖动的根本原因是，系统中进程的资源不足，频繁缺页</p>
<p>工作集是指在某段时间间隔内，进程要访问的页面集合。基于局部性原理，可以用最近访问过的页面来确定工作集。<br />
工作集W可由时间t和工作集窗口大小Δ来确定<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231218192001.png" alt="窗口大小为5的情形" /><br />
一般来说分配给进程的物理块数(即驻留集大小)要大于工作集大小。落在工作集内的页面需要调入驻留集中，而落在工作集外的页面可从驻留集移除。若可用物理块小于进程的工作集合，就需要暂停一个进程</p>
<p>一些对性能问题的影响因素：</p>
<ul>
<li>页面较大则缺页率较低，页面较小则缺页率较高。页面较小会减少碎片，但导致页表较长占用更多内存，页面较大时相反<br />
</li>
<li>物理块越多，缺页率越低，但达到一个阈值时改善就会变得不明显<br />
</li>
<li>换出已修改过的页面时，应当写回磁盘，如果每当一个页面被换出时就将它写回磁盘，那么每换出一个页面就需要启动一次磁盘，效率极低。为此在系统中建立一个已修改换出页面的链表，对每个要被换出的页面(已修改)，可以暂不将它们写回磁盘，而将它们挂在该链表上，仅当被换出页面数达到给定值时，才将它们一起写回磁盘，这样就可显著减少磁盘I/O的次数，即减少巳修改页面换出的开销。此外，如果有进程在这批数据还未写回磁盘时需要再次访问这些页面，就不需从外存调入，而直接从已修改换出页面链表上获取，这样也可以减少页面从磁盘读入内存的频率，减少页面换进的开销<br />
</li>
<li>编写程序的局部化程度越高，执行时的缺页率就越低。如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象</li>
</ul>
<h3 id="内存映射">内存映射</h3>
<div class="note info"><p><strong>内存映射文件(Memory-MappedFiles)</strong><br />
将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件I/O操作，也无须对文件内容进行缓存处理。可通过共享页表实现<br />
系统内存中的所有页面都由虚拟存储器负责管理，虚拟存储器以统一的方式处理所有磁盘I/O.当进程退出或显式地解除文件映射时，所有被改动的页面会被写回磁盘文件。<br />
多个进程允许并发地内存映射同一文件，以便允许数据共享。实际上，很多时候，共享内存是通过内存映射来实现的。进程可以通过共享内存来通信，而共享内存是通过映射相同文件到通信进程的虚拟地址空间实现的。内存映射文件充当通信进程之间的共享内存区域，如图3.28所示。一个进程在共享内存上完成了写操作，此刻当另一个进程在映射到这个文件的虚拟地址空间上执行读操作时，就能立刻看到上一个进程写操作的结果。</p>
</div>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231218192446.png" /></p>
<h3 id="地址翻译">地址翻译</h3>
<p>流程如下：</p>
<ol type="1">
<li>根据TLB,Cache是否n路组相联，页面大小等，计算出逻辑物理地址的格式<br />
</li>
<li>根据逻辑地址的标记查找TLB(注意是否分组)以及页表(注意是否有效)<br />
</li>
<li>拼接出物理地址，根据该地址查找Cache和主存(如果Cache不命中)</li>
</ol>
<div class="note warning"><ul>
<li>虚存的最大容量&lt;=计算机的地址位数能容纳的最大容量 &amp;&amp; &lt;=内外存之和<br />
</li>
<li>置换页时，把需要调入页的内容放到被换出的页的页框里，也就是页框号不变<br />
</li>
<li>页缓冲队列将被淘汰的页面缓存下来，暂时不写回磁盘，队列长度会影响页面置换的速度，但不会影响缺页率<br />
</li>
<li>处理缺页中断不包括访问调入的页内容，因此处理后从头开始访存<br />
</li>
<li>高级页表指的是最高几位表示的页表，也就是说一级页表是可以直接查到页框号的页表</li>
</ul>
</div>
<hr />
<h1 id="文件管理">文件管理</h1>
<h2 id="概念-2">概念</h2>
<p>文件(File)是以硬盘为载体的存储在计算机上的信息集合<br />
文件的结构:</p>
<ol type="1">
<li>数据项。是文件系统中最低级的数据组织形式，可分为以下两种类型：
<ol type="1">
<li>基本数据项。用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。<br />
</li>
<li>组合数据项。由多个基本数据项组成。<br />
</li>
</ol></li>
<li>记录。是一组相关的数据项的集合，用于描述一个对象在某方面的属性。<br />
</li>
<li>文件。是指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。在有结构的文件中，文件由若干个相似的记录组成，如一个班的学生记录；而无结构文件则被视为一个字符流，比如一个二进制文件或字符文件。</li>
</ol>
<p><strong>文件属性</strong>，一般用文件控制块(FCB)维护</p>
<ol type="1">
<li>名称，一般唯一<br />
</li>
<li>类型<br />
</li>
<li>创建者<br />
</li>
<li>所有者<br />
</li>
<li>位置(指针)<br />
</li>
<li>大小<br />
</li>
<li>保护(访问控制信息)<br />
</li>
<li>时间，包括创建，最后修改，最后存取等</li>
</ol>
<p><strong>FCB</strong><br />
文件控制块(FCB)是用来存放控制文件需要的各种信息的数据结构,FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231218195544.png" /><br />
FCB主要包含以下信息：</p>
<ul>
<li>基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。<br />
</li>
<li>存取控制信息，包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。<br />
</li>
<li>使用信息，如文件建立时间、上次修改时间等。</li>
</ul>
<p><strong>索引节点</strong></p>
<p>有的系统为了便于检索，采用了文件名和文件描述信息分开的方法，文件描述信息单独形成一个称为<strong>索引结点</strong>的数据结构，简称i结点(inode)</p>
<ul>
<li>磁盘索引结点，存放在磁盘上的索引节点，每个文件有一个唯一的磁盘索引结点
<ul>
<li>文件主标识符，表示拥有文件的个人或者用户组<br />
</li>
<li>文件类型，如linux的目录和普通文件<br />
</li>
<li>文件存取权限<br />
</li>
<li>物理地址<br />
</li>
<li>长度<br />
</li>
<li>链接计数<br />
</li>
<li>存取时间<br />
</li>
</ul></li>
<li>内存索引结点，存放在内存中的索引结点。当文件被打开时，要将磁盘索引结点复制到内存的索引结点中，便于以后使用。在磁盘结点的基础上增加了：
<ul>
<li>索引结点编号<br />
</li>
<li>状态,是否上锁或被修改<br />
</li>
<li>访问计数，记录正在访问此结点的进程数量<br />
</li>
<li>逻辑设备号，所属文件系统的逻辑设备号<br />
</li>
<li>链接指针，指向空闲链表和散列队列的指针</li>
</ul></li>
</ul>
<h3 id="操作">操作</h3>
<p><strong>对文件的基本操作</strong></p>
<ol type="1">
<li>创建文件：
<ol type="1">
<li>分配外存空间<br />
</li>
<li>创建目录项<br />
</li>
</ol></li>
<li>写文件，需要执行系统调用，需要搜索目录找到相关目录项，每个文件维护一个写指针，写后更新,如需要互斥写，<strong>可通过系统调用加锁</strong></li>
<li>读文件，需要执行系统调用，类似写文件也需要一个读指针，读后更新，对只用到一个文件的进程这两个指针可以共用<br />
</li>
<li>重新定位文件，也称文件定位，搜索目录找到适当条目，并将目前文件位置指针重定位到给定值，只涉及目录<br />
</li>
<li>删除，找到目录项，释放空间，删除目录条目<br />
</li>
<li>截断，文件所有属性不变，空间释放，长度置零</li>
</ol>
<p><strong>文件打开和关闭</strong><br />
操作系统维护一个包含所有打开文件信息的表(打开文件表)。打开操作时，通过系统调用open，搜索目录找到该文件，将其复制到内存打开文件表的一个表目，将该表目索引返回给用户。<br />
这样对打开文件可以用打开文件表快速索引，关闭时通过系统调用close，删除打开文件表的条目</p>
<p>在多个不同进程可以同时打开文件的操作系统中，通常采用两级表：整个系统表和每个进程表。<br />
整个系统的打开文件表包含FCB的副本及其他信息。每个进程的打开文件表根据它打开的所有文件，包含指向系统表中适当条目的指针。对通过open打开同一文件的其他进程，只需要增加文件打开表的一个条目与相应的指针。<br />
一般每个文件在系统打开表中有一个打开计数器，通过open和close增减，归零时允许删除</p>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231219191021.png" /><br />
对于访问打开文件表的索引，UNIX称之为文件描述符，而Windows称之为文件句柄。只要文件未被关闭，所有文件操作就通过打开文件表来进行</p>
<p>每个打开文件都具有如下关联信息：</p>
<ul>
<li>文件指针。系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。<br />
</li>
<li>文件打开计数。归零时才可以删除文件打开条目<br />
</li>
<li>文件磁盘位置。大多数文件操作要求系统修改文件数据。查找磁盘上的文件所需的信息保存在内存中能提高效率<br />
</li>
<li>访问权限。每个进程打开文件都需要有一个访问模式(创建、只读、读写、添加等)。操作系统根据该信息允许或拒绝后续的I/O请求</li>
</ul>
<h3 id="文件保护和权限">文件保护和权限</h3>
<p>文件保护通过口令保护、加密保护和访问控制等方式实现，相关权限可分为以下几种：</p>
<ul>
<li>读<br />
</li>
<li>写<br />
</li>
<li>执行<br />
</li>
<li>添加，相当于编程中的append操作<br />
</li>
<li>删除<br />
</li>
<li>列表清单，列出文件信息</li>
</ul>
<p>最普遍的访问控制机制，为每个文件和目录增加一个访问控制列表(Access-Control List, ACL)放在FCB或者索引结点,以规定每个用户名及其所允许的访问类型。这种方法的优点是可以使用复杂的访问方法，缺点是长度无法预计并且可能导致复杂的空间管理<br />
精简的访问列表采用拥有者、组和其他三种用户类型。</p>
<ol type="1">
<li>拥有者。创建文件的用户。<br />
</li>
<li>组。一组需要共享文件且具有类似访问的用户。<br />
</li>
<li>其他。系统内的所有其他用户。</li>
</ol>
<p>其他的访问控制方法：</p>
<ul>
<li>口令，用户在建立文件时提供一个口令，建立fcb时附上口令，其他用户访问时需要提供口令，缺点是口令存储在系统中不安全<br />
</li>
<li>密码，用密码对文件加密，访问需要密钥，有一定的加密解密成本</li>
</ul>
<p>此外，目录由于涉及递归的子目录，需要不同的保护机制</p>
<h3 id="逻辑结构">逻辑结构</h3>
<p>按逻辑结构，文件可划分为无结构文件和有结构文件两大类。</p>
<ul>
<li>无结构文件(流式文件)，无结构文件将数据按顺序组织成记录并积累、保存<br />
</li>
<li>有结构文件(记录式文件)
<ul>
<li>顺序文件，顺序或者链表存储，分为没有关键字排序的串结构和按关键字排序的顺序结构<br />
</li>
<li>索引文件，建立一张索引表，为主文件的每个记录在索引表中分别设置一个表项，包含指向变长记录的指针(即逻辑起始地址)和记录长度，索引表按关键字排序，因此其本身也是一个定长记录的顺序文件。<br />
</li>
<li>索引顺序文件,将顺序文件中的所有记录分为若干组，为顺序文件建立一张索引表，在索引表中为每组中的第一条记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。见附图<br />
</li>
<li>直接或者散列文件，直接用哈希产生的键值对储存地址</li>
</ul></li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231219200129.png" /></p>
<h3 id="物理结构">物理结构</h3>
<p>常用的磁盘空间分配方法有三种：连续分配、链接分配和索引分配。</p>
<ul>
<li>连续分配,每个文件在磁盘上占有一组连续的块,逻辑文件中的记录也顺序存储在相邻接的块中,目录项中的物理地址只需要包括第一块地址和区域长度
<ul>
<li>难以动态增加<br />
</li>
<li>删除和插入记录时性能消耗较大<br />
</li>
<li>反复增删会产生外部碎片<br />
</li>
<li>难以确定文件最后需要分配的空间大小<br />
</li>
</ul></li>
<li>链接分配
<ul>
<li>隐式链接，目录项中含有文件第一块的指针和最后一块的指针,一个盘块有链接下一个盘块的指针，只能顺序访问，缺点是容易丢失，可以通过将若干盘块组合成簇来改进(会增加内部碎片)<br />
</li>
<li>显式链接，把用于链接文件各物理块的指针，从每个物理块的末尾中提取出来，显式地存放在内存的一张链接表中，称为文件分配表FAT,可以用一个特殊的数字-1表示文件的最后一块，可以用-2表示这个磁盘块是空闲的,FAT表在系统启动时就会被读入内存，因此查找记录的过程是在内存中进行的<br />
</li>
</ul></li>
<li>索引分配，将每个文件所有的盘块号都集中放在一起构成索引，每个文件有索引块，其第i条目的指针指向文件第i块，这样没有外部碎片，但增加了存储开销
<ul>
<li>链接索引块来减少开销<br />
</li>
<li>多层索引来支持更大文件<br />
</li>
<li>混合索引，见下文</li>
</ul></li>
</ul>
<div class="note info"><ul>
<li>对于小文件，为了提高对众多小文件的访问速度，将它们的每个盘块地址直接放入FCB,这样就可以直接从FCB中获得该文件的盘块地址，即为直接寻址。<br />
</li>
<li>对于中型文件，可以采用单级索引方式，需要先从FCB中找到该文件的索引表，从中获得该文件的盘块地址，即为一次间址。<br />
</li>
<li>对于大型或特大型文件，可以采用两级和三级索引分配方式。UNIX系统采用的就是这种分配方式</li>
</ul>
<p><strong>unix的inode</strong></p>
<ul>
<li>直接地址，在索引结点中可设置10个直接地址项，小于10个盘块的文件可以直接寻址<br />
</li>
<li>—次间接地址，i.addr(l0)提供一次间接地址,存放的是索引表，所有一级寻址索引表可存放1024个盘块号，假设一个盘块4kB,允许文件长达4MB<br />
</li>
<li>多次间接地址。当文件长度大于4MB + 40KB (一次间接地址与10个直接地址项)时，系统还需采用二次间接地址分配方式。用地址项i.addr(ll)提供二次间接地址，允许文件最大长度可达4GB，以此类推</li>
</ul>
</div>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231219205637.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231219205646.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231219205853.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231219210438.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231219211121.png" /></p>
<div class="note info"><p>疑难梳理：<br />
文件：信息的集合，在操作系统中文件由一系列的目录项FCB管理。<br />
目录项可包括文件的大部分信息，但目录项最重要的功能是提供文件名以便查询，因此目录项可以只存放文件名与一个索引结点号或物理簇号，一般索引结点用于存放描述信息。同时，目录项可以集中存放在一些物理簇上便于查询<br />
当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件<br />
操作系统中的文件夹，实际上是一种目录文件，目录文件只存放目录项FCB,可以通过目录文件的FCB调取到目录文件</p>
<p>物理存放上，可分为：</p>
<ul>
<li>连续存放，此时FCB或者索引结点可以用(起始块号,块数)的形式描述文件物理地址<br />
</li>
<li>隐式链接，目录项需要记载起始结束块号或者指针，涉及到的每个磁盘块有指向下一块的指针(指针大小不计入文件大小)<br />
</li>
<li>显式链接，一个磁盘设置一张文件分配表FAT，常驻内存，由于表项等长，物理块号(表项的索引)可以等长,访问第i块可以查表，避免低速的IO(随机访问)<br />
</li>
<li>索引表，每个文件需要索引表，存放在特定物理簇，称为索引块，与数据块区分，FCB(或者索引结点)需要记录索引块号，索引块可以链接，可以分层，可以像linux一样混合在inode里</li>
</ul>
<p>文件操作：</p>
<ol type="1">
<li>创建(create系统调用)
<ol type="1">
<li>找到足够的空闲硬盘块<br />
</li>
<li>根据路径找到创建目录的目录文件，为其增加一个目录项<br />
</li>
</ol></li>
<li>删除(delete)
<ol type="1">
<li>找到目录项，根据物理块信息回收磁盘<br />
</li>
<li>删除目录项(在上级目录的目录文件里)<br />
</li>
</ol></li>
<li>打开(open)
<ol type="1">
<li>找到目录项，检查用户是否有足够权限<br />
</li>
<li>将目录项调入内存的打开文件表，返回用户的是对应表项的编号，不需要调入文件内容(分为进程和系统，系统中的表项有打开计数，进程中链接到系统的表项，并且进程有自己的读写指针)<br />
</li>
</ol></li>
<li>关闭(close)
<ol type="1">
<li>删除进程的打开文件表项<br />
</li>
<li>回收内存<br />
</li>
<li>系统打开文件表项，打开计数器减一，若为0删除<br />
</li>
</ol></li>
<li>读(read)
<ol type="1">
<li>根据读写指针，读入长度，读后数据存放位置进行读命令<br />
</li>
</ol></li>
<li>写(write)
<ol type="1">
<li>类似读命令</li>
</ol></li>
</ol>
<p><strong>注意</strong>：(进程)打开文件表的索引号也叫<strong>文件描述符(句柄)</strong>，读写时用描述符即可指定文件，无需访问外存的文件名</p>
<p>文件共享：</p>
<ul>
<li>硬链接：目录文件的目录项只提供文件名和索引结点指针(硬盘块号)，索引节点维护打开计数，链接到同一个索引节点的两个目录项共享一个索引节点表示的文件<br />
</li>
<li>软链接：一种类型为Link的文件，内容包括链接文件的路径，可以用这个路径检索到对应文件，但除此以外和链接文件无关，根据路径寻找发现无效后删除</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240221111830.png" /></p>
</div>
<h2 id="目录">目录</h2>
<p>FCB的有序集合称为目录，FCB则是目录项<br />
目录管理的基本要求：按名存取,访问控制，不同用户对不同文件采用相同的名字，性能较好等</p>
<p><strong>目录结构</strong></p>
<ol type="1">
<li>单级目录，当访问一个文件时，先按文件名在该目录中查找到相应的FCB，建立新文件时需要先确保没有重名再新增一个目录项<br />
</li>
<li>两级目录，分为主文件目录MDF和用户文件目录UFD,主文件目录项记录用户名及相应用户文件目录所在的存储位置。用户文件目录项记录该用户文件的FCB信息。当某用户欲对其文件进行访问时，只需搜索该用户对应的UFD，这样解决了重名问题<br />
</li>
<li>树形目录(最普遍)，用文件的路径名标识文件，文件路径名是个字符串，由从根目录出发到所找文件通路上所有目录名与数据文件名用分隔符“/”链接而成，分为绝对路径(根目录开始)和相对路径(当前目录开始)，一般操作系统提供一条专门的系统调用，供用户随时改变<br />
</li>
<li>无环图目录结构,每个共享结点设置一个共享计数器,归零才可以删除，对于共享文件，只存在一个真正的文件，任何改变都会为其他用户所见</li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231220121025.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231220121323.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231220121512.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231220121641.png" /></p>
<p><strong>目录操作</strong></p>
<ul>
<li>搜索<br />
</li>
<li>创建文件，新增目录项<br />
</li>
<li>删除文件，删除目录项<br />
</li>
<li>创建目录<br />
</li>
<li>删除目录，分为可删除非空目录和不可删除，后者需要递归删除目录中文件和目录<br />
</li>
<li>移动目录<br />
</li>
<li>显示目录<br />
</li>
<li>修改目录属性<br />
目录一般有哈希表和线性表两种实现</li>
</ul>
<p><strong>文件共享</strong></p>
<ul>
<li>基于索引结点的共享方式(硬链接)：文件属性等信息，不再放在目录项中，而放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。在索引结点中还应有一个链接计数count,用于表示链接到本索引结点(即文件)上的用户目录项的数目。<br />
</li>
<li>利用符号链实现文件共享(软链接)：为使用户B能共享用户A的一个文件F,可以由系统创建一个LINK类型的新文件，也取名为F,并将该文件写入用户B的目录中，系统看到要读的文件是LINK类型，则根据该文件中的路径名去找到文件F,然后对它进行读。只有文件主才拥有指向其索引结点的指针。而共享该文件的其他用户只有该文件的路径名，当文件主把一个共享文件删除后，若其他用户又试图通过符号链去访问它时，则会访问失败，于是将符号链接删除,缺点是增加I/O开销与一定的空间开销<br />
</li>
<li>两个进程同时对同一个文件进行操作，这样的共享称为动态共享</li>
</ul>
<p>硬链接的查找速度要比软链接的快</p>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231220122126.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231220122157.png" /></p>
<div class="note warning"><ul>
<li>n条记录的平均查找次数是(1+n)/2<br />
</li>
<li>索引分配下文件最大等于(<code>索引总数*文件块大小</code>)<br />
</li>
<li>对文件修改后需要写回操作<br />
</li>
<li>提前读(将可能访问盘块读入内存)和延迟写(对文件的修改先写入缓冲区以便高速读取，缓冲不够才写入文件)，硬盘高速缓存和连续分配空间都可以提高文件访问速度<br />
</li>
<li>平均访问硬盘块数=每个访问项需要的访问次数之和/访问项总数<br />
</li>
<li>读和写各自算一次访问io,例如移动记录这种操作需要两次访问io<br />
</li>
<li>文件最大长度只计算数据部分，需要减去链接指针占用大小<br />
</li>
<li>符号链接无法感知链接文件的状态，引用计数保持不变<br />
</li>
<li>进程的读/写指针记录了该进程对文件的读/写操作进行到的位置，独属于进程<br />
</li>
<li>文件描述符是进程各自的用户打开文件表项的索引号<br />
</li>
<li>FAT的每个表项中存放下一个簇号,且连续存放，访问特定地址时可以计算要访问的是第几个地址块，从而查表直接找到其物理块号<br />
</li>
<li>文件系统的文件索引结点数决定可存放的文件数，一个索引结点的地址项数量和性质以及簇可存放的地址项数量决定一个文件的最大长度<br />
</li>
<li>打开文件指的是将其目录项读入内存，且写入打开文件表，不包括将其内容调入内存</li>
</ul>
</div>
<h2 id="文件系统">文件系统</h2>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231221205930.png" /><br />
图中：</p>
<ul>
<li>基本文件系统：向相应设备驱动程序发生命令，读写磁盘的物理块；管理内存缓冲区，存文件系统需要的缓存<br />
</li>
<li>文件组织模块：组织文件及其逻辑和物理块，并进行逻辑物理块的转换；空闲空间管理器，跟踪未分配的块<br />
</li>
<li>逻辑文件系统，管理元数据，即文件系统的所有结构，但不包括实际数据，本质上通过FCB实现；文件保护</li>
</ul>
<h3 id="布局">布局</h3>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231221210857.png" /><br />
<div class="note info"><ol type="1">
<li>主引导记录(Master Boot Record, MBR),位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。表中的一个分区被标记为活动分区，当计算机启动时，BIOS读入并执行MBR。MBR做的第一件事是确定活动分区，读入它的第一块，即引导块。<br />
</li>
<li>引导块(boot block), MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统。为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统,也不排除以后会在该分区安装一个操作系统。Windows系统称之为分区引导扇区。除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的。文件系统经常包含有如图4.18所列的一些项目。<br />
</li>
<li>超级块(super block),包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的FCB数量和FCB指针等。<br />
</li>
<li>文件系统中空闲块的信息，可以使用位示图或指针链接的形式给出。后面也许是一组i结点，每个文件对应一个结点，i结点包含文件属性。也可能是根目录，它存放文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件</li>
</ol>
</div></p>
<p><strong>在内存中的结构</strong></p>
<p>内存中的信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。可能包括：</p>
<ol type="1">
<li>内存中的安装表(mounttable),包含每个已安装文件系统分区的有关信息。<br />
</li>
<li>内存中的目录结构的缓存,包含最近访问目录的信息。对安装分区的目录，它可以包括一个指向分区表的指针。<br />
</li>
<li>整个系统的打开文件表，包含每个打开文件的FCB副本及其他信息。<br />
</li>
<li>每个进程的打开文件表，包含一个指向整个系统的打开文件表中的适当条目的指针，以及其他信息</li>
</ol>
<p><strong>创建文件的流程</strong></p>
<ol type="1">
<li>进程调用逻辑文件系统<br />
</li>
<li>逻辑文件系统分配一个FCB<br />
</li>
<li>系统将新目录读入内存，用文件名和FCB更新，并写回磁盘</li>
</ol>
<p><strong>打开文件的流程</strong>：</p>
<ol type="1">
<li>调用Open，文件名传给逻辑文件系统<br />
</li>
<li>搜索系统的打开文件表
<ol type="1">
<li>如果有其他进程使用，则现在进程的打开文件表设置条目指向系统的打开文件表相应表项<br />
</li>
<li>如果这个文件尚未打开，则根据文件名搜索目录结构，找到后复制其FCB到系统打开文件表，进程的打开文件表项增设条目指向系统的表项，通过指针将整个系统打开文件表的条目与其他域相连<br />
</li>
</ol></li>
<li>返回一个指向单个进程的打开文件表中的适当条目的指针，文件操作将用该指针进行</li>
</ol>
<p><strong>关闭文件的流程</strong>：</p>
<ol type="1">
<li>删除单个进程打开文件表中的相应条目，整个系统的打开文件表的文件打开数量也会递减<br />
</li>
<li>当所有打开某个文件的用户都关闭该文件后，任何更新的元数据将复制到磁盘的目录结构中，并且整个系统的打开文件表的对应条目也会被删除</li>
</ol>
<h3 id="外存管理">外存管理</h3>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231223205344.png" /><br />
磁盘可以划分成分区，这是单纯对硬件的划分，而文件系统却是软件层面的概念，因此一个有文件系统的分区才能实际使用，称为卷，卷对应硬件上的存储，不局限于具体设备  <br />
卷中的文件数据和FCB是分离的(汝,似为分离而生),现代操作系统往往有很多文件管理模块，通过它们可以访问不同格式卷的文件  <br />
卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放卷信息的超级块  <br />
文件存储设备管理实质上是对空闲块的组织管理，过程中以块为单位交换信息<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231223204422.png" /><br />
引导信息是一系列可以加载到内存中的连续块，加载到内存后从其第一条代码开始执行，引导程序便启动一个具体的操作系统。引导块之后是超级块，它存储文件系统的有关信息,随后是多个索引结点,索引结点中包含多个指针，指向属于该文件的各个数据块。最后是文件数据块<br />
文件系统在进程使用前必须先安装，也称挂载</p>
<ul>
<li>Windows系统维护一个扩展的两级目录结构，用驱动器字母表示设备和卷，卷具有常规树结构的目录，与驱动器号相关联，每个卷有自己的文件系统<br />
</li>
<li>UNIX使用系统的根文件系统，由内核在引导阶段直接安装,也可以后续用脚本或者用户命令安装在已有文件系统的目录下，作为一个目录树，每个文件系统都拥有自己的根目录。安装文件系统的这个目录称为安装点，安装就是将磁盘分区挂载到该安装点下，进入该目录就可以读取该分区的数据。己安装文件系统属于安装点目录的一个子文件系统。</li>
</ul>
<ol type="1">
<li>空闲表法，每个文件分配一块连续空间，系统为所有空闲区建立空闲表，和表项一一对应，空闲区的分配类似内存分配，可以用首次/最佳适应等，不适用大型系统<br />
</li>
<li>空闲链表法，所有空闲盘区组成一个链表，不适用大型系统
<ol type="1">
<li> 空闲盘块链，分配文件从链首裁剪，回收空间插入到链尾，但这样的链会很长<br />
</li>
<li>空闲盘区链，盘区可以包括若干盘块，每个盘区包括自己盘块数的信息，一般用首次适应分配，和第一个相反，分配回收较复杂，效率较高<br />
</li>
</ol></li>
<li> 位示图法，用二进制的一位表示一个盘块使用情况，比如0表示空，1表示已分配，分配过程是：
<ol type="1">
<li> 顺序扫描位示图，找出足够的0位<br />
</li>
<li> 将找到的二进制位，转换成对应盘块号b，b = n(i-1) +j,ij是坐标，n是每行位数<br />
</li>
<li> 修改位示图,<code>map[i,j]=1</code><br />
</li>
<li> 回收时,<code>j = (b-1)DIVn+ 1</code>  <code>j = (b-1) MODn+ 1</code>并修改<code>map[i,j]=0</code><br />
</li>
</ol></li>
<li> 成组链接法(UNIX使用)，把顺序的n个空闲盘块号保存在第一个成组链块中，其最后一个空闲盘块(作为成组链块)则用于保存另一组空闲盘块号，系统只需保存指向第一个成组链块的指针，分配与回收过程：
<ol type="1">
<li> 根据第一个成组链块的指针，将其对应的盘块分配给用户<br />
</li>
<li> 指针后移，如果指向最后一个盘块，就把下一组读入内存，指针指向其开头<br />
</li>
<li> 回收时，成组链块的指针上移一格，再记入回收盘块号。当成组链块的链接数达到n时，表示己满，便将现有已记录n个空闲盘块号的成组链块号作为新链块记入新回收的盘块<br />
</li>
<li> 表示空闲空间的位向量表或第一个成组链块，以及卷中的目录区、文件区划分信息都要存放在磁盘中，一般放在卷头位置，在UNIX系统中称为超级块。在对卷中的文件进行操作前，超级块需要预先读入系统空闲的主存，并且经常保持主存超级块与磁盘卷中超级块的一致</li>
</ol></li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231223205331.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231223205318.png" /></p>
<h3 id="虚拟文件系统vfs">虚拟文件系统VFS</h3>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231223205303.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231223205258.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231223205226.png" /><br />
VFS提供文件系统的统一接口，使用者不需要关注具体实现  <br />
为了实现VFS, Linux主要抽象了四种对象类型。每个VFS对象都存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法(函数)表的指针。</p>
<ul>
<li>超级块对象：表示一个己安装(或称挂载)的特定文件系统。<br />
</li>
<li>索引结点对象；表示一个特定的文件。<br />
</li>
<li>目录项对象：表示一个特定的目录项。<br />
</li>
<li>文件对象：表示一个与进程相关的已打开文件</li>
</ul>
<p>linux中有一切皆文件的说法，这也包括目录，特定地说：</p>
<ul>
<li>超级块对象：对应文件系统的超级块，存储文件系统的元信息<br />
</li>
<li>索引节点对象：文件系统处理文件所需要的所有信息，都放在一个称为索引结点的数据结构中，索引结点对文件是唯一的。只有当文件被访问时，才在内存中创建索引结点对象，这个对象有个修改状态字，用于更新<br />
</li>
<li>目录项对象：目录项对象是一个路径的组成部分，它要么是目录名，要么是文件名;例如'/test'中'/'和'test'都是这种对象<br />
</li>
<li>文件对象：文件对象代表进程打开的一个文件，一个文件可以对应出多个文件对象，它对应一个唯一的索引节点和目录项，包含一些文件的必要信息</li>
</ul>
<p>物理存储中，不同文件系统的目录项，索引结点等也不同，VFS用统一的vnode表示文件，只运行在内存中(与inode不同的是inode可以存在外存)<br />
VFS还有另一个重要作用，即提高系统性能。最近最常使用的目录项对象被放在目录项高速缓存的磁盘缓存中，以加速从文件路径名到最后一个路径分量的索引结点的转换过程,VFS并不是一种实际的文件系统，它<strong>只存在于内存中</strong></p>
<p>新分区(文件系统)的挂载：</p>
<ol type="1">
<li>VFS注册新的文件系统，放在内存的挂载表中<br />
</li>
<li>文件系统提供一个函数地址列表<br />
</li>
<li>将分区挂载在特定的一个目录下</li>
</ol>
<hr />
<h1 id="io设备">I/O设备</h1>
<h2 id="概念-3">概念</h2>
<p><strong>分类</strong></p>
<ol type="1">
<li>块设备，信息交换以数据块为单位，属于有结构设备，如磁盘，传输的数据有结构,可寻址(随机读写)<br />
</li>
<li>字符设备，信息交换以字符为单位，属于无结构设备，如打印机，不可寻址</li>
</ol>
<p>或者按传输速率分：</p>
<ol type="1">
<li>低速设备，每秒数百字节或以下，如键鼠<br />
</li>
<li>中速设备，数万字节或以下，如打印机<br />
</li>
<li>高速设备，数百千字节或更高，如磁盘</li>
</ol>
<p><strong>I/O接口(设备控制器)</strong>：</p>
<p>根据cpu命令和设备状态协调两者工作</p>
<ul>
<li>设备控制器与cpu接口，分为数据，地址，控制线，数据线一般和数据寄存器与控制/状态寄存器相连<br />
</li>
<li>设备控制器与设备接口，可能有多个设备的多个接口，每个都有数据，控制，状态类型的信号<br />
</li>
<li>I/O逻辑，通过控制线与cpu交互，对cpu发来的命令译码，CPU启动设备时，将启动命令发送给控制器，同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地对所选设备进行控制。</li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231225194343.png" /><br />
主要作用：</p>
<ul>
<li>接受识别cpu命令<br />
</li>
<li>数据交互，设备主存控制器三者交互<br />
</li>
<li>识别报告设备状态<br />
</li>
<li>地址识别<br />
</li>
<li>数据缓冲<br />
</li>
<li>差错控制</li>
</ul>
<p><strong>I/O端口</strong><br />
指设备控制器中可被cpu直接访问的寄存器，主要有以下三类：</p>
<ul>
<li>数据寄存器，实现cpu和外设之间的数据缓冲<br />
</li>
<li>状态寄存器，获取执行结果和设备的状态信息<br />
</li>
<li>控制寄存器，cpu写入，对设备进行操作，如启动或更改模式</li>
</ul>
<p>cpu和io端口的通信方式：</p>
<ul>
<li>独立编址，每个端口分配一个端口号，只有操作系统可以用特殊io指令访问这些端口<br />
</li>
<li>统一编址(内存映射I/O)，每个端口分配唯一的内存地址，这部分内存被该端口独占，地址通常靠近地址空间顶端</li>
</ul>
<h3 id="控制方式">控制方式</h3>
<ol type="1">
<li>程序直接控制，cpu对外设状态循环检查，直到确定从i/o设备读取的字已经在io控制器的数据寄存器中，缺点是cpu利用率低下<br />
</li>
<li>中断驱动，允许I/O设备中断cpu，会消耗较多的CPU时间，流程如下
<ol type="1">
<li>cpu发送指令，如读，保存需要io的当前程序上下文，继续下一个作业<br />
</li>
<li>i/o控制器接受指令后，读数据存入数据寄存器后通过控制线发送中断信号<br />
</li>
<li>cpu收到中断信号，进行中断处理，对控制器发出取请求<br />
</li>
<li>控制器把数据放到数据总线，i/o控制器的操作完成<br />
</li>
<li>cpu存入寄存器，随后存入主存，恢复发出I/O请求的程序继续运行<br />
</li>
</ol></li>
<li>DMA方式，在I/O设备和内存之间设置数据交换通路，中断方式在每个数据需要传输时中断CPU,而DMA方式则是在所要求传送的一批数据全部传送结束时才中断CPU(缺点是对离散的数据块请求仍需要较多cpu占用)
<ol type="1">
<li>特点
<ol type="1">
<li>基本单位是数据块<br />
</li>
<li>数据直接在设备与内存之间传输<br />
</li>
<li>传输数据块的开始和结束时需要cpu干预，传输过程由dma控制器操纵<br />
</li>
</ol></li>
<li>寄存器
<ol type="1">
<li>命令/状态寄存器CR，接受i/o命令，控制状态信息<br />
</li>
<li>内存地址寄存器MAR,分别在输入输出时存放设备到内存和内存到设备的内存起始地址<br />
</li>
<li>数据寄存器DR，暂存交换的数据<br />
</li>
<li>数据计数器DC，存放传输数据的字数或者字节数<br />
</li>
</ol></li>
<li>工作流程
<ol type="1">
<li>cpu接受io设备的dma请求，向dma控制器发送命令，设置MAR,DC初值，继续其他工作<br />
</li>
<li>DMA与主存交换数据，每次一个字，结束后发送中断信号<br />
</li>
<li>cpu进行中断处理<br />
</li>
</ol></li>
</ol></li>
<li>通道控制，在内存设置通道，一个通道可以控制多个设备的内存交换，结束后中断cpu(通道只需要cpu简单地初始化，就可以控制一组数据块的传输，并行度最高，硬件成本也最高)通道没有自己的内存，程序存在主存</li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231225210128.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231225210117.png" /></p>
<h3 id="io软件层次">I/O软件层次</h3>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231225211213.png" /><br />
将系统中的设备管理模块分为若干个层次,每层都是利用其下层提供的服务，每层都只有接口与其他层面交互，屏蔽具体细节</p>
<ol type="1">
<li>用户层，用户可以调用相关库函数，对设备进行操作，最终一般会用系统调用来获取系统服务<br />
</li>
<li>设备独立性(无关性)软件，用于实现用户程序与设备驱动器的统一接口、设备命令、设备的保护及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间
<ol type="1">
<li>应用程序独立于具体的物理设备，用逻辑设备名请求设备，系统执行时映射成物理设备，这样可以灵活分配设备，并易于实现I/O重定向(即物理设备可以随意更换)、<br />
</li>
<li>主要功能：
<ol type="1">
<li>执行所有设备的公有操作，分配回收，逻辑映射，访问控制，缓冲差错控制等<br />
</li>
<li>对用户或文件层提供统一接口，r/w等<br />
</li>
</ol></li>
</ol></li>
<li>设备驱动程序，负责具体实现系统对设备发出的操作指令，设备驱动程序向上层用户程序提供一组标准接口，向下发送命令给设备控制器，并接受其信号发送给软件<br />
</li>
<li>中断处理，用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断进程。
<ol type="1">
<li>主要任务：进程上下文切换，读取设备状态，修改进程状态等</li>
</ol></li>
</ol>
<p>设备独立性软件,设备驱动程序，中断处理程序是操作系统内核部分，称为<strong>IO系统</strong>或者<strong>IO核心子系统</strong></p>
<p>一次标准I/O操作流程：</p>
<ol type="1">
<li>通过用户层软件发送io相关的指令<br />
</li>
<li>独立软件进行解析，一般转换成通用命令，发送给驱动程序<br />
</li>
<li>驱动程序根据设备具体实现这个命令<br />
</li>
<li>中断当前运行进程，由硬件开始执行命令</li>
</ol>
<h3 id="应用程序接口">应用程序接口</h3>
<p>I/O系统与更高层的接口</p>
<ol type="1">
<li>字符设备接口，字符设备是指数据的存取和传输是以字符为单位的设备，一般不可寻址，中断驱动，需要互斥操作。通常为字符设备建立一个字符缓冲区，用户程序通过get操作从缓冲区获取字符，通过put操作将字符输出到缓冲区。并用一个通用的in-control指令处理<br />
</li>
<li>块设备接口，块设备是指数据的存取和传输是以数据块为单位的设备，如磁盘，一般可寻址，常使用dma
<ol type="1">
<li>块设备接口将磁盘的所有扇区从0到依次编号，这样，就将二维结构变为一种线性序列。<br />
</li>
<li>把上层的打开关闭读写等抽象命令转换成设备识别的底层命令<br />
</li>
<li>内存映射接口通过内存的字节数组来访问磁盘，而不提供读/写磁盘操作。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时，才由虚拟存储器实际调页<br />
</li>
</ol></li>
<li>网络设备接口，一般使用网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。<br />
</li>
<li>阻塞/非阻塞I/O
<ol type="1">
<li>阻塞I/O是指当用户进程调用I/O操作时，进程就被阻塞，需要等待I/O操作完成，进程才被唤醒继续执行，更加常见<br />
</li>
<li>非阻塞I/O是指用户进程调用I/O操作时，不阻塞该进程，该I/O调用返回一个错误返回值，通常，进程需要通过轮询的方式来查询I/O操作是否完成。</li>
</ol></li>
</ol>
<div class="note warning"><ul>
<li>I/O管理的主要功能：状态跟踪，设备存取，分配(多用户)，控制<br />
</li>
<li>共享设备必须是可寻址的和可随机访问的设备<br />
</li>
<li>虚拟设备是指采用虚拟技术将一台独占设备转换为若干逻辑设备<br />
</li>
<li>通道控制设备控制器、设备控制器控制设备工作<br />
</li>
<li>所有设备的启动工作都由系统统一来做<br />
</li>
<li>首先获得中断驱动的io设备(如键盘)输入信息的是中断程序<br />
</li>
<li>dma每传送一个字都需要中断处理</li>
</ul>
</div>
<h2 id="设备独立性软件">设备独立性软件</h2>
<p>与设备无关的软件是I/O系统的最高层软件，一般用于执行所有设备公有操作</p>
<h3 id="高速缓存和缓冲区">高速缓存和缓冲区</h3>
<p><strong>磁盘高速缓存</strong><br />
利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。<br />
在内存中分为两种形式：</p>
<ul>
<li>在内存中开辟一个单独的空间作为磁盘高速缓存，大小固定；<br />
</li>
<li>是未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享。</li>
</ul>
<p><strong>缓冲区</strong></p>
<p>引入缓冲区的目的主要如下：</p>
<ol type="1">
<li>缓和CPU与I/O设备间速度不匹配的矛盾。<br />
</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制。<br />
</li>
<li>解决基本数据单元大小(即数据粒度)不匹配的问题。<br />
</li>
<li>提高CPU和I/O设备之间的并行性。</li>
</ol>
<p>硬件缓冲器出于成本较少用，内存设置缓冲区是更常见的情况<br />
假定从磁盘把一块数据输入到缓冲区的时间为T,操作系统将该缓冲区中的数据传送到用户区的时间为M,而CPU对这一块数据处理的时间为C。</p>
<p><strong>单缓冲</strong><br />
初始状态为：工作区是满的，缓冲区是空的。一般认为二者大小相等<br />
单缓冲区处理每块数据的用时为max(C, T)+M</p>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231226152658.png" /></p>
<p><strong>双缓冲</strong><br />
单缓冲中CPU在M时间空闲，所以引入双缓冲<br />
先装填到缓冲区1,在缓冲区1填满后才开始装填缓冲区2,与此同时处理机可以从缓冲区1中取出数据送入用户进程，当缓冲区1中的数据处理完后，若缓冲区2己填满，则处理机又从缓冲区2中取出数据送入用户进程，而I/O设备又可以装填缓冲区1<br />
初始状态：工作区是空的，其中一个缓冲区是满的，另外一个缓冲区是空的</p>
<ul>
<li>假设<code>T&gt;C+M</code>,满的区传送数据，空区充入数据，C+M后数据处理完，但新的数据还没冲入，需要等到T才能回到初始状态<br />
</li>
<li>假设<code>T&lt;C+M</code>,T后空区被冲满，但原数据没有处理完，需要等到C+M<br />
</li>
<li>若<code>M+C&lt;T</code>,则可使块设备连续输入；若<code>C+M&gt;T</code>,则可使CPU不必等待设备输入</li>
</ul>
<p>综上，处理一块数据周期需要时间是max(C + M, T)。<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226154810.png" /><br />
为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另一个用作接收缓冲区<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226155325.png" /></p>
<p><strong>循环缓冲</strong><br />
包含多个大小相等的缓冲区,每个有一个指向下个区的指针，构成一个循环链表<br />
需要有两个指针in和out，in指向第一个空区，out指向第一个满区</p>
<p><strong>缓冲池</strong><br />
由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列(输入队列)和装满输出数据的缓冲队列(输出队列)。<br />
以及四种缓冲区：</p>
<ul>
<li>用于收容输入数据的工作缓冲区<br />
</li>
<li>用于提取输入数据的工作缓冲区<br />
</li>
<li>用于收容输出数据的工作缓冲区<br />
</li>
<li>用于提取输出数据的工作缓冲区<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226155733.png" /><br />
当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据/数据用完后再将它挂到空缓冲队列尾。当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。当要输出时，由输出进程从输出队列中取得一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。<br />
类似一个循环流水线，一个装瓶，一个把瓶子里的原料用掉</li>
</ul>
<p><strong>两者比较</strong><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226160003.png" /></p>
<h3 id="设备分配与回收">设备分配与回收</h3>
<p>设备分配是指根据用户的I/O请求分配所需的设备。需要充分利用设备又不导致进程死锁</p>
<p><strong>设备的分类</strong></p>
<ul>
<li>独占设备，分配给进程后独占，直到释放<br />
</li>
<li>共享设备，多个进程可共用的设备<br />
</li>
<li>虚拟设备，SPOOLing(假脱机)技术实现了虚拟设备功能，可以将设备同时分配给多个进程。这种技术实质上就是实现了对设备的I/O操作的批处理。</li>
</ul>
<p><strong>数据结构</strong><br />
设备分配依据的主要数据结构有设备控制表(DCT)、控制器控制表(COCT)、通道控制表(CHCT)和系统设备表(SDT)</p>
<ul>
<li>一个设备控制表就表示一个设备，而这个控制表中的表项就是设备的各个属性,凡因请求本设备而未得到满足的进程，其PCB排成一个设备请求队列，设备队列的队首指针指向该请求队列队首PCB。<br />
</li>
<li>COCT需要一个通道服务，因此存放一个CHCT的指针<br />
</li>
<li>CHCT可以服务多个设备，因此存放一个设备控制器表的首地址<br />
</li>
<li>SDT存储系统连接到的设备，是唯一的<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226160400.png" /><br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226160538.png" /></li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240223185939.png" /></p>
<p>设备分配的过程:</p>
<ol type="1">
<li>分配设备:首先根据I/O请求中的物理设备名，查找SDT,从中找出该设备的DCT,再根据DCT中的设备状态字段，可知该设备的状态。若忙，则将进程PCB挂到设备等待队列中：若不忙，则根据一定的策略将设备分配给该进程</li>
<li>分配控制器:设备分配后，根据DCT找到COCT,查询控制器的状态。若忙，则将进程PCB挂到控制器等待队列中；若不忙，则将控制器分配给该进程。</li>
<li>分配通道:控制器分配后，根据COCT找到CHCT,查询通道的状态。若忙，则将进程PCB挂到通道等待队列中：若不忙，则将通道分配给该进程。只有设备、控制器和通道都分配成功时，这次的设备分配才算成功，之后便可启动设备进行数据传输</li>
<li>可以直接分配物理设备，也可以用类别区分逻辑设备，分配某一类设备</li>
</ol>
<p><strong>分配策略</strong><br />
需要考虑设备固有属性，分配算法，安全性</p>
<ul>
<li>静态分配：在用户作业执行前，一次性分配其需要的所有设备与控制器，进程独占这些设备与控制器直到终止或撤销，使用效率较低但没有死锁，常用于独占设备<br />
</li>
<li>动态分配：进程执行中根据需求分配，用完立刻释放，效率但可能死锁，常用于共享设备<br />
</li>
<li>常见的分配算法：先请求先分配，优先级等<br />
</li>
<li>每当进程发出I/O请求后便进入阻塞态，直到其I/O操作完成时才被唤醒，这样破坏了占有并等待条件，不会产生死锁，是一种安全的分配，但效率较低，不能并行<br />
</li>
<li>进程在发出I/O请求后仍继续运行，仅当进程所请求的设备已被另一进程占用时，才进入阻塞态，这样不安全，但并行度高</li>
</ul>
<p><strong>设备独立性</strong><br />
指应用程序独立于具体设备，在应用程序中使用逻辑设备名来请求使用某类设备，在系统中设置一张逻辑设备表LUT，用于将逻辑设备名映射为物理设备名，表项包括逻辑设备名、物理设备名和设备驱动程序入口地址；当进程用逻辑设备名来请求分配设备时，系统为它分配一台相应的物理设备，并在LUT中建立一个表目，当以后进程再利用该逻辑设备名请求I/O操作时，系统通过查找LUT来寻找对应的物理设备和驱动程序</p>
<p>逻辑设备表可以系统中唯一设定(不允许重名)也可以每个用户设置一个，用户登录时建立一个进程，并建立一个LUT放入其PCB</p>
<h3 id="spooling技术假脱机">SPOOLing技术(假脱机)</h3>
<p>为了缓和CPU的高速与I/O设备低速性之间的矛盾，引入了脱机输入/输出技术，利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226211005.png" /></p>
<ol type="1">
<li>输入井和输出井，分别模拟脱机输入和输出时的磁盘，接受IO设备输入的数据，收容用户程序的输出数据，每个进程的输入输出数据都以文件为单位保存，最后链接成一个输入或者输出队列<br />
</li>
<li>输入缓冲区和输出缓冲区，用于暂存输入输出过程的数据<br />
</li>
<li>输入进程和输出进程，模拟脱机输入/输出时的外围控制机，用户请求输入和输出的数据到达井后，可以从输入井读入内存，或者从输出井经过缓冲区到达输出设备</li>
</ol>
<p>实例：<strong>共享打印机</strong><br />
用户进程请求打印，由假脱机进程进行以下工作：</p>
<ol type="1">
<li>在磁盘缓冲区中为之申请一个空闲盘块，并将要打印的数据送入其中暂存。<br />
</li>
<li>为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到假脱机文件队列<br />
软件层面上进程已经完成了输出工作，具体的硬件操作会在之后进行</li>
</ol>
<p><strong>特点</strong></p>
<ol type="1">
<li>提高了 I/O的速度，将对低速I/O设备执行的I/O操作演变为对磁盘缓冲区中数据的存取，如同脱机输入/输出一样，缓和了 CPU和低速I/O设备之间的速度不匹配的矛盾<br />
</li>
<li>将独占设备改造为共享设备，在假脱机打印机系统中，实际上并没有为任何进程分配设备<br />
</li>
<li>实现了虚拟设备功能，对每个进程而言，它们都认为自己独占了一个设备<br />
这三部分由<strong>预输入程序、井管理程序和缓输出程序</strong>管理<br />
对时间的优化主要体现在，cpu通过内存向磁盘的输入输出井交换数据要快于低速I/O设备，但相对的也会增加空间占用</li>
</ol>
<h3 id="设备驱动程序接口">设备驱动程序接口</h3>
<p>每个设备驱动程序与操作系统之间应该有相同或相近的接口，这样便于设备的添加管理和开发<br />
对于每种设备类型，例如磁盘，操作系统都要定义一组驱动程序必须支持的函数，驱动程序中通常包含一张表格，这张表格具有针对这些函数指向驱动程序自身的指针，装载驱动程序时，操作系统记录这个函数指针表的地址，所以当操作系统需要调用一个函数时，它可以通过这张表格发出间接调用。这个函数指针表定义了驱动程序与操作系统其余部分之间的接口。.给定类型的所有设备都必须服从这一要求。<br />
与设备无关的软件还要负责将符号化的设备名映射到适当的驱动程序上。例如，在UNIX中,设备名/dev/disk0唯一确定了一个特殊文件的i结点，这个i结点包含了主设备号(用于定位相应的驱动程序)和次设备号(用来确定要读写的具体设备)<br />
在UNIX和Windows中，设备是作为命名对象出现在文件系统中的，有自己的FCB文件，因此针对文件的常规保护规则也适用于I/O设备。系统管理员可以为每个设备设置适当的访问权限</p>
<h2 id="磁盘和固态硬盘">磁盘和固态硬盘</h2>
<h3 id="磁盘">磁盘</h3>
<p>表面涂有磁性物质的物理盘片，盘片旋转，通过磁头读取数据，磁盘盘面上的数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样宽，一个盘面有上千个磁道。磁道又划分为几百个扇区，每个扇区固定存储大小，一个扇区称为一个盘块。<br />
多个盘片垂直堆叠，组成磁盘组，每个盘面对应一个磁头，所有磁头固定在一起，与磁盘中心的距离相同且一起移动。所有盘片上相对位置相同的磁道组成柱面。扇区是磁盘可寻址的最小单位，磁盘上能存储的物理块数目由扇区数、磁道数及磁盘面数决定<br />
磁盘地址用“柱面号•盘面号•扇区号”表示。<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231225195259.png" /><br />
磁盘按不同的方式可分为若干类型：</p>
<ul>
<li>磁头相对于盘片的径向方向固定的，称为固定头磁盘，每个磁道一个磁头；<br />
</li>
<li>磁头可移动的，称为活动头磁盘，磁头臂可来回伸缩定位磁道；<br />
</li>
<li>磁盘永久固定在磁盘驱动器内的，称为固定盘磁盘；<br />
</li>
<li>可移动和替换的，称为可换盘磁盘。</li>
</ul>
<h4 id="磁盘管理">磁盘管理</h4>
<p>为了让控制器能进行读写操作，需要把磁盘划分扇区，这被称为低级(物理)格式化，每个扇区的数据结构通常由头尾和中间的数据区完成<br />
低级格式化时，磁盘控制器可以用备用块替换坏块，这种情况坏块对操作系统透明<br />
操作系统需要把数据结构记录到磁盘上，这需要将磁盘分成若干柱面组成的分区(分区的起始扇区和大小记录在主引导记录的分区表)，并且对分区进行逻辑格式化，把文件系统存储到磁盘上<br />
逻辑格式化时屏蔽的坏块可以被操作系统感知<br />
若干相邻扇区会被组合成一簇(linux称为块)，一般簇是文件存储的最小单位,即小于一簇大小的文件也会占用一簇,所以一般对磁盘鼓励减少小文件</p>
<p>计算机启动时，自举程序找到磁盘上的操作系统内核，加载到内存，转到起始地址，一般rom中存放自举程序的装入程序，完整的引导程序放在磁盘启动块上，有启动分区的磁盘称为系统磁盘或者启动磁盘<br />
例如在windows中，0号扇区存放引导代码，称为主引导记录MBR，rom中代码指示系统从MBR读取代码，并根据MBR存放的分区表和引导分区标志读取到引导分区的引导扇区(第一个扇区)<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226102839.png" /><br />
磁盘可能会出现坏块，可以手动处理或者控制器维护屏蔽一个坏块列表，用备用块替换掉</p>
<h4 id="磁盘调度算法">磁盘调度算法</h4>
<p>一次磁盘读写操作的时间由寻找(寻道)时间、旋转延迟时间和传输时间决定。</p>
<ul>
<li>寻找时间<span class="math inline">\(T_s\)</span> ,活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间。这个时间除跨越n条磁道的时间外，还包括启动磁臂的时间s,即<span class="math inline">\(T_s = m\times{n} + s\)</span>,式中，m是与磁盘驱动器速度有关的常数，约为0.2ms,磁臂的启动时间约为2ms。<br />
</li>
<li>旋转延迟时间<span class="math inline">\(T_r\)</span> 磁头定位到某一磁道的扇区所需要的时间，设磁盘的旋转速度为r,<span class="math inline">\(T_r=\frac{1}{2r}\)</span>,典型速度是每分钟5400转<br />
</li>
<li>传输时间<span class="math inline">\(T_t\)</span>从磁盘读出或向磁盘写入数据所经历的时间，这个时间取决于每次所读/写的字节数b和磁盘的旋转速度：<span class="math inline">\(T_t=\frac{b}{rN}\)</span></li>
</ul>
<p>总平均存取时间可以表示为:<span class="math display">\[T_a=T_s+\frac{1}{2r}+\frac{b}{rN}\]</span></p>
<p><strong>常见的磁盘调度算法</strong>：</p>
<ol type="1">
<li>FCFS，较少用<br />
</li>
<li>最短寻找时间优先SSTF,调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以便使每次的寻找时间最短,可能产生饥饿<br />
</li>
<li>扫描SCAN (又称电梯调度)，规定磁头运动方向，来回往复地单向扫描，偏向于最里或者最外的磁道<br />
</li>
<li>循环扫描C-SCAN，在扫描算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求<br />
</li>
<li>LOOK和C-LOOK，在扫描算法的基础上，磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点，一般默认是扫描算法的高级替代<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231226104356.png" /></li>
</ol>
<p><strong>减少延迟时间</strong><br />
对盘面扇区进行交替编号，对磁盘片组中的不同盘面错位命名。假设每个盘面有8个扇区，磁盘片组共8个盘面<br />
磁盘是连续自转设备，磁头读/写一个物理块后，需要经过短暂的处理时间才能开始读/写下一块。假设逻辑记录数据连续存放在磁盘空间中，若在盘面上按扇区交替编号连续存放，则连续读/写多条记录时能减少磁头的延迟时间；同柱面不同盘面的扇区若能错位编号，连续读/写相邻两个盘面的逻辑记录时也能减少磁头延迟时间。</p>
<p>传输时间被硬件限制，无法优化</p>
<h3 id="固态硬盘">固态硬盘</h3>
<p>基于闪存技术的存储器，由一个或多个闪存芯片和闪存翻译层组成，闪存翻译层将来自CPU的逻辑块读写请求翻译成对底层物理设备的读写控制信号,相当于扮演了磁盘控制器的角色<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231225195457.png" /></p>
<p>固态的主要缺点是闪存擦写寿命有限，需要磨损均衡技术：</p>
<ol type="1">
<li>动态磨损均衡。写入数据时，自动选择较新的闪存块<br />
</li>
<li>静态磨损均衡。就算没有数据写入，SSD也会监测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常的读写操作在较新的闪存块中进行。</li>
</ol>
<div class="note warning"><ul>
<li>文件以块为单位存放于磁盘中，文件的读写也以块为单位<br />
</li>
<li>分区在逻辑格式化之前，逻辑格式化是建立文件系统<br />
</li>
<li>默认的scan算法不会调度到最内外的磁道，而是最靠近内外侧的磁道<br />
</li>
<li>包括多个扇区的簇，其物理地址是起始扇区的地址</li>
</ul>
</div>
]]></content>
      <categories>
        <category>考研笔记</category>
        <category>研distance</category>
      </categories>
      <tags>
        <tag>研distance</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>基于哈佛cs50的计算机通识笔记</title>
    <url>/thinklive/16959/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励" data-whm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励">
  <script id="hbeData" type="hbeData" data-hmacdigest="96a4704fb750c828ea2c4f175e4ecbc0314aaec2a1e8ea993f1f36e1af9548bb">3f83cb85842003a042bb5c209f93aa5b5b295d1a7d370853f032ab70d9d9b269638a7b1ec196061c3a80b2602066f2fb3e9e90245342590f8b89c43edef88fdae3b213845cb38db338380e1e881bc9735a118128c49839f4330391fc5f442d337843dee5cf2b5475539e78215f2cb99faa9ccf7fc07bf46644e7f9fdb93e8862d1218d20de95c5257feaea0b3c82d28b6479cfad45cc83bcde0d68528bb243058bcf326eabf67bd43213618191fb273533591ac33a869bc7339051c82d45c7df3175f29f302b94521f1b47edc332b152e37ecfb354ee7ac1661bdeeb5d8b3a6e67ee5704fa59b401b5da75a84987d5d1fd774540f30ba05b07cf79689bcceb224faabc6eb51c1974a9600f80a81757cc065858eb56a92873154614db6719aead649e00af52fcc2f67f67db2eabfdc540d3567369142fe954240246365c15009677dc847f0489146da5cd5604d57cce41397686b4071390090b2f67b9b8504b76b7ba92afa95fc75d20c605ee7080266cb0032cb171b50cba71a383b01713c8bcc091b3faf49b4221be22b47daae039d1b531c09eae9c43e1b3f1940ae20d01ac364970a7645ca120ed4e7875a5bb9c44b9da72bb63337d7ab6de47346d3a274897977da506b4b6381624aa097d95ecca3bf5c874a1121d859ca5c4191735ded1b838df0fc408ac7f084cf1860e4953b19e05f951b3836581b80092194c7c56af6f97e6f8c2612251384ac8aaa0746120361e5d8b81f12f9ad9fc3c7acff0a0bbaef238584436d3abb6c35a0396c045cbd3309cc2b16dc55bde5bcf5c41351af97746a9682509466277b67138bfcc67b8886669cbc39dce6ad5d49eae0c4a3f53b289909c3dcc8b08f7595de13a11714dced167453c2cbd64cce3e62d291b626b717ccc3d06d7687b07656558ccb3950771b0ca4742a64f2f961c6bf65dcb63a417657c6bbd044d82dc71790d7c669a318e81a30c95df31dadaea67df8aa90767fc36db91192410e2bcbf06cafec75a51434562388c52f725f710a34e5a3b6074e47b8b2074f3245fdc47947cefacedd9d38cb388d50f0e16427a2df0257d0d4962edbcb0b6d6d44a4bccfd28b8f7e4a7a2571097431221ad0d6513422185902c828f981414fc553f31d6da71e56d610fd88de6894f0d2fe55a875106e3686cda4a413595ccde20872afd43744b10bc423b98fc5c85283f9df761bdd9b981aa38ac7d1a216fcbf569b9d3be314fd91d6164df096328806a106330b3b48abf061268e63231750975dba8207a9beebdefc80724ea8ba384b18788b7aec999054ff4e19f49c49476fa457a5f83910173ffc29e18c3ed4de506120022e22e486552fd939d86408680c8309c366239238d53f8f558796f9a5812da5c551878165c3bff81579d371ecfc0c8a4e6301788074d1ad69659032c166ca95184a28aa82b1c18223ea4dbe2a1f9da4a35cf97167835c3597e8e4d77e7e326711cb6782bfc484b4509d270d2d51d5ae8e6532c84f36e65f0cdf7e61d8a24ca093367f44cefc0a08292eb1ee9c47eea7f1a50cf1129d63a6fe3c3b1d8d774562e12668f380caa7cf99d0f1bd27b64681e2b5f147cdac14b4cfbe8744147ac3d362a085b4a77bdc35322bc6ce250c12821dc0b673c07667ce466f2eabfc5b38b55283db5fe350ad39033839685bf61e21cfa4f692f773d58da0b82f7b5bff7ee4a1afcec34773d9df6f4e5a0c66d92ea7302a1481ac0c6bd57dcf7d5fff2aa80688ef555b2e34350ee3a60b6fab98ff2fa90d014e583c6f8ed31a4afffe8eeb11ec48bb50a9116b974f831e37debaf0bbdda3b2aab05cad25f68755c4cf2bde2f883f4db48193cc755015b2a28cf18e1f38f45cfda322a1eaecd0367a379dde36a4ff347992fb557e11634fe1607e69471f068ec784017bd3ca0cc67e758858702aa92538a0ca129d98d3a334b806f95644a23c243cd54e77321870c07318c64391c733b0fa8a570b65389be881aec7a4e6c91099d95c6c1d2bae2e55afbbd7f9f05c41a49adf5928c58ad35e652abf1fdf079a690ad92af61d7d784319a9b09294c1910bd886cdb4b0741c01c72a29004426079b2babb73db31244fbfe4ac86619046ae988df3ed209dad376873e8c46e0f0e22a0ff3239045dfb1aa526dcfe87fa3e748211a4e25f302ca06120b31572775d445a4148e2111b9b4a20f3596a99d1eda2f6e59f690bd1fd3008d1b326e6fe2b2fd1d1ec5699d0cb40844eb9b01367844da4c3d8e272671e702a5db73a56806b3f2efad44b1a97149b8f08e29ad7a915f30ea98e9148f5e60ebef49649f6dec41e8a12b2f6a2bb1af12acc24c27efea1af407c8c00b0f97d368c2aaf4fe0976d81ebd4b0a45d59ec9d767c9efdc2a2352ece777c091fa4a848a136861da9d9af5956504bd715df0400e5ba7b663eca28c622fc617b1aa3170f800c54ad85eb9e44639f4d7f2f8be3f8f54eedbb527e8360505e93b9470ce6daf39b9efd2a5ff965942070269b5170ee0edde4852677b1d91afecdb4758b582e2bf5e3733eeacbdaca323382aef219953eb68ef9cd5fd997c0c87e766711f14670b7429862063d113874e4d73745c2c9790411ac8198bd0efc84010c4920f08735ce0f5456658923271ec16e7e57995e993fce26f9b290d5cd31017c8ef763a3e257e3314d37a52c4f79b3cbadd92f490e7eefa445572f64fe171ef06012a3f1f2e63d90059c2c4a1975dca81ebe2cc7e9aab66b1ba178b3b31f68c6cc48f272a856c08204b6e2772fdd1c372389e71bf52f41bbaac0bbbd71267ed6d294176dd2c4ff3d9cdeb4c8c9550ff9d489bd8e696ea46cfa0e910bca5c0e00f83b0b9bc4a73016cdfe38bed26ee6b3f9d5f9ad05f2325b15f2a7ad4f621c00032295424ef2d4df472d24706405e978a6b1875a4b32fae7ff60c3d58d3674d033a93ee135f856d2ffeeb644cb08600c7c7fd6be8b26a2fefe0673756af62250e6a6f0d09a29d870ea2ffea68babd49446e6e0cde728ae46c52de68ee590ccc1255c94463c2ca14a0cf5bbc2d7c7a4b7fe059be04bf07fad5fc4ae2e7e12e27ac5cc16dd0e68be84f276c9535f063c5fdf6c507dec038e308665f1533182ae0117f8e0b5387ccd44d64ebdcb9b8934609079f8ef63f449fb2aa189fef54fdc93da35c138f6eab315cde05fbbdad070793023db16a24ffc82220038676eedffc0a110a1c9288c0e78d941b5fd86fa1726db96893c2938ff53fde740edee853df4b1a425b6da25fd5ff4c89d36aca5f10a7a86e0c4eb20d322da10c297a1422489f80ed97c696b415edc35f09a7a70ff70bbdc2c4081d2dc1b3e3b5e2f23f3986445213fbdd194bc8bbe26984d4de3d9bc31ac66d105371ba680f9735317210cb728d070ab5c90ddac89d3c2242db134c67e02c98855153d11db72cef1f588d53761f0b23b7bc7e79845875422ca7267eb3789de3508fe4c5fc42bccbbce3b8624d062bf44f69cb9a36ad4b4aa18b19387e782d1d0bd99ee9a4658a683b8c9fc83ebb79b0ff3b19fa6b74bf22dff7c755f1728c41a8d4aa91f31c498ff735cf860e92ca96ee4d8b91ed489436a5f4b1c18340d10b709c561aa1032728a514d8b53ca1de4d6045af4284183001e04419642b51ccfc85181c4ff021ef95ff31c33ab07751864eae608e54d0fbd2faa2d3d23d6c0139e9a2e254f79d8ed4273233fdbec4eac98b1353dfdc5ff6bb2564fb42199c1102e8e717df43ad1283d07a9d3611a389bd862d834833f9bb55a3ba8a8e1f79925e1e0a4985384c6e944e8cdfbe7d0ccdf51ebc88aa75cdd61705559af5dc0429480308d9d2edfa9337e1ece8722be54b7faa1830e09e5a16478115e458f624be324b9c31fe597e418d522ac789c4665f5a46e2810e10150aa9ce916205756ea8bd1e67dc15d2454bfd47ca2912da9065a8a7c989f4dee06e8dfb370ff1024b3f3b75c4ff22e49e37532e473f8b1bdc55435a11983cb3a0e9ded204ca5d0cb48bc29b4a1200b186d6b017389ecf4d13fa6fb139e1c72439080ad7cdc6c4c8a3b57cd98bd630a7edd244235332d14a4e3f4549f91576a85669cd93918ca9c651e5d88f39dd997a8264522d0f82ff1abfab2deb2b002e86fa0db60bcd3c0843b80b0beaab4ed2b4c2928a4b8bfde52fe05daf921d44d7e56580f1e9953ba7c3bcad344fe4a1c16d8b0f4baba71fc4a6ac991838518e2bb4b491d673e7b7b853dfb287e43d516aadf6e35ecdb1468ad7b0f479b803b621182599d914942d979bd059c27caa5997cf7f8ade9353a799a14a8c9ce4b1c99bdea8781a996f8bfb4ee2eca967df6680eefb7f5f9804ab0747cdcfdba1d10927735c421429366dea8fc64d3cf5cfe92133d929e7ccc2a6e6f24008310daffec028588fa5ccaea2970bac76e6254faaa8105da0d485c643398d183c52a0be7eec558fe5b261ee8988c7604bfa94974490eb13da5924ff5a452e3d0969860abc3783d8cd1f7e0e57a89c0ff3cd77006df4be0383459cdae4d0f482484a3933e2530f3318ad94630ad9389e93072786b939be91666987b0479117d1ec61fbaefaceab16a5408b1fcbe53dd80cb89a59ea09468bd8ec90dd2fee5d051d8cdd9195c863f47a57709cf6f887d58d2a34625c41cf9717f8e0eed3b9ce8c58c93594cfd1118c81d8537953cb014af1f025a88716edf402f4b7775d13925ed8f0c3b91e4d4be3b5bd25323cd218fd9ef8d6d87cdf569da93980923713f5edc5a11c846099ea42baf0db1e15edf9141761626e354e139f5e1d55baa0e9ff791940fc9d94cb1ed8ff5dfb4fcb4985feae467d61ecf5e762c46b5fe0ae64b7399271461bf38c3d1e3a7f1fa7a3ac9317687e830fd4dd8d36982334f06e25d0b4e3d1889922e872a655a2a886874c1650e15d29831057f17e208f20d4b774abea0b84e4d1e87262d1cb204a0a120af247117d0dc637dfca53f0869ef2e35a595931e3d7f02c5d4bff7792f4987583f82ca0d155ed662b35f91a7b816102f8caa431e6a57c161cac73d2eeed40e0f464e44ee00b3324ca7f142495bc81707851bbcd7db369d77bda6601b03fb237a87ea6986d693964294eb6203b2f2a212b71887e26f19211668a32e093cc73f4a950b7a0ca1b2e3473ce129074dfaf7a972e9f3db8e00515d906c1a4fac7fbc8d035fa2c6517fd55af8fe64342bf68822ff127f53632e9d0a548e5d10c555cf75908516bcfb6e3794fc9587269e55fb17bc88c724207fd62f0d03fe79834ef148363c9f185897a5e4ee070b346f8e363d2345f3714e2018e3dcc249d06dd6cb5f11ab5f8b2ffc9773fe984c08b368222466076198ea9359c3868faf431c752bc1e4732bd4e92286bdba8bc1716e68be5500eef239cc8071ddde2d6c0e12a0ede1af2b9c41d75e475a1c3d51c5af3142664147e8823e2715f38448ecb0d09bffbf4b064313e8de6d0da22c59021ebc773a6a3f3fcc2bfbd46d447bd18fa4c0d9def41fcd080b01df0fb323410538eff7431f84ed0d6954684eff487e319baf7ace475123c4e941a7bde8eceb6573eb0ff50b068fc3c4382fd4b29e40c8377f6e9845dd843fc9ca69fefaa70674100ca7cc6e5459bf76ac6b2f1456eae6433f76567bcc6623597d4939826f1637c55d7b6c067345c266195c80f312174d98b3894890a3043b5f3a4fe24b1e6f977a148822cefa58a09cdfc01e30685bdc10bbc74ce628136c3c22dd447bc7c504033c4576121dd1fa14e6b184d60a893237941b45ae05a717f43e35d0c5ca7cda9401ec863623940d6f5c39fb71337556c9deb432af8a0c41431f77bddc39969cfd3f238f7c1a345cc5b0f65c489e77a10691761c6d55dde325d8c28354d7f43bbbe2802153c3f912073e24109a2e029c21af7d93cc6f05e74e50f7d6c19ecf87a5ebcf8ed3cd3febebb01c9817eca6859423c914d070b039cf46acef55404862911c771cce974c0e65bf680b4bc824a0ac8a5ad9c4201a295d4e90e07b12a2835ebdb63e71b91897a02e8587b3fc68f8d96297b3d29ac1e8527b97d5d1f3faadf1a327941cc233a98cf5a16ae5bc3e76a6b74bb840d442ba5261215ddfbb4cf99a2b87bfb9054ba151291af45c1d8b1c661d64df86ebb6b4a33fde7cbc748a2e1f4f5d662faadf6b013260516f1774918b557ba84f42dacf4b2bf5233e9a5677ae8017487b0a0a772998cb445abf31315e78fb37deb5d83684a6906614b92e43dc0fac9a13ed51cf7c3b39f5aa2a7d1720c70cc0bf0e0e84abb8bfb561684fd1ad8436e1e96d3b226ae974498717430d4fb691a32f1f63be3d30c4e8ad1f0a9021df1e6e39f3d7ca881ca11035167f241d06f36d17baa9dea0e517e6aca291509bc2d5baa0ca319194c7fb3b3458b7bd77554870cd63d57e9c8c82abe1ef24298976db370423c1b01437f293eb0cd530b968d35935dacaf0d46e926262f8b63bd727ed259a83cf5418898b9e23d9de1d691547857f3f56967e04c8f1b6a49772407b41e27750f8656710d03445ea4cad0b6ca26dc88dbcb515a052e14d55fc57f66bd1634a14f0d4bc3f135015b67894c66673bbb8e32b53103910ca138a1abbc704402a71f2e6427dd18effcdd76b5bddb39f03f9df3c03f943bc988ecf8b9b640faa2b8c6cab3aaa37093498cd9ca001560f1a049aa29ec4ec60b65523f75642f22f69cd9e1139fdc398ad8e96637c334f0ff006e1539c6b39480f9e71490c68643e003a733654d57224073d04e90ca64804f53f1615d29f6f9a23a0359123ccf5a0e60c68b20fefc329c3b24118387cc4c006b0ee6d0ccc8e389fd6c6421c708fae5d0ae7e6217492d61ecde93a7aa4f8cc77ffafd8148839162a0ad5905e0cd00ca9c55446c1514bc5932d81abaf04b6158031b83c51582ec2991d93e0fe0c0d23346fd64a89d584b0c6a6e01454d95fc0191b32536c7714349a85862002f73eddc555d20eceb83905c96fa03bd1d4b5170838a0728d241888f363ab9241e81c8a7e490f62bbf630c39d43944561785e840fc2a583df197225f452619cd671b54b3693cef8f3927ceb541d822acdd0fb2b41a478f796a92b3797b9f615a996e8b669335620123c2fd41b97b7c750fb325decaa21448b9499e2596fa628e6ce2ca55123b19639bf8eb2008c6ee8485e707af25b3e458c0ff67b389c09d3af7d1ea9d9ce0cca6d71646f96731a5be46dd120befb22eea08930ab5df7e3c0a1e7df532f29f650178f98d19cfc0fbee8a1429bc38a22ee5ca903f7faecc5b0007b6a8db4c84a6bdb16d6271e661c70d7e7fcc1d848e171934e7b807bddcc6b5fcecff174605a50b62c68ef1b0c245d64ff0d3d1edd5ec5ae1e3c8a18448c415be9a9103584b2085c00fc775c08e15b9019157c515c2718328c6350e75080ea4883ed29e69fffd94a27f23f0f29fddcd07a379a94c768a2f4348938277fb836dbc3c374ca0a8a44629de69424f8c3d919eabd9309aa8d8ee67b366849194068d2d42ea7983d9a0b76ff6f1c6834bfc105ab998d6af8f2e885075e2a473240ab6bd7ebb680809b2278b30b0299e73d036470a40d10f86f7b7a8df5ed367d7a10b4d1bc7342d06ab009eafb0e048f8adfd75b3e62e33b33f2028f5d74f09643fc7692c9158e92c04787a5f3d60de40c284a71474294e60b8c6ca4d69ac09a2f62161a567bf2e9f32e02e0e95da662cb9c69d0505d891babf4ec7fa08231ec93bda7155dd24d9db7371392484fe4a317b3d432b3fc488975fcbad56ba4a485d8adbe056f0f30538fe8eb0f8036becf7653493e1b0094cbec9a4ecf0b64d19f13d43d17964141876c83f78b5a4a3babd43d89b929c7ed850a2b0d99541e2cea06199c4a16c83187011643b67dffce57c833848940595e2495a889ae94bc4f28fec984f7fcc13b1adcf9e85d455f3773d4dba80ee4052c3fe23aa944c0352cb0dbcefc639edd5a630851f6d8046ea7f33fb9a8fb5067de47540b15db5efcc309ededba2a055895c2fd97002634c16a8fb55e8d0192cc0ebbf3525465ea2bbd7c6bf2dec58e09694d1acbf3ca778a5aaf355889fed1ceeb967f86eaeb05279f9a53ef1859c5e50d25b88dbe9d3a1960e13e21788e0805101a8a48a6296ec2c8a00c8ee841a65a96bc5cd0a1bf42d20235691c4fb0ea77ee2ac299b9c19772d40f85e8b5ff15b8e0924183f01b9e3979f38f09246956ad9f5f18043d46c1568b83dfa670bd4e42847560ff70f5b6d559ab36d7f7c6140bd0baf189c3e41bbc6dd070de5fca46455674732fa264a726b63b37645546206108462eea44bc11b33deb081c484c18f8fb686a7b5ddb5b520e39ab9cbaba61b5060c31ad1dc9ba9285190062fbfdea2c22ad01abb51c18f3f3849ae56da544e626f550394eed6f67a8f3c068465bef17f844d8b7a4927c8a704b4c9eca49c9b443b6af3d9d955bfd0a47599df90a75ee746e797b735b42380a4c8bba2ce259883ce43d77598d322ef6c58fd04058cb181f53faf80fad067a4bc4381ffdc13d24fc10b853007bebb804d46a9739622aa325f6a71197256aead7ddaf8ea1207e4e66722cff9444f5e2b25f659d84046594b866ccf0d8a479220f117b9f7bfc5631eb4dd898276c2b104484337ee1d471a72964259f37edced2234bae2fe525e6718d9c04735c7ed5e565a3611d03108dcec95b4b7cf1551db224969df9a7a0cf1e9426c99a95e5891899f58246b39d38704f088bc9da847eb72314b5316cdcf4e7fefd4302d3cfb87716020e9f752627b52c5a91e24af93974296d66b594bf34ae16d87d75db623e27eb9d7d7516c5e736044fad12e99cd03726d01a5dc0779ec1106138d645342094546b4fa0ea9cf92f4f2d8d856093e4ddcbed1134fbb4fd4b6e0a3687f47933359e1a3b93927380077fddc16d84c067ed307b57e9848d6c50b8d0895bb2179f4ba61d114d614cd0fb2dc3f6c03e79e8b6b3115055d746419f08ca08e3c22e1d473b46bfc99582252ff52eac1914589faa8535ac0d2e0613e3aa906fc20cb641ed62117fa014acbd924bbfe2f86b18259d2e3c101e555850b1d33191a66331adce1f3978664fac8306ea38519da5b68413a50307c7c7d78a6c9ba9a345510938f5260b1aa4674df7e31beb92f653b3ce3bc29cd5bd96c0ba08e798fbc58e71f87846753dff526e111f934fccea994a670218743d1d7ed4afa5acbedbc842ff29c2feb72e3ee3d08e6c85b4a2743e45022b5fe9fdd0cbc25913db37aa5845aa75de78718d7ef49b020fcca33ad2d325b562264b14dd31a3c8c72ea74d381c08233816dac5a1d81cfc976e7252535e0d3d5eed8d0f890dc0b037479c58af74f489d3e0b62ae5f2bb6721d817f3182a832af2ea3573037cb405c208f74e0164d5630fea545bb0808265f224f00cf0b91e0fb6210f93488c0783aeb7989e09a5c1fe429ffe263623dedb2766e23e1f4ae61401c59e60cb9fea6dd3ab26a60e4625c7260fec886467c3ab48d98754524c022a6ec3d4a83a07a0a11f32965e6e006356f133f2ec77ea77c774e0e4d0a01629e99d1d32722d9f20842a8109738745c7cc051b8643e344c6e7e27befb51acbd974535d1fec96527f9785da3214149c1b814bc544235f437c6c76287ea05380a676b7fd03b428a0ccc84294afef3fb3e672e726264be1fc4f3a71a10f2953e2adf5b0971c50fd12f5abb0630238e040a8daafa0513c93ba2e3320a782769c55cbf564c488d5eee7c68f01cf216ac60062efe57880f6a0be016d3aaef96f46ade970bfb25bbb97e207b5463d2f56acff409cb07f0b1e19bcf9b05866d85a2dee410184c50b1d70740c87293c95c59e2bfb828939ebd7f3cb77801f5724f6be5efd9eccf4f6137360d6c30e30d39b5cbd7b9f41b4769a9cce34c5dc3983ede6046fe02b76d81a5b104c3a88443db725938354617ea5c3e4ec9d4b1a8c2e977c07e5182d08ebb967b41bdf5b3b34ea45bd0f97bba28b0495da5dcfe30130fdf17d4b85fe8615ceb6501b78b35e9aac93e159447ec71f267f4e759c82be7a7020c38fe0fd1e958dae336f838554301050b570a409d46b0d93c0384754e21f595ad0f404dc33f326f4436227db347cca5a8462d18dcd5c468805c0cc82e1ad6a791a2628527deb31f1df59317aa57b64e2434fd962fbc233057c30eb53653dde275f93fae120d2b193fef4cdef2046ab81f9e5c03336a14ade93c993f358c0d100fb4f54a7e3e76e9a1f8b08010fe31167acdf3d11b89a1b0582fb9482e557d60afb19a3388e4a3882fe97e41b3f9b9554c4a382e171ac600acea5f92a85e57584c0ab885ab387454ba1cf12c5b5b0433923980cd8c7d6c0b9b9b055356534b4192d5ed6d443746e33cf0c81109bbbc185b359643ca3208fbee2698a7846e839d35b5461efdc3833f05db3c81d34352ed31b0d4db33e7a5759c84e94acf64fd22155cc7e245fe9df182c3d69262834858406df7bca120d64272e08a63d39a354a2d3a0cd3461cbd0d2eb27712b33e40275fee3ee65c96b075319a367965de9cd7954c5d62d2af7353db916fc183ebbc0166d7e4c8d0d246fddaa52ddfbd579693a6a70d2d8e45d6d91b45cea29fa50c82a823dadc472c288abcc2f248567008f4281d0e4d20b337d0e204f2f19df6936368b825101ae65540e28ea0fb4e1111a2d16b7c875629b054885f7e780ce68d120141f57a912ff5b11339a85b066efe487f0df00ab5bd0d90c8b12615dabaedaf10037fd9793886622744ffb725b5b2964c603968ca33a7ca174ea67549f408581feb4f5a86386624496c9cb549c6b652ac20a296c3eae78f0cc10c7670808af728b1e3ee558a8a450195386bc90f70ea28c844fd63e23c62b1392d749983e8f9a5d3c03e2441c04c51d3a51f7806301d33bd0e64e3b3d3e0fdedfeee601a5a210f866047addfbce603f92b46dd0a98d40e3b1ec855f1f9b6797c393ebc0457b3b32f64f207c1d111ba428461d46a3e5b3221681196c28fe002ffb066e45452913d03fde881519e4ea1aa29f7b7aa9172cfcbec149a838dce46e3b0356b8229d9d4c9b951e30de073481e65d791a0a6483cd24c1cd02003252d63a2c80d9e7b3d0c4b1ea647ad5a74027f6ba2c57a79cff8bb789d9c4ce451a70407adf9fdf53d39e0fafeaa76f49f0d29ac61d5e931881e31c3accfd51f41fa4260d68bc1f5ebc8c0d820edad6251d84b07c28a6c61da59c0814874e2df3cb6f7f2b2aaa908f888b48315a227da4ee8e1668fac260d2c1d71222c42e890e7afb04f1236ab73f563f53633711bbb2e741b23644515b2be6f6325be354ecd3e769195ae3f8629e26572637b3db0dac003462cef2db008b18d3c4a399646f80175b87b83184b7f3e2acd8bcf7af63c136d2b2e57648b6ec294405121eda19d5f0600db2c6574ffd05220a7aed9bcfd8742f8921c50a36d9038d1364d847fc29ed9b63b7231ff3702d380f07fca9034ac4aa6dd4d49d70f0e0b4f563af8398c788226b3d8381bfaea56236296504ad94aff6d852e593595bc3622ba52f141cb6f6439c6790398e3f68aab0c91669e54fa672d4b21a1be42eddf9bd22b0680e60cc4b116925e4620ff311eecd694b5314b0922953449adfbbe0742d8098c7d10bec8e821c04817fbb691901a05a3f68f13915642121ef6bd0531bda438036994cf8de5b7445e16c72d8bf2bfc2ad32e8f6df61ee1be21ee43b19a009f212ac9577923c1fe69920cffd4baae00ddbfb7da3141478ad9a9000b0413f2f184ca4b882a77e0d11cc81889c9d9d779e6d5f35f09f74eaa902949b6f324ce265c3c141b6cf608469ddee84cf4b522338df04bec4f29887d4cf29783f1c5d9de2c349d5a9a021e26fbaffe507fd47085a924251a1eb6bf79fd22f5cf4c2d6fde9c685f4a456792779cb214b0c87050118ac2b1115ab252fa47020f117f6d9b36bc00cdb70a9aba7456b8d86b195e2c0a95b9fc4b900ed1f77ef38a1daad8d85f08145c159c70c4fae11d0eb97d7cfc3ba534f8fbc74ea9ab8b468803ce6f0f908df1456287dc818143fa3d9d15714472aa7aba35ef8dca436dee317ec16790e6a0ca3e96f7053be75b2f4579368043881b797955fa062e5bea6244cf63b358891e114de04468ed5f15217587e85874be0d245d2bd20ff4cb8fe52b9d95c1a711834d1edbe85500b2190b95225e9b738cff67393074252437c5cacc2635acfbe4637760f40b065ce464856a0a20eaca32580e79879d1dd0fdbb7e3f4e0a1fb2c5e848226923d6efed91c33ef5d6dd3076c84dd2890bbc38162691515c62d7ea3dd8e952c33845800f277ad30ad2e0b02fc3d5f12852a500d64ba5523a60462feb67b0cb1f3352807bb5957c92db6c96e5ff127e3b1ca83629848ac9864c61781e0a415f6828619b26767fa0cadc9a5a5a6c9b8a7fe370a3b9034cb1bcf563b439c77fe0533b849470d804591eb70ca1f511731ed3d16398913c6670e4dbc0f3b1947957de46bd0b86eb72181cf5b3f239f27ef98d8d45c9f1fe64ed1d4843f161175045062f95e38cac509218e4e51e6674c6760ea4600bafe38558549b5f52b6434ee428d392c075fa21e2813f1c51d115f93101e6abdd6d0fd0e077c5a1fed5fa55def1dfeef8f354a067a9f3c88ff32f6cee0ebb791e09b68f58fc844ebef994bc12a16ca358c66623a4df29cec5dc3dd097bcaf0aa053816028b6aadae8a4f0fe2aa9455698aa5ba1f4e0ceec6daa7fffdf059cb7a7b290290fae3030402cce73f87ed499cb8f0a5480fdac3fca7fb61a447143c6bc4f72f53f34c0681d479fc05aefeef5f51f1e6464b27cbf359449b819954928864fbbedbf4d41d6488068afbb90847ae878fb246a0f47149e35ca1d93d159254b8765bfcdc3fecf76ef3dcdc942a093bd7edb4828416db44bd1a6c92aaf000354a2a963652911b4ee7d1d8ac92658fce77b8da675ba8690d03690a7fcb9c60c66953d9916e42f88f27cec118101f5d25cab046a2aea12294c9a2de3f13ddfcdd48257e13e175299bb36c53e8841fa9087976e22aea2f31cf8f45b3a9c18cdcc5d669f64f24cadcd1706ffec8c225993ca670395600d4eb42cdb28caebcb6407c9b7fe7e323ff9aabfb42a3944e21a8aa63a430497f4f7e195b04fcd6614c070f8c0342bc62350702b020e3a84fcf4b7f8ac3c101bc54ddde121e4bbd1b0c274610b6210b87804f5f85045253dd98809cad456b4ebe91d9cafbb03cfec55d69edf09a9e54136539d992be33a18e4894a904d042a51f95d585a4c08d1d0a11f3808fe818bce24dc932a403348c20e0f1a062f5a1929573a1fedef4ba042d2d8d38d7f27947a42ac35d139f4245c3941fdee4bde890a50ebc75ab79697e6e01c41453e3154079eaceb786dcee9fc83801c99623db2a58a33ad58cc494da3f4f92a5347191eb2948be3c16b9b2d819bf9c5b31922c2486a5e0c4afa45de3ed703a73662468656fbcbed7dd2b8666ff46a58dd2a5ef07890aa203c5905f061e2e18319c5a0aeb4017aad7e47f48fcb2d18f2f60b6cbd15899090055bba9887483a16dfc4d8da3d800ea1c5ea90ddad6aba65b0ed5d8bf0aa46f9f4b35497d1b5c582a66ddbf3fda18addecf3239e54c8202961cebb61f59cb6814f48880d5939e390bb9edf0a7b8eb223689324455c3c8e5f88d8d6bd2fbf717923d41c4aa46d75df297ae235fb003a9304021f624ca523bfc3115ca68b2ad99eb92e8eae39696243fd64692a92b114090e34850ebcbe55859373577b80e7cfcd1ee1c37923ee82bb225fd9be11ff3d92590e44940c550a89e430029b74b5da71a4dba6888d27182050b84189237e5791fc21e49ed5b712af79e8be51aa9f24c5eb69e4d2786eb85faa70d32e63d00762c3c43c3db6375d829318025eeefc01b634d600efa6680f6877838590228eedafe803360b0c68ff297c1a58bb9d6189e01b895b749292953c9dec04764e496567cf5b9ef16ebd2aec5db8f7d5835d51277c294586b1247436c405ebea7eddfbadb9eac0426f88369535a36a444b516a58679bb4d0009facf3474372f3157445f80eb4b02fe6cd8417a5b4187ab36d4852fb110a8bbb52ef2c46da52fd111c4f0c5e8016f1db6c2603b9c3340a38c862b40e0aaffc9d00bc497fd496410c1c29012aa82a00b6cb76e8edcac0a7aaa40461e538e481e0639eb0da531f2d9d49f9b9aae139c02f4e75d885837d7522e8b496d811e110023c0f3c92e1c7f62b390747a8b47cce8cca614dbe717a138318094f4663523fd3831d24badf149e335afbadc5874a460e5c420aa55fb6523fc5d718ab691f6a029b0ec842116138c2ed013d662cc5f077b1daadfc7602026c57fc8d5f4d4298dad04539bbdf0067520a2421da83af830a1219a50811ee7f335acd876cd397338842244b666e7e62c7973b9c466e76d0b58f22863d48251f727a0751936eaa35f8b8503844e4b5f16cf78e76030bce05275b64ef466a70e1faa83dc526a7410cb7fcfc495aeaa80b3fc949d32809817bd18844f0669b6c1646510bf628df7d7d5093a66f6ce2f0a58d7791fd378899d1cee5293c48a7b1bef8edb0cdb65f83508b2d6367271a44d24e37a8678e2001e4e83a38555aca37aa2b7cc70e7cf8c407b6f36e9baec83e9d9240a91f0e10a2593706b00b7555d68b7bbee02e868bafc6cc0ef5c4bd2f75fe9c7af0d47e339d094caa180ce9c472c829ad94a69f499e12541dffc818ff0f3da49beec8d62ccfc136f8972b8a6a491b22f133440f17a8d81fd4888087e36a7a7a46a9a0d79f0d1e01e5da37d06803b1c19b4f7c917e4b6a0b04cf491ffc80a0d0fb6e28981648b0ab7be1aa84a15cd78e163d106da5a54857523601c2a6435af82af439d7737712832483e7d235189c566912da68760700d6b6a7cb226396d5141dfe4b9dc4d961b84acc5ea423e4d0fafe5a6ce32b48aedc1891180b72a4b511953a36d38bd4782dd2d73391e951716b932a0d35316a5bfb562a3d9843028d3c19ebd027fb54782fceaee3a9b2a168bc547393679de87e529f37eddea75ca594319999bfe01d7b9ee8730956759a19b2f2cf7e40f697568b9d38aece66b519f82b3282fc892441daa739f89adeabe09aae19c0b73067022d7e5b2ce74397b7ebd43eb3ee3fd7c5cd1b33f137032dec27905c6f7dd53c3ab816eee55a683655322926f355ab74e9b3674bcc3d7089a376529ccbc3aa4659fe1596fa0f6cf9c3ad6b8ab8526ebb143fe33d894b817e3a33d8bf72d74442bd70281f7d5d849734db554051f132c5cdff50a1925a08680c0a4db5ae920af501c582d803f5dc77d65c28baf6dda8a804c532ee0d0d4c1c1e315747c025969b18666d6e108c6a879f18a73f9bf62ba625450c6dc4122abd7a7b65fa4c5b061913424b8ddb6caf0019cfa1dd4feb914a4f1db2ea9e4b95abec802a9de45192cc0c6199b9bd38532d2626f1c57e649dde48184d3ac28ed4ef50b8ee26610829705f3109aa990d1b51e5ca9e9336ecae153cb91ab84b73f2f0d5faf2a3afd9125eab4d9963babbd0116c9666e50fb672041c6cea9832d09748ed9199c5af6e57e579c43d2af34da386ebc4e350fece5763a88c75c7d5470b9ec42b6e33457f394d587c113738d985467dcf94cb93f7fce1c7869c0944081b2963d7452a703f3447aafec518421d9127d70c50c78020c6c4968d3c7b6cef5f9dda597404f2005214c60391b5fca84f098d8f012fcb798a1b272fe07ae123df4785e43f06f2f74c8f208707b272add6f1ad8c5abb3627e3f85da9d6a84eea106c0fadc4322c343f4a3e7ff06e54b7f8e21097662f2f6ee6ad2b26f3a51d6c4bb8749bbef7faad1b9f7e2ffb905cb2b0940fecfe2af882bdf58f6be864425cf2be36cc5be1c2a92a77b36497f5f2cd05f5208aefd8ec2155f3155bf7ac421a14d48394375e32437885a1ebb124f2fe3acadd748ef6619363b54755185ceb06a857f8dabc05848bc7e85979210bcf2c0e78ed38f239bb6a58cdb9a80533be12cd78990c18a1be4fa59021f214986a23e012224926c731e5aa7c1773bae450242307b05ba0ceb7cfd12852ab90f2eb1fbb120f183876a4e03d844fd6dce895d881d830834819f9bdc6bbdf6afe6844900b7603cbc5bba06bc31fdd2c8e228d5e9dec09284647d8f95034185226a35690fa957539a2b3f02f225d379109137afb9dc0e0f6b5a82ec19af7366cb1a4bfea32bcb7991551a6a207840c406ba3368db77beb3027a5157f000a709a2a634d25e80f6ab5683c30ad91bf061b0de87eeca6d703bdb19c8091152cae1c6875e22a84468a11594b8c39a3d048797b0086c22eed0ae45e8a7523bafe0b344d0831345628e930d07b4b3350f627ddb8acb6446ac9840eaafe02a6d73c0dcc0ffbaf4d41dc65a65bec1948fc2c3889f89cea8b7bd5851bcf3f1e4f5b74352900ce0e606d7fbb9bf753c81876eac76f80e52ad3ac627688e73da79e2fe2c55e55ddfa9ed8bff2552f5756663c665b8b0938a193a3803cf49e70752b44eb23b8cac0bb7a860e35a7a33d4a809497701af015f2b4e47f2f923c9c7d8aaca3c91022c1f85bc3a8add57e45d1774897a9cbee295fc9981ac684d17ce34b8f208442131a6291c0443728759fcdecd0eddd9d0b1e317d1ea61fda613b3993025b77b5f737f9dee6b5c4574e5d47cda6f57c5adacd4cea16a7275b64a5ac5b7396e4df6a3ad8f29d665d0e5efd79096c6b6df23682011b157d0843ec8247b52cfff556382c0efbfc8a54b8ae7a53b4b4182245ffe2da6113c0ccde268848e49e452914d74158df3d313277c06a70c32a116cdd0e3e49210f4419e7e6e574febdb6b27ee6b50686c87499f1478eaa3b64f77da7c0c1e36fd3831da7b392713b1b76f2aa4f31e0665f85e0580eb73da4f1615dbb4d421458437eb672ab669f482968a7013ccc5630667d41ad6cbcba27960f78b6d3b6a1aceb58ecab2fed288f8590b13b5a8bf552d08746f7de66728c47c88c7f12286731f01157e8acff31022926c6e4595f4785559824003835edbc2907244093bc60f617b008c0316080c987862dc501780322d50639e5a2cd9d83aca9ae61fa3e368f9e19d27355c19afc7a6c98299ce6b85ab9e9b708e9abf2eafd27493b5568edcd23d87f6fae528571f89c4b78c44a9fdf95f84bb186591ae9ea1f6215a2f45ff3b2330f2460154eb635b4043a859e43d9277c959adcda2373b0d816438dc16d7797f5d71f16f8e34de2fade57f7fa1ebd6a594d4afffc51b64e1b76ab1918bee107ee4c684697d5a20e9cdd4739eacc72c51c9b86180e49845dc114dc29c4253c36a11681231f0a48cbf3acba18320571b7fb87a379a399b6f3cae239305667d540f8cf181a49be1100bd2d4c1a95827e7d4ebd447898963ba1f782666db60a438143f82226bb26bf0bc5d18a29daf445b9ec4d2d7c5c9a2335adcfeff4021c3a7e1ee2a157e3e00bb4d90896f663a1403180bf439925ec94825cd8c05ff1851c227f4c6a0da1a4ac60a3b67669cdbd08bb6ea895c84e8f22676751eebad627885aac83b7a6ad37b4fa3aabf1e9e389484077db0342399370db15d26e12dbe081566ec794b40f45fc4fd6d16b6d589de7e0d3f2d652faae455420943d5e7aa5429ceb7eda060415dbc5f887cf8d8981d55428cc2e38c9de0208f43eac2fbf0bb6d92a1580fbcda53f38d0865bf9f90079f65ef991349d045adc00a5c00a47086e763b99826f62f4e878fe432f781bc1d2a5bd296d20286d57e5e078299f3d234d447aa3e3d56c9ec508c7371646070294395480f21920ac2cb66053454adc087ad7c077b39ffeceb7457228a6b7e6b05852a6cb4e4991087f914ff330dbc7fdee02c04ec0c99dc4030e78b0d153b1318afa46c8df28dcf708f8b36527627a37b19843662918c3be761b7f6fe26313bb9e6fa76fce522a1d426750b1d0a9be8f19b10ea34397bf4f8174b3b03b9cad96f1ccc40a01c85ffa788a4fa4504c2896cf0cc1401d0b5c1188451c29055a1882273463ecef08ce7e9ca718a5c27deaa891af00df225e0e9e5ac48e12d51802441ef32e41c5bf2554ce3c5b4ea7200401519482260d8d3562812794982c4229d09a25f2f429022794bea27538a97c334bf8fdd763967794cbb3b5086788848fa854120bbb2912ec1c75d0fa64b06518b2c2fe289556b83d77b5fa42c8d8943896ef89f00d75e07c126a68e6b9e06435e6f58a30301f3bb1d12002aebf1da21257581294a5bdc07e4275e726be2b8ee7ed1970e31006bd29f53b40ac7066cc00f07f765054e586beb489ff391f40de73ede5014f4ed5abf1021b6923f284da3b3fd1260e74ee7783807adc388078569a22193d3464794c7cd36f9b6ef129c6735b5224237343a957885d8c8a1c4c1151d260a8f5a5e573cd00d84e6ee2a9de9d45c33cb620acb3f3e3495bc4407184266a14771cd7c922e04373faa7f70fe56182f6174428184db44e38ebe76f948d9fb24537ea85e892c4e2caca88999299edee0aef22bc63f73a1cee78e0a1fe9a37a4f7c6f7f4bae835a2c182f8031ef6917f5a1a09f7d09e50415170365ac5f0e9942c90bc02e82a57a252fe2b3417336f05e81f89f6a39ba37d3554d926bdba1e20758411dbd61038111d5f6d651ecb8556cfe9cee93654bdc0b874521a2f370479abee5b8e0f4a1c7c663bd4f890702cfc1f4645854571a5ccec25a9361eebfc9f961c9f7f85fc9352ab506d2e511e52d48b583e9c85e8b49b305bc3f9a06a14b038f4ccab4afc2a9a1a41f004e6e89b0d5db67d08b7c12551a4e17bbed8a1a055204179c95a2e987f7d73ff0bccdb5ffec96afa84123238ffa13d0da3fc00156eaaaed4072e78bdffbc9c6201e690f2d857df7d9fecd7b11f8a9c50a3fddc6bb752e5015924af57da5d54716d6d714f5f43908e5115ec4d3da240d015769c5f2521ea22e535cdbfe52e5c676c5c6b866419e76f6441dce3da4955f2e2346e5b782fe186b31df0bc87a244dd9e5176fc13b4da954c79a8ba8c17e562c78834dfc044b7825568d3577c5d949934ab610062973fa04ac519e5248391af74dca9261e453da98011cd268376cf9ad24a0d3c99a8b9551cb89b7ab22fc645f6871ae196ac6241626db25095907460572d0b03db82019f8421362c71f85aa470c278d20018d357bfe90854fb754bba37f8e92708a9d10e9cab6ff9fbc6b072546fe3a21ca419778fde5798451892bfc8eb02b579f1e1320f12566fb8bb39d5f55dad2c080aec11b3d080e789d91d334f1831e5ea0fdce71a02e73c74f4d5848712767d26ce917fd58427a5a26e9ee38af95615c584d0f681c41ac13b961cff41f9e8200c505c313f2323144c6716df31fcaaf327fa6f202b2677b5b3cfb2d7dacd1f55f8fb5af8936e6dff1dd58f7a62ce546bf02d2d549ccdad0bff87539e1385e48867af369932d93f9cfb9e6f7184cb55b8a6bdf2f562f14f5a824e9a0840f5c5f9709f85806552e1fc4826fa9b699476cb0d23c0927e6006f7435ad109ad158919d47dae8b994f6243c286e6a8ecf1f0a2958f55dd569120b5acbf70bcd45d7f2adb34034840001f0afc8d39ee004dc54007b8a0bec172d44c371ac25e79a07d5e606a42e2866cded0239a336122ba7e19db770fdcd47d109281129435b4fb763186d53ad064b922dd7fdbbb89521402957fc61e17bfce48299d0e67bfe1e3e9888d27635f8a1ad35fa4a72f736125981de46bde5b01c80efd6683b219be681f41117effe798229d28bb5897480471db7ef235a3bcc1e0de24bbb88e970c7aabeb5dd04e0602661121e273809d662017d6c31f8bce4504bb703ef91497447b7004bc63b4a83e80f074ca546afbc6fc30c6b8925d76791b1f6112900141415dfcbf13719c8af72963e63ab2e17ee1b1d3931e806c2b4480979c7fa07a0e8e5e4024a3cea22330b65b0dabc5c0b9bb00fbe9d19e28a728cbef6cbf6453731d218909892158c5b136761a68c78281d293e805d1b14a0158dcbf5c9052530e1b281f71a2fd8d67437bc82aaac50ad9358dea0e269ba1b8f4dfc61325d0092f65a995a4776eca9c6f13d4584df951d550683528bed78b58209fb030349fe819e710e9614b86476753fa8749b76bc2641c2f697bcf4f5fe80a8d8e71abc16d1a61f0efe2dd98dcdf62cb1e1738b4069ef8fc8a8f6e5ec3b36ed85c342bcfd50860fe6accd923416d43812bdf13488a936c3a0451d950f0c5a55ced3d3f3e041bb193b1bf415c6d6eb0023ada6720ba3ea203b15b7df30f66c1745f6746845cbfd3f52d789a2cd7d996810c99a6387fb23cd47e18795a45336cccefd20fe82835e5da4addc511b8882612fc94215c1b727a9fae1609e9844ab80922996aa7945e837e56d00184d3c57fbab5867cfe9a756ee683b5fc15a1c2b5b5eb012e223778324e1b8e8738473f921b1c162ac512192de37f30842e18ec4af226f3a52534ef014289d04899fce8d588ac1f671f0cac55f0a09a1c761d163a53a6716c85d08fd4653ed696a3d2e0d3c25508a3abf29710be0efc44d631bbb0150b3e787b9803148fc3a8ac05ebba684a8a0a365e731e5210c3418f37e5d58da41b38e9e368d638950f57e81d9a5622f368917500d2e9330876c6f67f9dc47f646707b24d709eabb7502f82348868e36262f3ab5528b3c5202539ff8084d304b0d1c1b2ad8d720085b667adb48a09229bad3c5c1a1ce9d972d27079ad8a69af1ddd56d3fae9399dab0e93c66b70d8561280ebc6e909f43c056e57bce7d02392b3d4204f64fd89508e208ddc2f22ca89028ef7454cc8606e239725eedc7989557d2f1569360b046e4d1987262ef11d4decd483f6ff351f47e83f2ee4da190a8bc317742892b9de93bec3e1f88c81c60f4106c62a2f550fee48d4bbb23bcb1f0031727e34c874610b6424de01bae0d7c1b4b9b2501e806bfcf82de76eb241335077e1b0a21beaa1b144951317bbbd669e738bac50527d5b6a5d39e91a7089ed99580a3deed4a6550fd9666ec267312295ca12b9d52a2ece0172837a2c16a572a5bb09e501932889d544d7a38882a52321dbb0c54f25d2b8198f9b7e945a0bfa2e003981bdcf306cc6d1f4c3af539496d94489d4d886a866cf8d42cda0fa91c0eafaef7e44d96e73880a3609b3f1d92ae3ccc9abace662aef314122ddbaab9d384e4f5372667bc3a6c6c4c3dcdcbdab9252828c8c87cd0367e6918e3870f1771f96e28af1e543695df18803c40aefa91c34d2cf306e3b66fde257707ffedaa58e629e8cd927df6c994860bbe8da3766940f16a3d9e57a212213d9602910798e278b676b93e5f0728e81dce6cb1359e25593064c4739c91ec648979008b5c51739b9939c4b75e7b337953edc5f6244f0fd05dc54983e8b17fb9580db156307fcfdf78cd8288f20e268a23a950a59a75a0ddbb46fd58e496f2d9682b2a4190ddb52693e3d6095991aa09ad1d33ac75bdcc838c8b47e0ca320d04c0369da094bba7c58669b51d798edbd7b015d18e8aa84daf3647d48c50480c2896732c0e364cf72721c0ca2a6665cbe8d7288d21e04340f7da855046789ecf606fdabe14e766806725cf8ef2addf32566add292625764ea5818c4c7829bfc65990ffa08e3d2b0a8c814e099530a4251b3a9dff81bff1dcb446045a185c313b6ce26c07550c691a6ffe4a62b6abd0a1849c820a04805285b51e75b092e76f7e3c736f1d2decc1d9c8245bd2b9caaff7e1e454f9a16df39dc836db9d88ebc12bca94b762c8b149b75eb23b4b82ab604a6a9c84b45636eab82d4312349cf49dd466b14ff154ffdc2140379ac613ead149e3208824a2548242bc954857d07538e13c30635a47aa197cf6b3bf50f1d47cd976e5dc2e0ca42ebb662a6d6ff80d6f5688404141aa22b6cadb5cdb25994a21e17364a54513504e2825a774e6d501747081266bdad20b9e12004b691f3a8de9cfd6e3da756cf918ab5da73aa0198fcc7952c9c32488411d4b4677e7b2b5b987aa08b682a7d61cf8e02709fa7c4816aeb4e980aaa4ddca4c3fd71f74dc03b1871cc0b3d870d249d5e2fc406ef85360e1d68d0f5013b1e82a7feed04dfc359fde8de104cb14859f0287c3776d4375bc46b3a9073e960d38a978ee6dafe09c07380bebe0fa1322ddb005895414308b63682ea6e8de8ade74c57e327d61cc7cbb6582713530bf6678e9a8faa84d835a8aac3462e1755d7a134b97c48fb37fbea55f85cec7d4223859f3f409e14008ef4a35657aac81736b4798c43392e761a05f18bdb96c0f092cd4ab4f0ffd2530a52f2eddb03308dea00859d5d992afc430c6335425eebbc1324bc442156396fdd84ce6fe7e07ccf109f7a21f6e911f056225d5adf602f6e52996dca2f2c63277114fa8dac0b9d44ff051168dca26e0ecaee550b882c815fd43b139a49a29aa07b8387a94fcb56ad80b1e03437e0ebc3983d3f4d3f9d21efc24e3e21a31b8ba48bd36651f3781c2e975c4c69d024986f61d27d8947c7f368c8e47be334d39c04a819edba7d8fe7469fd2b791c523a4a06cf8714c798a037888d94127026f532eaf0c9edc8db5a5cee273c31bd711d8c7c2cb7a2fd78ff14d0fa1b22189ace92c8aab490713f1db521b2cfa533cab708af85656c622a24a1f020be4761913b8f63b88637fb77665d1963bb855db3bae49a9f19ae7f47afbcf1b5611e6cbbe39608ea000efa3c12575e3d17e8352083524aedc7c0c97fcb6026ce0e58a01b4e4fbddc15d158afffefc927bb8d675c389bd510a013372a19785c7c3fdaede88169789852cfa7de186064eb6646e86a1ff440f8c01e15965f88b5364f7fb1124c754bec929a5ba05d3d54f9c23534838408ddce78082ff66e0a0c911ab33f42cf3ae0d3b65758d0a5a51138ff068e565acfbb5f789ea0285caaed845d133482bfc09f82e570208fe4ee8abaf3398b13fa0e321dffaf01b302636ce90883d612fd55dff9c3c44fecf531fd73ed245ba4a4e8db78b1f4c18b551e623874d452c37c70eae54c2ba55d5594db1404e76ec2cff9a2e77fbc8618055537f7b00ead21a4211f276bc9814a0bfc2fc22571f810dc6929409e8f283267de61b08faeea6096387ee8d2dff6897ac53fae944aacb468da2da9dda31e5a9a9c006ff43a4775d1f9d6aebe0ace1f6688bbf0297d70c858217556ea2622984b3ab7bf64159b743a3c482005b555e695226fdce9e4644a92dd84092d265875887aeeac4e8e9366e064a47b207bacc1b8790780a09fa72171af5c87fc80d5b5bb9841bfd37b229070ee2d10d7d22555a57497d47cc5ae6475148c8bff32d5fc29c36c94b015dbde1884047401c980d993561d4f2c63293587047fb14b1104366c30ac2302cb2d078663449f45f6c9e557af428e6d382ac5267fd5bf6e7f457b181a5ae61583bc9c63f5278956ce333a83b70eeb6c45c2c9ae680a3dbccbd5c2d1295f2125b9f9ed2238971ffc5301f767b6c51dc458fb1931c9e2020e7fd23ece6d9af901710e4dd4e73a582c7406008c288683e7b4e668581807b33247d57f633c70ccf1bcc6fa2da798c891040ecee475727eac4be8e51b6c72a55dcafde371aa5696d8e56077d1619ec67f199ec8b957e4673dcab02e147456713d2647ba5c7ec146d96144c8f9106b283149d8b78f29512b63f2d28040ecc14b684c26d8044d8127bd4deef3ec64dae54d9a3ac2cf5a61490c3321fdf18483dba2eea27a0b833a7821e03e08fe052c73fcf446ec4d386944bf5809638abc1a892b1289aef5b33a7a8c889a20dc33016f8cc91b9a67c49dc49be437c876061a95377c23a7cee69126d83c3673e6094bfcaf7bd8f339a367114086b516a98e0157e8b0e5b9c5ebaaff11090413d28857746ba1a3084c5cc21c289c31b1042910c866184786973fa0260a4db648cf73b0baf782041591e66bc6e6018e4687e71a00010c63a8ad4125a00b710d4f786660916e092c436be26d7fb23314ccd14de6ff127d2194dcdfce3da359d780026d26f1bce4e16b553b327bb5c2f01d2d57a73e0a42faef285f8be673a3f274a3d1b3240f5ac267316f60bea2bcc15d6c5c3bf0f8631729f26fba6efadbeab945d62f2e45526a02dcf7a62c460c86e2f7e6255c5113a8912398d2dad246326cc3760f350969143dc9a7e8ee62fb053e17f560a4b627249032a5589539f14ae0d7cae88c0edf665ac06ae1efdcddc3403e53c9ddfe85f6cb5eaa31ab0afce21d5e0126f3670803043768352f6a13cb2cbcedfc04a56d172b4ac313f2e8690da053b73dd874f7826af3b452fd4fadb9e7c5adf9e833094bfa1c0fa26fcd6e2140fcd791994396affcfc078ac9908b177e695369330e3bf2398dfbc37b7aa44f397179876f6c75fca834cd3d355c44be4d4e5add6965be2e261266cdd72e95c01ab21403a4bf272291af622489572b3334a436eaf6a4facc3bba66b0fb8fff87e61334eaac581aff78ca79b1a8f3f8ab4234885922effaa3c35de788f613aebf1fc31ca21ca42bd9621319ae52390fe8ed07564aa0a93e45ba3a86a4a229f32d670fe31fc4b29e5710e506667576f44e7126c2b605227c55473ce283e24de383d59ef0fed943aebe1b92c1be2666096305d948f7c636f13c38c438704371de8d51f645b4ce92fa53c98d5386b823e570d256b88846ac943f72dc6a0b003d1c14d755532bcbb643abfd546b1e50e3f3d2223a5288132f75a38330d89e705d73d6244d7d42fda4b316261911b9dcbce918010f3b1643041801479c812599e26d3f2b9e52883e9c6f772ffa94892870fc658882aaf17f6e8158d6f96eea64a16ed2a212b99c90ab034a20ed8888daf10b1e32fbae39de3191489f869e12bf231cb5b6e5cfcae2e025f578054d3251138b4e74976679ef043be5502c7a263e1cf8a7b84794ee6c0b62a23c2c0c0277c7dad40347cfd236289eb299a93121520b146ee4fd7f17e3c4c15c77d3f20543f4d408421597959b7e738a920eeeead332c5d8b9bd91229c503feb5c99fbb0ac62c45bd4811d14e7586763cccb0d842e1340edeb1e779804ba85ac0574141ed9608fd72cadac6e445c3f9277ebc884e2c491ed7de0f46a61955754d28c942848d73eec0de52b33fa9a770a704f5dc7199d3b27fe66b122cf2fb0443fd133356bf45c825ab72db5922d15179ede4f1931199a53c4b46406b1cd8d0bd85ebe7c30e6b2c0cc0f97701dfdac09de447b6b615b651a927056b8721bc20c1566f99b70497055a03e5d1b7b77144b214c2c6e8e8d296d62c886bdaa079ca22dd972ba396ba76c79ef128cc0b2a238c6839b9e57dda63d81d59b6233b19b9a26ff098a800cf8bab6185ce677d006988b6a4c8889af364e6e394498e4c9539d7807da37d27898e9e8bb32aec3e9ebb0753cc9577992ba58ff6641d4b2deaacbe1d604ba99ff4f834f1793cfb5a3bb16954aeb1a023c739277ea7c258004bdd7c4eac44fa7a5380a58434e8cf2a68e4f9f21ebd46af7392f4fd6393ae6538e8acdf2461f78ae86dbaa5992a8398656e0dd6ed5f19f4792cfd785137984227f0f0139e9dc44f7e0195d7741da465868734df23839ab6361c59ca5ebe62ab2741956202b963e8f32ea46e048acff1919bce5a72b5c7e47992a4abd5520015aedeaf91e4ccbd538a8adfbee2242d4dc92bfd0f03bccb6e9c37727a9966ee20180c0f6326de918f0c16c31bc28555eac6f0c687443b417c6e7e0c2b1a2867edcd16651805621e30acf39c7a7766035502d2579a6b50555d5bc184a1a2faadb1e58caea502d22df62bf31792c3f5e94eec782a57aa33a277d2d14a601abe58750bef4827e52ba6ebcc7a0afa9ede91efbf7d5623a369962e32c476661c43ed9b0204e2464d80acf69d9edaeb29615bd0d052af24390ba986dcc741bdb0c6c352ea032eed72ed6eba9ae2472916df1d0f4a2b28b59ca11a5cce7a9a0b54052db810f4b609cf7c86072eefa4864078d536d82d0e0b81863463d21b117fa94f6009cd300cde177c5f5d84523fd5f8c3b54278d37b51b5516f50a12b302c2498dafedf97105a2bb942700f1a1e61395cbbd26d2ad5c27db601122aea2557cc6441750dd1e1aaa39d5f25406dfb23feb127cbf485aa7e58326484d057c16173ca6981aa911cdc076a0a810ed28b234261fb7e140869a4e57a89c2f758bde3c9481ed9d0b96a085bfce34ea2f5815a7be8ecf15ea40d71b7fb920f91a758181b8b953fef3d94599c3b157199f1438fc566a3c6870d8a5f7d8558d06cb39e449426ac56d01815cda856680a06f9f005a73cf87656fa983a9195822a1a3fd34bc2b6347989697aa2195d2ad82521faa229dff3fc1b12c71d824db65f3dcf39a54be9923ea68e1dc03b9e6132c1d5ed54c2a2c34f9e4aff2f6b7b93fedf6f6901b704f6386dafe77e45d344149f3e888964beac4b14f5ec7e706d844642ebf7b4d2de8dd7c122373a847cee74be2bd2e35c32b80831fd40962232bfca6492f35b9b0eee3fc91f33bd447858648141962398c2fbc004c4029771d96f32ae69c728a566c50795b49c3c68d9eef70e478bc90b5834f003756f6ca499ad85eda36ae1c0c28e127d4047220bd676eeea3f3dc6a243fc251a966bb361627dc7ff70f7c76a77256c6e5ab99f654675bb4a8213a6e053b55cc9d56c40531dd683d215573ade5eccd19c2761dd5abf8e1d2bd2511c25b3a20f0141a8745cfe75c0ad9387d7fb909afe2cdd4b0c5d005492505463019ee39c918a7c8673284efd3ddb1d3466ad6543a23133113ef7f403520050c32b1bcaff6d141819cf301c8c29ea9b53d991bc51890ae3abe4dcabf4849205ddefcb36f599249e42dde811df2cfc7558eefd8efe98b5ccf559acf90872d54f6ec364e8a03fed7217cd84831bf4397abcef97cdf79b2bf588d0e42fb677f903b609e07564349ccc027bd871e000306fac32bbbae7d8fd79410fb285d80517a515c726de07e7a823731b24f5c12c2c96da6d4ad3042b7e22a98f831b988362fee9f02140619088f581aaaec1f485bed628cf9a6a8b13614ddb0e79e42cff5364f93678b2add11c40326397841d9888e98a522ac578a03fe3189db293c6ce573eeb48e80123650b9ef7a7ed2c1446f9f3f2bdfac83bf89707dbd2115a957779bf28f72f6eff045d028f297337ca28bb6543a1b0f8273c88cbcc588bc08ed6d14bcab01d361eae4e9d52affd1dee6600534060cd8461c5583fc18bd3a1c7a3c7097f275b079b3d24b2d3d8face3088405b30b6eb0bb3943f90cb45f237a9244a9347cabfe0fd8c87eb66d83cbb00203f905abda98c75e36b06ccf1e9d69b9f93fb4d3d21e39e2425213ed01f2bb269c921dba5c8ab0bb8401242c6d241dcea2fd43cab88de2fc57eb50106e13a30d7e997b8119e4d548b1ec3e90dfedf20ff54930d8882246106db6e2d4f28676a25d9d520cbe269a8ef06eba03371da2e995a5a6c87c7458624a9ff614f6510ef21fee6d558d22eb6c916e74d565a39c96efe4698f834a5c8036bce60f160b6f389da54273dd0818873a4e21e6ffb12497e64f80a349d85a0a4379bc078e8f726e5d6bc7d977d04d3fbe87d7bc8bddb25562ab32a3f0e2190a9d612fa943f05877977dc653e79fb5f3bddab2826fe809d1d86240fe6294df0e5f8d1ab13f4d1531cd17c53ea848b4f566f59b8f73b70673fa72602e1b33923dfa483d2c992687b611b6b2ad65e5672eb54d4330daa7c588dac23aa702b4615db464a6893c800e1391bad89524e884e0972fe34940bd4bd057fcef62f2bb78dc619f2f98d9341de7c3e04f80beca8abf2e2ab6f872bffee5f544fd608e034bf840aa6e97d1a599ca14cc3d22a8d3821eb1c3af9bd4f8f2cca66a169ec39470b2fd6a9fbae27d9f8f4e0fec3e3906aaabb3c4b161c9c58bfd4070359a7c89c78b0a1bd5fb10518c5fcbb48bbc0d154847f5d4f47164d3b0579e02a734585563ac2280b7347a4d6003b069ad23f0f8c6f9c7f8306aee213de6e9df637689bdcb1ca743a10dc111d0950e59eb630adbb1709f282ed1616c46865935323c0c61149eb7b3473ffd0f61a409b55240a3f2502632b235080c9b1c4bc74d578f8f7d09e0496127f0041ef2eca764623bfeda35a279c9c9ee796e0a1c5fef60e3d3504cd596202ad97e6027af2ea274d9c568377c0ffde310b21a6b4342c96b641af6f9eebe7eeb23df030021d559d01b8e41a30e7c5e170ec97bb32d46981486ee502a64676d6da170140d46c041f3fc64b94cf97cbdc0f0b0a195784efaa13e2e2554f76ebbc601f69b5bdfb3fb280f011d0caf740bc02c52b9609f801d6ae54a059bd4558819ab53048dd288cda9ce66cbe39882b4c9114e4b23ee79249e97f875eaf0ea16b56d294fe9eb59a6a8bc9a77a64bcca8f139a81d7a18cc4a289767e8e2706760e3fe2e73ac5fbd2fb097dbfd81ecf9d5c767cec98da84c02ea6b23deb4de77015b5db5cee8a6d06d53369c7cb7e032efed111999e54a4811d3258e6c84bce0ec08cb1eb3a2276befd35f4a1813b12c87fea1a9d2e73bccfe30e835681c7325e118a8eb97acabcd98713cdcc3b9fdc74e89c86b49cc796a8f8c99a5ee011d1b18206b33a52e6af916e1e8044ec5490f3c10f4f3390e2b53f1bcb78a4ccbf0d375d36e0f6e68da7c7432771933f803c7f5419108ddb3a7c41c982904047178a11f2e2b06a9b91f3d4f096f2ad2da6fef86d2981555d51c45d55d056920388a91aa59a65496cb1e2cccb97573a1929a5d45ee64034e2d486d7582c376d2e5df24b8046480ba5bd45d2cd8bbd3d659ec83993686e69f60ea668d68702ff66a5d3cbf31fb92a179d30cf2a8026425381de7583f522fb3d7c146346e337edd6c97b98ce0f87acd6233f3a96f2c7a78966f6eb8fd3504fa9059b40b750ab96cc79b3a543f49da25510c5b47d15239f023ea44d62e9c2e4de6a986d2e977f0453768ee4ae782389466e09abc9ede6cb9715256e65ca6ad5d16187d5ec370484a1bbace3b767c0c2291448ca4de89ba845adccee9a587f2859e4231624b2934a5393b579602a8cc4b1be4bc9a80877182002e691bd87c3196ef01d5d8728ca961a879bd97d4c0b8a84f32f0bff8e8b0072b2951e419c384319fb9b3d9fdd645c7dbd2cdeaac5e54bac4744a520920a0ec505754abf5b9199c4317bc637897f5cf521bf2612532fe3bcb8f8d123a6f12a1bf4720fda6d0e161328ac7cd4dbbaec8dd9840ba366838fe9be8ca0343b36be0009a7e6079b751177f4d9b46a09addaf08b28662c54835301f51f86b546c0587445fc1121405a1ccb6139a7f4aa1a64c6562437c2c2c91478c088662277489e282a03f458c87bd6949f287a54fa3555aff6bca9e7bf4c69c896d5c31118c1a75a1acb9f8db9b084ad5cf07a1616437d6a51a134c4c3cdc2da6382d99d90db1fb38c977aa89d4852816eb1823ca566b4fd059e8e266b3a2e68000fe9d4aa4b1a83fdc781836199c46f83bbcebcc495466f22893226b5e648b291fdd41f66a1f5fd3d10ed5b5ad285567a0d9bf71d4698963306341e7308c4fdaaa69ef7ec3ee648bfca86d92eda83438ebaf9cdd85b7a77c3c5c89d829dde000b110a7c22036d2851ab45ab924d55d57ac5681c1913fb8fbad3913c65be09c7ca05b4822ecb798c79c00fb90ce73a38cc1390b4620939bcb28486031e070abb163d983e019ef28a8b714b981014907ec17024c3503eb5757e9d2a128204b10af62a5877aee4316034d2c42546a8bd9a1f8ac8f99b8f08982c33a37ae85513c31918146b58f7ae1f637fdc242dd10bc296b7daa2be6a1c81e189aac6f903de93d949f61c0d4cfd479ac7c3bbb4ee31f42da71be0cf352c0c9a32fa4de6d4359f177ae111e4f6e254c973e7b93bd080ab4958ee5fb1bbceda962f7f6696020fcd1947d9e88e3c513f15bfcaf64d485b39fb686f531119e07a2d7a2cca5f1e4a1a8aa0b3d66bdb0d7ed5783abfd3b0d0adbf54ac0ed1077b09bfd5b8f89906d92b4b74fbea47cfe0e6145420ae064e482e0b6e2d3762e465b23f1a73c0f88ad135334f0844682c51123710f9de7205ef179d5a90fbcba44c9cf11d2dbf06a6ea7e22b93f1726d8d6519a3d6abff96d6b2fd3cc4af8a46c1eb01a4cdd71cbfffc4408c21ae5866199b537501999bb16cff6d08bbc131e1a242aad6e61f68cbe1c616cbdceb479751a57426a9e7741bb6603d7dac5696bad5e04c82dc2d363563c4610e3d7777536b551d0d8f94a86a3761f5eb84936ddaef705c5bdc452cd2b0659174a4dbe5cb7143d2c31832bd490ae557d39375f362b3701d7d827168f4de67c0d87c7c97095c812979eabf7268d05546ea54cd721fa5ac9ea7a7302acdcbda4c5e9d21d8446b510d15accea917f67329744223e3deb945bba7a12939f03cd2c251f8ae61da06db385224ec555f3d20389466701d824878c017c9778712388abe098589244314713b557b71cfdc7c17d5e31012b479c116993a6d5ea5a53e7b88bfe4e8cc3103085dd9e720d6b7845c9d9e4d67e07630fe8c14cc46b0f13da315debf6c9ef202bb1f63830e06105952514af3245e76fbc0cfbff74efc991fa56446cb4cd40686045ea3a5b1833666ddeffd0487a817aeeaa746935685684d5f7f8f419357d740d33c76d9af45f3c924252f2fea2b2cc9f09514ec45d15b2815302e70ee9949d35a445fb3577cf97ab4ce8628ce0b0beb5b4d93beae3ea41a24ee35e2aded9eef6813a5eacfed46b40860d76d32d54b1c000600795c81130edb0931be183af8e3e956647f121a57c14e18813deb09b8478ad934a6857293e687793cc5a9ac4febd918055f248bc189c3cb9b8874a685e5f32be00c7fcf12161cbdf55f2e1f13838873b57ebac5937be01efb41c16324a9b0ce83000d14c14824b420c94d64185731cb41be55e055ca0287fde92b7dc14bb16395bbcb676e7b539b3f184d49d54b2415b87ab8de83e3b19d2948bf20e6990a0e57a5a9f2c0de1b8a19d1e4239bd6e5f96143442a3bd1897a1581e7a96e2d2f43f53337b865d07bac4c5ea4e8c5b7f20afb6c0e1019ff21c36a063b250e3fd09a42329149c3dbcb578dd077b4ada068dac1ad6f4d14246463b33afcece4ffcb5cb0a9af4350398a35b1661d0850c67809826fba3a1c41be753a2541ef866c72b654b4a9ffcdd9f9788f9f0c59f606ab5b2b3c5b074e78ea31429ee0f7fc5e74e8f46a599390d5f7c0da22bfc6bc5be9e8b8e05476e3de99d0cc3e1cbedfd0a9859983552ef65ce8b10ce6bf43d25a1579e5b5b8efdf24d31214b794cd8ed6927e005fdaace2853b076232a4786fc65433a5da634953abd13c8fcd55bf0318504d3ab82fb07a59af97ac2383ed18df05444b3328b7840a4b9855b6687ae14fe906ea3a526a164dbb12be8bb335868e743f4fdbee67f307ee76ccea06d646fd9a9da64ad712ed70c96ae3b05cd2bf20dca4f640e1249b73ab66baae641fd4b23754ce20b22422e937fad3a33371cb9c5f7767202a5b0fe6d443dd0f928ef9ca1ca1648f5b90ec3c1501ac3e22dd44cd4307a6ef0c2343b61a37368d3863a1ad66a84c7275275732b577dbe0250973cce4c25bb69d3bdd2c7a60474c09b3cb0c86e299f0f8c6796e763f7c2aa8f1bb7992ab7627df4ed8dad5f481cd41004113abfce287efcecdc8ff997844443e833f381af34f1d712ce80f6a558727c1703f8e7adf805823d6bf3f9a2df10ab8608f0a50d7c5dab2e065372b965c343b159c2486a2725ca35a006f44da71420331800083ff5c3a982de2042ab0429182fc104464a3483efb49fecbf13bbdaf305fa2b28b02f40d4f1dfd63db613b63c61ca602eb3b9642d3caf71c16408a988908f928cdcf1ff854a8b50ce40eb3325c946fa1a02291b0ebaf64dc914e8da6cd7671a8caaad3e5947162f4771dd39fcf03b718b18fb1a942a1d89d1d347963915486b91ff708b2dce5c7dc2f7362bd2023860839407b6c274ef4787325e6d985c3364fc23aab78ad781f906c68f5fa9b6247d1a467ae8fb50241cb3cc8bd05b10320aa934dae7700a42f61622ec8052494d59928c5ae91f5b9da620323010bacb96d1a3488dea1cb2eff1d746b18c10257dde3c0a9b11d284df52ecf35d49c473d9a81830ebea96ed7cee81b77b923155125c988e8651a4ef86ce34523d5004a646bcbc2c1ba767210de5a604f9ab34a4df6ace36c50f5996f072ee51973a4cb81dbc920bcb9055ba2fc112c0ea7f4da5d9d5c20df274f29f9398672d090b111b05a19a532f7cacc1be75c0ff7c7d116ef188c94283c830951b54ef9facb5c28b6f0bc7ebd823fd9cecbb144819bab0a43e5b61d87107ec2cb1c482f72c452cf54c323b25e542afa5a60ff96276f9fe13355e9c1a0241e19df8cd57b6d5bb15879f832ccb9c923bd2eb3a597e91d29f71bb881d73218ab8fbc0603e7dc7ed47560998fa68c72f4740c4edbf140098e0485afe6ad121440cd996755960a6b18eec78e2ee498902d270f274d99eb6851291513adb1c405cb3cbdd8309426548914f1bac210dc8cc1d09feb23f772d03bc21b6a281a995e939effb6de4b7585aa2073b8fbdcc37056133cdd253b7ae58e21b590cf0342831fd75ef04c567ab8843239098f0b95c28c11a8ce22b94777e7406a9a42c8d213213fafe4eb3bf12f2f8f997d25a21cd4a7ee39141c3daff827e96ab5aa34948b949b55cbb4e9f7c63576e0276817f4c71adbce32c05cfd462a87a1d840c2135c0c4dfca994b9e059acc9a640302d80bd2cd33511181ff76d2fcd057896851daaf5198b6ffd5e1fb1fada7266745460b826fef3fbbc0c4eea7119c382bbdda07bad3b5b19a9ba3289ea9a3b1eb5c7a8be9c7cf7b69d00d79a4c74a850d230a07be5dad1f393e0e59e93b9ebf77901896602de905b55a6490741fe69818f27d3d767ba8c2ce2c51bfc35561cc2b05435b46481a1be5363e7e292ef8bc2c062a4f116b476c1acf496910cfccc620f5f89a75612c2ec2765a2306417edfac71fdca7c40eaa98ffefa683e60b398a9779e74cc93fa67ed73a88618bc180948e05c298d650f02b7c88dae76f95c6dcab65542825d00640653d03023ed0bedc90b16cff35521dd7919f99fc3997b5979ca186128a62fdd83b0e6f3c71476364e549ac48f8a1781a1957d2870733052c39a38e01620721a1b25aa40476b32e10e550ea3a0635ae14e4eadfff02d3b99cb245776d1590990df36eaae00dcbfe38840fc6e514da6ecd50d5c9dab89517591bb252469254815877478098bb168a3e6fa80b8eca2c051f013773873bc217e4f13f697821a837abcdafc7557adb0c5a8ef908e729327f72c0f4cd530ec3d3a38b7254079872d672c2c01a45a61d4d701f55ee13041e59d704ef3ea7b0b16a972d717df404c7186390645f17e3dedac9077ab705edf26b156ad7298b5a71ca9548a117ed98bc90194ebd0ac0767edf8e50a6536f3f588efca3125b555fc9a1adf619473fe9f7e4ea2d26ff41272aa15ad4f2fe8df6a1155ef9eedba53280c5b33817b72d8dc5a961fb6f01146b0a71fa38382d60190e5fa7ddac4c77e3c629cd729f9792347bbfcbb71f29323eb393c79792963b8dd727e34269a84f5a0ab5c0e83f8c41b23d76918890bdd6404f29404cab827ddaaf9720392b2b11deac5504665dd47bbe1326e448a105811db5f7492af8ef91cbfe155db5b7ffe1ef3e82b6c1d1def2cbdf458420677108745d036440da21fe5dd497c50551c7f12f51be3ace410c9a75009585d8bc7882f74c81c9ca11143cceebc1053aa476e5288940a74461cff3458676086f0c41f26091bddb6e408dd4501dd537f41f437ea5fa4797ad4f5a5fc672aad9a07f1017a3e42497e6a14011f95e86ec1a846c1b6dec7708c3b1df8eef5b339488b6c3b8ccb0dbe147f0acfdd9faa220a5f459bd307946a970ae0833104252f2ed20f785deefe518c0c277dc10544dfde95c591d7e34c8723aa2ec9cce027e31ff1d0de1f57d46e65441aa192dcf6196832c533c0258ed31f35dcf67a17f00a4b1500011dfdbf8170f2e2912e3c0bd7f0142e04fd6aaf7b031ab8810d4d5fa4873ae03b948ef028e12c52b15172dcab4627618c5422d83c9cfff466aa9333d1678dd29c5142ced8584ed798ad1196d60780d2031a5b469da6fc01501b5102c3869501f4dc54cc79d9fecd56ce0ab2a9415f7bc2db3985192c0a92c2c4fecd365e7e6fde38229bc9f74ce1b427cf64d3fd5a9fd0f19b4872cf0d8d1d084b6d499920e3981136dc81e0a0934ea8bfbac85a932da0cae01f749efe4850be8c2d6bfd674981aacdd4f24301013cbe3de61ef47cf466f6a5e1aaf690a01f5340c2adc4427adcf6696722cbe6db033ba2e3b88dd03158b95ac8d0a52a6c750fcb024af222374c83c97e88b1f3db9bd2c32bd14351a91ef17a6ae727174a0fc3872bab0b56a12a83dfb97ade21e00fcfb18a90c4fafa3269e18b17957d3c1ac4cd0b4edf17efbb848093fa8bbc3c563114ceff5736d4da18bd5d8262c72164e130ea432c41d9e410afc4fc731c0c2ca81caed23e215f888fa7564ec8781e5a914fe4052ac348e80d435ab5848b2fcf6a01cb9c79b4b44375b16ef1f2d65be9f866cc3cd278645ff29de0eaa6f04f5faa2cfdf667688202e64854f3770ffb5d7d8af1ea5100d62b5bb88e1afdb37b72e93580129f6a64ee1348bbfaecb2690ac4bb557831a60a635ccbecc5a9e4f746729a96999d44355cd8637c2f0b0aaf0e06873df775d954c81a3ed75f5c9aa73f7886a22874822115e80a154f338e7fd722551f6da8d61873566b288fe7051f487bdbaef0e3d3a13102263827fc7aa403972353b5555f2394d1506cd3dd526aa9c6856ae803dcdfa60da5e55ce10de2cc075311ab60bbfea7b98df128a60a220e6eb1b5938829d049bb10a468fa5bc84e75610ec0e2e915d248b4806d8d31ef77a0114bca1bf5beed4663aa68b9683da3dcd5152f8ea041d115fa51c9e443224bc1081994c7f6348f288fd169bd19ba95786f60e9934e3a470e3cb0a0d1b2a7f1a205ce0360e9651720de2d6773dc895972299bbf1bd270a8eb8d5a6c319fa6b2af59f7d228982c2294ab83c183c2818887649bc83a2b531ed8faf9a767386ed0a27beb6320bff648b52c6740da5946f7b02d0d94ccc9a96edc2f7eea544f1312345b59f28a2ce1690f0a8d2162c451b707365a613e80194ba4003bc568b6f7daa4efaeebdb043bfc2e305edb95276d3c5dbfdbe5e497ddfd704402d70bb8cf00117c5dd39f09c3ac4d645f5ff705373d7bedcb5c82c5ce0166205962d317e49b68dd45a9230cf1892c053cff90927d87b971a793ef598b959a51686496c364ca6b8c472552498236148d9a22fa31f2ee7f7bc87c302d298781f1dab01c0742022b9858c443f1e7005815f631bf6ab89566dc8b896da649498373bffb565c40389bfe2bca8ce969ed4793595f02f77697893ec3672a80720c0fab3f34515603648acb3094a415e081be826c7026cc4d76141aba465072fb64fdc7fcf187e5dafd92365c1081f6707328a142e3fee31af5d6054e6fd12012f6a0dca3dcf896a5dd47d4b293792083ff654e379e77243a9a82604f8803a6e089fc371336b5455da7fcca8e70637a8c48b4a3e7b288ae6726598c65c4de5355ba0878c70277f3e7b4283d4a7857fce660992beea9d2c74f8b3bb07144604608288898f560d597eef657a8686617646e727b4aa39d185ee686b6435f7638db6c97c88769dd5b3750093842fa41dc9318afaa2091adcc0385f37a5e7f7ff19ba7391a3fb7143ae79bd7a26c124d54a8932e9fd86ae594e115b7663ce58b71fa3962d63774ba015dfd4e71e2c57461e3a3a848bfacac3e31e2d420701b984669c399b0f76f8e4a4f112837aa6ab5020ccaee2e1633bbbad945dabb7157c95b1afb02327a74048492467025610b49b9ec3388e5b68b02ebef817a425dc82bd5c5f47a4c643572ad3ce7805ab7aa818f2c2109bfdfa7c8886c4d9bd0237175ba224a277b45ddd3a806d663aaef2d7925b485df4acf5897ccdcfe500123a02ffd9d529ddb41adfd55b5824b3ae6fa4d6a346d0b942fc03c1af45b97936a5dec523f14fc41b4b1586978ecfced21c9675bfff0a1a944a3c4815dab7ed7be82ff38b64905f172018e14af296abc1ac781ea0d15e60ee2880d59bc4299e00deea7e70cb92ed334e506670dfe11b6e764abe15fffb3de12661c22d6b95f11146b06a403b218c19a48109d1150e55c52cd356bcf440717f3b498d31bee33534cf8ba7a96dbaa3b8675bf00ffcd7a7a7579eae09c9538469162688ab2b6f5b879304be6c3aa3d2499ee91e2553bc66fe8a7d33c2ac7d10403ce678c3707410555b4d73492496382991d3f0cdabe8f0bc346d7ca0669cdb303f39db7e9ca38340ca4410b2555577eb4600b5ed22ca14109fc6648736a9f64eeaa66f089caf3f8188a65529c9cfe90e47803aee30c37989c63484d2688b7f5836f60a1dc4d5fd797cf07e7b2de1b521feccd020416dd4d6b0f3caec25a05011221233788bb76f9c62ae491ff2cc87280619bd631b50c95410382499af56e887789933ea3c7916911103e9dc80df3132fa253c08f82c5935288e8d055f399df1ececaa2e8389e0d11428de18d4d069349d336f197f53a4bc9edfd361030751515af02f080e5c59aa3d0592d484f943a20ddfe5f46fdf01c03364628a308dd76df29919a561c2067c633b821d50c77043384ed83353afb6c5b235aad6467ee15d31c57de19919ab47271200321c2daa34d5d85b06094f4e2afd34008f4fc86c62e34a5d8d4a822e0b8f548d510609063f3a3db41ccde3a70fa2e9abb5bf8ba707a3a8951ebb75394e3bf1b01232527e6561732a8029665ec5feb66beabea84d1fe7a8380757deb76da3fe06b716d653d5581b262c7551154f6be82829a0b05c59f5638db75a7d687ca8e170c64de3ae7316b43125bb9373aa7a8622ad754cfc00aa4f12dec4732cd4e3dc06b01301418be5981bdc1f875ea22e056807006d11d08c7a129d54af8f9ebc1d2eaa0c2964117c8bced0be5648c4592f389b88d88c389a6acbddbea2dfe6c8f391ab157c0c403a3de50421956afb054bb2ba6049401448ee878bcdcd957ebacb4f31e0a4439936570bba13e41317a6368b228a63d3195c298587c5a01a28e60beed9715a502b61ac7ca31cc102853a2ab780284e627c64d7a8926086e35e0982a8ae36159697905ef0d62ada4387f28f52904a8b79d42f135ea24799722333d600894de95b0280227c7ebff7bae749e93c34f3a0748a950df5398a57b777a8b7ea76f6f9b79fe9a1fc728f0e25b5238c9de930689344340d02aa88d1761c8483c193b06ca5b9c86460e36a339f7f4a311c2eaa8ced8be45c8853a73b699430a84ef5eeec2cc5f62b7353b7e75d305f3073631c431763a284cc624d368149fa73689d13b2ece79ebed6e7b440a7c2f5ccb077fd81db9d8cb895c1ef8d8d3de8518ec5f2fb337ede28f998721f506c1a75a2b629814327d8b95cb43327c7aba1d5b4c9fdc642a70ee6adf84ccea53a1221d27d55e7a7bea4aede7c5b4aadc2c0d454772c73e231994ad03904238c31d8f4aabf7364d25d7b07c6a04e4673fe09516b90d68d2a9023931ca5fa04c999d436cc451fcc4878b4a7089830c7688da447b012a5876b5c07da7eb8a9c28e84cf23ad13a4d3d75310039cb0bad22695513d568bb85d1e46d201d7ed77eb5952f3765a6287e33cdcbc71f642a161d6d51bce58f8e7b9feaacb4c7cc0b1cafee33770c2b2522c784df5542fcf5f2464b41a0db763e647392e723923208699692c49483e095abb71f0cae567266f843ff4b0def2c5a40c12330f85046c2123c70125b362d0cad0ac9240452df78f09ea0a659574cf1c12c1b90b94cde1b904d2ae4868af879b0abbbea7e96af54d90681b44aa7403a64d7097eaa8c9cb01df8e9b5309d4bbe4cf44a347c708da7176ffd92a86c3cf601095f04658c33a465ce2533cc9495c1f9be5f12bcbb6c42ede17be770b1e347316728a015ab3029c315507a5ade6ab871fa4d0b6242782f3bf6348674d0a1d90d722f65524f1861b73f00b6ce102077b60dcd07ab090d5f74c513444baf0d2f4b74d1d295b087744935ceea90c43422696a954b35d2ad9b6d5b98dec2d66639d424ad848f6cc88fbedb14cb371d61c794b24afd69e489ca513cc576205daec8e4a527f6efae9fd74f02eb95c0e966d6c0e04834680a3228395ee67148cb2e19964e237510ed459ffb7ae9d689b8af4be275c55327703d23070d27275fe670e0e63643d8ecbad5abb10d2e6186ceddb2a58cb65af4424c0979083c338928ff33400ce0823b76a1822b40f04f0ecb6a1bc6fa8048a0554f2b94e2d6fb6e0cf760ec6ee6115359adb11af1bfc3bb1887bdd1cf4d4f8da79edfedff0ec1379bc26307e585204559223e09bb262e3ca329ed4ee808984a1fe8169b8bd1d82a855cf8e63797604de2216db771b626ce158f0e68ef348d4c4c1d10e8acfaba97b163a03fb05efc1670e3f0bbb191be45fbcf2e17659b9d4ef3d6fe8f562216efa1de8c1dfb64f1b6670632c2013573a798403405ddac119724a667528bd6522440935518146db6f6ff64b34ffe1610f9391efe1980ff9825c096b959bb5d80001e549f99ba28f7fb9dc54ffbcae07aad68508df85cdea16f7c0d4d907ac8ee5c13a85a98000fecf1ded3ccb4b2cd4c81c710e1c99b1bdfe967e7b872d3bc6c6db3a8893696068aafcc38e9bf026bc49a2b939fa9346f4e52ffd776dd936c85727e3b86c95b6a9d4102dacfd1ed67c30d622398da6867c097b7bc6306ab8c528a9b1e1ef492c06e96982eca1dab01d0bbe0efda90b004b7c4020c900058c971aff090e0cb5b5487dfdfc11cb9e107d30dd50c189ea4ed4c7d56abd602bcc08587d3be508846f9817051c3b991930051e4314fa7245e3ef28585a83b756d7f189c6192ceffdd6883c719367f767f1e52919974953db768dac3d7da26b7259b78fc82f275c30de95f965458a4ac2aa9d25929f2785cbdb726e98d1c7e8773617700aea2af5589890f2880fa7d4b9fcd42274d8af01a5d97549f21e33bcaa22983061af5d52c0228a52fa9fc199da6e26059647274e4860ed8d310d4361f9320e89c352e203b1c9382370ffb2358b36317ec97a1a6f108f82bbb861fac1b060a2569efd5c41494da2a563c5946a5dfb286e9e8b2daf5bacb54a16af1d399c6f17f83782ab56aa2e0e1378f31b4992c15e2866292ae05ac24d01dbaf9adb6006627e1a4f55c98e026cd61f71838379609d9a8690246843f3e123fbfb6412144f8f5b2d859a0a5ea4e6fdf8916b2ca1b5699c7a41d39508628a3ae3ca3fb16aefd524866bcf0bb4705ecbc0da1e159a9628f7b6cc1b6fab0f71fb914147c9370fc6c0a5851eb8fdba1f68459287a98a97ab531c2c2383b0771c340342ee147724be330471085104780d6fec655f5971189bb7badd5afff6acdb8dd5576344f99083bf0b5fdce4d745c745348f5967cd6b7c4443ade87898b2cbc023beeb131f965eef920ef8abdc2948834dca8f48411f13c6e78cbe5ea8e887e7d92d2003c726b6fb5c540ed59bd7fa4849f5c41da7378c7a0e1327f3b0e7c9100e6964b8204059f27a5ea0a36467719def20a7ee803586338749d15b67affd968ee03a0ff4777cf904a595a694d67b1e0a8f0c41f517784806cacf273679f44e09a9ab6cb6a31a28bb91b0215183b0a3dc929b22b483c351a959ecc510956849350a2fd5cf7c523d55c3a2ee112f5890297ca14ef1a5658a422e147e0e6cb73502cff62c8a5678c1d609def757659eb0fa7e90d23d57ee64d1cee90b0573af72bd4600058f5cc02119806738df1669e36a65a782aac7792a7b0ff46cb06db044c3bb6bd4f7e1418d48c79d302d33af1b81afd24f3af0c67fb60e3e17270e48cbf6a6ed223d7569aa134973ed61ded9381482e2785234e22d7013d4b140e05b9b7d999cd0225ba144b7d84b1c87567ad72aa29b10a71bee8a6967acbb9bacb3d1e45435276bfa81ce347467d7481f204f583d33a1e3823fecd95733167abf7f9641959dd63fb77b57beab74db7b01f548fa39aaef302ddb94e9bbfa73c3b6a79e76d4677815652502e2238d4cb387c4c9920984c561030bddc84371a3a47bfd77f3e0bf280d0c7821c7478bcf61eaea54dd51c3e1503f69365566978218dd6b00f643d118c597d7a1e60b82aae307d4bd39167ea6601046157568fcd8b7f175c74aef0df3897f47b296c85f7dee36e6f5417ae8f3b84680530938fbd69e95f1a3be98fef53a5fcd48b2cfde1456e27a7acc8c8c89cf6cdb36dc0334f13364597a9e7870f96d56812610b4d8b442cdf7b95aa76d430e16c81b66eec0164e6d907f8ff7a35eb96a7f9f409e2b8fb475aa3a2ddf50449bbb129f81014e90519551c39481b69ee263a7aa5813a89c2b046247f351ed2c2bf8942fb8aa4560c5020b4560e50e999616ff16d0caa0816075c434389eb6d87fb037514249146985e511e7a20d9b7fb625d37d3c362c583089f69cf3e5dacd31701efad08ef81407fb7b215f7387c149ac95d37b8b6968d80076240f9c5ba5b350e535240df7cbd1f9745364c0aaba13a44e8730d0cee3d9688f5d47443060857d97da5c5a524ba066fbefb30ea87c0958d9a1e05363b0af201b33776c398522a39255c4bc53c82595a50d1b62d6ed082da6e3a92e7de84b6dbff1db291aff64f54046db8467ccf01a36c979077a4e059f30ef3e5b815feab81b243da6cffc54f2adcae421af90fff44df3a42f13c8653c1dcb2f362ec9abffb9b0d997da5ca051ee09bf57954ebf7608e2b3009928cebad142e4d6272271b8a9dd6c49412f679631e8a2e67746e3bfe091e288ca89a50184e2f456edb4c6afd0aa4ffd7adaa916016d211ad708ca3170fbfe32e881b6a8293d936413e3c6c028c587874ff6d50f95eab1dd35fb0065e8e6723674ab772db3a508a5d969a702ea470f93505220b49f5d9579a751fc08db068ec2093965e70b23beab9a57bc52800d252a35349f735daca3a56d2c4dcf04c0b97b01dae2ae371e74a3d51e98ab66e4428b46365969a1283155aff097878cd8499c65c91357df17ed52b8900ccefbcf9e4a4d72410de66642b1565e1a58b6ac635423a99c142cc1858257beeb7163c29b22982943f9357fcca5cf1d33bc1d6de720c6cb63ee0d13f39ef924c331c56b43156a388eca94eb86c848ce0d5662c5c895c5dcc4cc6e4359a5bd41a95c7ac64e640c36c80a969cc30134380ef6150a554e9ff5614429f0de1beb1f2e8057bb5771dba17afb67b84733b46fb136980ebf1d66b4fea7ed2353aec14b5a918417b8d2eb6ad0beab40f6fe6de13147ac7e5812743682d803e988b18ba9111f185ab8f119afa41b2967646531b094677ffbe9704f321958fadbb115431019ba6cd91ac5d08c49d4d02aaa0b0641cbe0b878de2763b132bb23d308ae47185c3ce31431fcdf35111f7c9e2f04859b3f325ca34114a7bfdf0c3da90d0920ad03b33a371489fcbd0b123ee34ab7957b1d795122c0c1d52cc356749e6b91ff2e417e7e8fb7524193bf8c4f29d0f978db8bef38a2b98ce76602c5e807cb7d652806ee2977851d8921e3e17f6e37db91800da4549bea8c1b9a941eac92727cec4f6c0525a684e42162806c347114fd37896dc7f00ad479a9a9e9d2f78f3f0ba4c7bb44a4f6c03215b6af48ede94e3c3d82d54e0d644c736987426314d82d6580ae8a4b46e0dab5fe3388f492d4dfaf78735466066215aef0efaada08f458c01ad7e81771f2eeb20e8617452b2adef93840a0701ec22174745c24604223bb965ec8bd7a7cdef0e2b2df7bee3b6ec0154210114fe1a88bef25b0e81de6131cc9786371ed1e967f8dbfa17f81c8640fc7b90b5a8ade20c38826575e10a12b06f8c0db8e69e10d45ae4a90170a8594e4649d063b77c76b3c3597e261ca68eb75c7546827b49f9de0e650da4872ff6110b0f1f1b668a21e04b9b0d0f6d202d5e63904175d3539689b877734e8b1c4f23de7fc8b7d7815fc4bd8436de75054e43d1f628525ec60e321adcf9ddadd236c10dea4dcc5e672a81f875e3bb04cb933e820191b7a764eeec85ccbc38eb9ec7e0f715e2539003c0e149cf89ba7b5022dc1265dcdf7dd5c603844d6955befd2cb0fb66991bab6b5734161af5f8223b67dc13b786d277f40181c9860ff074011fcecab83ff9392d5d55962beefa4055dc39347dcdf15570b8d99b8b36286fc625b1d8dd66ccd9158dae38541eb91009baf6c9b4ad7127c663c559686b704c8807fbbcc93a4a6e653544ce4cda53c299a39542c994c826e57657adad9155d7924983514b0f17710d95316d5cdedc3efa8726a0abf12a93dfe2f4cc6e93db12f67dc7a0f6bf47348c5a27d1895806afbd7e1e71aae97e96dbaec97016356ea3cb1add44acfade06a6e1fbf0bb6a743b059fdd6c6aec2a23dce2648d54695966f4dc876cdceb6f58c01e2211f8d36800db52fce63c46b785b130bfb8632207b2f4b84e339ce471457e0e0cfa1f96adbbe7f1dc1d1333349d616ca3ba96e2f9e83065bf45987ab55b29ef7c05393d05f67852deba1ab79071c154a636eee763084f7d96cac68dd53d5a6aff576701f8c7dadad4349d0cedede6f47835d9b1b4abc5e46703d9f720fca60bd63f011aee24a93eff021660ce5b5c6b9723f15070929e2e5f5508ccfa5cb6b13f9fda65d0fa07fedf5ca45767904d76dcfe92f475bd87fb009ed0ebde849391a02d4ecc10b3d4a23be72a124da22c37e6e09ae65b2686ebe3f3e31aa5139c471bc865129bd2ecaa44decca86cae2e845e9df501cb52c5c84f3cd030244fe25c75c3be622d13176059b0ca7c2567b9a502b9be0e19784b4abfc7cefa6928a10edbbb6b7ddf0e135f4445ca2577dce2effc507a629d1194fb847f60319ee3e730443c6d63557987706e74ba01e7046c1657baef6530d09e642742c248e3690b0bb0945f5d613d7af4bfa34ae10009d040a33f4ab493237f04b3882872503accd02efd2312cf9ba9ea54778c38c5b44c1961ad00ba72beee126011881111984943abc274bd8b8d9f519c51fb223e5fe1a52b30aba850804f6e89ac930208c265d5743d81d9ee46c60e21bd622a2815ce80572cd7c2cac56135e7fe294b388365335d502e9b0db852f8b839bfa4dbd681e0e0bdaaf636af2529a5847b15cdc5747fa7c0577a659a9eafd3f837b51df3b58fe81bcddd545a1e2efa017d5443c3ebac64f3aeea9e91bbd3f7853eb214aaccc50a78a2f3465624c65f2c7db7c321a5e153bcbd62747da2eab2f9b8cee0652197791cf4653b9c97399a0b0c8d316d10f9df0b6842d49476f7d0cea1d4796a7f5b603f8ac426028731d56a765862667f0f14b001fa2e6efca736757f049dc47004ae794bccd8a6c22004d682b259a6890d21e30e708fdb7c2d108e5bb070306eb879914253c13a9fb33bff6a684b242253c081a268ddc4d819f1e4c1c777e5426964de3963df802c26bef722f3551dae3f3c45ee6fdcc08aad3ec28038ab3999fafb1d9de0b010b9ec4e442cb2be8f8e8529d576ad6811f12b181d42d90ff522dd03744c6019ed7f5ef2db40fcc618f61134bb063d03852ee59c0fa73ebb6e39ddfaa23a1fe74ff7dfcb73abe3fceafead70bee48380ddd49c0dba731d3ed6799657f2571e23c707281ecda2f1d5a54a24523ec5fb89844bafdd83280d521e759d8f2c5d71d0a6b04565c782df2a5694221be54d0381dd8f5262ef83d2ef7ccff131c1012fe764fea6bfc3c6c53bdc929d6d35fb3972fb42e799daec42f811bc011d2f6b5cf2fd607240925414e4ce1954633346ee66e6cf1fe774dc20fd012be4651abaeadc5a440510ace515f2750dc8f9e75568d84be538152a0b97a9caf6a7c99418fcc6fa5e9079bf4a8cc36605abfcafb38c3511e1675ddcfe44b5158fc6393aa5e534ee3e5f4c1466f566a7e3caad9622c0e888419aa04c039121b7412f344049091b0589b2d1a98b39d16bf4691059cb4a7acfed6c94d177a87fdfa1311cfbb9d06c13b0e02710b1545b783695e42ae806fa5f4905a614557ddd319d0f0e89d605a3d933f74848ce28b85b1cbceb27d2a14ecd6e85f0453bb25c23571c9941776627c706eb138f7dd470932cf5b3e318cf2c52168c281420eae7f19e495a3ceb37e6b7ba49cecdc3f849775c6a047c24519f3bbe59f1186103cdf430d93eb483b7ba385e6eea47da64dd81f1cbeab096e73da0cca7213771c6411a12c363835952e5a71698d78a3ce5adbb88b83f1d5a158f2a1b658dfddd5cc76e6b44dabb653e12148432109fc5194d4d920adfb9ce70c94ea58a3e3ef8a2b509c54f616da75eb348d8e451b27bfaaa9e4f1f4fde6b40beef303a0f6fe5b03b3bafc7fb73e9dd5496d682d3a35c664d9f8f240bc3b569a3beac440260cdc97b170ef7b9fb5de909a658de7cf9e6b92ade435db55428fdf546ec5b2a21309abc2d374bd78d12e218af7bfcaf1c36fafa012255e933687f863bcf3e26c235422fff2153fab8e3f6b157e216935aa2d7b52471569145d66e7c8c2b62217300c8f55e4dff9efcb73cff45804295d0c2f623aa170ef5fa488e71083982632e2c26760fde33a8539153b2b6a493fa2148f6e3ec313381c0ffb4f37dee9bd702152a2782b2c71422328ab38907fb0496c68c42e3abf7fc8dc164914431127cb46ebdd3559487d2b05829c5e74887226a0e18ee66cebf28175e9ef1e2226c20b2a27b0df029ad87bfd645ede05af07eeb099020e7d20e71546826f2e507eae7bba39d6d854dea1822f5c74da6609baab355a6b95bd0868e6eb608d56bf52101e86698db720ebf9b904bba547ba33f43f10fd950b948f4d41db5db51bc9576c43878c60ee3968f390311a1e87ebf60e62f829a6c44419e83ec627884723aefb281a4a6e60a957c501f2cc2256d6704d7520e571136d6ac1bd0a9ef60c10de8b52f4fac2b2fae34b8db2e9d9a528ff5489e8fd33cea66c9f6416b775a3ede5b4048e61ec14d865813bba971dbd5910a14dd4fb2f1352671552478fc52ec8f2403ddd79f0258aa98372c7d3cb2fc059bc2f077f291bdb48c14014777e6d2caeae692ae3c1a27eb9051f891f1d3059837b944e529363952f9ea1d352e81f1b818f7cfbfb2420dae2f424dfa8925b0c4a098e3e4e0dffad6aa4fb3867f435880d4d46f04bac504cdee690e408ad275d33e73299349a4fc074d22c8c7e79206e6b5e8fd558a0133b177a3d8eb1cd2a0703e1da7960a2e75ae3f71fdd1a1b30fec30f8315b042ce78489745f3b56ab1e823dee2cbe30f8be94817a36bd5b3e735f9d804bd400984a8950eb7d984a559689b42fefd3f3d1f34a94df6f3a92832338b00744cb1a05c569b822afd488e8a6e91a01e5d3d51fdf32e22e28d32ce46de67e547f70dfe7a5b514bd353fe95f00655e93771c6806e4082bdb665840e1e69b27f6b5440225504582b8f09a3b3ad79dbc122468332739871c8914423d2c1e95f44e939bfbdfcb9044a1375796b4cda3d65eb4c12f2b4fa50d021c9f9b02fd99a140c8787b992659cef7508bd5a06f28ecebd65a0ec36b30f9eb2fca03e0825c564a4d0a15bce0b19f377efaf0226b3df3a478f4d6d58f4452ad9ce15ee82b73240a23fef772749a8a8803fd5b73b5d4800a6d79a0d22ca559e6f03930c4547ee0c13c53319724e48dfaee8d3ca53fa53fefa782fa6d9848c54ca600f38c44819c3e1261121df7d6f2fd1b4bb471eb3737ba42995cc37a4d9b4ed103a58709416bed2b1ff28a1a669e097960f2d63dec1147a90be62227cfabe09601f52570ce1c9ae70f81994feb11ce32f982b2160fa01784f30466fd6d196f9844e3a34eead1d43e17f93ebacee5df031ec958492e107aa0db45d61d9a7498a04823fbaf1c9a219faae9e7c3858ea92f6e28c16f82bccb2c94ce45d7c9f956e8e387ac202bccac16725252dca18cdf32d74c556b5c8fca4a863cae61ba49fd7058650652b82e5ce0628d586880f233b6bee3edea7f8cc5c82baeaa9b93f5f8e22e5f09bc200833241a022fe854a776db19f59ecf1eae94fa43618cf142ebd814ffeb72b29a7b70ca027a5963df6597d193bacd072e3d30b4e8825bda88b855fe2a708656bc1c50118cb5256ac6f04355015cbfcd6a184da7260b8c133cdab7cff3bc45329a40e7a05c219a48c1efc41b318f2fd3d625c4c2055951a384e060c7a8fae11b26fa565e2391c2b3b1e15134750ed07072fdbe7bca7b1f9c2724bd6a84594e1a092effeaecc58b6e1eff1481d2c3df5715dfd7071a1f72e03e278d04fb5b281c7247aad3a08fba3e662652d681068fb9fb50c88a8632a41f90f55cbed95ec1383cd434d92cf023a212cc438f6573a1b3ca884f36ba070a2186acf5df9274b185808cf8e8022b4553642bf42f6ef5a68f9b90d085d051ae799519793e1a46f606ae1710416f7cf0bb1881151c1ce5696855607a8273d29521fd10988d330b43ef4fc79d63b584dd4a97be020f03243565448a0109cbd6d4a849bb35a7408c7f71c2d8b1551f9d4c771400f23146683ac5d49f63149d0315757bc4273e1ec42d398bc69944e439727e29456c7016a727146731436a67558c81da04574cf95a08b885382c5e96981889b02987975917005e2c83b57c81e668c6221981dc0af98d1d76387917ee0589856c1e1bb79103e1e180ad7dfa93abe1226f2485fa2090c238c81d557b0fc2c6026f7b015fda98361f14729bf4900ff622cdf1d9753b69df3ceea7b77eeb678a6b46c6a64d45cb17032b270d17dedadac18384650f03e28a6e9e227f141a90e66a5164da584a9a0463b3fde6844c99387d3de14edd45a134b0a107531ff4b6478ffd58cd2b1b67b58c6a535d6b60a06697038d882ea38b0cf79d4993dc750f3a0c3c2abdc1bbf8de4fb045172fbe8d37e7c3db4915de1ca12ecdc5f80ae29d8aa3a6b11a3cc72f2c19a88e8daabd713543fa24add17cfff274cde7c697d5dc67820782aa0a2df115a9c4e2734d302ddcd09a43c848d973864cbffe00db3bc7d35f6de27385116f4fc0a4f570aed434a7002cba68f12dee4f0fa5e7cd620d76773195961ecd10e24f8d55397522624b47d77fae818bb39519db666d282c0997e23510fb2deac6e6ea6ca3e7dff8c60045eda0c836c957b3ba96300b1cddee605786155d194c96443b0a54f10d59e4683ca1b2b8a15462372cf54a0999c23fd5b8574cefa30da6b9b95ccb554b14f92decfda659a6587d67864f63aa7f0d9c63d2530297fe2b54dca465a9341d2af3b0b57031001c5d1b1fcef264b072119965bb719b7c2db7af22e4029a1797a9269218b2bb6bd81e32da2eb8fa5f132231d873af3110aba9d89f35fdd4e7ac6c084b0a02849aa00ad15c8663e88a5ff37fa7453748de179ecd21144b20a6b841ad8198c7e04747cb2e0327745fa89836c341a009367f113455cf783f34ddd1e39f2c86814e2176412c7aad5ab6920479329cd127d80effa549297f22e0b4cbdf65ce0dd2a6b0c67f4e604e763006e8b66f7af26b3157eaefba6a1362eaea7402bf3c93faaba04704f6819ed9f71776609650952846e91db73a8cff03f3635d2e6ba1b23ad419561722be9bed82401abd0b238307b8424d39c2dfcb9f19ef391e556630582b5f63b4348ef5cf9bb7c27e5d06a924c6f962d3d4e3f3cd569aef03a8fd11e30ccfb1cfa9b6476070960763187e83954f6cf1c17b38642e8ca11497c2436e7b5bbb353c2df11fa19560094cea082b823c6df44969d9b444a80a43051561d366083f6e2c961469bec1256da7aae25432ce0ea0d22fea3bd34a8634ef8e10d516236e8372a57e6647e28747a295f08508db24b4d832f22b059a9b0c6e34bdd07e082a02121cdb7287014c884147ba1feba4ab2e22a8fe8eb6519a1db489c72c8d4cb82bf98ce1d58f8c0d7b27a6f56b7c20526c6dbc1b83f28eced65918776e8d2526441a0e3f8a44417d20e0ecee6dcfdf15223c9c1e1f768edf1d2132e639849ba80a8f84d3e263fbff95fa0fb26139ae3eb9662d07b3c552d85b63173fb92f5a1f2506f4c1fe8fbcb02005b2a20a9b609ad521e5316dd8d1b94f46d51f61765040964db696115089d26a45653c450594cf278ade0814f35eda3866e97e6937b1d81514116d6537868c3164c37725904ab906c6cc0f1fd4ec871094b384f8c77307378dafc930fa1d3a1b0554f312ef047127f0a161ea4018af18361acf87eab885cd29bdef167c24ece2d0831b10a4038f441a221f06435c45e7eb0bbfa9529b05db7b756d3843dd21d72e9cb42985a64d2fb039e69ef151367c4feeb89209bae466bb63af33bc33477bb41596b199693d190806b553477e5d5574bb822439bcc3f7b64545264b57ac477220fa7dd5dbc3b7cc60c69f4f30b0f4f3e15ae1dcc91737b93e1e92ecd3b9f6a21433b546032222ea6fb18206f5bf878df874f44a1e2df2360d1aff00885f9d36942b822f85207fdfae570154599f737389d9264f798e0d3a0ec896755bdf24e50d5ffc1469391614a246f3e2e1f86973e0c3ec1b4a254eb7217738587d19a16a905af58b664dbff407fc06b5d7519374b4bce195931b0aba28c6d189af3dcb7d7a29f18ee533c70b3d717cceb24491c5a7fba38db5eafd28db3b68bfef4d5a13b296a6823b07e6529159b2fc60611b9acbaae21168c827f2ba4d5e700b113337dbef99ff3844abaa79d171c51c24634f63fac772df14e8e37304fda4ed1b550e2588fcc3c3d07134f9c56e10d2ece3a7b432b048a9d5187a44c503eeac475024359c32d391ae0eda4fb76e5e7c99d308a52bbb7fdab22cc7d86197330b0301bcb9df2193c675d30840f156873769a2a514e69bcc63cdf7b7460e3ce18eff9c427975df3598559e92c054f333fed495680c71aa9ae8191a5723aab0e50fcae276aa002c959fea826adc794a655c72f87a17e8ce79985f145e8b19c6a670adf3a3ce5cd22bd22f4b287997190d0b82e357e42e63954d2c27f58d3f5842e1f031a6a14fb91574164d3fa042790f22f39f29c9ebf87303d6c7bdaa7338843d2993f32f73201f28b1fde94b2b30c073eead98c01e2b9bdfa1b47dc95dc9e59f5f83503fea3fdf50aa8c8a01c05940f0f117563ca08744ab13f832717c900efdd5718faaedcef1c9e8a8b562e220d8292461b4be7e3642d9c6ca4c14f3cb95dcc98f56aa84156297d96d30caa3d10b357052b531d38f60d7c5350c57a9015651ce9e27fa63af8abebb419289dd0009dd4429ecd4b637d235564f9b314a948d4698ee3beb6a8b2cdb0b8236a0236249f1ee843fdd3ea2838d0a6b12d8c68c138b98a5edd58476c66938cd1260ba250eca5ca21e21a2beb1109bca8934b74718fa2fa78ae830c63f2f0850d7276096a4de750d095f3396ea6c26f814af6b8a11481aeb8292a9f84b6a7980c766f76b88afb9fe7973386699d4199d7a6021263d946532020d13a36374a0c278b304282c23b29dbed472fc460d304b802fb6a9284530c1ba9b4ce417f531a3da4321f96a83001f378f63edb6109e189af6998df7d2edff1fdafa49942f4df91238a8668768a174b76412e28853e2b302bc218c9cd83f4ace88002eea1ce72ced7bf1395a08fe440223516686040c3f229bf2d49533671b527cd26b47b1587c0bc04017b91277c7e494c5925dd202cbcd35872697c3c9c86905030ead9546d7e061196f34da3c89c149f4b63b8c99a647eaf3ec282ba0b9e19fb3343704a9e6ff71c39ce317be7f52b8b4bdb96ea2468cb11b1fefa19ff1e79274be157c82820e284fbe931e27ed5fa99a76eb5d8fb1cd5c6279451584fca2249abbecf15ee0b4f39885e15fb9b87b8111d8ec279235d9ae1a35a4b26c566d9aaaeb06d0a1a6d84782631fea49afdf87ffc7e76295d57c105de84576a86812d813d179065625e55e608db43313679a87e4b77af925d93f3fa7a6460e9e1e8f2ebd3e744f98ffb5324f48a728c9d1e2d809d6cc3090947e26dbac120a174575daf94961f9f6ef2396db4b7f71bffddd29da15ba1335886e7f000f3eb137402f58dfea371d01deba03984c34673de96d09ae686c41a720bb5bfda54d0a8d900daab362012b9b411eba1812884623f2d59f2ae707a325913221a8c92650ce0bb70b1a16b244b41c6ac2786c0117f038a86a27b0c9cf49957e10ec4c38199d54d5bddfc279578a0d0df3e729484bb045541684f5eb94dd35b8138d0d16972d34400ab02197cff262fcede063d22055ef7a6555ca4efd089b1c556aca28fd4dffe06795a0a9222be1ee2c9121c44c46d177cdbf4a3e63627f7248d29b58f64c8fec97108b8afa09ddd6b27eb2df74277c7c1107044ad196e441add117f8fb513a6610c7e7ca9462939202f2801bddc62e9d009850419cab9235ddd2c4af54ee6169ad3e0904043396418c31b9db0d9e9fd62d3796bfa66216faa4c2164eb9526c0c598e41ea041ecf330c4801eaed675e19287a437cc2ec42fcad0990a2e49d36395ef479f4b3c783fc587209b3bc49fa46d39507925db2200d8cf2b76b05d18835650e1be3078d755f18256c9ef94351bd155bcfeff8da6262a641c1cab41bc0c899da954351af5de4d82e7a28257dd2c2725f3a343c955b2d8fdfde84ef7bc91c35b274d59e3b30772ba4e7f94e8fd4e6eb44cd1418afdd43e91e09f88441cf94b7b5c0fdeb0c5f063df2578226607f38cbe5e55d5857ec604c298bf4f9cc6078ec9707741239a0785f50010cfb98ae81f0aeb7cc7515bc65dc4f02e93addb8dbf7990bf4939395f1b6967bb642fe9687d147f6cb5e35eec8e730c037fbe3eb132d78895d222f3145fbc33ceb9851ef7dee18c2cc95cbdff6940ebf5832ed2ad0b80aea4bc14cad491ba73c8ed7146302dd3443643d9ed2cb552da5fc4b4509eff9b659a5a96717d6fcfd11ff2a55f63d1b9dcd6fe64f491c1639881aa5a345762cf819d325e3d4c1a1151c293d9be72083105db5678582dec5ab25952ca0ea53fe6ac16ed715bf5f22b9a863cd2fa7d1ef9fc6e757fe2fa1cc69906ec49d242349fe80f0c76fd1a06bbc51d186671a22526203629ef2157c1ba791d7b6779b2269f06aead30cbc371c45a9508cb1fcc39b2629acbe84f27d2720754ee597988bbc3c404b31be3e290f6d20516509e25a7c3f8dd5c4aebf3bc1fa09b144802cdb800adec3c39cce667aee4b76ee10f533f0e6eed2990ff79388cf9432d23edc7e47e78cfef6cd46ec34eee2cb3db7b9b5f1ad3cd4ad3c70493512eef9f7c20812428edccf30acdd804f023d0e20cdff0099a5900012f8becb777101407576be9d481aa5a255f3f5fc2da4543efa3bec155c044abad8d3937c55c918f3371cad4d24fe1178993f6258afcde700e162bed22fbf8d8e2f4d3ac09231ef7cd92795ad8037aed4245ddefbf57b4650eebd10c964c05f6cc2b837eb99694a8d64c954657ef6e787fa47781700b95a56605016acaead3a8780a1eb7969583d4e9c3cea86c70837eaac74c51122f673fa19c9663a2aff1d28595d1cc11bb18ef8431b3fa12f84a79c538345784b43b65821d77a337bcf01592abb0f399d5b9b89b632fde214e8962277cafdce07ba03feefac68993ebf38f5742466ed41e2e0888ee8099d71786d538474531bb2de34bef51824ee035615c08716f31b9158a033d6c33535de023374c62d9120de38d56ad25eada2bdcf904aee8d99b5688b841af207d16ebb95d66fbb60b5bfb06a613b6fd74271f1056382625423ea19d674def19ab7d4a9c3ba9d9969603a29416908a4e95e6faba6d4fcc728a03b7b7202ad0434994cd551dd3f5f08ae54a0274a4040161ecf0795ac895fcde008a8625f0924923940a7a11bfd58e77c46dcea48a3f9e61724c7488d8419acdd707ae9c70f69936362483c3a14652a87e5d9e62707954fb2cf67e4190b30047719ed2db57b8aca708473c3b6efe432a4f6d392605928ca1dc6f51fac3aa96e635685350122a41b19d6dfcb254d63e4486172564b7cd4aa4a542e7fe2365b5a8866ee18e0ea6cccde1198a88cf73030ad38e435b14e0a1f2b03f7f4a8c98f4b5945f462ba5729a0d5a5d61dee2899fd011292bf8555b1cac278d2ca01865e7c19927e8a9e43cd47f848d5aa6be527fcedf9c3d1e55c758d8eace0eb57637c62c2f5e69dd186dbc5402839d7f90a4e15fd674402552eb9d76e941ac9375bcb3d5a0b8ded02d53c5a6df9d949a30a4fdc7312db3314fda801812259a968ae1d76dc72945ee254509ab81f536e35d7f02a62fac1ad7f8b7eebfb36ca5c07e154dee2f1fec50750869e03575c8f6f21c630ab8b4240bf1e5f59618cb10d42d47a34541b2b5adca8f5f002a55bb366881564b424f363cb1f696bc38d78fa98ef1a9e810e1bbecddf325b3826dff842fe4ed55f4ace02ff81ff318ef22704072fd652c5a2a2e820c74ebb1debfccb456aa061f90569fc49ead3ffefd5075093a436f6c6200cce1484d5e17a3dee6ae4b0d7f7c05810cb8c92f7e566f3f1eafd8890a3083ae45b491e93aaa1d7eafb58a8502c0038454dd10619b9c6c1114ed459aadac365c3bf33bb374f925010dfdc2325685e491c40f8a9414d0bb4097069fbaf58d99259ba1c4600d486ea4981158b6c9c8133c0ae09207a146a024293f8667a425f83ff7d52989ddc2b1cf97ed246556f35a53e51eee4c23efe4199bee7ac26f2153d4075d2fa518e8890900169b6fb0a35e2952ebb8585b3cd173e5d8afb8d57337b4b013394c00fc2d0770c1275b4350f86cea258a9bcdb6b7a153f6094930b9f34120a8b0ed31d4b73ccb15ef888fd80a01759f31b80342e94a087a0fedc0ee10534f113d1a6dd4156e5aee4ea5d17bf46e5590e06bad562ddf353fb24343678dee302efc5359ce31b2b95483a3e86b44c7029fa25a627d52b8a7a23c443d645cb1854e2b7049b5c1d635711ed3168bc0f46a4f1da4bfa886eb535d33894f2a3341b66bd2fd95a3d563e0218659cc5a250ab15416d7fa9a1a99ecf7bde68708298a3d5b7ac9b0d4296a50c1d967fd8f011043d44411baf65ab41957203b696c79dfd8615fcb5f39576aecad17bc2ac44249e4eb50990a2c1df142d3dfd633c4163aa65eb148e5c7bb59dbef496d1c607dc548271c7346a3067006ae1914698908cc13a31e06f03b67de3bd1082c1aae910f598c192c918caebeefeca1345d2e1e2005e3e298a953c51c66ce529b3718753902f20bbd2f73210bdd244df95045b57c7bdd3be733db744836015d7c2a331c502b1d7711cdb29587a779b8fa1343d41066b47b380fe60a7d77c048feb5bfd788d7124fcff70dca8deaa7d6edb7abdcce959e28b84af1e118edc8800102596fb991a5b9e759c3dcb764dd6e760e9b8762d5421ca2ce1a24472d709f10176cc8d10ffbd74ee6ad263f5a762118f279e83cafe6ed30d5a6d0c6cb0ec8cc74e0cec2403df224974ac0512b995f4fa7f3aaefd27b0524ddd85de784691819fc4194c4ba66e373b943d02a789059a666d3ee4477e109a47cfa3bcc121900ee345489ba707d41b8e85779b52b256e2dd4e9e9894ee3f3da4f9699e7fd027b9ac3e793309daff805ad4d50dd415930d75635e4b483d31545b774911d2f29d77f76443b48ed7bfb306d421dd41d0e9ed3e8ad5acea215f9780b33b58e6c7863dcfd7491e455afd096fba2ad947ba28dfab8368de02826095f41548ff270c6792633584f80fc703e1b6d12b04d6a6fc72c99137adcd2ed20bdfbdacf63a3131542e6446eba972296892af47a9b54f548ab48afcf31fa84552905e9ec207b8d9a11f9d9b8818cada3da868e330346cb3bb6deda3efd3d7856eeb65d1f3ed44271d46881e9202db77ab837da2740325c7cb641d13dcb30bad35d5315c27d03a749087bdf6b58b673b2a0703b64ef13d8865464af72d475fb3665cb528cf7eff6ea97beaabf69617bfc772261734d8f773e719c6e0732ed751dce990c5052ee20b5b5117061f1ce64d42e47090a5dc2a24028c378e0cecf47977dbf001d7306ff2dbda10f04fffb80efc14557fff2bcad03a2fa5ee9ed60bcfa5b4674b43513744ae659d8f3f882779099e194139bf1c9c3b1953a03c8331f6bae075191a5c75937b9b820bf43acf6c8480968a5642fcae060315514d0782b19b2ad313139e225dcc6a39468405cb09f70dab88276c6b3b83c2cd0ca6f6ea9a91cc1f93ac776bcd0e802dd7bd50921cd3254254b7bde665128e74ded7260cdbf5dd42453b2c037e5eaae71a9dd0bb8d80ac98f8eeefa68b720b1717ad8535f7e8d7cdf582fd9f1e7209aebc027cf4be307dfdc9f19b5e77cb2fd9e35123414bf91631279af7125ed246347ebb083f8576d01b5c888f7361a89424b3433aad8361b1a5ab16ab83d918ed3731385f80a071f505a11d66ecd66df48097dc9d662275b123e18e920b7793d12516cfd91c93892805e1479f1dbcb7699f8ea01cd579c4370587d8976171f3c8eaf08c13cf6bffc3d1ce122756c0ebebbbfbc9418ce34097c608bc2d1cc85f2ba1c4a56ce9a8ff224a20de32cb977beeb24740cacd39dd63cabafeb3709cf8332a7acc53a615df341babc599a9067dd71b23301ae462dd48b84a6bef696ff9f49c92c21fcf12f17da6d648597f56ab99cb43d7c281914b2370c8a3b285974296e77f83de270df627eaffb12df4fb31d91323034fe886e8f11ff0ea558841614f1c383e7d81bfa138d641128c5e3cbdcc62a0f3139675daa59734801e8b5006e2de1efbd71ecac3d7d8513107fea5e3c0bbdb82ad8e17ffb2bf4fa8906bcdd3564a1bd54f028aa36a16cc64303305f3529ed386aad502eed623e2f406166dafeccd6c8c4f9fdc5b0d7713a9c7fa55e62b8bbe33785d4e1d86f79c94ba3124496192fcb48dd366170317da52933801973a0acd56fd3675ad0ae072acd52639e7aad40624e79b791add75ea974d4cf1fcab7c0e4e49524e2921926c826504473970347d84a059a045ff31506bc4de802f4b8c247ff2281b4bed7cee8af95d448193feab24aed27f46e9dda55fcbdf23c0cfb82d61dbc7e0193a8de9b6f2bd2e6d249f683e39f051adfc180c6f1dc596a5fbf13598ba32ef7a47dae68dd90d1a7c557373ec7061274640f3e4f1a9bdefe398a034ccd001ee5a01b04533cb3f65c4ee64dcbba75303831dff1c60a45292b02e3cd27a369ed86b545a8fdea38a3b06d20dac31b890796f2fc394a0abbe75489ecd866d661d05dd6feb863b89a1314881decdd04531775cb428b9a9340b981b898fd760790a1cf42326567777ddb6c9b0b0c72b4afe98295e4839ab5e85ea486d6f2b5291fc21d3c90d14e4d81b12d3f639e0e6832c519ae1a3ef53bc1cbda474a567ff0ae123ab31ae80be0b6cf0ddb688f24c81a46c5c06e2fd7bf188db8ba3ceeef3b2bdb1b82f0d714687029d920cdd1fcacc6b3b330c93d21aa3ff3dddb772df7d99f47c0bf7937a12eac856f0b264ef0737fd0638196351b8291758e18fa36a727eceae6bbf4c0b25964da7bebcfe6cb5a73bc52b8dea570831bb98f74dc3a53cc748b5c1e55386b9821d26991dc12fe094eb203947eaa9989a684340fc43db7f04d461cad682e3573a03e1bec777064d8aba74249d85c28f010321bb2687ed038e99934a9d8e240bbc599bfde054eaade1f2f4c736d4daaaef06c8ee5d58602d8be9f381181be80bcd19c362d667f13be04169ff0be536b34698ce591f0208ffda6fce256a37fbbff5c54267f573716f0be4a277f0e33276b3c0709101a7f1c1f3856644a973b6c8a07a0458f7879545af24ebf3762932710bccab069bb179b565d072d939dd76be18390b1b4efe8e299b2130521a1e5fb1f6a0365be2c049c7430fc1ff6d0122ec49fc0c184211860f7c8a8f6837962b9ccfc8791579eb8238636bcfe78b5c751c9c28f4419ed00ba1ecffbe9022f6656faf7230198090e2848bb58900c22c2f2a9fd14efa1dc6bd61e8a38be4d4f8a5e7e2f88ac335437d292d1802c0a75ce400b22d2528bf3e167360698dee2bdcdb56f4d7f5de92011b1981555b49eb66a14c61f62f8f306493d364528651f09998eb8885500bf9ca32f53057676eac9c6409fd108bc4daf4254a420c7da20cd4deceaa06dd551f58116dec24880d653810204f6e24702899b2fd6ae70e7194af3ae8d0953271dfdf5db84abeb33a32c1071ad4033c8da82b916847f893b7843a800d99a5d32297bc6e1fe3c7cbb5c6d4a09d60d02451495268cc50c4aba0fd80bb35f4c9e31327d236bc0c86b4d24bc5dbab47310f2c9816773b65fae83bc11461cd06924123172960ae06799d3ea448df99d257f4a4602345c0f841d43188181745c0e97d4f107733091702998a76fe7841acbd598a2d99147745a5cba78c1409b37d366154e896a6c11fd4e6a1b610b38f2ecfed6f86e65504ce9e5f0e1b294796b248e09e468a8d55c5aebe2138c0ebf3bcc7633c4e48b47b5ee2a2aa6f6441e2a4acb1ffd0804be62e013a3b0a2170a3fc5be270c3a5f286db1a886992bebfae0f9f09552aa0b585962f1c061451f5fdb49d2311c60e4faaa3e05af437c1fd89ea573ecf697c18beac6d2909fb28a67f80b217e8ffd35424b0842814807b4b68a65d59ad769ec94a75b9c28106a521afbcdcf32a525ee819d4a1d813f759f50cd75e9e420e582b7710c21fdbd7c0865fc9af259e6b6e8d5341e398dbcdce56ab84b97323438bd07b6bc3a033ff85aa86853bd04bc06f0a18fa7ae0bc81f6135f2432077e73b7dad49b2388a07a3627e63001867c860ae4037548b1a854386ac5cbe95bbd6052436be6416c0c889fb78d5281964bb34d09a799e4edfc6d49ccf6ed2900fb5d22465fcada0152a8d1d433b69e9095261d3c4b9cded10339c3e48b32852a9de637531d2037fdfae36c2e1c51652926708ce238487eb7c132847fd2cf4e40972056087793c1916f62e36460d0a5e99c7a3996ddb57d50759857810e6f70aba1b30e084bfce1dd28f0140ee19d71d64e4b3f65e4a7b5b9f368c1d76fd427602e77ca670d2bb3a34a2ce9d37aa348bd2998b1d7c8b15c375378d5bfa4cdd727165f16ee01fd7324e4be9faba3337a504caa424b4417b01fc14147de7f9c4b1e666c84b28f0476c7f684d9dba595200e563b7483b923546e0286a33f84ae1d264766a0b0a3af6300c30d882772a2a566404b2228952716984848e67b55e516a93f7c822a06cbc23c88233b936b8d022966e36d994544cbfcd2ea5fa297ff7d00492d12c215b7e6290dd630720c2ed37c49987aefc5089296cc9bbbcfba6f6bd134a4b24b49c22719004ac6c6bc23338d56a399cdfde562060713e717eaecf35919dc7f3b67c1dce2c69ef0b4a48260c472d4c6b0035e383f3131d74d1bf5c5613c43a0567315efb3768223343223014bdae16d298c59ab0704785c0caff6ed39e20a895b1fe0a9303d9765d76d22a4567332126785c2e4d31c40a32367f0f88b15625d55eb5fb977db8f8504697814930b7010fe102630417a5ef62edf79ce3ce9f4d8e75e0f001c5c727aae243f176b01922832a636a53098971aedb7a30a8a5dc88df6ef7733a4281cef66096e9f47f16d987c7592dac42a896b64120a79575dc6ee312ae571651364e831139a64b21ddfe7cc34a5f5ddbdffe11afd64d8072f65891747420e4f5a6ba3109c53b0c7125f3a6598bcd74235fee584c36b5772f616832b44ca7182eb965116454d406c3e343d1a2a0414cef670df162b86f219e68350b3721edcb43bd98fc5cf6f76a1dafc7213829e62a17d6555a0ee94d59edaf936fa8074d1a86715361c309f46484f233a5c79d028731700d02d5df7d7c63a4d4ca0934e56324711278605ad35697cdfa5e4206e921d00ee87c640aaab313cda7c1075991fa01aa772d880bad9d62c69c036fb646b5d59e6b399dda3690393e8bd77d729f60540bef594481c31f840768583203e18175638fbbcb88517e73de13136f6f3a2cc817cc2768f8a024abc23d8baed011c97f1f607f5751e7fcfee38049ea3f41734d245d9a766ce9d43f76094dac9267018e4d4f21ac4c1b592a54a18e522e25211fe237b80bafc7a866c876f36ed3cce06e5213c387b5e17bdd35f3ee56430c33dcd413fc13209c66e379adb536566fe23f0ea974107323937b487834e8729fee19f3daa79a99e484e64e4e5e467a4c062a1e59724e1942757b3091706becb7a277b10fe842560ba85c9cd3c53adaa9b5e81cf9b8a998eaeb9818fe2fde402dc2ef2918a506fdc4ae917ff6f0f738d8352d972d935d1199adeb7f82f948a339370af685ea70e71ee78e193c69cc57ebe44716608fa53eaf13a52e7753dfc76c4a9d4df15812fcb6012a2fc7a4342e90d2f33d35e8f47ef7a302f5b0cb5e1c7b61cbe87b404912cc36c602cd310795ce05b6f5981d9a1f5ad42be86033b500b42addcf05febdc299f24d3c87ef971f2309f06f0bf16277d8c88a146d3ce60831e3d30260d9448613425ac4443761d89a913330b32f7d963762f4dc7583c0f706d25709cd06e6e5ca6bbb383a08ab6593623c4f0916ad5cb70f2fac3a9767114ec14c0f22a82cebf41ca1140807f14b2e92ec96dbd636bf7037ea13e4e9537f4868e2632996394b65415080ec18c7b21dda7d48ce94faa560559218c886942e1c538447a83e843984d16a365d6da80a11a50d509dfbe24cbf8f144fdc14c8245247275a4f028909f33a9259761c235653177cdff328a0564a745caec7beb2cb7efc95ed2f1de82bd0699ae35c29e8fa063c17254ac25848ea0bab71e2f9dd2f1e235e5fd5fe9cb011247e8b72eca2d92164d8bf23effca88fe0ec9dd8907f7ba9bef5023b5e237e36a28b865d2730d70f8d82074559e958faca6ac9d724c9892cd02e305193359975a79e7c65aee0b919c0df04c38ef4cea4fdb532e0895f8b88fca35b2a8b78ce20f914061ff9168bdd219007259b82096e3e18d0b5ef49882a64496829c038e08c295a4f91e2359e0443c156dbe0525798bf8323b48a2f8c9faa2a2300aa67310d67cd0ced0a0b4c96456fb800181daa72152d9858e14644f9bff5e36fbf124cfa82fbfc5cf613237a9088f95cb4376edf52957cefd942e70f70386d3e578bae6c74224258af12cd8279138504e54c0e82ff266fb330b6f17ee8d6737b084fc6627a0ff202c11517782154df36de2c55883ac43bd4bd3ae4ef9252c4793ec1c10a2ed6e65bd6f00994353c8e1243dbfd7ca5516822365eec9ddf86b46a0c8a4778bc2e58c256fb4c02c77e12d9962f84c0373d97966c3ba17265040c8d882e04b7f1fc2508c4195cbba2d8d2cc80e98e6fde07205edca4a79b248dcb654c8d4150dd681a73e95a3e028e71c6b08d2031b087c685e9a1e12af140d42ccd4337b729277c33d55e1cdbe69135f3c1857d48418b1ca976b596e26b0063ed298d2be77146531fbd50af673ca5e87bd9cd2d6743133337db8cf9916dff6f81836602fdb88434df2b729462e82d6370724e6ff2b5212b9433ed2e19b1aa8ca9601d13d153daced0208b6048b637d9972bdb9b685ba8b010447a4cb6fec6b6d63574c8eb4c7a5ec6091a6c09beb46d3253daaead1390922f3d765aef37afbc25703a28621c5d58d56422a0957379a676e9d64afddb70652805f13d04b6c965653a1124a7f28c9d009cc6eb0c94423ae15a37cedf6d6b07b9e99b0b7aef37ae13c9347fbd365ec362377b1a3fc686b561c5e2cc1c9127dbc016419f8051e2c35c13fda81f8753a785fbf94b786192aa853245c6d47e3e10b082cbd414c6d4c961fbfa09c062ecc47aeb926b16f5b96b70e89bdd0718a07e576d0c3217d0a132118dfc315888c292741f10c127dd2c2d6dc44c6a2faf4274c0bc230e77079a5d61479a1693571402125e1a5bd9d62643032d5b9c9d7a6953f1fcd35fe157704f7495f2de94df244fae17b4dffa984e4bca625afa25210b44166e80a232508b0341dbf59d2fffd42662317cc75a3d93df4c16da6ef465b16e14f935ef0e968bb65419f28e82d35b9a05797ca997222dcc63031398d738fc57e480987985ffbf9d0e2734e6a34ed3f4b92bcdd579740e99ceddf20de795dfce5d3f12dcc05df389197f7d8befcdc31c19e75eaccd7daf2185af0f7cf092991ad63186c992e82ad10ac1a59479bcbd3c04d65bfd5d7302711750e92edfd6eee19e81304691ee2eb86cca506eee8d77be8f6836fc73253e514af5fd916b1d412d4a1769df38c2828fcf17091b1e80d34057746ecdd36678f2004aad6a98f4628403db9387a1842c7d8b93242451a6ae404702edd8391494d056b082f7920ac40e13614550a62122d04c853e33baa044af25edc0b0813fbd8e05e8c8f671d46ca95df4291368e8fa9e15e66589d57e317a36efcc9f8ae60c35a6819c2a1e0e62238bd05ec587ed8c413519d5c62a378e4e97d3dc690cfb3a37ddc6509e981d4bfce07dbb3eb287d02da064c6810450754ba1a3d79ebeeb4c087c981aeeceaffb09a55f16aa7330bbd60c653de9d3323d62c03e445ef65cdc9b1a00db350db310acd1336ac51208623c7c1fae54ff4c2c70450ce2b5fe734e46d05cff07860806528df24b36d8bd43af66eddca0c50174b5342cd81d47881d41510d1747ba3771a7c466df44fed0c4811db2bbee5f8d2d866d130aebce64f3a5c0bc49b9fd0fec69916435c9fa895fb80e432339f77dcbcc2864c0b8a3c7e2ff70f0bd869db0daea6822f0425f2e146dda39c686d4376103710a84c53461ab5a53a462ef6ee4858aee4c4ff4638ce8dc36aa7e961b57c2c3b428135806b50e81f63dc70d8e368bf2b4244af83de69d251163f43f112fdd6e0663b9fb79f29e37cb582ff9cec34486025756857f2f4aa8e6ac31d1b0d43f4d89b7ad6469a154fa8d1ec15d203a562559ab07e74811b0d37be5cc3a5917bf35af9db548355f9760bc93baee3106c82535af742d28edb1c2bc25ffed99f918916bd7b75b5882dd70183cd5c1760dc37ca4fcdeb4f794fb644538ea46ae4c3df4aa9ccba566f4afbae939d2e1fbc79a5f9763e2b892f9a2c7e9f8a0952860a05bd13717098dd8fa7c1dd761a9ffab85f89a10db961827e8ebf29f462f7c2a19fc96415d0cd67331320b80147517945cbca6a03ec88bb5ed07b06929766c015dd28242f42851112c298a964c3477b35bc3d13ee05614688e1904b058c0a52fde172e91d907a115a0913426811d9600877872bb1c26c3875bc47e97010fb90f401ca7d5f63154578cbf4319ef912d06336925cbc346738e131444fa35f1832a638414686dc1877dae37fb6efc4607099f99aeedefb8b382b413e7bd89bebe9ef10edd2c7911c792f17ab6b0409dee77c115af8eb3eb703d72c947e2c652a3ba7df71210941ebbe8ff2f83fd7be6b0faa7f746103d06720f8349d97b1bbb6cdc1548e2d47fdda493598c5e5a8ae1948ac5ed1a14ad43d4ee82d96aca29cd9f6013ba9653129c4b303ed297060827fd1eef22a5c71ac6dc43e3ae17528c37c9d6bb6cd0e26dcc80348c267c9ab4f0e78fb5a6855185f44d7827ad05d551f695ba6ca6c489f2e99a10f9474fe9786cbf58fba402fb344b18571e8f5135f0c9f3ad2c192602a671abd7bed90b3037389fa41c7251eae23c22c3e26338b45f7cacb0568697faa5919c5b89460f1de06303252f141ecf390ada6abab2798db143ea79206191234df913f10d4143f12d81dc5d7d120ff995279a9d244ca565a655db5cce6247014e5eb9c26123204dcdc74fb03dca99174c550aeb5ea32925ffd5b9c40602fa7b949a63b23b848979a62d87109acafeaae9b961c18074d911d01ac52bbf47bc3f3550f641fe4a70086f1223e99ca687309ebf02383a1b89a1b73a6bb3e10238687c1d091451808fccebb5f9a6b9410f0504c0186366295a032c08a8ae00051d8f30aa560ddbfa605915e2bd4bb9e96386ddee95b9a640f42b0b99d962a4a369b55bd7494a35c377c538b5a4d03473024a83adb25445676827806f4a236f83a3bee881e436f2571258e58baa0a9b4e74da52bc9e152a68ed8fd35185139cee1fe66158518ada6eb148f17a2ff8efc86f9ba2a051393fbdb3fc8130abb36e60e082f12aac3419fca4dedda7320589e4eb2383317288828e33d5c891842aef90e0dd99a90b3137a3ad1f30da7db620c5c7991005d6e16ed9cfe93e21be1f914f18262131ecc046ff28c244321194ae64fb40a85fc685791cc92af00e45d45e4a54af3baf2eb0c8f28caec9f226e3e509704527b65b8f7a51ee52048f2bcff29bebbde69aba9fffce15558a49b0d2dcfe5a04780bd3a37b0e902bd568a95ae218d710901f11dab09fb0bd51207b0f1c96271085c9d1d3c82431f808ab0011e7dddb8ed97888cff2cdf0a37624eccee4ccad10eb79f1354ba412f03225f4cfc12a612a6a0fdd7502f00baf2f801b9d97378ee384f654db2dbed760f13294049b4b241bf1d2301125770586464e01eb0936f6e95b129f135c421879f13bbc6aad38da899500f27d2ac8afd9be54824447cf1e15824c897d40794ba7b442214332af615506eb7f646a7fb7864288c40461b87db2139d2c0887d92d0f95394ab9d93f5d5a8925168bf77359646ccaef389e208b00e7eec5fb2eef2ee74d6f6827137e9da1d2a8e1ba7fc276d5bf10204f014fb4c7707bd9142ff02aaa73125b82b2c61cbfbcb61ddd81c7fda388085c938f8b1c79bd8bc5d64fdbb1cc1743ed17167f9d260ea8c61b5583bb152d5d9694514252af325dcfbb03917080eb85eb7b31edc3e3a525e153f2ad4997f8d485063c205582cc677f41abd1a3ef3c41b1e86065999921e06d01c0c1d921394652372d4ab3901551f1b6e533ada9029460d0d90b89b73e752bcd8f4b759f427dca29ffecd10576b1b060c043e0cf1a644bbf1d6681dfd662395fa685d26799d5b0660b17dff349734c16027ce793f0a5c0c82529028db65f4d2316468ed14071cb936a8419b1032edb4a3248f7114c6e18d48c14a98ef4af28d357ad6b29c3af5dca54d900801dcd06c5a8c069cde7d15f1f55895681b5ee3247b4c7dd39767f0c7b32582ef4edef380554a2cb71f3d15724f2bbf6b3aec819dd5d72a47d92d7244b647ecca26e7c21dd82e0fd9f06720e4b63207827f403d2be3056070f04020244114245dde56b144277593cf356a594075cbfe472cb6c2b125862ebfe6a9e80fc43d376913c09d9bd6a0ae48d11773eea919d6846c345793ac7021edcf6558848d09f0d6225d98ca223f542b9e18a8813f7553c77b83fc55347263d76bfdda7400ae426f095e6f986d8191b716937110086aa2a6f6ec0dc06325b5c221a1f23f07e8adb3db68d5dd1a4db97c7de7cdb9ef031b458abbed9d6d7db113620301297dd3599227d3f02c8adf670e70699f091f90e1a38f1f3dbef6df273caa663b104ffbae0655accab3115d5af8bb55ae788fc444da41b65c39cab1c23e18e3f980847bd912fe06c265f9a406dd3bdcdb3f7c57dcbdc320f9c735a77cb5c9f08202958335b604b69c91843f01aaa29020196224ac9b218d463f7febc0b0d1c2a55016cf1f3ab8fb442278aafc4f5afb0b1b2dcc012848cdd006e939839729e5bf1af8a49a6a1d9cfad5d224f24a6e5a7b9e2a2a50a35906823bd12822936343d5fad780715ff724f0406732d980bbdb0395f7a62e8b393d1ee8aba78963662348397afeebb0f29d25af00af89f9fb82b1c3d5bae755a1ddb290560e044884db473e339372e4682f79e4de54e9c7b5a2f7441e2682c3980cb74eb7e440a26848e87088e0a24df0411f0521c5ba39139c557e92b19b6af2138bc77fd9a6ba4113cdb29f33a174912ab16ce1fa81c9e98c7c7cb5517de337242fc8c063de9d65cbc67e7fb685c01f869681e819d58fad0f011283f342fb4e7453e94a189032fc65c25a2478d6abbdbfc748df0adff6600beac20c31c17c623722b7aafe13702d79637ca6327282272c83586ff17131a16217f833ab86ba767b10fd49e85fc98c8765b299a6b979d296be0f28934cc75fb0077909f2bfe68df47360b053421e5ea9a01c273974833ea479fd358fa3b8405fe2054a061b3dc5e268334c24272fe163869009ee1ebad45276b510b5c52e4ccd5d43ed57747cc0502bc70b95feaca426ecb1c962f8d379e10c9e511bacefa4f86290f316f372891214a70b91c419bbbed93386848e0cee0d9962c0adddf62703fd09548384b54a3a35efda9b2bc3024765a91afe016a6d25f66c250133235b98aafee5e3b1aefa556f1825a37f3eafe5e0c8ed0e34a57cf4eabbc8e8c2b9f90733e3cb2bca3363d27b333ec28b80031da4914bbfb773a940f0ba061a1ae998ddbdb004d63b087dba024f82b8d206742b723038c8423324052250917c75fb50fd9e4d5b5a378f7b48a3df63c2c99dde6e6d7793520660a228f407094fca4cda7bb6c3c7cd19b6da5ec9c83ae637cbac591b23ea56cdc94cdb9d70e477f57dfcc96ff276fcaa4dc40e043c6685926c8a09291f733750bd69ab6a15aba221da5acba25706de0176b87a7a80e97c8d4003c1fdb665faa124d1a85385b57d43dae9607761be395e9e834ecab9f211dc4a5c7416ce16ce66d5c77876b9eaa79fafa3774f0a46f24776eca22ffb1983f5648cb5fd5ee4e6922783411eea1adf906c452698d3799545adf4d29cafe750da156dd3e6ee98c7414fe904680c13cbbf2d1875342d41487f7f061e2c836a99cbdcb600f4d4bf94bd40ad5171deeddec3d7cf7a849b97c7c036c37b07b921e8e7b4c38eb4ad4d5600a94e2b95c7acb075ccacde755a41f5d9f30890cb08b25b849dd06f1e5a5e3dd42557a15d307997d7c4372e1962613189f154235159543ac8e4a2c15e84411dd05f539ae8a2077afe2e83e34c8ced7f922be7e1ce3ca75134836449c7bd361429a33794ba0269c062caa8e853f3e95076d6f79b028d4b2c3f3f7793adeba1072ef36dd7080615235554249ab538f037802e2eeeb78eb870a90b6f5c41d60e38818d55bdff417895fdfe903c8ac4a0314087983c05b8cdc1c84552f5bcb85766ca1e19c29b62732160f712a3ae9d35e39244f40a3436781b4a82750b1b33190c0da0b6978855d173e2d3db9f4206a265ee91c8de22d68d745da0fb6dec956d1c9a6316d148f1df70154fc3ab4a1588b357763faecf26ca4b1e014d6ff5e4c1e8dafca4b4030b54cb1bd926c13dd4d6fa254c9840fb90fe3c7e46b12faaf9d415d5c30514ba1193bf20a39c428bb442637be89f4745df5c62e8dad5efc5ec2c483b7f81ae07474101a7eb59ab5dc507070ad52a3f5459fb09c278e33f671b23d9cfd689a50e3e43d7bf6fbbb25f90efc7fe7dba02be2510a6864d6d62056402c9de44388885e64c0e019ffa2934aa9569063d55046314db7fc392e306c08c9c1387015a2d00fbbf7d320c94c74b817f8465ac6cd3b8a8e7af0eb84b7c3ac4752acbc906023a2f44c455461afef137811c2a2e2a8920f6b85e4e5c1040c1bc3f96cee53df36551f22e327beeb2abb44e35df937044e3634640628321f5e8fe2cb5a61c0889f6cb5dfee0afcc09394181fa12d9606547c8d9addc80236cb8bc32ef681df16522414f1791601b0088deefebc3f9df16f525ef7b4edce872518299f8fa22fd66519d6b308e4c800ad22bd8675a95aa491637698ea7311b7daea2546fb2f5b0caa1c86941f4e266063e9cf67ec781d18929a37f3bf94b1fe0db1869d1edd784a1fb7e44b48f5fd54b3f7be6d6273e9ac774d31142e1e9bba366413858d3d1f9bc06b9f830273fc54719b3de69931f5f1ec65e4c573ce84e892342a23c33dda3c12d7ee850890441ea909c593cd60a9d4d73eb091a2e58bf119e136acb1e32643c9f0bfa331d9f85002215ae53e8b542777f654d6fed1c486031f927ee4fb46776629ef29fb37a7e48ddb97ce2ea5ab489c1058fe8cc59751fcf0cc73139cc451aee88222d8d0385f2e4737ed2ad55830f20acca52663508588b5712c610d3afa5394613ab75e41e1357cfa02e9a56886d192961565953d4e9a6b1608070e7011de0719920a8f5e730c824ae0acef8de2138840ae8f11932f83d4e6588b03ff7a8ed3c0d8fb667f3a774d63be854cd5664eb42494dd55280b329766940c396cf6769e27f28b42feb497251fef26f02648861cfc46a30c64b51bf9678fee6ca6cd4569505a6658f4488080bcf8a943e16ce90df0efd23296f9e3299d2fddc72e02715f25203acf2af4e130497cca70a77832886f724b2095af0351eaf9b5fe44c7d31d3ad6c32c43d08cb37166b91ce3a0324f73a847f7b95c7b4365873a5b0bea9ac0a43e314d89196de8b2159343339b8339116269881641549ce22add15e8a3350775ba1848c2b9fb096371e461a084bb483ce6fff377db0274437a3c7caafab351063852fcafa33e19b81035195fa0fd9b89cbbdb7ea963ef446defbfd367ff8567dd23b808aa1c7c8eea313e8421252bbf5dcf271f45ac1e519f7c35cb85de587d9183ab2811b2b3321d59bcfe47f594e606763d21bdaf420fe307169e96ba2b2ee39d22941cfe74239915191e3a61d4dc723acadfb245bae396dee54d3f8706e7d0a7a4f033d47bbf09ab2af86ad260653c767bccc6d06853d0c1566aa39b25d4be3333f52750a51466000561392608215192fcf4c02487a211a0f1b533263cfad1638a60bd7d5529a2035fb0ef6b073270950c5763716a530af04c413ab17eff3de44dabaf19c79d871541bb6265f161753ddee663fafc821ec230cddc39c954a511e821a587f03a7bcd8172327a220f92ad5a4b6457350322e8b6cc09b57314c11d09be6482d310671fa7a8fdbdddf8a8bdd91bd373cc54a6b5e1e32de69be99de272c6ecd1e6bfabb21dc474f525f7659c7fb9930afb82d3873ce22ea42f131f9b7cb2150256bda678a33bf0cda947571997486d783df793fef78605a151a0becf8f6a500bf3c344453a7a34e72543cfbfc4921c39b6e8878d0e0bc3e5953c6785cca3fb1beb47c579849188b4acc7c74d8ea990c49ac34da44e4eb9681fef4c80a9da682c95be048bc21051c9414fcf42f2418b48604f1f6d800a75cc9a4e6e33a107af30fcc1223eacd1053b1c1539baac1ef9c076fbd5b05639a8a99968cf70db2b680b487c28df6d2adfe64bf9fc733f8003042a55aef159a33c6e214b0af97a8501456d72662107b1a079f46881230c91823cd0e112b972e93c2deec7c0c511f54cab61d26b5633bd0a30bbc6d04c7969a16520311b16aca89e3f164383b04a686ce9dd7ca75e495b304154e425b88ea6a1d9742f42c67bd622738683c6ab3e01837968aa92d1eccc83b3b7d5ff7093e7ba55efd8324d86f4660db2803e1e9b6315b84cf417a8d3c5391a2beb7dbc3b23f0a6429757c505f968158261c5398b3cbf41ad51d79bbf0428f60d8833adcccfe6b8c54faf1fbd2d7112d104bfd9998b9193dcb5c0d6aa76f2670a2f1fcc690b42178c3401f8def94c14b405cc5e6be9337700212813b9c29de00e87042b55c0c740b86c3bf83a6a71d2309342fc0418c53315409efa93e57307e0e978b6711f098a49ded458f80f3839075e5215ed3a54df8ff60c00641ceb3e040e7f8c1c337bfa465cffc49e66b0e01c321ec86cbcdadb6a202c9efb0802b73256c4c52d9adc79de0a82663bd787a611740249dea78e77e393963f1ba69f910c217bd8970b9aec7e1f9eb7e076134c1bb3e279ab65386377f3e052a5139b19069327d05af616b8bab5a2c1de70de1c0d87479976f260d137ec649153f3d827853919cbd2b5d722b94ee6fed550a398453368daac20f5f10213c867f36199f9830a3e2e3de3bb27c31d1921f80bf60eb0e0e54053c56c76f72e1aae79e66d5cbdc0d7ca8cf992d2cd9ad2e75f9ada51b9a0e6b18be26c551bfe36f702dd83fa1df10f5f0210a49ecb87f3519ffcabe83d8fad337998f0b10bacc83207af8c17c6f730975c5b514b2096bdfc64b4502336af080c5748df47f018d66d05a7e34cd81da4b8c9afd162aedab5b7983f65ffc937e7fa74427500f83c5adc3f0a9c90be9447861c156f6c00c94885d5ada7d18611bdd7930554e75448515def19392b5ca71c392027d274d0f300ba0cc7acb4f0fa202713c088ff2626643cff1738c26b221be2cda50a82231c5b08c88221e4cd76c11e7a3b1516c884f06704efc4943d006988d29ecc6561925b0df01ec12313e756b6a3655494585e0a13def0a3653fa8057522f6642deddd1a9a9d5a32604d22d160d4c27d5a10c8ea110e6bdf93501df88478168f092ef911ec4c1dd4f7a6f0b9ad88c3944519acc194dd31cc5d29edb5875ea77fa5eee4c2e555adeede3b6ac0769251da32d3819b26c849ad8d51cb74de1b3d585b02e860bea8a27e12e9b2ab127aae7f3e2a2ee866215eb02e5e23c16b4bf224e5c78be229eb0d91ae28326b2da9dfef24e6526e285b22906b1ff7e834119d0404cf7afc35f5bccedaa8b673abaf61aa26486c07ac757d295a2b53a68a9fef4ddf9eeb79efa8b4e7eb21fff96149aca6903083b3f7fb639b949a2867c9b4f381814ca652f0d1061ac9ba86ffbb593bce924e09d4f1862a6ed489a9994ea852b469f384e03723c72ce4a4c969f3ed8a54c0a359823c5311ba0657bf3a026b7fc21de4a430629e7f5e0d6505a57d5a8cf8a128959a6c34b60164c88f710fa912ab403b5e2bc55dec2703665081776229037d0bd165d142b4927db500f9d522f8631d487d533876e7e45bdbbe0793cf324b8c837c9b4527ca043cc1c3e8f871aee9379ce6aacf10a1da06b39211842dade4958c34155bc26d99f3972196144127348c25fdb36cfc0bf68bbbe086254abfe499f0a32a45174461dd3e8bfdeb3b603e3847c05343fe12a34563ea51da5170adffd0e70c93eeaf4914ea28778bb4b2f34e5eabe3fadbfa38b25cd97cbab3c3aa17e1f609fab9b58ec8e6e890d6fab840ac5679597e02b8daa4cf6d8fbdf0c370764a13b3a4921a49717db13cff15a38a13454b52654b7e374c52a86dc0614d27f3163a4dd5c4a3d4833bbc20acd822ba6743056786563f373f1614706bc9f9fe64b5726986b99aa83df589618fd1e0e9e5bc79f73aa7318d1fb5fd99da511a7ecc7775962ab9bc3b44a3429314c29b3ec710a72d0a29e2caf625c509361fc6c55def6193dc0121ccb4b510ee8ca5c7ffc4240459a5bf5947c015b81c93adbb5aca531208685056250079cabb57e2cba1bd3defae37630ec809e2c779d5ad73fcbfd396e6f230b464fa39a652802d57e84c6ece4f1c665a3ed1b2ea20ac7ef4c1c329d825f268d97e72e63bc04c1647f4f670023611f9dfd7e5703740394dc26ecdcc49a4427af1d1c715e00977a9b0f07c9695319266a09cff4a91707f0585549160274fdfd9cabc30424c91b83b03b208a4861bbf8ca3cea0ee80db50e5ea592c84463c59031e609ba774b19b247eabf47f2826e299b8f861be49e7aea8fddcde3650d3474ad622837c18aa90805d8544aefb28588ec7de1b256a9821ba2624544e9f9af83428cadf5eec86375695c70d7c61c7530f420dfab9db9dd7f762361c3b39a07e10ac89525f21f902acda4bea53f49afb6330e47f5b9efd168ca13750f603fa8fe5eca47104cd1df930d9864acd3ee34d14edf70fdb4042ce6faf8d48e4bfbcd2ac8c00fb35311fe180dd39c24bbfdf4283a5acfd1ea6049cbbce5b0d1db39e19f0ec9c8923ab9ba9f4ae9655c64bb39785462830f017108c1b5a1c3501fcd7e7f261ded5553eb83d6e956b3d06ffce7c70e68cc2adc108647d321dcb0f6099b70b277f2029645ec3efc58afbbeec73d0145883c0422e1b3bcba5f64baec304a65ff0b94fcaa674b360104c79a140eece2401fef25b466337b10d9845e043a452308037f4c6e3d880dcf2ea82cd7dd4b49fb90c9c2956c6b43ad6cc83ae10b0d497a9e1d741678f3eec97d892b317c7a4a95494d5e46ad34c76795a0d6095f9c32638e2f6386215fa218949554e0442bfd7ad1899b4f6a9f369613a3d6fdc5f2cabaa0f18d9956efb25c63341945629a9cc9c1a0e20941987e50d93c668bece624b2e979063988137cc82bc5d532bd7633d150f8934eda9455469bfa96d9adf2027a30a783b87c30a78014f5b48576456f382e90384c6ffcf084b2219a991e937cec9a02d657af56ce6a79436869a6f4a2354e25804975a3cb3b9953260ae6e78b12210b4656c925c2156ec8127ee2d2926dc2fbb22f4448fe730500ac6173ccf5efee7e75775383af27f080c2b29c45759df4654525137d09ac9640ac7b7d33d426b69191032b02dbba1ad7eaec7b2b8deea07a124bb4aeaa3495857a6d6fec367a3fb2ece24ab99f255f190d7d35f9a2f0cfc891e0709dd34efe135c6e971e16da6f7b97e35c6d253d00b006894109b4fadbb5810d5a879447ce3177674556321b62dec3bc351a63108c5cbf2ea89583997aac62e82ca3838470b0d6000731a645120e81ec44013ab9177d6fba8e627619871c49e7ee6f41dbc3a748bd95a05bda6c38a75bfe64102e1326f4b3000deff9938dae63cdff3219000828dd67e3da8ecb23fed0d73a563855f35212ca57bab204655585b1de8a5236ea5a8ee91e662bdea39aaef28b5522297f62513d5f1fd5f3e301f23c6ffeb3d0e33e5c1014ffa3c48d94d625b4f3ca704e34666c95115e65d130e4c9ab8333222cc04e4bc49502e82065aef594e8959ebb3d64e0fb0ed040b01bbb71ec0168da3797e33b33801b360331433b249d5d0b78e8b9c698194e48d458ba22a1684549240ae9d90268c12d172ac05eb5ad4c82a2d849d585a0262e33993fa19a52186dfc1eea135eca49b01642ccdaa5dc28051c3c50a33b497c5fba925b95ade1390aea11bbc5fbf717f88f4db35dee89be32d21287d9561f54465b5bceed42d77d7eab56534ccd3bfc2d418db395f1f63a17956d121d1243f045f9eacd296360b2e8176618a324f88b701cdc3cf4631dcd6fbf08a1a321453b2d09aff168739586695731145510fb284d2a22b0d85a2992c8556e678a7503cd9f1866be96f1f70ee63844b2749415d7f6ebe333598e03296fdbf6b0a21271a483d9297aa5e91ee0af3c9b9ff221498d2e58021a1eb80438eb50cbe9d9306cbdb8b28de398a5d442083b5b3843ea92d850e85444706e4877cdacc5ca4bbbb2bed7ffcdf16f5781526d8e913dc5c30c8885e8ec5781bfb5311630a0c619664e1300ca4dc3724432a20a24669521d7bf82773a4cf39d663ff24a6713c5777e2fc2ccaa990286c18953217bfd39ec9b6bad5f8c3e16d56590a7e8cf666ea599ce60070fd69b4bcc6d610684606faaea0343a05494a26eadbb04dc738cdf0ac123f20473eebbda9d835c9d5d5b0d24d56205667f737add80de18345a4880550ca45887386c4129539cf875f93df17df559642d669a29c7fec6d81f75afc66e1a942c4f21760fca61c88079aff037d6fe8a8590df3e8c72e491dec98e50b7ccd720cae1f0cf798232fa189221a3922bc3fe7882ff0b1ef14fd7a0d2e96bd03b2a2ebd236489eacd63e9b9d7a544eb54aa6b510567f47706b9d5d5ee1eb06421f795fed52f70333881bdbebc0fa5ae46345461e9dfbd7fba6dc2a1b5dc1c8a44c6aec1d8e63c104f03130ea1749515ce16c166c1eb1fa08c4665bf64009472d518d128470ae2c24418a24e73b0ce2059007a2be4fb86fe30f96c7c586672e912c2ab0ef9ca34d015543edbb6cc1a1f33bcd640b55b917be8ae8c880889df61be3ea57a37867be02a1c742d03ff24f86203e6a01265fa53f4670e793704c471644f7311e506e971c06b0632aac5666a8dd2904096be052067faab0fd61208aefba8715d10f13e2ac61993f56b0bbeb9a9bdc44a66a4dd612eb6ea995202c68acdd9001bed6abedf255673025b1089561dce0d5ae09fa0df642f2eea4d9bfbcafa818b83b0b23367332c599b7aa3f528f9322e6ba384253851421ad8d1f93b4aad2c745a11af9899a8a3fd39f45e6abfe82d6756586c9f41861e82ca418dc9218cf8619e0bcb2b1b7664cbb8f82cca1b195926b837f4260b594edc430d01a29b688ac83d7a50d70920026e04e2db09fe641f1604e8c480b0180be682d11ca4ba2ee0d4792be91f00a2fdb27ad07d241d1fe4c32de84a3ec711d6e462b1f9f7c7869c75be1f84de983dd81c372da455b05d67946c773bb89c779093aa89ffc356193aa26b7c10fb6f8529b9074a5c6ca0d393c60cd709609643587a0097be16b7525d5b78c979655240118db19edf40502ed5f058605f9fbedbb1282bb6c54ba00b54be022ed9a8576bbf017a510e7c9b6f6a4926ff4430ab1a959e47fa8f3937ebb94903d0c76d3be94c9ee2d9162917f717b3ad4e3fc82cd7457b9296e25e83858d5e8a9ae42338497152b20360a7e48b976e631f035855b206b071e2129bcb08110bd5a15eb784180c537649704c35d1a0bf82005182a0cb431a4a913a53c98dc472319defe17181016a74eb2d12b3df7051c1241c6a71be69afd126039691702af9bfdcd5e30f3ff99151d8e005844299ce40c3415c454b8e8c817b311b7b7ae85240360776276f2d90575d808aa4ea9d5c0157f63b588b70abd669538c62fbe092409cf8e4c90d3faa6d83842273322daaaad8b303dbf2b47b4cbf1ee981913fb9e9b959f6366cab7e11113b61bc6c05c27723d3e41adfa46aaa47bed3cac4af159629acadb9ce1532e4a01f4fba9190c97e37a8ad9ad2913a2e447d8cec9bc3ddf2c6943a60047fe0a146bf6128c6793d73816c9b8c53b4d29747b9f303a6ebbc659ef3cb4b3df22620da7db9fe68fced43de11fa3680521f628504145175fa900d7e171cb8ffacb986aa44317eae592c408dc4ea50aa3c9ab07a1b52b817bd47e4270bb469914f24ec9c5b55c65afa7874a4c4c39eed82b0c436f8a785024902a9b5b1d3dc1006f5ffd78c26882563c4f83208730f34e84b6ff100341c970e44d830d7042dcd0d3efae3d2628732759c587994b2aa812bbbeb8da94d3f395ecd725a9298e0ab4d8c5522939dcfcd658983f2585b503a7a31d4d85029dc03c316ea88082a6001160074dd29e73911d901ae9471989ebfa31ced4bd162a066a231aac59bb98c65fa86d95c3e3d56b9d99f8dbc7531737acf94f6a62502e24f8a5eb9b6ec380f9e003602b363072c2e2133636023a6a39eedc6378a727385da82d71956e42f93d6fda5495b10a270bde7c828bd47a59a7baaa5f988947ae2d21786f41fdac35ad91649cc2c1e933194558f9c97dd61ce0202ae01275dfac95488820c88568b3d4069f43d3c9b69740ead815433c9e4d7c3783fc33ed7062f4418d32df6c15a0b44e2bdabfad50de0fa9c2c40b3ef527005ad39edd8c17d050937f77a8c94819b9d881a10f881a71e18abaecfce9e3644645c70054fe5c5e97771d8f4115f6e168a46bcaa9b2253a37543d75a1f0e75f2f35a8d4ef223bf74dc0c7dd0ad2390b9ff5bd951875747a42ab350ec45f3ce6fb59c8f0f24481881ccb76381aa24a5a1df539b7f493e9e7d34820cd19c7762f165f964227328f2746a20e5286530d69a187c603b8ad21e68688464eb8470ed543fdba4c9074a65421681cfd01b6624192e028c61d0dd27f74a6ade3a8c22b355bf0e5d724405ac7fce94684d67600948b55916cdd41f8d0d6519f4b5ca725321de39db529c4b948c3496038e4a242aad3eef8f243b640fa57c1bcbc48898f07f813a0f64e36fc16ced963caaada22a625619356cf1fc97a39d5e1241bf74c21c9404d8cd8a354998515bebf1e4eac92a76fbe020d8d3bacb79111bda107725a1c27ac427a26976d50acf8b5b637cdb03e538897e9660a5e0f51013456796977f99e979bcff56b2a00a2ffaaeb36e0109e2589c2cf2f5372955824d88988535a73ca4b47b8c123b504338841587c9874c433fb4c1800c16486dc5fa26279b60c02206d10b7649bb06a3d2421cba5f984c9616297bd7bb92b4cbe7431e8da241519869397e664d77c64b9c92bf415e2dde9cd81410b54981991b5753b5d9efb83b3060aef914028e42199651cb5f191dc9455c1e952c95e4a7f27e97c65c3c208891d4bcbde399eb4bd07570d8326a06f1f6d8ab3e596ca1cf04c971a1d37a8b3f7991ebbe51c7641eed970d79585a1e4460261c1f5f6e846237be59edd1e62966391c6276348ca5b4f68c9bf0edc11f262f20ba04f30ddcdd8e3986790915b8bc29d4b87098d43e57a6ef180d7b9f34054304382b0008929d70f33f0324971b2a0ffddaa75998c705d4e8bafdd3349558409045e98e19f94ce53789b77685faf5830b394c3a8f34fc79e6d8f536a515c07dc1811ddb244c80971eb98f2c6b398a930456207d2c3852cd54da5c1faaa18c2bdb18d95b96f3bcc41c49621a676fbd1c8d6e6ff8bea30fb7eb55c91f832538b862bebd59898a6a5a1e21f8555511d8c32c54ab311f780f1b71694cf8aca771a1a7a94d4201fd9c65cd2526e7fd4deb7d1383a9fe0b40131fc37f6a51faf8be7f94bb166ad3941ee42fa9f888da30f9f95afff01f8551ba9e9420661f1a034eb7711b6d01f7bbfd9fc8753c95b251d7b81c12f8382539c4eecb94b9a790af996656610dcde701cf10e3ade614615c8a2f651ef3ff486452baf771c67b5cb38f2f9d5e5493f87a923769212b8925c4899fa7477d7744701872b017a2d95d05ef317e40a675dbab72901a2854df5a1fed7ce1d7d0a7094a510aabaad0202b213fe7dc03be89e4d4d699746102d3bda142dfb0889a94f0755d66509e9f39fa212e1675f60e2a1b736ef19090697632f97c919de4ddc4c7b08d4662e46a9e612e2c17a82dc80448882dcefd02be8f68507ab528385f18c6fbf41132f10dfd673df96aa1e0e802d1559ba61d3cd5ab8c98ca4d5b1a910e07163bdd8f63ea55944bcc7d03574670add5b93b99f636a36b640f6e19d35c3f13bc4f99208e8addc64b978b1e4494086844f74db12e14deb9bb645419238842f5039fa3bf9b296d1aa94d59f27c35a0d70dc88ef47657c708f25602e35880d1ba17d71272ef09b4716c64e3230355afe58ea30c5c8eb9e9799d35945a42f0eac6884eabace7337e656c193d712cb1f69bd43d7271bd3f416643d0fe0737e057b5b3f059241e3eb5d25472853711dc85f1c6b19f7a87ed3c0f39e04c84dddf5d99fca06dc469a130fe1d9ae88398fd10c88c232e65dfed0be0fc7369d9479292643bdec0686490b6bd90253ebefe962640f22fa145d1d7a71037874b8c22a438a9227f535d4f42bdaa0c7e39d2f0c0f75db24841163341097c87a8632a49b1b2221f57f3dbcaf7babf43ffbae6aac6ec0126920ea3154d892ff4613a09d08d1a25318da4913cacb4ce53bc46ad11cf121347e1e688800c3dfbc4cd78e58b6a2aef1a2734a461b6a54fd3b658a8a51685cc5b9c9bf6f2f3cfdf0daa9a3d2b27e87fc9dbd1ade81b4344a1043063cbe6cf884adc02ede36cf27366e64287d5f453a19dfe03b32e9a4d5d7bbdd2632f9226480ca31e60675849a7f5a21bc30309e173822675b8d7eda95dc9b0f8cfd61f050c6a64ec40d4fa778f91abfcfe334ebe1e631f2894da1023009da857c6d876338c4d03f5792779fe207451e70184ab18df9698124bfec038b29014e6ce2a6bb1a1460b769c5ab16cc7427afa50f99754114bad6b51e4286b3a5c11fc3098b36c784cd9c48f9bdd2fbf7062db0877769c9984af5dff6d190af8fcea6f9e8a522359156d606586eac95ad39557d6bb0ce0c36f42f626f4ad71dbd1a39b42c7b741ff6fcc23719ad8d4956d5e37542fad051327459d1cebebbc8789fb9f3da87eaefeb8863c99df0eea02d6b7c8068266bdaddaa05cab789c1671d151a23679d2587da863bf4c07673ee0db70e3ac0ffa7661fcd5f631c3af34caf29e992a7b1af13e840e0b56fcb35ad1d9af91dc3108ed28c936fcc7eb54bda6c1dae3cef3a14703e68005af42309ee769aad840b72fba84fa94f01cfcbcc40fd103eee80f5963b86a343e3bde64bb63b97b0626c7ca52efb002e4621930f9034cb002498eedc8982dc1bc83988771d7d1d41e6b6ccda81e3ad3c8b7659d5a78f9d708f22c6c9f1ce4e4e1dc073b1aac65c634f1786468b1f760b464b2acc1a5979b36108b0fb4bafba14015e400216f3457695605244885e1d400d76b69bd7c8c2338c7e4aa36c4655fbd4732ad1b6daf26bef2da92f6045eea663c3335a7b7fcaa4f5175636a6e830ac379dfa59a5251155e01d73bf567d51bdbe54df729eba928f6ef72d66aaa2836b361705c0b31f79c879fde37c1945b44e79e1339a7958e057530709346c91ac717055fd638bc5b3be45176cecbf6d5616fc0e0db291e41bd81a7df91dbc89a56a88f2ff26e9bc3c91e31600a4e3ab9bb6b51ca44725f4c0e4c36adcc6bd194feda5026b790ee57566b0ba1c8bd854890133aa451bd2b01b7ba67ca84307b6d7e398936949a50aa7cf17cb1e7e71bf3c9385890b4f3ce5f677a643164dcddab91d908cf121b5a020894b4d0ea3a26f143586e2b671805fd3d2bd83bf12a103827aabaa12ade562355593fd6620f94cf61bf50acd0729bb483196e1a3c0de48d80557fdd49a08ac265be2cb616cf055ac2382bbde681f46bc5710ca8939fafdbb20771cf7d1921cc46b66912a9deacd7371d143394347413f2f0c3a88d50e2cc0196fd2c48e72259481dc738905cc742e135387746e1bb20bcede87d205d0cf5ef4345277c047f9305f7842f0c6536f125dcbcd6def3efe6cf5c96353d7f44dc84b7843562269ca25ee755a019d85bd846de63a136d71aa919f02122bdaeb006087fb6465bcedffbcb2421ae99c6c559c8f3ca3fce26a958b2a9f3c25f65541b603df9bba59e1f6420c113a12dbd0c7b6d7a7e7148083d95bb906eec14cd372b2360c4888ec71a9a1bdd8354fafe6a6508be86867f40a5a2007496270396f0efd92bab966e70f3a2936087feb100546fb2c13b92ceabb6b396fdc3e7a754b95e848afb109494dcd62d1d5276d803ea431105ea2b740d88af7e8b73a06a40626da20a484a09bbc2b48ee3834ef44da1769390b7ae5bdb4e1d664fa70f38c1e149fc48dd097f9ecd78036aa32828eb5aebdd0143ffb41be741134f1c2095edee0107f988be0f976e5828ffc770aa78470dd2320ac88712f3390bb9f25a172cb3861ad5674e584db6596fd380fd3522c4859e91bb750241f6790683d9a32d16f892f5e7b0f92b65511f27fb7db8d2198711a66cf679a063b071efd3a542401640835906b0264c9026754b454cc29ccd13f2b47a013952bca0946eb4a88f026c6fa5e4f3b49b564377e222e906d8d172bd19d647db61adf81d6e4c1ce46f31578fcbf180076232020c681331ef6d1378f49acc2531739d3b4fa7f4f83b96263daf2819160b9af5a598c5a20ab6e1d2ae180ca82c6c9017e128cf61f817ab8e8fb1e344d4a7177afd59424296ba0ff8aca9c1f777441ccb07d0269c047e18b16afb99302c49e9e7651408091c6f5fb3c366efc724b5c5915c6cbc9993d031f8b835f783e645cc0c266ec4dac8c83f5cedbc2259594e47f446386befb05b28a2f8ec48089adb8781d7f54d3cbf07a1c2cc65991bdd6579427c7539e933e8bf3247b9779d1253f7ae3b43d7a65d4565ece28fcf518e0ce76bab87e3a9cc502faf163920412eec9925c0dbe84df41e74240f11eecccfc90c016c7c133c53d00180d029fe5749126c91ab637d11676ade17aa65590e6714534aa011dded4f07b1bb967786b10c202ab89f0e0564c7b15af131b40a95f0b3275d3f8fa0b9622f0f8515c80984c2718fff94891f898b8457f8e3c8079e104dab8960a3456d27782825b79ea01287524540946a68cbd6fb6d2ea9c7d59a365a9712960759e932ed77d13923a2092613c81505b8f626378d667f995002c310bdb94f46239a8da9d6326e7af8bfc47c98b6da0fa6db90fabb8ffaf16b5437356e004d7e2033567993a721f6b06137ddf02013753a53e4982568f4a628dc801f54c88480308a9153a4756116136299d2f0be7a757805cc3ac8a0564ea188b7ffba2320510b1638bfc109415a51e1b08e92880b6c026a8dcd7627112808792b33d99b669cee47574273fd17158f85a6b19dfa7aa2e1f9b454eadba9bfd7e30980b1f7b814c9e27841b2591a02a78dcbf0c344df435645b70fc03adb26c5acc4e7cf35be42aaa8b48648aa527dd01ab479d9c41a93a556fa8661cf0c9c00cd815a85ff6656416274064624d64fd68dd7e77bab075a6df43c9a1f7ce7430d181687397866cad8fae04a36bb649d92218cf4c087799a7ec02e4dec12f8b7591224a0e24b16ca23c03abbe469578a63ad22ab456422ef39725358fec36c4d818abefdffd343b2ce2a2bd79aa219721dec3b2ae4562694e50bc85cd100de74f1b1f3706aa2fc32cdebd112a458f0a87b67d8ae39fd04d201dda71bc05cee86917df7d23dda415e3ade8babfb02a46c2e2104c07e5c447e36c47dd5cff5260b77e1bddac79e4d2e929faeccc776722cfb3652cbfbe67d57ed469fe9d99bd9b0aa4c2409bd8162e8769f950217c93def490106747648ec2b3301d7f62eb10ef4732abbfc4dc21938ad8b2dd071312a711707770ded4ff8fe6d3c9f488b1721f39bbcf497892326952cd6aaf220bf11936b659ae286963f94f2c8839fe424df4974ea23c6cc8a0d3f8efca13d377b6e0ba8081b42db998db6b86bf406cea47ef1d5b847ea5e399a9410f9ebd166037f621a2cb97a8bed5b4140521f53fd157558a549e0971b2205c7b0f3ff127c768f20b50d7146ec226920ae724fdde80cd57e121b37992ede0b91a1f25d2352c18f4534e06b0c9cbea36d67230b5484c15e4162afc54f76fbf2f911a6c505eaad01d63c16961460a56a2c934085aab723385c7a4b93809aa98636c3de83e27ace885e54c7941378c860a5c846b3a46f0327ed2953d790e880330b1f545ece78efcfdfc3dd5d4a6724ee0652a8dc19227d093465e32fb05a81d93e1f491673f5480f70b70079be3797e6a95ca547b811351a6829ae63ec3ecf6d072fdbe84a7324e7e7a75cd0f24a6e103314faea13a06cbfc1f2a38023fbfcc91c0a8610ddd77f6acfe02a809a6cc42ddd00e5ea0e6904141bf515bc66d8168f753aeeab6d282f9a3a1fbb57bf604655e6a3ea6297acffd0f3cdc7afa25b2685aecdd91d53700007b1802d6827ad41d417dfb4ff89161949a410c491ab9dc0865a7b1fcd8ff80c44fd1f086d14a0796118e9bc6c73f872f69a93f2687743ee9fd6760e88df1b30f9a744ca969185782d922f8d15d0e180b4090f182f659335176a3969bcc652182bd5b86fa49aa85756693a0b9e0435877b8544cd93d27d91da79b1119ff30f97ffd8bb3db343edae33c8600fbb11eb69c66120f8f208872879e17dadab1f970ecbac291f758d0d9aebe0fbd8d94c4e6ec1aa7333502e7201aed3d6a30d79e5888c216ef6ccb457c35617dae1f139c288081e6eb2c86432b9f531da69b9e195328651983b4230115a0e1abeb7e59ba2df84d9a33cd2f9fbb337d25e277bfd330252aa59fbd010af5fafe43603ccb233da5c0f32f1225ca262b920e9186eb75e2c6e5135565a2bb6e9566f786d8404bd2f45d507357772dcd9f729ff558d92b66575c142115e88c9b34f4edb11e458206348b6a84b81b0acdf7868cff5fc2a7822332f6dcf582e3129987016c895ca3ad10fad52c9db61ffab45638478a335d72c8df5ea4b6fc7a7dff3755b3c206b710f337fd3e15bcfc3c90e3173b3749c5c4d9d8c6d6ecea51f8bc04485edfa8f29e93f35e1597eb65e11c47fcb33dd511c902a104b1da56911b97b368eb60e2570db5f0f74aeb60f195542fbf28ab56524335b77085ed2e865f951f1a087c9f5027ef488fa158c6c4209ef855f1f8b32508e85b54a255fb7615bed99b06481dbcbadee8d791b47f259d05449858f6daf4d665314c1780e8ecb8d26706dfcdfeb3206fb02d61ea9d5557887c6eb7c0493a0d07aceb307ec796d624db12debe2506581396a21b98207719346acd3b2783f9bad6e8ba3b11258dc15451de2e66bc38fcd7741ed12c80ac64d93a7d007edcb600602360ea1d8b4287c8cff0af1ade19dc2ed678c88a15069fc56cdbd3d2b88685a2b2e754397de89985e4ab6bdc51484ea89b56fdbef8d456595a8cfd475397cd63cd0c9292e3579e60991aeea2b8503ab8807f5c84e5f16e681a0c51508f7cf79330d3d35c0b08639e557253da534359e2b5323611db71be45cc2168169e75bb42883a2377db68bfa284da36af199a2ac8a2b65cc6d6edb983d55c4e366295ef0a48488442a8e4f707287b729dcfcf86c657c184178971048e9f7acd4e94e09f444b26cc1a5ce7846aa0e58807e3724a167fe6374b0ea3e4ce90b5e7c040f429c0e2fb1a4470d36f701801b0a825d198554817ccc8f185eb67fdf59b2eba2dd440b056f6f7e7e295fa00abe0c71fd400ab4604ff6445cae3140e8491b59216b40714835d364bc032211e02fff1e7a552803337dac6d54bab920fd2fc7cacbe64c2c284beb1e8ff34d8c2a82f5155555247583ad9347efed201c7f3867edd4306260cc5008fac82513b1c30df60b869edcf477d9aa95bda00a40789c572d5e8665ccf2203df9b0c3a49586f0d8ac362ae3b0d7a4912f0a9616b648615f49c7a67927b8400f5e85912133762252394299f5b510de505687483458f1eb9e20b1e36427640ed6723b337444f8d08c201bfcec0f9f096dafb7ec81c428b3f872f1609c4a9ada1b87ff8dbf5e86a9cd4cac11f7deea638ec65fed8febb214f3f161f9d6e5c0b25c69581db860f7b0689617b41755ecab084806116529e379ef8ea4d1746b982e5fa21352781350b1fe5c7dd26f17ec01a2ce7bbab4cfa446a5a61265998ece6aee5f088528097974c78f3906072c6df334e5d0eb5d8813c58ae5665b7d50292402e228b1e0a900a401475c8ba04ae75755a693262f8095956b6339e5f61d88f16ae1d2ef3623f151478d5474e22f9fd6e43aba03c4dc2ca40d1a88d130ed5b4711e6d82568c5ae08d9e5807db8a1ab5f93146f3f2d5524b5cfedde6ed9a9b2ea8174f646d80374d8b2bf0502db98aa1db91e1cdc76ade909218c82200911d3fe7652ef7573bfee31b38e12d6ff6fc36f5465ed962602d9a327cded2c6b8f0c081fcf25f523beadb98d3e36c6ec94666b34850776c3fc4fff5e3c50ca45995a81cb2b015bd2d8ad74c7795693756d5d23246eaf4819e1ebe002eedab4db7d431dd12ddb1b28d9d5608a6ca9ebe372c04f45e20a4190a884141b4b45003207d21a46f19e410ae0e8363f917230efb3ac543b878bbec8a08ae10663a8ffedb7d417ba67ba9d7a1dd72cae04cc6924c7f33eb31bc3f0e01f91a869b86e4a1578f84801d5a9aa9cc751fbaf3c973aa6f1ce339aa12e2be6b8cd992b9739187e7b2b26407b33c7511c6437529ed196205b7d52605c8abbe3ee27fccea8eecec78c65dbb27017944929adc64e948aae2f432be6a73e2fcc27e3dc8ff2607301fee9dd660a7c2f621ce8f9026dc416182d9637b2eb9311d44f71985dd2780ac52e959056604fd0eb68910e3a79123c5b64b377d099fb0cc2597e5b500f793b4a64ad1c1b85ad1a4773ac63d0501c5d0462a1c3f1dfdeb250a786624f9f0b322dbab6b7bceb84a29ac71eedb184bffd7a2305f2e30cb0407106edd56a02e6d5104c14461f49de1b1b7ca2af3e3ee519cbb057d119ac56a29d350946992b67165b67b4fd9f06e2bed27852a7c7b551faa6c2303a1ef22c49fc6d73c0793350596ae1bdb56a74331bf152e53ea1cf20f73d6bb17251b9f391a604dcf1f40b56722fde1869d9eb2e1968509e1e4820abb5c71ab9875732e98ea3e312f965eb1b83265042e7f4456eb418ec75c1fb24e41c9ccb7b183c34a78ea296b97de1d70c63c25153478e21a2f3315ba6b9f0e92756c1303045c459904f914cfe4cba260e542bf7197b701c42bdec13ab2176eaf850647effec07bb1ddbdc47ee55b8b27bd3294e98e2bc7913cf4f2c41650b9823b6956092bc7850a3c262d7d5e092e40597ad63050b65b9b6f99efcf95d9ebb00a03de3729432b2e36f4c23143d1456306cade2dde26844893e59add7bdbe7c54a6f6deb463c7f3bf7312d4a09de093d02404a417e1cc8aa210612ccd8ff7266f7d01c41d24efd73dfd8549d6c7b03cc3320542075c8aa6f995e816d2240d57df9dc9d4d358fe98c7e3e905575373f71764adff93ae334ac9132818a025d7a283a1bed024186c72b0b0e1062506186bd2a8e787083eabf4c59857d4af25fc74e1e9a3622b2b25dab9b6a427a54ef4f123595a9fb659bd933f7a81f397826b5780e0c9e7728bcaf33d0b050a7d884a8d0e0b9fd64205fada28f7d100b696ae79d1692cbf401fc0974dcf93ece5365c559809a94df0995bc9a1a7a4eb5238b53e4e51b76c6b0f8c5dbb584d458890df80fa980460d04ed90b130bfdd96252cd8e72518706e5cbfa1ac423f8da610cd4b1eeef244eac46c4dcd89151616ac75631037452dd853cd5089df85cfdd83b9e5dfff25d4eae54bea15df1308eb4656fb8762238b6f26d74e563cf3e96c54b719039c45997b75658e0d064c9ddb9da10257fda731c0115c2fbd85d1a632793f170ba187644850ec1341374468ef1a138c239635e1d90648596f9051d5fd060f47d918a452b060f7d9c57086fb0f9f7018e6df0c1429dec0217e2a0d01c52925fd2bcc25ad4da8a62de93832407028ddc80ef6e7ded8f6fb5ee551cbffc1ba88661b4a830c0eb84a6b4792a85e21a9a7bd7d3a5e4ff703a4a47edf5c24f15b69512c112d56b5ab4d43476291a4e5ac9aaadb7722a288972c6e6864309414dd380d51b9806b8859876d86cb0a33ac057857d8a34a6d6c1cb0c5282f6bd5a9ea4ad7b4ca8c6eecf9fb8d61693763b9afa8184f6746c5420346ea24cedcc8887c85e42f11b77f0538fd4b012fe15a3ecedeb236acae90a5fc0f59982b4e06459522f63d71e2b53d0e55fc6005be81316c7319da877f978ed5a59e2f0a26d4a5a544c5b38e47a3b121a8f0fe164910c5301de1ea1d70c4df58d0b25c946e441b945f0935c59e97f2905387c5dc4b9761f2968cb61d60ce16f5858c129e226280c18a059d12bc3f7c41da57c94e426c818788fa350a4a8b1e6adc726a10defe82d297cb1d45d785839c81134c6d79f5d675be151b56aac130534329a3552a6a5568fbb8d9fcc5fc586f73d1b7cf1c7cf7b9d1c9082cd5b074e3d81a0c8203f1bf6286bf7eaea256f2093912ced5eff64294f1ba23be1115ee0865d40b351e7a3e68f360f5820769fcf25e1d12aad1898e3aadc97e309b3b108c0df9aebf2f89eeb895992931b964fc761425d9751aa78800e2e5349f60c7efc60b594b54c2506ed34236bb8d691461918259924dac04987b70cb54eb25ec8af872766b00dc20583ece6a7b1ecf480d0801dc0b1194143fe31d74cb681de33c7ced331b8a1fe1f43e1c8728b494caa7f064c146a307c2669762fb201ad18b56e635c76943e64830c71029715d64893833d6b139a435125db8793b5b7520c7ac22aceb98b229b48952d5cd403b8e412b4f268be4e64725f6729c78bd37cd4b211b3d7660cc1a99612f6a0641c23f23ad2ed45f2c7f1342e1e0ff6d0eccb54cf0441ec64fad485c6d38bc9232c16f96cd4f8e3d80c9d873a84823c9e910dd8b82988a18b86633f25ee81e51baeb59685a0e9ac903f8943b3820d5ce862bd17d22f6567b777d873620a839e074ddba6583fe5d687deb7bc29cbf8cf7d173cb02c0ca8de57009b09a0cdcefd1114ede96a242ddba5517987af326ca0fe060fc7b9eead3aa80d867606785ec27a7d5127f13b500ab57c80da24d34fc3009de388f842cf0e2b8f023129e8cea347ef5f968dc46f444c282668dc4b64d8887a40479433e96794fb659e5846a410f7806d54743df53428a9b58ce246ec6f76aea18785176d2477bf528d47d33579f4d2f864b82ab4d9f54e998393f9284c6387e3daafb3bebc6f14726e68ab4ed31430b02b0c6737c1268c4183cc8325133647b12e854473021d8b53eaafc058a8a8db89ea5091561cff757446afd8a20d1c608e32a4c20efd32a66519e95fa41cd1c2b1e3159acb5097d12b5f60f02b9f3a0e1416405df09850d6dc44f432383f06333ccf7250a443a81013e6d9e743875b801dc126ae4dc226cdf020bc198c35c78e20a9aeb90345f983a2144b789f3a2d8266d10a59bed910e768fac2b80132c2b22d3ed193c97a1f425da9217e23e7bb994b5943b3eece05f7ee7340147a61edbe4092fbaec618fc912a941dc8ac5f281e8dbf45efddd829366887fd247974b3b72548010551f3dce0aca9531b01fa187003c7f736cfd35646d49163e03735aff12f782f6e84fb742c7b9f3c13c34fa76f7c0a8c829eff829dd1da171ec9454c83a4697c69a082efd028ea52a2257c6c12555f4510328b94ea6be9b39c368c519e45ab8d7a953aef2b84bb6815aeffca86e97387b814f86dfcd27790cefa9c25394bd09807a8f86e5ccc3f667d57e1f043d4bddbca7afe43e373201fcc43a8584d46b1cf66930e0a5b19be414c69df1790ff0a4cd59457e020f9f3b0e7e45611cbddb1e10db29289ec6310d0656b3ec88c7541b63c96d75a80123708ddad3ae26c83c839166ceef0e4cdae5d750b6a4d84e5a62bd129c5f1674b3d865793dcf03b71500724e9e1b45b988fb80f4c3597a7eaaccd72851c438bc9c2b3864d236a804b13755d5c3811a321caa1d8ff96eda782adf765f0a155a098c1a90026a1b217aa765774e045b63303ce38a0e2db96b111b8ecd1dadb64b81746856a061a7ab92c2e1ed26311fcb8798378da351f95e8a16ca8190d5fb1e2e8ed79042aff8627fa64b5209f3fc43ff9a435b8717bb798018c0c7f924662be74bc6c7d85f30d338247ef087cab40dd16154fb86a9d9a2a49ee485c08f73cd3a82ecfdb498667cc75ce6bfc65b6aeb70a59a80ae927dd5a04263d8df717c277a7370ffda1dc76ddfb08948bf6701dd57d09fde4cd034bbb95f6307a2358202b15e9a565b5ad311213e608a95747b59fbdb6054a0d4b2606879f67eb6c3ee372d675c06f648960b78f3262d017f53237c56e959ae67a6271accbda03c5de206af3bd4c028f4bd5039878b2b603d33589f6f6511d45e5ce03d72c1485c37a30967e0bcfc46041d5a754426f268b030db7fc252bbd4f39fd16a72ec4cacd708bf77035d08a2985a4744ddd017a57b892e2d4611b5518fba9f82aa6f05032a3f2038914a1b5bf534d1e4ee7096bdb85e662139fd9473c6b4e2ad2ad5d158b16d6322b38a2e66badb1715ebb60d950224ce1445f737c656b63e37cfd49d3ed1ab489339201e40f4f0b58dcda625c503f05b8a17c1534a9bf254057e9a163149281aecd8d0fc3d4ab71c3b7f8d9cd5af909b6ca17f4b407875925b90dfccf7f390b72051da3a266937f84ab1a83aaecec8234ffc450d47a38b8fb512df8dd3fa8a48097450e4440da032d3428715bc5fa6b0b8acd2f4cf42a1ab8e8e3dd97ffd0b06902d9ce36c50831bab68a4afe0135fc75e1d785c6376749ca82e7eb032dc4871689091d6aa99f18685354a374389432d3b3d0470a1816e2cd724487cddee0cb40a82e73ddd92bfdff9cdbb2ddbb4d2e0310a702708f70c9dcca7000cdd3832986d6c5cc401fc5156078bcab7d69bc3918a0f6e017f4ce60122166551523c649651888cc71919efa731ac1848ee9f753d46606634ca3d507812f8de11efc540c77231c263a03bfb11afa4fc13d19d574832a5f8da8d444268df095a0c3b51be71e8f3dd921229e76aa8a2914e8249f3da30b7b161b7cd832398747726e0b598143a47cd9737893276d30ff8bde6a58605acde3d868d0890c360be66ec74d98cec798be4c9109b2877f23608c09fe669996f6358abac8db74eb59b10a65fe6b68de21c6cb67e1af5b4cead3a3d16cc86c67ddbe4776bc3cc8bff23775e90df5f357f38517c2cb4a7d9027a96128d35a7bd0eb92d56589a6f73f145de97e5fe1d668e4256400184eb8a5d1482e92c2b05d3f07028863974b1895110e25d37e2871d2ed913b926a9035d081035dd2471df664336b4867a381c3f1cb20e113308a0198f75f824bd5731dda380a6b8bfb6fc608389b515a3903e8c27666fd63ee8ed7466743a151dd5cca5f31a90152399720e29bb4063417d3314381d951f61fc1a2fa2db98188d71d6ece6d5d6aacc186cccf8760cde83edd91aaf04541c08f4255541ea86c1fca7931e16f5ececbdf9aae8312bcad360a8a97dd5d32c3474600798e8c725e8adb585af74b11e5a32a7f2b72f8c03eb976d739de842443e669e9b55210988b7474a5d1c59ff4fed2e1bd399829a8c1f6dc16d6cbc9975f7c799faf7b93d0a4d258856b7f42e00805d73e751fe1872e187b3fde01229cf3503e14ae32083d6cd1a514ef6dbcb5b8a0dfefbb339d476b1896f9efbcc839e98467fed409024f1857c7b0cd7f914f6d3362e9ebd72a84f0896a26496aada7d7b3c8e69bcbee1eb8d8f92aecad4d28be95d4a29a89760023515f116b798d6df80e9966a21ac9172963a0089b3a8e2fcd5b7c528581319269136cb3c875a1c8ffe3e2cafee7c2013203a34b0e2f1b4642bbad7721c4c95f4f8503c3dd781b2fe6215894572468e29a204b80b2ef5c2342d834063fece9958b98d669bc1cf3cdd298ee5b4ddabbb11677ab247132cf0461ff75ff4a3f2dee6cc10b0dd7e37d3c6f528b24e842a2271d6e20b866fca1e016583d147805723708b4938aa4ea7a7b016bc2d8891c5744d64d5f325538b31d0da6f3625d5e2fa8e82cd34a2dbe458e81afe5555a7b67593dc65fa995aff64bf9f427dc1af927351a7ce3329e4f80647021800482e8f34269c9b80e0018dcdada02ce6399d2d2e1b7096a1047e6d583d9525d94ee5d393e2898960f7bc5251444515136b9ce97a22bfacee58cf2d9654d58155c2193ad34f3ce4b4d73734d117858afdaebb9dafea48b1f21c45628db500e1dee8fab9f44fab07864517084eb414524ed75b1420213389e16f775e87737332d3392edd31a65a4816766ace6350be8dd6e9faca7d1132e316f64ac64a4840b4ee04b57677deaa4d2db55764c6028ce5fe4ed82c5c40df93c5463900598038299039821d7c7c5e480f569033c5242b0b343774aab9dff68f084c2078ad24b08f6af03e7049d0cd49661f284a2453769ba27c5e1f908bcb1581559d67cdae2ef26466a64e3dc511880a7b5ad80a7f04aaf05b679e1994bda694efde7c5ff8c01821fab808d3feeae4b458de265b4cc9b65a633dc9e35caca9c253cdba2035ae5129851412fd623251bc137d9d4b489e300d9dde485d46c2beffadb09bd8ac2f133672d59aa3fb1649e0af9d5a62b79c353601c56d24576242632a3951cfaaeb66545c94499a3134add478a06c4a5592b26c975e3078e17cef69a560a427b3b996d65548bda702f61cd76f58ad911d9cf2e5620254dafaaf8e9ad78b8472c3ad18e717dd48ed85b407b18dfb1e868bf224ee57520b83fd44c0d4ec4f69945b2091351b4bd3e362d25deadae160f7f80f103a9f8209b3fd4886c7058bb370fa537835df6e169e4d352da19ab3b021a2d630c562fe6d88fa47a6360bea2afb04075f6c2ec0bf560648b80f0ae8b6e1ee205cd71016b0f6b4bde3413bfe7770203763e1e2d98b861a61e54a9bd39bf9b006870beca72a80d0a97f07eca2defe89a1f03cdea1f7306941ef4ed38a903199ce86ba8174c2a5bb07d2e7e5b9349ace93cf8cc886b57b9d8893393fa20bf5156421e2a727a49b621264cc550ef8ec6e4d66f9eced193115ccc40c9e774e927f74de04dc72b2d44171b900b0b36332126c5609ef96a42d0ba86a0f5fbe73761530787ed9f66451df1c0e5b56518f1d6ef3117d51f9b87d4e91f814788ebe881e69fe4b6d411d175b6c2a319d614e813d7fa95c534bbcdde0380b9db151fad3daf9b00553a9d9b787aeeb06b1a0c921e50669965df188038ca48f6087b55e216bb39007739c7a16b0aba87ce1054854f9e037d7db58e53edc010401bd3dac4a4b5669d4fbdffe661d8ead56a7d95374716de341256b0409fd175355244a732aac3377e923bc10bfbf91fc2a595d5592925b668fa2f4b9063d3afe979886d44286159e804a6b7d211c81616e309d10361ab79fb99d6a59f4900a4031faebe19bf36edf507b2e08fcd7d45ea2d3f8d4eb5e5aca6416af5b5b1a454d1317b0da012dc1f7074a520ef41d72e24ec2296d6a021c2a25879c548a8706328b4dd410da85de30974bab66560f97f94fa1f34155e7ae1522176f858ab9d25d937d38746228ac27f8f84ca992195cd3ca653c4ad948ab0e5a6075c4d508501e6d415e4708c0d59361283225b19e936c0a223d0329d0e3d125eb409131ba09ccfaa7ffd9ca790a2bbf98f4751dbd2fdd512ecf6a751170dd63481a920de2f309e16879bfd1c8923f90952caa85e3bd717ca8c1500c7de9cda7ebfbe2ba37b0191198ef565bfc26ef2ed70785cb1ba75434a8a65d075e8b4e8e64e113df13adbfdf2eae1ae186fef9f9cf32b17f6c3ec92fef997aa84e222e1af6606fcf47b934de6214429b00d55f1c2b596e79cb0a0a24f3c5737dc7578b38cac29b8919684633ec4482ddea16a48a753fd73f69c55ea6739a09248fe045261544d74867fd290c09766919ceeaa86f3a38601e7ac32e4add8b3dd33607355306974a7fbb1fba772e8b775c374a6d72c61537c767ef17336509284b2497a9f520f01e12a5a53d7311a9bff2da6728eb2d4b519103eacd0afce4125a59b3c91bfd1d2ac6d776984b8940a2c7d3531cec49baf774325e7c0205e4cb2cfbbc0b632c373ad92850bb6a6b314489f1cc9cb87a0af04ea70faef7fef1f69e5e7cea9d22ee573d35a4c9791f2c0e855a2ae9438bd928f90674df3c9d65d17146217a9837006a20f0095b2ac0367bf5293747935bb928d7dcdf1d4296bc6398378ebc4d2205a09fccf55d7d15a3a46736ffd0aa605aeae28251d8fdd45e506a9acf117ed14decc837703a6984aab83a2e4d679eda9ca7bdfbe52b02d044b807307dd510935892fa4747a6c0c60213b88b47aab186830161ec939e9de72f4aa264657eba8e6266df3ecf33a56a43414acaa0755707df4a68736725a7665e8b38d8e2b6d09dacd60452153d3a6d2d2b97ecc33c2fd50051ce42c7a69fb7a785a15b904789ea0d5a8c6ddcbbdfbb2cb8d8583be911a32b51ff9ddf0ee1ca5d33e78c1e92430fe9e1f920ae661ff944cf717049acf85231f0a81515c13220bd01e73cb4e179603f5fdb186049991dbd9e5dd53df871edf0e96eb5842380cfdc161f426d1878cf99a74b2fa64562dbbc1deceae83a13efc2d1ee9acfdc4833aecbd292dd0c04dbfa1267befa56059875e87dd15df4bd9f76827d73abd7619d4a61c7e6a482992373c63786e4f1cbac37ec6f7dc19cba80a681ccec507cd19e62327dc53423f58caa2ac4550e347af515fbc8fcaf65b79580f252025fa9a6a7b41177598bfeeab517697fbe547c0982aa51764854cbe6d759c823d18dec22141ee0ff1de7f734c028dfd81d761eb7659bba3df2826b046bfe7df507ef6514458ec2165048441ffc0b26ac01b6d4daa7c31b6a2150103ebaf62b7090c553b48b9c5df65e102abceadd56a7e05be83f54efd18a02d708c71d1a5699da64d2bbe1e077139e6d10a53a98a65fcd3af528b2f8ecde3f6d11cc71f635d4ec652038bc79cf8ee63db5d91e36c7b47dd1566141fb0a76ca6f764b587df2908d86340a5095ae6d7ce79e567348662a474dcdb988629b09f61a89566911c290bcb2049647482a889fbd82efea3594274ed54d40c9288d6450372cecabe45aadee5a8e0bb6d0681e17deeb29dab0e3bf2be070fefceb422282321b38d9885c7f66ed9bb44098a9d9d6a331fc3aef1d115c146e72957cf7f371e558098c49b0d8dcd9d0934e97372b1235107801d9192d07f8b62d249bc14ea302507942d1a7a5d1946f3e6ce2553cd2f3da699cb31d36fbd83ec0192aff2cdca5251afaa1da15a3d42e1774d498f1d9a2c263bad29de3839e6a98c660e7dbb06af3dc304d8b0d4ec235c98849f64f3180dd572c5e23ab799e7fa650aea12559b252cceb029773c5d205f92beccdf75a435cd5aa48b18bb95f668088fad3b921fa699e275eff7379844098b34f05d95a21e6b9ad285725dafaea459fd3b3d5d26e076bb1f612500dbddf42485dd0cc7a6345392310cc7496362bda7f41dbadd032de15dfefbd62e998782b11e4ed245228f9c5437268584aa2f369cf762390deed2e112a0c302a3ee76a1871db2b864c5e82baa6422a28428815be9a06dbdf81ac50f37ea0f3c687f0536077206d68e8cc9e11bf0d858b165ff5c3eef83957615c5196ed6559fabb14e56b06742c4112278137bfc5f23b9ff16475ea5e5680342f406533c42d5f9f564ff0bbfd00e765c866b8e248457e02df26da3035a4db7d5688403c586645789fad1cc7630563e5ab8a8eef6022fe71354b8783f15933cb5bfb3a4dfcf7526e5ac2b90957e6051064f32f07fdf5e39c585c46bc92939408cf475d8fd45a5d181aa32fb6d09b5bed17f14644cbfa77e92ba7f375f9e9bf052e9c8af9df20800f094ffb91d927742ef7e1a1155dbbfa94fc26c4850bbd9cd415331aa26f02d64bb50cf18ae7183b6d6c8a7d15a0579d7c5ae6c9eea99fd508b4bda89666d3736c48630d4c94ed180f8d619ff7704ea2670530f90a3ab619668c79b8cf0714503150ce3e1b838d4037958acbf68507f3b9da068d638657650fd9052c21a485cda00a51645edac07bcae8509733a4d9716816439bc1705c0c5f8609aa976a7e63482927842568e75c7b08e692ea89adcc1fbf123584493dd1e3117928cdb5e35f48b367a2b7c12c025b0e293b1e1ba113fe04f43b746ed50f8662281284521d96bd0b5a0a85f0182d93e165d12b51b277f045a37f78de42d386f5026df12d33e7992d8d9037a141b22b6210d904fbbb2989a4f92305cdd125eabf4a7e7ef9f14d1634a81d42257e7abdde3d03a3d76d0f31fa1d643b9bacff0888114b81f51620103bb9b111e55e6e3a48017e536c0070274a2f36dc27c079d024fd6ddfcdcf9707ed93dc8db35b3241c91c49de710f6d56b4bf6de05df5fe089098bd62ed1182e3b08bcb7cf604fed8f2e654815e587c7fe987d1ebcab4c943d55deb5385e37541242a39ed5a3ec201316f0a3b92626aebecdb4f7a8ec5c8ee470c858d04c7944ca1ffb38ca5ba6da1ce665b7d6c21333bddfb6e77daf34be33af2ca3b81e8ec802d4f39a456a8a972882bf0c4bb30cca9ef35ddf7b78c074b3dfd3e5e98f1825e0c9246ae1bbc13f83cc2034f1a8c0838e183540fe6e766dac8298f47f865f2364c733f7473f3c199b96eab3ee8f179965fcc53b1d372f0e9d6663162f6301c5603eaf0a77ced71cb48bb387d3b230fd75b9ca809329df0d206bb712dc366828b543d71dd1e3120edf81c5341a30ff5435c6d4fb15b71d1256e73eb93cf0a4da4c36fb280f9422e5873cb0247ad2f503b2227d1c9087da4f05621f57d4ab090b5e5f8496588fb8197e734a77866974dca4d78054d3acc09acee24ac78adc4509a082ff802e7786be41da83ea206d921615a31aff249bbb5cacb2a4d42b1f7af8d22adb00e1df9e0559484230276c96d4eb5296de680160d665380643b0ceb8a9c38c6742e9e97995f164a794a8bbd48f9b1192755bb374778934004cc52a9068bbd8428452fd055ece7ca62321b47773f7ba0b214f3797cdaa7bb7309af6811e7fd37699bfc85efe680b36d099df58081b27a3fdd00291b3ece30e1b1e346fd4054302f8ff1a837cd95bd6d5e035a8d4316f0e951bde34e0f08157e40408e4ac86dadeb5aceedf05db058e609f5a4ce6cb2896aa6003872baa235027b80a4fa9a30ffadaf8e679ba111a0806ae0108b0ad15418a544a5945bafca14fd771944eefca8ab371bb5adb77fbb09913a6f7283ae2c527d12f28b521b526984da5c1e8c4ee23cbadedc5312ff09b241f236af8f65e4cd0e4f66c7e6d331c194b5433876f65689b24d8744f22ba6bb0fa8d5ec81cf1f22038d7f0da79210f96415165307522f7d9b9456ee2595a8f27e5bc663ba2f505d79632c196d111aa77c6fde9f961ec8153a1080588d115780b0f24cbb608b8f10dfbeeffe83daf4a711196f335a66b978d1d72f4b73e7c6ea2f91379923a660ef92722739e5837493a1b2b6431994a47fda2b00a19b14a091e1aa226f38e3da8312630863c8acb8780c48191a78b4a8a4ea4c31e03b01749e34a82cf78ae6a7d3bb31847b959d5bf0391746168e1203f21e7e48ff01762a1c575a81a8ee6230d20c85d1401fcc6c8df76838946a7841e09697ebf15751a8f1b6dc38504e06897473843081c6e3fe200b0cee54d2131bb5426da6045bbaafef9425c684f8bf196c6916cb9247391416d28449616e59cea08669b470de70d1b230658ceaf3d0b5d970e07c554af4c16601e687f2786adb2ba62776e18a12c480a70e0a44cd16a515ee9154b9f1fddb15ae659d5ca05a9bf57998080a421950730746e0fb58fe5c603506294297cafc13f3a240a712d07fc7aabe5111c2aa26c30546039f2ffec775096f3f20f74c0eb91176bd19ce2ed31f218f278bc8c571753db7dc0626abe261170b7431a52e6658fb7e4835fb99a4c29637f1a3d5c34b9cfdbdf18af8c99071a45cd9b544270de9a5acd25407c37b2c7fe378163e8a7e366c654e38960232efc2bcfa988bd93562ff745722a60e440540c877a8073502f2f755e22d5749d9cf0c4e472cd16d9261b8a941422220184c2c12d83feebc1137072016eb8289dc8c3f42ab43e6d7f3a60290e25a865f8dfddb55c4a66792985729ff0f101ea3369a327c224ae7cbaccf73fb9a5b60664a06e2395b484d58bdb9bd8bb3a15901fe53a66c1baad40d3dc7beac1f3cc93876e9baab93500b432e494a75100291c23e4c74dee76d6ac49174a6cf8e64511f3025dc40ab515183a5d7e1e877a800d969a8022e7875dc7ff1465e6520c2035d6654c50a998014237431afa5237dabe44978fad7803af953c251527b3903c66671f1e9f096f110d4a26ad546bf6e7f0daea94ed18293bce1e6eda8581d305e4d1e29b1f5fb153a7a264fa76968c6e5a20e50b6409c0b6df5b5ab3a0c7a64b318dc56b594d8a8b68f66f888422b58ca0c6a4ec351e67a994ce5d4ee1d4c88d329b7ab444f21b3b332ddb99a1c8c7f74ad26ba20938efde44748ace1c9016ca8d44eff87051349c23609e7e29dd574a61a408ce2fa693178f1d9a745c02a0807ea82125d3871231f64f2547f0cf54b670b246782488bf153583c5b7cb3d140708c44e7290e12beb6c954fc569950ccbf3ed2037c52c04a0dd28bf4c23ab57c726a5e68e312b40fec66fe71258548a9c0f6ee5055dca102a32f890af4777fdb62cf61e33e62b44d125db0fa4591e9fd0b8be92db5ec757db11ec719df4cb021892786f6ee70bf958616c519df89fd933f8e0c1fb9e721a78c9106a2f02bf6922515107982ec59afc5192cd34ef5efd78ac695ee5df6abf8c16f4a117129021ffc484872bac7662ac39ecdbd2ad79a4a214c6a1418299ee367089ee2a62f5b1c43f4696d809fc850e872bbe1bd779fac60682a3cde231acc1576250100182f092c9d423239cf48e63f78645f3c53138dc04f1d531fe81c7a19d1f9ee8010a380066660d67a2163f8fedd1f2a8217ff3e9312e72b5eaa7d073941f7a9030d859ed59a0b1bd5387b1db620d1d744d0fb19d00fa0b03ec3b6885aad80b1500c6d2fb0954f709e51b36423b71cd1778ca8bd3222ed30ebb2ded54331fb3252a41c6dbdbf9ca6ccb0e14d92d78ca2a40a2617313b6ba78ac71c21c6bd39a35d3675cce04627bca4682174a9d92b859227f2423e3365e77926ccd33927ef662f6217dee631576907577eed0c69ad854094b30054f2dc91c86faa8ee54eddd98ef92508ea7f4dc67e9197ed5ebb2305a9a845a814764cc86682c24e289d9b0634e1228be9e653aa0d14dda227dbbfa5ab930ce771ab422989fa6df1f0c1f68e34d32d75f6a528902c5ff7d7643c07a54594c44a6837342dcaca18c1e399162e281666099378e9b0713dd8be552f2ee84af92ec5fe20cd6b8ba5e7aed606ee090fb7c6406a2d2db90c4ddebeacd34fbd5b3cd7e22ed92b933e9830376ffd1e9ffa3c715bbb50c1c9300ca374fe26bb11a53ed3b15c4a19d4e375116c0391854b6ca7ebcd4777e648517473be4a4ffef2ca27a97f26367c67c7ec9907ead10d77097e6d544bfbf4ddce6291996f17f7b73eee8dc40cb7ed52fb091187a95bbb6419050967c5aa78bc143ce1dfb22925db97b8aff1529684e1a007a881ec272904c903af3cb6055ef86d1a02e3b53277aaf2153782fa606722b0d390a861bbca4b5772361d0e1ea692a113c4b9c048e0c5b0d39435cfec4fc9fb0d48f452feb23f3fedee516ba426c19f742b1a2ca1c1a0dd60e40857e749b81ae1196b788b0c22e96faf021498c84bd4b14520df2a245c896cbaca5fe7c69410243ef80554eea02bd8951d129336b6026e7a5bc7601886af5568ee28e60ffbb217894a6e79cf49a8d430a0ab144df9ac889ea66a8c03db52f67cf9e19573d417338edec2d63948ce600f9837dd961c659d82c230f35dde0e8a215e1e45fc1434bae5845bb247d07054dda14292840d3545952dd77a51041b7611ea9397e811f74ec7a5530cbd4a97c734aefbfa2645e3d1639fe6df9ac314e02a07c4a3ab9e9eb61d106eef0cc9e4d40e3f059684f59a78c887690bb38de831df0af9c6ca9ed6d27d1c9bfca278cbe5eb7940b378170485f8c8c3bea9b215d67a557dbc91c967daf2e2e84ece600db02799f24c1a26d611ec5c3c2450fa6ef6113703ebca2170e5b50eee74dc7d5975c8f95e983ccfa8790f0359a83151b19f740b59a0270f4e73132fe56b39a9977e19682ca34eee07a0232d72ed75b10ea0f34b885ee2ca8de351b529a8adab970fd9dbb9cc116daf68b1646126dcc66225a9caf4178946ba35e0d0dfd7c34a23a2d7082f598c5864bf1eb095da639defe52f53a1a77001c68c148f36691c2c9f45859380c01a6904b987c3b4b399aa964850047f9346068dc352eb3eca4096d27533ac21b437a9baa12b56a02e5414d28ce50d49331636bc3d9e5d319cb8821f2e2af8ec6a1247b13df29334bbd52e930379b3c3fd99babd9e323ee641def3e39b786d915130a8ea50aa184fa08784417cf070a0a777261cd4d2d9dd4b27d47a7d5c30f690fd2fce35bfd96966489be2bee864b4abc4818dfd8a1a9fd1f721bae707ce03105a2a1bb1126d1d26c337c91b2b0a73eac241adee330802c21cb9bd7f180a2863562a13dafeb7a8f423f68028a1716623537cf749c457a228f8be2f0a5d3618a35b5dce08d519b211d042cac34f14ee50a7bbbaa829cc81f0174c9353cc1ab409053fcee63cd2b7f7fc2c19054cc30d9db1cd425f0b8813b591440a10588bf61ec30be699640f8fa721edbc02180e64cf4e116b151f2c3e76f3ee2c18625e9ecadcc53f63237801777a4e1e0775bd41597871bf482e686890bb450b51c3ceb2224ddd1505836fbe3381e4eb3434c03889dfd3fb2b1106787fcd1c2e09ab7630cbe01857a6fe47ae1d73d1d05308f542b8e3d647cfe21257684e683346d8e9aa0b24cea1184b8f1fb7459583c997ab208052a92c08d9d40a3005dfd0469f4754dba89473ac403f98c3faef116365c0fb486649dcea9dfcb6d2c8be1f28141a41caf98d8dfa6e1fc2a29e9cf13b119a3faa7155c1897f27070134b4d5d844f2147696d21fcd031ed903e198b05a9a379217f2ed14fcef83ec1a822b89224c21a04e053ce7ff3573e322cc52043a9fd339a5f800438e2277facec943cd5011bb0be3d508fc20ee9a3fbaf3b283fe0c0570b0e35bbcc724b1e10db014a8b6d5e8e89c07d169b85267e7c9ac0c100e2bf251101e751542fae7652f2104c79ba3ef04d1bc2673af7eff7687d9676fe9f6679d9bf8d620f7c93d56a5749de3fd766c24bb68340b5ecd1132887c115c9ea4e9f62393338ccc7c76e08f56578fd31dafe58d715b87619de9a481eddebdf5d4f85ce04538125b2d623e7b9306f212ddbe7430614ea9bf90af94cbceab11d2bac425b4ad6eaf55042dd421332d5d790ab2d4ed40e738f32e48d2149b99c7253b666cf5e1fd455af07bfe4e3a0c8a34baf32122eafb6b1a9ae70ddcd25ec34b07a08e880fa8483e525cff7d9820f3a44bd2ec459cbcd44a2bb49fd3663ea5c29b1f1ad297db5d992861c5325532a0dbe3b08fa9b18dc50f0694b4d4d3b3dc7180446bd456da5e81ced8543f9526928d3df9ec68876b9d6cd125a7729533cced089d8789ae495b78882a11e632b46b4941e15db01b67cd1e8128f50160526ad89ef76a761d9e1fd91657ba41b389bb6253456e89d32325ab822c3da4e06d2151a55435323cb898ed03563904e956c52518a37dc75de3411b8d793e816e0c33fefb9b3aeb45f18907c6a34ee181ba42c8b3fb1ed504d768f7c270338d5967819174368c806bf464bc2cb86baf25c34f4b316e2cf28e1f0bd37a5952cfe57b182ba9ba7dd059caa2156a27e54d815f445f086f17245b6f6e3051b161f11872c857e8dbe85f3879154f1e06094fd0a8a240851357b0b35826ac93bc9be33f646eb8c28707af8b4ee88ec31195c4ec7d6482e2aeef5767441ebdc2fc52fe2f3e959ea4b47060bb748633c83ef781f347dff72ba149237e45161ad691304a78b702371d70fde1102001bedaae54068ab145b6285666e8fd8e35ca7f1387ca5a863be5e4835065afb2a3fbc92b28196669abec98c8b75593aff995de5573eeaa01191c1b5bb1911838c2a218aaa4450b42b80545146bedd5c8828ec9548b16a5c0f46258a6fe912e010fe455edf258331ad1ab492bad0b31ba718e50a4c71b60b66bab20809a50cbdafc81b8a276d7ac13953e549633e8a0e36b160b04ad1b3296a2e96fa23f74e1bc653d8e859d98d1d7b04496e66ddc19966f6e0af99c2cd1f15752a62e28eb7ba039857e6d3ce882020cf8142374ea8d5cdf4565d1894aaeac12a739c86b8a8630196e74b6c4820ca48e3ca8648b7d682ba02e08160c1342a6bd97a3cca96c026bdbea91bc152f71204077102eed5fbe1a3d4d05d41023a36f2d672ec01103f948f87bebe4f59c8382234e7c32285e2e981f96cda74aec8d56f7030abe547a0d1150c2bc08af44766d4f4b25ef15bbe587f9390460bc7903ef32f5590be24014cf4e9a0f48c2c2cdd0d9b52f09ff016cc6c24763d41f50f1a0512d8d7b7e86e3f541b16935940b0525547227bd0818120951cd8348b83148b4122e1fce54bfdf81943f0dd003b20ee3b152b4c002f5ac94fbbf6abf5cba45922410e1a170b3b7b11e9b1e58af44db8fd3a232da0df0ff90ed2a3f8fdcd078ca1612adf9d31a50bd31e9d7be7c2883b3d5325403f38ee9f37471d52ab99b0a1170c03cfa6bcb32263ef94bdb6bcdd6bc6740f1bfceda4262ab9edd65f21caa6a1ec00ce6a2c41542218bb4af0083c150497b544683597280f7ab295abf95aca07df4e133e147c66e09e9b3d8db3d8541750ec0415eb90f62c3bdf7355be165764f877fbc7bd12bfc704b79d3df4bf26b40759e26ff11696c318f539279c9aa5370e5c52aa336f5fa468b10be65e6b8496fdd9c7e343e1b7bd9d6ee9af3749e0c7983f86439412227f49bc801b51bca56ac7d06660ea17d1c6a810d8298b3812ac02ed8498928c2040c6b362fbc3566531a2ed085287271b304d89ed5f692edfa2f5bc5d257b8ef8e6e2703bce223339f510054d6615c235f52e598ae1191d9bd02235527a88b97f029e1887829227036460d27b2143ebcad75d953aa4e4c39ea6f28b81b4545782e396beaab96aca5ae675be924e45f31d735eeba0993fe8b395108026df82c372077905250e6a57ea85fe295981c296c373e9a6daa79f57c7f9609bff8025a6769c30f53e647e8ee93671f0ebeeead7bae7819739e1a0b9cfd4b222ba511bb6ed2be07c8370a08d619c8ee6b9667e815ba34fbb6af4937914dbd633d3370a23f33e48d9d65219d1fc3c357a4a03f56531b132530c0752aa5822c2ee87879d67f1e082b02b61dbfd6a52cdc3b9e5de869bc3f54a5b84c93c3ebe5ff6f825a6d37d9246b3a16eb487d64603ba299b8ddf7274fa4613d9a723027692566391e123c2e90907da798142ed40a653f89673a989215f4ae6ae58ac5dd15bebff3e6f4f376a134a9d53f58200d7f68423ed85e9fa41ce66af992e932b0a3bfd4188ed2767119af25493cee0f917e9654a1f764f048dbffc8cbc5c1974a706ce56f9c5ad6a2559efd2cd8fbf09b63bb55fae376742050c06b8e7cba6f7e0406b3857b3b0230a3312de6145e46fa4d4747d37127423907caa867dde382aac6717910faf8fa2d957cd5c34fde1184f7ed6238c189a2b6def3e494469ba9e7c10ab0f3839aade4547abc8a2956a5cdf0e44a532bd9dcf607ebad3b291a4c5cf6ec35db823cd299f7a6182e62e39ab5d8b68e45a56a80ec63ebe35abf2bc904e6005fa2073a3ca15f938c75bf9137bcdcdec6dd5af0b5f6815ec3d2edfad489c9031b019af3b05e8900cd1daa737dcbf11250f3a2ab076e0ab841bb34293d074372dcce102ced4e65fd8b63318d56429a60173ffac4e5b7c39eae67c2f685dbeb7bf070601cdf24f0558221e8f64cac4b0302ffd2205fd6e5c89395399dfad84f85d52ff8c10d73b4facaa6ca6a7d0d49cf78b791e09602e94e54ec4b54b8dcf62379f07809e83f55f7de0bdacba22de194a9430e71f6830f3c962cde4f6c3b1319699f01ffb242c51568d05a39c5a3c9e712798033954c8c6939b48c10bf48379bf9b57cbac69b6a9b606429c6fd5f6080918f41dff0c0fa71364e173b63bf50fa21a9fa7a8a5ae583edc7f90a01088ea0a11f3254345c24d566bf5a94ca4bb6f47de9d13ec9d81078255be161b28ac77f6801a01e19296c91060515645fdf24c523ce42e9318b97eed8af7e65677b3e3818f330d0b51e473845b69c76e004216558a3c4b34d8ae085cf91b88f8c229b2fcf47f1ba8eb7b54ce931a40461e609c46503cd075aabddaef19c28ddaef2622672314dd0a7f614d46d879a62f9b534d891c031037696dbccae0a8fd014d5348fa31e3306d4eb42fc3e026ff5c0d18b66b7cba44978369e22e5d976d6b16403b1ebc6dce5f2a3f2bb1ec5f4df39d0383ec80c4bd7be03f70d68c7b87b1faa21e3f9872302ae720828c94ae8cec08edc2bc124740eebfa6ec39277a20e86187c7176ad1034f645ef05ae7ea34e6a357777d133c2f45ce8b22ff638e169ae1e15362f186722b2bc0da42c5e239e92953582fdf3433a59337b206285cb79b42c9bded447ae4a770607ceb31e58686723d25530146137ba8fa83a6d4454d836602d8931d9ae3061b927496f7081a44681682a5dc4c65f695b8044c7e967f4265a2d97d21f13f13ae6d9a93d543718df9e0a4d4e8db55d5a56456771233e96c77888affe829b66b7ddc0fa679e29cf89fee328207317b20bccc220fe4b0da0e8ec6d9f1b8546a49ad954ef8744992de004e27f2fa3ccf22cda6ab059320cd5e8d10ed5d811d065aaad26feff338eb56c953982ebd40362c11dfbd9bb0cd5f19cd686cd4206f8f6571098bc1c7407b896d9d1714196b851194e73e102b7b73ea76e8270bcddc52c858ef7c88a2e0e393b5b16a3d6f6128ece503742bdc0a8ed85f21bf704e60fac20f1b3b69b3a7739fc6dd3a0209aeb0391857dced5f5721c237039a8c0c5f0c53a9e55254eaff40456eccfa8d26e892800a452f4df8d9e39ad16f04cf53eb69274020b079ea31cafe3c86bb8d14c62468748f33acc90c6875cf00de1e974d19aaf4f02e7f3f426921e55445d532dc99ee28ca26967061fb6de4caeb103532aa61ab26c549b515b45b2fff5686205f47329f7028894725260e753be49abff8f6ec03e1feae51f488493af7d5bfb3847b159bdf9f034e05dd0472c2a2fd00f027ee90e718b4365eee2dd449afbdcc671d01b9ff36f18a6568964549641f6e984ef0e81875a74994229b9128e86c618e54f8b0ba2af429c96fce90af0a313a3ba704c5c4e6965d9d16058a110cafb1ac970784cd96724539e55cfbc962f4ec21c217b28577165c0e359a68685f2352c82b3af7e8d6654d5230befe22f1f429d11ec6248c76d6581044a42ce9c1842bd722d3eda13bab179bd2554c77d28e3c2fc62dfc4d81502594ab21c24617a375a437f05ecbbaf4a258b43ac03f1dab83931cd76b05355cbca3dd257570c1e1e82b6ebffe1b1d4954e136f8516ee79a577c39d5ccc66f4ccc0f7d7edddfe22b4f7e13b3b6dd3e97e006a6d8c48318118fd2f6e58b9169552c2362ff18696dde30764ea6510b69070b0119995941978e66a4971a199716224cded2916450f925090523d32928b125098c5fe68001475b93d603ba5fd1fec9c550c32ff58d1cf512a0ccc704e8a2647a2a298e6cdc465ad0ee5311ea0c1a1eed7c7d3f17efea9e50d50b423ed9b39fb68fb4c021a30e4a7ce599464b44a8cf721474ecfe19b1776c1594e77098636ae11a8dfe2bcb67147ec60a919fa29fd3f81485f1984da8554c97e0a5110ea0c9213aeba785dbf3575fdd06fccae3c37de8f593f49db0f2dfe0bca0ead42331ecd2db933229074a1a65c3dc23961789a3172f7ac866427ef3f4c9173b72100dda582abb1707cf040e465c48afb2b3749466cd36dc8a137dbd660f107ba4bf95d90fb438dabf3ab06893e7f58bb4f896f7a178fc199701d9348bbed3efbf2e6dff8a53ad543e6ac6be998c68d0c63a3d3ab43f4da59aeaf88fae7e4f84ebe51d46373e7d32678e53e14c2ad7262b606b14ca9005c88acbd5de8c4f0f74ad47a2f8cca9b559d312be278c85de0aba36b140ff89e1a529bbc7eab4e83a97813ed6a067b23ec09df4a9f31cfa94275af621c3d3b87b423da33812f506c9d50417d57fd155e0ad849fb9d6f1acdd9e623a7b1b5cf70c3b9ce24976c983d25fe6a120d0ea37941c57e07f0e6d1c66c607fefe4ff2501b7cefb84e1abb753382b726e4f4bdb014cd156640a2a13711f5d7dcc7a3d1bebb06780952acd56a054d218053a2e30ee6f6d694edce9ed6c4f561b16efa87292ff6f58c692a60843aabf8ded2244b9d705bc64f0c336f920070753d2de8e1d00753e8202f24b483648ab5d396bb6dfea6544192eff85929b3f2e859689d4c16c077946d1277e6f968571b1d962cdac837929ff19289e2a0a15b9a58dc844fd4d26b3a97d6dfb3b359bbb920c73dcfedda2e835985055ebe216616762712192a0cba386840b01f7a2b96c681106415b6c1079bb20fd2f1b591f77f9be68ab820750cddc813d1512409e394ab45dfeec4528efdebe08a76ba3e3b297339695225fa9b3bb7f7528f0c7e676d5e1bc1b596a013836f8facdcc561139826a58727cae33f8e204d68263ff66d9b5cb0284a7e7a381ec391b53b31704c9beedef994703faf6f4f6c98a1914ddb4c2cea112dd01c9f50a0d6d98935286b6b3e28cc2a908a78ff801e265c5d98807b0b63d750b930be536c7aff06c27b7064456fcb78573536c99e00a4a9808b9a14b887673f4fb38b374585594b781b0f0279a95aff1825dee6207abd5aeb49204f715c1c87cc19f3a98e61235494f646ca9c851c7f1271163bca154316ef8d14dec2bdaeadf67ea0fd99d7439e83a431c35be5cbeff495570b881e3e1f6a45e8fa806660fedac1186b8155748d81f801f0c41ccd3363baac07dc3c13b5fde529ee03d53fbdb20184f45e85ae68512da4f8935637065a783a3171098e67f0ce62136884c82790def71db054d92272684d99698360a6da5af066f8e916df871441a5eeaa4796650a00689698d8e427ae97fe9ed47da4dc24edee46a512a36d509150d3f1447cb6379f0f4614f0eb06e03173b067af67f186641a1761b5b877ea30d13c74f994ff8f0e644080251139327b86fe783b723d249ddbe8b49e039699489cb65c474b14eecd01e97f0a573d55d391b34d26a1a632a6840f86ff34b5e61205f22ca3a2e9c895ed8388b2ab605544864936ba4fd7bf6267a781b1eeeb8221adf6a545dbeca694d80ca97b586c462a06d30d15a6a118ba19f3d2de27a69bc0c1806d4918f9c1cd777e9ef5a29ccd304b4371e730031224942fa32e3a86547659c45d12190ef1f57ca4333830ea6943f26fe12c7fc35e54135f90612aef9e612ed2ee3fb5c230bdf6981a22b7cd1632269ffcf5c11fed09b3e459532541b077ab164ddb0fe0fafc1386b5e1ce592bce7f441b8d655016b55405d3627bc6d336238ec7b7f720cb42d54486e6fb408ef2b900157274bbef8d60cbcb73e5c3d9bbd7627d2bf7137eac910304afb9c7114a74021f3b4d08ac0c9d038f617bb80b8052bed8a768aefef2c0267fd587be88d645e8f29270bd859887406894494e3afac1ac6868d43d903ea5521ddfaafc1aceb588583e26bdc68b8d6749c31ca15579fe54f48730b4c2bb2078d9febdde518f22dfe191d961dc8d8195efe15a9d22d884b1243d4c46f000a8614a4e10223541cf4344fd233238d48f7135536f758e4edb5bfefb416ea3d8d26936bfee108c361bbe3e1cc0f33d1aced9c3abd41a3be36675df503f00b99d9795b4a1b7014ae3f0f3dec51e2e39d7764a3030e2b9a4a1de55378c4ac36cc4699c4181441c1352ac31fdefa1fb93f5a350b4a3ee355c8e9e4c45153a0b785d95e224e7b87fe37a509dd5138d475a3efb79990125a65d8cc08c3846a1cd6a08eb6d7f7145d2b842323fba3e2326afbaea1c4edf6234faf2e725414a707989e9a681fc8d325b5a7b9138cde96a4da70b16f889116b58a6ca381931e3d48e8272a55169accb7a4eb65e325578b1feeffaeb114f5ed37c9a54fee7558b0c7ce569d4032b827634feb83058cd7e584a7b51a275bd036e7f10433e4f4b5849040181cfbf357fe48e3ec44e50e99c31cde1e9bc9d0f266ff09f9e4ee90645a4c80c69a01c69e5963b3f9a8af8d60c852b7c9dcbfc5dd7105520e0829971d5a5540467c62478acb23ed15b82f3b04110174d90516a768fefdcffedd35a2c6afb212f0e5ac4c5c79b6b10a8042c55d33f08e3cdb535d019444d86a74902cea456fe86d1bdb6e0e3b3b76ebed52651e37f23b05ed0123aee5a7b9da7de1bb1c7f0a96a41c72163c1a74b99a79efca5252c1aaa340237ba73623d5729cd0368c6ef7e933c4db56e4af505ea828265942a89fdd521ee51dac9014f721a5124a58d8eef1c4cfb5e01e80907042a7a11dcfc87cff2d9188a6e817d060d2d96a8830da1e7913530f591543f0bd55637799efb52ea9eb2cbb23cf3652aa936c196831d66a842144d3d4e7ce4bd6ca32a9c025432168ecdaa0c79b47bf8713ff637a5725444e1adaba9ff6a1c1c34c89f8178787fb00114246a22f093d4a64712ac265b4eb1abc0b24e0103a7209e967f8831e91f2b1d90c94e2368bbff5524da43a89d3a200e1a48ef59e98897b58f55541ffc6c994e29be629d34cd3343216455953a6eaf93c0c078ea5d1580e07181985967346610a3c1c837bfb3dcb40efa6a1e4f9c76e7ae2ff5c299f75243e449d79e082e7fcae121821cc91246f1c35141bda6e2e7bc557b23dc6266aea84c9cfbb35e8f968f3a045fb67bc3eff7eb0ebef005c00146d2643194f609deef4ace0aed00cebf3091bf7e3de9f5b7a7efc8b7640209a59064d309594b081f545c2cb4da42c944d44f3f82ab766cffe6e069e60de5299795121491903d766a74dc63fcf920bc3b1b37c9a91f4b9c787f0d8d5bca87d84553a47009a4d83eb05a0e7d59a06d342910a23687e0792f8d73584c9e4ee9fc3bf4922a8cd53cb195fdb6ddb6f50392de9a1a56626e9d73af35dc0a525cf2baabaf1a5ea2a777aa26ef2dc40b49a031559e66e77146396e44cc9043fa3a27de505fe1d6c849b0e4ff8ca52417978bfa54b89e481642b4af7bed5cc72f1bd66d1c264bed859a921ae0d28bcae2faf2333ea23712a9b0c94683fc634c40fca9b4f9cdb4fa17b5081779b169180f1a4fd85d1125a6cece9dd2f7e57ac5a1410e5cdee91fc50eb90b90fda99d0f898bc8c99da8dbab7e8856dd1701bc4aca0ce653078a5a4e4f52efbc03829886be22b8d02ad1ce7fd50a0364b4ba5d9585e36eb5e3fd4475b56caf27b8465b0d205c1f2cf48278b5236c304fdce9d404e006f42b48b9d53df384cdb88a7c6b02dcc85d224bb500aa3f85e07c8aa91fd53ad1dc1629d56bd94592e5134467ba7436c5251eb2410a02ad581a54eb8e39c6ab49066212e32b69bbc518beb02d5b915ac31f55a381770b98c7812c650d25dc7574f54cdaa6bf0acd312719a48d63c83fe19508c7c5f627140b45ff23b2005382487b569915c522d15836195358c91d24d61940f1b2b79664e67f25bb298fbbbd92bca4bbf460f863a52a964c9987c6d7be71b321a24f9402ad6de1bf8c5e694beb47082240be8e7f184d430edf3e7c37097f30e6a4a897c106e832d9fcfc553693a5eac27ac22af39f222ac8625c763d3c7c86e4fc6a48a4e4f6d3369c97aba06659ba1f292223e9aacaeefdb8e65009c4bf8da2312d4ecff6905045158bf65c5c3fc5ded4d37f3b387d951928aa42e50d43217534479c273c2b0c84d6bf5507f6d70e979a1e6aee2214fdd87c01b081731b3a23f3662101e07c18836debe113f5a3d3815e6444967e9aa2c988084ec43f0d311cd686bcef0c4176c3f3ae617f9b487840e90ef3774f9c14e0ad29eb1e651dab7e1c3f26de84aa88e4f701aff6572cc10278454b59b60683c95f351aca15bca1fc7f2692c09c28ca09d454134faffbbcce69fdaf187fac558fe1e0d3855a2de5f407725f2bde1f8bb3d9d5e496bdf7351fbe9efe046aebacffa2ad52e0e127f77ccbbb79e7f65c8bb6274523ab69613dda249eb79ba58e02a41dca4049de86f059cde41af02e1fd20fccb007162e37df1a1aa06b05d24d767a280c137d85ad23504e11388bd0b5c822fd504f7dec019c600072a1e3f548641b80b22dd3e8920ff82cc8fe0df09b61e8999add745218d76ad8e8005adc027095de79d866cb08e46e52181f6b9d03cc07b70a0717654007aab3d53123e683c6583be8c7eb27de9b5cf43b98fcd9f667d1309ba88c247084c06cc9d413b651ce410c8c0bf598e2a052059acdd4c57974c6c2bd1565c07a44fcfab8bed77a24b9897a8455340c63758e5628186dcc468782f6459aa7fb6f37ab8483a3f935a99d2c8c6419accc7197d0a9afd9fba850a01523ab2f943c0264a5ef5624b9cc7b3ca6d1b8221f850e6a61ecfa857ee38dc71181ef418ad72fbb94626c02dd49d45b493723471d4bd5a2f93053300d975737eac3928dfb7a98b1ab053b40123802a2c5610603e386e40310a62f619f97bf4d0bb0ba0fbaa79dbced1e0046076ed9c372370421ec0849a077ef7f218cde096c09401bdeb272dce812bacb9ca6d3b5b7777394c0abcf1ca03632d4dd6252c0f8e72cd863867b255cbc2b1dd2883160ad4c6177545d06d75e053b9d321b8f3e29601c39d8a9ee3b611981116bb0f6b2aaba5813aabda25f8cdb348be9c47fd05cc4f816ca997af0a70c01855068ced4121f62858a986aeeeea131ffb77eaed5b7119f57aed3b9760fb4dfb2797420e59ea696c60b4e1c15757d871ca0323eeccd64ae077d7471105d79afa3096b2a57063c26d43de9ac684950b756290133aeaaabff8e92b80de802ef8df848568ab9537cc2ac5a7b40b8389c6e7021b9763a2760ec0bd032e02099e69847a6666c11af9578fdad2ab441ad14481d6ad83c3ce9a3ffc1311bcc6ac45d3f180ec12f57a1e69aed83b944edebcd2bdbdf1b226a13e1e3404a34925667d0cbe3385ccbe702826d4a5f8439454f32782045461ef4bf8f893627a32e6a482cf922dae3090f0fb6736284fc1ad0be128a069d815a4d31f6e6b0f8c65b3353b16ef76d65e9f18df70c658464dbad16ccd4467ae1cccfa84cb4f066a746fd477b7b5d1a62edd5d61c0923ffcad80bc42fe4c6f2afa1115d88b3b2ee1e8c2c33eb5b0b203908a48cd4afcef09b9ec013c2d3b398c3bd3541e3eea49164793802f4a9c8ae83db1ae8e2585f84d877506a7dbf468a2e8bfab75cb04095ac1c993b16083aaeba3da0bf067d7acd9622c76860a14aa9334279fcb18c3fd2662e65ec8f57e033dcb0616e3ed7c695fd7a9752349c5e2e0f861f53712e5a9c4a859cdd286cae761d8aa389e71a67c27e6bdd3af51394021580cc44f3297aad85ca5fbb318b0a731ce2a2fc72c4d2e3c02bf0da71a006e4b4b98ae400141194f7af98019cbd2a8c4642fa855c5463b750fc0bda6515ea29e8966ed1dc5472aac777362cc99cac873d97b156087e26b8c06876a8f071bf5bdee19424024da83ce18d09f95857da870df63bb34fcd9a0d1adf135f1ded51d6cc2435d43e03b370639e2f38ab9ccfcc05e6cee421b0e5f838a9e06e1bc0172f834b33b1e20ff2d75bc0c12a11d0adc4bd8a3490b7254190fe522f2aa1f8b3239b6ee2bb09c22febeea5f79050977bbee1743b12ce80f762720359cae11bcca08eab04384f1312b8bad3022dd07ad2a39fc37a319f0e2a7d91b9b5fdbd6ff1960f7f395eecd78d61bb956ff1514aba291a5812625607901a18be7d1b501853b979dfbcf7b36ad64a597eeae1a749c09216258a40f81969fc49856710a49a23ed0eaf67eae3a57e3c56679d6d3029839dc1a86dc6b460fb90c7ebb6e3ee522ced9dd2e68e8b143d65210da1ac8819d0f79e09e460a55e3131448c4d49170ecdba673f8c1beedc469a50ed5caedc7513dd86c617d837fea6ccabf8d019b4b6195790b87544ed6b0c5d2ba27dd35eee9436d9f6c5d4ad8987647f9e83a0ee8fff4ab6c662abdd95bf954ff6a11d95cbcd0236f6c51bf471fc48922fceb852854c7733f6bf5a85719f2cfab135174611c0a80f3dc08b903c62574c15e71aa0501ce4cb7f414141c572051f3c12243d068b8317d5fa015c293ee3dabcc2bd925ab7c1d6e92fc5872c469c54be701d337cf759850afe07b635d7ddc5cc6524526ee1c472df8a7e57c961a2b272e16e3fd3ee905ccc819a898a7a5496d8a61afc9f9e8b7ff78465f5ec9c9cbe96b0dae9187b4669a15b094525f5b175f922461c35efe4601261bf7aacc6b4695c08cb9c9a7136040e183b26dd605ac910b7fddc8527b56ff9d395af32a3bcce71621e00e2f5059fd8d2ed83a6ba82a82c2ace5960e741483c3affa38c4a3983a2c916fb2ed73fe5a4859c8e8803ccbc0d4e5e1ec03fab5e4c476669a19fd855d84214bbbf5f0fe2df7745fb067aa0225a1fa92c144458d17dd715ca30c6b883de3bdb5163a3a4018497c9ededaa60141ea7969c0c27abb392e11bb70850f711b0dafb0af70cabf3249b1fe9bb17987819fa2f28334f85a5db1c475b9c3d81ec67fbd09c927019c2ee156854a941b920a4636484517f5a277ae9a80f4dccdf41b2df7abc823f42d9174b86bd7baeea90267af1446873a9e8c4cfb76d094d8057ed6a8a5815f2925a6830e27cec39c038625f937138e01d12ff8c57ee0a54d38b8f2cdec1dd86cf0c61d971bbdc2fdabcf400c47cfaf433a0453b939f5226f9954021e0dd0b3d67934e9183bf56ebfbe592116b7ee640330ff7b775f5f689c53d5517315d288c8e082d4e5d3507b3cc8178e9111d9ff14f7b647f41ecb687856f4dc6afefdcbfaaca35c0fb60fb662d4b1d9d743ab0674ad78f8c94f678b805f8e07b4a2a0b0b9f13d58cf3342cf03b53fe22cfdc4f4fcfd1aee89967fae39ad8a5a139cebb8694b00a8e5502bf3fc3a161f831c17bad682608eb7b1be94db4d2a122f355a9b5ebf1334b95a3203ff5918dc6368f8e8e293a52a2e45f0fa89ec316e1ea76f03e579f4337eb60a32e4487a1bd294f005f508fda42e4ada651b4ee199590cb5266ae92517394b1c8bfab4e4eae8d9bfb69a7e46fda5522dacd55185fb414e7f5a96d8de03681087645f5b348d93c3f1997111d85c192b24f2d2b98f25f2859ea59786b7a9439ebc524156396cec2ea89aad1dfe3988ce8e9aed46d2a4f04d4f3345a67d6db645b547ef747cc81da3c8ac7e58285f860e3714913117207f589ca686b39c68741a868782d964512665b8e86acccaf1ce1ccf7b02b7b707dee9c45e8bb13ab94e1498c89cba2f0990f828ca59689febf8b3a4a4e2a7d4ff9d8e2f5d1ee09a8828dcf9dbfa70089a53123d8cd33465ec04f63099b00a9d7b73ea6d91ccd777388ceb6b4387a4a2f1642fa0a9453b5f21cd3916eafe23049c0d754d72da83071e01641d412c2867e3adb4bafddbcfbde16ba3978cc050cc1bb0da0095610ba96486a66daaf03229155326b18d323529fb156123ce59bca69acb49f3ae4adfb5d469122089a1a11d079789ac7648b1d4ee91e203481acf58883d6759f3687823a6888156c35554e9afe60d8d6e009b1c78df21212e1277f6bca9c0393d783ebdb92c394b9f519860efb67195356a854d28c82ba97c5f0bad227a0701118b709206403bafb3a8a88ab295dfed005620f175349bdcf33f5e48b766c73aa23b9286cb7a3e9cfb0202578889d46265e800e7cf938ee97e685a414641d1eef05f684e10d924f58cdb9584967c6161c87e9ef2f24b3bfc2236c296a097d3e7ea801d5494ff914fdcf5a8f9fd9fab52aa6e40700d81553ce6cbd0856832afbb7c88ace4b8ca44d01f1dbf9cbfd14369274250a007d2fac9801de83d7b19f53b67ba41a99b4bc79fe1d4e1d15a56d73abce616049f13684671fac26d2602bb28cec193e8c15005dc3958749e80742ebf22c25b52f089596966fe6e30a2792b6d7dd309d040c71dffc5b0df34507cef43f988adbc11cd10665eff40d831615a17b05e612312dfe69566765138d3d03980cf2707c2e0ec9d6c50f5d3edf06753a47e5ba647df7528f74d5426bcfab27044d07ee019c4025b06af64422d63668f7de73b6b3f8470bfede873142e14904126274cb430d513cb14e105d771e0a39e68ac39059bab61e2313f600c8a4267a3499448fd4ce5d771923d84ebe55ba6062c3d57814654745dd613381557fe0c3613ec64b420e3e78fcf24bae9ffb60c14817caa000a0df794f80b1202f115a035e15ccf393231657a5ff2c72e760324d3c85fea44377b0974d2912ae6ba996f2dbc6978e5b6de451256f046c876953fbd488ad03b5167fe95ca900991b643f7514815a113cff6be9c3e9bb2d0ad81927982900d81b99935bc13cb7d719961b7c7cef42ae1745c99b60952b2a0312602dd6b98493cb642a6a53e9316498637c7b5f2228587f0d3527312d01bc79fd5eddc2aca816b463013fed7fc5054272e2b296e766756151b8e7bb340111ba5a3529c6e20031e6047f89f173a1064c7cf78656d2b644b3fdf2df9ab2474ce4e8ad0e26e1215b7b3709992de53e971f6d5a0bafb37d5efcb8a490665f62e6287d7308e28c36268f1e229fc9f98c078b82f7c094c5701727212f905467d83e37daa9bd08eb0e6abd52959997adf18cca21ff7c2d6b9b11a928f87ef778a3124be5225744757e537898be722a0b297bd04d4264b89f7eb8b1f4d1962a3f34e67bb9c13e878c63b41a11b4902e9505ed3c77ac143e1852e1d9ddaa0792902b7896e1ed5910906ba59600094b7d204072a0683ed2a9eb69cf9795caf9bb5450ffb0f1789b1c19b481c13f1b4e5cf33e3f7d1fa42d587665b96194fd147a0f7fe094c2dabfaba6c719d44387cebfe0a2e7f9b840f90083738697bb5ef06b38d20afef1bfd5bb707d28a4c6a6a391ef270944d90f09421a51ca24920d203bde6f86adab22129d79de7de1efedccf44951407935897b85b1df83f0e66d688369f635377999d80c8b1177df5a25cf5c4854ef6039d486cfd9b62d2e49e53aea41167736e3257dbc3607fc8f32d5a3e2c7a1bc40ad2d3a3cfdb8ae10c0ee49f2490adf20025badee44bba6cde3f2f083e04ae0e307f270a4ab96818cdef15316383a299c6ef8e87e92dbb25378a7deb2275b730fa71e8d5dc0463b6c0c13892386e2f35ad7c8e0178917938aecb7f97b8981f180828a9db6d4d27ba5ded6a583e836592316432607270c0757cbd38c9b33ab61587ec4860ad6308bab6a0c9a6c68cbf42df365b5510f313182fbb5fb88f4e38c196b199be82d9feffa04d1850679217a0199e237a84437cbbf17403b100fdb9b2d73b885b776febc396eb338b8a5913bcb0cc0753653bafd78896ef00c05718edce2607dee41e70b6e84b48f17fc62bfcafe045c0d9b0362f436f62cea45d98c2437285759372b91a7d627569787005eff1b07581f373b9e336ee7ff81b936ad1b54f3878de758e0b82ab273678e7fe42282165902d1695dd12a5223b657746772492f8cbdf82db161f54736e2333420e064adc9d72feda1d96834dea7824650948f56db851d165dbcc99a9b1c73abf45050d45a7bdc11355bb3ee39dab40ffe990c2566bdb109ef73b9e4eaa97d3de98e7b3ef698f5b0742f321e9a5c656f7eafdedb186ab72f02b1ee2fa9480cf05cd5446f3f9b750d1d452919184a412c5a8a2cb35b3c548587aba950b1716d18673461456ca84f991823f5ebb1c1d2c4de34b284c2e2ec275e88db218c6afdb1e126861067109c135fe5cf9120c5ec70607d2ea3696c9b529d0912750db65df169d7530b3e3411e8f75e694055bdc73f56bda25194d5dfdfa0293186e485f289780026fa2bf7800cc75f669c91b273e7bf96915ebfcd6cb156c5b6a52db2aaf837abda7191b17a8025a82535409f3289030ab9b2c786a5e2cdc03b7250911c2a7e7fab361c5c23d9e3d756e3c665a1c9bc5eaf5168899c078c650449e37bac4eb24fe3e0be549f768f5ef198d22b092cac15883ff1dc8e81e07200a1ed780453f6c9aae1cdaa6170e7b9fc18461e160898d742bb753d8e93a5773a4ba1775c38a5a627bb4f0bc21879073863487b79c2e73a193af7a64363afd7c014fc32788a54bb1b2d3e1087701f64d29461c2a072aee2e91fccd7874e1c6157d3093ac540d3d124c15cde496ec9399c5c59e3e35d8ee332b61eee3c8eca582ac003be782c43a132068bb72bd7a459e9a828de4d8ef6c29a3bd755c104804c4ac5fefe28c14004905dcbddcfa365b08cc251088652b639bc291e68ddfb27c0a850b389a1b8c89cb0d14f42275aa7ed847dfb782b182884d02a2da887c6178b6c0930c6df48575d9b63e0fc324db0d78689f1ee7fa289207a7e8236b465978659f1c192776465c98f99ab574891d61e9ca72032ed5c8c77c14a2ff617225dac89b13ffce98c96671e696a62ea1d3e5ab52e20e8e23cb0828e0eac291444456170bc451b535a47efa98ef1131cb3bc62bce11c84fb47160426323dd176e0f30c1acdabe2a404107b68bb3eb704bba6f16eaba9ffb06abda6a8f48a6ba2d0af04fc8d70dc5f5764271fb478db322cde7e55c37e0386590a600ea0d5e3b24b3bf573e57145963ca2fb6b92116723f08ec9201b92f1fe3e417b46e8ef31fb54b3713522f83c5f92374d931f38c1657b952da7fef44c058eb9472ded84ea467da18b4bcb2bd0f59dd74683de2502852f2b919aa7879cdbdeda0301e070e2e7b5c9f3da46d1c8738e7ae350a23664a7a8cdb7c45a86697a71173816b9fe813d3dae1f2ee0e4efea32bc19a3ba1a0c9b34ea53f5d90e242b802aea5c713973841884b54bca904d3b4b290b306ba9d2c4a277b7c940eda97bdb547f3a814975b3c108642043605394adab97fb76ab72a6db78acced4e56e28e863432f73e8a4f11e13f57ca898122ebe7845b2018c2aad465fe8cc8a22551c301374829a9150b338b4480776ce80e1b485464b0c3f05ab90e6d63dabf8acdf2d3331e434855f974fc1f6617e9ea37d061168903919ee8aba49556fbd0fbce24fbdd9b5f49099e018e8e37f53929f312ec188ed5f7f7aebf02e631cd7ca0178a853ad9e4123db740944d73ed30b16d8d03a0a9d33a808f3e01923f9f17d8b1ea0eccbd5b8a38e9b520e6f88efde8c8ec3ac133ccae46fa4cb51aa1cebd0d4547099d36ece76e313624ab30e9c9d68070e0bc46fbd648015c6610c7a0596338332c55c8037e56934e9488e2413ea442932a93650a6821b58e92d073baba776f505101a2de6bbfd18fd8acdb0ca3c044e81c233958cf52fe4b79c19ac27afad2a1328b1b0b287f4ccce3e3be84b3760bc21b96b9076481697fdffc93df16c54a7502f4dff66805eff507a4f03cbd6e8ee7f95527d95fb7f138d3a5c4e005cd88138cbae393711ec09c723a939b1a11a4a3dddf1855a5181534fc70ed717c47670b03ec61a1acc0edeab5cbde03e1e75f94819ca968259454e05bdf4dbf991b622ed4ab9d642b9434b434276dcaa7f68ab7496a341581ce10fbe71f07dc09beee199ccff532c96f0a4d300e4e1f17146984ed71290547e24641a4bf2fff4f726313cf05ce80ad587a1ae5a66bde15339f4c3d79ddd821510401afa9554b7a019266bb4e005725be68ae2880d5c265bca5b9e13feef17b999943e55fe4660de8e90e9444d00ddc93235ec9a5f9af4f58b62b5ad6e80436d55bf04a46d6c43a7d26f849893874297101cedb334351a900f8ca15fb45ecd7df00b8755aa626c90f506f603f51100d4ec1c3fc4b63a6e8fb9f77dcfe60a8a62360b57316341bcbf7bec72294cb81af3108d92cbad0b3a7c4e3c778ca431637fbd6fd240ab392aa64d9ab0d3c1bf9302271d4d59997f68ae7b4661dcb330eb7b38483c2bc2b8c260c931a74470883a3d36c12d7410bbd148bff9ef0b031eb126e0acdf05d242c09ae4f4c315c9a666e26b8045b42f8432936dd0da4d24b7187121618f4700394abbb4223b8fb6c6b7c8016231b454dfde76e7d69c3db6e83216de476b3dd45584920e1a9f0bb9c7a2540f6760c9dbcb4ef655cf760ed2355b9f7d627e9e42f736c6eda3727147e6d24ffb302e405a736e6e5e073964b9f59dd93a1ac264d91bfe3410e0a13cabd6c011b16e24aefa7d210deb142cd164f88d5aeac2b556b321440239db1bc1499aaccfd4630e0f5edfe6639baa301b22185e6cf07220ac1cb1a3910ee5b1d6487e0e9ab29d3954ff19b4f096d984e8ed32edb824e82cc8232cbee2389a6fc450f59e7f94473b05b74f5c27fa1e6749353b12f1970268262289418f9fc07ab1bcb6f885e8d88605d4f7fba81cc5e2847a47d0ca3f2915914ecc700fbfa287d3c7ebddcac7c40606fb06adad05d7ffdbe6aa15530748d4c7bac2f075bcfc0e54058897992245971f72e9871a70bc3d94e9a339cf67c88e3b61728538e7a0af983ffebefdab0a6a8cf29615500e4535dd7cb77c02ca26035c2b5f021bd5facd61536dec3c1c04365d4dae5f092276d8477a90f745db8a461f99575601970b03f5388bf86644742a05732622cc387a444ca4e6fecb5908a029af350a9fca713d3c67f1ebfb21ee1847deff6a229cda02dc1f5abc46258044bedaec64174c9229003569e4b6a2059f51dac2b15c667767667df25a920186023aa63f1c6f0e0b169e5daf9c3d70631ddc0fdccabca46f75de231554729bdbdcc0a59dada51e8777c8dd999938a16f71e512725739655d6c79b5108bcabaa08e0deb3c21d249a3b7e6b9daee9eedd94bdc076e8cc6ba3e2ceb532cecbd2f864ce89c4fe07ecce3b9c608face79e4df44e8d34a7b17b7908242f66efe4f22f12751d0d0f8179d8a05da81e1c33628a1f884bdc78a0da93e06fbe3e3b3cbb287d2cafc3cc4b1445c30b8d3adabaaeeb116a9a6881c8eb98f301eee3ecdb2e11d62a3fad5ba0dfdd225bf89b65823a3001cdd6ad72def517987809b7372180579fa9d3b35bcaf909874a2d077b9562e6800907cb7780fa9d852587e1f311e42ec6c579b0a5bf1125f76003d77b32c239b7d7f609af32d817d71fa9f16087601c3a39133dfedf2247612649165a5dbdc23cb08986dc3eeff80b474b239a36cf6441f21c64e799cd355a02f487afaa97d8b34a36cd5c259cabfa170672395bfe0d204b8036028c1810b7b686bd79eb2100c41be9497f0c0b8bf4702810745da2e2e48c4591e6b634061c030dc11bdc240feb27ad2fe2de9d4c885fc7aa241b9cd1a3451ad7d5b4ad926c323ca95bfadba5e882a7d994bb8f873556fc84b637a587be3d8dac265d5776d26e70d007e983c83abaf5169e4dd048ee72ff259092c8f08f93f10845c82393e40a206a486b5f336320b5c16721851acfd0f06981908f72b85bfe2ec972fa19dcdde87129b8d4b5a9ec25640a0e8619ec31d5493fe6987fecf2c83256e917e4e6082d2aa8bae50c543dcdc1f820891d6d51e2f4c35e68877e4519918c0a215cdc7e0dbbb09ed8c9329c3cded23449473ae4d89f2f31b7c1ebf5f7079c5a935931d15ad3a0d605a4a332a266f64a86fad9107dba92ce92800c6e42df6155e7689ee7e518f38e2eb868ad6b9103871430552035b9d0777583440aecd825d7a388f831e288488645efa778f9ed729d8d2811a50c8279565f2f18800aabd2fd09412920f24045a521bc28c2af4c248f18d8dae1758530b3315fe9c4c3841a31e77a030df6b18e54e564343d55923e740a6a5b120646f258fb94af9206f7e17c49d485d4edbba3ea2c11e479a1855de77aeb0b60ea27d58e4ee78b8a9c5a2d5ccdbfc06a0ac79a7a1255098ef1e6d84e61ef33c24324d09d9d385e62ca52c6d1ed010024515a647bb52ff98393c08b6d8dca2bb03814755b176212e9aa38df271e1b13e3bd4527fc8ac22a9c708c684502850587408f73f0a85a0f4bb393f744c3229382b1b3d36fa6e2b128a29318056e7084554ee02dfb2a6c99aaec26121aa68760094593c2c50e144e3388e4bbb455d37789262ea8a18627b51901c29b7a301565d4881c8ef6ba0f5cb229f4b0076979f7c9ed20bc443598a00936a70bf2d8ef597728e7459b1226a316c8440cc266fddc9ab8d49f9b0976d99c24c81cfeb11dca41121329746fa85ad5214c454619bec26f05d1f9cb316bf9eed525ecb91312c7333a16f51d21e9cc93c8f7e273b33a015e1d381f7c2dfa808ebe1175baaa0239afdfc9775348bf20d502cf2c074070c4aada7237150810350179a3924b85b48b048830f0fc6656bf16db374750fbbd5c05bf6497d90f5b5d2904f3a318f1e93d102cea93bc712e493a987f05d19b3a08e89d4e51ad0f5764fe5ceedb7d9baef10812e04cb5178afd7470f9ff4671c4b038d6c6c759dae0b698d420a1d5a87b11c21ca4cb28358e1fd7270dc51e8dc420b2add5a30b06d10cd55700a1d8ba2e84bfc0e98c28075eddf191a3cea2c7eb759af17048ee564b5c6abfaffd3f03cf978992b87375dcc95b081e1357d25b0dbf81a7c08f4a9608f45fa12001b27cebac201d890706f75eb46db0ff6ecd5a88918b8643d6586c0d0376f9f0fda4778ef21e94b8af4cf0c29e6267c011dd6ffebab7988c64b10efe745af03f04fa13c1f47710eceb23bcd2c0d3acd1aa4f4eba366e7e8b12a3872c484a10afe98d913fec169d563b19b54b23f999ea2716d7e3948af9b53fbccf44492296dbf6dfb00b5f47bb2bc1626a24932e7612dcf4aa17b4fc6815a4a0055e8311e273865cda7aa2849de1ffaff66264f169bfe59b9de1462a0c5ab449155fc7ae6d8658545da7e65f458f57c05f97dd5dd23206a31b472e6e2c79fabae2e7038722f79762a7c3c04666248b1c3c80937abe2c6fd0511e24e16ef6f0a82620cf157af1502c374d51ef7ff3f81564daee952eaea4f0097a1426033d899525bf1832a16463030922ac2a2dbdd41c3841f4d44c5f4bff6d956a1ae875587b164611a5aca65aa676726157eab56ef565c16f1fc40cd8750958b0e341cfa47d8b2a32929fe9054ffe08ca4febce23615ca8eccbfacee7530b533a9ac9c031674bfb0ec688fed9480b338315b1cfec6edf3367cf56b4eaf96fb1ffcbdaa44c802e1aeb082ee61007f86dbea05427b8dcd88ef141e8adbc9d5f85ddc92a3ae4d1caef71a99066ed4393548546658c72f4db75a6bc7c344d2f3c6a0e0371b53449695ade6e77161f4eb36663c4ca2aa4c95447609e05cd74c62230dcf5f728cff9237f7393ea2ec3c71f93088bded6086c7950b971ef01ee0c93ed42f81ecf537ab7d3fb4779023310e46deaa14bed85259263808fc300c290548cc812e090cbbae7114be01bc47cb7e2b2265b27918c6daad14e9f6a0ad5f529f236c94cc539be7f4fe0c73a777a2f292fc3387750a920c574129923e243395088b8749bfbe9d3844140b2b30aad321f15906ac0ce13ed2e25d0a95fcb46250a48f0286e1d96f767cc0e666a3f275e560b64805d0d498c418a2cd90b3cbd24abe00d921a7c48e248553a356ad3859a44217a543ee9234ff796797b23f3180c0f3978c09f9584d7abc979b4c08f5b800f8c36107c59f465603698785457905226cc1ca3bff5e66af9e2f2d804a0950381af867e2649a88bfee54c6a49cf8e0295b3f6c9691429ff35d5fe26217e0dc1677ab455d200f7aa81409ac41426fee01cef8e2af3d99c8ffb039a5768c93f7fba6740e8c76d43ef21f4bef007bc82d320ab54a81046617e45a52f79ae018af2fb668ef129a57a23f821e73cdf5f615fe0cc8308445a5b9712b06768f2c0ce0376ae40327b7003d66da35f82f5324775e5b1e066edc1294567aee00bf1e2cc5ea7372e0f7f60b266c000f69129548062ea631431c7ac8cc18bb9bc5efb8cfbd7a4952c3b855cb24009797cd91bd479764eaba2fee75b7da7268509b4d0595d68a8cb1486344d70c8ddbc7dc02d02632e8e7e0ec6601b41e1447ca9fae3e89acfa76d03f849acc41642182bcc768f77269366d45283a5cc963052d3f77a738620a25ed8660d29c746f8e6a2dd25eed591eb3ce9f1680986365b6ea0ca7d9c62b98ef299aa1b9d1f332b21e9c339458625ff8ca1555bfc10f7e034361fb0b2db7999e04dbef7b859caecc278100fd652fe12cd23035012e9ef24fa0c32506b719bd340bf8e55299e38f5214d9d2f72ec4fafb91372c5b15d699d3a8eb513a46adb3bda908e992e948c775631bf3468fe03ca9482182e591914c39e96a71d68d76a7d6eae9440237b968a8010f43835e37b3128644f2f3f114c070d6351852df75cc05db083bc0bcbdc8b27bfefe1c80592821f365e0ca7cd4506a26da266155d2389e50ab510de8ee6a662b278c78e1d7c7ce3684307cb6fec6168b870bc0bd3fdb4bfb5f1a61255e62ea576bebeb059f58d58f1d01200321ec7e8e2dcabf7dd9350b178e459db1099d9b22a8e2727cc94774a04e6611db8b168a4fa22a526985cf7e9712b14bc6aa11e399e35c29893f6947c9ff9933c7639349e5346820ecc0a61986c16bfafde8ead51bfd69f8c4e297efbdad7dbdfb9720555edbd6084656a91b475f660d410abd6b927da41a3ca40a4d6cc1a81d3ca475d465158316553248dae0e48c8db04fa25a8ef0e3d2538f1b195cf72d0327b51d4ea8c97144578ddc9cf0fd52fe9a9dee5bbf937b022a5e53ebc8562bc8aed337acc7b7e4b2069d847705692e2b8e1fd85b1b7395e67b7e46495edfce9a0b2b9fa17f7d71afd8e09066c45bca687db5e93bbf5e2ba9627ff28ea0e0d42283febf4ef79fb902c94f83abb9be94ab3282ec97c42ac33bf37be8a0e61064f76de58d6612ded4afcf4b1aff961cdd870a5d27a86f73bb437ab2d058217acf72e049b9c62a25ebff0ccefa68ae2436ad5f15e2c38b0ffe9aba3b7650a94cef983db34b46be82a0b557b25e62eac3164747a826015df7384c4d3e3798a038c3ff15a0523500978564dd577ea3e833c81c9e2a975df93c449c2e01b5fd2644373b9b59b998fd24ce81400e70020f6f7550d69b7f08599dc82a74989a2bc8c2ece0caa2b301420981a2b88258b14f2be8021a7909955390cac48b37be023711383f5efd36f886458fd4ea31474d5e1d7d67477b0ed3f525dc7a50656af66c63db90d2ee75fab736da5da3c79fcb172ad9c5539c6ccea8095ef86a15d0762459e602180d750f4980c58b2b29322dc626ee7416a4af4c35f8f2a147420a439e2ca496b4ed6f4b579edf07181c8740d5c3c801263ca7024c2450851039a8c6219d2a4019257ddb625017e2e52758908c20fe6aed5553f2df0d28b61e516e2518d36a137bca4c280983263fe45fae25a6d796f46573b5987fd6449aeb2b0979d9439fa3eb3a437447baa2c980fa71dc3ba6ebcf25820664ff69263e16c5fcc66195629ae8383fa5446e6d7040eb58f692857e0757cc7eff101adb0d5f9e6dff056c98c0289615712b1ce7ab1e29babfb26723ea3beb449785f0b31b05824a08d1f587284ff384433f10b4f238631c7fdd9384d15b441bfedc5687f5566398b49c1cc75de83e470fb347a84168a123c23ff1e12daaae62c223462340252b5603e228360b49f15fbcc6919a285cd20199c63fd5519aba988fa7a4246fb170872f38dd57611c068894c7fafc2fed093abdca3861a720e3e224360ef2c43c69325efc2cc47fb45e825b2aa61d4dd3d87aaad08fd64a44c6c228f0c6f4d98fa3d8aa484e03b5b3c812559c09cf16db6eb29a688f3fb8724ad48a0f8f3ac9d1cddced110f54fc408d135be131962c34e3dc213b4338b48ff46b4f04eb21f5a90d6cd30f2737355ba388c66915594d1742fdb582a57a2c442225d5c1f65fefc4dbefb3a0099525ce6abb484b8e5a68c0ccaa2dc0e7748d8f7b49232408c71fd0dadd19e98956920f7d43bac32f5d9d825adceb06b5b9837e58af372ac7ba86f338d6cdfe27d750c86f743610ce53ca85e5b978e093736eac43f39523b9cce4c2fc1ff5389ff000cf8623ed64974d3bd95d0598951fb03c04c3f1bd01af9e02571e8d553c2c540de60704761ef0f0ec4004a687d2bbed6662800f0936633a474aec2a734955e17299d41dcd10897acbe13a5619a32640a2839ffd043cdeaced3649d8859b6edde8dc0dbcf9f1be47db3870e1ebaa8900ae04c20af0117b7ce286eaf27b14c6c062deb01b28f8614a14d1f80f5ded0e76d807672a2be56770d7cc0ed4e063f2998496087a7e7fe864c3e843e4439e8bc002898ac5aa10cf2cc8c88dca21de9557be12497f1c937305bb6124047544b443de7fa391f980bcdec3ee838da6fb6c2191a64e58f67f76bd3dffe2cbb315241c326336813a7dd1ed7c5bcac286a843f9116e1fb28005b7e521e90071a05f603b9150d872c7bd1b526115dd27bb2bd52ff023ab3ff66ec9056c74715e72145cfc1bbd79d91d300c7e8e5359b76bd74c3596e015fc8635579a79ffc117c85977fa35c18acd173befe9ac60934f2ca4a13b1b69544fa6ed6c363bf8420fa91127068c5239c1c208535578f9d8522ca15e83c60f4e4a34147824db99b0c424825778880975d0b693e90da8ec86d21e14baf61e257c706c970ce4386645946057c968b03db8eaf9d08faeab648249b493c31d940b43c30ffff3c7ced625db18c9ad50f8475b768c896208201b11f1b103fe7e2adcc0cfd9b5cc53af10b9d14e97418d512c410c54cfe1cee279aa99c85c95220d217187d6419b5d1cb51ba614b3ec0f3b8fdf973a9abe306e7562fcb9af4549cb754a6abd84de0602225f0ea998944f35f2d37dd1e117f0fe1bacae3713a3af57ddb42b80e530b1fc675a300b38d16fe442bb0ef0c6d19f97fbc7edb52ca48d726962e23525332dd45fa6ec36a9938145d6ada628fe328fbee28bc78b04b07498b7fa4775748545d9695f28b6574bbb4cfdd5f847b6cee422393632ac0cdebfda04a86ce9cc234219aef5687c9afddff8cc7e8bd47d0e2bdded6cf8abd74b487ecf17f78db236b8cd6dccab7dcb42904e48a6d61f715d784326def505c73a07c011e15f375cfdcdec5a33747a27def76ff69adfe37896d14e3749f8b9c85f40caa6869f87246419912ae32629dd812d5c4a35b484ca46179d994e8500b642df9f94460ee16800d3cde1c1d42c58dafc1ef3e06614fea3e0c0162a1dfc24ce9e1ae470d28c97ab814c144768908677dc24a482ad693d11234cab9db27bec3fab4d148a4f26b978dcceec4a263d4547b528ec790a58cbf07bb55017fc93735f68cf7bcac68859d70df0ce80cdaee506923079069dde106c343282c94c2c5bdf8a9fa20e233f5063c0ad46bfe1ea1293e57a06ac2f9f8b850e89b18c73f03149f33cd479f499382eb461bc5acdab0dfe87d36df1c4acf92567075b1bca5773e3c5726eff1a1e28390d1ef8a2c1acc8b835d77c48529c87f9a753b85293699cd12bb2bbfccaebdcc649a15ccb6f258d7bbe357fd37a150c35bba4309f89b40ebef06c3f03a6b43443f5d14ca96a0637198626b2681a778f7be469894413619f4a34a28bbbd2cf3e5f4bddb6bcefd1f109827ac24c2b7b86f0a448539b00d05d30d339c50077f7c332d4eb71ce3c5fea44a24a0575a1dc39e384c88413dd6c3af0884c94fd2e91713dbb698c6915f9400061fdbe1e6d7f0f569daa7994d0ca9bcefd84856b5a2c1c32b084863863df8a82538cd650cc77d6c6adf730865d6df524243219f3ca2b986ce0699733a1f57a17b802cb02bf77b528d6619cfe72339c3285cfcac3eaf37ef242660d9f77818a8bc0105a1ed251935eac68e0930b0c2c25c5c24569e286c50c48b5ca04f31c9a72f8fb3f3dee02332bdd9fd15c809cd2a8c968d9869563480115bed12a1f6793b9fcb77cb202f6f4808616970b1645f044afa87f267f198d6bec0eeaf737ed6a283414a3eab8de53f05381d8fc3bf112e7d3e445dd69e21b4f5a085e9c3ad8196482998ab08d14898ec2fb3bf77ec55ef8c226f47db0a8ecaa6fa86a293269a657f909cd8999a206821f423a4fe0db872fb7e75fd8f52e92404529ed608554fd753269076d9a17a427cdf722100a60647d99ca9d74c046362a3b6bebac4e18cef699431e0e1a8fb4d02b0c0a9a85ecdedafae9a85c0c4df71687835f3030f98011b3a243ad852fc2ca55bc8da002c2e3f9063ed4e9c4f3e071635bcb7b6629b076b65a6ad16c42eac0c43ecff890f1f014805e6373cd734380ae3d1c8b569b5ec45c89533007a29d0796541073b7ffc24b7fee0cea6e6bfe601949b89454d54a1483daa70a86f8a98fad0ff0afe53efc5e06fe5ed702c8d1175db430d174a455d1a61a7fabaaf2f3146db7ac45a7fc7626f2b2e21eb84ec24350dc87d675decb8ba87ce86239284e77ad382c16a99641555d7714db4b7f1669e5ee08595031455037202a9ab0b4b0a7b5593f2dbdba38045764dbc55d487e942b0903366570a57166cae35bc9c27297c8cd05c5885c38e4707cd5c3de046d195b36203555428796660242f9976b77b128a76597a298d8a2b253cea5fea312bc094e4a30a505b43898e1e8cc828e2e0c461db07450b75b4b120e88f0b8b11ba7f29d20c96e6fcceec9e09c3ec8f3ea4cfd61322936becce281552fe3936ac2051332a95badd10334ac83753c118f2adaa9b429091a170b94a868ba1a696a1c72e637728bdb2409b1c3173d650199974ef4c09d52575ef0b745fb236c4cae787a19decf021e6eaccccc9c90e7c3ec53f55b223035106e8c44c000f0b285ea61010a8d26dbf081b0e2fe3924073769da05ce659c44a795effbde421f08c7ec379669985a98f5fc26a8c0d02d0db27470825e27e75bd4b68a5a1fa0793e7f9e72fb5258e8a74a34e0ef12f9b7d445855252acef6e073c04b1486fbedabcffc46fd944bd44adb95db18c29e8f1c48d3b701c7a47f8f2bc669208d8465b47fa35abfc1cca0a56c5821553a9b158dd6b755176c4379e48cdfb9c41de32123cea51865e0fdad90b735c7ac0112dc1b806451e9929d96390c78b833bbb93f2dc3370e91809e2655cb36a8c5710197bcc708908729ab4a8d3e9a21b7e74e0d6bc5ef894351a6aed2b24a34a94c9f4156d58dde93724ed7f9e0a1e00b700f15edc068c46ed7e8bdb59d43b7c8dc1611a65574938db8b46bf7071f47fbd2b2d70783459da389fd3e707868adc7421c9b59f407ed7dc9acfb9821345026181e664a9cc7c6766451427f15ecd7a7377502b904ec828282b233184773645e039bbb1358d43cc96015b6e01ea1a941f2cec2b545515fe6a5aa4d5904e0e1d3dcd0e82ac7a9d4f794a9e3944b6acb88ad471472612afa421f6aaffbcfa7630ea5dcca1c9105fb478724c48194823cd83bdfb6b297ae962a141f148971b787ffddb6fa848df1d1332b7d10001f598b8bdcb2d51e063ecde2d2b81f810210d2401678967e8e60d6c07bd9c0364250d01fe82aa40a6fa8549891897e0ff6737c5941674a1d264623a686984bbbbb947363d8df04500e6adafc015f0d565d995b314b146c1246f65c3423bba18f14d0a597062a7744bea37230af102b1e796ee0870bd97f9ac6b4970d2f0f05f8d46d432ef0e59fe77974dcd3ba75241e53951eb342860ec6f5f322b8ef9f4105e137e49850c12b9810a1b49a6d67b988136834d81dc6e91b601c34766405ccc9b99eb844d5a684116f57b8df2b312b68a38bebbe607d634f4233e3ef35a6189aa94a66a6d0b1d97123e53d1f9e9c85a4bc17731c673afc1584049ba05be178b7a5bd3424d8b75e333dc48bbed0892a6b6db5cd3478804e396742814af4df99fb33609661954a368718ccc36d41a0f873fca463608d21054684687c7ae4c4f6fef87f86d242cf5f021653c2120bc42e2edcc357df3f7598f9e1edd365d022d34f2f1f693d654c380265b01fc18d17ea15fc6429e35961373fdd5a376ae62d866d714a510c949ab73b6fff7ce43447ba64cc6d9eb97cd5fdac32f63288b14198d3ca6df9c04949d2b5e1756cbc28ddd044b07a4382e842d20ccbc7657f3c66060434904d5c7b6f4dbc28da3a373e9377aea33d4332c857da96a971f3725a34a769c136930ff1489be78c07cd941277d4b5e2e6acd932a467c660bb59d423fa823b95f520bc4b88b68d9854aa785359d5020d08ae61032bd13fb561329e833ea092cb8c6aedf24b9f6866c1b8dc66769d055d3a3c77669176393326d843f42a1b241afbe0cb7f7f1a6b3efdc67fd2215d874fe440679e262f559031e7969394166e253e8b2336c25bd4e8740e0b9b67650c63ef0fb544a4d974316802fd35095a9fe48947af1e78b64876202082c9fa84a8db48d0d3ce7f6331605899b0cf2a9115a773e1dc1cee9342713f4cdca61570f629f58f9a22b31a5b5536f88c93da7cf68ebcb9025417e3a47a1e123c0ff3c3f1d5491c99faf8b2d644091d5b1ffcbf0889d8afd24509b607994270d71bbc48c99d30335595927743ce1a1fd492300181f1078812bb3468782ee985c2e985fac766b44d1d3af901dd2ab10231d32241cf9b23e065e16f68f992e0b85da2f54892150c5294fdec4ac7c891125d76e9c0a9b932bdc7164fad3ba1f307fab0332ded1f7ed854e229ef24c6d1164b1f0a04d3d9810b71f3b2d12bc93c39b6ae9d40ac8b0f180fd4b34b312feff08e1484f6f50c1a1001454c5940a94baa2949f771b1349c6427aa6cfc482d8848d46104f326c69438e40b7d873a3063c60844c0cbdb902dc6ac0a3ef6f3a796e31f3637ba0c3ce030f981abbf531375718d3e008c52d0a9bf60b73ca9c8fbdacc14971a3159835cb734a3c733ef845464a51d53607d1fe8d1db85638fe60ca82da0eed2a497cc4f68a8d4bdeaf9eaf166281ba2e9404546fd20b0e6f0afd5567a6da4be159a378cca14685dac7873959f387fea53b7ca8bb4bfa6bb65b53238a75dc29f671d1e7e9e2c5cf6685245f2b136509331d5c9c44bb0cb951e8136f6b24fba445b11e6c742f05e9edee70e7760e5da98149fe9ec1fac7a0f260c217a50707569c9e7aaef1bc8554c5064d2a5555b77e64db4d00f6ccb334e8c987cd9953036a5747ab14ec8d63e9bf9b5602cbc21afcebf2d4d6a52c62a21f6bd2e4d5e90805db2600d061e1997a3d37ba4ed60d306db86b2bbc2fea780c68129452158308c420ada4563e92852d7db2a473d66bdc1386344e2408aca19652b7ab8513fd176bba534376701d49f8da5306f3ff9854e3f148c8eb433a71164e15e8c94e34bded60fdb469ad92cf746171d9700bd5d8e01668e655bd5be157eec39a21e842922d0b83ec0d374dc000366f30d0ad948126b721260fdc1ffbe25ff2ae38ced59ed14cf221442b4b0fec18d66b3f16daef423661e687c1f2e572c0c7b6e80c7c555f7d0ce394119f0ce930fca9c0a94441b4f75d0dbdbfac6a7e01771cfd92d2c00850fcf95b208c6e88f2e3c702896fffff569db69a7741678caf07a15ad558bcf1b13b587eab05c0af2f38a15be7692f76b90ce196d05f54e0e2c081764fb171539d0e2293879637dfaf455bcf39d9123587053fa6656851b0f16b56d15f64aa5c1856dc5db3603b58da93ffd477ce0cc9edc1391a743a9ab60c80bea273c0d825120a42ed815494fcd4bbd239d1f9b6cfccef422e83c530583f3a438b50d888be9717454e017ec93e780c0dbd701113fe8a64b57af38562e0ea6a55dbb3e92f4608bd4a08c4ee782421fe10ba5d0338a79bd05bb05378abcca4fbaf76bd428ea00a3dd4349ac406c286cf1bf8a00df7e18ee455789d77a76375ec53c74ff11f9ff3dbda8ea6c5955b2056a941b41cdf7ab5ff4ec83705a7288aa1093f7459de67734ebce684ec6813b1f1c00fd7f3da9ddd1d6985c1b9156fd2ab10891eca9f29d02c650e1fcb784d31fe8eb5d2372fd1bcc1fd039f5d021ac6e85460132c65089b18c7788e291dc0cdc9adf864c57cc3bfa908396012a4208f6933ff546abb3736fadd68e15abcfeb260328c050210ef4be8ccfbdd90daab5219b1b5d8a38ac0e8c862fe69451feba1ffc8a54e6ceefdbad2a497ce92e88167659e7fa6be5b6f322a1d833cbadb6810b9c7b675cc7096e735416cd24767e2b62f9b637f6eabafc68a505f46f0bb9c691cc931b1fb5278760780bb7171912863865e7b966daf6d48e828e6a2c7859658a97710f7a074e08d0f3a7423803da62a77a13ef8f1a201225cfd267506da363612d2155517e6b8c9b7ce4bfc1b7ad6abd951c2fcbe6e2c2ebdaf5e36b6f5f105f97341d0557c9245a0312d66950daf414e5594a11e59d965401f8fd789953a7c6189bafab46c464cfde9802410676ed7a38b078d9050cd81f4220cf74bf38866179861584e356cdac81bf5c25892f2e81d5e48018bd92dd661d1024fb85f95cc19619a9fb97a3da1f275b4f111219b2cc7d42501dfb6a1a6f371feedea2360c38599e73a770eef7bc6ee4478295e6c1265361a8e1de203c09e6806868d25b2f63c0b14bd67e57d34022b64f9cacdd77f992dc5d8fbdc5222173a3b17b900cb4d376ad5cd43dadc9af742fdcccf1be79ae28d71571ffc51a3d247ab6ec9d3b7f6a9278737e2307da3e7f98b75b6ec14b4ba3f7976fe6d8c197ce68c8068f877868224ba895469c0a95fc7045f8fbf5d27e90f11c689ac7a7cd796614f8b208f63100877b78807a5fa5d002a92babee2ff3ae3c4c5c0575db0a91e187bcd9bf2aedef72f465b7215c95d9aaa4e20849f9186fefd55e2488cd4e37b0f1b037357004d8b2302fac3618f235e115745d7624a7503a9574a9f65d4cd8ad79ee40cff4c06575828d685884c9bb4f0963f77791d4c050f348f9e73bbd23840c50e50089022cdffb5f570ff2e48dd0e21a6dadc208c815e674e7a44e5c177685672fd620597370b7e6c1cc30043417d41b6745016db40a80a78b5b5faa783e5cef33fc896e847bbc02a91b39e545880fa19cdaef10d7698271e4ca8583d80eea3e6c55fce185a3517083d4399a952f3fbeb183b7a3fb03360eef13b3d51e0066b62c2f79893a16e7c76074129bba219e468a28e7863adc7577e77244b453e6be60142c8f094f1b14df0028e0d021a76cb341b19a2766e27877df4dc4eff7937623f7cee331eb9e9049c98691dcbaeb9b3e11a3ec8360b46490b09c7af32a252b03abd1a195d8b3ac96ea4462a7b5c4a4b9ff821777059bb9acc4d281e186b98a9bcbebf490e05ae159ab1a91aeb961a31fecd6f69ea0815319a797d954171cd7ab4cb5bb70a134d906bf5a59b4f51c1605b8baf3fb3506953daafd102d4fd1070317b404f12c5030153ef0cab4646a3905d03b0dd18fb9ea95b6315c854492eb750e600394d50eb9fa555a9b1da4ab63f9e567f4eb19ffc0a4f28d8d836a4eea7b65da0d84f70332658df8f893595185d2b70bac898dd82c31bb9092d8403cbe792891d29b5f42e2736d65068c2b74debbe5dbab7131d68bea8a3e3691be901740f76bd3368844079a9fdfbee63aeb2d3cf6a319a22d05f26c8442a683c8773c76961cc1c2fe852548d659a13ddd0dcbbf8dc2388d36bbafc349ec7adca53fe6a8a5fc846232364cd8f3597b20ec134d5ff2fcf62ac041aa4f5f1184e162e3203f415ae479f367b064a113a79183267b19c083daa361d46ceac7f4c559af5485bcf413985e90601edfa9bccd4091d3f4c785a4e34796a716dc7d3d097a428b2811ea3a51da1344e2bf0e632f5df76960598abf10275324b7392ce9484a7f6b48d799732cca4133bdd42d8172a6dcef746031643ee2e12cfa4965f1fc1158684b01d0ac5cef33342b59f28771a87caaa6dbe7f2243a13c9f9de79ddbe3855772e2d7f2ada4d5f326ca492d872815c5031e4e724fa322b0d0c6fd15bc6095f5e21d7980f340e82d502d7c6aa803be2e47f2c197f4c92322df342befbe73f9a41bf797f21cdf3c38ca416f16c33406eee38f9270fa6280ed9ca29297c79f084a2a733ebce93d2e7c16046565e00b55fd63beec649b923cc2052b1928a138d4489b0e2e8a7547f6604da5b4097b10bfa4479b025fe440795550156ecd7920e879b1cd148e3c0520dcbd6810aab961315683a0ed2bf41f8b8d0564811d84d592a9856a5e5c5e160921bf885fb011319f66577fd02b1187519362919699fb4229186ffe1771c339d1ea17b02b4e71c9b2492708235e484adb66dae5c3910de3d6d3f0242a2721f06062d20d265295ffb70d29d0db37494c6f4dca6677250b3ecc0b8ad2ea6c7a3117d18a05632ac26a876383efe78fd03e72053f7726648f38a4d1456e7854306d24f70164b687f5254ca2e379a87a61430fa99fc5b3090f133404caa3398b590eb70b88c8a5cbf43c2fbfdfbc04eb5697c2aaab144d48a78ed7e81bb85c949c36757678045a672c50283d1015a7e35c694bcf83946c38c833363efda44b2abc420b0213795bfaf137147da46d136102a777aa24753d74fe5dd04d957dce42fd076de4b62ca017fd784cab6ab52f0802eb03f96fd1c54d3c5c64f850566bde4218c78bd89244e5346e47bc95ef15615643a99f3b884206a34e146c220189e5dc07260e55ad1b526951f531725fbd95cceee0e603f7551d5653d922e507f623fd5a5bb47de34a0c16fea485500862c59fa54b4758cc3a3a1a78b575c5b4654cadd0553983a720b060ea8d7e460cadc5542280f1c1a29cbd54b3522a7cc325460e29eef43e7230ca2a9a37e0448a1dbe7d28506df985ea42a1b6706432abbcb592d033c99ac0a9b3fcecc7880bf937925437e79b74e0d779d6b4ae548fc965a3a51b398ecb6a4be0709b8a43252668ce3d7c26b706eccca93dd78884f8e286a62592adc8d8f48beccebd77be30049530dd643debbea89af16c8e7b94ed0b0dccc85c96f59100482a8a22fa1adfc5b7ad88b977eb023aa08fa8b942e33c113ce6f18630e243e0eadc3a2190d7db4add3c95567252bc7f2a442b92823b56880a55737745cfc63b318993540980d5de73541bf8b2d3e4a2a8a46e70a1be8d576546ac7bcd932cd572f3f103c4e7ffcd805e18a2689429b496a2f22f79fefaf4c5ff675e3dd5794eb273aada499ba802f429c5bbfc1d1afd183ead3978a7966df3394c6867ea35b40ee3485a02c973d1ef439399341f4c4e490979e06c07f7f6e5756848b0fd8f11bafa8e54436d1887f50c6a542729f7271fd34ee9db50f5501137542a4a7fd662fe75a69d207def6c4bfed3b96c5ebca4accf213a2a2bad45a52774e7f2381e178b3b5ba496aadc38dfd369bd93a3023f09f2a04b6bcb3831ee859e81af3be9a5692b24a043e24804e8d42dc31a881532a903c003c5de98c16709541d4ae7c9147a903e440c2b861e878ef3b277ce063a40ffce2d77d26a1e06750188d2d40a5135b0819516909decca1f2641a9c0b810d9aafa2b06a709f96a955d34f4b187eee2603b3fa205a7c06e5bd465c99cf394009a737a60de0df01a3134d12dcf6ec557d161c8e10b40ccea804819457421e575000c594ad07f27a28c52ac0471385e055f396b49889938b0d1ea9a281e204206204edc7a0b60f9784578b390817e15485f119f62fba90ec9ca25515522999b81cdbaa37ec60b6668a2f572e3a4f447606752cae626b22335b7cb9e2c0e9329dcddeacd8529ddd65159bc4b326e016e27c5b022a442a94fd03c52f567a133ba298a9620c86f34005542be68292ba2f88468bcdc65f3115745297d59cbf53d7358a1f3f6eb8c00d1448fd8fcca315b31a5a2fb8cfbe3b0981405e4ebb35d4879ef29ee0409241cc0c677f0b817c7b1e7f18a642c73e74b427bb39e7567680a18c3a35fee6c18c2625e6812723531abf8e3fbe156181e382aa341210d5d0c17f18506d21ec84c7d94b86f3e919d853b094ff0b61518ab2d4cb4f6fb8f16e2e344864fc2bf22ca9c46e5d7f3f89b8a9a2bc63b04928fe711ccd3d0d7c63360ff73671ce7a6c5ad680b873b48821ae3228031fd5047e65740c9cb43a4ce6e9eb144de6e143c1165f7e6114e4ddfc6c2ade85ca01742eaa8f1e31b17f1518cb1b43e802e394eb8abbc6264ec01f4f969d41fa7b6165dbcdc19dafe33219fd6e466f0f90fca90387e31833afc58ea2b59a52da5b4049b3f0d013f67b5b43560b5778a978fdd43f4c6c71d2babc0248a38d773f44e0464c48b22437d672ac55e4b6383a8df0c176526636ae218da011d5448025fe261a12f85ea44b5bdad360629885f6bf2bdfb996dc49168d03ce09355198256a1ad11a314229260c090f8f49e168022d60097dadf2c7e52031f52167222022f7fbb350737459212d535a7e1148528cf32831cd7ba6eef0dd704e37dbe1639ee3237c1b84551b335af834806ae11e782e492f2525d3fc4f16fd69e2a5061a0f2c762f0288fd40c57db97c932ee353a8c4b755f2e647bc4d07bc21a8ecd837a5a1248c0ee815f2f2cd2b935e52fdfbd3b7106571cf6477562dbe14db7d88ff5e63d53cd199282b2055dfdf58b197e8cb27c2ae2093b409f6e3a80c8b041832ff0b196d853293aa1d6230dead9e3a6436b773ea97d8299bc409502299d83ac0f2e0d5581292646b8e7a3edb214b70476a374c9c2868f9b2d7d2ee94c1090594bf9bb80506611be371528665e79e6d256f8f923526b97073a1b1e5f3b15978a6bb7086d5edb92648e19909920f663044ed99521b0693fe9c2033c6d7f1aeb4509e9cea39279e937dc67172f481edb49cee7ee1fc54c43f8ad7b14c8ec26e6095d59927cb7c99b1ed0dc82d3417178de3f61a8ed26877d840aafd47baa8286bec86b3eba577bc97f8a7a853e05d78c2d927cb089d89a6a3851cd0dd19c980edaa5d9cce2112ccba24c49840e3a4932986c37ef47cdb506b18f67180030b1c0ba44ec8002437aed6d86db0662b900f3ee66a873053bc0806646ab7323fcd35c3838f4bd84a01387617f60ab3c8ce175325e7e74e6467e3192a9d1fe374b1d28314d9eeac2d2599f109f60728d37d393f335760896008b4a78fc1330923910f487499d7ae1fe0a0a39930f13390107db757c7b1eaf7bc6ba526f72aaae8d04f939aa783b9f01af948e5b82e3a16b49508ad17f2afb01a555c26f06a0b3ee5ffc7fe95db8453aae6c16723923f0d37a8c91c7e0fa2ef6e3467e23f7f53847125969d61276e3fb7042f5cd43cfa75b5347503a8bd236cec784b54312b2c63c9e902d0c6e463c9612c13a15c9b195e2e990b47410a5ab3efd224061d50075187b30e647de383bb0f8e8c30daf5eedee4fe26ddac3a2ceac7f1b69fc5bdb42254a660d07665d2f3b3b56cc70a8798da61700272cdd0d02fca6230db27718ca2fb945367314cc8cf1528acf88b7072c145ab905b200ce0c152fbf6af70a11782f43aa42a7552412a2e7ab5a4bf10adef8802103c3f01c85a9f0c202efaad441bb73eaf6d5056ede28764156ccc5a032ab7767ad4eab6bafca7149f742a78c6c6e2507b58b69de192e9fe24198999f98635e53be1d0f6bde43a3bf08d7768de37bee624d6fe517d89b52cdc065aa88ddce2ba0155846e59e72e8713d1c9aca43fdeca69ac942e802c7f7733aee5c5611e4e06f1251024dd5ac87fbeb00a00c2330eacce761a08a21ed93099e3a0c3ef380c6de17d9e5a1ca765abf44a83b7393425d67c36b1fbfc5298a334a228b60cebcbf954f52fc08d237551655dd4e2f716314a13835829e33cd0fd89ab759bfc8ccda6d1281317e0066ef442f995df0d55737a2bb05ef3fe170d4defbb01aaab8bc65fa8610f5732b86a2ce42cbc14c9aa213061b379ac281e26c1ebdf6608920a946604feb99717f22a8465af95bad678a1278a071bbad6266f41f70806393f56c2898a6b048aed6f595ff2b482cfb9cac208d84c205acec23beea82cfd7c8dc4af25e5e5427acd5472ff5bffd0d2a88eeda064201a28e319fbae9149f1ac85822c2c56a39e5b9496727c0c39ed6fb0e90015d9f1dec8d7a1723a0e178275100a245e722c6faab46e9d97a15af36edae0639f13f154b72bd8da5ae872dd3a849c71717fdc2f8348e92be38f5aefd37c9afa068cdcfec48aa5a5e46b1968a31e739f4f3e96ac8e368a73b49dfe9e3172f1d0d911e5c91525804a8daa3cec7e9cae7e1190ca817c2b626de3276370f0eeac7f2769b41ac4e2ae66294032ba2b676851b309393b7cb3372490045c746ddd08dc04adefa8c7fe5594b3253d65d99958233dce54b729969d12d6036b43a04a3592177f4c7c9269e9552d902b3be258651556e4ff7e6243eb3c66af7f058cd7b77e02a801bdd74fad9edfe4144539309cf1820142956bf69774423b6ec921a13d4a47e9a4f72c1862ab12af87a0934ccab9390394a8227362b291e9daed552dc0b60100f789ae6b979f0c87dd50af0677de282a46ca9a5c23196b7714538c34f846d14b3fcf246672f7b7c677d1f16de2eb4bd783c9834921dbbc1373520e28a4caa92758e59a7d6a26425b1f79054af3cd716d3117d6fc26e59add6015becd0c97adb13481f9c5ca31489ac3f1b4d1cf78550039cda1f27116d53132f48d20abfb619b107c4d54f602eb9853912aa33646d3bccccb267c85d43b48091f9b636c4a22120e22b7c68b074b634e7c65f4f3edb3d414069bdf0e994c2cfa9727797f44438fb66070826e5fd624732094bbeba4fa13e03cdbf8c2bacc3b1c034894894ea12119c7424220151c8aa25e2f4a8af076b59a5b1cb3487574022243ded764a94a85cc14f01867aa7e54f05548f7b00be98511e0cb82165c2b2ac02c1d04f320308ba0d7f85789c6d58f02e15f12600800a4e127070b004b63f138eb30e4e90058016c1344aaeaf7b9fda8d6b21f010318628c0f781d93940d8c27a5f9a10df58e78978a9f077e9151dcd5bc32d8f237bc95b1b80c6f71f138df8c1a3f7b692d1b317448f1ec2843e3117f4bc7ce91a194d2a65a31bd55678fc2a31667c2a5deded998524f7f3cdc3f995fc7eda23ffc71f3ed94eec24377b470c371d5989b9fe3150a9710c695f23c7269b1ef399d3476476668751b419eaa0310746724ea247e8f0fea033caf8a878f50ebbfd6aee5c9f2616ab557b5b15eeb22cb607a9ab2707de532cea0fe344c54a1bb7b8dd926648aa8c5f85e0ff61cf0d583c7178826cafd9e27aaaeee07a8bcf31372bbb15de103e158f261ff11cf27dc8dadd183af79d8233fc8edde710680a3968499638dcdac71e397117e9300b3a505fbf2df536ec4964aaecedbf075bfe607a0e4db07125c257d9dd9ab994ee5d37e79f8202664e4b378d69a08030265dbd0043f5503f36912d0191cca6d29dacf088b2d5e76036aa6dc769601d04aa16bec4fd0849290327853efa36c2ed5726c895158abaae466eb0d87b1921d5c3f4bdb57a27451c5da1930f4f64906b64f8bf6500c80e0c86d70a98a746585de479cfa1b6db67147dd54d5037db4a2fb2f115e9557d766ddbda8e28d0793afc13fb6d1fe0cf39e68e687948e672ad9327866ec462e83b894e3caf9ef2400a63601ede8cad0430e8f103fbd5f5e20b4c988bbfdc0fb0546c7f0ca690dea926c0e575b43dc4ea40ee95dcc24894ca553cc29684260a6707c48418e17c4015ab4a9de8634b5daa6a7da0ba87520b3e8c901c138fa36fe1a4decc023c2f2bf0c820012ef480f9e93f6042624d0d53cb21f0c9eb9713611ecca3bc32eeb4d7c679639974c3ed43a1fdc8a2827df0798033e8869bdd7063a4bfca0d122b42ae5027798e0a54db356e8057346467e81121090de05ae877f2ed555c0adec26718f873295cf11c96d0c1f6ebd5fcbfd8675bb7644f4e7e8434442e70840445be6131ded19bb3f58ad131b05dd2ae6919f3846493a2a9c782e5c2dc457e414f7d4e2539624f04975823c3033269161ed5e9b15c4ad3da3b0646574a70b4ef4d9c28fd8a9b97507035f083bb8edf5b6679bbe44128389ed0206181e4ed25b45af7a1b2fcce9f733d17dd9782c44d69b8799b859f805e799f38c267eb56324d15e026ed8478af2e75ed13c2dc36598531a2916c5676154ad8617087b0f65d7f76d40352929d9e91298667ddf8658b3cc7f94793c2abb2fe84cdd36198563e960cafbeb686b778845974626fd726d68c7aa991c8d4a4a4141fd3ecbd9db33c14724510c0e8bb584f4b6230f4ba1d4ebddc596e78df73b6cb56d2c39fcd1f4412090a3dc02bf218ef2ca894ed0094f1ce873179f11fd2d151a01011efcc88a95285ad72392a81b98903c515635d5f4a19cd1d10e67c0e7180f8dc49b795c6fa6c5f98ab9fbb2f0df314a82ecd693a8f96dcde610f7fd25a86b5cdd9d70b5cfb9868695256a7884321baa10c06152f0cc390041d50524efc00dacb32b90281a5cb8bace2e1461fa074d48f37239436e09271699c1713e28d5fa93c2a77f6741b3d683d6325a538d4f19c40a022f1c6f23557d6e782c7994b21e26f6acce4aaf73663e89327c119992c8386016fb16f7a3323db0143e0d481019878cf64dbb9a05f5dc9a2e9d2b49647d12965d20ad82429b1ec50a5ae8ffcbef0d33a22acbfef4558762515c0767327fa57108673b9a4e89f0bbf0dc4454b108871bd356f03ed5fd43a1eced824849de0568bfdc77fe0cf1a5a6d732d105a0c605353e8d4b80dac8902f3ba7422d7ceb725b164362991fa43122110832928aecdb3573fd89003f9fa209b7f9e5ed48eb61a245535b3e60853918f0e921c18f505c725469441d7213caff3bd76d2ed904324bce3ca8ab0a2c427267b7df548c221d55ebf67b47c369ee076f0bb2633b07fd9f752ccb0a0530c14ea650fc49d964b6e3516a026e6a3a5be87ffafa527a7341299a21d908b6fe6f7783efc68f81e5415a12a27e7156cc6e7d4ee46ef17b473f94e5273c19f5bc08c5bef22d10af54102eaa0b6a17a8c73b9218876cdcebf1b7f31dce6c8c02497f3abf8c04de7b3a3fd654844803f759dd44c905b88109732b95646bb6e7cdad64f56968af8e85c288f05e1bfbf058a5d7b73e849771155fd1581844daae2ce7a4e1643545d6a5864f6e464dfd3ff24ee03b560234653b02152c6b902b39e1ccd45f97116ba1d1f799146052b6e3654ffa0c9f01276ababa37da029f03a17ec3cd2cf34630c4e901424b6e98465c919791dc048eb251d122da4111faae85c49635e55b7e2bf6556bf7edf257b7946df9678017b4c9a1890a6b2f8fc051316c4381d0781d16e8e854e724137c623150a2c77c5ebd7f6cc93957f84516b09eedd52ca57fae2645b062055ceb61c7d138e67c299e4f5785dcaffc3896201f5ca9d295c41f06d9ddbcd25a10ec6605d4b09d474626aa5a827554adc4066c9764b3e5fe1f3aa5f9743cd0924c362f600e462e26037ced8afa3db757d6498adebc81c66ec3c92413130f15b4a415ac5973ac7ac0e28409166b7b765623dd6239ac35ba41c26577ca3918c3bb8e8a242bc0c4840c852cfcc105fbf0845f9dfb29ad892c1a4cabf636497670dc30c9268df54fa01d57d9e9d28798cf3f5607a5ac911631d420ceef09a7b964ab7a689338c09c21252a7562618e0844dfb50a26c90d89160315b570985c798de595de4bb6304e6abbf2515381df84e7d2e920c13606dcf2e9e8caa91840d364b562a543c6cb94efecd69fba5b26ef92a564a4b1710cd00bfb4d480931234e73f2e0e37529e61693db4ab26af992b5e9d14aaef5727309aca814aacb10a47e6681351b6e7bc501523e453f61de73bd38cc25398d042b934ce40c29c8a9005988e27097fb3c4ccf4f8766065b77965f9b8ddcbc290f23c2ef90572537cdacadff73b3d6bfccbe1ab75f5681d51e504a1a315ee9904166961f2a5404288f08db16530b414a00b3292abda651bf3b10929bfadbefc13e60336e9fb5194a7aadabb20a876231e8712a8514b96d9281193826c0444232ab8139b474c212394003aeeb09713a4dfafae4c53c0fab454849a3ad23e0772a11b94b17b53b93b446428e8cd086dba36159d2064434819bd0085c5031103985e8d45fa694f9786d7cdfd5767699b0ed9c72b384d2bc7fff1427568f2a27fbbc1a6ea75b91d068e5a20a3449fb999173b446751b26e251a633a2eef16f234c718f65026da54fd5b127ab89c87125c5060ea7d9c585ecda2416ac9211fc16030716b54599591f45f8b8752de8358abe71d03beda3704bcb3d73f8f1b7c6d67d898244d6e5c81d41e189bb9319b08c08a203a9bc6ca708d238e824077c953d3c50c0f50cad2ffd52f667e19c6c4722edc8a0467884f26d33d585ed8d7a216d465c303de46fea8cfbd00ef15e850e038741805ac29edcf96f10961a38ceab9e6868f57375423c5f52d719a5cdb84333272a7f2ba39a6a00dc2fa5395a1707fb1736c46e93ff95b579a9897990d597c5a6b6232263281ed852e28a16ae34e0246d02dc4452ce3ca7dfb61d62ff37bd4baac4096e3d8852e92b82e223f76ba4a104fa1545fcffe35562820cd64813c1bc464d8b808ca93b7dc72bc7e6ac3106e3df99c323e70c8a0cdca4ceef846fd820dd3d6f69b4a85fa8ecaff09021e7d661280439fe8bef527ab6c5258f1261adc3d2652a61a4d28f8da07686a2399e1d502587a6972ade2dba27e56698eddde0e1359f4da2430cc91fb455c761b0e18d4610d0e51b36304efe0aeb47056ad91e290b67233588bb7b25ef4d28c71ced86eb8a0b6f0f72c428f19b8413ced7cf438a34ed1602e2c34420df743fc766d5ce7b7b6d0da278f9369f5ecbbf5ccfc24b92366778cd9bc503d444ad630495b937d2fae8b95007ae82654d3feb86df0a2c2757f1525269667364f0e50d12bb813e13115f33cbba815db9622055832f58ebd08b7c3ee2d68ca49e1b0394ca84fe37bdde30d9640411e64b066dbbfad62e5a40c4f5f34aa803c78f03eeece04664cbbe79cd85fff5f3327f552c3d9234f90c316e9d6ffbabe137b73536c001b865828d79be613bf630efed65f6d55b6e599513fa57d798cb4b74fe3bd50bd7cdc91a8ae8dd423a6bed34519412c1633dd7fe250fe2bcdcb8335b1aae00a7c079f449d69fb9d1c502a1ffe6fea852b537b6af987bc8181597e486344651b38932ab4ed68d5cca2619d649971ef2fab536ee6d1093035e05470e52642cd34f51c1f3317bdd7ef5cc0f03c737acd3386c70940eb5adb7160b6da4c86b0471946ec9289a7a8642e183f7af6c71e88c839ffef7921235885b9d45a049b08c85af7050d18d6feb1dada5fe0ce604e29ac84ac6f553985811b8e2c20d1eb49607c6e3890b25723cec752857bf2ec8a215e166473989341f39c2920f4fafb1adb27c97a9b87b21045a59c8ee9fa7e0b31d417db6444ba13d562d669e8f7f43012038399f4ac86a5c48b7b586ec8c84cf1b7c4f18d04688bee5a954594c2ae066f9d0337c8c2235fc416f23eab539af7bf821e125a387f7501bcd5ab4f10f43bdabeaf6c528cf3892dd30125664fb8b632d94874d973ea67e50cfbacb7db80e5d8cba385adc6c9a2ef89009eb97284f0546b59b3a36c630fee527ca1696954422dab8c4e179790ca67ca1215d73859a8541aab4fc27c2ad7f8b90d648c327ec267f1e84b6ccd8aa382745d4e81ef80927e2fed60b2c62c872b194d4cb9c4d3b4115a6eb673e21406c68a082220675ddaf3b3cef35385aa66975db6d248922d1c24182163ac29e72d160d3851614f6fca536d15dd502776b1e85142987cf5db4714045b656f05060a2e625c92cb376495ad0b067d39d31cf9da9a37cac31e0a9c34d79e7378881eeaed89dd2f007b31ab4cde81abd7fd4e8605ccee3ca319b1e7bb7f659ae3e937f581103de6f1a0390f308927d408dacc0963e03f0a5963bffb2c6ec6cf7404f4993980833ff73759954a55142fcad7d5765d2cc1238df284aaa2d567422258092e0cf470090fd924ef0d9db41fb5bb318f07b649e826298b0eb4a188c18d3eca9a7bc655541756331ade514b11ef0ad216c362624c04b80f46e12533fd74d594d3c95674f7c8b1e4da2aad5047ca5fa3fbc2f1ae92fc48d6d6597375e4826bbc039e3f4c8fd5c0810b6148027757c04c09bdef384f6ca170e30f70e4d1efd6a4568080d8ca7ff988c988aa29e71668ac56fc390336187f35ddb30d6d94caa9e5979ed85970ec4f8f6cdc82a6639668dfd5a3974b8aebefdd7932d1c80b4e057a20f07af312d75972c258a6f34d0bf8edd45a04999d2c818cbebf8b696b682e6178ec2892bdd338efc27450d1a86d82ec905633af33b3946c330a6c500142d13c4c33ce1cedb0aa0d9eebe3081652b7ef0203ffda4432820bc8595aaa22df440ea8dd355f4ed08ab0606046ec79ba107169d1994a18d028782ea5c32b9dd71ed2f8edd798fc6121b18b9af94b8d55a21c5f0f414fb9fec9ca4af4f3aedf408f9671ecec0fdba11a4d1ab028a743d2525fd9fd2728ceeb10caa7735b469a8a58f325aadd8898136a86d35701b74f706e06e832796778bf4feddae1825a9603ed497a008cd64379912a008273030233d6d167cd31eac10ea31aa73058a6fdc8a9c2b692fd86ae4918811ef2320ad586dbeb7ca7e307d43fc7325327d77d5e8b5c05f5bcb69362bbb51330855f5ca830a1715a3eb4ff7b14d87680ef2d0b8141c1957afcf4c831cd6c28ba8a5806522a1cd65b3d4843b51253e156ff21fc93cf7f05cb6f18c3b5ad3a37b09dd7ef64f97e1048955a736b92573aa47b20ef3b16b32dba46b1407b6cb46e81721c6a5578e1c3aaf0798e876ac46dcae377a0c86fe7962d99565875dfa2a8863bb6b35d6dc38e36d356c722259f959fbe857a257451fb68cf989425b9df9f454b417b7e4d2c174a6dd01961d29a604a2225ff0aaeb71cea446cc26384cb62b2bab42d32d1ae17bc8313eaeed585b667844b11e6e809cf345a842afc6ff4760cda4d578a082330d45786f4e06e78e544b2531540f197c74ecc4a083d44dee0066c863464ec189be5e510be8d06e30919e282a9614667d6872e7281842d1d32152c9940791cb696d6924e6c2a1e7e0bfa7bafaa780b74609b1c5e973bba53659b9093e773617bfdf08a275a8c1e8979ce5da33fb8e5592f1d39d07d91966b8275d1cee27cba5e3ade5b9fd8d3e485ec140831dedf0256e07d98b10a31b200dc7fbacb13b07f84301ee3010152b1556e2d2c3560395f5d2322b940328eb1ef32b1a113409b6374e5ca321773fd648c2b8075532881a46ddf7bb85d2652cee851b74370873782f2a266475580cf33a429910aa8c854b89a1e43429b619cf8e111575c10d163bd36d3c7ada706a310e130ec66c9551dea75ad91697be9b708adf8c07737f4076392a82606899f3ba6e65b22948de12a70b68fe60a0fda725664d8e85fedd3d1924e6edcf7bc22d1f207ff7738817f35829c10e323b471bc601dc32c5fc6ae9b926bd42a65f08597304e888c729716cbe57d34644067641262c20cccbe299aa1da054439a150c019044128a901464c33c8a7e0da7d62f04fa28cc5ad1f44ca054f837ab82f994430ea4b5256da47a241091fb0fd5f3369ce582a3e68abd58b4dc6efc6ca05f6fd8eb92b1fa723557e4e05234bf7677dd30c66fd9a1eb554f6d83184d6ad7208a10411d5a7972fe9771402a4719f481de0756eab7e88623dd9e0f6e264eb57216856e044152c54d655e10d7be8ccf5d037ba38264bfaed7f997727af5173cbf3e62dfe9fa6ec798496befac6505681c1851a538f75e3d6252e079ddeccb6bda5d3fa338e32414690cc8e4579f9a7cb8cc134f43bcb0401baedd5f8c24dba60d209ad1ec193dfb96230ad1855688f0e987fc4c048858412a06a41a8937d878d51328d5e989937d22ba5755f52e9a99d60713d810e9520b9a73468b80284152a00149cf0d6f19fc6542a782d94b22a4ba10da04833ac88eacce43908dc16ce0b11b1c6e48533036c89a28392559c81dedd7a14ba42def708d26d13393916dd5acd9f7d13169c8455c76ce5d94fd7a89498833d1f75541ee59eb3753af04f03cf2b7f68a47cd8367501e51a2933ed11711f2e5e59340a4d70e2049a4122f1f893476c7b410cc1b569c493040f270deb84b822b81adec2f065c57c34135b5bffa4d86c5dc23de804a8bd4ea3955646bad1f925ddcb989e6c24580696c16388b125d31a513e18219db58b27b565e5b36b3c2701e3ba98d1cc6a7a7f1cdc87276176f3be529824912dfc8db822a01e078f0400322ccde761fe246b716e9814f1fe156c9541c1ee9c02e5bdca83fd1650cdc3ca5498a8a0ef25a029647fb79d359532b7bc4913963773d38b485f2e97a9dc00281658ca1fad3213b577e1c805111cd0f0fb010994c172fddf5a74e57df5d9b9fb954cbbd062c71407faa8456a99eeb58d7b220b948b77ae34dbe9526010abd4c4d1261e826104f5cd5451d4cad1fa3ec06da1ce16d7a7f8d1fa40d45d4d730aa4ed4169973f82a753e0b84e5fb422b44051b5d4f90474124baf9f7448dad8ca4d606de84fd8ca702cf267b41dd49bfadf2dc9494395a936665849e0bd22a453937186c273e1e53d1e5b46202ad28be11cbebba6591cd0f78d4db63b13221edac202fce0fe420f829a10dbcba297e42a56ecbb5d6ab217a2ecd55519ad9dd3e824e77f9c51d6862cee63c10ffef644ba051f722d7f92e272dedcf257e020e9f80c678aa33f91cfd930a2f563584829c3f4a3d8f520cbbcb4a186159c8af021e19e5484dff593d980e6d060a61a9285d90b3c0490689667c0828ee9136965e988163c9cad188f78f7afb6161914a099ccba4c86aa7c71b9ea65ad2704631824640625f5a56f943369a32b3ea9c1fe88f6e76e6c058bdc741bceb9311cb0da7d8d2d1c9be16ddb900f993cf6b693feeafee38996444aa3f69fd2ac8cda0f9530988669011830240745d84b1838b21e19bd6feba64d5544ecb6175f27f28f9932c0b952e18c97b7fbb5823731bf55cb77a03860ae3b892346e990126b5b9584871727735fbaa96f7898740d647ac0b5e3a530ab2f7c7e8a4bd72dfa32002bb9387a3b037f7d3b3832677b22467e7983edcd3ccd832adaf84821a7e4ecdcfe90e3c3b30a9bfb37640d097d7e6f6476079ac8a70df23519a0c72630d835de5232e81f0cce1fe63e25fb1be797ff6cbf107986abb923c5803fec81b6b68a3585ff08ad67f9e43a510d604acac086ac60a0be74465ed9ac98cda1e94d36a5302835e381293547a69cc81c23db74636bd37152012c8501d97c094e0d4d65cc4fce467d5ff4d1a56e0e50ada5c891e8b471001cade9237f5da0536123160755d1da692c37d1cf439d49179aaf75fd10c4296be689908b2ed46315ee3a169bb063a8b781c2172d95d547b8f911bcc85ad8af5e576341d82fcd2e7497305570e03ceab86c2102bf8b9ada9123c421e762f42e0731c9fa668d94d6a490671db67ce75abc08cf05cd3d0f26330731f3c74c1de6c486354748091b249c5a83d2c0f765ce1356e3b5e9b30872e67905e2c6a063df4b4d851bf1ca3649ea96c0a87ef6c8ea4d41d15a727ff7adde1a02995177b087f373f858fbee8d8af86be9ba2fc4c4ee5ffa9f2be03d8e62fd4b55e75f991581e303d0e06dd1a0c949780bb6e2ba608f2d74be50d319a63f72eb55b983f8962d7a47bef2d784330b29187d662a9be83744a1460abdfaa2d973e0a5a62ea5621f9eaf05aefbb7991caf89783332393f938444b65ba9952c48a528a2e833c15f98014be496e64f1ac41c6a89ad092b4a1b908071ae22e49f3e80976c1d8ce8c3c4eed8a29bf1cc163f95a842c64373f82627f18ffb05b3ad0466ff612ffe27575c6893a9961d531d396b5f1c922ac3e63566e65cbe5e22af403b8bf2b52655f59f7ddc30360bebfd2c80fb4256c01a06d52f8d7bda0d49d0e8415ef2d8d8901f005b43df81b31badffa6a0eaf204b092fea1a9820d14fe149040ead91295c075b5bfb5f8f797ecfd48ff5aa2a228345664bce5f6091094007ae581d22964bf43f384ea31f5ebe27a1fd0e192965ddf4a45a7a369bcc72d8ebe36656fc721341277ee6e508adb7f606e7f4f1f625bb68c2b838b5b652c27feda60a3e5025daf102d4a54618676ee6e32c90fca41f4be66949f51fe416af1cc2e147b53f639650bc08e77a2c42fc6f58fc318007bb88ea06258473f1877f56be25bed8c8681dd89fdaa191b7b1f77b8f2f920faeb40fb9f6ced454ff54b8a71815529df679a99e09cff799286c00740348c9407bf0290f2bc4ddb7e68674b7bb01a05075c6cbf0c96ef42c23a79ea411b208538cb35c9cfc7b8e6ca846ad4d9ce8c9513f3c62907ef58de39cb56bc848eeb83996400f308ff1ae574a84e2f2d4b344d1d2f969e8f946b6d50928249687a4d9627d52154ab54857e98cbad99a6dc20d4421bf6c1582b8acf292b749bc803289a1683843d84a232f8082140983f084a8066db50e36e83c6b6757dcd77d3e4f446fa319c9a9c879fd7f116b967402d8eb35612daa8e0acc3821a7a9a66404560968e45ad409acc787dc3498aa364c901b5143def64d5745e20e6ba6dc7734923f01c34859a6f311c520ffba89565efd058b54b8d4fb5f2f2fba278bc751b4e4674cba8584cdfadc2f7507cdd52acbc1c730bc2762b50fe628d6dcb7d4724f0e5a5b503c417710fd817b72fc819750c9974528da3282514f1fcf9f508b5540320bea541f73e38dda0ce7c26dd6c52f2ec550323331ceda5afe0c8b9e11a7c36b6b4693a403325949d2da304a956bd949ed4bacc1cbc90983d286b1ba1bcc1ed590aba33622db7b30c61b66c9ecd7df70a3097d9c674d60472cdd8d32e520f6fc4f830fc80f6c634a6b01b7d712034383b915791b094547ac9fae751fcab51ec901a191b5bdbe922e0ba91c62a7ad03b3f2be6ad31c47d0dcec36b96092fcbb431486fdce8d29bbe8686eece6082ec0c451b96749744430f7242b34c22eabc0e992e20a2be8a13f4a3ec58f6a82767e82cd7946ce1a4e316c25c3aaac7fc6896d0f4f7777bc6d9780480f3d5719a2432e9c9dcbe62df92384a77cde0ad595565e19fefb6eaa5b2ce9a90e0e81a4c19769644d9503b404f05172ebba284e7084794e46439e6b12e951be7268b99fb07ae7c58df9a1d2f4609572fdcf864dca983e23a42372582c1045e296a7d01184d331f9953c35f212ccf34e352a56feab03b2347f1ed7bb0faf64770f789501c7ec54d544439316ae49431487e871d33371ebe64a06dc5a7b1cdfb6ed7be615419badf16c9bf504d47a8cc71d2881a4557f8cb005d278a47991ea10c33700f5f38fba9970e7970dfc2fcbe9cfbf29388785fb7aaca7c1bdd73991322c6a748083d3908e6afbc625335b2b022c34b9fab50b3a1bc1203412e34704c997715b933f5bef71cd06991abc0f8a352e16eb3bab680d4b143f422b6b346557c66bb351a96a4d9ecce582820883b57b95f255e18fae3aa7ce1ae006c2841992eb38c06b38906ee9218c859cbb9522f4317549ea4f7f93fa3bf991b3016fcb80b02729385b9185387a761ac1a92b50dad5a762db6ae2e53b11e4c53e3a467410bc8f3510d27284741e861cea994b28376c998cca089c5bbcfc70110b259ad2633f3ee3e6d810e48e96c3cff78b0367323d7fe7c2e4071558f6819c1f1a7b6b1c371caba1f3ab9e49f93e46409b398a602145a42f71630a1928c2c5fb2a13b2d3fbd4d293a10fb1b1043899a3231ea42cceb0d3c28cc4ef7ad04ccb13f14076fd3cc1405b1586c48006ad19b7b33b98fcdeaab2f3684d98f4eb01803dbeb6eecb63868972dcb6064bee565a1d25eec920ef48b91384e039f0d9b62380751af4c3d5a38505ee6bb26e210bd17691a742b3834484ac84dc3ffeaf3d0bef27c18cb13612214cda31ca27b956540e818094db38a287ffd7be6864bf181141dc43ea6513f80151701f037b0815048d497e14c199391dcde527babbc54a6eea72f73ab0ba49c42784eadb946db149d8676c3b00e5031c7c3f218e63d795b82a508fc23c2ad4e2d0e225c2b86a75cf3c7b6259d399ba301ad33b37bd79d814046fdf8deae3ef7abe30ce92941d4785bbdd2d7c4063d57282a5b22e5a96e607eb180d7179a9adef5f96973f3a47519d1c31c5ccbb6128531c184249ef7f56f0b291e52323e0ff67a1c0b08ef7fdd704d0d6765e9a51f7e22a44f48c1fc224a2c10a6bfc6de0d5084dedf2415bc5cb9b0be9418413af8af2a960c3fc178fa0f8b778bae72531c66574b837f63230f0b48f1d71832c1b18f465ac48f3885fc43fef0b327e92dd352cf64b6094cb5dc7b4b419f03421348e9a349491d2bd81763bd4289623d8bf4dbb7fd4b474c827a1d7144013a7dff0f4449e6b57dd6355fdac8cebef369412b16aeaf14291398d33bcf32827f9371b797c447ef23fa9066a8260de7c846ff277866828bbe692bf4b1158ecab27e99cf27696bcae6194b86aa19209c51aaa486932a982945486cfda204a73df7e0a7a8df41ce043e065f92cc3555672729a2fb7d53fd70f5bb4ddacb848453fb5ab6ff807b37607db9ae55c423af4cbf294aa593965c8aecd122ec7c2d3fddfe8cf164c6c237d367a8f1b404d8295b14ca503e851bd7a6b7574b2b4fa8a56c583fac0603e08d55b340dce06d607bef80a506b0c6617d0d74418c8a87730eec21c2af1abca01ef2afc987b3f60af6a8c24dd02fd6e8b8a899d4bbe8d22c491fddefaf8060466659634ae379e3d4c525919b6021999d9f5f420d5ae6ce842b36e1b71fe2c738267541850cac290a4b241e7fed0a3f8a04f99fd7afb34e24f8a661d92d73072118918f7f351c624d8d194b98acb07a1e9f8f9b3dc771dd997a93a428a83b7d5d0ba7db4d426143bb18ab187a76e8f07d24faf5489e99dba9676e57ee3cf2697f420714ef5df9e776de3aac015f07c4bbb2c0f26f0bada7d30faeb977134679f044ab36449c2a14fa3a4471b22daf50c666e5197c6ea9fa8880f6c2dbc0a135944e979059c5b376e73861674622f7ebcf11455eb910061196c0950949280009f48104a62b35fb93e069205c5a169971f98144d2e3c088410edad9440b5897856a742baadfffd3a87118cdfe5ff9e872e1ea0d94eee196c1cedb63e0d58916794a9fa70365f159cfc4a50bf930f6b8a1b763fb49e83fb70287b1bec530e4a17034cef7a1bf8aeda5455d0a8c6caea561fdfb20ffd06761ca0bd75dc631583032cc504b0221685b91ba9c79964fb87882a43fabd3e5ef49bc664ef91a34fa6fb430468540e0b68e3f874681b505d37d33a2b4406de5cd26833a578c34cf8762737df8540be3b59052e2c2964f20b1e3adf0c4dba6ce84679daeff30a0c509e1af197549575e58e383e0e8b074420c250bf278891407692310a28fbf64e3864fff8dc9ca76368bb097b998e5f0af9a891c25f69a76ed2f0fdc5aec8d9db7081750683cf2012cd6690dee1ec712e0d31d6b94b026a08f5b2f41c51cd8c354c44c1c0e6149be2a0d3db6b2c2b112de70adbf9efe9bceb84640ce28d37d83bfea429798d66b26c6a4f07311c7589f697cda226c53a73d8024018549e062a2ba279e34f9580b59221a2143208247990cecec421a7fa93721743e1dd59428cdc0366c8557f8acf07dcea52d9841a75b627b7264a28f30fd788b0c6775d7c00ade7f08f33c549e390021d5b0ddba18701cf7ca68d8f772f91a4693f7c4ae80d980644260f57c99f615796850cfcebe16eacbf5e073e6337eda9297d63498780c489297afec07d1870b6e8147cdbc5c3fa4717deb071f63bca2d5dadba1f9920b53d8563454c32117793b64521fcce24aba2516a0d765431079edffc951f0e868460628618338b49f169640b0239885465937d48bb77fc456c73f8fa0629992c79f462f515f0ce801d3ea4e3af3411a85693994234299ac1e3fe8c0b2c379f3dcb8afaf79494747d049b76951463f2c5831a3069e6b6724e3784e3432ad258b77e0d127b2328321f055830b602a2c6f16cdc20cf9aa2fff30e35881ccb96a4d073200770c2bf4a5475c7266a1489f64a3cfc0ea76febee6acbd30eca7b60efedb33ed4f871024f8236107ce6e7f5156147e0e0c2804ab4bd61a0e11479c684a3cb332e90da68f68699ad3536504c51f6b64df37bcc86b1af9c33db316a68f0aa50a5c4fe8dee702d6187f6b729176d6dabe231f07bf850e31905dfa3f6f45bbc2ec7e4129a3e196990a37480efd42271dc582ad49ac5132655bb5da1f154e99c6d901c817a68d28f903da56478e24cb691f4496f4670713d60aed8c045c3e7db74327f1691fcc9e72f4dc19b95f9bbd81824ffe00e0549e93b698405f1bb067b9bdf0f2cb1f02e4f1fceea050e561800087c9ff2ad85c6fab30af4be9f83775f0f91508a0fa8a0e95b9464e2604758e28c74266716a23aee94acdc4c9142a511f44333af879905bc2038e6a59a87be89f18fb3cf64d12e022cd863abd87cfe06d3e9b7dd58221da8394a7917a1f4314248c4d41e77eaa3cb077b538f92332457059ad57251042d46c159dea6d48927d80e1b42c1d66e47a9ceb4b24a8c35034987c3864286419795ac41f5117439d2f961d7135702cf70babb2493e23fe578f32ae9501c4da2444d492acb543cbc86ff686f1529a5644445e71e3787b7672e0d3798dd14ed712016840bea44cfa9e593f6861d96cdd91449788c549080888bd162e50256ed802f8b9dcd5a9c4aa077dea6f3834d6f6bf878cf0e31b6d6cb5cdeee953d75b237f09ae1812df6bc1bd0895ff47a4355e9a87a9eaf3156ec349e3e352f8f29fb8a12fad06ff5874c963dc871ba61083a397023d672960b1bc75df3cd2da80044de47b02287b4ca6605c0d13b8b0d52ddd3c55f6e22b909386a8df989803864c191128001126d24b38cb3638cf8753ad556a416511e92a8cb6050499899afd029f915ccaea68c8730574f743f739c82b274863cbd48fb5409ab86d354405abf9dc2b7afffbcad5f219a873daca7801d4c19415994fcfc156876a333fdf4da3c6d45d7cb0b6fac9b34342eae15fc2dd42bdcafb864590bd9380414f4256e6339beb0aa7637e28fc10e627f8548b6a525629ba4bc09aeb38a3bcc3cd46617ed63db4f31e9ed7228778b1c38b074bcbbf3c61ef28a9e3eb5d7cb88e1885135e1e963dea950fa349efc09f50801e7adfdffeaddda799f1c2d61e1a7ee17a4270f6158ab2dda4e6731e3611ec2e84efa1980efdf306cc584f3d3429346af14139df0c8b41fb21682f60b3e3320e68e9f7515bb1bcc297e776fe03db7c1b122e6dca176980a9d728d543f9c96ce73b63ad5c82382fccf4fd6c54c469ec300e1f57d81e067d23c3c4decdb17d3cdafb62902f03c0ca91e750154e430ac06830a062d527d46193f6ee9a89f3d75f786a39371189ad1efbdd47de2f5d310b1a090ff405fddf8acc91d43475e7d6ce4fed93b934e5cee8fd9510ebaa4a172a022d63145da209fb137dabefec85e8a5d13421ede486a238176b5d55d70f4d415a1c6c95307a8ed395c738d1e22c9cb282ff6ded03e6ba585108492d7f43da05d82d7e29f9284a727f7e0718b3233d7353d9f82ae783d5c485f9d2fb41c31ee3a30982728bc969302760102e6d25eb9fa79e285b81a72c1e450bd6b6598d28050e50c076672ba6c9d7a1e6e9a6b95ec7b83a08d75e81f3d57cc1910c66ef3b958c308016c958cebe6f4ca3eff0663e708e9f1ff71d53670ec51cb1a217f1bd907c187d019a95e00cf1d8aee556e604517e4062e1d1e12c91bb67d432a4a32081f527b335b5890b7eb8d08cc61dcd474647be436464f976ed4cf4cee5f0380c6dfb019a675697fcee67decd063170406311c47c3c502ab7aa0abaeb1eb6e8313c671e34668172175b6db76fb67b92ad6f2c2255afe30b5a715ae0a64f321db70bf191a6fbd2dd3ade6a8556d8e55c7a4daae77b7eaeefe807326788b5ddb1a5239a4a39486e9c1a32c8c060b53f41602ed536b803abfaaa8ddd3a86c77beb7b78462504b7e89e100e6254e948e99d56da7efa44e015675723ff271fa8145775a5c08e7f6c441e96b61d4d5c767ba7f90ee20159cd8c7fbf065c71552216201920983c261afc0f779d7dff152e7a6b07c3d1afa4f796d250450e375d52ff2c4655e300b39fd2dc1056f3f681834e80b8be68a1d941730ec858cc1788518a407e8f86eeded9227fb785</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>课程笔记</category>
        <category>通识</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>哈佛</tag>
        <tag>人工智能</tag>
        <tag>计算机安全</tag>
      </tags>
  </entry>
  <entry>
    <title>基于北大前沿计算实践课和missing semester的vim笔记</title>
    <url>/thinklive/11086/</url>
    <content><![CDATA[<h1 id="you-are-your-dotfiles">you are your dotfiles</h1>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch1.gif" /></p>
<h2 id="帮助">帮助</h2>
<p>按f1或命令行输入help开启在线帮助 <code>&lt;Cw&gt;</code>切换到另一个窗口,q关闭窗口 <span id="more"></span></p>
<h2 id="编辑">编辑</h2>
<p>如之前所述，Vim最主要的编辑模式是Insert模式，想要修改文本，先将光标在Normal模式下移动到对应位置，然后再键入<code>i</code>进入Insert模式，在这个模式下添加或者删除文本。但是当我们需要修改的地方非常多时，每次都需要先移动光标再输入<code>i</code>就是一个相对麻烦的操作，因而Vim提供了一些命令将移动光标和进入Insert模式合成一步：</p>
<ul>
<li><code>i</code>在当前位置输入（光标前），<code>I</code>在行首输入</li>
<li><code>a</code>在光标后输入(append)，<code>A</code>在行尾输入</li>
<li><code>o</code>在当前行下新建一行输入，<code>O</code>在当前行上新建一行输入</li>
<li><code>c</code>+光标移动命令会先删除然后进入Insert模式，比如<code>cl</code>会删除下一个字符，<code>cw</code>会删除到单词尾，<code>c10l</code>会删除10个字符。此外，<code>ciw</code>会删除整个单词，<code>cc</code>会删除整行，<code>ci(</code>(change in)会删除小括号里的内容，<code>ca(</code>(change around)则会删除小括号以及小括号里的内容，这在修改代码里的字符串、修改函数变量之类的工作中极其有用</li>
<li><code>s</code>(substitute)会删除当前字符并进入Insert模式，等同于<code>cl</code></li>
<li><code>r</code>(replace)替换当前字母</li>
<li><code>p</code>把上次删除的行放置在当前位置</li>
</ul>
<p>进入Insert模式之后，Vim也有一些奇奇怪怪的命令，比如<code>&lt;C-h&gt;</code>等同于删除键，会删除前一个字符，<code>&lt;C-j&gt;</code>等同于回车键，将光标后的文本移到下一行，但是否要这样做就全凭个人喜好了。<br />
其实在Normal模式下也能进行一些删除操作，<code>x</code>会删除当前字符，<code>d</code>+光标移动命令会删除对应文本，与<code>s</code>以及<code>c</code>命令的区别仅仅在于<code>x</code>和<code>d</code>操作完之后依然处在Normal模式，所以<code>s</code>也等同于<code>xi</code>。此外，<code>r</code>的作用也是替换当前字符，键入<code>r</code>之后会提示输入一个字符，输入完成之后自动回到Normal模式，想要替换长文本就需要键入<code>R</code>进入Replace模式。因此如果想要替换一个字符成x，最快的方法是<code>r</code>+x，也可以<code>s</code>+x+<code>&lt;ESC&gt;</code>，也可以<code>xi</code>+x+<code>&lt;ESC&gt;</code>，也可以<code>cl</code>+x+<code>&lt;ESC&gt;</code>。<br />
撤销和重做也是非常常用的编辑命令，在Vim中分别对应Normal模式下的<code>u</code>(undo)和<code>U</code>，同时<code>.</code>可以重复之前最后一个命令。<br />
“U”（行撤销）。恢复整行的所有操作<br />
<code>&lt;C-r&gt;</code>重做上一个 被撤销的命令</p>
<h2 id="命令行">命令行</h2>
<p>在Normal模式下键入<code>:</code>就会进入命令行模式，此时光标已经移动到了最下面。命令行中可以输入的命令种类非常多：</p>
<ul>
<li><code>w</code>保存文件，但是不退出</li>
<li><code>w !sudo tee %</code>使用sudo保存文件 w filename保存文件到当前目录</li>
<li><code>wq</code>、<code>x</code>、<code>ZZ</code>保存并退出</li>
<li><code>q!</code>、<code>ZQ</code>退出但不保存</li>
<li><code>!</code>+命令 可以在shell环境下执行命令</li>
<li><code>r !</code>+命令 可以在shell环境下执行命令并插入到当前光标下一行</li>
<li><code>e</code>+文件 可以加载新的文件（当前文件没保存的话会报错）</li>
<li><code>e!</code>+文件 加载新文件并丢弃当前更改</li>
<li><code>f</code>显示当前文件的文件名</li>
<li><code>%s/old/new/g</code>搜索所有<code>old</code>并替代成<code>new</code>，支持正则表达式o 命令行界面输入&lt;Cd&gt;显示可以选择的命令，tab自动补全o</li>
</ul>
<h2 id="搜索">搜索</h2>
<p>除了这些直接跳转命令，Vim也提供了搜索机制。<br />
首先是行内的搜索，<code>f</code>、<code>t</code>、<code>F</code>、<code>T</code>后面加上任意字符x，代表跳转到当前光标下一个x、跳转到下一个x之前、跳转到上一个x、跳转到上一个x之后，搜索到了之后也可以继续按<code>,</code>和<code>;</code>在搜索结果之间前后移动。 然后是文件内的搜索:<br />
直接键入<code>/</code>或者<code>?</code>会进入命令行搜索模式，<code>/</code>是从开头开始搜索，<code>?</code>是从结尾开始搜索，后面可以加上任意长度的字符<br />
然后键入<code>&lt;CR&gt;</code>就可以高亮显示所有的搜索结果，按<code>n</code>和<code>N</code>就可以在搜索结果之间向前和向后移动。<br />
输入:set ic(ignore case)忽略大小写搜索 set noic取消<br />
仅搜索一次忽略大小写:/search_sth\s<br />
输入:set hls is高亮搜索结果<br />
//'ic' 'ignorecase' ignore upper/lower case when searching</p>
<p>'is' 'incsearch' show partial matches for a search phrase</p>
<p>'hls' 'hlsearch' highlight all matching phrases<br />
搜索模式支持正则表达式。最后如果想要关闭搜索结果的高亮，需要借助命令行命令，输入<code>:noh</code>即可关闭高亮。<br />
type :#,#s/old/new/g where #,# are the line numbers of the range</p>
<p>of lines where the substitution is to be done.</p>
<p>Type :%s/old/new/g to change every occurrence in the whole file.</p>
<p>Type :%s/old/new/gc to find every occurrence in the whole file,</p>
<p>with a prompt whether to substitute or not.</p>
<h2 id="选择">选择</h2>
<p>编辑文本和代码难免要复制和粘贴，复制操作涉及到选择需要复制的文本，在Vim中这需要在Visual模式下进行。在Normal模式中键入<code>v</code>进入选择模式，可以跟在Normal模式下一样移动光标，被选择的文本就会高亮。<br />
或者在Normal模式中键入<code>V</code>进入行选择模式，被选择的行会高亮。选择完成后，如果直接按<code>&lt;ESC&gt;</code>就会返回Normal模式，并且选择的内容高亮消失，因此不应该这么做，而应该直接在Visual模式下键入<code>y</code>(yank)复制高亮的文本，如果输入的是<code>d</code>则会删除被选择的文本，此时会自动回到Normal模式。<br />
不管是<code>y</code>还是<code>d</code>操作，被选择的文本都会被操作到Vim的缓存中，在Normal模式下按<code>p</code>就会粘贴其中的文本到当前位置。与之前介绍的<code>cc</code>、<code>dd</code>类似，也可以直接在Normal模式下输入<code>yy</code>，对应复制当前行。<br />
Vim还提供了列选择模式，在Normal模式下键入<code>&lt;C-V&gt;</code>进入，选择完列之后可以跟Normal模式一样进行<code>r</code>、<code>d</code>等操作，这在制表、注释中非常有用。</p>
<h2 id="移动">移动</h2>
<p>Vim中所有键盘输入都可以视为命令，可以被记录下来映射到快捷键。在Normal模式下，最基本的命令是控制光标移动的命令<code>hjkl</code>，其中<code>jk</code>控制上下(大写状态下删除行间空格)，<code>hl</code>控制左右，方向键同样可以控制光标，但是因为方向键盘离打字的范围比较远，所以推荐大家熟悉<code>hjkl</code>这四个键。在没有鼠标的情况下想实现长距离的光标跳转，每次只能移动一个单位显然是低效的，好在Vim为光标跳转提供了多种命令：</p>
<ul>
<li><p>单词间：<code>w</code>可以跳转到下一个单词的开头，<code>b</code>跳转到当前单词的开头，继续按跳转到上一个单词的开头，<code>e</code>跳转到当前单词的结尾，继续按跳转到下一个单词的结尾</p>
<blockquote>
<p>遗憾的是中文很难分词，所以在中文中键入<code>w</code>会跳转到下一个短句</p>
</blockquote></li>
<li><p>括号、引号间：如果光标在括号或者引号中间，<code>%</code>会高亮显示括号或引号，继续按会在头和尾反复横跳<br />
</p></li>
<li><p>行内：<code>0</code>跳转到行的开头，<code>^</code>跳转到行的第一个非空格的字符，<code>$</code>跳转到行的结尾<br />
</p></li>
<li><p>段落间：<code>&#123;</code>跳转到上一段，<code>&#125;</code>跳转到下一段</p></li>
<li><p>屏幕内：<code>H</code>跳转到屏幕最上面，<code>M</code>跳转到屏幕最中间，<code>L</code>跳转到屏幕最下面</p></li>
<li><p>屏幕滑动：<code>&lt;C-u&gt;</code>向上滑动，<code>&lt;C-d&gt;</code>向下滑动</p></li>
<li><p>文件内：<code>gg</code>跳转到文件开头，<code>G</code>跳转到文件结尾,</p></li>
<li><p><code>&lt;CG&gt;</code>显示当前行数，数字G跳转到对应行</p></li>
<li><p>其他：<code>zz</code>会将光标置于屏幕中心</p></li>
</ul>
<p>这些基本命令可以和数字进行组合，输入任意数字（默认情况下显示在右下角），然后输入<code>j</code>就会向下移动对应行数，同理，如果是数字+<code>w</code>，就会移动对应单词数。另外，数字+<code>&lt;CR&gt;</code>等同于数字+<code>j</code>，数字+<code>G</code>会跳转到整个文件的第几行。</p>
<h2 id="模式">模式</h2>
<p>Normal模式是最基本的模式，在这个模式下基本只能移动光标，不能直接输入文本，因为此时键入任何字符都会被当成是Vim的命令而非插入到文本中。 想要输入文本需要切换到Insert模式，可以直接键入<code>i</code>进入Insert模式，此时输入任何字符都会插入到光标所在位置。想从输入模式中返回Normal模式，只需要键入<code>&lt;ESC&gt;</code>。事实上，在任何模式下键入<code>&lt;ESC&gt;</code>都 能回到Normal模式。<br />
Normal模式和Insert模式是Vim中最常用的两种模式，理论上我们只需要这两种模式就能完成修改文本的所有操作，其他模式和命令都是用来更快地完成一些任务。默认情况下，所处模式会显示在Vim窗口的左下角，Normal模式没有显示，Insert模式会显示<code>--INSERT--</code>，Command-line模式会显示所输入的命令等等。<br />
在Normal模式下键入<code>R</code>进入Replace模式，用于替换当前光标处的文本，键入<code>v</code>进入Visual模式，用于选择文本。</p>
<figure>
<img src="/images/obsidian/vim-mode.jpg" title="image" alt="" /><figcaption>图片</figcaption>
</figure>
<h2 id="进阶">进阶</h2>
<p>.命令重复上一次命令，可用于简化操作</p>
<ul>
<li>C=c$</li>
<li>s=cl</li>
<li>S=^C//整行替换</li>
<li>I=^i</li>
<li>A=$a</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>麻省理工</tag>
        <tag>北京大学</tag>
        <tag>编程工具</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>基于苏大ppt的计算机硬件笔记</title>
    <url>/thinklive/33908/</url>
    <content><![CDATA[<p>`冯·诺依曼计算机特点<br />
– 计算机由五大部件组成<br />
• 输入数据和程序的“输入设备”<br />
• 记忆程序和数据的“存储器”<br />
• 完成数据加工处理的“运算器”<br />
• 控制程序执行的“控制器”<br />
• 输出处理结果的“输出设备”</p>
<span id="more"></span>
<p>– 指令和数据以同等地位存于存储器，可按地址寻访<br />
– 指令和数据用二进制表示<br />
– 指令由操作码和地址码组成<br />
– 以运算器为中心 基础逻辑电路：与门，非门，或门，异或门，与非门，或非门，同或门 半加器<br />
– 𝑆𝑖当前位， 𝐶𝑖进位符 全加器 （包括之前的进位cn-1） – 𝐹𝑛当前位， 𝐶𝑛进位符 𝐶𝑛 = 𝑋𝑛 ⋅ 𝑌𝑛 + 𝑋𝑛⨁𝑌𝑛 ⋅ 𝐶𝑛−1 <img src="/images/obsidian/20230531113546.png" title="image" alt="图片" /> <img src="/images/obsidian/20230531113559.png" title="image" alt="图片" /> <img src="/images/obsidian/20230531113735.png" title="image" alt="图片" /> CPU与外设之间的数据交换必须通过接口来完成，通常接口有<br />
以下一些功能：<br />
– 设置数据的寄存、缓冲逻辑，以适应CPU与外设之间的速度差异；<br />
– 进行信息格式的转换，例如串行和并行的转换；<br />
– 协调CPU和外设两者在信息的类型和电平的差异，如电平转换驱动器、<br />
数/模或模/数转换器等；<br />
– 协调时序差异；<br />
– 地址译码和设备选择功能；<br />
– 设置中断和DMA（直接存储器存取）控制逻辑，以保证在中断和DMA<br />
允许的情况下产生中断和DMA请求信号，并在接受到中断和DMA应答<br />
之后完成中断处理和DMA传输。 `为何要用二进制表示（冯.诺依曼核心）<br />
– 无法制造多个稳定状态的物理器件<br />
– 编码、计数、运算规则简单<br />
– 和逻辑的真、假对应，通过逻辑门电路可实现算数运算 BCD码<br />
– 机器中用4位二进制对每个十进制数位进行编码方法<br />
– 4位二进制有16种组合，选取其中的十个。<br />
– 常用的方法有：8421码、余3码、格雷码</p>
<p>为什么要用BCD码<br />
– 高精确度的计算<br />
– 耗费更多的存储空间 <code>数的定点与浮点表示   – 十进制的公式表示：𝑁 = 10𝐸 ∗ 𝑆   – 二进制数的公式表示：𝑁 = 2𝐸 ∗ 𝑆   • 定点数：阶码𝐸位置固定，存储时统一忽略阶码   – 定点整数: 𝐸 = 0， 𝑆为纯整数，小数点固定在数值部分的右边   – 定点小数: 𝐸 = 0， 𝑆为纯小数，小数点固定在数值部分的左边</code>浮点数详解<br />
– 浮点数的表示范围<br />
• 阶码E的范围：−128 ≤ 𝑒 &lt; 127<br />
• 最大正数：0.111 ... 1 × 2011...1 = (1 − 2^−23) × 2^127<br />
• 最小正数：0.100 ... 0 × 2100...0 = 1<br />
2 × 2−128 = 2−129<br />
– 浮点数的表示精度<br />
• 总位数不变<br />
– 阶码越大：数值表示范围越大<br />
– 尾数越少：精度变低 <img src="/images/obsidian/20230531114156.png" title="image" alt="图片" /> 机器数的表示形式：原码、反码、补码<br />
– 原码：符号+真值<br />
• +41 原 = 0 0101001， −41 原 = 1 0101001<br />
• +0 原 = 0 0000000， −0 原 = 1 0000000<br />
– 反码：正数不变，负数时符号不变，其他各位取反<br />
• +41 反 = 0 0101001， −41 反 = 1 1010110<br />
• +0 反 = 0 0000000， −0 反 = 1 1111111<br />
– 补码：正数不变，负数为反码+1（计算机表示带符号数的方法）<br />
• +41 补 = 0 0101001， −41 补 = 1 1010111<br />
• +0 补 = 0 0000000， −0 补 = 0 0000000<br />
• +127 补 = 0 1111111， −127 补 = 1 0000001<br />
• −128 补 = 1 0000000 `溢出<br />
– 运算结果超出机器数所能表示的范围时，称为溢出<br />
– 定点数溢出的判断方法<br />
• 两个同符号的数相加，得到的和的符号与相加数的符号不一致。<br />
– 采用双符号位：正数的符号位为00，负数的符号位为11。符号位参加运算。如果<br />
两个符号位不相同，则溢出。（浪费资源）<br />
• 任意两数相加，如果数值最高位的进位不等于符号位的进位，则溢出。<br />
– 浮点数溢出的判断方法<br />
• 看阶码是否溢出！</p>
<p>BCD码：用四位二进制数表达一个十进制数，方便运算和显示 浮点数：尾数S和阶码E 符号+阶码+符号+尾数 反码：正数不变，负数除了符号位取反 补码：正数不变，负数除了符号位加一 +0：00000000 -128:10000000 [x+y]补=[x]补+[y]补 [x-y]补=[x]补+[-y]补</p>
<p>有效地址EA=基址（BX/BP）+变址值(SI/DI)+位移量DISP +段基址=物理地址</p>
<h2 id="cisc和risc是cpu的两种基本架构">CISC和RISC是CPU的两种基本架构</h2>
<p>– CISC：寻址方式多，方便编程<br />
– RISC：寻址方式少，指令短、规整</p>
<h3 id="risc特点">RISC特点</h3>
<p>– 指令系统<br />
• RISC指令长度相同；寻址方式少；指令执行时间相当<br />
– RISC CPU内部寄存器多<br />
– 存储器操作<br />
• 只有取数/存数指令访问存储器，大部分指令都在寄存器之间进行<br />
– 代码量增多，实现特殊功能时程序复杂<br />
– 较少的单元电路，面积小，功耗低<br />
– 结构简单，设计周期短</p>
<h3 id="程序执行过程">程序执行过程</h3>
<p>– PC发起地址查询<br />
– 内存依据地址返回指令/数据<br />
– CPU进行指令解析<br />
– PC增量或PC赋值<br />
• 指令结构<br />
– 操作码+地址码（操作数所在地）</p>
<h3 id="寻址方式">寻址方式</h3>
<ul>
<li>立即数寻址（办理人随身携带）<br />
– 操作数由指令的地址码部分直接给出来<br />
• 操作码+操作数<br />
</li>
<li>寄存器直接寻址（办理人已寄存）<br />
– 指令地址码部分给出某一通用寄存器地址<br />
– 从寄存器存取数据比主存快得多<br />
– 由于寄存器的数量较少，其地址码字段短</li>
<li>直接寻址（办理人在队伍里）<br />
– 指令中地址码字段给出操作数的地址<br />
• PC赋值——取操作数</li>
<li>间接寻址（办理人在哪问家长）<br />
– 指令中给出的地址是存放操作数地址的地址<br />
– 寄存器间接寻址（家长已寄存）<br />
– 存储器间接寻址（家长在队伍里）</li>
<li>偏移寻址（相对寻址）<br />
– 从我往后数A个<br />
– EA：有效地址 – 相对寻址： EA=A+(PC) 相对于当前指令处位移量为A的单元<br />
– 基址寻址： EA=A+(B) 相对于基址(B)处位移量为A的单元<br />
– 变址寻址： EA=A+(I) 相对于首址A处位移量为(I)的单元</li>
</ul>
<h2 id="微处理器">8086/8088微处理器</h2>
<h3 id="指令队列缓冲器">指令队列缓冲器</h3>
<p>– 取指令时，每当指令队列缓冲区满一条指令，EU立即开始执行<br />
– 当指令队列中有2个空字节（8088一个）BIU自动去取指<br />
– EU从指令队列中去取指，然后执行指令，当该指令需要内存或<br />
I/O访问，EU请求BIU进入总线周期完成访问：<br />
• BIU空闲状态：立即响应<br />
• 正在取指：取指完后响应<br />
– 指令队列已满，EU没有对BIU有请求，BIU进入空闲状态<br />
– 执行转移、调用、返回指令：指令队列中的内容（原顺序指令）<br />
被清除，BIU去取EU所指示的新的程序段指令</p>
<h3 id="寻址空间计算">寻址空间计算</h3>
<p>– 8位机寻址：8根地址线<br />
• 地址范围：0~255<br />
• 最大内存空间：28 = 256Byte<br />
– 16位机：216 = 64KB<br />
– 32位机：232 = 4GB<br />
– 64位机：264 = 16EB</p>
<h3 id="编程结构">编程结构</h3>
<p><img src="/images/obsidian/20230603134629.png" title="image" alt="图片" /> – 4个通用寄存器(16位)<br />
• AX、BX、CX、DX（可8位单独使用）<br />
– 4个专用寄存器(16位)<br />
• BP（Base Pointer）基数指针<br />
• SP（Stack Pointer）堆栈指针<br />
• SI（Source Index）源变址<br />
• DI（Destination Index）目的变址<br />
– 4个段寄存器（16位）<br />
• CS（Code Segment）代码段寄存器<br />
• DS（Data Segment）数据段寄存器<br />
• SS（Stack Segment）堆栈段寄存器<br />
• ES（Extra Segment）扩展段寄存器 – CS用来存放程序当前使用的代码段的段地址，CPU执行的指令<br />
将从代码段取得<br />
• CS:IP构成传统意义的PC<br />
– SS用来存放堆栈段的段地址，堆栈操作的数据就在堆栈段中<br />
• 通常SS:SP和SS:BP构成堆栈段的访问<br />
– DS用来存放数据段的段地址，一般地说，程序所用的数据就存<br />
放在数据段中<br />
• 通常DS:XX（通用寄存器）构成对数据段的访问；<br />
– ES用来存放附加段的段地址，也用来存放数据，但典型用法是<br />
存放处理后的数据</p>
<h2 id="主存储器">主存储器</h2>
<h3 id="主存储器处于中心地位的原因">主存储器处于中心地位的原因</h3>
<p>• 当前计算机正在执行的程序和数据均存放在存储器中，<br />
CPU直接从存储器取指令或数据；<br />
• 输入输出设备增多，数据传输速度加快，因此采用了<br />
DMA(直接存储器存取)技术和输入/输出通道技术，<br />
在存储器与输入/输出系统之间直接传送数据；<br />
• 共享存储器的多处理机的出现，利用存储器存放共享<br />
数据，并实现处理机之间的通信。</p>
<h3 id="存储器的分类和指标">存储器的分类和指标</h3>
<p>随机存储器（random access memory，RAM）<br />
• 又称读写存储器，指通过指令可以随机地、个别地对<br />
各个存储单元进行访问（读写）的存储器<br />
• 访问所需时间基本固定，与存储单元地址无关<br />
• 停电会造成信号丢失<br />
非易失性存储器<br />
• 停电仍能保持其内容 <code>容量 • 计算机可寻址的最小单位是一个存储字，一个存储字   所包括的二进制位数称为字长   • 一个字节（Byte）为8个二进制位（bit），一个字可   以由若干字节组成，一个字的字长通常是8的倍数。   • 主存储器的容量：以字或字节为单位来表示主存储器   存储单元的总数   • 单位：B、KB、MB、GB、 TB、PB、EB、ZB...   • 指令中地址码的位数决定了主存储器的可直接寻址的   最大空间   • 32位微型机提供32位物理地址，支持对4G字节的物理主存   空间的访问</code>存储器存取时间(Memory Access Time)<br />
• 又称存储器访问时间<br />
• 启动一次存储器操作到完成该操作所经历的时间。<br />
`存储周期(Memory Cycle Time)<br />
• 连续启动两次独立的存储器操作(例如连续两次读操<br />
作)所需间隔的最小时间 • 主存储器和CPU是由总线连接的。CPU通过使<br />
用AR（地址寄存器）和DR（数据寄存器）个<br />
主存储器进行数据传送。若AR为K位字长，<br />
DR为n位字长，则允许主存包含2^k个可寻址<br />
字节或字。<br />
• 在一个周期内，CPU和主存储器之间进行n位<br />
数据传送。 读操作：存储器→CPU<br />
• CPU把信息字的地址送到<br />
AR,经地址总线送往主存<br />
储器<br />
• CPU通过控制总线发读<br />
(Read)命令<br />
• CPU等待主存储器的<br />
Ready回答信号，Ready<br />
为 1，表示信息已读出经<br />
数据总线,送入DR。<br />
AR：地址寄存器<br />
DR：数码寄存器<br />
主存储器的基本操作</p>
<p>• 写操作：CPU→存储器<br />
• CPU把信息字的地址送<br />
到AR，经地址总线送往<br />
主存储器,并将信息字送<br />
往DR<br />
• CPU通过控制总线发写<br />
(Write)命令<br />
• CPU等待主存储器的<br />
Ready回答信号，Ready<br />
为 1，表示信息已从DR<br />
经数据总线写入主存储<br />
器</p>
<h3 id="读写存储器">读写存储器</h3>
<p>按存储元件在运行中能否长时间保存信息分为静<br />
态存储器SRAM和动态存储器DRAM两种<br />
• 静态存储器：利用双稳态触发器来保存信息，只<br />
要不断电，信息就不会丢失<br />
• 动态存储器：利用MOS电容存储电荷来保存信<br />
息，使用时需不断给电容充电才能使信息保持<br />
• 静态存储器的集成度低，功耗较大；动态存储器<br />
的集成度高，功耗小，主要用于大容量存储器 • DRAM每片容量大，引脚少; 价格低; 功耗低; 但<br />
速度低，须再生。 DRAM一般用作计算机的主<br />
存储器。<br />
• SRAM速度快，价格较高，一般用作容量不大的<br />
高速存储器。 DRAM和SRAM是可任意读写的随机存储器，当发生掉电时，存储的<br />
内容容易立即消失，属于易失性存储器。<br />
非易失性存储器，即使掉电，内容也不会消失：<br />
只读存储器(ROM)<br />
• 掩膜式ROM，由芯片制造商在制造时写入内容，以后只能读不能写<br />
可编程序的只读存储器(PROM)<br />
• 用户根据自己需要确定ROM的内容；<br />
• 有熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元<br />
的熔丝(写入)。<br />
可擦除可编程序的只读存储器(EPROM)<br />
• 产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线<br />
照射后,浮置栅上的电子将逸散,即整体擦除。<br />
可用电擦除的可编程序的只读存储器(E2PROM)<br />
• 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写<br />
入周期要几毫秒,寿命为10万次。<br />
闪速存储器(Flash Memory)<br />
• 用电擦除,但只能整体擦除或分区擦除。</p>
<h2 id="存储器组织">8086/8088存储器组织</h2>
<p>存储器分段<br />
– 为什么分段<br />
• 地址寄存器均为16位： 216 = 64KB<br />
– 分段方便操作系统进行存储管理<br />
– 如何分段<br />
• 8086地址空间为20位=1MB，地址为5位16进制数：00000H~FFFFFH<br />
– 从偏移地址考虑，理论上最多16个不重叠的地址段<br />
– 从段地址考虑，最多可以定义216个不同段<br />
– 段重叠<br />
• 段区分配通常由操作系统完成<br />
– CS、DS、SS、ES存储与程序相关的段基址<br />
– IP、SP、BP、SI、DI存储与程序相关的偏移地址 逻辑地址和物理地址<br />
– 逻辑地址<br />
• 程序和指令表示的一种地址<br />
• 包括两部分：段地址和偏移地址<br />
– 物理地址<br />
• 段地址*\16+偏移地址=物理地址<br />
– 寻址操作根据操作系统默认规则完成 堆栈（段）<br />
– 机制<br />
• 栈顶为唯一出入口<br />
– 地址较小的一端<br />
• 后进先出原则<br />
– 作用<br />
• 数据暂存<br />
• 保留轨迹 段加偏移”寻址机制允许重定位<br />
– 重定位是指一个完整的程序块或数据块可以在存储器所允许的空<br />
间内任意浮动，并定位到一个新的可寻址的区域<br />
– 允许程序和数据不需要做任何修改</p>
<h2 id="小结">小结</h2>
<p>• 微处理器的设计有CISC与RISC两种基本架构。深入理解16位微处理器8086的内部结构<br />
及其工作原理，是掌握微机工作原理的基础和关键。Intel系列高档微处理器内部的复杂<br />
结构及其工作原理，都是在8086CPU的结构基础上逐步分解结构和细化流水线操作而发<br />
展起来的。透彻地掌握8086CPU的基础，将有利于理解高档微处理器的技术发展。<br />
• 8086/8088 CPU的内部结构由总线接口单元BIU和执行单元EU两部分组成。其内部有3<br />
组共14个寄存器，必须了解它们各自的功能，并能掌握它们的使用方法。<br />
• 总线周期是理解CPU按时序工作的重要概念。8086/8088 CPU一个最基本的总线周期由<br />
4个时钟周期组成，简称为4个状态，即T1、T2、T3与T4这4个状态。<br />
• 微处理器的引脚及其功能是其重要的外部特性。由于8086／8088 CPU只有40条引脚，<br />
学习和掌握它们的功能相对于高档微处理器说来就比较简单。</p>
<p>CF - 进位标志(Carry Flag),表示上一条指令的运算是否产生进位。如果产生进位,CF为1,否则为0。OF - 溢出标志(Overflow Flag),表示上一条指令的结果是否越界。如果结果超出目的操作数可以表示的范围,OF为1,否则为0。 SF - 符号标志(Sign Flag),表示上一条指令运算结果的符号。如果结果为负数,SF为1,如果为正数,SF为0。 ZF - 零标志(Zero Flag),表示上一条指令的运算结果是否为0。如果结果为0,ZF为1,否则为0。</p>
<h2 id="指令格式">指令格式</h2>
<p>计算机是通过指令来处理各种数据，为指出数据的来源、<br />
操作结果的去向及执行何操作，一条指令必须包含以下信<br />
息：<br />
– (1) 操作码——位数及位置。<br />
– (2) 操作数的地址——操作数的个数<br />
– (3) 操作结果的存储地址。<br />
– (4) 下一条指令的地址 <code>指令长度   – 可以等于机器字长，也可以大于或小于机器字长。   • 尽可能短   • 等于字节的整数倍。   – 若所有指令的长度都是相等的，称为定长指令字结构   • RISC指令大多采用定长指令结构   – 若各种指令的长度随指令功能而异，</code>操作码<br />
– 操作码的位数取决于计算机指令系统的规模<br />
– 定长编码和变长编码 变长编码：分散地放在指令字的不同字段中，如INTEL 8086/Pentium<br />
– 优点：能表示更多的指令<br />
– 缺点：增加了译码难度，控制器复杂 <code>指令涉及的数据类型   – 地址：无符号数，一般是加减操作（含移位）   • 8、16或32位   – 数值数据   • 定点数（整数）：补码表示   – 16位、32位、64位   • 浮点数（实数）：IEEE754标准   – 位、位串、字符与字符串   • 用来表示文本、声音和图像等   • 字节、字(16位)、双字(32位)、四字(64位)   – 现代32位计算机通常以32位为一个字：字节、半字(16位)、字(32位)、双字(64位)   – 逻辑数据   • 按位操作（0-假/非0-真）</code>数据寻址方式<br />
– 有效地址EA（Effective Address）=基址值（BX或BP）+变址<br />
值（SI或DI）+位移量DISP<br />
• +段基址=物理地址<br />
– 根据命令判断字段长短<br />
• 通常由寄存器长度决定</p>
<h3 id="寻址方式-1">寻址方式</h3>
<ul>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>直接数据寻址</li>
<li>寄存器间接寻址（间接寻址目标为存储器，故不能确定目标位置长度）</li>
<li>基址加变址寻址</li>
<li>寄存器相对寻址</li>
<li>相对基址加变址寻址(带DISP的基址加变址寻址) 程序存储器寻址方式<br />
– 实现程序转移<br />
• 条件转移<br />
– 段内短转移（-128~+127）<br />
• JMP<br />
– 段内/段间，直接/间接寻址<br />
• CALL<br />
– 段内/段间，直接/间接寻址<br />
• 中断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他寻址方式  </span><br><span class="line">– 串操作指令寻址方式  </span><br><span class="line">• 操作类别：清0、复制、比较等  </span><br><span class="line">• 源数据地址：DS:SI  </span><br><span class="line">• 目标数据地址：ES:DI  </span><br><span class="line">– I/O端口寻址方式  </span><br><span class="line">• 直接端口寻址  </span><br><span class="line">– IN AL, n OUT n, AL  </span><br><span class="line">– 端口号：0～255  </span><br><span class="line">• 间接端口寻址  </span><br><span class="line">– IN AL, DX OUT DX, AL  </span><br><span class="line">– 端口号：0～65535</span><br></pre></td></tr></table></figure>
<h2 id="通用数据传送">通用数据传送</h2>
<p>//CS - Code Segment,代码段寄存器。它保存代码段的起始地址,用于查找程序的指令。IP - Instruction Pointer,指令指针寄存器。它保存下条指令的地址,用于告诉CPU去哪里找到下一条要执行的指令。 1、基本传送指令 MOV（Move）：传送<br />
– 一般形式：MOV dest, src<br />
• dest  src，将源操作数src复制到目的操作数dest，src不变 2、堆栈操作<br />
– PUSH src<br />
– POP dest<br />
– LIFO后进先出<br />
– 堆栈操作按字进行<br />
– 不能POP CS 3、XCHG（Exchange）：交换<br />
– 一般形式：<br />
• XCHG oprd1, oprd2 ;交换oprd1与oprd2的内容<br />
– 语法格式：<br />
• XCHG reg/mem, reg/mem 4.字节翻译指令XLAT（代码转换或查表指令）<br />
– BX 基址：代码转换表首地址（表大小：0~255）<br />
– AL 偏移（码值） MOV BX,0030H<br />
MOV AL,5<br />
XLAT</p>
<h2 id="目标地址传送类指令">目标地址传送类指令</h2>
<p><code>LEA（Load Effective Address）装入有效地址   – 语法格式：LEA reg16, mem ;reg16 = mem的有效地址   – 通常用于建立串操作   – 对标志位的影响：无。   – 【例】设BX = 5678H   • LEA SI, 2\[BX]   ;执行后，SI = 567AH 将计算结果放入BX寄存器,而不会访问那个地址的值</code>LDS reg16, mem<br />
– 定位串操作源地址<br />
– LDS SI, [DI+100AH]<br />
– 低16位存入reg16，高16位存入DS<br />
<code>LES reg16, mem   – 定位串操作目标地址   – 同上，高16位存入ES</code>LAHF、SAHF（保存和设置标志位）<br />
– 与AH寄存器交互<br />
– SF：符号标志：运算结果符号位<br />
– ZF：零标志：运算结果是否为0<br />
– AF：辅助进位标志：低四位是否向高四位进位<br />
– PF：奇偶标志：是否有偶数个1<br />
– CF：进位标志：是否进位/借位</p>
<h2 id="算术运算类指令">算术运算类指令</h2>
<p>加法<br />
– 一般形式：<br />
• ADD dest, src ; dest  dest + src<br />
• ADC dest, src ; dest  dest + src + CF<br />
• INC oprd ;oprd  oprd + 1<br />
– 语法格式：<br />
• ADD reg/mem, reg/mem/imm<br />
• ADC reg/mem, reg/mem/imm<br />
• INC reg/mem<br />
– 对标志位的影响：<br />
• ADD、ADC：按一般规则影响CF、OF、SF和ZF<br />
• INC：不影响CF，其它同ADD<br />
• ADD与ADC的2个操作数必须类型匹配，且不能同时是内存操作数 减法<br />
– 一般形式：<br />
• SUB dest, src ; dest  dest - src<br />
• SBB dest, src ; dest  dest - src - CF<br />
• CMP oprd1, oprd2 ; oprd1 - oprd2<br />
– 与SUB的区别在于，不将减法结果存入dest，只影响标志位<br />
• DEC oprd ; oprd  oprd - 1<br />
• NEG oprd ; oprd  0 – oprd = oprd + 1<br />
– 语法格式：<br />
• SUB reg/mem, reg/mem/imm<br />
• SBB reg/mem, reg/mem/imm<br />
• CMP reg/mem, reg/mem/imm<br />
• DEC reg/mem<br />
• NEG reg/mem SUB、SBB、CMP：影响CF、OF、SF、ZF、AF和PF<br />
• DEC：不影响CF，其它同SUB<br />
• SUB与SBB的2个操作数必须类型匹配，且不能同时是内存操作数 乘法<br />
<code>– MUL（Unsigned Multiplication）：无符号乘法   – 一般形式：   • MUL src   – 语法格式：   • MUL reg8/mem8 ; AX = AL × src   • MUL reg16/mem16 ; DX:AX = AX × src   • 对标志位的影响：若8位×8位、16位×16位的结果分别能由8、16位容   纳（即结果的高一半为0），则CF = OF = 0，否则，CF = OF = 1；其   余标志无定义。   • 由于2个n位数的乘积可能需要2n位，因此，若操作数是8位，则结果为   16位；同样，16位操作数相乘结果为32位（80386中32位数相乘结果   为64位）。</code>IMUL（Integer Multiplication）：带符号乘法<br />
– 一般形式：<br />
• IMUL src<br />
– 语法格式：<br />
• IMUL reg8/mem8 ; AX = AL × src<br />
• IMUL reg16/mem16 ; DX:AX = AX × src<br />
• 对标志位的影响：若结果的高一半为低一半的符号扩展，则CF = OF =<br />
0，否则，CF = OF = 1；其余标志无定义<br />
– 【例】对于同一个二进制数，采用 MUL与IMUL执行的结果可能<br />
不同。设AL = 0FFH，BL = 1，分别执行下列指令，会得出不同<br />
结果。<br />
• MUL BL ; AX = 00ffh（255D）<br />
• IMUL BL ; AX = 0ffffh（-1D） 除法<br />
– 一般形式：<br />
• DIV src ; 无符号数除法<br />
• IDIV src ; 带符号数除法<br />
– 语法格式：<br />
• DIV reg/mem<br />
• IDIV reg/mem<br />
– 功能描述：<br />
• src是8位：AX÷src，结果商在AL、余数在AH<br />
• src是16位：DX:AX÷src，结果商在AX、余数在DX<br />
– 对标志位的影响：无定义<br />
– 若是8位÷8位或16位÷16位怎么解决？</p>
<p>符号扩展<br />
– 对标志位的影响：无<br />
– CBW、CWD（Convert Byte/Word to Word/Double word）<br />
– 语法格式：<br />
• CBW ; AL符号扩展为AX<br />
– (若AL为正数,则零扩展,若AL为负数,则扩展部分全1)<br />
• CWD ; AX符号扩展为32位数DX:AX<br />
– 【例】设AL = 0FEH，给出依次执行下列指令后的结果。<br />
• CBW ; ax = fffeh<br />
• CWD ; dx = ffffh, ax不变，即dx:ax = -2<br />
• 十进制调整指令（不要求）<br />
– BCD码的加减乘除</p>
<h2 id="逻辑运算类指令">逻辑运算类指令</h2>
<p>AND reg/mem, reg/mem/imm<br />
– OR reg/mem, reg/mem/imm<br />
– XOR reg/mem, reg/mem/imm<br />
– NOT reg/mem<br />
– TEST reg/mem, reg/mem/imm；执行AND操作但不存储<br />
结果<br />
• 对标志位的影响：<br />
– NOT：无。<br />
– 其它指令：CF = OF = 0，按一般规则影响SF和ZF `使某位变反，其余位保持不变：对应位异或1，其余位为0<br />
• 例： XOR AL, 60H ; 使第5、6两位为原来码的反码<br />
• 特例： XOR AL, 0FFH = NOT AL</p>
<h2 id="移位指令和循环移位指令">移位指令和循环移位指令</h2>
<p>一般形式：<br />
– SHL dest, count ; dest逻辑左移，count为移位次数<br />
– SAL dest, count ; dest算术左移<br />
– SHR dest, count ; dest逻辑右移<br />
– SAR dest, count ; dest算术右移<br />
– ROL, ROR循环左/右移；RCL, RCR带进位标志循环左/右移 对标志位的影响：<br />
– 移位次数为1时，若移位后符号位发生了变化，则OF = 1，否则<br />
OF = 0；若移位次数 &gt; 1，则OF无定义<br />
– 按一般规则影响ZF与SF。然而，若移位次数为0，则不影响标志<br />
位；CF为最后移入位<br />
• 参数规范：当count = 1时，可以立即数输入，否则需先<br />
存入CL中；count取值范围0~255<br />
• 【例】设AX的值为一个2字节非压缩BCD码，将其转换为<br />
1字节压缩BCD码存入AL。<br />
MOV CL, 4<br />
SHL AH, CL ; ah低4位移到高4位<br />
AND AL , 0FH ; al高4位清0<br />
OR AL , AH</p>
<h2 id="串操作指令">串操作指令</h2>
<p>目标和源都是存储器 (字、字节)<br />
– DS:SI 提供源，ES:DI提供目的，CX提供长度<br />
• 种类<br />
– MOVS（Move）传送<br />
– CMPS（Compare）比较<br />
– SCAS（Scan）搜索<br />
– LODS（Load）读<br />
– STOS（Store）写<br />
• 方向（DF标志位）<br />
• 重复前缀<br />
– REP（Repeat）<br />
– REPE/REPZ<br />
– REPNE/REPNZ</p>
<h2 id="程序控制类指令">程序控制类指令</h2>
<p>无条件转移JMP（Jump）<br />
• 一般形式：<br />
– JMP target ; 转移到target指定的目标地址处<br />
– 根据转移的距离，JMP指令可分为下列两类：<br />
• 段内转移：在同一代码段内进行，又称近（Near）转移，只要修改IP的<br />
值即可实现<br />
• 段间转移：可在不同代码段之间进行，又称远（Far）转移，需要同时<br />
修改CS和IP的值<br />
– 根据目标地址的指定方式，JMP指令又可分为直接转移和间接转<br />
移<br />
• 直接转移：是指转移的目标地址直接出现在指令中，在程序执行前就已<br />
确定<br />
• 间接转移：指转移的目标地址是寄存器或内存操作数的值，只有执行到<br />
该条指令时才能确定 – 直接转移<br />
• JMP [NEAR PTR] label ; 段内转移<br />
– 目标地址 = IP + label（2字节） ; ±32KB<br />
例：JMP ADDR1 ; ADDR1代表一个段内目标地址<br />
ADDR1与当前IP位移量1235H, CS=1500H, IP=2400H<br />
目的地址：18638H JMP SHORT label<br />
– 目标地址 = IP + label（1字节） ; -128~127<br />
• JMP FAR PTR label ; 段间转移<br />
– 间接转移<br />
• JMP reg16/WORD PTR mem<br />
; IP = reg16/mem16 段内间接转移<br />
例：JMP FAR PTR ADDR2 ; ADDR2代表一个段间目标地址<br />
ADDR2所在CS=6500H，IP=020CH<br />
目的地址：6520CH<br />
例：JMP BX ；BX→IP，CS不变<br />
JMP WORD PTR [DI] ；[DS:DI] →IP，CS不变 JMP DWORD PTR mem<br />
– ; CS = [mem+2]，IP = [mem]<br />
例：当前CS=1000H, IP=026AH<br />
DS=2000H, BX=1400H, ADDR3=020AH<br />
JMP DWORD PTR [BX+ADDR3]<br />
CS=4000H, IP=320EH • CALL过程名<br />
– CALL NEAR PROC 段内直接寻址（修改IP, CS不变）<br />
– CALL BX 段内间接转移（BX → IP）<br />
– CALL FAR PROC 段间直接调用<br />
• IP、CS都改变，例如：CALL 2000H:5600H<br />
• 返回地址入栈包括CS和IP<br />
– CALL DWORD PTR [reg16] 段间间接调用<br />
• 低字 → IP，高字 → CS<br />
– CALL与JMP区别<br />
• CALL调用时会将修改前IP（或IP与CS）入栈，且完成后会返回当前位置<br />
• RET<br />
– 要和CALL调用类型对应：RET（段内）与RETF（段间）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例】求AX累加器和BX累加器中两个无符号数之差的绝  </span><br><span class="line">对值，结果放在2800H单元中  </span><br><span class="line">CMP AX, BX  </span><br><span class="line">JB AA  </span><br><span class="line">SUB AX, BX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], AX  </span><br><span class="line">JMP STOP ;该句缺少怎样？  </span><br><span class="line">AA: SUB BX, AX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], BX  </span><br><span class="line">STOP： HLT</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例】从外设71H中取一个数M,判断其值是否在10和20之  </span><br><span class="line">间，如果M≥20，则送0FFH给外设73H;如果M&lt;10,则送  </span><br><span class="line">00H给外设73H;如果10≤M&lt;20,则送88H给外设73H  </span><br><span class="line">IN AL, 71H  </span><br><span class="line">CMP AL, 10  </span><br><span class="line">JNC LP1  </span><br><span class="line">MOV AL, 00H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP1: CMP AL, 20  </span><br><span class="line">JNC LP2  </span><br><span class="line">MOV AL, 88H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP2: MOV AL, 0FFH  </span><br><span class="line">LP3: OUT 73H, AL  </span><br><span class="line">HLT</span><br></pre></td></tr></table></figure>
<p>循环控制（短地址区间）<br />
– LOOP 目标地址<br />
• CX-1,如CX≠0,转移到目标地址（负值）<br />
– LOOPE/LOOPZ 目标地址<br />
• CX-1,如ZF=1且CX≠0循环（LOOPNE/LOOPNZ时ZF=0）</p>
<figure class="highlight plaintext"><figcaption><span>【例】求2个数组之和，每个数组长度为N。如遇到2个组</span></figcaption><table><tr><td class="code"><pre><span class="line">数元素都为0，则停止求和  </span><br><span class="line">MOV SI, -1  </span><br><span class="line">MOV CX, N  </span><br><span class="line">NEXT: INC SI  </span><br><span class="line">MOV AL, [ADDR1 + SI]  </span><br><span class="line">ADD AL, [SI + ADDR2]  </span><br><span class="line">MOV [SI + ADDR3], AL  </span><br><span class="line">LOOPNZ NEXT</span><br></pre></td></tr></table></figure>
<p>中断指令<br />
– INT 中断类型<br />
• 0-255<br />
• 中断向量表<br />
– 每种中断占4个字节<br />
» 前两个为偏移地址，后两个为段地址<br />
– 和CALL的区别<br />
• 相同点：断点入栈<br />
• 不同点<br />
– 清除中断标志IF<br />
– 清除单步标志TF<br />
– 标志寄存器入栈<br />
• 【例】 INT 20H<br />
– IRET<br />
– INTO 溢出中断（中断号04H）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">延时一秒</span><br><span class="line">START: MOV CX, 1000  </span><br><span class="line">DELAY1S: CALL DELAY1MS  </span><br><span class="line">LOOP DELAY1S  </span><br><span class="line">HLT  </span><br><span class="line">DELAY1MS: PUSH CX  </span><br><span class="line">MOV CX, 374  </span><br><span class="line">LP1: PUSHF  </span><br><span class="line">POPF  </span><br><span class="line">LOOP LP1  </span><br><span class="line">POP CX  </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<h2 id="类型">类型</h2>
<p><code>汇编流程   – 汇编源程序：用助记符指令、变量名和标号编写的程序。   • 文件名：\*\*\*.ASM   – 目标程序：机器能识别的二进制代码程序。   • 文件名：\*\*\*.OBJ   – 执行程序：为PC系统所接受的应用程序。   • 文件名：\*\*\*.EXE   • 工具程序   –</code> 汇编程序：把汇编源程序翻译成机器能识别的机器指令程序的工<br />
<code>具程序。   • 文件名：MASM.EXE   – 连接程序：把目标文件与库文件以及其他目标文件连接在一起。   • 文件名：LINK.EXE</code>汇编语言语句类型<br />
– 指令性语句——真指令<br />
• 实际的CPU指令<br />
• 汇编程序将其翻译成机器目标代码<br />
• 由四部分组成：<br />
[标号:] 指令助记符 [操作数] [; 注释]<br />
– 指示性语句——伪指令[伪操作指令]<br />
• 方便编制程序<br />
• 不产生代码<br />
[名字] 伪操作命令 [操作数表] [; 注释]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSEG SEGMENT PARA STACK ; 堆栈段定义  </span><br><span class="line">DW 256 DUP (?)  </span><br><span class="line">SSEG ENDS  </span><br><span class="line">DSEG SEGMENT ; 数据段定义  </span><br><span class="line">MESS DB &#x27;HELLO&#x27;, 0DH, 0AH, &#x27;$&#x27;  </span><br><span class="line">DSEG ENDS  </span><br><span class="line">CSEG SEGMENT ; 代码段(指令区)  </span><br><span class="line">ASSUME CS:CSEG, DS:DSEG ; 规定段的性质  </span><br><span class="line">START: MOV AX, DSEG ; 设置数据段基值  </span><br><span class="line">MOV DS, AX  </span><br><span class="line">MOV DX, OFFSET MESS ; 显示字符串信息  </span><br><span class="line">MOV AH, 09  </span><br><span class="line">INT 21H  </span><br><span class="line">MOV AH,4CH ; 结束本程序运行，返回DOS  </span><br><span class="line">INT 21H  </span><br><span class="line">CSEG ENDS  </span><br><span class="line">END START  </span><br><span class="line">汇编语言有若干个段  </span><br><span class="line">段名、开始、结束  </span><br><span class="line">唯一的END结束  </span><br><span class="line">定义起始执行地址</span><br></pre></td></tr></table></figure>
<p>表达式和运算符<br />
– 由汇编程序计算<br />
• 值<br />
• 地址<br />
– 算术运算符（7种）<br />
• +、-、*、/<br />
• MOD<br />
• SHL、SHR 逻辑运算符（4种）<br />
• AND、OR、XOR、NOT<br />
• 和指令助记符的区别<br />
• MOV AL, 0ADH AND 0EAH → MOV AL, 0A8H<br />
– 关系运算符（6种）<br />
• EQ、NE、LT、GT、LE、GE<br />
• 关系成立时返回0FFFFH，不成立时返回0<br />
– 数值返回运算符<br />
• SEG<br />
• OFFSET<br />
• TYPE • SIZE<br />
• LENGTH 属性运算符<br />
• PTR 修改操作数类型<br />
• THIS</p>
<h2 id="伪指令">伪指令</h2>
<p>数据定义伪指令（变量定义）<br />
– 数据定义伪指令用来为数据分配内存空间(规定变量的类型），<br />
并设置相应内存单元的初始值。<br />
– 形式：<br />
变量名 变量定义符 操作数, 操作数, ..., 操作数<br />
• 其中，变量名是一个符号地址，表示其后操作数的首地址，变量名为可<br />
选项，给出变量名只是为了按名存取其对应的内存单元。 变量定义符主要包括下列几种<br />
– DB（Define Byte）：定义字节，后面的每个操作数占1个字节。<br />
– DW（Define Word）：定义字，后面的每个操作数占1个字。<br />
– DD（Define Dword）：定义双字，后面的每个操作数占2个字。<br />
– 操作数可以是<br />
• 常数 例：DATA DB 10, 4, 10H<br />
• 表达式 例：DATA DW 2*3, 8/4<br />
• 字符串 例：DATA DB 'ABCD'<br />
– ？表示只保留内存空间，未定义初始值。<br />
• 例：DATA DD ？, 1, ？<br />
• 重复次数 DUP （操作数，．．．，操作数）<br />
– 例：DATA DB 3 DUP（？，9）</p>
<h2 id="存储器的分类与组成">存储器的分类与组成</h2>
<p><code>存储器分类   – 程序的执行是从主存中自动的取指令到控制器进行解释执行，需   要的数据也放在主存中根据指令需要存取。   – 按存储介质分类   • 半导体存储器：双极型，静态MOS型，动态MOS型   • 磁表面存储器：磁盘（Disk）、磁带 （Tape）   • 光存储器：CD、CD-ROM、DVD   – 按断电后信息的可保存性分类   • 非易失性存储器   – 信息可一直保留，不需电源维持（如 ：ROM、磁表面存储器、光存储器等）   • 易失性存储器   – 电源关闭时信息自动丢失。（如：RAM、Cache等） – 按存储器功能分类   • 读写存储器（Read/Write Memory)：可读可写   • 只读存储器（Read Only Memory)：只能读不能写   – 按工作方式/存取方式分类   • 随机存取存储器Random Access Memory (RAM)   – 每个单元读写时间一样，且与各单元所在位置无关，如：内存。   • 顺序存取存储器Sequential Access Memory (SAM)   – 数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置   有关，例如：磁带。   • 直接存取存储器Direct Access Memory (DAM)   – 直接定位到要读写的数据块，在读写某个数据块时按顺序进行。例如：磁盘。   • 相联存储器Associate Memory/Content Addressed Memory (CAM）   – 按内容存储与检索，根据内容访问存储位置并进行读写。例如：快表。 – 按容量/速度   • 寄存器   • 高速缓存   • 主存   • 外存储器</code>参数 – 存取速度：<br />
• 存取时间𝑇𝑎：指的是CPU从启动一次存储器操作到完成所需要的时间。<br />
• 存取周期𝑇𝑚：是指连续启动两次独立的存储器操作所需最小时间间隔。<br />
• 带宽（数据传输速度）</p>
<h3 id="读写过程">读写过程</h3>
<p>– 读<br />
• CPU先把读单元地址送到AR，经过地址总线送往主存，同时CPU通过控<br />
制总线发一个读请求，然后CPU等待从主存储器发来的信号，通知CPU<br />
读操作已经完成。<br />
• 存储器通过ready线回答，如果ready信号为1，说明存储字的内容已经<br />
读出，并放在数据总线上，送往DR。<br />
– 写<br />
• CPU先将写单元地址经AR送往地址总线，并把写内容字送DR，同时通<br />
过控制总线发出写命令，然后CPU等待写操作完成信号。<br />
• 主存把收到的信息字写入CPU指定的地址后通过ready线发出完成信号。</p>
<h3 id="只读存储器">只读存储器</h3>
<p>分类<br />
– ROM<br />
• 芯片的内容在制造时已经输入，只能读，不能修改。<br />
• 存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。存储<br />
元件：二极管或晶体管。<br />
– PROM（Programmable ROM, PROM）<br />
• 用户可根据自己的需要来确定ROM里的内容，常见的是熔丝式PROM<br />
是以熔丝的接通来表示1、断开表示0。常用于工业控制机。<br />
– EPROM（Erasable PROM, EPROM）<br />
• 紫外线擦除，只能对芯片进行整体擦除，而不能对芯片中个别需要改写<br />
的存储单元单独擦除。编程次数不受限制。 E2PROM（Electrically EPROM）<br />
• 电擦除，可以用字擦除方式擦除，也可以用数据块擦除方式擦除。以字<br />
擦除方式操作时，能够只擦除被选中的那个存储单元的内容；在数据块<br />
擦除方式操作时，可擦除数据块内所有单元的内容。编程次数受限制。<br />
– 闪速存储器（Flash Memory）<br />
• 一种快擦写型存储器，它的主要特点是：既可在不加电的情况下长期保<br />
存信息，又能进行快速擦除（整体擦除或分区擦除）与重写，兼备了E2<br />
PROM和RAM的优点。<br />
• 闪存的读取速度与DRAM相近，是磁盘的100倍左右；写数据（快擦－<br />
编程）则与硬盘相近。</p>
<h3 id="拓展">拓展</h3>
<ul>
<li>字扩展（位数不变、扩充容量）</li>
<li>位扩展（字数不变，位数扩展）</li>
<li>字位同时扩展（字和位同时扩展）</li>
</ul>
<h3 id="内存">内存</h3>
<p>解决内存访问速度慢的措施有三个：<br />
• 提高主存芯片本身的速度<br />
• 采用多模块存储器技术<br />
• 在主存和CPU之间加入Cache</p>
<h3 id="外部存储器辅助存储器">外部存储器（辅助存储器</h3>
<p>磁表面存储器<br />
– 两类：数字磁记录和模拟磁记录。<br />
– 原理：磁性材料沉积在基体上形成记录介质，通过磁头与记录介<br />
质的相对运动来读写信息。<br />
– 优点：<br />
①容量大，位价低<br />
②记录介质可重复使用<br />
③信息可长期保存甚至可脱机保存<br />
④非破坏性读出<br />
– 缺点：<br />
①速度慢<br />
②对工作环境要求高 光存储器<br />
– 记录原理：用激光在具有感光特性的介质上非接触地记录高密度<br />
信息，以介质材料的光学性质的变化来表示0或1。<br />
– 优点：容量大、可替换（便携带）<br />
– 缺点：速度慢。</p>
<p>寻址时间<br />
– 寻址时间包括两部分：磁头寻找目标磁道所需的寻道时间和找到<br />
磁道后磁头等待所需要读写的区段旋转到磁头下方的等待时间。<br />
– 平均寻址时间=平均寻道时间+平均等待时间<br />
– 平均等待时间与磁盘转速有关，用磁盘旋转一周所需时间的一半<br />
来表示。 数据传输率<br />
– 外部：磁表面存储器的缓存在单位时间内与主机之间传送数据的<br />
位数或字节数。<br />
• 单位bps。<br />
• 取决于总线的类型和标准<br />
– ATA、SCSI、SATA、SAS<br />
– 内部：磁头与硬盘内存之间的数据传输率。<br />
• 传输率=记录密度D x 运动速度V<br />
• 误码率<br />
– 衡量磁表面存储器的出错概率，等于出错信息的位数和读出的总<br />
信息位数比。 磁盘cache<br />
– 基本情况：硬盘内存速度差 (ms-ns)<br />
• 可采用增加磁盘主轴转速<br />
• 提高I/O总线速度<br />
• 改进读写算法<br />
• 采用磁盘cache等方法<br />
– 缓存的大小与速度是直接关系到硬盘的传输速度的重要因素。<br />
– 主流硬盘的缓存8M以上（有些甚至1G）。<br />
– 类型一般是DRAM或SDRAM。<br />
– 采用预读策略（局部性规则）：对顺序数据特别有效<br />
• 视频数据<br />
• 图像文件 磁盘阵列存储器（RAID）<br />
• 廉价冗余磁盘阵列（RAID）是用多台磁盘储存器组成的大<br />
容量外存储子系统。（Redundant Arrays of<br />
Inexpensive Disk）由美国加州大学伯克利分校提出。<br />
• 目的<br />
– 组合小的廉价磁盘来代替大的昂贵的磁盘，降低大批量数据存储<br />
的费用；<br />
– 希望采用冗余信息的方式，使得磁盘失效时不会使对数据的访问<br />
受损失；<br />
– 能适当的提升数据传输速度。<br />
– 保证数据的可靠性和高可用性 RAID的实现<br />
– 专门的控制芯片来完成<br />
– 用软件的方法来实现， RAID 0级（无冗余和无校验的数据分块）<br />
– 将连续的数据块分别存放在不同的磁盘上。具有最高的I/O性能<br />
和磁盘空间利用率，无数据冗余，无容错能力，不能应用于数据<br />
安全性要求高的场合。<br />
• RAID 1级（镜像磁盘阵列）<br />
– 由磁盘对组成，每一个工作盘都有对应的镜像盘，上面保存着与<br />
工作盘完全相同的数据，安全性高，但磁盘空间的利用率只有<br />
50% RAID 2级（具有纠错海明码的磁盘阵列）<br />
– 采用海明码纠错技术和位交叉技术，用户需增加足够的校验盘来<br />
提供单纠错和双验错功能。当阵列内有G个数据盘时，则所需的<br />
校验盘数C要满足公式： 2𝐶 ≥ 𝐺 + 𝐶 + 1，如果有4个数据盘，<br />
则需要3个校验盘。对数据的访问涉及到磁盘阵列中的每一个盘，<br />
对大数据量传送有较高性能，但不利于小数据量的传送。RAID<br />
2很少使用。 位交叉存取<br />
– 将一个数据段中的各位分别存储在不同的磁盘上，以同步方式进<br />
行读写，最小访问数据单位是每个磁盘的最小读写单位（例如扇<br />
区）X磁盘数。<br />
– 适合传送批量数据<br />
• 块交叉存取<br />
– 以数据块为单位，将连续的数据块分别存放在不同的磁盘上，最<br />
小访问数据单位是每个磁盘的最小读写单位（例如扇区）<br />
– 适合传送少量数据 RAID 5级（无专用校验盘的奇偶校验磁盘阵列）<br />
– 无专用的校验盘，将校验信息分布到组内所有盘上，对大、小数<br />
据量的读写都有很好的性能，因而是一种较好的方案。<br />
• RAID 10级（RAID 0级+RAID 1级）<br />
– 由分块和镜像组成，是所有RAID中性能最好的磁盘阵列，但每<br />
次写入时要写两个互为镜像的盘， CPU占用率高，磁盘的利用<br />
率低 磁盘存储器与光盘存储器的比较<br />
– 两种存储器的记录原理、组成部分等方面都是相同的。在计算机<br />
中它们各有自己的特点与功能。<br />
– 硬盘驱动器<br />
• 容量大、数据传输率高、等待时间短。<br />
– 光盘驱动器<br />
• 存储密度高、容量大、价格低。但是光盘与主机的速度不匹配所以不能<br />
作为中间存储器，即不能替代硬盘 <img src="/images/obsidian/20230610145852.png" title="image" alt="图片" /> 为什么这种层次化结构是有效的？<br />
– 时间局部性（Temporal Locality）<br />
• 含义：刚被访问过的单元很可能不久又被访问<br />
• 做法：让最近被访问过的信息保留在靠近CPU的存储器中<br />
– 空间局部性 （Spatial Locality）<br />
• 含义：刚被访问过的单元的邻近单元很可能不久被访问<br />
• 做法：将刚被访问过的单元的邻近单元调到靠近CPU的存储器中<br />
– 大量典型程序的运行情况分析结果表明：程序具有访问局部性特<br />
征<br />
• 指令：指令按序存放，地址连续，循环程序段或子程序段重复执行<br />
• 数据：连续存放，数组元素重复、按序访问</p>
<p>• 键盘<br />
– 键盘是一组排列成阵列形式的按键开关，按下一个键就产生一个<br />
相应的字符，然后转换成ASCII或其他码送往主机<br />
– 键盘输入信号处理可分为三个步骤：<br />
• (1) 按下一个键；<br />
• (2) 查出按下的是哪一个键；<br />
• (3) 将该键翻译成能被计算机接收的代码<br />
• 键盘的种类<br />
– 机械式键盘<br />
• 触点的导通或断开<br />
• 每个键由底座、轴帽、轴帽固定卡、弹簧、金属支脚、触点金属片 导电橡胶式键盘<br />
• 通过导电的橡胶实现触点的连接<br />
– 电容式键盘<br />
• 当人体（手指）接触金属感应片的时候，由于人体相当于一个接大地的<br />
电容，因此会在感应片和大地之间形成一个电容 薄膜式键盘<br />
• 无机械磨损<br />
• 低价格<br />
• 低噪音<br />
• 低成本<br />
• 市场占有相当份额 • 鼠标<br />
– 一种坐标定位部件，只能用来输入相对坐标。 • CMOS传感器将每一幅图像都发送给数字信号处理器（DSP）进行分析。<br />
• DSP检测各图像中的图案，并分析图像中图案的位置如何变动。<br />
• 根据一系列图像中图案位置的变化，DSP确定鼠标的移动距离并将相应<br />
坐标发送给计算机。<br />
• 计算机根据从鼠标接收到的坐标信息，移动屏幕上的光标。<br />
– 与轨迹球鼠标相比，光电鼠标具有下列优势：<br />
• 没有可移动的零部件，这意味着磨损更少、故障率更低。<br />
• 灰尘无法进入鼠标内部并干扰跟踪传感器。<br />
• 增加的跟踪分辨率意味着响应更顺畅。<br />
• 不需要鼠标垫等专用表面。 触摸屏<br />
– 电阻式：利用压力感应进行控制电阻<br />
– 电容式：利用人体的电流感应进行工作<br />
– 红外式：在显示器上加上光点距架框，在屏幕表面形成一个红外<br />
线网<br />
– 表面声波触摸屏：玻璃屏的左上角和右下角各固定了竖直和水平<br />
方向的超声波发射换能器，右上角则固定了两个相应的超声波接<br />
收换能器。玻璃屏的四个周边则刻有45°角由疏到密间隔非常精<br />
密的反射条纹 条形码（Bar Code）<br />
– 由一组宽度和反射率不同的平行相邻条和空按预先规定的编码规<br />
则组合起来，用来表示一组数据的符号 主要类型<br />
• 堆叠式/行排式<br />
– 建立在一维条码基础之上，按需要堆积成二行或多行<br />
– 继承了一维条码的一些特点<br />
– 需要对行进行判定，其译码算法与软件也不完全相同于一维条码<br />
• 矩阵式二维码<br />
– 它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码<br />
– 用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制<br />
的“0”，点的排列组合确定了矩阵式二维条码所代表的意义 显示器显色原理<br />
– 像素点：颜色显示的最小单元<br />
• 一个像素点包含三原色<br />
• 通过调整三原色的显示强弱来控制颜色 CRT<br />
– 可用于字符、图形和图像显示器。<br />
– CRT是一个真空器件，由电子枪、偏转装置和荧光屏组成。<br />
– 玻璃屏内壁涂有荧光粉，它将电子束的动能转换成光能，显示出<br />
光点。不同的荧光粉在电子束的轰击下发出不同的颜色。<br />
– 对电子束的要求<br />
• （1）电子束要有足够的强度和速度。<br />
• （2）电子束要足够细。<br />
• （3）电子束的运动方向要高度可控 有机发光二极管（OLED）<br />
– 自发光的二极管，无需背光<br />
• 等离子显示器（PDP）<br />
– 利用惰性气体在一定电压下产生气体放电现象而实现的发光技术。<br />
• 显示技术的重要技术指标<br />
– 分辨率<br />
• 字符显示方式<br />
– 一屏可显示的最多字符数称为分辨率，例如80列×25行，表示每屏最多可显示25<br />
行，每行可有80个字符。<br />
• 在图形显示方式<br />
– 一屏可显示的像点数称为分辨率，例如800×600，表示一屏可包含600条水平扫<br />
描线，每线可分为800点。<br />
• 分辨率越高，显示的信息越多 颜色数（位深）：每个像素点可显示的颜色数（灰度级）<br />
• 每种原色由8位表示灰度，三原色共计224种颜色<br />
• 实际传输过程中采用32位表示一种颜色，而高端显示器每种原色用10位<br />
表示，总共可表示230，约10.7亿色 按打字原理分：击打式打印机（点阵针式打印机）和非击<br />
打式打印机（喷墨打印机、激光打印机）。<br />
• 按工作方式分：串行打印机和行式打印机。串行打印机一<br />
次只能打一个字，行式打印机一次可以打印一行<br />
• 常见打印机类型<br />
– 点阵针式打印机<br />
– 激光打印机<br />
– 喷墨打印机<br />
– 热转印和热敏打字机<br />
• 发展趋势<br />
– 击打式和非击打式并存<br />
– 击打式的多样化、特殊化：银行、铁路、超市、酒店</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>计组</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>苏州大学</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>基于赫尔辛基大学《深入浅出现代Web编程》的web笔记</title>
    <url>/thinklive/3231/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励" data-whm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励">
  <script id="hbeData" type="hbeData" data-hmacdigest="23f25c1e75edb7c1c4ba0cf24b4eed24321acfb55c909f8bbdf0a09e90c31bd6">3f83cb85842003a042bb5c209f93aa5b5b295d1a7d370853f032ab70d9d9b26977df920c900199e248437f3e78d5892117a9c69c479ca7fbd743a49df8f184d553030ddd062c2e2748d895dcc46d04c80840f49fed96f7edf7bef137402556311ff081a4f48537c30d0460ca80700433b6efe1f5e692b8287e08c359f99c34033e011ed51946cac761a5a6ccd4082f4a2c7f7882d49020054cccb50467da0afccadf6ca339ed46e8d3fae6dac77fd6129095bd789ff673e7c84502f197a43c02cb3b6cecfb212e50d5db35cf6d189a4a66d3f619aa8a8004ab8e942875a8b5ce770db5f0d3189ee6eaffe2927347d07eb4875d15d03a6378db344771651c106911581f6ce39b64b80e5d3aef1ea6f40325ba7c800d87cb59ff5dc588eb57a7c1556ca9de7b27b7f50b0ef336b393ea707eb8c3833f91cd59861c669afb1dd9639b5a4ef280d6c30b0031d03ab06d99a45c9466cef85360a2a6b2ac976d178632c0a531090b7ce0e0a275373ecb4ae985cfe0f58fa148b857337ee340d92dff4957209d47b3fbe392743897132630d37b112c654e61ab5544ee2ebaf10531fabc7690f50c1222851970f2c972547d28fb453d01139660786af2be02f6df6371f1cddfe503c93532df2d58bd3618a0e8a217dffbbfc90c3654d6dd23b95ba67f35ff50656fcb4ab859fc02e56b1c057e033ec99666f942b245b4d3795dbf69f1a446799ae786f316172904ac877dbb8ee3ad5a78e795bc671642f0bf72df4e0cea99c51ce0058d32c0689eb20dc3dc895d9cba070297916d8cf62fc31653a3b49c7f754040d6fb958cb3ef35e3681156d56e23e9dab08252146e6b2c35789cce8da900bbfe68a885a71e830f19094afde825694e9ff246de069dbdad3abd20de9782aef40e86a4e81f735bfed8cc564208b1c5ba50fa6d6380449487bcfe5f92c7faeb56ae70c1c1251c24b9eb113fe3a9dacbe72658013d292952f4517c6fd36b616f0b0c5d25792775481ea83afe045169ef500210582a39ab30869e0094436e9a16aaf3e5d8ec6c5c09963d93c9bf4eb64e3fba62dab20769168d1ddc99116ee97ba52c163cbf7ad4cad0d67b1788105e6101511070bbece99b633e6a4eba41cf71b5a519abab4cf5690252bf964da2776898533a38208e262e5f91971346454b7df580d87f5700500f1d29a5c8b2d1555bb1388eb90e08f40af87d36876afa8dd0cf3ff5005272aaab4cdd6b63aa2dd6dc95a76d913a135efde4b3911cfea12ca8337ae4951e7766b7e8401c249c53526af3eabbc0bfba0ac175dbdeabbab785ca8f2b76a609b6ea49a32ffbdf1e860c4dc8bdcf9565637a7fd70cb49564cb1dd0189912e3d316f9c6aaeb2783f228aec595055fe6b6997512c75cf3b4db07f353765159db93028ad212a0c1d9a86e1bca8e6c0f44e1678ca70161d71cb87066901f73ffdfda3248258d94eba1752b97484ba36578a6e4d52088cc4f91d5f57ea0a578d1a0686e839b06fdb494d75ca1db6d32e244faca6bcd5b1536f9f13b3223a1b2c65288cf30ab8287ff54a30b51d05a7a20814766f2e22fd9fb0f8036457126b1b66478bee29d17fb2bbc10d378282d2d2c7708dbbbb5bf9f87b6cb8646dcfcf8f3d7a02c40f6caee6cf1b537de0e911fc9673b4923abba3856191bd48a1813f132cc81f3d6da3229d83395bf1114a168016d3fd6087bac38f10008be30d6253a22b909104b0da5e6bd5145e7b485d9b7ea6b6bb6ad86f08ae5a823039fee1810282905ad65ea572f72619548a4bfaa96c5ae29b48af55bb175983a2d6b46de6169b9d8e5ac336ac2ee88efb944c38cf2c2b3c5524d724ea764120985a102cc80c389478ade90089f68e95de19cfc7a75fb9cefce85a1b4b34d0965e570860a85d966ff833dbe744cfcf6e346957caebd9abc57468041473f3a11d09befbbfd584d103a9445b0ec733537ff8ea7263de96225fede07b89d3d44bb45722d380ad71378f27a807e16220ca08f7e045325b32ac8eabb2ce15c68c99f36d8b4faf11053f35f864bec095ee250c2b5d7fb26fe9fb4e708e1268c0798d86ae17a994acd1c49e28a4b9968442209e296488dcfa4cd3b408f5a8c9d7754a876873ab97cb6077d4d37d02ae448b17163ebab2366c10811a99b46c7a79c6026623c432622123dee4d7b73e4bb3fb631e4189bf08ec6e68625d8d8ba558c5538eda09806d74258bfeab39a8851fc10092e472f7ad5b8d9bf6489ba566a5c08417ef947d98083871739dfc3e5da77b24ac573674e386bbc53e53e89156ebda7c91bf8212dcbbe5949fa5db74eb995b5c1071c02713fd011edeccf4cbdd9d976c4bc8dcfc895762014f0299f3f0858e35d67fabd2ddfa3cdf2426485b6e7fa05632b48124a3e0216cca0bde4086a7c2ae6d0d9b6b85c6da9e7659725ec51a6ec1b9b3e5d7add8d9ba86bbe8dfa57cd193a64b3bdd712e1e5df601054679e445f7c27fe29a486f2e007a391de3cc0ab15d04ee9cc9d4e721e014fa6d4613b609b63dc669feed53a2d11f01beac6e45b0ad620ffdf454bfea4c9ed1a3d1a1fd6a4a62770dfd2562f35276eec654f0b95166ab151b943f1808be0385695d68637d9939ddd19255703702cee2b643112f2c44b77e06a1ed28319e21243f771ae5f774ac0d2b086a404afc627b1c5458c5b09a2f0227be6058e4ba4b5700f662479fd2cfa1500add0d8c7540601ba973e7bee26f08fc0358f4fd80a99fa81aa9bf78ec7268200f803349742959888e753eae98cc94b8c25fa47f2a1db131ef5a1f58bd72f81a5436d05cdd02ecd19b8eb1102c07a948f0e6fc5d071fad94e07a6e68d40b31adac2742f5d4de0a82b11d30770fed8a923fec96cb260765289d741983012d85ccad89039d7eddeddb657f8937addd860c7ca92a7b8585754dbf63d902998535592fb1c684a7b280aeb24225de55470248b1a46441a48ff2c612a3cf9cf23a6ba2dc9d80c07b526a31af6d5ac85c3ae4bcb11da842569114b3d4647f0ee9a012f0233fd2f7c2fe1e969091d2b7e620d1bec1a29bb21c035650e78b0c15856ce588a63299b344d888f4c50b64e2e3ac1f1360449ffc67a888d0b9a76fc04c45f7f43a5eaaa4a21aaa3cb414c949a782b622b9ea8f454d2d347e0cb54cd4b05637b832a8d36e48b78942639ab34e8ca6d9656a30260b0c13a7a8408e0fc63c9327d1b9090462ccbfbc7eec147de9f2fdd5cf682925b29b9ea65d30609ad753ecf8185977de654400fc34fe36049032f5b9c4293315afb1ab9268708b6b3659bbae2f9485f416c4a9cf4442113b9dddca391508d4520f73590ccf7731cfffc49223ba74b8a8d6ec1f93e04d0bd460b3c08825595b9829e135702f1701db1571a0580c617033a1975ef47e0466ed82a18763c30348544a0de739a1de76d966440a99772e16f979bf79f12e9605a91b2a79472fa8dc96ef5304f6fae9778fcac99d6f6ae6b3d13123c185dad1f18dc9d136b1d02c0adada2303e9b0e2606e324155fd2cf5cff70109b437c28001844d40c74820d9dcb1a72557ad68230fc8da5b5843dc6bb7cad655fa089f2f4d226e1c2cad3980500e2aec82300ec4807a88d0552fd3b03b64438fb4984ae40f6cd755c868b1f4d7ba1d92a3158258857881cbd6eba1cc76de05a34599d7694d018f03bd528415cbe8d46d64b3840daac4ac7518e74caf198e79c303557b70255f0021f4f5618c3facba0a72616b911c82bca0db0da435b3692ad1f8276317fab2aa0795912e2bef98a00de229fd282a40cb60aa48c8e7e249042b0bc724c049848016fb1de74976fc4537a53b772fdb4d1483ca0972c00c1c05b0300a353df792bc6a21cf3b8162231ba19d5934bd1d4ac593d2b5c4c5203b5d7e9bbdd694ec70456e31130e6a23bbb7b140417dab28309be8d31bf916a4fa715c15506c571d09f5fa3da55fda02627fc1207c14f90a8757a78a64c9927b3df94b3bd3ca58b833ad1d7f9595ceeaa271e0278ac37c775c7f9b221b95b5bb5a431a45790b7cdc1460eebbfa27b58e97af09c20b800c10145640c16dda716ff5340e65229cd944df8f66ddc117e35cb1c892cc9baa0f8934e90323ba56b4e6c8b3eb72c4630e04ffed1d7a75aacb147ea1057fc48136cc287394b197dc5e2d447909d042d28de3f5f96f6ee09a941e2b9f3f611dfd904da9fb0bf0301b5f219128acecdaebe7f7b7b4be85203b2a17a54cdcb28545e88c1e28078895059d068ac4c4a81e8a87c8532474188a5edffdf46f29d7a5b550a6609cebac9691439a7fab5fb72cd717d0d442c5fa6b88ccf06c3aaf73a92b8d50125016d48ca9a837bb4c703b0a4e4030064f293c29e7d2f5c243945be67e55b6598af7166073e3d7d8fc48be26084e82b573f80c5fa095bd89ef898a995c945c7d62483bc68e9a23a214c7161aab3abbc85d8a24c19df91dbcd34a16321e54efbd71999f000a3c5fbe8ffb3b0a2750eab4649c8c0de1d24638b9f54831550bff0ff4b71fec14363a25c6e91e1d1e7adc5ddf08b5224337da252e9800a061ac4046b145e70d565461146eaeb75e8b9bbdf834f366ee1ae469f77544fd8f11bb5a74ad8bf5e8877493af65cac05c7d0df527699810565ba799e48f251c40adfb2a15d7ec1c310add371f929b043e91b44c612983641e8f58a81b3595e7107cb2d6494b33411cff71c116f485fea5a63d55a37b2e389681654686b26f0059209573b28eb95533635f8bf47bb842616f0d04180d520adb19e4f36755dabf71dcb502b596c35f4a2c2f516be2b7d0477de107e4b375984fc3c485612a70d6a590f51f4f1b52f52b769125868367215294b63c980ad76efe6c6f0d9537afd7eddf54c00dadf394c606d1bd6fbf6bd299e04b78fcfbc7856442d9df0ac37331b727b70446761e7ca02720c7c291a60b952ccf670c464607e0b4ef7ce08ee3c3adb971567e3a63e0789032cedc63f1476126584f68c9c3209fddb0d25b3fda66dea639d81644f084b54244878a14e1d4dd05bbadc588926075cec47c38fe9f5c7e773142ff0c3af940a5a4ffc9dbbd115da54560b2fc136cdc0ebf239c229ecdc7bee5527b590c65216c866361931394d989de077f772a51c63f357801c4caedd30a8920e0169d8a6f147a95ea57f4e691ed68ce191a8ae6dd6690b45440cae8953ebef817223c14b0a78b5803a20b70e4c4f64a74c9c8d0f20b8258e1a42ca91e2eda65548857c4b5a969a6baa739fb308a90809fd9ee1eaa3f11a4fd52726652e133ca7cf0d5176062d959cdcd75a4cdb60083d01728ed8bc5cca37d46b35cf8946fbc31d30860fb1d2a6c46c9a941802c8130e0f7a5da9ae59b639f9526aa4c46ffe3f8bef3722ca73a675e4b72150d9a5a2d381bd80bff15213dce7b77b642757bd4ffb5eb2c80064a70e6f3b7d76ad4d94d3db794b9c2d5ff7965714fe28583e44bf69dbae2c6c0451febe9ca06dac0b034612a9efe0f6fcc1fee62b11a77c7783f039e3117b5bc3852ea7883ade074d0ce390cc87feb7419af222a045080f8cc4924e16d552bd8333d28454f42f28d5a6a5526f3755a7d7fa4cae9f63ae82ec2cb5cc349edff0c5159df588e736dc00ad082b36618f25fea6fb9a7b1f3bea0fbac7563fa85bb747674a6846509ad84adc6d6eb7675d5a28081a5d0e12a017b85ecf03b0c89729d4f2860821faa163ac60c987c226c009b8f20ab8d254b38e7cd5480b05b850473e26e6af943480c979b9f51e3b9b96ba17842e4880535215e93a8ccfa29801caced20f5dfbc907bb495da8da97ccfc85b49107eefcf07f45a32d3b7e392a95c262601ff6efa95cd03363e7662c0697ee5d2daaac10193cfd23b70ff6e319038d12059bc67373517a1ab08d59fe9c8e6062a3a270bf87d27a91ae1fdc2bd0da8fb3811654974129e5c1cbcb411762ba86b392d8fa406444ebe680b2139883f5b6b55896f92764a6d32e890818e5c75f1c966651c22ea5814f9006658e94ac8680b00f587a193ae4b83d6b4296fdf5016ed377072dec174281813e9fa3cdead41b66ca9ec89bc58838eef02e3c9996d35629779a3b6b3253a3bb2b025afa770a9559a892451c57151d8cbc746e218ef238a05f7dffc2d80303a6cb425efe9a3fd900d093d76f7a6afdecb14824b85d38fa1f4bb0b0ad3803c7f27db91c5e9e9cc5f7595139859eaf532058fdde66e567ade6769fcdcaed1f1834a7869f450bb59c4580ac29039284da44c705b65f71517d1e1a18c8bc7f907c83c66786850a5c020c226cbc3c12bf1bdd3f8b5d6d387bc331238763f89c49bab722be95db973e12d4a02eeed11a84f6be500255e078d0db575379a471b4009ca7cf2bafa757e584bab40dbf229b5530cfbe49f837ad5817331f3ad14d0a7f44a86481eede78d7457a57620840d84164257a921c575818ae1caaff3bb9675e74e993f437ec01053737885b6cf98ee160fd9d47cbf45092133fe5c26a89542b2463907bf78221dd71b4421042e8138901095468b30f8a05c1c450198b2ecb135e75b9a5cc1b760c0ae15fbd78fcd3ba06bb040298fe80905698a33fd162ab09a5fc5642ab803f51887c1bcf7e8e6f30aceb06028f4cc5f5d830eeb0463fd9e10c6f91ddba77f343b5ac6c630955261b16fabad35b878430efd022a266d3479acca7b2fd0f0bbaeaa75939f3876c114adf4f838cc77aea87396efe63c38083b550934618645e98146b3dde4d94d1209879ba0724c371fbb347e0f1e7c316e053d77c6846ff352529005ed612781c59cba17531ccdb89a69f12b1333a0f9361ee789626f0a0b00d75e344ba817359a72eac53622a9d248abe32d06b9b9e9702fccc3fa1ee23874d0840c339157207649c134d4099646039a29c68186b5cba7250db8ac1452a1ee2a41c7ade69e231883feb0b35e5c68c4ac86919f64d3342a54eec5fd75a81990b646de0da6dc5f41f4974d12c8ffc4033c4668165ed87d07691ddc33d0207d1c94c8770d0a131c755740e898e80979bd27305dc11911b921fd7b55bb5e2ce7af291aa72e6654daef1e1dd112703f4cd6bd83cf49d23714b6cfcb17c3cccb9d506672b90469422dd3e1b028629ef78e57fd4cc981759073762a72351a4afab8342522755f8b7b81279a7327adeefb2814dc7f13583a6735410b2bf2c94b53053b7bb3cdf30146ae768b9b4fd3d81dced63696eb554b99b6c62ea7c436b16f0813ece61c978360954ee60dd083c0aa6ead3ba2be97a0f1959ea1998cb831a7a02d2477ff27be1d021ebd3ccc7dd656f8a80f7a1ff50a2f4464b6d16255b23012014f11c903e2df239a400fe6207094537c950a459cedf14fb3e0226e5de09269587edd7e908c84f8d5c4f1c5474a91ca9694601c53ba3e68598bebe5b2d0da08bc22b4fba33b642dbd295ad13a5ff6d830832c8970153dfd355268bc51db105d73cc473d117cff40edbd0df22c9bfc8a8da2b93090b1c82e466accd3d0f52a34ae1eca6d4f727fba655c220dc6e52fe00415dd00e77bcc3fe90a53bb30c809122c3e0aa127668e11d7fb474b077d5a7e09a6f517452b50f5591d71023d97c7c876c3ceaaf152504cf5bc8d909baf792d720a9c8f16fd79004a36c3a006c5ed5105809d2accc6bab9373689d0fdce22aa970d766c37f927f4798142c3d28255d4db6db19d59c64f23e955d22305cc2f53eb22e7bacbb0848f6b0c250794f8d4b4f003f142ced5b8c82360342beb12eef1cdac697afbad97e813da32927d366bd397c5788bc896533d099a18f9a35e716704acfd7802ebdd1c49736874d96c33f3d1786a0bd7e1bb542107a3caf6697b169a3534d8ee8459d96c1e21745092a76bc1dfffea4b91461c43769ba60ef42df06fc9e28dcb422bc263b6617607f3a08b05c97aa685fe35edfe6d549c2b8743956bd889767b382e82ec132f206a09cffc38874cf8911b129bf9d00475ba24ca57fd5075eb5fb27c158ce837fcc596c8f0306a88623e8bf61d9dd42dc98c6ba0758c535486015a15eedf4f30362bef78dd4a1929e0b7e545e4a653d4ea7025e8253b07bd698cb0efcb177d6f69903f18f99d7727179bb3da037e71c44b93a149e84564a778f50baac136c3d664b4d0b2f8dac89882d7532b602476926db2eec3ea1042650d10e05325fa7080b1a13d6a532b0b6c485865eab270e683c0f09d6c3253b0bcf6177a83e1978fd57de174b9f5020474e927bd2460c5961870b3a68b7f1b7d7aa80b7a793c794fffe3c26749217ffe22a79a6ae4ea6ba0b2f418d5a5bcbd08ee3cc25ff7edb154f51714206ad004466bddeac464137314347cd7d054f2d00eaf5166f643b7ccde6de2e4f9082dd3a1d1bc83d95ce3072ca007565e4083fed52265658a042f9fbbecd1a1f5992f7eb7a0cfd6c43c45c43ffb749abad35b17fcd5e08114b595704320a0364019a12454479eee072ffbe0f16e9bef19c6c89e545a0d88bed7bf319047915a29f70ee3a4d627e69972c889cf8b04ffaa1e08c062189f54094c1cfbe8ee827161ca1d9874fa7b2eb25b1913d809398c55c13e8ee30455a640efc01f127e7cd35a951f40278bd15fefcbc59a9b936b7343b2a2981fd6fe714e8f0b405b5ce1fe664feec06b0c60ef715afee30207db864b584bf6d070c9e34c2e04497d91365548ca749bf5ace50aaea5f63633bd532a33fe5b4275b85ef500a251798785df647225646b1a5411df0a2c41da843807ed44c617805aaf557d3a973c7abe018297c5ee7640d79f68d59371584cb451eea7186ec3732243cd8e166e65c068deef00693c9300b8bca6081e1af62d1e539be318db7d085177ff2ff87ad899041ede627adc53931b09b3b887b5f0700181db84e14b053298aab60b532a807d617f0a1d0643e737d1a213ddc33ac1773f1651ac1cd9218c3648659fa75b9527ecb4dce70cf096d4fc74d6ae594a0e273382bdbd589b276d254bc4c7170906c6d518be3f461aff687a924156f5236ef3979f032797c493dbf9b64aa7ee9e4c37b52f099ed35d0adb617a46f87744c1418e0b22d064dceab83f5939a7a7f62fd4f44709181c3e684d2069bd596a6ff4e827847374db12f7ce0f9c549c490fbec36940fe02eccc41d97182222f7331a3e7c5fdb2cd2838127b58dbf2001885579aade54d52fe3750abd4a1ad9bcea6e1afd72755feb8a6fd7464cf09b03e5b73349b360bf48f9a7dbbfed90a087b6f4beacf88957a4d5983b7e8f6d8e135ebb115dd8f62af1a0e2f172ea1a4960341a3a8429686e23b21560f7ec62000651808ac65a41e44349aa5209656387c0c09b4b5a172bc0f768ca7245439e9516b20a502d0a668db6c5961775e88c3018265adfecb50ed23f33e6d1db3569c1ba569c63f92f36dd9e53114b0b31f0106676bee8a1498a1baa0404e6987406273c3562063edaaa1d05296385e7457b8c0a89dde6bd0e666e11f2088d8c7fc685d05c3d9ea86503c861352d8368125e21e7386b10159f701e52f502fc58c021cee45fd4fde2f94984613fe65d495109ee42f2bde478856b8e1d5045627a0c3fcbbe7b3c73f6535dabc139d7d6884d40645dd9d3da67602d2108a99a7cb6f6d2ab7fed031e0e026eb3259330138ed129d67d121d15e9ca56a22111d8d048f87267ea1f4258bf258b7d40b4503383b525c7b8ac1b931ac770b5a2a22fa9d3c8f6ce578ef424ee400a12b43b50f7bc9a7a481ec2039c740f4e1352b42fcb2355000e22a2d94abb3c308388ce4b0b08cf36a4a646e42f166f5e709edf5f719002c036902dd45f9eff6ad79d6c333c27cfaaf993a3522ff99a64bb1d80b96e653a7276fe25427f6eb9920b9d49db5c7bf4a2439a6216a0f2a18352a35db4fedda77bfef26737af32e904acbfaf86da7bf972474f86a7bde7884bb939130aaeaf8fe7728d1b7056811dc2c274d10c102e665c23aa862017e1fed340f3cfa4e1ec1eb1856c1b10b305653584f72226e086151fd201ac68d765297b7d3eee2081b183d8d53fae37f101b77d03a8e8fd9c17bf0cf64198e31e5b65310090a6357f9d8a757bf68ba3a462e79c46f979bfc5aec93dda8090bbb4defea7ccbb91d84bc188b4c76c5651a59dc01f2b082f5e8bad1af316b47ec3e559d2594f519e67598a2c4749e09720b0c44d91e90ea131f5aae72d3e72270af44eb8c3a394f3b70f7036fd112ea905272d18b353fd1a8652e60a1751a6cf02f3ea9f99db03d8d7b983a5ce7e77f66a1ba8c0326f0cb2c2290c56ec01fdc1c02e4d21379d7665ab3e13d7bec28ad60c4d404828ac7b65d002268e12680a7d4ac286619a1cfcf4fbbfe5c055ad27a52f46d619051b91e0018bd60d8638439172b6e4cc601d1495802b66d145ce743994c18b358e9efdb7875f2fa9ec1adcad149eb39d8cca72391a7975aae55c679ff6fe8786b72064447e8b056ceb52181cf88a7a2a9a4df4778f4b35b34921021dc7c5752ec0de079ebb883edc62ee3ccb423363e5473d9e8e678b0c6a446892c0a655a07fc59ca90f7381440c1d22ff0009ed8d03b863d0debd23696904e6ac34a03689f65195ba424223ec5c63e383ac75e3149242c011fbaca3a490f3f56481a92645b901bea13afd7e9e66d9fef5f15c29a6e7960718208ee8e01979a625df6c67e99ecd83311d413d753e7c54b5a6909088494d6dd9a115c9856c292a841ae2db420dda82d5197086bd89f26f9df28304026182ad1d5616694c4e86d04d1aaa0c1d7da0aaaaa92d657429ddc916d04df33cfabf277677948081ceb4807050db872a987d1724ab65447b20a01d8904ca83087dd9189cf0f182c842d7af1a907f3a1c9f41540fda9bcbe8a194f109add6e0f91625635d4872efa945a6f29be074347b20a691e7e947b513b256852fdeb7d6c767fe3f60c69c525a624c09756f72633a514b72fb0d9db5701daa7d5510e4ad4e9393088f397352c25d882173f6f4fde67c1e25ddaf745d58a65c874339250a101b9bad6a0da4cd0013cd1b48c747373fe645fc503fff84b2f2476635193a80e5f8db37b930b2a946c2fda019e3f54ee202cd5e9c2a0db7a31843da075dd5ee39655539089e995918f20d2ef6a31dfc53dc7e867ed9275d9684281cb3221d5597bb60744cbf8faec21524f755f93b3604aeda0e82d923fd097650b82ead91da21262fc9cf2b92b241bc0fbc4b12f9338977b037b2ac4db1b71dca49e1f171ba4f47f196ce9169cac1128f2cc41bcd6ca1572b2ed72a87c7444b8c4bd5578dc53fdfd33d44ce86c69df47192062037086c4a052bd91fc724f19777a52331ce22396c6f6b2001e7ba6fb84ee0d5283f905cc5ac3752bb900baa5048f76edeb8f4b2e59ecae04255da60fdc7ad3097c31557f59fbd542e31cfed8097597184e37ad9be8ea5a1772d9b652178dd6c51218183fcb25d704c67bc332a3d6966b08d889ca1bea8cb105a595b11c4a9bd891b36dee5bff4fbbdfdec3426cdc0af35b973829b4464dac43fe83ce79c2dcaa780456f1601656833d53e46c68fcc2beb364e85807fc5b5530736faedae4db12a8901f6098f3d840c5746b6582c5a708c6ca87ed3def87c1b40bce4e261fab7d19695ea080ca96865dcb2d41edc4a3782bc9f72e1e3232d121389503cfb152a11cc32a7c9dabef302b7e0a53274d66ce71078895deedb40a89eca4fee28bbd25bc267dd784e9531ae681cafd5aa1e60a38d550efa99b6a30bf701777837da7bf0a61f07fee2560463a8ef2c6443a227a589f890d7eba8521d392301346f64e07fb2a3ce721b0bf357fadc0dc33a474bb94c2bce4254173ad7ac1a4274e1e3f6c88d5de6cf77b39dd226fd381d8cf856865f529c571106c2d6b3030cc9cd1515fe4a2f270581c3394444beb3ac2e5507773d0efc35a64eb92a57e2527ea891a68f49bb95ead9a3ea41adb73971fd846a469ef73d038b1df7ad0719942ad7b1384058fd76f3e3e381d6059d0ac94bdff2367d2e1c02381134127bd3f53b62a39a222adf343ea0091e4ee22344f5e0cc6c38ba01d63bd9beb7d5bff0b35c2db385856bccd8b073cc07d4f985b447aede1a705deaf712cbe389905ef1dd6080c16870c4c7f45e829940adc356178b733a657d56b2f81e6934d3b82e8370fa5e7b7d9fbafd16f22523a49e9860cd38859e361e0e9f04cf23101a02b8f973cf86ae47e0851ae0b33a2c8750225d2ab82e79fb961bc3a993fd62dbab7339e0d795f85e9fa07c0e87b1b30700323146e60d83a35624b57b0132eea5491bfa55f72513927f4814c0a752ec9bf3fd96c198a205d7c2aed0580d8c6a31130e917eb1a7ca52ae2777399556d641511fc4d65c129d3bdcc862b26fc8bb889b85b4276a63665568d4da0f335f06e0e260dbeb9d34a4aec434e8f60eea57d1988c3e5cf485ac91555f0f3d59fe1cfa8cbe3a77b91edf9b77130c575e3990e9ba8bd11b44e6a1175810c39ceb981be7d5c2f0d04a9515688ed16f66e07e71ff1f58bf1b47637d2894d84315fc8b211a0cd16c2960e78d07d915dfff61ee836569e62fcc6a5e43035dc983e7b1a5ab92fd8f71c1efb4ae4daec165b261ade44f8a10de7dff60663298320a7732d6ec04e0cd673942cf7850f9d368428e474e6abb2fd03f2633183348f45b7ba60abff07581581c2d505c0f8c4c697d58f8ff718be96c506434332f57496370a01fe06db7836123a1b6ee394e3070e8e95cc9232f531c8fc0145457e2a269ab4c309196da4a724564cacc8907576af276b17b4d1c8dbcebb8f287529a1b78cace327cd721ebc9d2003f0cc97045f318aa56d2696e3fe845257de775a2505de4cd1542c7b9e1f3b421df8237d4cb813488dc09608ab2c5805e946186c8b4a8679647de23e0d34a6c5973d532f28186c0e235064b63b1d72170b112c7dab3f013b995ce8c813f2fc9886dabcd28f594aa49233984edb170c054ca5f3b17af513ae650f1d215d1d5306653bb004cae801010f199c1407ea5e12dedccd71762f2ef7ad6616357b13d04373e4ea08e7c1f32f8596c263ed725d870603c7a230a80dbbaebfeac2e2f85de0971e4e94920ad870238d9ffde682410d853ccbe56bdc5dec8370858e8f69276333123fe7a1673f8c906dd10b670411dd375b8dfb0a0806b9c4e9c1d9bee2a7d76cb96371c90c06948bef7384bfa27ed0b6f18df7fb1c551683b424a2d07a14db7dbdf748d0f500927d70d415395cf63a63f4e5affeccbf8940678ad80ce4722f563183b539f4d161772dae98dc2a7e88039d1fdf13325a9b78005afbbdd17734c11a7b4d828a2737b974fbb1a65681a5df93de352b1ff52e0edd688b7d151e6c3e23fd9e76f5e0f6a03e4d5b4089474ad38d31497a27c3400574f3c7d1685b65d57a306775f77565496c49a808319080452a6d770235af1809460b9354d345c6559292ddbbba36abd1476f5270cf79ae5022d423f255511d15e19865e024c5500a1c6a04c0a26afbd29785f72b83bfc6c7e59cfb28f8fdd63e9640d9e1eff396481374657d0feea439d10b957bbfd110a9c692042bfa650f33f63ff5439dec192ef97df333e922a02087f3968440f9afc04bbccafc954e87f370575713b5b042803d92ce513ccb3f2a772671c2ac88538ffb73f783a55ebd55c58804f4d3828353ff564b107b25286bfb022927d470218376df70b33bd3a4e067b4eed093640f7410c0e9d087e211cf5908f22d4a6e0c4b9510934260e4f55abf0b5c2033d8d83d2e8b92a4d5c04519b8c8617478f2ed39d23e8783ba1743d2911d76183fd8b6a90b6a76c9d4f44b6dd75b0f6023da6a161c0a8f6adbc70cc8d191229649ed154377b9ab1a18718defddcd6599d1f031a8f786def9971f476f72896db18a2856177c753e2bb94c98718740876ad5a4a276027735a6c5e5ce1e5ffd03672abe9f286f51299e0eefc3bc90267e41819b86d18ceb8ce570e9e998166d1b177c5fbc39b4f203639bbfefa033bcc2874f63d7a025db448c817021fa1c45aa91b136212f5893a1a12215756d2ee518a8fafd24b4cf727d62b5d0e19d7141da33c07925898f09cdae2ad37503e90f7463b134171c75f991f7e6949df7036787a382836115b25b6016bbb75fb3468bf9f8239ef4933ae917c0a0f809d8fc624d8cbec4b62213060773bd7f799f1e5f6e9ee803a1ad32df1ed7a143494ca23c64deefdfd349265af7d166b5ea1e14fe41846104abd39de07927a895f384823e482a07be5e510fdf5a0154279bd2854950d3508f745f8249d54d1bea2be6a5b9955da0b78d23be8d7878cf73854a31ef514aa393c0b0d6a712784f88b2f069412a46f9b109d70a94ebdcca2acfeb6f659a2a9e16b12113b92bc178c2ff308ef388260671e861a45d7741aa76203f4a07dfc16b00441b5acf66d3f546e41589a6b52d50a3cc6e0873e0c2ad33c52021571cb5a133c5af452422e551b0ae1e61eedf4f6a7eaade957bb964ed2ae2afc010864da9549055637cc40fd76d5041a04c0f52fcbbf681c9a273998c7084287d33f0e5f8cf2c6fde4aec8470bcfb59902b3051ee1ee39567d433ffc9059302ae9e8b5ae7a8f07298b2d128c5f7b90db58f788cc2a23f8dbe216e1815614595c53ade875f539f5e3879e1e3a27649a588c828ce6e25a34f79c0dd541701cd4f380c1b006585e2119e9400b375398260692453bb316bba1e43e23a94c65ccccc1637f9a03e41f70a7a770d55fc3d83b5c948f815e75a126145225f9a28457cbf78b91575a7d56e3b34a6f2fc730777a7174ce4ee6a63dd28cd971e19e7dcdbe8f2b8ded59a7fb64fb7ae09b58f3355278b4584ce811ffe13d8d352283d06686323a6e85207878f61cfb4d80301b8dcfa35731e8591fd5005a8651ae8ed661bd2c964072fe7105c5b77fabe3b8e315b0280ce61c9708ac8c75a679fe6463cf49dc8c666150accfc69094a0ed6671c5696601528163654e9e84c6d954c76f61f56d183897b2cf6c304d2ef9b5e72e647c963118282478a96654b1c31dee1fc55c4f8d699a83e3a8bb3b699ae070c418d05e5369becda8c4b9da9ddb24b549ab1e560583b588365d6ba411365f62c282f9409c33ca521a3b89d256eb2a6aa3aa937c59e908494435ebba00c334bcad9450c998da6a1d487d43085e74edf37d87240037c8e66e1d2f6eb7d9a2fa5f44857537a937a66f681df9bc5d1620527869d3d1b314023f3b108950f1f98daa519c21b6d621d5247a6b20d60edd8c9a5b3c29ca89529d2b9488eb39e5fadfdaa63c624435dbdbfc0d8d592455a0eb34fde42b7e084a3b1558ecdd0075d4475a1bd4cc378ab65a063fc951910d5bd7cfd4fa0985e9a2878c16acf99ea05e73197dac3281f3e2cd6b0a2906f0f2d26c3d676c252158182bb41fa79faa75b0f9b4c21c6cbf5aaf799121b1b45ea629e581776a55fd2f2d20d1161a75cb084b6a0c120f1e2e48cab60ca743ef6175b54cf67af0024e3b37f724599d5197237f69b5ac99876261a35a69b708fa0c19a9cb561d4419c0e5d5b99e7e4ce35d9a1b8c80531db9e22be82cba02402d1053cd11f204b437769a59aa9db9760f55dcfa56840825c157d931f55d57200b3f066ef7d8226af845b8064c3fd993ceb300a156aa4ca9d1a0103de1dc224267fb5dab3623f817ee175c1b9c7e5e26e36ddf770b518b080a75c807f0a24b2955c48f4bc964172735e794f38a7decc3bc128ae14079c44af1c0e1bc727d3622ac5ee3c6b87ea6e311b2869a838855f947b91787eb5429c621c4dbee1f8809eb1f4e16bb345e5cb8c61a3bc6e7aef2cacef2ec3d65afa23bb62f829e43b7ec65de724a62c525c47eac5159307898a125a642d50a3b6b4594b25fffe2f1007f09a47d49214ea2c0d2c2dcb6f8e414c043996950b9d36be53f96b33c26cc760c46eafb0150a9c7d6ac59a83464dee0378e9fb5fee9b8762523c9345f26a6c3e341112b4fadc1deb69de8f0a22305e303da5857af48c4f623548d4168fdab23af9168b807b65287f756d412dc3522f801f7a9a2bce4657a5061bf111347782935394ac147995118d754a33a6154098e20f9f2e633565a75e909163e203e1de0ba9dd74391761985942b50c34ed5c269d44d943f3cb6f931e917bf1999a6bffde7e28859973c236640b9944c7ee1000dffc8fbdda3395724a696bd244710f21667379820b6dc0de3241fa70cadd1f4971a2d990fd140104127c82967c029b8f036f029f666b6da36078fe251eee239a8bd1250c5308c1a342e4189a305247a1cd367881f1ce588eb12c0dabf3cc908bf68c4b8206b3785bcb068529f750305eb448fccc313684aa1d5791060f3340dffe1f998da1b4df52697d3284beccb7708ac11825909c29f18842b95cf4019793db0eebda78eb9521021cd61264a6f66b204dc98b91acdedd3eefe29a4ff4793afd253c5cb4549b40f5fb24479ec18902124cf8c7d43e447f211ca36bc9a96683145584a25a8d4d98e50d50b6907b1f45ac899c41fb5dd3b6f5e2da19c26bec470c8afd5c47ab5110cb8de1132e72adab90210299855ec550941686da09a70bf58208c68badfe04390e1640e24fac71fc53568c02fd03f1036679280ac41459f2b6f37aa8816e129e043c276e2f0b496534af6493d5addda1c2b5c610873d976ce9564d7141ec5e7718d1978eb356759e356a61fbdc46eaeee2d43eaa0a62eac8b0a969b2625d9fdaa4b873448939af524ee5f3ec3e5d52faa23fc9681d7366cd726934c7a6e11c8cf344047571f305c7349c4ab3ca1efd189a6f2be7600522f2e5ae57612ecdc5220d2ede9c9b7fb2f3e7d1a082102db2927f699b3c8325d23625579f6edde7b89e5da2f60c26a11eeb4323e4816b6e0997a42eaa84e426c464516ea331fb382a6a14a86805fafbe679c22e0d1a995bedf2f8a50b9a611bc0ac12ac4adc6e500964dda431b4f3ff5d15fb6cecea19a5d11b820dd832295e51cc85a849f4a1c05bf1e2f8984f22a4e3ac8383d116435448f2fa0464799729dc2658496b7620d29d333db1319a213cf817afdb49bb0f9daf100e2ce6a176d7166029fb5a310dc3d80fcf4cbfffe8ebf7e6fb51c6ea1b99668b4a803e8130391097cf1853aa2278b129c1777ad7565fa7bc8d3b9f39ee24cac442593e7f80c374e2c49de4077fe9a39117616e08f8c6d2729fc66bdfe294146c43baa270ef268d2cbb9765bb3544ce9c71c7893d9c26d6996e69207cbcb36b88a31b15cb631119096a89b4b726afddcfbae1e94b52e9717d937bb0aa6dc0e8f2a97a34be4009b38d5e16547a54d49681ac0116d0992c028f0eedf8b1f53866af7b64473062d707bfaeb91a48da1f68cee06b5d3bdb58f956f5cf833d8d21d1e8799d1b9de7af3d71e3e96f5b667cb66dc27a0c3d6da1f6ea3c717bc107f005883c9a1e1eb0ac7b16ca012ec7f2d6444d3a611ac9ef59eaab4663eba3b57fe54a5e29aa314a212ac52dfc32230a3c4fec66aad070587bb7c8e2df25471821fbe8ef29ecf0d51d8696aff6aa2c6c2836d4b42036015bf5328943648c6cf8ae990475bb0486705c5b9da978e8460404b453968d849534a458b6599387d7d258375925fdda2e2ff79ed05e62dd6dd8d5f3f32e1d2a2fb7370dd5eb5c2562291e7cb7ec92841c88682bb522b69cd741673331d5815df12c6bfdd7f0496cb77a386c4df060f74b40c39e7b8d71821b005b6e8d7092ea30015c0eafa6aae44fd0eccdb56c47489ebc60862b20ef3c34120ad717284839655682a1ee161c63ca58440eb8e82f53cf286944f6ff8a61b3d3087ca7c1e74ed8f177967fb55a43fd5b24c04811cd655b2a50072078926924ca37598a7895ee48925424f82d0af561d746c73043e1bf8e6bae20811b520cda1a73227e2aa1941af48dac32b0ed6556a1f50d57916e3f969fc7e5180fdb0bd4ca1b9e1b9c6c3d5141e82f20b5ecdac90e789732c290ee8fae672b92385f7e8414509fe175082971eee29665a8e89e3d215314844aad5bcb6d9a250d9f5e1cee319706a96e3ec613777a733b4e300d60394a8aa1e5c09a72e94495f08608f542684dde6143bafc30ee58a8c3f04aa96c1e49209a2597bd5954b0917237d47792c1abc2026ed6bd9619ae4390b083d96c4de686e723cfe7b7a3c7e3f32020e63c5e3890edc3d6155cc25a06ea9bb87df72cd8446a96fb6ef67d2ebc5345885020308c4317ca62d41c66d8a112c751737d27f79ced15d260c1180d4d94d710bc6d10b43b24c61b11ef7310f45a5e39dd502ed448702b5546c8ca3ed273fdf6d7d98709704e9c3394269c6380ee0507781201dd079ff098e03e461f65460f6881c49d33e14f79d18242f76ced27efdb7ef8b0bc1bde27c7255bd55dcb7ffaed030cb31d35a283405c22812a3b7b08c4224f95c577f4c20906c7b6fee5e0c69b1684d27e718279e2314710bb91acc1fd0b521351764ea214fe4d46fb695b0f5a0a86c85e881af290b08b7b0855941e2c97e7848ef28d48679077907444a9acc385403e12202e1aaa5f46c54ca334774a7b1d0ae7b41f50938ae2a8b704be56c0686fac983880cd4a00f3f38b7c1d40a15234830f9338a2ce5bef0ad9ef62dbcbcf7fd03a088686aae70ad4f1739bc5885518a9ba8c1ab2824cbea7d10663737ca5c86403908d761a142e37e583dc23de5fd3751bc0de336a588c8b80cdff66262add31c101171675660589207777dde7c2263bfb58eba2179032eb73c1e515ef0776e05a2908ef89b6debb755a258d761b5a7038422dba93938191e719a7a05a6061781b545403bb459fd312994762a5dffee1658395010d3ba97c5b2dd8d9de73b14c38d7346e9d90c8c0d71855c7af709af97b644e1572f34d2d6bd422c1b3ed8d07304a11b9ecc3657b0b75c2762ba8db0d5f743dca29b2a16a7bd63785c8aab7831532a06f4de1f161fe31fe30974a09bd2b7e89431c4d44e0995a1490238afb7778308373fdf91f316bacadf5369ce232a6b3721ec389bc8f7c55146608ba5b008a0da33941851b4b38974a97983790f181850d8c19f187d797c4a93543716b97d4206e5ea591ea1975d98e8b5db7c78f2a1482025dd98551dea60b6e5ea2ae484475f35833a2b0b11fba7b08cdaa9d3f42caa52b00e83bd2babf8caa22ab1ceb27193b460e43b26841500790703d83cb3c6d2719c7c579232e40e0718d29ba02ade5d296f908bb584f5ae7b898f582eec72d59621b37d80877fad7e411fa2809af712f31b00ac4370fba22dfe527e0b40b28c9a141d27e015385514ae16b246528ae6a42802317dea16bdba46d1fd9b883b305d28698a67adfa329a3c058cc88c60105c9f4e9146f35323db7fa957e007a2ef39e96b2fe810e05c0829fd1d2201f98e7119c6efeacd828aac3d2b74753e154edb297b48c6c27b07bfa5ff35ada39c34f736ecced5c737e4e387d88f80dd913cdebd82cd79b8aab7a1b37c556d19d25f6b44adad7c23d12eade1fec8f1ca2bdf5acc002d33dc5716303d7a928a92cc02a90fb5f57e483066c60fe71739b81234169bc5f2f19211f08abf987b38a36415a6c9eac1e52a3c0a5f339fa5965548367f434d32e332a2106af3d5b0436cea3c70d8178f971f249c62d6650afcf5e7209c5a799abaf3ce5ede612b0f481d0edebec15c2c6039c5e7b10db0c3ba83c2e30f01051452041163b1fd9ff9ba50949d39b396ac7b5436e47b68b3ced0e00e7b035fc5172e6fb054ee0087bc11532620e84dfa08b1da116a0cad52adcdbf96f27db6cf95d89c7f3e62855b25e8decdeb7ea5725b937b9519c05c16d07777f71b5d44d5cba96525147391e5d3b4799b1b8759ca2ad120bbe0d9eaf0a680a87cb9fd29e4e93f60c0d0cf377844d8e674c5a64d6f24b295b9dff609c14b1ba826918f9b1c5506b851330097d421bf3fc50ecede76768e40b26a129b8633c50850b34de8929c20512c5efdf955a3e0ff66bcdd294472841914d08df88f93bf4350d4c5b29831b20dafc1a5ff7215c887dbcdafbf9fbd0ae0f40cae12eafabfbab2877f95dd6f05f72a3bbe1ceaddeb2ea77094969e8a5acb8b9c65c5ee415a587b7c8f4fe160c1dbceac670c5a30f95d040176cc39c9ef6bce7d350a303b0bce787fec0aabae14f843c6bc07068e8e983d5fa20c68bbb1a47d48e4fb15a1e020cceb2339461c1695b0818270129e386b4c3d805ae031e43fc5e9ebf763c6c7dc45271402ee4c564f8be93f91ed02f11e1e1e6bac851f543c1f2d994cdd3296dfcbaa081a6d92f687229699711aa9517c2108598e5212c51d203dabb27ea3c0107771dae7ce080472e4feb3444b261657646f6b733de46b1263706a2214f5714452323f7b87bdb35a42877a52cc7d707a1abed47aeff89c34eebae6e9c78518d82f9a74a74034feaa061bd68e2e85530a024e0dd7f532b4635ba65999d08ab58573e2f46d8fe1a124b3c75c164232ab04ef440003181cbd7919584ec96bab7e277dd8a34724f80fff63eb63e7a593fb6daa826e1c81fddeb636a19e05eb5cbda8fa994e3b31e7116aa1a80a773c3d6c85a11363ef2fafdbf9efc5739f19089e1b22609bdd157221a0a8384aa2c0b013bb56563404504e42cef4850b0eed078627c21af2504d9a42b6aa20ef00beeee7deb05d9f98633dae2e0029f6229bab9dd9ef3ea6a473266475c2364d20b07b9d400ddb85d5022663126fe7bcecd2aae632f81aa9918de6ea17fae7b61e7da572f6be6555a52984e9c3c792d974e8334dea4cfe6394d815b7850bd57da281c2170a3096b0f75e12cd4bb9595915de37d9139e8183b36bf40c6390e3b4e614400b35169e6d6cc2d470e7a8576099644c58f61d0e292fd4668df7311a76426f4a2fdc4afaf64cf33372d064f46cae99aadea62f18cadea4b473f3bd8d7316531a34bca1d8c00a5890ae6bbdb692cf99f9ca0d09f1af5ff1fb69112347afc7e9738e523d1bb639822ef7c3bc8f87f31560815f98fb2bdddb9708ff11dbcaec2c296d0b39ab491ca9e76ef20497b0221d79b6c24a029ceb450d9d3c7050104ec6c365700b1ad00ee76627928ad2a2ba670526667f1f824679a719eac6b8dfbf2145226148885023a6b394d194d445581d97951076112a59290b1655d1e8e3d31b742d938b89da028f97c66aca338c1e55dd6752ccf3aa3639575d26741c058cfcdcf83f16e3a21a7ba628274d472e564ec5c4cdf5d564c54af49b8b82e9cd7ecceae9abe8052c44f7978a59e9c7232ff746acb9105d6c2b3bc903511c118962ce2d44f020c9fe0911730d71477f86052a3ab5baf279d88d9655d8ff5cb05882ebf1d0398925d869718f5515be17f243117ed374e238ed9a7e24a8f41ed6ad1e36e6d171d9453e34a7bf0279ed86dfccc8dae07cf865e8faef04a9b94023552df3d81742bb02cf0aae2565d46280e31d91f59c4b0f50dfc72720a959625dd42806f13d8fb1fe354590b61d539d8d64bb91aa2d26ade719054852115a3793001974517513eb4d8150c837b32cbcfa2a2792533ff015ea846a5c446fe82cfcfce97d2976783ca501720912181fd402fb3c9042856b72a5e96e802b6f685e7ddda646789c16388e7f42b0f30270e85e8406fbe8edd85692bf2d3140fa6a038ec9a7af4e45f92962f777cd638872f8db05bdaa426044c2e45806b21f67b2fe1c6d3f2ae159c608d870af40a9b7a8af3f8ba63d8c68bf867ed97e5315cafe5fbe7f4a661e3688a1290bf3ca41224e97e48d2b64a8963ba5fdc6807eeedd2de5eb8388087695dc8d3f83583a2bfed2225f5d8bb5814d8f16de96ad52302f12b772faf10b8a49fba1a5459aed00582de485e09fb13ea2d49a071e3ad165f67155240204cffd4a7362f90f497893c9d5c11de54781798ef5482a9e7ad40c05022ff95173be8a03d3a4167271acf0895984db1f56185b6c83bbfa06a7bbb5ecd4275098b84b728199e256c2a61911192e64ce5d8490f2d18579e94e025011d828ca595685bcfc13851c285b56a5b8c7c80ed1fc10f5ececbe8625b1eb8ea225165e302e52d8f5b1e85c874ffee3ccb0828c800274ee97192c76b3027367be1cccf617f222ec988ed4e685972731391fa4f535a302d7defbd4c823eb68b483d9707641b93e31e29b75c54134c9d860a0c29914fedc4ca67da44103fc81d4d0c7709148be62b2193691c48fa3b3a9394a065ccbdcbf7021fcb186bd40040b9f2fbbd990b3d7a792d098a068c8a168b3dcd5cd058b6d1071b9da41c73cdabd7971e999d18906e4546dba1f8e9b40fb4bb81ed332a52e4f83bbf1f6a8d7f70612049dad5d7307b7687a5a026f34a698ddffb4d5654b48a821b14b0ec48ce446f1be844a4833e4a85d360ae3aa1da851046a2d9bf1d1be4aa274a312820753f9c947008bcddb3ea9bdbba65b5a4530965ac3d8bf0615b25e2b66917b5b4ea955e121f925cc92c1620839fb627839eb260adbb80d89fc123d61ef73706f2fea5498ea24f5fefed50a27ae5cf8fbbaabdb324b2b2adee45f3c622dbb42b3483cefe45da689adf3173ef2af3c397a0dfb2395f995358b75fd2cc9121dfb2e9a02bd4dcd995038dec97f30f366e312f01f137a3e0dcab3f34bcc5e6193ad04c7376d84bd12b992fc0195d7290e4269c443b48ed7590c7925769445088f4e7f8ea35a2984f1a33bfc5c08c3b4197267c9f34dd326389c76a9a8b5a391c7a4b7e7116656634ff6a3ea6bc68670798561651e9717f9ac36fc787569c0756f193bde92b49940d6f97b97e53226a0c3716e7b5f782c4aaf8304993e9edc24254c82770ed272ee3d11ee8fc1d92721563806ae4654e463f6919f4f79fde9a21a5ca2c5cfcc18db39de9b1efeee35b128c2a3f5fb9526c465ac7a0b7656da9b29057083ec45ed01484a7c95ae7162013d5eb077b0790cc69c84f68da662ef30f4d2b2d853fae9633407259c9be5d4552630d84d34f1cd8d22c01c2f08b79433dbb9db08603dbbed281d4f7dd9c5f02022a2b6c62efce4280342d509bf6ea2752112b192790c64daefab52a1e0e5f6c243b81243c20c6e90ea38bfb1085dea3878d233f2853d30507a5fe2b9fbca2c6054a22920cbce56028e4b337b373d68f453e6d41f8ff4f832d417103969e94d60aac448aef85e10537231216d339b965be5fa4ed62a01ff9b8b914957f98b407f60aa4727ac59a13933160f0ef3dc2d0a9adae3d0c2b404f79d429a38a9ca150043a253ebde910a0400cd48a405a39c7fb38dc2c08a6b9fea2a00e351b38ed439eec1abf9bc790dd99ece6cb7f2c42cbc96b935ddd5144348b97c140722fe4f074babad48644c2147acddcd3182176ac792fe135bd77cf0970da328de63d2a96fbc812b6811c1e46f01c16a670d4c99f01daae894aa8b5425eb69eedb9ad5a3a1edbe901fa8b3999022e351762c4b66f1c259cb84b33ca7d4348873e2b9896061e5f2debedbb1d8b34b1d506676068030435e3511223e41608e587c62c2bf644215350d5791f4316c1d1c4d60dcce6bf20bc98d85ccfafdd0792b0b8502b26c94110b74fd59e50aa0ca8341cf29edeaa002aa4b05805797dda2747dd35970266e9718702f35856c070d2e1103ca87130c26791550531d2d915ebb7036833c99d5f122ec6d96fbbe15d8034a0c28548b7954de9d5e7d9c97a4db637748dfa2409f3169769d100ce8c9e6b19fb84d4ac7b3ada28d74cf5540cb74626b04c877f96bd60ae589aca683e13872ca64fd001922e6f43a266b0ce46381a8c683bf4a06a721bba63b4d0078d08ffd459ec97ebefcd5ad41bb676755e4cab70140565253ae5984ca4e1f7dae087bd627ef255a17fc9b15f7278751900bd04a885a3ccf26edd2761b30c77a5811f5e6e1165432ed7186a6b1bc15c0b2db6e0f25924c7d4755f2cf61559f8f9688da5f8bd5e7d1ad62fd2ad0e236fcbb8ce3724d8a8cbf4b1d948a80ba60b648471cfe6159ac4f2a2ee00651466881bac22c4b244eb9d4681166c19bd98b12ce3b0596135382ef3f0f9968526dfb24dff02365094837960231565d7ba446b2ebc16b62fd2f3c3cdb615b73104cff8e68eccecbde2b8d38faa4856a342d9a23c0e3c5e44503a4d54225121e9023d0cd7968e9c5563435f83eadc3a0a4b7c9ba219791904551bf92e7cb192eaf15119ca53143ab750f17764dbf31d8effbaae2986817af54ead9eca85020b71658521fce1e8018a35ef53306b3a27e592c62eb0b05b63071bdd19871585fb0ec7247d35d03d2695f96c64d3ecd97c821717fb71a17ab35225f98e8e5e4a6c9a44e1f1a2dd169e2c3a2ce99d2338b3de407f01c1e7a40f1911054a81986f7377ca7b46859bd91a5dc45803fc4ff07ea34bb0df31e033e2b0ead2e1f39c2307ee1f242fe08f71e34dfa7cb735e98b7d45755052b3abdc97a8361bb398cb949de9f72044e2226fcc308de7f4e2462142a8064787d85fe6366a0a16528694f23ab1964027df0306b8939a5119885e6331e5b73b37f8b707cf63ec0c08d5320d5f4306edffe280ade5d13618a7a38c6494212f148f4156a5d5c17be9f2171ba8eb02cbe645704d87a3993a487bb0a9c0d14c29fd6821fd00ed25b93b13c5041a87eb55a0dc33d074a93cd5a0983b862c6e70abbcc9965a31cd4497692df1f8feb693c6d31b739c81da09e7e9ce09dc5a7c87b59e48360f093609b480c0ac389e64857341c3fa5c3c830b7f3c8ea5a30d4d242f0d67dfd609e4277219cd1d2e3011d0298be5accc79e872fb1effadeec8b43abf0b92d83be2b4ea6b262e5684fdc8ea3c72f46e66d4805a891723edc9af3fe119d42f4471300fa234e27ea52f50b94dfcea7c13503178b5f40c95124b5803af2aff9dfa235104f75caab3c3262c8bd54acc0c57a0d885f62ca2bde9f3c55a550f46c49480471e7b680ad1f6982a9737a875682df277d05466ded7f758aa90fbb82f7c507aed2740003d2b867a851e38e476a05f43928ffe9747e2238aa190d2c7cba2b8f1ea88c4c1125c04dfc2fb8ccf63e4d71b17361072c08c96a732d3ec4c027e813d301a26862819b9dc3ceaf1efa4f8b7aa4fd28fffd0d03249fb96d28299bc60149a6d9238c14fa644ac931522cb9cd4cc3d4d653a8daa1149135c8c17a0e57bab0108630001c58c37b50c19f8472a6bd26dcfac3874574ff61012859c0c980bcda60c966118d8e9c68f3ba788d2155c8731ac6c12bf5f9990c01badb9d11524c6f9a406be9a1a3d0c6a2e8dc7f23c61d09d418edd3354bf4b84ebfbb87a9bf4e8c8476e7db3751f243805434a10170ea8b1b810e3695283c1afceb865ceebd5a5c5202e1f5f962c7a2f7f902dffbe76ef62637f3f94a1bd96730a30b83a8f00b44edfa6eea648ae0cbed292e4960b3aa654708fe9a710bde646296cd1faaea7cf878aac5b8e68c4b52287ed6c1cd936cc9b893fa1fcfbd2474324b43d4bd3af630b222f675ed6b2cfa1baf0f00a9cc17f2316593a36d4fc33fdabd1928a82c0f779037a4f22c3cd5f797f937a8e1653fc07d873bbc479fb86fc56cc64aa5edbe9df6321e149cd3961a35b37ccb400c8c8874e32ee20f485be1f329eda8ef8094944eccb42bfe11c88f898e7f4b83db444112265b4241f81f713285b9104222d16b36ba7be2acedcbaba47a9cf4ff70086516a600f756e8ab626fb47fa323ba90f982ab5dac616158472ce22edcc8f3c07c22153722c1e764707133bfd6334916866e5bdf1c77f5be89e0d26616b4791edea89a8193d926f6d613708edc4b28b169078264fe2aa236aac457ea117c168e62a294f1344b7c53bc2d4d27e9dd526a253537e8d9cceaf97b0fa37b499b9d9ec5dc77a11401ea65211eddf1d047ed50a0b8b83ae249617e5a2e94f675a9093dae4a6f2cdef85dad1ef7103342bd64b97fe64a00ae022850446b053ac20205a8b7b2df7528e526545e8a836f50f054734f796d389d47b6265a44540fb53af09d347de6c8abdbf022fe89ce2a60cb486ec2365eee6d0f1a5c050b097e3a29b2480b618ebf165a1ca1dc0764a16f07833bbd077d9e30bb7f4682a6d65e477bcd3f0914d2cde45c83b128737af1edd82ec0638a9317ea92d3d721470ba0a974f751b5a9246649a77a4fb12342cbbcab6b36f307c34d485c2c64dc8ffb38a85e55240e430561d2ce2cf4bc9cb1969fa0203f4ce70bb45e4be57cb259b52a23f3cd57e3825fb4b393401f97037bf82eb0848eff05720a13cdef64c237874409a89dd533742abecf95a317ffa95eeaa0c22da84eda214e1c4671fa0d8644529150e43f9a40a97fd3c78e6f813d4e98c95af51ef5624838f22263bf378c9001e8a38e24b011821b65043bc43594e5cd173adb8af623151c27afe6a7054903cbf5d68f7795f62c71fdce65a403239ff897385d7842c846c9ca5d78604567e11b66ea12b76650dcbf1719893c156f46ad616527a68b8c83c608d002015aee79e6a7859a59d2e8027537a65945d8585d0ecbe895e1e5459bf1ad487c68f8e09539adbe6130bac5484adce5f9acf16239e325b4cbaa0e2e32f2e4d2661029081006cf15b130392aa57629022f14d25633e8846c5784b8422418a295c8898d1b774ce2831b2ec8deda992e08da319633fe68b220ad0b7b2476b05493ff2ee96aa6cfa71bec05766cbbb8e5981c9db28f4cecd16885f19b92ec8b48890d3ff92ebb250411371efea5d2d6fe692b7082e0dfb09d0e8933ff1ad03c615a993e9cea4687b5c969b870825b75b12b4c8adf71b88f73fdcdd5b8d26137ab6c698922199a6f0ffe653896c7ed2ccda1ec6b245bf47d3a6e04e88d828a820de5ab3e48100e022cccf88f4a9d8e67ca377a3cbbcbec39310b7202d4caf98c2d215d445b09e43798fe4adeb89aa75fd517e87ad12af96981cdec0a8fa6db2ab0e07d261207e5810c0a15137e8d0d920c03790be43c5ab207a6b51d7c4a708948e848d59d39267761322232eb26d6fc68671349c3becba92e509a581633bbfbb957f4106bba083133676bb99379dc1c6cd4c56ecd05be70cdd4bdc2a9bc0744723feea9a2b9ed386a7018d25a6b5a8b597522d257f18358dd866f743e8e91ed9a29938d5fc24682b829490f3c9cec66ceef5e45a2de8957b13c29403642d3dafed243eec51dcedda71134b37b6a5c88b633660026fd4db0f77fdc3a2b82a909336383726db95a6c18192cf1c6307b6c506553ef8d65dd223be9f021af3173fc7a9029c06a1da869f4f82848c5db935e9d0c8ad4c297017b01b266bba38aec6bb47877fd531d7cb6bd8ac5b1de44f5832b9271003942c810bd444121770af25ae636fb75afac84676d03341133ae2283420cd2e3e9757800c42acbc173eefd29d92c9be684d2f13f4596e25e55620ae47832612e69e06ab24bd31fcbde833b5ca7e4d8cea023e5f8ce158c07964de8e9dd44c73faa19bcf52365f52279bd904946293a20f0814333b7af08b0332917bbad7e4e7fb262c09c7353754f221465965e643b1fc8c49164c7589dd9fcd8440bf4666268b47c87bf8c60c7cf4187f28006668bb5a89fd3034587c2f3a58194121501b05e4ff69ac0aec4cda3b4cea65fa64998422024aa345df5fd9cbf1c3ee57e2deb20c36d078bc11d4d3d6127a6e7c71772afa6c6b71688e13f87001f897230ceabeeebbee0b83a62e32aeee2ebddd75d61416b71fa5603fe7aa0bcb3f1ca845d9c8fd2a9fef3486db315353d523289ef4f21ee7db5420b160a3b6671e99f4df82b8c11474ac8428dea3d2e7e8e3c9be532f6b8a88498e9eebe9d5d458254cffbba937f6a3819310a153dfebf303c6c7c43d7010bb549721ca4ffe5138384aa19da580fa9426de8e5c956194037945a4de567e5a24ef2f3973b220a00c80e5030e2549ed30105c83391c8f75c0eb2dded1451833610515641b29595265860fe011ca87d46260819a24670459fe2e22f9bd331b61efee94c50062a1ca39b4bb47fb8c3ed243d2ba6c916154d19495cc9fcc7b2a1129b511a1c987b4e74e4e5e68c886858e099c49b93f1de1af2a3a2c785f353f662b749f13fab978e09143ddb9cbbc797eae339965efb69526d7c9ca4e1363e2049148851510a6cfaa5f87827f4a9ea4e86ed86a5ff598a846498fe6b11da0f5edafc4edfaa45418af33075254ff4776fa4372501b33eac899be3376dea792279c2ec8f4bca35cde0486e64aa5f54c57a20a151d11ed57b086989a8b6c7cd2b6107399ae6bc7c286cdc5c7497dc7b1ee86be45a883a3f20be9c34c1df60f8d768fdf216983acb3726146e0d7aa3f1b256497d39b3b9362e4ed0b3e8d3d0d05bb88b1357371c26255b1373115b22a32f0776c88f9cf68bf1cb2df9db0423cd154eb7d03f3381b5071606f738a34c80f9543caec4290f7a20830339c5ce471bbf92e9af237d5aaf612fb57270563350566b55573fc646eb3b14be87822eb9b77fc40ce18f7e9e3a0dab0fcb0c42ba966623027e5132881b472f2e167cc7a99a77db65d4ef9d0e3c5b284e663cdbb221db838f5794bf1ab68abbe1d3f1088fa30339d2b7f18cc246c5c91cf47fb5c127d4d64a45365983b6417fdbf44cb242d6c0ac27f3297ec3961fad148f28d6a3e3487fb6d05628f0ec9fce8d9fc43e611b2ea7c9b31281a688036aa80393a3ac1f1fea5769965533d9ba5f185b1a3b245490037b050fd004de3ff589fc785724a7a110ca5232067dae2a354cc10765fdea62cdae5cddbdd585b78a33efe462dafad3df09625ce378838d8f355fb69fe65372744d49647b6d189f0e4eb4ab00a7c31d1a0e734ee3ddd3dd89bafd43abc1c06255e420a9c48433e9938e5c3c212842d3985746e1d58f6ee11b79a645a58e6927a71293a1063883244ac4d10726d30d3f385fe0587dc686302bcdb34eff68bd77de4fa9d5636cac54bd9d6098fce99400d6180228102cd7c7481670a832f257c8c8882b4baafa998bcd24d61591c0322080b8f67b725c9b67ace3c14d88f852f97fe0ff6d4ab7f43af5f40f01ad53988cefeb6b027ee276af67540825743a23ef3f36bb2b60124fdcd0775a2c75ab7d98d411bcddb9f18b69ff7513712d29a1a6690bebfff27ddcbf45ae48117fa8a4000b5858a566caa869e98d5ec170348b9776ee7966c9118a64a8f17127eb4518f49b65d37d423e6a25c88696a591c92e11f3de2faf9a1d65f3126446d63b78a0f86d3aba3e7e7143571ae0bbe967caadde062e5fff62a6e105cdb1310667bd806c4201bd048982da532e14682a79c644159faa3a8b76d1afcd1fc2782cdf11d16e88ec6db7930ac3e2e1d4d4ba60cd2daafcad54dec542537099ab8c9d4157e834a3f9442f424380f80d8b474e1e1b5fc4fab84f62ff8c83332161327a9988954e7a250d7ace0420717ce86cb018347c027396e7c228a7cc99ea4768fe1815f9f7a15fa9f5e9eaef501f32442bfc887e7a00c1c1ee3bbf780d826383002aa2d501871181cf1e8a8aad09c93ec5a0e798a5aebd07018adf7f9261b84494dd20da4e55ec02c767e1a5296b7f68d3a935d878bb51a90e95677fc75c9aa645d45429f0c2f5a58132f9c770481299116b5694fc8498871a5462f337b0dc438fdd398b37688fb65b592357b499eee7edc716545fcdfd9a2dd5a5586375704c08cc0d50fd35ed9c462c04caa125249fe6bb11ac83a46a60e19704e566325780f3ebfc808f696f99bad0f0558f0b17bed93b1b3925ba50436bc13089c7fd52b2fd946348277393865ca868dc48e9adac5645f035b12a22e081b08422c14cfd44f39dad2c174c59d3cba82a1f9bad4c45ff18612feb6829212eb009962987aa6e1c76c8b096867c935e676cc1a65a6f4e73a283e7801750f3336c882b6d1ad0970d624a31a791c7bad434ea5aab1ff4f10f60b2883e713c2655d19ab0c037843d18974dbe0c200500eb1a2f96f2568c000d513f5938152df266228513884fd9a95fe88e3cb5d74fb8f523e0810fff67952f2141b557833da381b86d9487e1e8515a96f765dc92c5c626dcc12ea2d71c13edf0c4e42247d93f6c982017c038a880dcb8b1b7c5b3e6a9c60aa9380be7fbc8ae5f9b12754d33fae6073d0595cd496be4c4cab06e9c496dba3c99ac9c0764e9a512b4c9713d5bbf7928845db3bd865777421b4f11825498e46606ca0c1549930d86fc18c9912579394b29aea33a47f4052ae70517008367c34680b57f4c1ac0e82eb6094af5c4189893e77a136a6ad4be0e33fc07978831b1e1bd4e546bb7db3a50d3d228a5a9c2d27f65794c7787652cac1358e0c3cdfe5cc91d1757402062f2f1a24e0ebfe944e38066df1326b2254a26f99a3f8b4f48bd8fa8b3edc2d8fc050ea531dfc6b2734aff023ef9b957f538dd6ca059ef64e6a8a9f0a0083686a7320b57903e7416489e56c1449d42eb67cd7f21a1c6aa4a5745458bf2d5bafbeab0c2dc61ab2038afe14b1062a6537da9d179419eebab10fb5b7502abd6d4e7930789bf180bcfbfd74efe9c52469b49e5f9a46c392d60c3279686bbf91dd10b7654ad073d2a6798bfe74b81cd187f7e966d7cb043710c9f562b52fa6bc6a4eef791ce7e3d4669a0865c4cb2944a798c6e8fcbacc683b073b3b17bd0919e4ab153a7ddcdd4996a2c088db9fc3e5815a6d325cb43506dfb51d91f70e2374c153da3b552c4e2a6c411b2ae06bffc88d5fb21bf26d9489ebd3eb85e5d9df4ea734387d6ac7ec472fb04b8c6340d47673ac933efd517b9a2224f9ada9d04d77790fcf39cf5712443db8bc067fe4b6be18a669cb7dca716d26e5f36c2884a682d6f81bb1be90fe3c85015b2e3c66b612e182427272c2b2d371ea18143e6513c56cb9a94fb1c79f9e729a52dc789c7611f777fa8fb3aaf1fdeab6ae4d36cd3e1e3f033110fc6224006becfea861982b2706183f684de70dcaf81a17dfe14d27b132d9dfad1495827d24200dbd5e02126ea773f80d25669aa31282aaaa53bcff974124b5d401aca83affd1675b7c0902e412254ed9d4b864d13d6d9b3160fcd3535b3255ccf376f875d66828dcfed05b437444f830169629f31365ca0df5ffaf89ffc6ace2aefd720caeabc9e3476cd7d98c839e8358c36a4481bca8fe4971efb1e175812c2930b0f9701c1f558918bb7c9099bf3de9c4f9852c4ad1e4591a68e21c520944102ea4b727df9d3cf144e6da9dbfb50c154f25f9233bba87432ba687fafb002325a371913e6c8dbe35bfa84db8e40974a20bd4b225d841aa1ff1b84da63368a864d0fb85815532e5d9087314d306c7d41fc4a87c3114d1479dfc607b3a6d13a60d1264b62335c03910d70378bafbced2e5320bacb0b2476e14aed2af18c7ebc6984a4e09ce65b75512e0dd8a9696e1a326e8a8dd1cf21174f6d2a4fd1902328771d57bf7f58f1303011246f206d9d4172fccc3f128d68755f4291c9dba5dd51de6b03df80599c5cd53e81cdab2891bfce2507acaccc3cf0dd1d28e9eabe18059db4e8a306a5731b48302feac33023a2ef8c6e70d56b82ec352cd188fc71c117fc8591337f6ef59cdcbb78b2939d9eba7921c6ddc700e6fc5dc2ff1ca32dc3347891a467c9105978f3151eda050aaf7e950912b469fff18c8f9c9f9f268653e3980d8eff73528b95166dc4d1db7dc803ea7837fdfdae9164a461d2914fd881ad7e2ecd60650dc1b0117327b7248d79ff2ffb16da7f98a41b8eda2e0093f939a204ecc1071a6881b3e56eecab1064578391ebc7f03016798f5ebda0ea6dd10945bc422b8fbc6d7ee6837d360590ba35434dccb01ac4347aeaed0f343b66377a4754f097938c21e1ae36dc9d86cc2cd91abe95e6883b06730b336ba0c8e52f7df41ec598c0a4113d6acb80619f62cc5d9deb57bc71559ac4680e7d5398e390e97c28e917e0ec740100ad27b7ce79d02f1ea7fa2442935df4a98c20c24b06a38d03637f8e601e6a65344b0037ee72343121a48c3734ce697325d2c2ebda6cb4ea2b6d71ce71d1f93a8e412d197422c3ef8fa9739d8d88e52634adeecb6c311e1a765b9592c0068674c1f143877671a052016266559af2b23d40035607dda7034198f1aa5359286ddc97006eec006990c304fb8d877ce6cfa719a3f35f8095520e54c1b91bd398e70357008da7b7385c79a43011a51ab18ef2711e7e38b53c804b51dd59b76358756a119a00f35d67ed97af5ec0ed907a60eea8c2c3a7cd458ca4b4e386321dc4d43653e6e088d1bf5553923821a3b3598a94165352bea82aa797a1083502ae89302c5b331de3b19f0fbc5f70a0fe0b1ce1e6a8f38aad0ff77e93d644addfe6342f74bc67cda3e8c139eb16c82922e907d80f81c519365e80c177ae1af07d4ff59778875bcb3b096e92a7ad040bb061ddcc5f900c87b2a350d8c9564d474bb0e0b493cb5a88c4e90c736dd5e7b3d37770a4034b07ec4a55b6be5fae804bfebb19f04b0044943a8c2a657b16658881ec0f73bfbdf594e6d07667466524fba3b772c2f089d468c9db0f223b491587bfc509f6dd9bd3dc19ae55992e97d0c3178aa792cbeae82b9cadc9b97d8069acd0fde1415695244c056ceb37d50930210d1e0df66e5e10d976a8e02275c0b65b612f849b6631b40b909bd11d525d0fb6dee6906485369c9a4b8d7374a37427731d341512840015c5972252d4bec1f375c76e97440fe5fc16ba677a53d66ab54e13fe585625ad85f73c1c2ded6a64fe944390b243f745dd64e9a5db4307e3170946317c1e153b5ab7a0b0ca0f7c5e747ccc2234851807af9ab38e25621cf08f2858205c9d8f3ff058a33b43fc1d0025e68279762702da23c389e19c87cf9ea2e6201df37769ebfe5b1f1b7ea17ed1cdcb5e3537c57f8ce1a5f5b84f039c5b992097311415968c99ab9e5be2c469eeb9647ee0d04bbfef294c56d963651aed52744d74528d8842fbef5ba5a1f4c0bb9685c52207ad2d4ed2985004f4ed1298d1b1cca04952beefe5be26d5e1953dd81d888baef1aac824629ef335b8e1dad72d0411e2a679b8e84455786e462e08a1047c68d785f6476c31030724d54f1402136bb2354dc1e60246e4904b3dcf2b8100c8c0ba6bf84aff3f345983674a5343174c264c3be128c47c6ef3789834d18df17e7cb15e363953b4bf1a50cba51fade350fed9a4d351f1168a899450d5fd70fe5c51f01c6bac01bdf62bbe5f6aebcde9a4b33c1ef4d7951b718275fdb310e4a6e8c3ec5477cb78fc4fb5ee3d27dd5e29131e4b13e514a538b7910dfa158bac7a043ce2c19351347f3e27dc3fbde10b56768cb82347b1dda1d9a7ba6e5252803f78b887de7c659f93366f24219f4453c7a8ee6f2aadbaed60b3509ae24ce692efe8c37be12800f34769095b68dc6058bdb4415e69428cdf22678e2713a9baafb027a42a8d0cd4390530f0ecce4ec02ab33cbccbb151bb35b0fde15342c59e299ba90b1e5507c01d855f7a187f095bfebe86cf52e825833df044f7d519248edbdb8515aaf50981bbbb987619d26f97c35248dacd21b16248998deb14ca56d78b6c20721d5dbf48ed62e85166f2399b9062e730b4511a57eb5d91aeaec9d78b9eb7a3e9327cff0115d2f2620fbf5c78782c4298bef7692f035be8703bc039da61d9bc1c5c320b7cfe09d18fda7630f011d8467d187db9d0601e870817f4bf90ee727c45a9bb4717c2e5bf8e40660ebc2a003c5601cc89c0fd3891bc6867c2ff258f77e97480ffc13c18871a189c3fd9ac54b17f904b3c680b2a89e77e37e47f84d7a48601eca1772a063e029a01320d6889704ba0c466a3271be4784f619a203ecd749722cc2eb8af0f5cfb963e40b865116ad844926d4a43ca4609a5153060fdf8026a16e4879a344b3282b30de98434e6b7f8fb3dd0084b5edbd3aa18c055ac091e8bf93c1cde54db264fb7e6498a28044c90073809ff4deed858ebcbc26203f3abb76bf0dac6227ff7aec3f03fd2cf81dd2b6a196d2a6bf8a3698d9e9d824d308f62440ac507a5eecf79b191f2b966585eb22285c3c00cfea6340a0fa40464e746cab146297a3bd4e35ca933f0ce41f94089fb90e33013147049003623df97b17e999890d09ebae29c0c395843a296f886b7c26ce116a0b58e4289475a3d1ac7b21e24eebd187878aa0d376a20288506ddc796bf13f77f49480f73280f6780063167382881a21dc8a5651b23ee80095dd8dc39caddba017323e12a07d188097cefddeeae0773c1fff9ec5260042a6f84f4cb9683a3a6ace01603871d4e7a0d804e922a2a0a9b2b2342ea5fc3326d3add7e3b301c7210057ab88c34a5ed6d4fb059bdc3428e63a36b684ab9408b7b063e91b83b81e2ccb69c02824b877fdc0e9193898f2438a3b4886a0dcb66287264c627648cba342aadab0584880f1fee8eb7a49a1bb083c8ca7735b2d2875065cb2633b700acf9a9641afad027fb4aab940768405ee5f50466108547ee76ca7f8d4a8247eeac21ca3dbcd6a7335dc4438f35034a79bf45426c362bfb37203b2b82f31ef2f6488b9c541f0d95d67184daab0b3a1f88794ec41774d2dc0e352b80f2e5f0bd8958e04636ac6c0f756e1d94692bbc25c31d8d17ea467d1c0aaa2752959317242772d06e5ebded771c8de46a467959838fdf494b808e9d0a62f31f2c48923a63bcdc7227c5b99a15929d5b74840fa72c759d027d6d5969f9093b2a7c5a778309654fee05f3f4390211489da513972e5595bc01efe0143d4b5b3d4d2faa1f1354234cd40f09b8aa96bde44a83e85bb909fb063499d0791b98b5793536e2f7eb74b04d430331c81bf019093cf1abe3dc489e6dd87a18a34fdfab5031ece6d5dd55b8bfdd9569b6711f74891b27dbbddcc2fa176e28c44cf6c5d46de9a2ca7d4fba7455be6404d78e48f1027f7de8c4dfa46cde010053addeff141433bee9aae77f8c4386aa04acc8cb757e4c521bb170c1a1f15336ba26ecda9e0e9da9a02b55af972d302e12ff591e3471bcc8b84c9d766beec8f89bfcde976af0705d221706321bd6d49decfac4514ef3c91d09b02ade991b17636db757f99af95df1e361dbdd6e7a57f6ccecf32d38f5c40ccca493aad4fa1ed26fd5d9481d6967dc43831b476825621bd653239a4ed654ad7100a0ec6f89dd36ee00952adf83e70797500f790673268bb820343352a434cf03e6ee563e4da879576d8d6c112991f80374a44502ea129a5b882043157553abe8aa977b247ff0a67428fc92845d4dcc313b1ec4eabc4f0f5c8be2757807c3a7986037f72aa7ab7282d67f6883757b49a7909e81d9ec1eae60f54907e931421feed3f561b18bbe7aa447cfb8e63199ca45fb65eb217d8e4953d70be6f52a6480080adac31274d9fa9bbc065f62889a71194f98b141c09bc182210743da4e9e44e04220d0b56e983600631a0bbdb2ca5ade102238456ce40d626343e183a5e1b8f3ec7f97aa07170307982570493bfaa79e993bb0a5adf0eb820e2a8a8c6039b831bef9528ec1819eb6abff4dbfe002b538ea6599bfb00047417c772188ac29cfa9a208cd736a02c11849011b336f9356ba13fb037fa8d45d5634abf3a8b665878c6d255bf27923607a295b1cb38d1e283590f97e527b6e512fa2d7bf5bfea90391dad66805b31b151a7fa0517af9399aa699e59068645f669ec51f5dc349189a0668fd849a1bc6af661dc95ff64fae5a9e7d4879ae5f75c18c0dfc9f32a311847be3509c933f2b6e53451ec0492cfac294b35769d5350f8d452ab6ed84c77b52da1caad25cfe04a229ccd36841a8c1901bc81e2034fb0e98979601550be96e63d02f6dc46795d32d5eec9df78be656095e6284460b86c74e24b4889744d53af0e802a37b4379403d54911329a5595f2001bac3c1e4b238d9985a14815f2c99b34d86c930fd6ac0605e035e3d166802028076ef53fa067e587ae5b056ff7b0eee1581258001509424e22b53ba55b3e98b03e53786ab08078a3fe9aa67959022d470d85981c9ecdca46be94dc9d90dbf14bb663ef48970436b55a5df5da19ff5342ed8c93294dae9854450031dad7c86887fc16c98881503b0c3457fa42b3d2b75940081200ea940e0f787eeb42bd03ab66f90f37999a79a69501dcb40d49ceec7b678aeedef0c7717c4903ef9e7feabf2a422faecfeee41f022aea10e50be2d5826faeca18c40d68453e3c75f52767c80c2884e007edd6e362ffd8e0c228b4d7607be51f6fcdb7ea116328307ae8b4cef9c0254fbff0e63da6f9b4c3c758a755caf996cc404e1f2583c99b8bfac456432ad689a7174a03d779a0901765d91db1236ebb948c9c16bd3d44b8d6be8c6434ccf665b27fd8045e8672f2274a6537354219a7b81f2b0ccf30035bda4078fb2e3586064d78880826d1762a0826c86da9c45b7834950b95dea2b758090a301242253c73aa9e39edcad18c9a7d31dbeaad7ae0068d807200bcd6f169326725bbfba155c622470f82b8d5b6d6cbcb6451c275d4ef2627882fcfed8ad1752948b6df6b97ddd55544a763d5930aac8e6214b0c943abda1e692f7fbb1f30c71b455f949cac7908452182669394c4bc6e1922dbc331669dd6a5958999f1f72864d0c2ab9a22d2e829758c324c434253b2972a4efbfee12a609174bb861ab85fcce0a776fbb2764db4cfedcc51d356b36b281f77e8a5380d942c8c213b095f3b677e57f2b3993683fff466ed577a76dfb1171a20148ae4f24c837176c9e97238108093eac1ecd8862c9d92c61d759c7949eceaa7f1bbe3168d142706664d252c8e7e771608ec4f881171ea4857e1ff6b14e14a151634c242d43ed7fc3e1c46549f3fd82b23612777a7fa28e00bccfa0de5af3fb197375f17053f19645c140cd4179d37bfe21135286c458efa375da39a84a82fcb56b9672c530b58a98c8a41a9ecf19303c878f6e168187225ef19ddd624e8ab2cda9521da8b33600b1505387ce22be2d4cc135770fb6dd9f62d5b155cc050f72972d168f7a5814bbeb1ca85e2f2dc2d2751da6dedb6ad821dd0611980ecab73f1d7d7f3122eaaf2c3c29b7fca5b0eb966b63c3ea0463397c2229631387662125479dd558748ee4059df6cd8eba6a75fdcbeab724dec9d5d2df2db2f82c8b50f51cd340e2d53f231d268b931ee396261ce025d868ecf2e8562e7c670060ebe4b35b9d889040b988adbb346d772425136c31f5e7fd4ad2c611937feff83faa95703fbc315bd02f1baf15bdd1531336ae02b0284b622d9ac40ff78c033f07577c51564938ed6f88e25b6ef7cc31f1ee83c1c6590f8f61632a875ce873450f357b270bbdfa811fd01d83cbf5357506a500892db326dc3e65854bb8ad7c52d9897e95c1069a63819014ee83a5398ccae2cd831f312ea5acd11b1bd1925d4fc6a9191da28dec6001e4e5a46947639b0150f4ed5d6d5bb082fd5b9eb08e605f0d203608dd5ed80edfeee6538cfe50f5cdb175d790c96b415ee0d4a4ca30342e32d351107f8e519e13c0366517ab1e8de8708c2447d1af9bd9c4df52537d614da0d6385e0f65eb36007557b590b3cf21c274bc3c9f60a022b643d691c554e9405e91a50541ec6c7b95391ff4ddbb657b720f761898f074f6101495724df985dc42c63e711420be6765bdfcbb0147787f95c24efb9eb7ece5d552d5d4393434773c8f24ccaf51c85d85fb17b0ebdeff0ff20b1b4c2b85218a591140acacdae3e36d684d4a7339e35b17039fda6761a5043010d6d69580f41973516543c2b3fecd6c7a768620b1a03d0902ba3c6cdecfb69c540372caa225404fa3251218ac0877b79dbe155471ff988a82185ae7be382cd3cb57229285a8891ee1ea24f425bc963f81ad4547abd25e4baa76a93b54b6e90886a6ab8c83bbe1308663c77ef927dbb11d6025cdf19c9e8f7b11ca2d91a07d88c900e8215160857c80bf33dd7552c521f66d7cdbcdf9e8ae73001fc2d3d3b7daa33fbee9ad7dec095d31b3698084eff3622bfda062027243ffd6c36c33a14ac90cc976a6a2712fa97cb416bc06a36c6df4d52d51af23c7a3bd0ba5a2978527b4ed61d6e88f45eb20b5f78c4f0dc887ea41e8b6d0549edf1b68a99b780bbd29028b8ec1e16335305e01764f1a9067c1c29a40dd2359d9e0e28d2637c6787a2023fd5cffb7c005d158247b7e18eacc88ebf1a25ab78d68452ebd9481cdb178a2b6b54074c900e420c7faef1711b3e4af0f6c4b8c54ee3f33e264c52320b8742d0b95482bf83255ceec76140761f2ddf92a215263d9eb6873469ce4b5abc35515283bcb94d82fe249fbc1f7144219c027b635968868dc6e3d1920d41f3334d4aa2a362265c3f0c701911ef2228d4859737c6ff2da1cd2859999f07fe8e793b89fa9efc0eeccfa415f472845368b1288fa4672ab950ec2450d4085fe616a7a5e1541a0ef15a1f99e2b577ba5d9cf1ab2466723df6ad105508ee609936c2f144ead0418a7f63a3aa24fe2f7fd8dc39b85b6c14f66745b68d3b0c01ca1abf834a6ce19c750f77d243a5c8a27cf0ac22e55972f6fdca4f265ae2eb154e100f7a1c2b90916ad1119d1f911a364bf1f3beb649169cbd98f26a83e1b79e027d1b6b333b1c4d9ee6dd8e27ed4c48cdbc0aab75325f958d87da09de44049526929c599bef1e535b6262bc54acd023bf7721cb4e80db5ba8f52df61b63d281f307f194b94f147907e2559d468976a142ba1710f983af5a9f147f27f92216bdded1ce5421d321ea3dcaa6f5db36683c18741ba0f5f309a0685ac9889322681941f38dc58692ec31ecbdb961f11b417120af2dab4388582e68a5ff97fdc519d6c5f78c67244a0238be792c327341089be5507462e4085af48fa43002731103e584961483e47c7eec1430d7ee7b39da1fcf6379495ace5a5efe7aceda55a2155e71cda7cf84d6516ae4beef343c431f238a4454b858df70253b624894c1e12c3a82d11ed9028e6c669e014c98413c8bc1a5dc6ba0f30c2c4a69ba6562d86599f4d3524e19814635173592d5ad1294fc64d52adba0990dc71157920f18a047af3254698f329acdf2c413445b2d173c6b61a322d85903a197ddaf3440e2ef839b66c590a9d35c37323d37882a66b2c4d69b2014eb8e9ded240f84cc9417244a6ecad752cbac6304549ccee3aec889a8e85555fbabde64a67c922bfa470dc7abcf42ad3246d215455173f5c7736d0b06b808e7a51cc420c3e0918a96e0cc841e029442f8d408254de5c33961391712462fda8cb12222f8523d640b6dbc77dde2444fc0f735e217476407ee9b307e0756acc0625eccb30dc7efaa9a1dc58c01a20298752d00b103de590efa4c56b2d7d4302cb7f8debc197b803f98fecd0a9abc5384882bf52ea7adcc8ba2ea0976f959fe9de0cf524b946ea6a156a303aedc439148674908d65a267ce517c4df01f8e4dcdbc42fb9470b9d143f1394e9598f3d3e2af0376088b43d50e5c6ffe3f329323877293b8e038d2235a4d621112d6d2b382a7896bccb07aa739c44c35b39fa65272d8a0ebc0f316cc39dbf12a7a90502892fe9f7db794cdd97569a5b97776606b3a36adbbdd6e95e394ccbf7c9ad8c21d85c67c9a72e87978312672a8f6e1d4cecc5cb36283d3fd2ed422e35e2456d14f7b438ecbdde8c2323f526819265afef7f008849481aa12e5f46c291932404d00c8296ac9d929b02a06117841d3b526a4d01a2925680fb6a0d6ba95170e870ed614949fc7aada6618c7e87ed1f699761f4a6e4040ea9cbb533aa6b5acecedb268201f51ae986a46118a88e5d2acdfcb71c8a7593c3ed10548c476530062aa44be342c4631baf6029e483711fe793302623ae449b3bbfcd80b4179d789cc433632efbea1e79228e609036970d309da4a3d7038c6c3410d86a6848e6335f1ac3d6da6147cc6d48a1b90016284c359f0d075876a8dc8be3778626129a4b9efae02b22b3c0eb1c5989e256fec412680792f81d7ff8de04f5a5e606c1ab6fd68e757d55f96b91e88ae25fde412c7ca20304c815750f273926f0bff57252b44ae96041dfb47bfff6e50a68928b2023d56ad55ab584cea59af3eb317f0d6eb9f65ac5d2420b9a91533fa5be86a530fe6b8d0aeb6346eb2606b0677d024cf1eda722fdaa150f39f5e6f056d3fccbef051f07906b12e6f38d95d3a0f619bff5a7daaf675b1d45e0e8bccaadb4359f05925daba74c9e2ab6b38dc4cbbef0077b7b5d51f240249359483cc0fedc3c2dcb1c51868ba5002bb5d42eae4705085ead9e230c3ea2a39a3e09d2b815dbfa33e0f07b4165ce6b66ecde2193b7d1a5c79fafb3f0fd23e1b1146d8bb322f45c1d1e2b26b7e4fae6d1a7543148d645d676837f45bce5ca399592ef670ec85ad48d6ab430790b7b8a88b0e9258676dfc131a4e19ed096bc89f3dda5a07a49b61a74c142ac75e2d015727c6845e7a5457e78010e3bdda310a617556f44742d5cec5a291cde8a1b75a0859ba54c900d738ba5c2d5c4ec93389ce253c9d209e54dc864672296b611cb0b93f37479307c9fca6adbb3e5b1af31c9c94526a56224b520f49306968e8d0acdcc6efc3a9cab3c4cfb4bfca637e7eaf71b9c1ed709b22998a737e002c44dc377b8d8663dfd95b1252c6c30c1ab363d9e1e9bdff4fbb16a35a9cf79fe15713a6c666c8060860f231a6c054dbcb1b49bfd915dc0c1ca71a8b48709723ce7f187714ca67b0397ccb7fcaac093856c95e8d51f4d71678f8331a562e5cd1d565fdc3f42298f8f428a43ae0a2d1b70d206cf2b830eaf78028fcaa9b87d021d4183b6c6ffeda94ab6cd632cb073ebb3d764ecb700fa7ec2541afdd7f6d2ee8530e2405019789b6feeb718f51c8b7d5b8470df54772e33e928e77e2051b7e1d8b66dc70073834276a3c669b7f6aace59bfb9aefe5d6618a7745e1aba025ef456e9b9ba8cab8700f5466faabda9a680fed821e2347240cba89e1a0dd112133b3184e792fab001496dabc13a3fc7ff30600a65731657b11470077df47c4af5ba23898c93eb671d90225371641cdbbf91f089882cd865e4520755bb90fd5819c232f9c916027f52743da5ea097f48df612b560178c4b727ea72aa5a49843531920c6536255e890facb799672525de0aa11eca3e8be4e466167aad66397835ccd415fa78139d784607b24a8a988ed07c59f0d156487494e0a11e0f16d2d2f413406e449ddbf56b0d00997f99149e34d4c7e51c87724cb1dd4c89a767eb4f7a80de909bfb5463e04d85080efd590fb2407be855d31a2dd2d129e04d73a49371d8113a0e10c2dcbde15942abbb2d61cec71c175249e9325de36a6bc072a9e4c00ec1c35c16e64510b59dbda14bd74ef0003aa862551b0bf1fabd01cd68da7a468900391f152464c98e0f4560d766d9275620a1826fbcbc4fac8e113ac72ba4464391eca0d20d67b4a4d0d942f3ebba92f9b21aae7eb5beeb35d5e0de818fabbefdfb40420c19a378b3ae2301d3e3bbd613d11c9f0fc6a23b84addc0130b39e60d2771fd5189c33ddd23bd0ea63a2029855b7b438dd0aa626f7b67aa367575b4492811d062a2a93b17a26bc8997c73e387cb89ea8bd1288e6385a43ada163d038077c3a21f2555175f65d02a6e5e26dc9ff44488228a7051bed15a494a64eded9eae4ece06ab79f46ad8fd2bfc1d936c5a69a2903fac520dd4bf1560333305aec304f00ab26f73729eb163f4d1e0518ef4c65391ea030202b501350a4de0f906be565c4147f68ac28d79f12809e70ba753c281062fb4626b4febf3e6b4ef49589eb048579ba51b471cbb0e8b4c69d63810243c8c877327c56ccd25e24eb85ecfbc25f6401dd052c7105d9658f9184c6e356b307c29355ff1d2614912300ae9415cd2ec5da37fb3a8e39d109414ccd7cfee1f65cdc784a1c9a966aae987bc18efa31e0b27bca9e8f508d76a5220012ab5d37773e089b3382448af0faab135740eb2dbe88f1160fa5d09c4c4d910dd7dc19bf2122c021d4e330875baedb1b1ad7d4bd07ac4b4f750d19cbc13a56f632da18c140887ddd70bdbc51f2f3ed9367552ad260f4f5b6b423631495350c02466c77f96f716549f5ce64fbd6d933f8ebc2b9cb0f342dfcebb8edc5e1a3c989c69d48efcc25cf3ac03d5b573b60a5a4018b471252e34883a87ed01149f33092bfef34384fc44dec2aa21f78a1f3c6ba487e31a835e893969663f14c4afba9b99f82b12ff4395f399aa4566942faef8a61c54672eefa75c8706808eb859692bd6b3c94bfa9aa6b9cf67cc7e1682447f6108b684653438a4daa3e6304954cbfaab5464124c2624326e7915139b36bb91eb895fb0e1b9a7084ae624712b19a6080ca8c4b2cbafb415dcaca4e648c45c1e379045e7641f73003775a5c60feda0839258e1384f3e3464a9fce49d6101488e0bf4d2536b34982c19e43019d223ebde45a248f07ee32b3a2a35f06fdffa6ed135d1d7166af9995ce9e4f8b5eabac72c4b13cab3e115d90808f6bb52a67d3d8603ac25d6b0fd6044d3c660ca9f25002f8bbbd67fcf8ad227ae9b386e85ce4607852a9b93ce335cfc552ef55ade7572187d9f6dcc73661b7ea4004dd10ff6044a1ca67de3460e22775d6bc7ff63da29419b9b667d949e63306ceb41e4b48fa331bc49f2b62b7066093756a0177237a006503f29e9e0d6032fe7d5a0200e4beb2d6363517ed5cababb80ce93bf2fa4652f5032d6cbe11f12c371fa2dc6a0736ff69a7ac0733c0dbce9621c561d20da0698cdaa0884e06b7bb034a3811e19c6cc728f1a7eb382ff582ef1861945d144b62ea7df3e7f91fd57915800d1ce87965d9976f4d7920e1c15c9c55b49331eb31431c6118b383a5e63ce6534bd404b52d64dc4110e0f894c54507dbbfe3aa93f498114d9bc360dbebc4d3b6fe60dc88c7f966cc54831a6a6f2f374dc1db7c724ed979e48fbc7f861a3a5cfb8a3b004a6a54b1aaca5e82f3bc5e406eda87a92418d66bf07497a058e8a07d5cdadf6822fc1da09ca040f5c7d450e63ab8374c1740467d756334fb214cd39a776e2bb480d2dbb0fa69969b6b7da5f74916a1fcc4796db01dc5e6c4e4aff729632f875c3a5c79aa3225e1067e287c97e7989cfa2098b820a67dcda5dfcd965b256958f368970fa13889d743b1e6a8186d0fc226faeec6512f10afa9eedeab1e0b9e32a0b9ed4502bbeec1c7d555d91a0e0834d317a4f3c67075949f7e13eb87bfb928eafccc8e3a64c582e22bcddf1e3ffc25952873005207a1fbb6d6684cb29ea0c427b99d01cf8fa47629ecae5d99bae28c69193845242fbe0f62deefb43154f83508482e59f2a71536445eda754dbd14c24957043874bf275fcfcc5d42428414d782ebf96903640b7d5a42c70e6e049f116dfef598cf86530e21bdc575932a5c6d057072aaa4f709c7e5c874cfd6815050d0bb1ed3036e809fa56823fda1a26caa9e139cec79bcf221bbaa49e7d2e7fed4d1f91194428b46a19f0fcef82af3565050bea2be8876527e21bde5cb412876f707f8c312f578b3708ab37a9ef8df8fd0d71a1e46bc5716a04697ac0c45bbfc37762e1b190263271c74ece867b4ebc0e8f396c2eb3facbc8c6befabf3e6fbe782db4338fdee0775a7222e2f969e476c5eb647d58c45d6259cc6c5568884f193796cd302a552793cdb072775a761be0039e3294811b281025c10c645df71a0d43417006fe496b78c8c0731f1f03cb324eef79a38e45ba428d0edf1dafa6444a040b5530a2839957348a04fde84ebce3d2b5e63b784ea7ddc0990eb88c2a8f7b3431ab974738f79160a3a663a36c4dbd55175e4d5c99ce988da36e8165a9370f06cdfa2462e445ca465acef45aad6c03756726fff1e51ed083e737cc7bba5b62129e50aca5692f3e207e1dd5ae94e1baaf678652f5c153d394e4376f2dd0faeab3989a044f9d15f087e43cbf9f4228eeb03ddf6005b053d44ab1b7c63f67315731ebca11a35d14dc974cdc2e5499b6d42c7d54de0ce826c4bea67eff4b365768fa7ba12abc5461da30a3e2def8ef30192207d58fc6d85ca72df488d7d01d9b46b11f8c4ba87c590e70d65ef67a3626e38e3663598bfa8fdc076c32cb560d0a7fc52aec31e68780e06f72bf1ce7c91721b1c1d3ea108671a50571bb8d0ac9a3ffcc46d0981a0a677e4bc611fe55d8a18e9dae08a071d94fd099403f0f5410345a6b9e71b1e558dc849a2e967f458fc71488ed0b2758cd679cf1aa6c20e898f1416ca4700c8162bc4eaa1b4e6746ad971d282c0a440ac91f3144adf27251e50b6c92e0ae8e9dbf01354ec8ed2dba01562ab2f0c48c6d258f920abad4e953222e86c98191462cb9dcef5e5b905f7045c5051f93e242f8824c27764582a21bcda5f866476da934099cf622ea89e0dc8ff448a91c129002645899868b21277aeb109b0063b325b111286d0fdc967c73cd3a9f3fa3646a10ef3bd7bae5bc68acc16fa65a3f4cde2bed20a543415d4e6867c4e465e61a43496e938894e326cd90d2283ea1fd219cb626c95b7ac169e491ce545f2e622223de064ac877bf27dbb90580c4cdf441b5c9e43ffedd892e5aa0e945fd902e20e308f01006b4136906122e7cec378c19c1279fec78e2de60dc61bb3a8d179d601d3053fe4702639f976c82516dfb9d9e6dc66181ccb8ca3ba11caccfc14644b2f35be4d41b6b4a0d4ebe9e169f5869dcdd48c6d86ecf58e41c2cd69759bf0365e722c7832c81fe77135b0ad79409578f8e81ceab3ae20df0becf0f2c699dfe19879692828c89fd4d35e56af7c3c3d50f1a15fa4c0ced7f353348500edc4c5a66806e2739c10eebbb5f6858b3820befce5f4e966c9b707e73f3a04422957fb3a71a51d5627f981e62835ab20c7adba328ba066fda3296f2ef66e220bae95a858793d91227336058059c64460f00070f50683805f8fbf317f3d614fe294c0896b074031d967fa932f07f48404d6219b39650a085fc0b4f954d580e0574a59bde8095b61e23ff39dcba26cf5fb8c2d77383bb04943ae3f2b5638da7d241d7508f1094ca8ff7b697d28e7f2e372bf11b6e141ccb02fd381e7fc9d6007c89a69416d222bb03be0993450b993636d96a5559a9130dcc36459501a6dfbb2b4a2d7d72a0a0507c11de4681031526a8d441e843f86a1d9d440530f7291fc0e8124add6076a5eea747b7bd52c6fd01f1437bbecb0f43a4d1d4cf93ca38eb6716fcb635cf8d30d3415ff7c90b0ff3c11b60b7e084e8ec78ddc4e70632ea5df7d6a226e47881413a983d23db413f88ded291f047a934bb83407e5623e15a54b7f3ceccea6912107895d64967a8843e9a7a0bdd599057cb1a0e8e6a3ffd81b71205560313aa440e6eeeaf525cca102d92ab33ea6648034727426ba2578def625d99762a78fd3601ff8952d08a7b611939af30de3dc065131aa14b08ef66053b16602f0894b1100f42be70a0d593f83b5d64cad198b58ee2600229633df9b0d069ab51fc5041a1262100ca35e032a757da8195fdbfbabf36f09c29e1624f6c39af27e646b03e71be4caceda5160b03d7b5685b5caeb6c6f281e2531ccfc151f43f20ce74d2863a7da1277b956c664cf09ffd891bf9ff9917e7ba3c5af88f1eec178110f8e79149d6a23f70743a4982fa7814a432c63d724b5548980ea56811d5b80b2a9457fa11ff04b7678f406d53bceb2416a47067664e2075d5cb4b81a0009431efac83b4f9c330dbe90de1a1d923ef2225dcd8e8e3ee479058679de0ba894199a90f94bf951629774febe430ddd0142d9de17b7492d2445c22767bb3e06782b9bf63dd4b2b646963023979b5728ad232c8cf927666916aabb0dad5cb549b14a5bf21cc6776446bcbdd028c8b1aea4476137802449b5be89fb5697f58202483f1e183f4832fd0e92fdbac67a60fd4238316f995f54502993d04f90cb19a189e049fe49b88a7f3d2cb3f8d2869ea24d5be47e83311ce4c5f784e37c3de36b8f9508c448debc6bd9df0e5f0de87dba8ebd52a965e5fe685a2b1c96e3228e865e83e98b7e886114163e5fac35b26e2d3397fcd9f18eca8bd2c6e3962839d34aa93954988d5941f715480f326700a49477738a9995dafbb32aad8c388dedbb3269adfbf0df6486e49c03f780b5ea09f43b07952e7cabfd6d81d43919c8a0b0839fb9a7cdfa4a7e5c20a9da90390af3d6d3dc6a32d5b4d4f06ca870eb67f4eeeb277d426a7d7ca8ec552ae8d895e1c3b9c66d5493864af56092c14bda95c57fdb05484fbe11945f1c81c8caf4c551904a704fa302f2779b5500d1a75e6c9ed092c8118a7c4c773bfb917e5ffccf826a3ea6a66e77425e61c116718bc0b40286320fde191f608afcfceb4908b1c5c15badd41cba8ea1a8d7bd288fbc5e28bea5e405a111dbf9695ab2b0af34d8386e4c875c9fd4af16ee51195a81e04ee7fa8ce7ff0fb5c2d8622de175b00ef4f976c853c2508c48fcd97c80303a2ec6c590db77c13c3fb01f9bcaa6849f63f3e88e2ea6e24e20ec8db3d71fa3badd6773a3c0dcd8e665a03f676c7f0a89fc4b71cb88f70817a0e9520826c377c4b8b5928372b97f38072af83069b2a2d87c1bb632f7b2c7eb83839b7b6e8948c4eedfb1931f7d427a1b8ae17fb7b388ca9d8a6ed30a75109cbc1e9f665709ba5b00e4be7821712f5ecffa868241b54bb869d6f9c50d8d10cb9bac3aaf275216d07c6da51e4a6c42e90d02260ddb969dd8ff2e9ad39a36a620783542c18a4d45e39c63177959758c4ea8ffa1056d7c747059bdf4f7e9193ac6b9957ea370e8fa2c8d3dab4f8cf223f9ea0db62b0f224daa62bf2fd713967dbdcfc21f034f4042185cb8e76ea39a8e96f7b891162ae0fa9bd8a79072226e6b66c10f6dd000e05b81ee80ca8a31bdc4b3607a89d53da0ba824a1770ceed17ad52037cd5ad637566f7aba8190f1b75df31ead4ea22cb248981b0b81d51d3c7106a5dc722838694e8099b7878259fb556bdcabe43371d6e5bcd10e1bc2e1ef0ece3f0b6ac781c8695e07aa560086c6acabe95266f95f1d113d6b5311bf0d57a12e85eafafcef02cf7b3998fc4d4d1c9d6efab7020304b0ea5bdb86896182dfb7572c0e452959edad9044b836a5d200832104018d9c75987ab2d12ba723875890da94ec547e11d7ce3f1b04d338a0de0e68c22a980c52851238cd0785a922f654e2fa9481eee9c903e6a7c60e938d965a95b2970c01d9601243cf396646b7ef598c189ed899cc528e9c538af5f44b56e90be92b6fda864133d9b889edc191b19d63b2d9c3b798cdacf18324cf9de860773a46dcabc2a3be5a31e45eaa3d9f137caf1f69ec057278293da8cb2a98577cfbf5db2a52c28cf636c74c8b3f30ee44ec624a84d88688cff287ad9de977134005181caeb04d391422111e0fb3975097571fd82361c76b82028984c6ebf5f4b69a8d39a7e2e5bd20862ced7237a37efe492859820c17aa482a832324d504b7f5ca9bf891b13a45a30d08bce3e2084891c90278c3cc1c8f03350ea46d25e206a998c62467260fe4a690379e007447057226fd4f7b6217a216e40dabde1f9236f03c2caef40719b7eb6d60fd41ac28bda43839c7424eec6bdc87276507e47591c85876facda6136214e6a67b950a317f915b8c2c06e6dc620e2f1e933b322f72bc38ed3c5e5bf0ffd2fd414300bf2d0c0d2741c4358d8c0cd50fba424adf821b785221ca050e5b4346d63043a057526011d785043ca599ba99e216f48f175f1ab359a9cec033ff7197a154877eb9156bef9feab5bcc98377e56106af3ceff8801d5c9ed28696ce8d0425fcc58fc4ab8c74853a94febe136798575beb5444eec4715333b8075d7cd5de271c4d96d7f90a22595ef8b9b085ef870d6bf52cb6f81a4dbe00017faffae94aa19e7556189c11f91289da8d35d44d0cd2d66e8bc2d2753d834735eb80917a1d0cd63b2fe1d28c43d5ac7977e5da88133a6fc9df17fa822ea66bc0355d10880179db07acff0857000f227c16aaf6fbdccd5f2c5bccd11db17b3c8579244d8eeec239e6955eb833319603ddb9b73e3528d9e85a95be1a26c656232b846530a832f552d9e028a695f269b78414331802349dd8c519bb910e9c4a240783f40c5dab938d413abec66ae03c8e9534113ae8e24a373cb71ac96c4cebd32f209ca90f2a8ae1541a14b34e6f85040d9295c5591e68ff758ca1b3a98b074bbafca1f8d42306f831d01b086be8fc770959bc93d84aa782b88bcb78b537151b32ff24dda39345bba541cf408a6ab72b54f4dd2d8cac750728430a0df68a0d0bac6b8eb09efa878ca63fca07d8424942bc27e5cb0b3ebf738894935bbf6737d94eeb4f2ae3b58cf4179f5b8bb8f2dda52a951d3a5e7fa0b3726d26193da31779297e4df6302e4251af838fab757503770037e9d4bcb18090e5dc87e5689fb74117e9802c6801312da2e404f1624a132b4e7386d7624edf01cd3f0f56e020dad1151d2581ebc85eda0f9a4f08877d748e9895d2c37f929184dfdc672beb0195c494fb8b84308d995ff83142501ff11327154af2a72a85b5464e374ed0bb9b2844a2b5d28e9dd022879daa7abc832505a7716dcd7acbe96239bcaeb202fd45b58b884cd0ee1f28ed7947ade92325af115ca298d02367ec53eab965e082624c467d9e3260146b3f73e3ee466736d2919151e0714f6b42216e7eae9e9c6354890156156f64b4b0e8ffb4bb4dcbaa257e5b74ae12f4179bb450528ec9b72f20ff25b0b4c9601b3b6a1bed7d94740bc940d96e540197a30d40f5b877b267ff80c0204fdff0b4192de7445c4ebedb09c391f5e29a9c23c9600d48d7d6b94f043dbfcec5393116dfa112b186b8761cc6ccee1891bb4a3d9b42bd495ac03fd1d4d2f091e8b9a18d817a4dd9e564f4422c51991b972a023218c210f54a710eeb4a3f73890ba2afcdcd1d5ae7cbf6581c8adf12556728b43a1ccaa4573b47ba1bfcc3531f494d220e58f9e25e32f66bb0c791e958e870ba4e373943fcff76711562722f6ebd62531d9c4729f478afa45b256622e7fc7633ea00f8f74e4beaefe6119fe0fb4aa606f77d88704468dac4d9ae31b7e8934f942989aff10650cacd60bc5871bc211e634cc4661f274658f393f81e6506164c5f9eab0bf887ca1ca30a97a3ad316b8c7394bf2ff7d2e82d7b85b310ff2c1a924610b75dda6b70ec330557eddea528ebb5311b41ccc4f5028c3daf3ff33f8ee8b43bd6609b4bfd8b852baa4c322f27f7ac5b0d2e37177089255491cf2bfb0b764127af493e59d8c684dcc46a6612e78f8dc780065a06ff32f24194792ee6502b793250c0e0550128c8bfb15fc9541484216bac5888360ed6f2473484cab0f72a7081bda67feafcbee0a3397ff434f5a95ed7deb37afa6ac7ffe4ea888c6302c431effd9e55639b36c32dd8c5d216e5a1e80cb5c2cd7c8c10c2a44d480926d38518f6601247e949c93254219d69e10408748a7b1c809d416ffbc034f08754e5b2ecfae3b1d82f12e9b565b651d543bdbd5fc54cddf62c0929a36c169a4ce70ec94a2ccb3299e4102c1dac57d915d65e8c60b19d2471ff7a8d9b4c1c0fe6b6a1bd7e8832c28e3c80ae048a5df1570a4610551e6604e057cb1507a555350da79d6a0977c375c1af8183ec8e7024f193422251b24466d95a3e5a8113ce54452c4a3f1d410e52859f90a9373bb0938c8bcfdbeabac4f2144adb2c0e70ef72fa4c51a9daac3eab392983e925facd526af13b855943246881fd4d2483590ed38b8131afd5b2e6242031a5aa7a45a22059f8698fae626b36f7478df2c770c31b50e0a603c8442070c4d98d930ab26fdf2cd1f7047a912a8ff2fdb7aaa9428fa8ca7e445e26c58ddca396a637d74511f8e5dcbc4978eab015d7d649b66f420c36c4b27ede5612b885e3122dbeefb92193746167ca2b82d6ec9c033e9f6ae569cf64a65331b837bb2208725f53df20ccc8c1d2611dd15682c899389cad09e3995fd753b420db81b41e7bceb14e0682d3b8312d4bce9ef4865822744731ce2683af790e6871ac9d86014f3b40c828991fb350cf1dcc906f0605b5dfec2e4bfb437150c153ae91fdfaf6aa8031a84e777cc23dae1fbde19e72de28fb7d5c75edf02484a96b258a2a661b07c9e0870c445f753602915c20314be607ff551512034f49a888733d42880db2f145991ff6141e70312672addef40ee0a0087259e6d82dfff6a403ab95fc515cf494b55e74ad7fad3d1b1c571881b8533f95a62e10bd8762f80e157fab0f38832de5517106d72fab6178e0bf7940e750d369887665eb2c1e9f70a93f0fb5c3f76418274e292bae47a631f31cbdc065dab9148a3f1d708f54514a33164fd27eafdd412b00d77e42c5b0bc3351600b81fd1eacf61f95c431d9a6ecd3e5f8602ab3852c026f1a2db662f0abae1879f559ce20157b99f3f5747a455bf49327dc9a869df345091a2fa45835b4bf2cbdab5b544db58a6f97c087ac957e61397ebad52ae499e9a556c3712269869a34c0d55cec4b37019ad094ef09973bb2432e1abb4abba49c40b9d57683159430578187fb9de677c4086a82c453b9a0b4966fc794cc71d9441293f9192b9c0e1cf14dd46363cf17597672822d76f4d7d28f914d852e6993090c6f084439a181a114b3ff9a4d73871ed5a6bc50ff1a8f62f7e657c628d008b4cb2148a6785e366e9e8748b93e4b4a92d6b05265b2bc0660a3b10ad0081fba085701a9c3d7c5f787099390639f73b2fa61b19402f474977a8cb3f00083b61a6f7cb64799bc883a38e34fe508c775b7ee599274c0cd6f87db3c59b88d320d1d1acc932f1751f124b185c3be25af6f5a2221d1b71468dadd8fefe8b951682ae7591b0ce9c4b5c804d28a66deff3388298aa87632a2ed8b93b9f207e65e3514f8d22c0228c439008d152fddae3ec090b82b9a6e2a95f26e2c84a44af241a3a4c067e6a31bf3f1eec343f3691c8ed09970d655cb4ccbdddedeaa8e15b0eea088f7398e626495c0b8f1aaaabe313fe1a50b28ec16dd3ac14e3a567ac039d3032cfa2525099df2397932e21a8ffca83762b674db2bc7020e81c4b538a7016da5547168374728cc3053c0dcf9d747a307cec73fba8e9ded88b7e5fed4df78a83330bedbcff59c1a14a3fe1cb291144f1dd3433149afbcfef86996e57bf8d982a75cf06e999674b82cdfcaf32af3383b92872a1ea76053cc994df64a3d4543ae10d5d09ab15e28dcfffef08af6e96e51a4899fe72816c9747daa83a9be6f03c7c778ba9f17e4c8c206656da5bfff42eed04f12d824a75dcc5de9afb2b0552018e46cf896b490fbfdb5bfbf26873de95405d647006a20912ba4024954b83f2c9fdac4e059ebc40a0196f3cf18dcd3e5c25b19fbbd3a63878d1258b0d9e0ea6d4d3bbda1bf3183fcb96a1c0056b59c937aaff965b6fc50751a18bcdebca8df8443bf819b1b935dce993fa4b125e866d70093134b55570ed199696638547634777a27688bd22f4c22d8f3969117af4d8491111f40d02881c5676ac9469ad1eafb9eac9dc68ec9be6ca51a19ce67920fd3910bae852c22403ce3d46be508915b08ec7e3d52506203b51671cdba919fbd14f6efb205424bb3266eacaff6a0bee6a3d61170b3c7689d54269ddcf19c9ac00c8dc497bc99ae709c9f9c231186790850270a3fd28d623dd209ce22bf135829ca550f0f9d2368127315e412b8b50e5964a0913ff969b0402f9fd5d5b52fc1027cbb6cb28c45fb4919ff387ac1109b983a763505365f0341c773e3c8d4eda8dee77209a6cc1504a8c945f065c0793bf82c67cd5983cdab22da9cd4dc8178e78150eb3818bc669bc0ba7e9d5e53b900582c58101af161e104f241fecb19237054327b86405f4bd2564da1ae20845c8178900a61f8a715fc8a8db8b4d54dd892d33d1d88f4ae3539f811517fa067203618bad4c5f66194163aaf9acbee08ba07e2a293999a53520b7c12306f561c9cef92b010a8d14131c3e6c92df809d9b2c74480b5754ee6f47e7f5e47af10b723f2eb7b2b3d597f6249cb04e7fb02ab3c95bb805c6e2352a373822433d1a91867b3165c97380ef7ad49d56a5a350338a0e043d4f3116f1d3f26ef71efe2feba38306f2dcead3fa8d462ed043c999533d669865b36c4a6aad8da48dba8e0d1ff24ff8a6fd3a8ecab98b4273a0ede0c5e89658de91b34d0bb5517869bb8c723a0f82f083e1c854c677434067e580c6c7a3ddea4c24d7846a75a9fab4848c53ea9b622c8ce23253de4441487c232b3885a0276da55683d4670f6194d539351b9cb02d95b852b003f8e3517f39aa97dfa67534c55226a74afc9433ffd616269af0f1990884ea7f5060ac21d672a922c443b5a7b9146bc679b45da4b50d343bfa9778c3905d264a4cce65ec8aa5111e6ec80e83089e860a3ba1ce5b11e2c81529e831333b300dddd57e2a0bf57332ee7d0e204cc3bdf3ae53a5dc68b00ccb0f6d6cb65c9ae20435a8d382baf8e7b599d4ead91ae1e028ba8135c6441539a845eab77f24e0d93471b51def0f2406100f0608bd5cdb77079d08230f3c484af2033e938d5c5ef3974ee403b3e96e7da40189d99332a2d58fc50a32640e9b14252a7f8285b20cf241a3482aadf635ba5b0ad1c677aa7c07778295b2d66f9736a6371063b126613ea839e7bdce26985a95297ac1212bb08a86e0815dd1c1486239a2fd59d4fa1e5b0e09f6373944afa1308d788d6c0306e293aed464ae08c1562cf11639f75bf74e0bee9fc35326a809a9bcee8ac6ad94f6b79649240d6554c808d5aaf984667a1869c2bda1c33aa043f9ee7c0beea848b27dad5f1d244294d402387178466ac413fb0d0a25fbf43b31016023be31422d1b7d185bc7549c2e68ffba00ce56c7ba8d54ff3c2bb458523978bbb187b86ad0a805b489273588785927f1eefb0f16b5498f7ce418e2e0ab7ec05472d2b482f5327ac1f686afaeaa2966290522a366007ca3e9370ebeea2ba62a7070ea04d69872fe3200d0ca5af485c56d5e88b73f8b4016d3a570be5a3912030e161795f232e0e61e0949bf4b0b231cc0bb0798f09379ef3dc16f48cf4f1822667356ff5d120608ff2ecb09ba385e1851ebd03e22ac2c99336f71ac546988187c28e42bfc59f8453b8a066eb2010198964e84147ce09bb579f8e9e4b76267135233e7b9ea990da4dcd59861d450c9ac8d47e8278ed4af3adad388c64bf24c4a3c45d933174952a593de6c06c19b39571674f50ae9dd1e37b435c9518a2d6fc8db7b6e8fcbc06d0e7e8a65ebec92aa6ffede2235ab9a476db7467dd05305705b46e1f93e9e6a9c66c968185d0c2320f1a12162765f791ede565a2ee8d142bdeb62223cd96b5ade421c4fc39de14b103177cb97f2df0d27e7fcb0a20a765b486b9962f09f179a1fc528622ed0d3c52480f7f4a81bad26257222fefd812b162b9eb5ec55933d6f3b306b8efefd6b8048ba5c28ebe7a61c1732df2d3129e33300bb839aa12a08cbe186af5656b0127cece35889fc528222ca14bda50af301ff4128fe3c5072ed4e3c1f0e058cb0a6d3c9d15ce28f30b349be44e52457bcaca27c863b68a7874c4fd18e28de0f12098dd34100c2bdc40590a1688fbcc44c59b59450ddfbd68769d5ebaa1527c90003a7ed5dabcdc006f376bc36fd02089b2ff4f95538c5392bfa9c07f32d7cb8851e2b47241de9dec2b2ece228038eb3cc5a4c73c7700cce97ed9fc9040ea68f22149a574d2d282b2081ed1c6dd7c72d5dd88d8311c978c296e5287e3f0a0bd766ed71d519dcc1de778725a15ba0ed683e3560c90fa5dca0513bab2e1fbc6da62483cc693157929d1060258ea11bd54e5f0e0de5f8356b63a465f256afd4d2e8ad4474c4ad82341600885c3cbfba0729b63ff464e8572e13a0445ed113b1c5ed96613e75b9e0a73463251e3a0d7c4d1c1fe1a3ee74be68b737a4fcc93435a8ee0fb70ca339c727c55617eff2bae3a0ba4dfa7c86d01d40ed40db300b0b75a644d5d30703d96d8eba8130f11c29b6a9534691f30f4be90587306cfcc9c39715764269164ef887244436be02861f7fac91d9692a663556aae9cd2e0041f42c9ee5c3db3592a97c2f7ff5b0c33ccc31997f59a6084804ce7cfb42c07ff78e3c0582632fe5d943ba41369fa22f480b868e60cd91d47f464d43bd3d780d8bb1aa4e0ba5d00562bd0fd0a57c76ea1e52a236292c599485c314482ca34af5df31ebd7e5750d18277dc38aa40cf7cccb0181c18fed958822e8355bcfd0ec9896923102d663d71d6ea6e5b4138f86cefd238c4dd86952b24772256e74cf0d3b2d588b3f6ca90275d1c84d499e690ef43ee672dc6bde7772b46ec75e0f37c71d76b6f91707640adc7ec115dbb7f6e014b43007b885bdf6ccfa8df7625e2b898b26516364c56683981fba072ee2f26c4263210a28121c08ab964633404106d7f52f2e0058b57eee9318ce365591e7585644d4cb8ab8cf7073fcccc3d9b4e75edce3590598ba9a00125a98ed40c43431fb2f1cef630257e9f0bf58fbe6f51fe5f50edf1a7a9a7fd89e4f4c01d0150d96bed63475af25dff1f70ff1efe0b9d37059e44ca0ff098fdea66f5d7e31e4914a9e7d5afabd1792ab92c19dca7f805de4b6dc9d6c8615ee68b24d9d8d055359c694434b2284acf9d9479c22919462be04f95fe2c4b76757293ccf55a1f1266eb4c0ab0952ae479441a241a8965c80d2f0ccb7bd6cf618f81c2b4d1ffd18af7e3eaee1c5bef2e25a99d8e7fef45bae92395c534ae8c9d8718659655448d00a1b96fcbf81bd2ea661ddc27cf91d9629c5de2823ad416910a96798c6d97c3852d749d9c578748dcccd8fb8a59a87833def9abbcd9eba8792c7b71cf7014ee6fb2619eaccdc32724bd5aac8d14b1a585175f7cf5c9728e5eabbf62bcecab684b036a46d16c617bd836c5435973a30c2fe6ac719980059017dc7fefcf4845aa4ce7c538ab9368abc2e73059e9db5a199d4091c743d9f8a8132f74f76b64756e7406aa70f0e0502a5322cb34066ee619ad0855bc0f2178905777f47e1add124ae4bcaca12cf32b1169cd886e34fe5f2ac6518125b1b3e5c0202f0a334da14bd9151aaa6df98b2059652603ed4c3f251d0dcc63d2aa95d795d418cc74bee59f0d016427eab77bfa4db38a93939a61b1bb8602e8d5c95158e65de17d4f7be94ec1ea4cfb3b4485c4270ef534075410711bc396897b4174b74554c3abb3e034d3f73e167dca4ce3e95e291c48cdfef245bc208dcf3cdd614c3dedbc5774cc6a277be02154a9b2b8d983d944eaae24cd90451d35a4fd77e3cbfb31ed737f75a20588c99f65a2926d98d044b95efab48b566cb9af15edb7a005f936706c6e8d54d55c2fcffcbcf9f6b9a58555bcc02dd78b5fc43c6844e32a818d5434590af61e23e4608ea076c6b4ce9de185c8060fb5e9b8cacd9ccd3ac546031c18b9169db5eb963daacd4740fa946ad518e5bde13cd550d0d10e743e9260cc8104e378188d9aad55cc06d8dc8d1dbb6302c292ed576704c9326797944c05a552338dad4683116e1ec853060df35642c088a12abc707a850933fea19cccc8061305062f740f15461ceeadf0f6335da0da9660de10ed23f296a06a291041e5cbd7cbff389a6d6d45a4ff04f283f1be168c75d6e64d44fe8bc607aece078fdafafef7b64f44fa297c288d9760f96444bae836bb7365ee877aa87046614d5423925ad47db38ed7c00b509e2fda338bfc634aeee8360b3b0167462ccd37637a26b0c830790029bb10a2967181914bf48e269f40cf30b5672376b4b61dba3cf9cf3ac3e61df82d23d8db96f4c748ce08f7203d4ff5265f485d75f661a0880ca2774d5a702fe6b15b214ba9728bcbaf7e14d761bb0ec2511f76316342076edff60ff94e2c73415c7994454a4078ffd3b396749f6689dd1da3ceff121cee764bbc90310f7d20322b2e5831f841f73fdb8e557e78b6c62788da0cef3e1fed203c9c5abea882e9936a161e9a7fb385225c71d368a4e5034064efb86b0733251867c25b887c4ccdc3e2d94e6be6912cdffbb3eaba6d6f4194d4a7873cb6af866e8068805db4d850193129c527aaf029a3bfee236decf3a9fe138eee6703a04216e622c4a028988b107c4392d2633d99e08be5a8d990fa110a86ab1c1896534cb53f04a386b17f895fc69e576edbef79f7e6eeb49a8f810dbb6571ff99f46d5b7e938d4e17a65edb570fcda73366c523b96d1da4f2c014e8927970673e6b2b0f60f4b1e4526b67f657db7ef03a8f492b98cb8b4e8a13afecc2f60a9daa46bfd7640315743e6b380f3f3765c307f5efcbb2f39a762bf0571dc8f71aeeaf3382337d4934ad8c82c58d88aaa4f24e1c4edfba49534295671f5889dc866464cf3904fe7dcaf1dfab212ecedc3cb5a7f6fd1b51bcb07d58a4b05a7d0276719d9146c521905904e01bd81af677c79cc493e9ebd874771adb23877a9673324cf6fa175976d05529b6a27a896726b6050709cc88be7511b5b7b68f0dc12bae9656b847335a8e2ed22954317d30e8497128ea389a15ca165958bc9c2ce2c7838e7ab4d2fe3a1917fc9a68af4fc167a71be93892a0f0c30f5804ac7fb7a5b574cf6ec6338991ad9e24cf05161d82a12224adeb0769318eb76e73988fc13c99b8666b49ed2403f8b49519d57182b80db62f823871c06869a7382664a5163a7363df4055bf3b5c21d271d18bec6531faf4c7b588cba9199af5432b9714470e695d174fe9fce1c92a8a6dc89cc5509b3ae3204eb54702b99fda526a11a56f83e3de7126589797b82ca32fff0c7fac46d1e39d71a2740f72f8b21e11db571bb59467cd026803679e9996be547d9290e691de3d3749b7e4a4d318def2c1b8300e01005410558d87b1f8febdf68d9884e3429bb69205d3ee9d6f570df7ef8c005381922b41f96c03925b559dd10eff72312a1f497bc7656b962f3ac74b48362d59cfa434ef8bd0ab46b0b99816c1552f1c87e42e184c9c1b7b52b1374ab2c9384d05f11a1906381f5df74e599242e85f73969579e7e5147783da71de2fea2e6fab72c3b9895e7189f22053e1a919e123d8b13a045236617951e3f4c3b2d58b617bd616c2a158be1121c318fdf829ebd0b587b2fe04eed1723290d9afbf140dd1d2ac649b28c14cf3de9fe5b645ab6a663780acc17dc9a7319c1d598f34351dd232d7102045fb301a12443aad47df2aa9649bce6476d21fac80026d536a6d2d257fb029bba895ba462bd006502977f822d3565c040c77d5aeff56076c3226b692788b23cda8d2c23677b016bda8b8678c764a9bd4b9436cb8db8c18e5e2552dfc1bfa5967b4aec98e98d7fbe6fc23ea6463e3a3d788d1ae4d846babe16f7af9aecc8262c877cb17b6055200eaf1607a8cdd13e232d6dec21438754bc4c5df6c8d7d1317a36a4d14e64c339e5cfb9fa50472ff7c176eefdb530648cd57a892656e4f87d21918d7a0eec30c34e5a615b38c3c9d317298764f293dea2b26f699486364af4838dc8b26cd22ddb4b0dc6a1e8b25e0770ae3635d97db09125675e83566c51bbe31e358473e389590ca6a1fd0844704e5d5bc621b0c8d57d57f5f25aa13effaaf1a7e50f4245381b26a8aa314efd8bdf40487cae41a7d56ad9a03081bf0b1af7bed6f83a65c2630ffe67c3b4b0f9dfc3c7817e6d06146a9495196b0da747df499c2c44f245aca14874e086feee4ccb9dbeef9454c57a934a5da6882bc9c8c6e2e5786fee85da21d63bdaa38e9e007e69e3cd76834faa27e55b7110870f19ddf0b0a563d10fe7cc664667363c9a307a0ef8f3ab3eb5604faf806e6ec98f861ec68cbe71e11690477335cc710ae7af0a338050e3011a5143713026ee3a5c35ed90430782905c6c42d2db3afe194344a900cb41a34d0c7fdf3ee6b546efa347a84b44b467b5c3a5c5a2b98b76793e41488ed733e2f776a5e8508e4c967840f9393d84b890df6a4fc639d68ea06637957890a5cc622d36fa9e2ddb66aeacdabc895baedb6df7af0573a8153545a2a6b59a3b31ba0e7663a1d0b179b63eb0d72f8b99cd286d3c6b27c93c4a0389582a5450249268e08ca8f9ba608be996397df8c6b7180b787471e03e737417b48b266e700c3aa8b86574eb9cfda0cab0e147ab3316310e0613988d4d2dc748714ede5834422411768de4f6b05d6cb9463b56fe9fcd7e99adf712bf93f903315b09f7516d02e73dd7d09ce4e488e10b9d9e0667b85b4db48999c311d3516588bebf2968d223f9e19a53d53fcc691de859609eb6aabb0635461e5364b2bfebfae4c9a848a96ae72ffd6f178760100494b5feb810cf81160ae6f1e326191b112b17236ac3021a41550a4898137c6125c37068b0136ab1bc0bd14d0800db5ef0cc6783c05dd541e5c10e9aea20d0c94a82c9474af9647ae335b5383c683e27b5a5cc349bfd83bf931a776a0cc451b0507d75c1cf4363304ac7c49481466afa44057756f309eb2706608fe351349e3c52bd980592f10c8a81c6793079403181addac2cd3951b4a5adb7e140eab9900f100cea23788b161ceca1eaa85a865c1d97d112e86ddecb36e20988e5a52fcfa0967703c8d74d6c9e5ffda5e3ec7a488e7b9ec9a55a6e2f7566fcfe66ce296339e3a1807e9747f4d3f541948de92d662f2fc0d8c38d093a2377ea002c7859433bb3122279484969e6b9a55aa270e233663c20d6bb9d35b4819063ff6afda59e59e892409be58660fc59131b8bfceea5bf36e3c9f65c5999fb60a2ca829f6ebdb31e26bcb49e91256b6bb4e57eb819d152f9a9dd6883d07c00349c31e98c791e1035032af3ead6d32ba3520a4a547ece1aad7c8c076e027238608a434f5d058e6c367bc4c68bb27f4ca20df6ea680a9c6ecb1b0f155ee10803e09c92eb88493dbcbfc836bf4bb9dac11705fcc9d3b14f808e134b216708070a21184bec42bd7813cee862dec0cc874614d59f8b84bb720b97ab5b5ee2781bf40c05dfa29a3e270be21b1f78eb503a2e4eea25070afe7f16e33e1ca52695ad481c22e4665a99b150768976f81a7e4209b5ab0c8ccd0c13fd2e544017a2a8854cf7c874e9a893e4de04b4c7710c5eb6a0a4266398a81e823e6c9560accecf5e67a93f173f9375e0edffbf15d8d99ac100f7e69e36ce984886b4b7268cf54a22218cb2c946c127ee3f26f04f5fb36962ec51de849cd2fdfd5a6aadf870cbc8cfe4d97e5cf2aa291524f5bfba0506cdfcdb55d15ecdaec8024ef60b77cc4f00790c29784c8ed1fc290c406ffcce820dbf340481091ec9306587d5a6979109228c55abe85cdaa59335c86b95cff5ad11ecece221b2afea8f285cbf7423009bb4defa63f18b2757c54099f432cf55bff5f437e9dfe1e0eccaa99ee58b590600b047d8007be4f5ce1d8d7a30fcec44a2a50b9e9ab5624f1f97ba1032132afb6c956b68da17ceae6e9446f5af138d2f3af35d487e1bc160bf31d414f9a53da094a2898c35857d005dfc10acc9372b204cefcc5e4a995fc3472c56b5e6149d04f29950de712a519c9e46ec959d4db211b0ada9199fa01fd3d638f396f7b6d8705b40b24c86af56bf582d2304b8d95c75dcd21fce2b07be2ab09b5a919a4c757de70c403c94186495b54f79539c0a83176b540818ac1836374fcf31538581d3c1c1ae0b77c8a343d1318a12f258f7b63deec8df8b17f41c1fc01e43787b0b501b87f7ace40be0b83809b4452b8b6178232b2e165d8cd7dab44123400a5314013e89ba88a0aace33578dc2c5f62b14380fff589aa4ecd945504742f5f7c7c2317a0868aaa33a67a4af06f0b5d279eca5eadce6ab2f3141543d0ce4194999c5ebe143daf30f2cce5d4bdbbe92166832263dac5639b9ac49c4734381f2178349d91568d84d80d3e636f0e1760cc6a3bf0410d449c03ec56508872d6aa3712324e6c2e375a55258bd41ea9a0479cd77c04b4463e8f65323e44e0c2ba874ce1b2aa39b24c8202d9ac72cd22d6fd98a67e6a5d8d040e9575699aa021e705458afc87b341ccb00fb8f8357b1e18203f5d72acce7aff56d2d99ef6e61c116aed5c0be0677b75210c35931135d7a7aca96ce6ce93dd7bdd0412edb651216106bb863223f5b33966280ba58e68164aca69dff9da3a157c087e1f7e1fb76b51e6b112d14b556bc86a1c6f51bb3226108e0d18570967c18c187581097b369d70e1bb5b26e73c3a25a9ba489d65a66788c0e1b35b7a3f66f254de35408f5e01aa3fd1705a12323991371a2efe68b51a56d15aa03fddc3be68b6b5503191bdb038a79594281d5114300e5823238763ea7fe0d0a12ba0087217a22b4e96c5f9d9a13e12d7f3799b890777261d3a2cb5a0def63d445c6d9d95ec41fbe2b16d0919adc2fe9c1021b46297ce542c04c1dfdc3e1d793e4930ed515b4b2ba44ec1fa094b8271ad53e9d36667f763014b30ddcf7e284ecd2ae2d39ec3f746c8abb09092bb4f4ba41c44939e36561a2e45bef6f7491b09726074ba6b9ffd33175418985668b7c165d67b4d5de5193c97ca4d84cdf748d747ef8913f99a1f8cd1d7d6416d7dbad72dd9cd32c96630e016306e5ebf831e372e36b20aa990fd618733e61afeeedbaadc1a5079e0968fda858426fea19fed94b50452f9e663a4558645270875f6d1cac4e2ced1472250a853a275c0f92110a3c850cbefeef81446dfbaa18024317cf4f29cfcd68461424060649d75659df1c084cd23e9564de4f6c32c02a7bae21ed87f060d6d052a58e563beedbc6fc43d2eded653e5a88fa0c6be830f52926f0a94668f22877111635d55a9f94538e8c664869f0a19d8155044b74d03db3c9c1cffa69332cd70926e2abbd9c8ded68feddc36ac2370d731c9eaa5d465f670461556c9badb1a0b59010e9f36e9499ada0e34c32ee8d304e86f751af7927f6eeaa741e1b71af30402ac53859443a43c987dd75b91cca8829bec7da43badaf595b16170bf8b4f8e74bf700bd7cbc58ecde6910357d09a9c2c46c62803dd9725a2004442fbf72c8ba501e01901064b594b80418c905ebbab5c2fd1815e0e74a021d823b848463cbce92e9a7e96fad5fc94a4251ab9c910d9406e63a2c81b5fdac2ad4690e3b524b29fc36b52a7435453a822895d0e112d249b0fa34bab9169e0618e32ed2e7389770287f9ca8c895770204b2230d982d8e05309d48424839f41ae18877a8a6696050a056cb495eb0a1cae0472a2cd52897f7897e2bb7c851d23b795c6c293020ac818aae25256f5d798eaebc498692cf0f5a154750a31e24c185ef904456335e691593ba22b27ec5347cf0782647744d91016e8e645f376a7b1e6385dbd4bb886d7abb1de79df28faed3bc301e645febed0663ac467f1f5ef334af80985b99b05e747cc51c2428190cbc4ce11ff123a2d68a15bc414e6153fd16685bfd2908bf5c56a2a26f61870bcb449d729d3d3364c39818e8ec0a49715963018f505ddf63c605f04227b90ce524e736ac18de6615dfadda3df46828029ebb03eb859f74bc6b98b2ab83b0f56e85ceaf532a2315ea13c5b60dc1940bc8e77f53c01701ae1ee052c9c64e52f48f2fdf0273b66d17103b10b1f6c3562564bca8db39e9f77c312783744eab011afa7a804ac6e843d3fd3bffdc4d6898ff9c63b9d7da6086793f0d57be79f8fd1c59e9fe8c8cd9064bad2a2ef7bf211614bb7d755767e079636c21e0313f97334d8424ff225931114b1872412e358ab97a2a5b5263a7f6f3c4d83aa44fadd91cf6ea6448792ae90fc5154271d8cf2b03590f76854596d3c4747dadda7303b7bbaef18feaa7b3da03a3937cb2cc8160a597758872c7de35a5aea03c1fd8cd65c6f203271ab8f0a7f45ad71bb3c8618591f339f3521b6c5eb3a630453492146362c5a94c98a20099cbd9b06834edbfdc04287d95782c84579301e30731e4b153809ba7cd25cef6db3ea1bff1dc2d95c9a9246006eefec1f918785b1b48c6bec7e4cdbb840113579e0b9394a6ae466272b4a1dc32cf0e8d92725c6ab51ff2ca228730dc89f4ea4fc33d3de5b41940a971337275637f486c4ed4314dad24f3ec8cc51e645b528e228a16af93f40f427d3fd849fb942d912cba5b52d8cb9bf7dc96d4daa339c6b71038ed96e9eda0ec3e1ae041503848de0d04068e0e80adaeff5acd5a08bddb0e2984ceca6c37d58ebb01ae399e1061acac6c6d0e582d91064c18c0b2ab8080a707346181f01297c13f2223541fc4c9300c70abca38cb70ec7d0868cdf78c4b3ca28eef1340a26b68ec06b7c237eb038e96406a4d8c9a99553a429e75099c62a74cf6c92badd63f22f4a52abe979dbc4fc2b25c0641ee2e731ef0f3333845c21743eaba1c3723c10b8a4ea599ac2b5f79e1dd1514a9984edf08387d93f6705bad884bf825af809a2480c1660d9a87c0d541ff9f285fd6b8a35c13ae2e6562fda1212459c390af4c729532df6c1b1396efb54438e5256021bec5f6371ddc42a6b824852e66fa4361f665445d7b3f5718c7544db9d33d85255876f740743a6791b40ddeafe841a4fa5428157799a52170ca95c8aa51248ebf6a8ae0bb931e522659924a30b432e755a52531eabde28156b3fc9d669d2349c88945c6a8e0ff6189059e60d5925240d4c9e3e2cb8729b431e4214a2cff57477b06ee855c48abe13345f4e4434860fb6c0def85db6e2a85ca2b9542a9bcfae133544218070f94707295483a03e49fb1a9a8c33e8b79ad21c5c89a5567468a1279e18114ce24201c24a53bad7493cc3638c378ecc19746143beac256bfadc601999f467d751d4d31d22ef446407326c5df45e6c5482bef90ff8cfb18c797ca17a38f7d1e5aeecdfc98f8cf683037eb0388ff0e4868e94a315816c213f47143cbc15c8d6836601bf4825c7b1a52ac1356d76ca073c37762e174db4aa90b03fbb37beee4648471e7913a465fb0c1fe87581b30623be6e38ed9df2a735411685af69c87e8967decb0bd65c12222b7305347b7f19380aa7d96911a1e6bc325e4958545b03241daebd1a7585f7e67d3c4a34a56b2a9411a2d34cb611af76c463810bb7d5454bc50ee7d643a67189a829bde8600e03a1166d3e0243c3e83dd61477fbf4ef56551f73d87ddf0d7ef3a585e734c55c192cfcc9a08acc01d44b60135220b8706d00cf1455bdbf0674377e99feb992250c9c8472ddc757d45f11369e086d36a8da9cf7a231067edd727397b0709189d296413e080ac6d23423b6bb20da0fab286c4310c92b77ed1c9711de796a63469964adf1898898790243658198fcb069b9e7c00296aa3fb2a4ca9b44218b22468cad134736a38349028e0a3f121a60e318106be785cfd6c750375f40b25d6cff78b5312bf9a32045452ae85d7e124fd823eb0f23c96287a3c29c3af7df54615aad9839a849d2435e7f2c34fe83042619a3391def754615fbbeeece62ffefcd9a1ce115467579463c73e5220e39a6857080523febc54ff5346bf55828e585c46d4fdfb5bbb10398c49e1e1cbfdd99805905c3a0dec0071e9b2691e897e6c7d4a4bd26b7602c734084daff46380f5d1bb1b64640d9c3be25f0e3d094e968e869d5d5aaef2635bc63a174c778b7b8a8e30a81b831c53dc1bf282a18fb5e39ab36f5eab5020a720793476141d3acb2c02fd7124be08369dcb302398e7c2d245d3b330f197d16a1099b7eac1987b5db1d4e1d59f7125df4dd9617f7ef9fe23abb5e7a304fc0ec768b00a175250e241aae7da0478fc6bc12709b6d113d75f38b7cf822eab2cd9a3fa471e509670ac4db13ad576c9c3a474ebb9a044e3691790f3da56d25bede11f08b8c7f0fe16d71eb2fc721a44c545f06374deba03a22c80fb7b8ee94dada83fb9c1f8c736b963c2487976984c7a118eede34afc6865c44e4b47cf0e6eaa9142a738f0eccb05821dc71624811f492c298ca616efd92eb0bb68da713b2d945783fdb8a252256130c20547cdd638ff2f998e100cf6562a4a08dc2894ef2cb08f628f536f10760d69bb98560d4fdaaa6407343035e3ed669e41d7b53e78b188d4b7a29f8a2bb033c44e6fcdaac66912ffd3f2194d35bc1fe898516d564f9636e16dddd84bab2b7561f122afbf57fe28b694da89cbafdcf1e9c55b3b5f7b4fe9e1d48837139beb109dc1f1324f404f6f351198925e8c6d5745ef1d966270250170332c6b1a2d739d35687a6487de7defb90d46080ff89653ed0e27db0c564378337e7af5a4c14be9a3b3051c59cbed588d288dda041817177916caba3b234a02dd8e3f3487de0ef0823830c302d9e27d7e4c844e8b9ee2fd9107d977dc4e786312705f04218ed0e9c3ba5de42cc30c6e76a0af9450db40dd733d6e7311018ac9166ff9e883a3a791c9c873654eaab2c71dcfd16bd23510d97f4f77ad47e31e78836c42c42ce8601b96c098452a869f0b5a874780c4d0fdd30ddfd14026e28a2fd66ad5144b8c65645be5c73367967cffc3e6d8d3c447eb0ff45dae9ef9f8576ed9ae3ec79acb26424822f8d39f6405925585670532e688cb74092fe0934af4466532077397d23d29c9941d2ab6a7de36e5f8577a37132d6a0756e37a4b05a1472835a18ce34298de9c51f46ce3a8bed6e9b3e8cc817f2bad58cebee09f9bc5c0b6a134296a84d1d8cffd98186084df824d7d66dbb7a4112829319cc1c131556ee9c39c53f61a174e128108d2c88f9f59876d25d1d3999b71b4bc1a7357c92984d737434747b799dd746ea8d8d3be9fa546eec5dca2bd7541f749f04794317723ae75419f124bc2117b24545cf894f4a36f0bad3ae4ab6ee5936de9a63dca8c0753363c08292a859064c987b772a98f44c2f3fac7abf0e047a4c81dc1249f485f3ad80f4e560d7ebb4d73fa8b451dc73c8f0fbbfa35859cfc44589eb1d3615abe2ca7c0b5de43c4d540f9b8046d6c0c5bf0ed04ea3bfb971dae2353a17379663f503c655ffeab7829a86d97fb5b5c16c03a4bb2d1870f4fdcf2d5dbadaabc4a330e7a992c8b451903eefa50f84f7ed8899dfe23e227df279674a37d17a69a9f094d131de7ffe0441fa2394663683274cc6f5cbb9af59da70da16f573f57697730a820bb48e26eb0481c37fb520f207e1244ff1fe73ab2e99f6234f8341469906be62f07ef7fe70d1c67f6d44dc4bfdde1ed3e9e552308d9c4ee57befcdf888eac05ca0fedcbd3662f761b44462433161dffee141df0e20d63e9b3009fcb714c968ab71d78dc0bd77da0d9ab3c4173a9452b61ac4a4d089f6426f803bf617675f453432ac71f5069812af4e939b2022b2e5243295a05e4e68c41459e6bea413ff038bd1f995d0a4b0c4d8663cefc98df872e40fd899a7476994cc3eeab1c8c133e90b26036d5fc2d069c28a722f69af47cadf225e2f4c57727703b6a24c7a8182145bf4adda8610a9e7cc9f9b952242aa4226353e095d591fec8ab0f88026868da71cf8442b614fc7720fdf452d34631b8758f1963efcafeb9c6bcc91c540160e140ba7e37580960ffcf838532bac0e65c0eb08b9d04bbe86f1d23614f50716d1b2387d4a093bb3d2d351a0cf58ea94d21dab075e7e14a62a7f71c34ff72d901b56c5e20ee48ce76df4afa46e4c322da8946da1829eb4e1de996e0a299e23f7af2c289e992b6f7274a0dc62ffe112584f710e6eddbd73302434b8fb00251fb0dfd8d563d17bc0b9052732f3185942b371583119c8fd87acb16affcc6d323e5e9d7311fca8671a1813ff176901a8ab323fab0c384e56647149b8d677e9bd5ede08d79c448812e687ffa37c5c42d67560fd8129093671ebc2d1418c3e1bea00cb9dc79487a8db9db588dbb22aa1d13e415ee161d84e2f9cfdd0d2c968ac2529d6911478cfb25b96656e56379f36281501a7d75a625f5617cda15d311c3f4b23f215a25e76a92952fd9956fc135577413c82d5591eef83fc2427b93c085a5cc7db402c359e94988b8b76a77935639cbfa597b52f87e55cf72a6ceb0c609dba33ef8c6db586111107aefb4d981632efbc6b2c8373633b6c29eb2539f47e4eae41509fb072fc64a15aade7e8ab090f4fb47c56144ca6153b209c0db8ac816c549d1e6d65a3d7738eaecb2c8f5538ad2bcb564df7a8bf280fb9e37481664caa16cce2b21ccc759cc02955b616340085ab8ac5daa53053191e6f91d521c87f1e6b91f8dde103ff4cacce6fef7ee3e2ba24d546f554034e5b7016fae925f3a96c61a0e26069490bdba1b09e49ae022a36404f229d04e7d463bd4fb2265d1e758cc52fc19f638c8c3a72d4be0e5d80b1ec2dab254deb2e625b8ffe04d07bca9bc383f713ed68591b2668f997185d05349a1687feb2a16daeb14714b4d1d25831e1ee386cee6a5754126fa448525467741d007fc4d7392f775e261ac74e99dfa9b081dd7d9bb3556d4d3c1959c0222942b368192b35b04c90410de86c037e82e1b49ac4dc63c8941aa7e2641edb53b0daf6299fd9db7cbbd5a231a26b276c1dada9593f44b5f456fc71e2630ccf7116361727e5818cad3e1535431e35224fae309ec1bb9e97b21d8e5e827d454824418461d9bd65b791878823586d8fda338592b24283368fa9780bec888de2be79ddff5c4646b70a11934de65f15344305156ae7308705a2f168f781a830fe1c80cf6b163d7b89e0ae3c2fdc969fc95804fc3cb413b24af336ed827747816d8c8a1815dd70fd8d16da2dab1229d264110d351875a936d88727483032daec2a872541b142dbe6a43b0afbf882479b603398ac4ed0f06c3ab63c79651de8c2029e01c9cc08c4b51f85d20bb6ff7d470482149eb565b4d69f7cd8a7b42837be686c7d44d5ca921667dc850110f9b4285abce5fc1aac253caf7e777419d6aef612ef52f6600a72e7d616b7e657e7eb9b42da3d49ae72ee35c4aa4e1ac6e092f0942bd254adfb2873d2438316a235bec965590a2baf0dc34d5a070cce67b579b286ea32c070099bc8c9d04e93e775cea9be998dba2bab40028839416ad06bd5f7e4be4f1a546ea81656feb14ffe6e41fe04260a3a039ec31538483860063920fa7dea4618455fe482bfcb52d12c667e55eb6cbed10028fe95d0412fd76b3849e11ba96dcfaf209d29829653e7155b4895d59fd2dba18cb157db83d9d077d6cb77d667614421c3729e59db78af7ee6f53437c78753dd1d0fff9a3ebfff6a2865d0b08f2b6e1dcec9223cec23008086cc23d63f045fc1a91ee765028caa468bd9b61b3793d80c4597ba38a0882e55bf7eefe0add9c0fa3f0329b29d06c3ab4e8c01cb7b2e4b5bb1d3564347be257a1868cafa6ab121316a5f4687af0e3af63a5ec136a10fcfc177706258bd4ab7f36a8bcf23362b9e7b0a8e2d6610b6f6c7856532fdbc64705a16958f31d689592df211d66410a1bf733a927fa66ed555984599df52aa468805706d2783bb52a16c94d4ff91028dc2c9d3b99e66ef670d06595a46198b08deb541b3654c6d0e58fb2edbba7fc77adf9c244bc711c68eea2f91c31f3eabd01f354951c531a84c5b6e3ca8114202ef09a7eb15d521c74ce4337b39f6963b8fa000cfaff5665e6b0bc0858c04c4b677a884ea1ac9e623aef3234946c960cd7c3b42e815ab8e144dfa32b1c15d165f9e480e9c1de9d0d21bdd43e8634818d6d6689caa852539640c8b6276e69cfc65728ef3cd2bfcc3a649f7916eb4570568a801618ea75a622801ee784622f64ba822dbb113d64a5fabfbc62559f3817118f663067d684491e3bd7a486c2653583f4faf3ebd1c5eacd5ec72eca5782f977e627f0583c07224e7baaea0f0b9d85c552ef13ee367de3e5831a2da078588058916009573e455a70c92a4a105f4e70b8dcc22bc10f98d4b6b2bf7e7d7c034c18579038c90a1c686e6ae11e3947d15fc09fc935ae29597dae8d645bb379c611dc9e5962c72f9b38e195d50ff545f718c86a4ebb8f77ca2639a08c45650de9fa88c70e18d7072c319021563b965fac14e90377cbaefb387468d4c3481a015fe094a056a99077765d32fd3d0e309b8dd30f2397c85453ee45a15c14d7957ebb8883db2fafd9cc3e4bf8510825070c1c3c4a6a5caa5025e6e54560b17605a5bec3809c5f58f2e505430db9dc11884b8452becbf3d801a034eeddd01ee6829870884f11c41dcc7698fdb1794ac6092f184082d7801e6b8aa44d66ec190e9bd6d96894eb50b8ecf48778df4cdde705051f76511529069717fe6ebfe0c192a3fd7e3f325282c1ef27a8548ea819f41f901be42a50034fd16dd0f4a7c9007f34156884a070f40acf8e26b427ccdbae5e52b76615f0f35fadb47a36fe99c8d22e24838a9428e486100f5d21198316380190d6df9ba33230700c54a5849ef3a3b5794c4a849b5279b28f46f06d6d822ec3dc041b4801449cb99a456913126f1417c64a618f39fca5fa326b310911833530a994c93e38feac44d835bc3afdee794505d4f4708fd88a2ecbe5eabadde58db4a03a8481519981177c8bd49c177a91fd26f60e76cd26c3ac7f1f7d00c2f2377f42116b275d823adafc0f7f362e60f9c754755b0e271dcf739b313e0e23c791d9ed590bce381e40b2ad74a796f6975ea7a844efcaafb082a030801302a898849d96f7bc6dfdb83382f148befac22dc0f40cefa40fd1140faefd57314f3841e5db542861467b3ffdd62b4d89f71143a2d40bf420e755b717d45c4821c3613e7ca8c177771709f28802e2edb03cf82fc3720c6deb4b8baa28c7f86590af148464fdaa7c2e03497ef62aa27cb71a078b3669acc55586075aa3c2e3d000f7e0704cf159df327a6a7bb647c7978ef94081c3ff640996eafb231221a4fb120056d62f3545f8577b17411fabc9f280f556301bf09d3ee7fe276326fac151724af2f0b83892f4cbbaea86bbc923c6ce47b78e81c19dd62142871769755862f4b27c8240642a80f75817e6a41f6f1d6892bc91af0c0ac159b8cadd71d8fcebc3ba1c57b4b0f4e37c269239091c50ccd2845e6d9d157351ead574374fb358dbe98974c7b93cfe8fce011116d3e64c0fbd8ac945a040009889bb77edd3a58e88b5068a95fb4fc63f9ec2e57376c936bbbdd9db5ac1e9006ed24364a026845eff2e8a3b7bbafa51b20382b7b031a6d1d32ffa70b4fbba9664fc9bbdfafb0ee9a131456b8c1d1d4fa0fa57f9315d8b019e46574b00fa9d1f6b5182e3ea9571a6575191dbd7ba48c2df0ac849c06b01f99f7ece72b9418258db3350ecc6581a49b279fc46589ebd256214e817d5206b4a0407c5056539a5a94cc9909e50535d971d9a994b366a9cf61bea8397e0adeef161e3833cda696d64bff34681d0c1a7599a97532d8047b391c2fb01bd195f6979d9e6164504afaa02d36605f541d56a938b6362017b24d56fb8df16c9dc6daa6cd2d23227d8618febf07da833e52b1ec6f69d632d6010d419fc6dedd0f127e6b38be1748711f26706b8990111c82e03e34dabd131a7e9f8a1690634986c47099201e7a8f5573ca180d10b1d8f7a2d244585f809c17203f99d3f80a89bcf532dd0fe768b9a874d0fc3b8a0da4ade591156ba12d542d65404ed814f9560ab23088eb82f9a6d888f72836bea4845ca622b148c871bb6a2b94db5f743d9381b366e427158f298c6ed37e3fb5da6bb82cd762653424e64bca1392df12872d8cc6110513752d14cfd58d773f74c74d99691ad706de3d5b19d9dc6185d249e97c0ead78022845fef2f4b9c3765c6a02507e662b1791c1de8d1d919d1265b6c691016f7e778fe967f50671b6d674b5c09d19971fd5836b749d34e85ea15670ca93faa945e440439b0ca3f0a117707f2587e65cfbb23b01c6b7f22b82f997162d3ba7953a925a4702f3ed1cfea175b3924aeb6a52534f5aa2c5be51f031d0e0ff0442d01ed8343f78b2d6249c8e3f0472b72e632e5eb7c9797480aa6fbdd39c044cb5818c5a81acdf8d5d9635966310b37d6c83845bf0d7178139532d399db7a63fb5442a9bae05abe414dfd6ee00578c8271c00886a423642d4e75eee59ca94b368700a7fbbfe1570e575d8cc0145bc08e0ef56d8e8e3a5680a7d3855bdfdcbc8780cb438bc9b9aa378a8cc04ece4a4150da1f4601f05fe11e12e0f458496834c36bce2866145eee3ec1626ef395dd78684c092b7d09dacb164983d0b2bd7b47c46f314ec49205fab066209badbfada7793312d3494e8a1a6cffc831cfd06816d58e075cb225e67ba38aa6237fddd1d4be80c9cca9be3c5ef03cdc7ae4bf5431de3ab053cfb2991b1fa7c1f674bee510c03fd61ae016848eb7d60cd0ebfe574124e0a8185ddbd146e63add48fc2ce541b172291ff248ed34e921eccd700fe4a5126ec092b0865786277171f66b04db22ef5c23a01f1fae435c23e36b7eb64e5132646da4287d3b76afe0b2a0c33ab9e234f56932764bbd562a7e58ef1f4c9a81b12831d233cf693dc6d195743ba5d050cd75914b44c08c267c4532c95231cff230754f4fa7cfc15ea28fe243afa0e81f909cfac8b9e402fe2b3ee3d31d91dc1902bbe0498bcac9f1dccffcf059aae831f9977d869efab4d6ad761d83663702d9ec29072952fbbd8237e0dc608ccc7933530f2a9a894bd3525b5ff2705ff52fbc22ac480547ff309309fb7790bc64c66dd93a78b8c9c789cafa61f265d1bb0c93579efd2e6df2370bd7324748de0f28da8f69341abb7ef51edfde21be7eda4177d50a5ba1e847a6594e1ea9feffa7825274f1d46cf2ffb3947d3cd0624edce5e0e33bd50813bb10918d8c0460a5d1c60940a624423896dc0041cc1f9172d1914312c1b95991c1ef6bb4de9647308c2251d70d8ae7aaefd2f3362a019d0e4d2ac228c537e4923698b46cf789281d20da53edf735f2397da8fbce92f22f07331267c13d8ad5379dbf294618b594fb5315962df3f060bd23dd8aa0d5e986d4d7e2ad1ee12422758efd931933258fc32ee84f3aaf96eabd7ca30d34994a58a53e0e355115e6c88d809d99cff5416c0728c3c2df50f10700cca7ea3fc16361a54e408c4385f9ccdd1836dbc6c750441683537c8f2014917225349ff0a4586490ef577a84d9ff34bb4cc4cb6b909bcede9d8127cdc7472ce2688f6fa43259b4f85c5146ef79f0c00d61996011bf4e6f9b8d569eadc0a38180f5a6cedac232a99bb254f3845126e5592a6029627876ec12a8b036961fd49fa941546323fc139365d495418c8ed9a6971bc284e877a2972980c81d7f65274e66f85b39c9d28336dbcf260eb0b1b2abeab685ce996f2a59016ab2db6eef547ade55ecc688a5a702f2519c0a3ea1b167b39d75ae4c0ab179b1e6a05b5aa2127116b813ce1593007724f7774fd62fe89cece126f2d20b4b220195e8fa79200d201e5af82102222363fe4bc8f64ad7c46872affe3de0f410eddb4c5db4180c4e3c3b385fa07e29dea90fb8033845bdf671af66fe8b169fe0c0a553a691fe991c40d7e4861bc802edf286d863042133df7e7513e55ce5a5b446a2318d1cdd5f823db63063df5325b3b2b21cecb0dc8315b46c4d165378cd234384ace9e15c61e026e082171dff1119de522754256a38590b7e059dcbf5289a245dbd92be08ee0d055a726743adf6920421d3af737f1e1258a3486b3fda6aee5d66eb5bf4d9bd950a8a73fe86d00fcbbeaef7c0aaaa27c37f9427bd1343a5ff4099ba5e277c1d30b92cb23462fc4ec992c5ae287374a2b5e143f24912f42f3bf4322d8af7279ae5c18bee61948e38220712c0f4a515e7a98f8081ebf172267a38434f663c684a810bfd31ebc7e8394897bc215038a0cad0703064efb4a75fcec09107d079c2589d030de41d3bdf1c376658fb1647e93897dd0b2977e2d9b24d558826f95e556b7c1704c4cc54d535bc43762ea29fba2b43434315d6fb17ee4a79eb66e88a4eacbb90a6cd2239a0a524efb5c3d0914cbb50a0f2fcd0e0940da02834780c6cfe21bf10951721fc72a3de040673b7b1f1a952bf8a935a39718af7f0a19b3ad89c721cd4687e67ba6365d451859f35f63e3db598bfedeac43909e136aa44c89107c3c637b57eacf7f4412def7091c9a4019ea561ea661069721a8e244da8fc61c322c1b05117f74a0f8d1ffa69b8ff41054477b84ce174575129008245470e06328e734d4b1bc29219914a6a22e9ad640ad336806f4a3c15433034fdae750f076e62478b0dafc516d933d1880ca9b4e207cd545b315ccda6637b377fe8f204ba9942ffa72ad2f84532993afb4ec0f217b3515f650af32774fee7d33d73c4e92839e547976c3a0e2c3a4eff9468b6f3b7d1deedb43b30cc97ac6c7696c78f962cb1a11c05963ecf1ce2fb45bd7ada7ffd4d3a63b54c7426056b24dd4045bbfcd4802b0119b369d1846c0fa744e872819cf436cdc9111c3d45ff1a89818cb5e3f7ec0d56a471368e57cfcb3ac68c07761dcc36f7ab74b450c3921e09d8d350dd3123b1f5659ebd1ea638f600abb3a2d305fb5963d7518c24fc13d76fbbe22c9021fb78e5e549f39a509fe58281a065dc52283664e85b9846e91345f3bed7abcc9ce1380280529806aadd27a3d464287089c94d369913aa1340e2bc0bd3fbfd7fe10c41b48cd1a82412af7b1073183a78b6b12f00fa1665228dc26e277afa65be61a48e222943e695b64c881ab05541aff41177055255779701165de6921028ecec95c90849fc7f6b41ecf89acd10d1454048eb73d8dff9ae8e46d8abc70a19ad756d942d7b574d0f4e2904161511b43852e909ccf0da2f9f1b36cee2af42f72441195cfee50b5dd10a612e4bfb29a6446b120058254df481db325432bc296298c7b405ff344b2cd9843553e50803fc31edb06db261c40c28a73641e46b865dbf47c94f5f0e79f4df7a404ef5c8d20aa8b177477b67793cf49eb8c004a168684ce54294ece1a08a170650b792ac94ec620a31d324c7f0d89f4ce30621db3c0038bb593a7841c3e6d120e4d4a1e534f8125f71b86b924d5fb760c8b99596c8b29d5b2fe9e69232e6675cde38f4eac901e648078d8ef505d483d7bc49769ae2379542211e4df41674e093103938388d604c05ebe4901dbdd879c67481832af5282ec44a4858ed207679f5b34bf5f826775c8e26cd10ea631c6f08ea4431e2708f06e121d27bd3d0c2a0a4e3396e8d65be4cf961368a29533d18e4f5734d90eee7a2aadc47d10f040cf747d2c4fc0d0f6baa4738b70cdb7185979d9ce162fe50b37f55549bd923bf2aad1dd190e50fe11d434287ba76c0aaa18552d58004b3aa9166eb0b139b594756ba7abb2144d4eb4c96d2188922fd35bbde5fb38625f27bbb9fa30ce2a20800711598e587d9dbcbef87781aaa8aa0cd5e2fb7eb9af9831065dd20fe59e7ab5d21b8144cd6917a3b015052daeb2a036965ec40b5e8768bcd368d3ffe0129d7f894410e1832c551faf6ec60c218298cd97f5260dc53cbacba9c420f1afbb723934121150c46ef79596ee3364bb3c2f865530fa87ca041d088dfa50d3776025f003d9e5b89a2d5de870ced7f14cae98da0a1bf40be3afb1408f69ccd8f7ea2a224836f8e35b2eb47eb220a9a3e60621eea0ace9ad00aa1047277470c5ccc6f46818167deb9a609b8833627f43da9fa5eb2f6ca230a9c1ed918aadfd7ce99ecf2dec9eeea23618cefb6df94c7a914b3be7b341a03dfdab9a3af8194dc801e01b55c54c21ccd8f0c493579e5abd057a0e36587f3938aec31dc763c4b393932cd4be19a401ae67708617b27f53d08192bd25911dac1c1cae3844eef283868d85528fca2023798564a0c6d7d95e4d11540bf1c36c3e4ffb041a938887a96e9740bf701d41e2ed69b2831b7f9986e4f753906bb7a0925e23a038adf3da09d888aba48ebde5b9c7492d95fa1f540428a68a3e9ea50d909255dae563669a12cddec2970dd9f6061a0115db9079d956fcea36be44692e29a803900c81d9da6cbe92469daace98c0d9197fb6f085f888a43a3833080873c0631f7e61f1fad4c7bbe56177fd1b5ab67f1ab5b9c739617b07445c35a9b26edd4c4a41872e46add3c4852bfc4d938531b90125719f58ee759e43c79d710ebe6b1ec6d857d5a1306b1cc9f32e5621c56ceacb735b13b25d18100c17df8812d12dd55f0abfeeaa838cfb42bfd6245d1ba6f9c155293223bb1595fe0f4ce5a282e91570a09b5caabe31a43fd17c9c8d610706985d9899758add080ff57e6a949a1bb28a1634d95acdc7a549a2497d917b97ca03976114eeeb9170574b70e8bd4b23bd4cfbca5ddeba714bc7834164d093c28e1945a9c8e126cd355075e79d424ce48b9d9d1224fa72836d49e3cc69ca488076fcab4ea7cdf8a2cd85068d3728d7f12029d345dfe8bf10e6c5af245cba4313e0573e1498aee76e2e66d374b9049ab40dd9cbe2a90cc1a8227e37ada7e4f0ed07b5d07987c3500f5bc5182245199c3539c3ffc19b35ec71cbf343e6669cb466042ce7c41093327eaf03f8233a186fc69b03bbf9bc5d0fb18005c7c94e3306d1edb80b07b636c193005f396842e9db9bb140a1f7bfa305a3c5963fbdfbeb0f6e18237ebb543439d5461aaf4b20225be04a50dae370fc47966aed4c779a1a561345c2d1cfc858b5bc7dfcb583c6c792fad6eef5ff992a771b154ec73c17b83d7782326d0f104b5b25d4fef1ede335134c79abdad2bd544b1a9be4ed60b237f01069c4f43587e6cd6a046c80c786208a3d4121f143b71b6318faab295d6efaf5f2ef26cbf041f1635a1ede433b22b1c37c258ebae18043a169eba754b1512075878f0fcad5adf7d5a2668676cb99284142d6bb9a40e2cac43fd4504bc4b83436518cdcaf5b55dcaa9f273abb0ebfe3f06483164ac91aa5782de3c99a5ab7db5483d1b2f82b27119cce2215c4ad1c6f4a9adf51e6ca3516580c36143eba0769e36b5479e25f4b4fd9864badd96c1b5ceb7fd372bf79e2d155b1fa0860a7637a4e130bd02c0a19d125e15319463cf14715c8b4fa67dd1efe09abb778cabafc9283c5b4dc3138db0d728e9d09f35919a10c212663d0b5c7f7c4a01760caa52cc124611ac0c276ff0160360b2f64430a3f6c4021afa0559aa0f304b1be027eea700b48feae5ce7ea25b06bb9fc5e43acdd1f6f3c6d8708fb953758688d94ae71247784d98cffd64809af4948205e1018d44c0996cb8d73d0a112db8b338d8ed1b2410f3fc9debb646dab57914d20591df5f13bfad7b55e0a8f2f114c2c2668755ebf052d0f9f9087a393dfc00f5af69d19294494db290d64e1e41510573fb0a7ba4bdce0ce129c1f83d6e20e36bb7da5ab5bd8cda6c632346c43153824a13928b4573af72ef521a49aa4a10e2e6f7ce600f2ff7905256528bfef38761cf6d47ae26eb8f4f4aa47f9e05427b2cf2cf408814c555073820c3704715ef27a11e817c04f660e843ceb387a95ccd307082b32e9487191eb23abedba4e9b54d3a31c06ca3fef8d458e48021d6f49a48cac6c209911bd0e931c47261e55e2c03639358314f459069ba1bf2855428bef53cedba315066a658c0c6b74b9ece99a4522f407d20e81145be4e255b94b6af47da556e05f52c1b2fe6174f50eec1fae60063007b313ad59a22557560869fec134dd73328edf1ce75fde8d2983b8b42349926e497c032c6dfeea0aa38fed399c2bcbf1872e3de26f59d295b674bbfa8e4214afeffa907db709df48e06ce3a53499f9be6c2c256182e8325776d50cd82716d05745b398d6c688cf47b45d58bc21f486d13d0e8421c7f9df9df431593ef8e9a28713b48e6e6a4170fffc3bc3b9af35608ac0380628c4f836449d2d76e58c3f54a134615808c2023f8c7fb98154004e55a0cac1c088b594fe84293cd8ed51906805691315ab9a93bf641630ed213ba9da34f6ce80b50ea60ba3926e2adfe00b03cdcb0c7239060a1e77d5b459143eeb985f227821c950ca59055abfa1417d59183925786e2b99a25999b6a4885f5a2a9661f7d7e15758211d27c608dfb16e9db12bacf73ad9a69b37739e2d33878c9863365b5dcbe7d89e79740a714e24b30b23c41a00ac853091594044ce3556f774ea840c694e1e67b2578ae0ca71374baaaea375008ab11962816d372692498e54e91af64fb2e1a75a08ac4370190eb72a845475634aaed7b1d1676d8003cbd4ccc5f767ba675324e49fc3f322a7bd82c11190fb314cee331f36ea48a5687fc3b2984df82cd1086fcf5e8327c570ae839949a3d4222101bf5604b8560996d2de499cfc59b18a49f43f472f6f00f71196c6e635af05428ddae6a098a4eae3e8c713edef1bfcf859d1604434d8e0ece0c4d9bdfa8bfaa2dbb7432dc10bcca5dce76afe9a04aaf2336be3a112c5314a2eaf1ccb4c90ff6c8aef925c030bdb91b214478de233f030c66d48b2da0a62eeb698a6c14b8f5fae4375e484625aac6a52d040e11eda10377e0b5a5d749d3ea4e92174a8fede10771cf9b348534f6f881ea24ad88d243506ccb0a3f8efbf15f121bc4a8b6f5e58e695cec2f7563526f32710c0042b5253dda29d7ae3b4006d6f5ed0533308ed3a56f5a7a56e31f04f0748a6771b3c18224939fa0f0192d72df6e5d0b45ca6a5e0bffd683683355eef4c8ce0f0d07f8b0e008fdb56fce9ea9ed980f4f32ae82112f555f95c23877c0b90adb562e763567a3c7f175036f2b0f6a5bd6b6133a9a733d0d7bf66259ec642ffd254dd3a5169e9aab7fbb45c1d0233e76120329c467f067ba8d2a533546a74c022ffdecf7f3a03c6d9a7cd7b2f2abea1495d0ec71591f6d713a9d7a5fb35c902617ad62b48e66e51f00a3d7e614b61f3e449af7e4afcecc9949ed8d423aeef04a59fb7cf532761e0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>web开发</tag>
        <tag>赫尔辛基大学</tag>
      </tags>
  </entry>
  <entry>
    <title>研distance——408关键问题辨析(已废弃)</title>
    <url>/thinklive/25833/</url>
    <content><![CDATA[<h1 id="计组">计组</h1>
<h2 id="概论部分">概论部分</h2>
<p>问题：</p>
<ol type="1">
<li>硬件系统的五个组成部分</li>
<li>指令和数据怎么被cpu区分</li>
<li>控制器怎么取指和译码</li>
<li>三种语言类型，汇编解释和编译的区别</li>
<li>硬软件逻辑功能等价性</li>
<li>计算机的五级层次结构</li>
<li>指令集ISA是软硬的界限,是一种接口不是实现</li>
<li>以c语言为例，怎么最后得到可执行文件</li>
<li>ALU,CU,IR，M,MAR,MDR,OP,PC等组件是什么</li>
<li>相联存储器的特点</li>
<li>常见性能指标，字长，数据容量带宽,基准程序等</li>
<li>存储，数据，机器，指令字长分别是什么</li>
<li>提高cpu速度具体机制</li>
</ol>
<span id="more"></span>
<p>Tips:</p>
<ol type="1">
<li>冯•诺依曼机基本工作方式是控制流驱动方式</li>
<li>地址译码器是主存的构成部分，不属于CPU(但一般现代cpu也集成)</li>
<li>MIPS:每秒执行几百万指令</li>
<li>毫微纳皮mμnp：依次更小</li>
<li>MGTPEZ(FLOPS)；浮点操作次数，依次更大，M对应10 ^ 6</li>
<li>固件：固化于ROM的程序</li>
</ol>
<h2 id="数据">数据</h2>
<h3 id="定点数">定点数</h3>
<p>问题：</p>
<ol type="1">
<li>BCD码是什么</li>
<li>浮点数的本质:将数据分布得更散，但不会改变一定二进制位能表示的状态数上限</li>
<li>补码，原码，移码的转化，逻辑移位时补0还是1</li>
<li>进制之间的转化和舍入</li>
<li>一位全加器，串行加法，并行加分器等原理</li>
<li>进位产生和进位传递函数分别是什么</li>
<li>4种循环移位</li>
<li>几个标志位：OF,SD,ZF,CF</li>
<li>PSW和FR是什么</li>
<li>单双符号位，进位怎么判断溢出</li>
<li>原/补码一位乘法</li>
<li>原码除法（不恢复余数法）/补码除法(加减交替法)</li>
<li>乘除法最多运算次数</li>
<li>c语言中数据怎么转换，填充和截断</li>
<li>低位和高位，最低有效字节LSB,最高MSB;大端和小端存放</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>ALU是由组合逻辑电路构成的，最基本的部件是并行加法器</li>
<li>数据总线也是运算器部件</li>
<li>模4补码更容易检查溢出</li>
<li>存储模4补码只要一位符号</li>
<li>补码一位乘法中，最多需要n次移位，n+1次加法运算。原码乘法移位和加法运算最多均为n次</li>
<li>原码不恢复余数法最后一步不够减时需要恢复余数</li>
<li>阵列乘法器实现的乘法指令比使用ALU与位移器实现的快</li>
</ol>
<h3 id="浮点数">浮点数</h3>
<p>问题：</p>
<ol type="1">
<li>表示范围</li>
<li>规格化，左规右规分别使用场景</li>
<li>IEEE 754标准的单双精度浮点数(32/64位)</li>
<li>浮点数的阶码全0全1特殊含义</li>
<li>加减操作过程</li>
<li>舍入方法的优缺点</li>
<li>溢出判断</li>
<li>为什么用移码表示阶码</li>
<li>为什么基数影响表示的数的分布</li>
<li>各种溢出都可能在什么时候发生</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>阶码的值反映浮点数的小数点的实际位置；阶码的位数反映浮点数的表示范围；尾数的位数反映浮点数的精度</li>
<li>对阶将较小的阶码调整到与较大的阶码一致</li>
<li>对阶是将较小的阶码调整到与较大的阶码一致</li>
<li>float保存24位整数</li>
<li>浮点数的加减运算，右规不会超过一次，左规不会超过n次</li>
<li>阶码上溢可能出现于运算完的右规或尾数舍入，下溢可能出现于运算完左规</li>
</ol>
<h3 id="存储器">存储器</h3>
<p>问题：</p>
<ol type="1">
<li>串行访问存储器怎么分为顺序和直接存取</li>
<li>DRAM的三种刷新方式，单位是什么</li>
<li>存储器芯片的组成</li>
<li>ROM的种类</li>
<li>主存储器的构成</li>
<li>主存访问过程</li>
<li>引脚复用技术，及其适用范围</li>
<li>多模块存储器的种类，运作原理</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>Cache内容是主存的子集</li>
<li>存取周期是两次访问存储器(读/写)之间最短时间间隔</li>
<li>主存一般用DRAM,Cache一般用SRAM</li>
<li>DRAM芯片的集成度高于SRAM</li>
<li>地址复用时，地址线减半，增加两条行/列通选线</li>
<li></li>
</ol>
<h3 id="高速缓冲存储器">高速缓冲存储器</h3>
<p>问题：</p>
<p>Tips:</p>
<h3 id="虚拟存储器">虚拟存储器</h3>
<p>问题：</p>
<p>Tips:</p>
<h1 id="操作系统">操作系统</h1>
<p>问题：</p>
<ol type="1">
<li>四个基本特征</li>
<li>历史演变或者说分类</li>
<li>内核和用户态辨析</li>
<li>内核的四种主要功能/机制</li>
<li>中断异常的具体分类</li>
<li>主要的系统调用</li>
<li>5种结构</li>
<li>引导过程</li>
<li>两种虚拟机</li>
<li>机制与策略</li>
</ol>
<h2 id="进程">进程</h2>
<p>问题：</p>
<ol type="1">
<li>进程和线程，进程和程序辨析</li>
<li>进程和线程的唯一标志</li>
<li>五种状态，生命周期</li>
<li>PCB具体内容组成</li>
<li>怎么通过PCB管理进程</li>
<li>进程的三个组成部分</li>
<li>对进程的几种操作的执行步骤</li>
<li>三种进程通信方式</li>
<li>线程独有的资源是什么</li>
<li>分类</li>
<li>内核，用户级对应关系</li>
<li>线程库</li>
<li>多线程的映射</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>PCB内所含的数据结构内容，主要有四大类：进程标志信息、进程控制信息、进程资源信息、CPU现场信息</li>
<li>进程中某线程的栈指针（包含在线程TCB中）是属于线程的，属于进程的资源可以共享，属于线程的栈指针是独享的，对其他线程透明</li>
<li>父进程可与子进程共享一部分资源，但不能共享虚拟地址空间</li>
<li>二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时使用的变量在数据栈段</li>
</ol>
<h3 id="调度">调度</h3>
<h3 id="同步">同步</h3>
<h3 id="死锁">死锁</h3>
<h2 id="内存">内存</h2>
<h2 id="文件">文件</h2>
<h2 id="io">I/O</h2>
<h1 id="计网">计网</h1>
<p>问题:</p>
<ol type="1">
<li>主流定义</li>
<li>硬件软件协议；语法语义同步</li>
<li>资源子网和通信子网</li>
<li>边缘系统和核心</li>
<li>主要功能</li>
<li>几种分类；拓扑结构有几种</li>
<li>三种交换方式及其优缺点</li>
<li>主要传输介质</li>
<li>主要性能指标，时延的组成</li>
<li>实体，<strong>协议，接口，服务</strong>，SDU,PCI,PDU等概念</li>
<li>OSI和TCP/IP异同</li>
<li>5层参考模型中每层的单位分别是什么</li>
</ol>
<h2 id="物理层">物理层</h2>
<p>问题：</p>
<ol type="1">
<li>物理媒体的四种特性</li>
<li>模拟/数据信号及其转化</li>
<li>宽带和基带信号</li>
<li>信道的三种交互方式及例子</li>
<li>计网的带宽指什么</li>
<li>奈氏准则和香农定理</li>
<li>编码和调制方式(均为4种)及其简称</li>
<li>采样编码</li>
<li>三种交换方式(物理层的，不要和之后搞混)</li>
<li><strong>物理层的</strong>分组交换方式的两种类型，及其优缺点</li>
<li>几种常见介质</li>
<li>两种常见设备(不能隔绝冲突域)，工作方式</li>
<li>网络和网段</li>
<li>543规则？</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>虚电路可以是永久的</li>
<li>基带传输常见局域网</li>
<li>宽带传输可以多路复用，划分信道(基于频带传输)</li>
</ol>
<h2 id="数据链路层">数据链路层</h2>
<p>问题：</p>
<ol type="1">
<li>提供的3种服务(确认和连接)</li>
<li>主要功能</li>
<li>基本单位，及其组成格式</li>
<li>OSI和TCP/IP中功能有何异同</li>
<li>在差错控制中需要解决什么问题，使用什么机制</li>
<li>传输基本单位，有何特点</li>
<li>定界符的4种实现</li>
<li>检错(2种)和纠错(海明)编码</li>
<li>该层内流量控制和可靠传输合一，其具体机制是？</li>
<li>自动重传请求ARQ的三种机制</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>正如字面意义上所言，传输数据奇数时，奇校验检不出错</li>
<li>为了区分正常帧和重传帧，选择重传协议的窗口大小不超过序号范围一半(即 <span class="math inline">\(2^{n-1}\)</span> )</li>
</ol>
<h3 id="介质">介质</h3>
<p>问题：</p>
<ol type="1">
<li>信道效率的定义(计算)</li>
<li>多路复用介质的四种方式及其简称</li>
<li>随机访问介质的4种协议(争用型)</li>
<li>CSMA的全称，或者说具体意思</li>
<li>最小帧长的确认，单程传播时延和争用期定义(<strong>与帧间最小间隔不同</strong>)</li>
<li>二进制指数退避算法，适用哪个协议</li>
<li>CA的隐蔽站问题</li>
<li>802.11规定的三种帧间间隔IFS</li>
<li>CA在何时使用退避算法，具体机制</li>
<li>CA的信道预约机制</li>
<li>CA和CD的具体区别</li>
<li>令牌轮询机制</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>码分向量利用的是一系列两两正交的向量，其内积均为0不会相互影响，因此可以同时传输</li>
</ol>
<div class="note info"><p>没什么用的冷知识：</p>
<ul>
<li>ALOHA网络（英语：ALOHAnet，或ALOHA），世界上第一个无线资料网络，是由美国夏威夷大学所开发的实验性电脑网络系统，Aloha在夏威夷语中有希望、爱、和平以及幸福等意思。 因为比较早所以协议比较简单，不觉得这很酷吗？很符合我对过去科技的想象。</li>
<li>话说这么多碰撞的协议怎么传达爱与和平的意思啊，虚假宣传</li>
</ul>
</div>
<h3 id="局域广域网及其设备">局域/广域网及其设备</h3>
<p>问题：</p>
<ol type="1">
<li>定义/特点</li>
<li>介质访问控制方法及适用拓扑</li>
<li>常见拓扑</li>
<li>两个子层</li>
<li>802.3标准(主流)及V2标准</li>
<li>MAC地址结构</li>
<li>MAC帧构成</li>
<li>三种高速以太网</li>
<li>无线局域网802.11的拓扑，协议</li>
<li>AP,BSS,</li>
<li>有无固定设施</li>
<li>数据，控制，管理帧</li>
<li>相比802.3，帧结构</li>
<li>VLAN的定义，划分</li>
<li>广域网常见构造</li>
<li>PPP的组成，与HDLC异同</li>
<li>网桥和交换机，类型，记忆机制</li>
<li>VLAN的划分条件</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>广域网的连接是两端同构的</li>
<li>越底层的设备理论上传输时延越小</li>
<li>广播不会涉及发送方的端口</li>
</ol>
<h2 id="网络层">网络层</h2>
<p>问题:</p>
<ol type="1">
<li>路由器的两种功能</li>
<li>SDN的定义，南北，东西向接口</li>
<li>什么是拥塞，常见特点</li>
<li>两种拥塞控制方法</li>
<li>路由算法分类</li>
<li>距离向量，链路状态，层次路由算法</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>网络层开始才有网络的划分，不同网络可以异构</li>
</ol>
<h3 id="ip协议">IP协议</h3>
<p>问题：</p>
<ol type="1">
<li>数据报的组成</li>
<li>分片原理，机制</li>
<li>三种地址，特殊地址含义</li>
<li>NAT技术及其三种前缀</li>
<li>子网机制和CIDR(路由聚合)</li>
<li>转发和路由机制</li>
<li>地址解析协议(ARP)的作用，缓存，过程</li>
<li>动态主机配置协议(DHCP):应用层基于UDP的协议，工作过程</li>
<li>网际控制报文协议ICMP种类，适用场合</li>
<li>最长前缀匹配原则</li>
<li>IPv6特点，过渡策略</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>如果分组长度超过MTU,那么当DF=1时，丢弃该分组，并且要用ICMP差错报文向源主机报告</li>
<li>没有对应转发表项时，nat路由器直接丢弃分组</li>
</ol>
<h3 id="as组播移动ip">AS/组播/移动IP</h3>
<p>问题：</p>
<ol type="1">
<li>域内/域间路由选择</li>
<li>外/内部网关协议EGP/IGP</li>
<li>路由信息协议RIP</li>
<li>开放最短路径优先OSPF</li>
<li>边界网关协议BGP,4种报文</li>
<li>组播机制,地址，数据报特点</li>
<li>互联网组管理协议IGMP作用</li>
<li>组播路由选择算法</li>
<li>分散响应和抑制机制</li>
<li>移动IP的三种功能实体，工作流程</li>
</ol>
<p>Tips:</p>
<ol type="1">
<li>组播机制:让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机</li>
</ol>
<h2 id="传输层">传输层</h2>
<p>问题：</p>
<ol type="1">
<li>该层的复用分用</li>
<li>三种端口号</li>
<li>点对点和端对端</li>
<li>UDP的两种附加服务</li>
<li>首部格式</li>
<li>校验机制</li>
</ol>
<h3 id="tcp">TCP</h3>
<h2 id="应用层">应用层</h2>
<h1 id="数据结构">数据结构</h1>
]]></content>
      <categories>
        <category>考研笔记</category>
      </categories>
      <tags>
        <tag>研distance</tag>
      </tags>
  </entry>
  <entry>
    <title>恐怖人偶剧场古兰吉涅尔</title>
    <url>/thinklive/57068/</url>
    <content><![CDATA[<h1 id="来自20世纪的妄想堕落与疯狂揭开恐怖人偶剧场古兰.吉涅尔的帷幕">来自20世纪的妄想，堕落与疯狂——揭开恐怖人偶剧场古兰.吉涅尔的帷幕</h1>
<p>二十世纪前夕，巴黎仍处于科技革命时期，经济文化迅速发展，拥挤的贫民窟，纸醉金迷的上层社会，工厂里挥洒汗水的工人一同构成了近现代欧洲最繁华的城市之一</p>
<span id="more"></span>
<p>此时的巴黎市民中流行着一种简短的犯罪故事新闻，包括连环杀人案等骇人听闻的恶性犯罪事件，或许可以视为早期的都市传说，一八九七年，一个消息灵通且头脑敏锐的小报记者捕捉到了市民们对街头犯罪和底层人生活的兴趣，于是他买下了一部废弃教堂，改造成剧院，命名为Grand—Guigno，古兰.吉涅尔<br />
吉涅尔这个名字来源于一个木偶角色，早在十七世纪，意大利的即兴喜剧就开始使用木偶进行演出，一个出名的形象叫做普钦内拉，传到英国又发展为潘趣和朱迪两个木偶形象，这些木偶形象属于集体创作，木偶艺人希望能吸引大人们的关注，因此加入了不少讽刺社会的内容<br />
在法国，也受到普钦内拉的影响，一个底层牙医(只会拔牙)创作了吉涅尔的形象，法语中“guignol”有侮辱性的意思，意思是“丑角”；但相比其同行，吉涅尔更有反抗精神，常帮助底层人对抗不公，是正面形象。<br />
可能是对底层人民抱有同情心，也可能是看到了商机，古兰—吉涅尔就这样诞生了，直译可以是大人偶剧场，用于演出各路社会边缘人的真实生活，使用guignol的名字，可能正是为了表明这座剧场对类似吉涅尔形象的底层人的关注，但和名字不同的是，剧场本身不演出木偶剧，虽然演出可能会用到人偶制作的假人，倒是后世部分剧场粉丝试着用木偶剧来演出古兰式的恐怖剧。<br />
古兰剧场有着部分哥特风格的外观，位于巴黎一个偏僻位置，此处犯罪猖獗，没有路灯，内部空间狭小，更微妙地是，还保留了原先教堂的雕像和装饰，使它充斥着阴暗诡异的氛围。<br />
初期的古兰剧场有着自然主义的艺术观，自然主义可以被视为现实主义的一种更为极端的形式，现实主义关注现实中可能发生的故事，但创作中可以选取合适的视角和时机营造戏剧冲突，而自然主义更进一步，提出将现实生活赤裸裸地展示在观众前，不需要进行戏剧化处理，古兰剧场把底层人的贫困生活还原到了舞台上，在当时矛盾日益激化的巴黎，这种创作方式着实引起了官方和民众的注意，剧院一时声名鹊起，有趣的是，其中有关犯罪的剧作人气明显地更高。<br />
在一年后，剧院于 1898 年(一说1899)转交给马克斯·莫雷，莫雷继承了自然主义的创作观，并将犯罪故事的主题换成了恐怖故事，这可能是基于现实的恐怖创作的先驱之一。与流行的吸血鬼狼人等怪谈不同，莫雷领导着剧院把目标放在了疯狂科学家，心理变态，连环杀手之类的“现实”题材上，这些题材不仅刺激感官，而且对观众来说更有真实感，此后的古兰剧院一直秉持着这种创作思路。<br />
莫雷是个商业奇才，以完美主义而闻名，他入魔一般地痴迷于改写剧本，调整舞台特效，强逼演员们一遍遍地排练他不满意的桥段，用现在的话说就是片场暴君。他将自然主义的创作观和猎奇恐怖联系在一起——这就是说，受害者被谋害的动机和死因非常现实，而被残害的过程却五花八门。在营销方面则更是极尽炒作所能，传说，每场演出都有晕倒的观众，因此剧院专门配备了驻场医生，莫雷将晕倒人数作为剧场的kpi和宣发手段，很难考证这是都市传说还是确有其事，不过据说晕倒的观众主要是男性，可能是因为他们不像女性观众那样经常在恐怖时刻遮住眼睛。<br />
此外莫雷重视剧作家的地位，发掘出了天才的恐怖剧本作家，后来被誉为恐怖王子的洛德，他是剧院最受欢迎和最多产的剧作家之一， 从1901 年开始创作到 1930 年代退休，他写了了 150 多部戏剧。洛德是一名医生的儿子，从小就对他父亲的病人的尖叫声感到着迷。随后他接触到并沉迷于爱伦·坡和莫泊桑的恐怖小说。 对死亡的痴迷以及丰富的阅历帮助他想象出种种病态狂气的剧本。1900 年弗洛伊德发布了著名的 <em>《梦的解析</em> 》，洛德了解到精神分析的概念，并经常与实验心理学家兼他的心理治疗师阿尔弗雷德合作(后者发明过第一个智商测试)就心理疾病题材进行剧本创作。凭借其卓越的才华，洛德活跃时期剧院迎来了巅峰。<br />
剧院在特效方面也有着建树，保罗—拉蒂诺是一位杰出的特效师，在他的指导下，剧院血腥猎奇的画面愈加真假难辨。显然，现场演出没有重来的机会，演员的一切都暴露在观众眼中，在这种前提下骗过观众需要杰出的道具技术，他开发了一系列针对不同色调和粘度的血液的配方，测试狗眼的弹跳能力，设计了一系列可喷血的隐藏机关、逼真的化妆术和无穷无尽的假肢假眼。他每天都会从屠夫那里收到动物器官，其中包括羊眼、牛舌头和各种内脏。他设计的用来愚弄观众的血袋、断肢和可伸缩刀片至今仍是电影布景的标准配置。除了道具外，他还需要指导演员怎么不露痕迹地将各种惨状呈现于观众面前，设置灯光的导向，控制剧院的音效……<br />
据相关研究者统计剧院的常见主题有无助、杀婴、疯狂、残害、神秘死亡、无辜者的痛苦、自杀、手术和复仇。喜剧和闹剧的类别包括资产阶级道德观、绿帽子、性丑闻和无辜者的痛苦。此外，还有若干附属主题：异国情调、催眠、监禁、巴黎底层生活、卖淫，如果你觉得这些主题有些耳熟，那么可以说或多或少地，现在的流行文化也受到了其影响。<br />
在三位恐怖界人才的配合以及演员们的努力下，剧场吸引了来自社会各个阶层的观众，其中不乏当时的王室成员，成为了20世纪恐怖文化的一大标志。可以说，古兰剧院的真面目是情色与暴力的剧场，最初的剧院使用"冷热交替"排戏法，也就是把讽刺喜剧和悲剧交替排列，打个鞭子给个糖果，莫雷继承剧院后依旧保留了喜剧和恐怖剧的交替排列，古兰的喜剧部分往往是粗俗的性丑闻等题材，而恐怖剧也不乏能产生刺激的要素，这种冷热交替极大地促进了观众的某种情感，以至于上映的当晚经常有在偏僻处为爱鼓掌的情侣。这也是其成功的关键，这两个原始主题的交织能够迅速地击溃观众的社会人面具，使其退回到原始的本我，心理学，科学家等题材在其中更多的是一个恐怖的符号。<br />
说到这里，你可能觉得古兰的血腥戏码品位庸俗，充斥着对精神病人的歧视，对心理学的引用浮于表面，抹黑现代科学和科学家形象等等；不过需要记住的是这只是一个商业剧场，也就是说以赚钱为核心要义，而巴黎市民就喜欢这一出。<br />
剧院的普遍暴力可以说平等地憎恨着全部人类，不管你的社会阶层高高在上，还是贱如尘土，都可能成为血腥场面中的受害者。道德，秩序，真理，科学，一切都在这里搅碎为鲜血，死亡以及官能刺激。讽刺的是，即使对演员也是一样，受害者的选取由经济因素决定，当资金紧张时，剧院更愿意刺伤女演员而不是男演员，因为她们的服装较小，清洗起来更便宜。对于头部伤口，男性则会成为受害者，因为他们的短发更容易洗，也有不少演员因为舞台机关陷入危险或者由于过于入戏产生精神问题。<br />
总之，你可以说古兰剧场是对现有道德，秩序，人性的挑战和批判，也可以它只是在贩卖批判的符号，并顺便把批判庸俗化；当然，我更推荐你纯粹把它当作商业剧，售卖恐惧、厌恶、怜悯、震惊、兴奋、恶心以及性兴奋。从这个角度来说，古兰确实是个人偶剧场，台上的角色们不过是为了售卖恐惧而顺着丝线活动的人偶，手握丝线的操纵者既是猎奇的观众也是贪婪的商人，机械地操作人偶走向被悲惨死亡的命运。<br />
1962年，古兰剧院永远地闭幕了，对其的衰落有着很多说法，管理层的错误决策，二战后观众看腻了纯粹的血腥剧等等，不过我认为这只是电影时代到来后的必然，毕竟很明显当时的恐怖电影并没有像古兰一样衰落，反而诞生了不少佳作。可以说，今日的恐怖电影以及游戏中依旧能看到古兰的影子，因此，古兰的精神遗产将会永存。<br />
人类对恐怖的喜好到底来自何处，这是一个经典的问题，可能是作为顶级掠食者的杀戮本能，可能是居安思危的智性，可能是对死亡的恐惧经常能刺激繁殖后代的欲望，可能是对颠覆一切现有秩序的自私本能和背德快感，可能是直面死亡就更有活着的实感，可能是在安全的观众席观看他人惨状的幸灾乐祸？但不管怎么说，这种情节时至今日仍经久不衰无疑说明了大众对其的狂热。恐惧似乎是一种跨越了理性和感性界限，跨越了现代和前现代甚至后现代的奇妙感情，面对恐惧，我们不得不想起自己依旧是动物的事实……</p>
<p>之后，我会简单评述一下恐怖王子的洛德的几部戏剧，以及恐怖剧场在东方和bs里的neta，洛德的很多剧作都是法语资料或者疑似遗失，留下的只有几部知名作品有英语翻译，当然国内就更没有翻译了，因此我会机翻并润色一遍。链接会放到简介，有兴趣的观众可以先看一遍发表一下感想</p>
<h1 id="欢迎来到暗黑舞台古兰吉涅尔今日上演恐怖王子解剖秀">欢迎来到暗黑舞台古兰吉涅尔，今日上演——《恐怖王子解剖秀》</h1>
<h2 id="在电话中">在电话中</h2>
<p>1902</p>
<p>角色:</p>
<p>安德烈·马雷克斯:男主人 45岁<br />
玛莎·马雷克斯:他的妻子， 30岁<br />
布莱斯：一位60岁的老管家<br />
娜奈特：一位60岁的老女仆<br />
小皮埃尔·马雷克斯：6岁<br />
一个流浪汉：不到20岁<br />
里沃尔：马雷克斯的朋友， 50岁<br />
贾斯汀：一位30岁的男仆<br />
露西恩·里沃尔：里沃尔的妻子， 30岁</p>
<h3 id="scene-1">scene 1</h3>
<p>一栋乡村别墅。一楼大客厅，背后有一扇落地窗通向后院公园。落地窗两侧各有一扇小窗。左右两侧各有一扇门。在左侧还有一个点燃的壁炉。在壁炉和观众之间的墙上装有一台电话机。右侧有一张桌子、扶手椅、普通椅子，一个角落里有一张写字台。<br />
幕开时，老仆人娜奈特正抱着小皮埃尔坐在壁炉边，小皮埃尔正在翻阅一本画册。马雷克斯正穿着旅行服，把一些文件放进敞开的写字台里。马雷克斯的妻子玛莎正在包装一些小物品，放进桌上的一个袋子里。<br />
马雷克斯(停下来倾听):"那是马车吗?"<br />
玛莎(走到窗前):"不，不是。"<br />
马雷克斯:"他怎么迟到这么久?"<br />
玛莎:"他通常很准时的。"<br />
马雷克斯:"你订的是哪里的马车?"<br />
玛莎(回到桌边):"像往常一样，从佩兰那里订的。娜奈特去订的。"<br />
娜奈特:"我亲自去的，我看到他们记下了订单。"<br />
玛莎(看表):"你还有很多时间。"<br />
马雷克斯(看钟):"我只能勉强赶上了。"<br />
玛莎:"去车站只需要二十分钟车程。"<br />
马雷克斯:"我最好步行去。"(走到窗前)<br />
娜奈特:"哦，不，先生，你的时间很充裕。那匹马很快的。"<br />
马雷克斯:"如果再过一两分钟它还没来，我就得放弃出门的计划了。"<br />
玛莎:"它一定会来的。"<br />
马雷克斯:"要是我误了火车，麻烦可就大了。如果我明天没赶到巴黎见米勒，这笔生意就泡汤了 —— 损失一万法郎——"<br />
玛莎:"这生意对你来说这么重要吗?"<br />
马雷克斯:"是的，比你所能设想的还重要。"<br />
玛莎(焦急地看着窗外):"啊，我本以为马车应该早就到了。要是马厩有电话就好了，我们就可以问问他们出发了没有。"<br />
马雷克斯:"如果现在还不出发就太迟了;而且，他们那里也没有电话;塞尔丰连个人都没有，那是个被上帝遗忘的地方。电话？他们连这种东西是什么都不知道。"<br />
玛莎(看着壁炉上的钟):"六点钟了。"<br />
马雷克斯:"啊，要是那个驾驶员在这里就好了!听着，我要步行去了。布莱斯可以拿着我的包 —我会比马车先到。"(雨势和风声越来越大)<br />
娜奈特:"但先生，听!外面下着很大的雨。"<br />
玛莎:"天气真糟糕。"<br />
马雷克斯:"是啊，下个不停!我们来乡下是为了呼吸新鲜空气，远足郊游，可这三个星期我们连门都出不了。讨厌的地方，我已经开始讨厌这里了。"<br />
玛莎(合上袋子):"我们下次假期不来这里了。"<br />
马雷克斯:"对，一点也不方便!潮湿、阴沉。镇上又脏又乱，还没有任何通讯方式。"<br />
娜奈特:"而且离一切都太远!如果我们需要什么东西 — 如果半夜有人生病，可能会在没有任何医疗的情况下去世。"<br />
玛莎:"你可以去向邻居求助。"<br />
娜奈特:"邻居!？他们都离得很远。"<br />
马雷克斯:"没错，这里太孤僻了。"<br />
玛莎:"要是我们能负担得起自己的马车就不会这么不方便了。"<br />
马雷克斯:"而且，这里太大了;需要五六个仆人来维持。那片林地，有七英亩——一片小森林，有什么用呢?我不打猎，也没人在里面走。"<br />
娜奈特:"是啊，里面全是讨厌的流浪汉。前几天我遇到过一个，真讨厌!"<br />
玛莎(笑着):"你这个老糊涂娜奈特。"<br />
马雷克斯:"只是个乞丐。"<br />
娜奈特:"他长得很难看，只会 ——"<br />
马雷克斯:"长得难看!就这样而已?好吧，明年我们换个地方度假。"<br />
娜奈特:"这是个好主意。要是我一个人呆在这里，我会活不下去的，不过幸好还有先生和布莱斯。"<br />
马雷克斯:"我差点忘了!"(他走到电话机旁打电话)<br />
玛莎:"你在做什么?"<br />
马雷克斯:"我正在给里沃尔打电话。"(对着电话讲话)"喂!给我维特雷27632 — 尽快，谢谢。"(对玛莎说)"我要告诉他我今晚八点左右到。"<br />
玛莎:"你坐哪趟火车过去?"<br />
马雷克斯:"十点四十分的快车。我明天早上五点十五分到达巴黎。如果你想在那之前联系我，可以在今晚九点前打电话给里沃尔家"<br />
玛莎:"在巴黎你住哪呢?"<br />
马雷克斯:"终点酒店，16号房间。"(电话响，他又对着电话讲话)"喂!是你吗，老朋友?是的，是的，但我已经让他们装了电话。虽然很贵，因为塞尔丰这里没有交换机。我是用吕克瑙交换机—最贵的型号了;但对我的生意来说是必需品。是的。我说我今晚要来和你一起喝咖啡。我要坐巴黎快车。有急事要办。不，只喝咖啡，我已经吃过晚饭了。我大约八点到。希望不会打扰到你们。"<br />
玛莎(走到马雷克斯身边):"说些好听的话根他问好，也向露西恩转告我的问候。"<br />
马雷克斯(又对着电话讲话):"是的 — 她在这里。她让我转告你们各种问候。"<br />
玛莎(对丈夫说):"什么!他听到了吗?"<br />
马雷克斯(仍在电话边):"谢谢。今晚见。"(挂断电话)<br />
玛莎:"他听到我的声音了吗?"<br />
马雷克斯:"你离我太近了。(这种距离下)什么秘密都能听到。"<br />
玛莎:"真不可思议!"<br />
娜奈特(侧耳倾听):"我听到车轮声了。"<br />
玛莎:"是马车到了。"(听到冰雹声)<br />
娜奈特:"是从林中驶来的。"<br />
马雷克斯:"感谢上帝，我刚好赶上。"<br />
皮埃尔(站起来走到父亲身边):"爸爸!"<br />
马雷克斯:"我在这呢，小家伙。"<br />
皮埃尔:"爸爸!我想要你给我带个礼物回来。"<br />
马雷克斯:"好的，孩子。"(对玛莎说)"给我拿包。布莱斯在哪里?"<br />
玛莎:"布莱斯在餐厅里。我去叫他。—— 布莱斯!布莱斯!"<br />
娜奈特(望着窗外):"马车终于来了。"<br />
(布莱斯进场)<br />
布莱斯:"夫人，您叫我?"<br />
马雷克斯:"哦，布莱斯，这个家就是我的整个世界;我离开时就全交给你照顾了。我相信你会好好看管的。"<br />
布莱斯:"先生可以放心。"<br />
马雷克斯:"把我的包放到马车上去。"(布莱斯照办后离开)<br />
马雷克斯(亲吻孩子):"再见，我的小伙子;乖乖的，要不然我就会忘记给你买礼物了。"<br />
皮埃尔:"是的，爸爸，我会很乖的。"<br />
马雷克斯:"你想要我给你带什么?"<br />
皮埃尔:"哦，爸爸!给我带一个妹妹回来吧。"<br />
马雷克斯:"天哪，那太贵了。"<br />
皮埃尔:"但是，爸爸，我还是想要。"<br />
马雷克斯:"好吧，我尽量。"<br />
皮埃尔:"如果新的太贵，就买一个二手的吧。"<br />
马雷克斯(笑着亲吻孩子):"二手的!好的，亲爱的。"(亲吻妻子)再见，娜奈特，别再想那些蠢事了 —没必要害怕。(布莱斯进场)布莱斯来了。啊，对了。布莱斯 — (指着桌子，拉出抽屉)你永远不知道未来会发生什么 — 最好做好准备 —吓吓娜奈特说的那些"怪人"，这里面有一把上好弹药的手枪。(试图关上抽屉)怎么关不上?你一定要把它关好，非常小心，不要让孩子碰到。再见。再见，亲爱的。我还能勉强赶上火车。(玛莎、娜奈特和皮埃尔送他出去)<br />
玛莎:"再见。"<br />
马雷克斯(叫住玛莎):"别出来，你会感冒的。"(离开，然后说)"好了，车夫，尽快开，不然我就赶不上火车了。记住，布莱斯，记得我跟你说的 — 我把所有事都交给你了。"(门被关上)<br />
皮埃尔(突然跑到门边):"再见，爸爸!别忘了给我买个妹妹。"(然后走到娜奈特身边)<br />
娜奈特:"是的，爸爸不会忘记的。来看看画册吧。"(她把孩子抱在怀里，他渐渐睡着了)<br />
玛莎(站在窗前):"他在大道尽头了。希望他能及时赶上。天气真糟 — 雾气笼罩，灯光都看不清了;马车正在小树林边转弯 — 现在看不到了;雨越下越大。天又这么暗。这片乡村真是阴郁。娜奈特!"<br />
娜奈特:"嘘!他睡着了。"<br />
玛莎:"啊，小心地把他放到沙发上去，然后去拿灯，太黑了看不清了。"(布莱斯重新进场)嘘!孩子睡着了。(她出去了。娜奈特把孩子放到沙发上，去拿灯)<br />
布莱斯(小声说):"先生这会儿已经走得很远了，那匹马很快。"<br />
玛莎:"布莱斯，你可以去把餐厅的百叶窗关上。还有把大门锁上。"<br />
布莱斯:"好的，我也把狗放出去好了?"<br />
玛莎:"对了，哦，布莱斯!"<br />
布莱斯:"夫人?"<br />
玛莎:"现在主人走了，我感觉好孤单。我想—— 我想你今晚要不要睡在这层楼上?你可以在这里铺个床。"<br />
布莱斯:"当然，夫人，如果这样您会更放心的话。"<br />
玛莎:"谢谢你，布莱斯，我相信这样更好 ——"<br />
(娜奈特拿着灯重新进场，带来一本书。布莱斯出去。玛莎对娜奈特说)我让布莱斯在这层楼上铺个床，你会觉得更安心些。<br />
娜奈特(小声):"是的，我们就不会那么害怕了。"(将灯放在桌上)<br />
玛莎:"'我们'?你为什么不说'我'呢，我的好娜奈特?"<br />
娜奈特:"好吧，我会更舒服些。我承认我胆子不大。"<br />
玛莎:"我虽然装得很勇敢，但其实也没那么胆大。"<br />
娜奈特:"好吧，我已经老了。请您别太放在心上，三天很快就过去了;主人最迟星期三就回来，不是吗?我知道他不太想离开。"<br />
玛莎:"我们上楼把孩子放到床上时，布莱斯就可以在这里铺床了。"<br />
娜奈特:"是的。看看他，多漂亮啊!他睡得像块木头一样。夫人，在我们把皮埃尔送上床之前，你有时间看看家里的账单吗?"<br />
玛莎:"他睡得很沉。也行，用不了十分钟吧?"<br />
娜奈特:"哦，五分钟就够了。"<br />
玛莎(坐在桌子左边，拿起一本账本，边看边说):"我昨天给你20法郎 ——"<br />
娜奈特:"是的，夫人。"<br />
玛莎(做计算):"你付了面包店的钱吗?"<br />
娜奈特:"是的，夫人 — 6法郎10索。"<br />
玛莎:"6法郎10索 — 肉店的也付了吗?"<br />
娜奈特:"是的，这是他的账本。"(风越刮越大，雨越下越大)<br />
玛莎:"风声真大啊。"(站起来)关好百叶窗。晚上听到这种风声太令人沮丧了。(走到左边)<br />
娜奈特(打开窗户关百叶窗):"是的。"(迅速退回来)啊!<br />
玛莎:"怎么了?"<br />
娜奈特(害怕和惊恐):"窗外有人。"<br />
玛莎(转过身):"什么!哦，胡说!那只是灯光的反射。"<br />
娜奈特(害怕):"不是的!"<br />
玛莎(走近她):"娜奈特，你太神经质了 ——"<br />
娜奈特(退后):"哦，夫人，我的心砰砰直跳!必须让布莱斯拿枪打他们，我受不了了，我太害怕了。"<br />
玛莎:"你胆子真是小过头了。你以为真的会有谁在那里?好吧，让我看看。"<br />
(走到背后的门，打开，突然后退，发出一声闷声尖叫。她看到一个流浪汉摘下帽子。流浪汉进来，留下门半开)<br />
流浪汉:"对不起，女士 ——"<br />
玛莎:"你是谁?你想要什么?"<br />
流浪汉(快速环视):"我有一封信。"(在口袋里摸索)<br />
玛莎:"一封信!你从哪里来的?"<br />
流浪汉(在另一个口袋里摸索):"我从村子里上来的。"<br />
玛莎(激动):"你是怎么进来的?你为什么不先在前门按铃呢!"<br />
流浪汉(环视):"我不知道前门在哪里。我走了个近路，从林子里穿过来的。"(从口袋里掏出一封破旧的信，递给她)<br />
玛莎:"这封信是给谁的?谁给你的?"<br />
流浪汉:"是给你的仆人布莱斯的，他的母亲病危了。"<br />
玛莎(非常激动):"他母亲病危!娜奈特，立刻把信拿给布莱斯。"<br />
娜奈特:"是，夫人。"(她离开了)可怜的家伙!哦，可怜的人!<br />
玛莎:"快点!快点!"(对流浪汉)谁给你的信?<br />
流浪汉:"我不认识的人 — 他告诉我把信送到这里 — 说我要赶快，仅此而已。"<br />
玛莎:"你等一会，也许还有回信。"<br />
(睡梦中的小皮埃尔打翻了放在扶手椅上的画册。玛莎看着他。)<br />
"亲爱的，你睡着了吗!"(走到沙发边，试着让孩子睡得更舒服，没回头说)坐下。布莱斯马上就来，你可以跟他解释。<br />
(流浪汉在离桌子一点距离的地方坐下。他的眼睛落在敞开的抽屉上，看到了手枪，环顾四周确认没人注意，靠近抽屉取出手枪，悄悄走到半开的门边迅速消失了。)<br />
皮埃尔(在睡梦中):"娜奈特!"<br />
玛莎(走到孩子身边，俯身到沙发上，背对桌子):"娜奈特很快就来。乖，我们要把你送上床睡觉了 — 好好睡吧，妈妈在这里。他离炉火太远了。"(把椅子拉近壁炉)而且，门还开着。你能不能把门关上，如果 ——"(转过身)怎么，他去哪了?(直起身)走了!我让他待在这里，他可能没听懂。也许他在外面等着。(走到落地窗前看)不，外面没人。(关上右边的窗户)他走了，他可能没听懂。<br />
(娜奈特进场)怎么样了?<br />
娜奈特:"我把信给布莱斯了 — 给他读了;这个可怜的人哭了。那小子呢?(环视四周)<br />
玛莎:"他走了。他可能没听懂我的话。布莱斯!布莱斯，我很遗憾。"(布莱斯进来，擦拭着眼睛)<br />
布莱斯:"夫人，我母亲病了 — 他们说快要死了;她想见我;一直在问我。"<br />
玛莎:"哦，可怜的布莱斯，是她写信给你的吗?"<br />
布莱斯:"不，她自己写不了信。是邻居帮她写的。"(哭泣)<br />
娜奈特:"可怜的布莱斯!你打算怎么办?"<br />
布莱斯(犹豫):"我不知道。我能做什么呢？"<br />
玛莎:"娜奈特，布莱斯必须立刻走;他母亲快要死了 — 他必须去看她。"<br />
布莱斯:"夫人，您能让我离开一会吗?我不会耽搁太久。"<br />
玛莎:"赶快去吧。"(布莱斯向门边走去)<br />
娜奈特:"我们就要独自留在这里了。"<br />
布莱斯(转过身停下):"夫人，我不能把您一个人留在这里。主人把您交给我照顾。"<br />
娜奈特:"他会很生气的。"<br />
布莱斯:"我最好明天一大早去 —— 天一亮就走。夫人，天一亮您就不会害怕了吧?"<br />
玛莎(走到布莱斯身边，他稍微后退):"我不害怕 — 怕什么?我们会把门都锁好。娜奈特真是太不近人情了。你去吧，布莱斯，离开我们。我会跟先生解释的;我会告诉他是我坚持要你去的。快去吧。你半个小时就能到塞尔丰了。"<br />
布莱斯:"哦，不会用那么长时间。"<br />
玛莎:"你可以叫辆出租车回来。你不用待太久。"<br />
布莱斯:"夫人，我保证我会尽快回来。"<br />
玛莎:"走之前把百叶窗关好。"(对娜奈特说)我们不应该那么自私。如果不让他最后见母亲最后一面，我会内疚一辈子的。(大声对布莱斯说)好了，你快走吧。<br />
布莱斯:"您真善良，夫人。我把屋子都关好了。我会一路跑过去，然后开车回来。我想大概 ——(语塞)我最多两个小时就回来，我向您保证，夫人。九点之前我就会回来。"<br />
娜奈特(紧张地):"对，九点之前。"<br />
玛莎:"没问题 — 裹好身子，外面在下雨。我会帮你锁门，娜奈特没勇气。"<br />
布莱斯:"谢谢您，夫人，谢谢。"(他离开，玛莎跟着他)<br />
娜奈特:"哦，不，我没那个胆量!这个孤独的大房子让我害怕;在得到救援之前，我们可能会被勒死。我就在昨天的报纸上看到 ——"<br />
(右边的门被关上。玛莎重新进场)<br />
玛莎:"我已经帮他锁好门了。好了，我们现在安全了。我们就在这里等布莱斯回来;孩子还在睡觉。"<br />
娜奈特(走到沙发边):"是的，他睡得很沉。我们把他送上楼吧?"<br />
玛莎:"不，让他继续睡。布莱斯回来我们再一起上楼。"(又坐到桌前)我们继续算账吧。我刚说到哪里了?(对娜奈特)你付过肉店的钱吗?<br />
娜奈特:"是的，夫人。"<br />
玛莎:"我们有账本吗?"<br />
娜奈特(摸索着):"在这里。"<br />
玛莎:"好。明天要订6瓶维希矿泉水。别忘了。"<br />
娜奈特:"和往常一样的类型?"<br />
玛莎:"是的，当然 — 给先生的。"<br />
娜奈特(笑):"还有布莱斯。"<br />
玛莎:"什么意思?"<br />
娜奈特:"哦，他也时不时喝一点。"<br />
玛莎(笑):"哦，那很好。"<br />
娜奈特:"但不要跟他说是我说的。"(突然停下)夫人，你听到什么了吗?<br />
玛莎:"什么?你又开始了吗?"<br />
娜奈特:"有人在吹口哨。"<br />
玛莎(冷淡地):"没，什么都没有;只是风在呼啸。"(娜奈特拿起她的针织品)你付过洗衣店的钱吗?<br />
娜奈特(站起来，把针织品放在扶手椅上，走到门边):"又来了!这不是风声。你听不见吗?"<br />
玛莎(走到她身边 — 倾听):"是狗在低吼。可以了吗?"<br />
娜奈特(自言自语):"园子里有人。"<br />
玛莎(不耐烦地):"也许是布莱斯忘了什么东西回来了。"<br />
娜奈特:"狗认识他 — 但现在它们在叫 — 很远，在后门那边。"<br />
玛莎(不耐烦地):"有人经过 ——"<br />
娜奈特:"或者是小偷!"<br />
玛莎:"它们经常这样吠叫。你太神经质了!"<br />
娜奈特:"不是这样的。它们在乱窜。"<br />
玛莎(倾听 — 开始焦虑):"是的。"<br />
娜奈特:"啊，夫人，它们越来越近了 — 它们在追人 — 现在离得很近了;又退远了。啊，脚步声越来越近!我在砾石小道上听到了。"<br />
玛莎:"娜奈特!娜奈特!"<br />
娜奈特:"就在那里，很近 — 就在门的另一边，也许。"<br />
玛莎:"娜奈特。"<br />
娜奈特(自言自语):"是的，就在那里，另一边;也许他们想进来 — 想砸开百叶窗。"<br />
玛莎(害怕):"安静，娜奈特。"(把手伸给娜奈特)<br />
娜奈特(握住她的手):"啊，夫人，您也害怕了;您的手在颤抖。"<br />
玛莎:"是你。你这些胡思乱想太可笑了。你都快让我害怕了。"<br />
娜奈特:"我吓坏了，夫人。"(倒进椅子里)<br />
玛莎(焦虑，声音虚弱):"你这个傻女人，要是有小偷在 — 在门边 — 狗早就叫了。我们什么都听不到。"<br />
娜奈特:"这是真的 — 除非 ——"(她们对视)<br />
玛莎:"除非 ——?"<br />
娜奈特:"它们现在叫不出来了!"<br />
玛莎:"真荒唐!"(沉默很久)我只听到风声。你看 ——"<br />
娜奈特:"是的?"<br />
玛莎(急忙安慰她):"你看，什么都没有。"<br />
娜奈特(恢复一些勇气):"但愿如此。"<br />
玛莎:"来，振作一点，娜奈特。"<br />
娜奈特:"我全身都在发抖。您也脸色苍白，夫人。"<br />
玛莎:"好了，现在一切都过去了。真的，你刚才把我吓到了。把火烧旺一点，它要熄了。"(自言自语，不耐烦):"才八点钟!"(试图转移注意力)"安德烈现在一定已经到里沃尔先生家了。里沃尔家人真不错。你还记得他们吗，娜奈特?"<br />
娜奈特(自我安慰):"哦，是的，主人现在一定已经到那里了，他们肯定把主人招待地很舒服。"<br />
玛莎:"我很想给他打个电话，告诉他布莱斯的母亲病情很严重。"<br />
娜奈特(高兴地):"是的，是的，夫人，请打吧。那能让我们转移一下注意 — (指着电话)能听到主人在电话那头的声音;仿佛他就在我们身边。您会让我也听听吗，夫人?"<br />
玛莎:"好的，好的。"(拿起话筒拨号)喂!喂!<br />
娜奈特:"哦，那真是个了不起的发明!主人在很远的地方 — 却可以跟我们说话，好像就在这个房间里一样。"<br />
玛莎(在电话边):"喂!喂!"<br />
娜奈特:"我确信听到主人的声音我就不再害怕了。就好像主人就在这里一样。"<br />
玛莎(在电话边，帷幕落下)"啊!请给我接到维特雷27632号。快点 — 快点 ——好了!谢谢，我会等着的。"</p>
<h3 id="scene-2">scene 2</h3>
<p>场景为一间书房。有椅子和扶手椅。中央桌上有一部电话。帷幕升起，电话铃响;同时背后的门打开，一名男仆进来走向电话。<br />
男仆(对着电话讲话):"喂!喂!夫人 — 啊 — 马雷克斯先生 — 是谁?哦，很好，夫人 — 是的，他和里沃尔先生夫人在餐厅里 — 刚刚到的。我这就叫他 — 是的，夫人 — 很好 — 如果您能等会儿，夫人。"(放下听筒，走向背后的门。此时同一扇门打开，里沃尔先生夫人和马雷克斯进场。)<br />
里沃尔夫人(对男仆说):"贾斯汀，你可以端咖啡来了。"<br />
男仆:"好的，夫人。"(对马雷克斯说)"有人给您打电话，马雷克斯先生。"<br />
马雷克斯:"啊!"(环顾寻找电话)<br />
里沃尔(指着桌上的电话):"就在那里。"<br />
(男仆端着托盘进场)<br />
里沃尔(对男仆):"你可以拿白兰地来 — 你知道，那瓶红封的。"<br />
男仆:"好的，先生。"(离开)<br />
马雷克斯(在电话边):"喂!喂!喂!喂!"(停顿)<br />
里沃尔:"你没听到回答吗?"<br />
马雷克斯:"没有。"(再次拿起电话)"是你吗?喂!喂!"<br />
里沃尔夫人:"他们已经挂断了。总是这样乱搞!"<br />
里沃尔(对马雷克斯):"是啊，总是这样 — 如果不马上接听的话。"<br />
马雷克斯:"到处都一样。好吧，等着我妻子再打电话来。"(挂断听筒)<br />
里沃尔夫人(给马雷克斯倒咖啡):"要糖吗?"<br />
马雷克斯:"谢谢，不用。"<br />
里沃尔(手里拿着杯子):"亲爱的朋友，电话是个了不起的发明 — 很有用，但组织得很糟糕 — 至少在法国是这样。"<br />
马雷克斯:"不过，总比没有强。也许是我没见识 — 它对我来说太神奇了，即使我一天打20次电话，我也从未理解过这个神奇的东西;它让我困惑 — 感觉很奇怪。"(男仆带着一瓶酒重新进场)<br />
男仆:"白兰地，先生。"(放在桌上离开)<br />
里沃尔(对马雷克斯):"好了，我要让你尝尝我最珍贵、最古老的藏品 — 1857年的。"<br />
马雷克斯:"1857年?<br />
里沃尔:"非同一般。"<br />
里沃尔夫人:"维特雷的神父出价50法郎一瓶想买它。"<br />
里沃尔:"别提那家伙了。"<br />
马雷克斯(慢慢品尝):"哦，太美妙了。你说得很对，真是太棒了。"<br />
里沃尔(递上香烟):"那么，你在你那座离一切都很远的城堡里过得还习惯吗?"<br />
马雷克斯:"习惯?非常不习惯，老朋友。明年我们绝不会再去那里度假了。"<br />
里沃尔夫人:"你打算去哪里?"<br />
马雷克斯:"图兰，离巴黎不太远，气氛也更好一些。"<br />
里沃尔:"你在拉谢讷耶付的租金很高?"<br />
马雷克斯:"是的，很高。不仅如此，地理位置也很糟糕 — 去巴黎要换三次车。对我这样的商人来说几乎是不可能的。我还不得不花钱装电话，真是一笔不小的开支!"<br />
里沃尔夫人:"我不觉得奇怪。从吕克瑙到塞尔丰之间那段路 ——"(此时电话铃响起)<br />
马雷克斯:"是 — "(走向电话)"喂!喂!啊!是你吗，亲爱的?是的，旅途很愉快。你的朋友们都很好。你怎么样?还没睡?布莱斯不在!— 他母亲?— 哦，可怜的家伙!你说得很对，当然。娜奈特想多了。可怜的人。你有没有告诉他赶快回来 — 打辆马车?— 很好 — 我觉得你并不害怕。是吗?太好了!刚才有声音?是狗!每天晚上都这样。你还记得上周一那次骚动吗?— 娜奈特是个老胆小鬼，胆子比婴儿还小。<br />
他睡了吗?没有?你在等布莱斯?— 那样更好 — 啊!— 他睡着了 — 铃声把他吵醒了。把他抱过来让他和我道晚安。— 晚安，我的宝贝，你睡着了吗?如果你在我回来时表现很好 — "(转向里沃尔夫妇，笑着)他不知道怎么拿听筒。"(对着电话)告诉他也许会有一个小妹妹。我已经考虑过了，我想我可以给他承诺 — (笑)我们来买一个吧?是的 — 全新的 — 好吗?(停顿)<br />
怎么了?娜奈特又听到什么了?叫她过来让我训斥她。是你吗，娜奈特，你什么时候才能改掉这个毛病?有声音，对吗?是什么样的声音?你害怕什么?你们都关好门了 — 关得很牢 — 这真是可笑。来，去睡吧。布莱斯最多一个小时就会回来。我不许你再读《小报》上的那些故事了 — 那些文章总让你害怕没完。好的。晚安。— 做个好梦。<br />
晚安，亲爱的 — 明天见。你不觉得太神奇了吗?你就在我身边 — 我能听到你声音中微小的变化 — 几乎每一个轻微的语气 — 我几乎能看到你 — 是的，我能看到你，亲爱的。你知道现在我想干什么吗。"(在电话中吻她)<br />
里沃尔夫人:"你们真像一对鸳鸯一样恩爱。"<br />
里沃尔:"别介意我们。"<br />
马雷克斯(对着电话):"我的朋友们在取笑我 — 但我不介意。明天见。是的，亲爱的。明天见。"(停止说话，挂断电话)<br />
里沃尔:"如果我们不在这里 ——"<br />
里沃尔夫人:"他们会做出什么样的事情!"<br />
里沃尔:"幸运的是，两部电话相距还算远。"<br />
马雷克斯(高兴地):"从一个嘴唇到另一个嘴唇有70公里远。"<br />
里沃尔:"你的咖啡凉了。"<br />
马雷克斯:"哦，没关系。"(喝了一口)"想象一下，我们有一个很忠诚的老仆人，但极其神经质 — 哪怕是最小的声响都会让她惊慌。她总是认为有小偷 — 杀人犯 ——"<br />
(里沃尔点燃一支香烟)<br />
里沃尔:"我想那里应该很安全吧?"<br />
马雷克斯:"哦，天啊，是很安全，我想 — 就像其他任何地方一样。我们确实有些孤独，但马 ——"<br />
里沃尔夫人:"你没有个男仆在你们不在时睡在房子里吗?"<br />
马雷克斯:"有，布莱斯，一个好佣人，但恰好他被叫去看他病重的母亲了。"<br />
里沃尔:"哦，那她们就独自在那里了?"<br />
马雷克斯:"哦，只有一两个小时。我必须承认我有些担心，但我不会告诉玛莎。此外，在这种情况下她也无能为力。不会有危险的 — 为这种事担心实在是太可笑了。"<br />
里沃尔夫人:"天哪!还是小心为好;报纸上总是报道那些可怕的事情。"<br />
马雷克斯:"你们真和娜奈特一样。"(电话又响起)<br />
里沃尔(走向电话):"好了，现在怎么回事?什么 — 啊!"(走到马雷克斯身边)是你的妻子，老伙计。"(把听筒递给他)<br />
马雷克斯(略显焦虑地站起来走到电话边):"是你吗?你的声音听起来完全不同!怎么了?你听到脚步声 — 在花园里?也许是布莱斯。那样的话 — 你们就有保护了。也许是狗在砾石小径上走?那是一种闷闷的声音 — 在门边?拜托你，我恳求你不要失去理智。<br />
你在听我说吗?是的，我恳求你。宝贝在哭 — 我听到了。你吓到他了。请保持冷静。娜奈特应该为此负很大责任 — 是她把你们吓坏了 — 是的，你们很害怕。在门后?还是在哪里?够了，这是不可能的。听着，很容易确认一下。你知道桌子抽屉里有一把手枪;我留在那里 — 上好子弹。<br />
听着!悄悄打开一扇窗户。你不敢吗?我简直不认识你了 — 你向来那么勇敢!打开窗户，不是百叶窗，就是窗户，然后开一枪。别管他们会不会被吓到 — 这肯定会把他们吓跑的 — 如果有人在那里的话;但我觉得没有 — 这是不可能的。—是的?啊!也许是某种动物 — 一只狐狸。<br />
我恳求你不要发抖。按我说的做 — 开枪;注意不要伤到自己。要提醒宝贝，免得他被吓到。照我说的做。我在听着。 — 你可以告诉我 ——"<br />
里沃尔(相当激动，走到马雷克斯身边):"怎么回事?"<br />
马雷克斯(对里沃尔):"亲爱的朋友，她们吓坏了 — 仅此而已。她们说听到了响声 — 脚步声 — 嘎吱声 — 各种各样的东西从通向公园的门那边传来。这全是幻觉。不过，如果有列火车能把我送回去，我一定会去 ——"<br />
里沃尔:"你为什么不打电话给村里的人?"<br />
马雷克斯:"那里没有电话总局。我们是接在吕克瑙的总局上的。"<br />
里沃尔:"那就打电话给吕克瑙 — 叫他们派人过去。"<br />
马雷克斯:"那太远了。哦，我也开始害怕了 — 我是 — 我不知道发生了什么事。"<br />
里沃尔:"没事的。"<br />
马雷克斯:"我在想 — 布莱斯在我离开后那么快也走了 — 会有这么巧吗 ——"<br />
里沃尔:"别想傻事了。没什么的"<br />
马雷克斯:"是的，肯定是我多想了。"<br />
(在电话边)"你什么意思?手枪不见了?这不可能。快看看 — 到处找。在抽屉里?柜子里?什么都没有?你觉得它可能在哪里?我把它放在那里的。"(对里沃尔夫妇说)"啊，朋友们!"<br />
里沃尔:"怎么了?"(他和他的妻子站起来，情绪越来越激动，一直到场景结束;他们一直站着，紧跟着马雷克斯的每一句话和动作)<br />
马雷克斯:"什么?什么都没有?那它被拿走了?— 是谁?— 不是布莱斯?那么是谁?— 一个流浪汉!啊，说清楚一点 — 我听不清 — 我耳朵里嗡嗡作响。<br />
你说什么?哦，玛莎，不要害怕，我恳求你，我乞求你 — 我在这里 — 我在这里。在被撬开!不可能!百叶窗很结实。啊，我听到你在发抖!宝贝在哭。不要出声。让他安静下来。— 安静，亲爱的，我求求你，小皮埃尔。是的，把灯灭了。<br />
告诉娜奈特 — 马上 — 也许那会把他们吓跑 — 我不知道 — 我 — 我 — 天啊!现在在窗户百叶窗下 — 你觉得 — 有好几个人 — 还有门后面!他们正在往下面塞什么东西 — 啊! — 呼救!呼救!— 把他们吓跑!— 尖叫 — 呼救 — 喊'救命'!— 太可怕了!是的，你说得对。<br />
不要尖叫。逃走，带上孩子。是的，逃跑 — 从厨房逃跑。快跑!啊!"(发出一声尖叫)哦!是谁在尖叫!玛莎!玛莎!那是你吗?回答!回答!我说!他们在做什么?他们在对你做什么?啊! — 他们在杀人!他们要勒死人 — 啊! — 救命!— 谋杀!救命!"<br />
(离开电话，像个疯子一样冲了出去，而里沃尔先生和夫人试图拦住他。)"救命!— 谋杀!— 谋杀!— 救命!"(一直喊着，直到帷幕落下。)</p>
<h2 id="焦油博士和羽毛教授的系统">焦油博士和羽毛教授的系统</h2>
<p>1903 改编自爱伦坡同名小说<br />
这篇只找到法语版，很难校对机翻，可能会有偏差</p>
<p>(爬楼梯声)<br />
(亨利和基恩进来，门打开)<br />
亨利:没人<br />
基恩:还是没有任何人!(门关上)真是个管理糟糕的地方啊!所有的门都开着，疯子可以随意逃脱!<br />
亨利:我们在这里等着，总会有人来的，这里应该是院长的办公室 (沉默)<br />
基恩:喂，老兄，我们没找错地方吧?你确定是这里吗?(喊声)那是什么声音?<br />
亨利:那是疯子发出的<br />
基恩:疯子?你这么认为?<br />
亨利:(打开窗户)还能是谁呢?(喊声)<br />
基恩:什么喊声!出什么事了?你看到什么了吗?<br />
亨利:从这个阳台上看不到什么，下面有个大院子，(探身出去)哦!好高啊!(窗户关上)一定是疯子在制造这种喧闹声，他们常这样大声嚎叫，尤其是在暴雨天气，(雷声)空气也这么沉闷<br />
基恩:有道理!<br />
亨利:听到他们在打雷的时候嚎叫，真让人胆寒!你从来没有参观过精神病院吗?<br />
基恩:(讽刺地)这还是我第一次享受这种乐趣呢!<br />
亨利:这很有意思!<br />
基恩:是吗，可能吧，反正是你想来，我才跟着过来的<br />
亨利:你不会后悔的。(喊声)<br />
基恩:又来了!但是他们对这些可怜人做了什么?我敢肯定是看守虐待他们，真可耻!<br />
亨利:哦，不，我告诉你，是暴风雨让他们激动起来了，你看，在这个在法国独一无二的机构里，疯子们几乎是自由生活的，而且得到了非常好的照顾，以一种非常温和、人性化的方式<br />
基恩:但并非处处如此，不过我觉得这种景象并不太令人愉快，这些可怜的家伙，我们看他们像看笼里的野兽一样，我们没有这种权利!他们和其他病人一样都是病人，而且更应该被同情<br />
亨利:可是，朋友，来看他们、关心他们有什么不对吗?况且，我不是来看他们的，而是来看这家机构的院长。听说他是一位出色的精神病学家，在世界范围内都很有名气，他有一种独特的治疗方法，一种系统，靠它可以取得奇迹般的治疗效果，知道吗?普通人很难来这里<br />
基恩:那可不是!大门口是大敞开的，我们穿过走廊，走遍了整个机构，连个人影都没见到<br />
亨利:我的意思是，院长——一个非常特立独行的人——很少允许访客进来，幸好我有一封推荐信<br />
古德朗:(进入)你们是谁?你们想要什么?<br />
亨利:对不起，先生，我们穿过整个机构都没遇到任何人能为我们指路<br />
基恩:(接着说)我们想见院长<br />
古德朗:院长吗?你们想见他干什么?<br />
亨利:我们是来参观这个机构的，我们是由理查德医生推荐来的，这里有他的一封信，(纸张沙沙声)<br />
古德朗:啊!啊!很好，很好，(纸张沙沙声)我明白了，(微笑)你们想得到参观这家机构、看看这些疯子的许可<br />
基恩:如果可以我们会很高兴的<br />
亨利:院长先生在吗?<br />
古德朗:院长!不是，先生们，你们想见的人就是我啊<br />
亨利:对不起!我之前不知道我有幸能与您交谈<br />
古德朗—(友好地)请坐，先生们<br />
基恩:我们是否打扰了您?<br />
古德朗:一点也没有，先生们，一点也没有，我很乐意为你们效劳。<br />
亨利:谢谢您<br />
基恩:您真是太客气了!<br />
古德朗:先生们，现在你们可以告诉我来意了<br />
亨利:院长先生，我们期待得到您的恩准，我们知道您很少允许参观者详细参观您多年来主管的这家机构<br />
古德朗:(重复)多年来!<br />
亨利:(图片—报纸)我和我的朋友，基恩·瓦尔蒙先生，都是《小报》的编辑，如果您允许的话，我们想对您的机构、您在这里治疗的病人，以及——如果您不反对——您的著作、治疗方法、著名的系统做些笔记<br />
古德朗:我的系统!<br />
基恩:如果您能给我们这个机会，我们将不胜感激<br />
亨利:我们报纸的读者也会感谢您的。<br />
古德朗:先生们，我感到非常荣幸，非常荣幸，你们想来采访我，并对我一直倾心的事业感兴趣，这项事业已成为我一生的追求，你们听说的那个系统——我费了无数心血才创建出来的系统——确实是我的发明。啊!这些精神病人，先生们!谁会关心他们的痛苦和悲惨!到目前为止，人们一直像对待有害动物、稀奇古怪的野兽，而不是病人一样对待他们，让我们同情他们吧!让我们照顾他们，先生们!人性要求如此，科学也需要如此，作为一个隐居在世外桃源的卑微学者，我自认为不那么自负地告诉你们，到目前为止我已经取得了相当有趣的治疗成果，我正在进行观察，以便提交给医学院，((咕哝声)他停下来倾听)对不起，先生们，但你安静点!我的朋友!当你哀鸣完毕之后，你以为我会在乎你的感受吗?我才是这里的主人，听明白了吗?(用拳头猛敲桌子，然后对基恩微笑着说)必须要这样跟他说话，请原谅我的粗鲁，那是一个可怜的疯子，很难安抚他<br />
基恩:(惊恐地)就在你旁边的隔间，那里有个疯子?<br />
古德朗:是的，我把他放在那里监视他，只有我才对他有些影响力，他是最严重和最危险的，是的，先生们，最危险的。(停顿)但我们刚才在说什么来着?<br />
亨利:我们在谈论您的系统所取得的非常出色的结果<br />
古德朗:啊!是的!我的系统!好吧，先生们，毫无疑问，你们已经听说过我在这里对病人实施的治疗中最重要、最有趣的部分，这种治疗方式已经在整个德国、英国、美国广泛应用，我希望很快也能推广到全世界，我的系统，(咕哝声)他又开始了，真是头疯狗!(愤怒地)这种噪音必须停下来!(脚步声+门开关声)<br />
基恩:他确实是个有趣的人物<br />
亨利:那到底是什么?声音<br />
(喊叫声+撞击声)<br />
基恩:究竟发生了什么事?<br />
古德朗:没什么，先生们，没什么，(微笑)他不会再打扰我们了，我已经让他平静下来了。真是头野兽!<br />
基恩:有像这样的病人，您一定经常面临各种危险 古德朗:是的，很难对付!这位病人在发作期以外非常聪明，但他有一种执念，到目前为止我们一直无法治愈，尽管他在这里接受治疗已经多年了，(微笑)他一定要成为医生，亲自管理这家机构，他对我怀有狂热的仇恨!..就在半个小时前，你看，他竟然成功地煽动其他疯子们反抗!他们想把我们关在病房里。我们费了很大劲才摆脱他们，让他们服从(笑起来)不过，先生们，你说我们能用理性说服一个疯子吗?那是一场可怕的战斗!<br />
亨利:(对基恩)这就是我们听到的那些叫喊声!<br />
古德朗:总之，他们现在被关起来了，关得很牢固，至于大家都称之为"院长"的人，我把他关在那边(指右边的房间)让他保持安静，但他总发出这么大的噪音!我最讨厌噪音了!是的，先生们，我最讨厌噪音!我不得不严厉地惩罚他，尽管我向来不愿意这样对待病人，(感伤地)这让我很难过!<br />
基恩:你让他穿上了拘束衣吗?<br />
古德朗:啊!别提这个!真是的，为什么要提这个呢?<br />
基恩:但我以为<br />
古德朗:拘束衣!真可怕!太残酷了!你这样说我不得不提出抗议!<br />
亨利:我们知道您并不赞同这种严厉的镇压手段<br />
古德朗:野蛮!卑鄙!<br />
基恩:但是，在某些情况下<br />
亨利:不得不如此<br />
古德朗:(用拳头狂击桌子—现场)先生们，你们说什么呢!你们显然不知道那意味着什么，啊!请不要再说这个，我求你们了。(把头埋在手里，似乎在痛苦。长时间的尴尬沉默。基恩和亨利面面相觑，好像在问:他怎么了?)<br />
亨利:院长先生，你能否详细告诉我们你采用的新方法?<br />
古德朗:(突然变得很和善平静)当然，先生们，当然，这不就是你们来的目的嘛，(门开声)这是普鲁姆先生，还有罗伯特先生，我很高兴向你们介绍，他们是我可敬的合作者和朋友。(对参观者们)请不要客气，请不要客气。早安，先生们，女士们，你们可以进来了，(脚步声)不要害怕。这些先生是记者，他们听说过我们的机构，想来参观一下<br />
乔伊斯女士(乔伊斯是法语的快乐一词音译):真的，先生们，你们来看疯子?这对你们来说很有意思吗?<br />
古德朗:容我给您介绍一下，尊敬的普鲁姆教授，我亲爱的朋友和杰出的合作者，(疯子们喊叫)<br />
普鲁姆:亲爱的院长!先生们<br />
古德朗:，我的朋友，罗伯特先生，还有这些女士们，请坐下吧。等一会儿，我们会让这些先生们看看我们可怜的病人，等他们平静一些。<br />
普鲁姆:平静一些!<br />
乔伊斯女士:啊!我真希望这些先生能玩得开心!我可不敢正视一个疯子。<br />
基恩:(小声对亨利)她在这里做什么?<br />
尤金妮小姐:(对乔伊斯女士)真是个有趣的消遣!<br />
亨利:(对基恩，指着古德朗)他的妻子和女儿，想必是这样!<br />
尤金妮小姐:疯狂!这真是可怕的病啊!<br />
普鲁姆:可怕!<br />
乔伊斯女士:啊!博学的先生们，你们应该赶快找到治疗这个可怕疾病的良方。<br />
古德朗:(庄严地)我们正在努力<br />
普鲁姆:我们正在努力!<br />
基恩:(自言自语，看着普鲁姆)这位老学究真有趣!<br />
亨利:(奉承古德朗)但是，院长先生，多亏了您的系统<br />
基恩:(接着说)这个系统实在是了不起<br />
亨利:太棒了!<br />
古德朗:(谦逊地)哦，先生们，我不值得这么高的赞扬，无论如何，这不能归功于我一个人，请您把我亲爱的杰出合作者，普鲁姆教授，也算进在这项功绩中吧。<br />
普鲁姆:(夸张地再次鞠躬)亲爱的院长!<br />
古德朗:我采用的治疗病人的方法 — 我称之为"温和系统" — 是我的发明，但这种方法在某些方面已经被我杰出的朋友大大改良了，(指着普鲁姆教授)我们对病人使用的治疗方法，先生们，是最简单的，我们不反对他们任何的偏执想法。相反，我们不仅配合他们，还鼓励他们，这样我们就能取得许多根治的效果，大约百分之六十。<br />
基恩:百分之六十!<br />
亨利:真的有这么高的比例吗?<br />
古德朗:绝对如此!比如，我们遇到过一些病人认为自己是鸡，他们的治疗就是这样:承认、接受他们的偏执想法是事实，然后在整整一周里，给予病人专属于鸡类的饮食。有了这种方法，只需要一些谷物和砂石就能奇迹般地治愈他们，谷物，砂石!(他大笑起来)<br />
(所有人都笑了起来)<br />
基恩:(也在笑)真有意思!<br />
亨利:(也是如此)太好笑了!<br />
古德朗:但是，这种无与伦比的人性化的系统，却也存在一个危险，一个很大的危险!我们无法预知、预防疯子的任性，让他们自由活动而不加监督是非常不谨慎的，疯人先生们，可能会在在某个时期变得温顺，但最终还是会产生骚乱，而且，他们的狡诈是出了名的，真的非常了不起!如果他们有什么计划，他们会用奇妙的演技来掩盖它。<br />
普鲁姆:奇妙!(雷鸣)<br />
亨利:现在，院长先生，您这里有很多病人吗?<br />
古德朗:总共有半打。<br />
基恩:不多?<br />
古德朗:但一个人能抵得上三个人!我们对付他们六个人就已经很费力了!<br />
亨利:在这六个人中，女性比男性多吗?<br />
古德朗:都是男性，而且都是壮实的家伙，我可以向你们保证!啊哈哈!(他放声大笑。普鲁姆、罗伯特、乔伊斯女士、尤金妮小姐也跟着更大声地笑起来。)<br />
基恩:(小声自语)他们为什么要笑得这么厉害?<br />
亨利:(对古德朗)我一直听说，女性中的疯子比男性多 乔伊斯女士:啊!先生，你说什么?这种说法是错误的，而且对我们女性也很不友好 亨利:当然，夫人，我很抱歉!但这不是我说的，而是统计数据如此 乔伊斯女士:统计数据有错!女性中的疯子比男性多!这种观点这太荒谬了!不是吗，我亲爱的普鲁姆先生?<br />
普鲁姆:荒谬。<br />
乔伊斯女士:女性，几乎都是有个性的，有的古怪的，有的偏执，但要说到真正的精神错乱，差得可远了!不是吗，亲爱的院长?<br />
古德朗:我完全赞同你的看法，乔伊斯女士。<br />
乔伊斯女士:那么，尤金妮小姐，你也赞同我的观点吗?<br />
尤金妮:当然，乔伊斯女士!只有蠢驴才会反对!<br />
古德朗:(兴奋地笑着)说到驴子，你们知道，我们这里有个病人，就把自己当成了驴子!<br />
罗伯特:而且他真是个很麻烦的病人!我们很难控制住他，长期以来他只愿意吃蓟，他一直在用脚跺地，像这样!(罗伯特学驴子)<br />
乔伊斯女士:(生气)罗伯特先生，我要请您收敛一些，您的玩笑太没品味了，您弄坏了我的衣服!这些先生们不需要您这样演示就能明白 罗伯特:非常抱歉，乔伊斯女士，我完全没有想要冒犯您，一点也没有!(雷声)<br />
古德朗:(打断他)亲爱的罗伯特先生，您提到的那位病人确实病得很重，但他不能和我们大家都认识的那位相提并论，我指的是那个把自己当成香槟酒瓶的人，在说话时总是有"砰，砰，"和"噗嘎，噗嘎，"(疯子们模仿酒瓶的声音和动作，使记者们吓了一跳)的声音，就像是酒瓶被拔开的样子，砰，噗嘎!砰，噗嘎!砰，噗嘎!(其他人也学着他们模仿，然后大笑起来)<br />
基恩:(小声对亨利说)他们这样"砰，噗嘎!"和大笑，真让我烦躁。<br />
亨利:(也小声)他们怎么回事?<br />
罗伯特:(笑着说)还有布维尔呢?<br />
普鲁姆:(狂笑)对，布维尔!<br />
古德朗:我们给他起了个外号叫"陀螺"，因为他总以为自己变成了陀螺<br />
罗伯特:先生们，要是看到他像陀螺一样转个不停，你们一定会笑死的!他立在脚尖上能转好几个小时。(罗伯特模仿陀螺转动)我们也有一个很有趣的病人，名叫朱尔斯·德舒立耶，简直令人难以置信，他以为自己是一个南瓜!(模仿南瓜)他一直纠缠不休地逼迫厨师把他放进热水里<br />
所有人:放进热水里，先生们!放进热水里!哈哈哈!<br />
基恩:(小声对亨利说)他们不正常<br />
亨利:(小声)对，不正常<br />
尤金妮:至少梅林先生的偏执想法比较有理有据，他经过深思熟虑后发现，自己不小心变成了公鸡;而作为公鸡，他的行为很合理，他像这样扑棱翅膀!(尤金妮学公鸡)他的啼叫声也很悦耳!(她模仿公鸡叫)咕咕咯!咕咕咯!<br />
所有人:咕咕咯!咕咕咯!<br />
亨利:(小声对基恩说)他们疯了!<br />
基恩:(也小声)这是怎么回事?<br />
古德朗:(生气，重重敲桌子)尤金妮小姐，请您节制一些。如果您无法像一个年轻女孩一样举止得体，您就可以出去了。<br />
所有人:(除了尤金妮，她低头站在房间中间不动)院长先生是对的!院长先生是对的!院长先生是对的!<br />
基恩:(小声对亨利)快走吧，这些人让我难受。<br />
亨利:(对古德朗)但是先生，这不是个糟糕的玩笑吗?<br />
(雷声)<br />
古德朗:(害怕，抓住亨利的胳膊)这是什么声音?<br />
亨利:(挣脱开)那是雷声啊<br />
古德朗:(又一声雷)雷声!<br />
乔伊斯女士:(惊恐万分，呻吟)雷声!啊，天呐!<br />
尤金妮:雷雨!我好害怕!(呻吟着扑倒在地上)啊!<br />
普鲁姆:(颤抖，牙齿打架)雷雨!藏起来!藏起来!<br />
罗伯特:(在房间里踱步)我们完了!我们完了!<br />
古德朗:(在哀叫声中挥舞手臂)安静!安静!你们这样会引来雷电的，我命令你们闭嘴!我才是主人，明白吗?安静!<br />
基恩:(对亨利)我们逃走吧，这里很危险<br />
亨利:(对基恩)他们一个比一个更疯狂!<br />
古德朗:(冷笑)不要害怕，不要害怕，(古德朗指挥众人捉住让)轻轻的，它进来了，不要吓它，我们要关门(锁门)。现在我们抓住它了，我们抓住雷电了!(指着让)抓住他，我们抓住了它，帮我!它逃不掉了!<br />
基恩:(挣扎)放开我，救命啊!<br />
亨利:你们这些可怕的家伙，快放开他!<br />
古德朗:等等，给我一把刀，我要挖他的眼睛 普鲁姆:对，让我们抠掉他的眼睛<br />
基恩:(仍在挣扎)救命!亨利!<br />
普鲁姆:(看见血流出来)哇，流血了，哈哈!(大笑)<br />
亨利:可怜的疯子们!啊!<br />
罗伯特:把他从窗户扔出去!从窗户扔出去!<br />
古德朗:对，从窗户扔出去!<br />
基恩:(挣扎)救命啊!(敲门声等)<br />
警卫长:开门，开门!<br />
亨利:门被锁上了!快撞开门!<br />
警卫长:发生什么事了?罗伯特!普鲁姆!古德朗!你们在里面吗?<br />
亨利:快，救救我们!<br />
基恩:我们被疯子们锁起来了，救命!<br />
警卫长:(撞门进来)出什么事了?<br />
第一名警卫:他们在互相残杀<br />
第二名警卫:终于找到这几个人了，普鲁姆，罗伯特<br />
第一名警卫:古德朗也在<br />
第二名警卫:最危险的那些人<br />
第一名警卫:虽然抓他们不是我们的任务<br />
第二名警卫:其他病人可能已经逃走了<br />
警卫长:等会再找他们，把这些人带走，要轻柔点，别伤到他们，让他们逃出来是我们的错，这教育我们以后要加强防范<br />
(疯子们被警卫们带走，发出各种叫喊声;普鲁姆笑着，罗伯特模仿酒瓶弹出的声音，女人们模仿公鸡叫)<br />
(对基恩和亨利)你们两个在这里干什么?(对抗拒的古德朗)啊，轻点，古德朗，不然我要让你穿上拘束衣了，乖乖的!<br />
古德朗:(疯狂挥舞着手臂)安静!安静!我命令你们闭嘴!我是主人，听见没有?我是主人!(警卫们把他拖走，他的呼喊声渐行渐远)<br />
亨利:万幸你们及时赶到!<br />
警卫长:你们是怎么来到这里的?<br />
亨利:我们是记者，来参观这个机构的，我们发现大门开着<br />
警卫长:是的，刚刚疯子们发生了骚乱!他们把我们关在牢房里，幸好我的一名手下逃脱出来救了我们<br />
基恩:我差点就遭殃了!<br />
亨利:他们差点把你的眼睛挖瞎<br />
警卫长:但是，究竟是谁接待了你们在这里?你们最后遇到了谁?<br />
亨利:就是那个最后被带走的人<br />
警卫长:古德朗?<br />
基恩:我们以为他就是院长<br />
警卫长:那你们真是逃过一劫了!他是这个机构里最危险的疯子!是他组织了这次叛乱，不过说到这里，我们的院长马亚尔先生到哪去了?天啊!愿他平安无事<br />
亨利:等等!我们进来的时候，那边(指右侧门)有些动静，我敲过去，古德朗就从那里出来了。<br />
警卫长:是吗!<br />
基恩:而且在我们和他说话的时候，我们听到了哀鸣声。<br />
警卫长:天啊!<br />
(亨利盯着右边的门，突然大喊)<br />
亨利:哦!<br />
警卫长:怎么了?<br />
亨利:看那里，门下面!<br />
基恩:那些红色的痕迹，那就是血!<br />
警卫长:(恐惧)噢，天啊!如果那是他的血，(发现马亚尔院长的尸体)<br />
亨利:怎么了?<br />
基恩:发生什么事了?<br />
警卫长:(从里面走出来，双手沾满鲜血)不要进去!太可怕了!(大喊)快去找警察和医生，太可怕了，太可怕了!</p>
<h2 id="恐怖的实验">恐怖的实验</h2>
<p>1909</p>
<h3 id="act1">act1</h3>
<h4 id="scene-1-1">Scene 1</h4>
<p>这是夏尔医生的办公室。陈设简单严谨。背景墙上有一面单向镜，从中可以看到阳光明媚的乡间景色。壁炉柜台上有一尊希波克拉底大理石半身像，还有一盏台灯、化学试剂瓶、手术器械、一个插着鲜花的花瓶等。左右两边也有大窗户，同样可以看到外面的乡村景色。在右边窗户和壁炉之间，有一个支撑着一个大桃木衣柜的矮桌。前台右边有通往餐厅的门。左后台有通往珍妮房间的门。前台左边有一张大沙发。舞台右边有一张大工作桌，斜放着，靠窗照明。桌子后面有一张办公椅。靠桌子右边还有一把椅子。壁炉边还有一张椅子，放在桌子的一角。桌子前面有一个脚凳。左边墙上有一个挂钟，显示时间是下午2点。外面阳光明媚。<br />
幕布从空无一物的舞台上升起。但从左边的门里可以听到热烈的谈论声和椅子移动声。夏尔走进来，珍妮和基恩跟在后面。他看了看表。</p>
<p>夏尔：我们在餐桌上聊了很久!我亲爱的珍妮，你的午餐真是美味极了。<br />
珍妮：你这么觉得吗，爸爸?<br />
夏尔：问问你未婚夫。你觉得怎么样，基恩?<br />
基恩:太好吃了，亲爱的先生。<br />
夏尔：特别是那只加了蘑菇的山鹑。你注意到了吗?(基恩笑了)怎么，你不觉得很好吗?<br />
基恩(笑着)：我在想别的事情。<br />
夏尔：真不可思议!我亲爱的女儿，你费了这么大劲准备一桌菜……<br />
珍妮：没什么大不了的。<br />
夏尔：什么?<br />
珍妮：当基恩来的时候，我很乐意安排好菜肴。虽然他向来对吃的东西不怎么在意，那也无所谓。<br />
夏尔：好吧。我可不像你们两个那么心不在焉，我可注意着呢。现在我们喝杯咖啡吧，在我的办公室里喝。<br />
基恩:好啊。<br />
珍妮：我去拿过来。(退下)<br />
夏尔(对她喊)：快点儿!(对基恩)没有咖啡的好午餐就像漂亮女人没有好头脑。(电话响)好久没有电话铃响了!真令人吃惊!啊，我的朋友，电话真是个祸害!(接起电话)喂?夏尔医生?是我。啊!亲爱的女士，别急成这样。没什么大不了的。(对基恩做了个厌烦的表情)只是小小的消化不良。是的，如果您愿意的话。简单的杨斯或鲁宾拿一剂就好。我明天早上就去看您。是的，女士。再见，女士。(挂断)唉。这些女士和她们的各种毛病。一点小事也要惹你烦恼。她们总是很怕死亡!(他坐到办公桌后)<br />
基恩:尤其是富人!<br />
夏尔：你看，我亲爱的孩子，如果你想当个科学家，就要小心你的资助人。他们的要求永无止境!<br />
基恩:必须谋生嘛<br />
夏尔：确实如此。<br />
基恩:对于像我这样事业刚刚起步的人来说，需要担心的不是客户太多，而是太少。<br />
(他们都笑了)<br />
夏尔：那当然!但是当你有患者的时候，最重要的是教导好他们。如果你总是听从他们的差遣，他们会让你白天黑夜地随时上门，却毫无缘由。<br />
基恩:噢，我知道。如果你太迁就他们，他们就会占你的便宜<br />
夏尔：我来到乡下，就是为了在夏天有安静的时间，能够继续我的实验<br />
基恩:你对进展感到满意吗?<br />
夏尔：非常满意!但你敢信吗？我竟然一直被这些讨厌的电话打扰<br />
珍妮(进来)：咖啡准备好了!<br />
夏尔：刚热的吗?<br />
珍妮：还烫的。<br />
(她和基恩清理桌子，将书搬到壁炉架上。)<br />
夏尔：很好。(玛丽亚端着咖啡盘进来)你的腿今天感觉怎么样?<br />
玛丽亚(脾气不好但坚毅)：我吃了您开的药。我原本不相信，但似乎确实好了一些。<br />
夏尔：很好!不过你还是应该待在房间里。<br />
玛丽亚：为什么我要待在房间里?独自一个人我会觉得很无聊。我喜欢来来去去，见见人<br />
(她为咖啡倒杯子)<br />
夏尔：我也不知道该怎么跟你说。(停顿)你的咖啡简直就是像是用防腐剂泡的!喝完这个，你能去地窖里拿一瓶好香槟吗?你知道，就是门边那个箱子里的。<br />
玛丽亚：您指的是那个黄色封盖的吗?<br />
夏尔：不，是绿色的那个。<br />
珍妮(已经开始给大家倒咖啡)：我去拿吧，亲爱的玛丽亚。<br />
玛丽亚：我自己去拿就行，我还没成废人呢<br />
珍妮：但是我知道放在哪里.<br />
玛丽亚：我也知道，小姐，让我自己来!我可不想让我的小可爱累着。她从今天早上就一直在忙，还没坐下来过，..(气冲冲地退下)<br />
珍妮(笑着)：噢，当她在别人面前叫我"小可爱"的时候，我就知道她生气了。可怜的家伙!<br />
基恩:她在你们家待了多长时间了?<br />
珍妮：玛丽亚?玛丽亚是在我出生前一年来到我们家的。<br />
夏尔：她是个好姑娘。不过也有点毛病<br />
珍妮：不，玛丽亚没有任何毛病。她很照顾我们。我去帮她吧，她一定找不到。<br />
基恩(对只给两人倒咖啡的珍妮说)：你自己不喝吗，珍妮?<br />
夏尔：不，这对她不好。<br />
珍妮：我还可以给你们拿点雪茄来。<br />
夏尔：好。过来，我的孩子，让我看看你。(珍妮向他走近一步)再近一点。<br />
珍妮(咯咯笑着，小步走近)：就像这样?<br />
夏尔:(当她走得很近时)你穿的这件衣服是什么?<br />
珍妮:只是一件很简单的连衣裙。<br />
夏尔:虽然很简单，但我很喜欢。你穿着真漂亮。<br />
珍妮(转头对基恩笑着)：那您觉得呢，先生?<br />
基恩(微笑着)：嗯.<br />
夏尔(开玩笑地打断)：不用问他，你知道他会称赞你。他必须得这样!<br />
珍妮:才不是呢，爸爸。<br />
夏尔(用力抱住她)：爸爸，再说一遍，爸爸。被称为爸爸真让人高兴。想到马上就要，.!噢，我的小珍妮，我的小珍妮。走吧，转个圈让我看看。我只不过是个老傻瓜!<br />
珍妮:老爸，别开玩笑了。<br />
夏尔:我很认真的。好了，现在帮我们拿雪茄来，顺便把我的烟斗也拿来。</p>
<h4 id="scene-2-1">Scene 2</h4>
<p>夏尔(对基恩)：你看，基恩?我有点太溺爱我的女儿了。<br />
基恩:为什么这么说?<br />
夏尔:可能这听起来有点荒谬，我正为我的爱而受折磨。<br />
基恩:你是什么意思?<br />
夏尔：前天晚上，你独自和她待在这个房间的角落里，你们低声交谈，离得很近，我不知道她跟你说了什么，随后你温柔地拥抱了她<br />
基恩:那时候你就在这里吗?<br />
夏尔：当然，我总是在不该在的地方。嗯，这很难承认，但我的感情压倒了理智，我感觉到，我该如何向你解释呢?是一种不安的感觉，嫉妒!<br />
基恩(抗议)：不不!<br />
夏尔：嫉妒!对，没错。一种可以理解的动物般的嫉妒，因为你要把她从我这里夺走<br />
基恩:但是，亲爱的先生，您知道<br />
夏尔：我知道这很荒谬!没有人会这么依恋自己的儿女。不过我可以稍作解释。当母亲早逝的时候，父亲对孩子的依恋会更加深厚。她很小就失去了母亲。<br />
基恩:可怜的小珍妮!<br />
夏尔：我对她的抚养很是费心，好孩子!特别是在五岁左右。那时她常常出现失神的症状!晚上我会发现她双手发烫。她那小小的额头都烧起来了!她甜甜的大眼睛望着我说:"爸爸，这里好痛。"有一天我再也受不了了。我把她带去看我在医院工作的同事Breton医生，我说:"无论如何请你告诉我真相!她到底得了什么病?"他检查后说:"她有点虚弱，有点娇嫩 - 要小心她的心脏 - 但对你最担心的情况我可以说—没有那么严重。"你知道，我当时以为她得了脑膜炎。<br />
基恩:你当时肯定很紧张!<br />
夏尔:我双手抓住Breton，一边哭泣一边抱住他。从那以后，即便我当时还算年轻，我的一切都不再重要了。我活着只为我的女儿。我不再只是个男人，我是个父亲。<br />
基恩:她是个孝顺的女儿。<br />
夏尔:所以当我意识到我即将失去她的时候<br />
基恩:失去她，那可能有点夸张了？<br />
夏尔:但这是事实!她曾全属于我，现在要全属于你。这就是人生!我很满意这门婚事，非常高兴能有你这个女婿，但总有一天你会明白，当你有了自己的孩子 — 她要结婚了，你会很高兴，但同时也会有些许伤感。<br />
基恩:我明白。<br />
夏尔:所以如果有一段时间我看起来有些悲伤，甚至有点无礼，请你不要太在意。这会过去的。我会慢慢习惯的。最终，什么都可以习惯。<br />
基恩:您知道我们永远不会抛弃您!我不仅是您的儿子，也是您的学生。您门下最早的学生之一。您常常允许我与您合作进行研究。我希望我们能继续这样的知性生活，就像一家人一样。<br />
夏尔:你是个好人!不过现在，让我们换个话题吧。我一直在给你讲述我的故事，这可能让你感到无聊了。他们找那瓶酒找得真慢啊!真是个管理不善的家庭。我的小伙子，你以后要盯紧你自己家里的事， (珍妮进来)发生什么事了?</p>
<h4 id="scene-3">Scene 3</h4>
<p>珍妮:我来了，爸爸!您别太着急。我拿来了雪茄和您的烟斗，但是我们找不到那瓶香槟。<br />
夏尔:什么?但那还剩三瓶呢。<br />
珍妮:我们到处找过了。除非被藏在我的房间里了。<br />
基恩:也许家里遭贼了!<br />
夏尔:等等!我真是太笨了!我现在想起来了。我把它们放在我的实验室里了。我让石匠修葺地窖，我担心他们会， (他做了个暗示偷窃的手势)<br />
珍妮:要我让玛丽亚去拿吗，还是我自己去?<br />
夏尔:不，不用，我去。我不能让人在我的实验室里乱动东西。(离开)</p>
<h4 id="scene-4">Scene 4</h4>
<p>珍妮:那你觉得我的咖啡怎么样?<br />
基恩:太好喝了!你确定你自己不喝吗?<br />
珍妮:这是被禁止的。你和爸爸刚才讨论了什么?<br />
基恩:他告诉我他有多爱你!我跟他谈得比平时更亲密了一些。他告诉了我一些事情。我感到，触动，动容。他非常不愿意接受你将要离开他的想法<br />
珍妮:可怜的爸爸!我们两个人在一起的时候，我看得出来他一直被我们要分开的想法所困扰，但我们之间存在一种默契的约定。我们从不提及此事。他该怎么承受得了?我不知道当他独自一个人待在巴黎的大公寓里时，这个冬天对他来说会变成什么样，完全孤单<br />
基恩:他一个人也会过得很充实。<br />
珍妮:我知道。<br />
基恩:早上去医院，下午接待就诊、探访病人、在实验室工作，以及去医学院。<br />
珍妮:是的，但到了晚上!夜晚是人感到孤独的时候。请原谅我说这么直白的话。<br />
基恩:我理解你的担心，珍妮。但我向你保证，我们会让他感受到关爱和温暖<br />
珍妮:是的，不是吗?离开我们他一定会很伤心!而你呢，基恩，你自己快乐吗?<br />
基恩(亲吻她的手)：我比世间的一切都更爱你，珍妮。<br />
珍妮:噢，基恩，我也爱你。<br />
基恩:亲爱的，想到我们很快就会属于彼此!<br />
珍妮:再有五十三天<br />
基恩:准确到天数?<br />
珍妮:我一直在数。每天在日历上画叉。<br />
基恩:就像等待战斗的士兵!<br />
珍妮:是的，就是这样!<br />
基恩:好久啊!五十三天!<br />
珍妮:你等不及了。但对我们来说这只是人生中的一小段时间。<br />
基恩:这话没错，但是<br />
珍妮:说到这个，你有没有跟爸爸谈过我们的蜜月旅行?我们要去哪里?<br />
基恩:你想去哪里都可以!西班牙，还是瑞士，或者意大利<br />
珍妮:噢，意大利!你不是已经去过那里了吗?<br />
基恩:那已经是很久以前的事了!而且当时只是匆匆路过。有很多美丽的地方我都迫不及待想带你一起去探访。那不勒斯，罗马<br />
珍妮:佛罗伦萨，威尼斯<br />
基恩:杜卡宫!<br />
珍妮:贡多拉!<br />
基恩:维苏威火山!<br />
珍妮:教皇!<br />
基恩:你很虔诚吗?<br />
珍妮:我有我自己的信仰。噢!很小的信仰，别害怕，你几乎都不会注意到的。</p>
<h4 id="scene-5">Scene 5</h4>
<p>(夏尔突然回来，手拿一瓶酒)<br />
夏尔:不用担心，我找到了!(基恩和珍妮都在笑)你们怎么了?<br />
珍妮:没什么，只是<br />
基恩:看着真不错!这是什么酒啊!<br />
夏尔:是很不错吧?不过我想你们并不关心这瓶酒。珍妮，你去给我们倒一杯，我看看这封信。(递给她酒瓶。)<br />
珍妮:噢，邮件已经来了?<br />
夏尔:是的。(看到珍妮在倒酒)别摇晃!<br />
珍妮:没有奶奶的信吗?<br />
夏尔:没有，你今天得去看看她。<br />
珍妮:好的。我们应该关心一下她的近况<br />
夏尔:车半小时后就能准备好。<br />
基恩:勒梅尔夫人病了吗?<br />
珍妮(给男士们倒香槟)：只是感冒而已，但她已经这个年纪了<br />
基恩:如果允许的话，我可以陪你去<br />
珍妮:我很乐意<br />
夏尔:不，不行。我需要他留在这里。<br />
珍妮(不高兴):哦。<br />
夏尔:这封信是来自我们的木匠雷诺神父。他写来感谢我。这种表达感激之情的话语还真有点诗意<br />
珍妮:这很合理。毕竟你救了他的命<br />
夏尔:别那么夸张。(喝酒，对基恩)你觉得怎么样?<br />
基恩:太好了!雷诺之前出了什么问题?<br />
夏尔:他开始因为漏气而窒息。我们用了普通的方法都没有结果。可怜的人已经差不多停止呼吸20分钟了，我才亲自出马。<br />
基恩:用你那著名的发电机?<br />
夏尔:是的。<br />
基恩:有用吗?<br />
夏尔:非常有用。说到这里，你昨天去了马西研究所吗?<br />
基恩:去了，那是年度会议<br />
夏尔:我听说他们展示了布朗-塞卡尔实验?<br />
基恩:确实如此。他们给我们展示了一个被切断的狗头，并使它可以存活至少2个小时。<br />
珍妮:他们是怎么做到的?<br />
基恩:他们解剖了动物头部的血管，移植到另一条狗的动脉上。<br />
珍妮:我觉得这个实验很残酷。<br />
夏尔:更是如此，因为它没有告诉我们任何新的东西!大家都知道，只要有充足的血流，大脑就能继续运转，我所研究的是心脏的复活，而不是大脑的存活<br />
基恩:对，我知道<br />
夏尔:大部分死亡都是由于心脏停跳引起的，准确的说，是因为神经冲动失效<br />
基恩:若能在心脏衰竭时，通过电脉冲重新启动心脏，就能拯救数百，甚至数千条生命<br />
基恩:你那里有新的仪器吗?<br />
夏尔:是的，在这个箱子里<br />
基恩:让我来帮你拿吧<br />
夏尔:谢谢。(打开盖子，露出一个带有电流的蓝色管状物)就是它。我用通俗的话给你解释一下 - 你看到那个齿轮了吗?齿轮和齿条?还有线圈?<br />
基恩:看清楚了。<br />
夏尔:这里就是电流流经的地方。频率为每分钟72次。<br />
基恩:模拟正常心跳?<br />
夏尔:对。现在通过线圈的自动运动，我可以获得我想要的电流强度。它是规律的、数学的<br />
基恩:我明白了，我明白了<br />
夏尔:找到电刺激的位置也很重要。有人建议在胸部开个口子<br />
基恩:我本想建议这个。<br />
夏尔:那是错误的。必须穿过膈肌，直到到达靠近心脏的动脉壁，电极必须放在那里。需要一些特殊的手法，我找到了，我已经成功了。今天我要试着让心脏人工跳动几个小时。<br />
基恩:这是一种非常出色的治疗心力衰竭或窒息的方法!<br />
珍妮:是的，太棒了!<br />
基恩:但是，医生，请允许我问一个问题。这种人工抢救能在死后的多长时间内起效?<br />
夏尔:这确实是个关键问题。到目前为止，只有极其聪明的人才会问这个问题。<br />
基恩:让我作为你的学生问一问吧。<br />
夏尔:但是现在我不能回答，只有能回答这个问题的时候，我的研究才算真正完成了。<br />
基恩:有上限存在吗?<br />
夏尔:我认为没有，但是进行实验的机会实在太少。<br />
基恩:你在医院工作时没有机会实验吗?<br />
夏尔:不，我主要是在治疗肺结核或酗酒的病人。所有器官都已经损坏了。我在他们身上没有任何收获。但如果能找到一个健康的普通人，突然死亡的，我或许能得到一些可以改变生理学领域的结果!<br />
珍妮:很长时间之后?几个小时后?<br />
基恩:哦，不!总之，让死者复生是不可能的。<br />
珍妮:当然!<br />
基恩:死亡伴随着彻底的破坏。化学分解是不可逆的。<br />
夏尔:不可逆?我可不这么认为<br />
基恩:至少，这是常人的想法。<br />
夏尔:这个话题值得深究。总之，我们对死亡太过于顺从。正是我们的脆弱和宿命感，给予死亡力量，当我和死亡搏斗来拯救一个病人时，就仿佛我在与一个有思想和意志的敌手、一个邪恶的实体战斗。但我总有获胜的希望。一直到最后一刻，我都在奋战，奋战， (有敲门声)进来!(对进来的玛丽亚说)啊，玛丽亚!你想要什么?<br />
玛丽亚:夏尔医生，有个男人，(递给他一封信)他给我这封便条要给你<br />
夏尔:(看信)又一位病人!让我看看<br />
玛丽亚:我应该说你不在吗?我可以让他走，他穿得不太体面!<br />
夏尔:是的，小心点。让他进来。等等，珍妮，你介意……<br />
珍妮:我明白。我就先离开了。<br />
基恩:我也是。<br />
夏尔:不，你得留下。<br />
基恩:好吧。<br />
珍妮:我什么时候能再见到你们?今晚你们要跟我们一起吃晚餐吗?<br />
基恩:我不想显得太无礼。<br />
夏尔(开玩笑):带走我女儿才是真正的无礼。(对珍妮)那你就去看看你奶奶，然后回来。<br />
珍妮:好的，我开车去。应该很快就能回来。<br />
夏尔:你确定?有40公里远呢。<br />
珍妮:我们走勒佩克的路，更近一些。<br />
玛丽亚:就是查尔斯说的。<br />
珍妮(对基恩):查尔斯是我们的司机。<br />
基恩:我知道。<br />
夏尔:那好，再见!<br />
玛丽亚:小心点，别太晚回来。<br />
夏尔:记得穿外套!<br />
珍妮:我不冷。<br />
夏尔:我怕你冷。你就不能给我一个吻别吗?<br />
珍妮(走过来拥抱亲吻他)：好像我要出远门一样？<br />
夏尔:哦，我亲爱的宝贝!好了，你该走了。(仍握着她的胳膊)<br />
珍妮(笑)：可这样我走不了啊!<br />
夏尔(放手)：好吧，再见，亲爱的!<br />
珍妮:再见!<br />
基恩:再见!</p>
<h4 id="scene-6">Scene 6</h4>
<p>夏尔:好了，我亲爱的玛丽亚，让那个男人进来，好好看看他。你这辈子都不会再见到这样的人。<br />
玛丽亚:什么?难道是总统?<br />
夏尔:不，不完全是。不完全是。他是刽子手。<br />
基恩:哇，你的交际圈还真有意思。<br />
夏尔:没错。他是个很有趣的人。我的实验非常需要他。和他打好关系可不容易，.不过，打扰你一下，能帮我开下窗户吗?<br />
基恩:你觉得热吗?(走过去打开窗户)<br />
夏尔:是的，有些热。看来要下暴雨了。<br />
基恩(望向阳光明媚)：看起来是个美好的日子啊!<br />
夏尔:对你来说，现在每天都是美好的。</p>
<h4 id="scene-7">Scene 7</h4>
<p>(那个男人一身黑衣，有种典型的中产阶级气质)</p>
<p>夏尔:先生，请进<br />
男人:先生<br />
夏尔:这位是我女婿、中央办公室的外科医生德马尔医生。(两人打招呼)请坐。<br />
男人:谢谢您。<br />
夏尔:你介意他在我们讨论时在场吗?<br />
男人:当然不介意。<br />
夏尔:他对这些问题很感兴趣。(窗外传来汽车喇叭声)啊!(对男人)你不介意吧?(快走到窗边)<br />
基恩(也走到窗边)：是教授的女儿珍妮，她正要出门。<br />
夏尔(向窗外喊)：再见!小心点!别太晚回来!<br />
基恩(也在挥手)：再见!<br />
(听到汽车开走的声音。夏尔挥舞着手帕，基恩挥手。)<br />
夏尔(重新坐下)：抱歉，刚才是我女儿。<br />
男人:没关系，我理解。<br />
夏尔:那么，你带给我什么消息?(对基恩)你请坐。(基恩坐下。对男人)好的，说吧。<br />
男人(神秘地)：先生，波瓦捷尔即将会有，一位。<br />
夏尔(记下)：啊!告诉我关于那个受判刑者的情况。<br />
男人:一个流浪汉，试图偷盗一名女子而杀害了她。<br />
夏尔:他多大年纪?<br />
男人:35岁。<br />
夏尔:那具体什么时候执行?<br />
男人:我现在还无法确切告诉你。两三天后就会定下日期。<br />
夏尔:非常感谢。哦，我可不是去看热闹的。我不属于那些猎奇的人。我去过一次，至今都印象很深刻<br />
男人(几乎自言自语)：你说得对，这太令人悲伤了。不得不被迫去。<br />
夏尔(沉默片刻)：那会在哪里执行?<br />
男人:在集市广场，靠近监狱。<br />
夏尔:离监狱有多远?<br />
男人:大约200米。<br />
夏尔:该死!有点远啊<br />
男人:为什么?<br />
夏尔:在那么远的地方，执行之后多长时间能把尸体送到我这里?<br />
男人:哎呀，难道你想对尸体做实验?<br />
夏尔:是的，当然。我记得已经告诉过你了。<br />
男人:我之前没理解你的意思。好吧，这要看你在哪里。在手术室?在医院?<br />
夏尔:不，在监狱的院子里，就在那里<br />
男人:我们得假装把尸体装入棺材，然后偷偷沿路运送尸体，这些大概...大概需要15分钟左右。<br />
夏尔:不能再快点吗?<br />
男人:恐怕不行。我的助手们不习惯急走，而且在众目睽睽之下，他们也不太好急走。<br />
夏尔(对基恩)：如果能在自然死亡的情况下这么快介入就好了。<br />
基恩:但是处刑之后呢?出血情况怎么样?<br />
男人:哦,这位先生,其实我想到了一个办法，如果检察官能允许的话。<br />
夏尔:我可以获得许可。我认识法务部的人事负责人。<br />
男人:您需要复杂的设备吗?<br />
夏尔:我只需要一张很大的桌子就行。<br />
男人:我可以为你设置一顶帐篷,就在我旁边。<br />
夏尔:这样路程就会更短。<br />
男人:没错。而且不需要棺材。但我们仍然要亲手绑缚尸体，简单的捆绑。我们可以把他固定在木板下。我应该能让你尽快地分别得到它的头颅和身体。<br />
夏尔:真的可以做到吗?<br />
男人:是的,在我们和人群之间有一道警戒线。<br />
夏尔:这条件对于我的实验似乎很有利。<br />
男人:先生,如果我现在要过问一些与我无关的事,还请见谅，我不是医生，但在过去20年里,我一直参与处决,您知道,我见过很多事<br />
夏尔:当然。<br />
男人:我曾经见过一些场面，我想我从未向任何人提起过<br />
夏尔:真的吗?<br />
男人(似乎要站起来)：但是我已经占用了您太多时间。也许我打扰到您了。<br />
夏尔:一点也不。你的故事让我非常感兴趣。<br />
男人:哎呀,好吧,听你说起实验,我立即想到了我在南方的一次处决。那是很久以前的事了!我刚开始从事这种工作，被判处死刑的是一个农民,他在强奸后谋杀了一个年轻女孩。我们在准备的时候,他突然一动,被我的剪刀划伤了。他转过头来给了我一个眼神，我永远也忘不了他的眼神。我们不得不把他拖到断头台上,他挣扎得太厉害了。我们四个人才把他放在木板上。我仍能看到那整个场景。当他的头落下时,他的全身都在抽搐,我感到有什么东西抓住了我的胳膊。是他的手。是的,先生,那位死人的手抓住了我，而且抓得那么用力,他的手指都嵌进了我的皮肤里。最后我们费了很大劲才能够把他的手松开，(男人坐着一动不动,脸上满是刚才描述的惊骇之色。)<br />
基恩(对夏尔)：你怎么看?<br />
夏尔:这听起来只不过是神经兴奋导致的强直性痉挛。<br />
基恩:也许吧。但尸体的僵硬也可能产生类似的效果,甚至可能做出一些让你觉得它还活着的动作<br />
夏尔:当然，死后几个小时<br />
基恩:有时在死后不久。<br />
夏尔(对男人)：无论如何,那人的动作都是纯机械性的,没有证据能说明他仍有意识..<br />
男人:也许吧。但是他的眼睛呢?<br />
夏尔:他的眼睛?<br />
男人:通常你知道,当人头落下、滚进刑筒、陷入木屑中后,你就再也见不到它了...它消失了...这次不知为什么,他的头飞出去后又平稳地落在脖子上。那颗头就那样立着...这绝不是幻觉...我的同事也看见了。眼睛睁开着...眼皮在眨动...他的眼神看上去在寻找我...目光慢慢地...慢慢地...落在我的身上<br />
夏尔:这也可以解释。<br />
男人:怎么解释?<br />
夏尔:因为头靠在脖子上,出血停止了。<br />
基恩:大脑就能在这几个瞬间继续存活,因为还有足够的血液<br />
夏尔:布朗-西卡的最近实验已经证明了这一点<br />
男人:(沉默片刻,站起)但是,我得告辞了。时候不早了,我该走了。<br />
夏尔:先生,我很感谢你抽出时间来见我。<br />
男人:先生,我知道您的身份。我听说过您那伟大的工作。很高兴能为您效劳。<br />
夏尔(没有握手)：请让我再次表示感谢。<br />
男人:先生,这是我的荣幸。(对基恩)先生。(离开)</p>
<h4 id="scene-8">Scene 8</h4>
<p>基恩:我从未想象过刽子手会是这样的。他有种善良的气质。看起来连蚊子也不会上海。<br />
夏尔:但你有没有注意到他那痛苦的神情?(电话突然响起)那只野兽醒了。我敢打赌,是那个女人打来抱怨她的肠胃情况。等着瞧吧。(接听电话)喂?喂?(对基恩)莫里哀说得对，对于这些神经过敏的人来说，什么都不会改变<br />
基恩:我希望这次实验的材料的品质会不错。<br />
夏尔:喂?喂?<br />
基恩:她说什么了?<br />
夏尔:天啊!我几乎什么也听不见!昨天一整天都是这样。<br />
基恩:是啊,乡下就是这样。<br />
夏尔:说得对。有像煎东西时的噪音。真烦人。(对电话)什么?<br />
基恩:发生什么了?<br />
夏尔(对基恩):安静!(在电话上)谁在那里?是你吗,查尔斯?<br />
基恩:是修车工吗?<br />
夏尔:什么?出什么事了?车坏了吗?<br />
基恩:什么?<br />
夏尔:大声点,靠!出了意外?珍妮受伤了吗?<br />
基恩:受伤?<br />
夏尔:我听不见。<br />
基恩(试图听)：让我来好吗?<br />
夏尔:我听不见,我告诉过你了。我耳朵嗡嗡响。<br />
基恩(试图接过电话)：拜托,让我试试。<br />
夏尔(推开他)：不,她是我的孩子!我先。(在电话上)她受伤了吗?不?晕倒了?只是晕倒?这是实话吗?好,我马上过去!<br />
基恩:但是,发生什么了?<br />
夏尔:车在勒佩克附近的一个山坡上冲出了路,彻底毁坏了。<br />
基恩:但是珍妮呢?她没事吧?<br />
夏尔:没...司机说没事<br />
基恩:我们必须赶快去她那里。你有药吗?你的医药包在哪?<br />
夏尔:在抽屉里,拿点绷带,棉质的<br />
基恩:好的,好的<br />
夏尔:找到了吗?<br />
基恩:我准备好了所有需要的东西。但是我们怎么去?我们必须尽快。<br />
夏尔:邻居有一辆车。<br />
基恩:啊,太好了!<br />
夏尔:玛丽亚可以跑去他家借车。<br />
基恩:不,让我去。这样更快。<br />
夏尔:(絕望地)天哪!我的天啊!<br />
基恩:请试着保持冷静。我求你了!坚强一点。现在没时间耽搁了。快跟我来!<br />
夏尔:太可怕了。哦,我的朋友,如果我女儿出了什么事!天啊!我不敢想象。(喘不过气来)啊!(靠在桌子上避免倒下。)<br />
基恩:您怎么了?<br />
夏尔:没事。我太震惊了。会过去的。不要等我。你先去吧。快去!快去找她。快去!<br />
(基恩放开他,冲向门口。夏尔跌倒在地,幕落。)</p>
<h3 id="act-2">act 2</h3>
<p>与第一幕相同的布置。左侧的窗户关闭并拉上了窗帘。右侧的窗户仍然敞开。外面可以看到阴沉的乌云。天色渐暗,大约6点钟。<br />
桌子上已经清理干净,只有一顶男士帽放在那里。</p>
<h4 id="scene-1-2">Scene 1</h4>
<p>舞台左上方,当门打开时,我们可以看到珍妮房间里点着蜡烛。<br />
帷幕升起时,舞台是空的。风时不时吹动舞台右侧的帘幕。不时可以听到雷声。<br />
壁炉架上,除了第一幕时的科学仪器外,还放置了毛巾和绷带。沙发上有另一顶男士帽。</p>
<p>过了很久,珍妮房间的门悄无声息地缓缓打开。第一位医生出现,后面跟着第二位医生,最后是基恩,他轻轻关上门。他们的说话声很微弱。<br />
基恩:再次感谢你们能尽力救助她。<br />
第一位医生(从桌子上拿起自己的帽子)：不需要感谢我们。<br />
第二位医生(从沙发上拿起自己的帽子)：我们只是在尽自己的职责。<br />
第一位医生:不幸的是,我们什么也做不了。<br />
第二位医生:你知道,心力衰竭的话.<br />
基恩:你们认为是心力衰竭?<br />
第一位医生:是的。她没有明显的伤害,连瘀伤都没有。<br />
第二位医生:我记得你告诉过我们她的心脏很虚弱。<br />
基恩:是的<br />
第一位医生:真希望我们能及时赶到!<br />
第二位医生:我们到现场时已经太晚了<br />
基恩:想到几个小时前她还兴高采烈,满怀对未来的希望...现在却<br />
第一位医生:她多大年纪?<br />
基恩(强忍着哽咽)：还不到二十岁。我们才刚订婚几天。<br />
第一位医生(握手)：我对您的痛苦深感遗憾。<br />
第二位医生(握手)：我也是。<br />
基恩:他才更需要你们的同情。<br />
第二位医生:她的父亲?<br />
基恩:是的。<br />
第二位医生:我们照顾他女儿时,看到他在我们周围默默地移动。可怜的人啊!他似乎什么也看不见,听不见,也理解不了。<br />
基恩:当司机打电话告诉他发生了车祸时,我就在他身边。他倒在地上一动不动。在我们把他女儿的遗体抬进来后他才恢复了意识,但仍然神情恍惚。<br />
第二位医生:可怜的人!<br />
基恩:她是他唯一的女儿。他一手把她养大...她也从未离开他身边...他的生命就依托于她身上...听,他在哭。(我们听到夏尔在场外哭泣。三个人静静地听了一会儿。)<br />
第一位医生:我们应该把她的尸体带走。<br />
基恩:不可能。自从他恢复意识,他就陷入了让我担心他精神状况的绝望之中。(敲门声,玛丽亚进来。)怎么了?<br />
玛丽亚:先生,只是我...我要点亮油灯,天快黑了。<br />
第一位医生:我们该走了。<br />
第二位医生:等他平静下来后,请代我们向夏尔医生表示慰问<br />
基恩:好的...好的<br />
第一位医生:如果你需要我,我可以随时为你效劳。<br />
第二位医生:我也是,我亲爱的同事。<br />
基恩(给他们开门)：非常感谢。我不会忘记<br />
第二位医生:我们自己出去就行。<br />
第一位医生:您就留在这儿吧。我们认识路。(他们退出。)</p>
<h4 id="scene-2-2">Scene 2</h4>
<p>基恩坐在沙发上,双手捧着头。<br />
玛丽亚:他还在里面吗?<br />
基恩:还在。<br />
玛丽亚:可怜的人。我真为他感到难过。<br />
基恩:他正承受着巨大的痛苦。<br />
玛丽亚:我们都是!<br />
基恩:是的,我们都是。但他<br />
玛丽亚:是的,我知道。她是他的女儿。不一样。<br />
(外面风声呼啸。暴雨落下。窗帘被吹动。)<br />
基恩:你去把窗户关上吧?风越来越大了。<br />
玛丽亚:是暴风雨来了。但愿它能带走我们所有人。(外面传来教堂钟声。)<br />
基恩:那是什么声音?<br />
玛丽亚:教堂那边。他们正在为昨晚去世的可怜的玛丽.露易丝女士敲响丧钟。明天他们将为珍妮小姐敲响。(她开始哭泣。)天哪!我真不敢相信她已经走了!<br />
基恩(安慰她)：没事的,亲爱的玛丽亚。一切都会好起来的。<br />
玛丽亚:我永远无法释怀这种痛苦。<br />
基恩:嘘...另一个房间里有人在走动。<br />
玛丽亚:是夏尔医生吗?<br />
基恩:肯定是他了。别的人都不在。听<br />
玛丽亚:我觉得他在说话<br />
基恩:对,现在听起来像是他往这边来了。小心点。<br />
(他们后退了一步。夏尔像鬼魂一样悄悄地走进来,悲痛欲绝,看起来非常糟糕。)</p>
<h4 id="scene-3-1">Scene 3</h4>
<p>夏尔(自言自语)：哦,太可怕了。这样年轻就离世...这是犯罪,违背自然的犯罪<br />
基恩:我亲爱的先生,我恳求你,你必须振作起来。要有勇气!<br />
玛丽亚:我亲爱的先生<br />
夏尔(望向珍妮的房间)：看!看那边!要是他们没有放那些花就好了<br />
基恩:她是如此喜欢那些花<br />
夏尔：...还有蜡烛,她看起来就像只是在睡觉。(他在基恩的肩膀上哭泣了一会儿。)<br />
玛丽亚:亲爱的先生,让我去陪伴她吧。<br />
夏尔:不,我要独自看护她。只能我一个人去!<br />
玛丽亚(双手合十请求)：噢,夏尔医生!我不会打扰你的。我会待在角落里。我求求您,先生。我也一直看着她长大。您根本不知道我有多爱她。(她哭泣)<br />
夏尔:不,我的女儿只属于我。只属于我一个人!<br />
玛丽亚:我求求您!<br />
夏尔:不!不!(对基恩)叫她走开!<br />
基恩:抱歉,玛丽亚。你该走了。你正在伤害他的感情。请先离开这里。(他温和地把她引向门口。)<br />
玛丽亚(愤怒)：我的天哪!我的天哪!(她哭泣着退出。)</p>
<h4 id="scene-4-1">Scene 4</h4>
<p>夏尔(望着卧室门)：她看上去像睡着了，如果我呼唤她,她就会睁开眼睛。(他呼唤她)珍妮,我亲爱的珍妮,珍妮<br />
基恩:我恳求您,这种想法只会让您的痛苦加重。<br />
夏尔:我不想忘记我的悲痛。我要与之共生!失去我的女儿,对我来说就是失去一切!(回到门口)她的脸是多么平静啊!<br />
基恩:她没有受苦。<br />
夏尔:啊!<br />
基恩:她是因心力衰竭而即死的。<br />
夏尔:心力衰竭?<br />
基恩:是的,她没有其他任何伤害。<br />
夏尔(沉默。内心挣扎。突然握住基恩的手,奇怪地看着他)：这里只有我们两个人吗?<br />
基恩(惊讶)：是的,完全只有我们两个。<br />
夏尔:没有别人在这里吗?<br />
基恩:没有。<br />
夏尔:你真的爱过她吗?<br />
基恩:你怎么能这么问?<br />
夏尔:就算你真的爱过她,但现在你就像其他人一样。顺应死亡。认同死亡。你是个懦夫!<br />
基恩:什么?<br />
夏尔:当然,当我们面对死亡时,我们都是懦夫。<br />
基恩:你在说什么?<br />
夏尔:死亡。我们恨死亡,但我们却容许它如此猖獗。没有人敢与之抗争。但我敢！我会去挑战死亡!<br />
基恩:你打算做什么?<br />
夏尔:本来在别人身上进行的实验...我要在我女儿身上试试<br />
基恩(惊恐)：在你女儿身上?<br />
夏尔(检查壁炉架)：我有剪刀,手术刀,海绵<br />
基恩:不可能。<br />
夏尔:没有什么是不可能的。我们不认识死亡。我们对它一无所知。从未有人有勇气去尝试。<br />
基恩:她已经死亡几个小时了!<br />
夏尔:我要去试试。<br />
基恩:但我们已经尽了一切努力。当时在山坡上,我在草地上找到她的尸体...<br />
夏尔:我当时不在场。<br />
基恩:后来我和其他两位医生一起抢救。我们尽了自己的所能。人工呼吸...<br />
夏尔:你们应该对她的心脏进行急救。<br />
基恩:现在已经太晚了。<br />
夏尔:为什么?<br />
基恩:她的心脏已经死亡了。<br />
夏尔:也许并非如此。我可以让心脏重新跳动。我可以让它跳动数小时。我愿意相信这点!<br />
基恩:之后呢?<br />
夏尔:如果我让心脏跳动几个小时,尸体会发生什么变化,谁知道呢?<br />
基恩:这是不可能的!<br />
夏尔(向珍妮房间走去)：我要去试试。<br />
基恩(挡住他的路)：你疯了!<br />
夏尔:所以你害怕了?<br />
基恩:我担心你神智不清。<br />
夏尔:不,是你害怕了。你说你爱她,但你害怕她。你害怕她的尸体。也许不是害怕,也许是厌恶。<br />
基恩:请你冷静下来!<br />
夏尔:哦!那就让我一个人去吧!我把你当成我的儿子。我的女儿爱你!她几乎是崇拜你!<br />
基恩:那我到底该怎么办?<br />
夏尔:你就在旁边看着吧。(他像个疯子一样进入左边的房间。)<br />
基恩(走到门边观看,被他的行为惊恐)：你在做什么?可怜的人啊,你在做什么?不,夏尔老师!不要这样!夏尔,我求你!<br />
夏尔(抱出珍妮的尸体,观众可以看到她的脸。)：不,我决不放弃!让我一个人来救她。<br />
(他把她放在桌子上,绕到后面,望向观众。珍妮穿着第一幕时的同一件白裙子,腰带和装饰品已被摘下。她的双臂垂下,头发散乱,鞋子也被脱掉。她穿着与衣服同色的白色长袜,躺在桌子上,双脚朝向观众。)<br />
基恩:不,我不敢相信!你不会想...<br />
夏尔:我要进行实验。<br />
基恩:在你自己的女儿身上!<br />
夏尔(调整尸体在桌上的摆放位置)：在我女儿身上。<br />
基恩:我不敢相信!<br />
夏尔:你很快就会看到结果。<br />
基恩:不!不!夏尔,你疯了。<br />
夏尔(没有听基恩的话,望着珍妮)：我可怜的女儿!我们已经等了太久了。(对基恩)给我剪刀。(基恩机械地服从。夏尔开始剪开尸体上的衣服。)要是在她被带到这里的时候我就能这么做就好了。但我当时没有想到这点。我已经失去了理智。(剪开衣服后,他放下剪刀,卷起袖子准备手术。)<br />
基恩(试图阻止他)：听着,夏尔...<br />
夏尔:给我一些棉花和手术刀。在那边。我们必须快点动手。我要做一个切口...<br />
基恩(递给他所需的物品)：这太可怕了!<br />
夏尔:我需要更多灯光。把桌子移过去。(基恩帮他把桌子移到更亮的地方。)你为什么在发抖?你在害怕什么?看到她复活吗?她是我亲爱的女儿,我的珍妮!我几乎认不出她了。死亡损坏了她的容貌。死亡破坏了一切它所触碰的东西。<br />
(夏尔开始进行手术。不久,他放下了手术刀。)啊!<br />
基恩:怎么了?出什么问题了?<br />
夏尔:没什么,没什么。只是一点点血。<br />
基恩:血?<br />
夏尔:是的,我切开了一条血管。有一个血块。<br />
基恩(用双手遮住脸)：这太可怕了!<br />
夏尔:你必须冷静下来。(拾起手术刀)现在是电极。(基恩从盒子里取出电极递给夏尔。)我们必须快点。她的肉体正在腐烂。<br />
基恩:这是在亵渎尸体!<br />
夏尔:你必须平静下来。现在,开启电流。<br />
基恩:这是徒劳!<br />
夏尔:电流开启了吗?<br />
基恩:是的。<br />
夏尔:调高频率。(倾听珍妮的心跳)我把头贴在她的心脏旁,但是什么都听不到。再次调高频率。<br />
基恩:等等,夏尔...<br />
夏尔:我说,再次调高频率!(基恩照做了。电流声。)它就要重新跳动了。我知道它会的!是的,我听到了些动静!不,只是电流的声音。<br />
基恩:你不可能让死者复活!<br />
夏尔:我不能!她的心脏保持僵直,像冻结了一般。已经太晚了。太晚了。结束了。死亡夺走了她。是的,死亡就在这里。我感受到它了。我能感受到它。而我无能为力。死亡夺走了我的女儿。她要随它而去。啊,死亡!你这个混蛋!你这个混蛋!<br />
(他让珍妮的头落在桌子上。外面狂风呼啸。一扇窗户被吹开,风灌进房间。灯熄灭了。舞台陷入黑暗。寂静。我们听到令人不安的单调电流声。唯一的光源是时不时冒出的电火花。两个男人都不由自主地惊叫出声。夏尔从桌子旁退开。)<br />
夏尔:是谁关掉了灯?是你吗?<br />
基恩:不,是风吹灭的。<br />
夏尔:有人进入了房间。<br />
基恩:不,没有人进来。<br />
夏尔:不，有人闯进来了。<br />
基恩:夏尔...<br />
夏尔:我告诉你,有人在这个房间里。有人在这里。在黑暗中。在观察我们。(他盯着女儿的尸体。)<br />
基恩:我恳求你,冷静下来。我去点亮灯。<br />
夏尔:不!不,别动!(停顿)她要醒过来了。<br />
基恩(望着尸体)：什么?<br />
夏尔:她的身体抖动了。(珍妮的手开始移动。)她的手!看,看她的手!<br />
(尸体的右手缓慢、几乎机械但又抽搐地开始升起。手指紧张,好像想掐住什么小东西。夏尔被这只手的动作所吸引。)<br />
基恩:这只是尸僵现象。<br />
夏尔:不,不!她活了过来!毋庸置疑。她正在复活!<br />
基恩:这只是尸体的肌肉收缩。还记得我们之前讨论过这个吗?<br />
夏尔(握住手吻它)：珍妮!我亲爱的珍妮!(但就在他的嘴触到那只手时,它抓住了他的脸,然后紧紧攫住他的脖子。死者的手指越握越紧,直到夏尔发出一声惨叫跪了下来,仍被那只手控制着。声音嘶哑):你弄痛我了!你握得太紧了!<br />
基恩:这只是肌肉收缩反应,再加上电流的作用!(他跑去关掉电流。)<br />
夏尔:救命!救命!我喘不过气来。(对尸体)放开我!你在勒死我!放开我!<br />
基恩(试图让手松开)：我做不到!<br />
夏尔:我要窒息了!(在挣扎中,他把尸体从桌子上撞了下去,滑落到地板上。)<br />
基恩(试图掰开手)：我们得把手砍掉!(抓住手,突然大喊)救命!玛丽亚,快来!<br />
(基恩终于将尸体的手从夏尔颈部移开。夏尔无声地断了气。门开了,年迈的女仆惊慌地进来,在门槛处呆住,被眼前的景象吓到。)</p>
<h4 id="scene-5-1">Scene 5</h4>
<p>玛丽亚(发出惊恐的尖叫)：这里发生了什么事?<br />
基恩(检查夏尔的脉搏)：他死了,被勒死了!<br />
玛丽亚:被勒死?<br />
基恩:他想尝试一个实验...想让女儿复活...<br />
玛丽亚(跪下,画十字圣号)：试图欺骗死神是亵神的行为...<br />
基恩(望着珍妮和夏尔的尸体)：看来死神已经报了仇。<br />
(帷幕在痛苦与恐惧的景象中落下。)</p>
<h2 id="幻觉实验室">幻觉实验室</h2>
<p>1916<br />
这篇只找到法语版，很难校对机翻，可能会有偏差</p>
<h3 id="act1-1">act1</h3>
<p>我们来到了俄罗斯乡下的一座与世隔绝的疗养院。<br />
主要人物:</p>
<p>戈尔利茨医生，他是一位杰出的神经外科医生，也是疗养院的院长，以其不同寻常的实验而闻名<br />
他的妻子索尼娅百无聊赖，梦想着逃离令她恐惧的疗养院和丈夫<br />
塔尼娅:索尼娅的表姐<br />
玛丽萨:索尼娅的佣人<br />
米琴:医生的助手<br />
德摩拉:一位绅士</p>
<p>帷幕拉开，客厅里陈设富丽堂皇——哥特式风格，悲凉而阴暗。索尼娅的表妹塔妮娅独自一人拉着小提琴。曲调忧郁哀伤(索尼娅走进来，她听了一会儿表妹的演奏 然后打断了她)</p>
<p>索尼娅:我在等莫拉先生。(铃声)<br />
塔尼娅:你还是打算在这样的天气里去参观那些废墟吗?<br />
索尼娅:是的，我必须出去。离开这个房子，它，你确定不想和我们一起去吗?<br />
玛丽萨:(门开了又关，玛丽萨进来，脚步声)索尼娅夫人<br />
索尼娅:你把我的信送出去了吗?<br />
玛丽萨:是的，夫人。<br />
索尼娅:谢谢你。请帮我拿我的皮大衣来。<br />
玛丽萨:(玛丽萨准备离开，脚步声)是的，夫人。夫人?<br />
索尼娅:什么?怎么了?<br />
玛丽萨:我必须和您谈谈<br />
索尼娅:当然，请讲吧。<br />
玛丽萨:夫人，我觉得<br />
索尼娅:直说吧!<br />
玛丽萨:夫人，我再也待不下去了!<br />
索尼娅:什么?<br />
玛丽萨:我真的待不下去了!<br />
索尼娅:天哪，玛丽萨，这不可能!你想离开我，为什么呢?<br />
玛丽萨:夫人，您知道我是多么忠诚于您<br />
索尼娅:正是如此!所以我不明白你为什么要走，你对我有什么怨言吗?<br />
玛丽萨:哦!没有，从未有过，夫人对我一直很好。但是这个房子，我再也待不下去了!当我们还在城里的时候，还可以忍受，但是在这个偏远荒凉的地方，而且，事情只会越来越糟，如果不是因为夫人，我早就走了!因为您看，夫人，在这里，我<br />
索尼娅:什么?你怎么了?<br />
玛丽萨:我害怕!<br />
索尼娅:可怜的玛丽萨，你不应该，你不应该，这太可笑了!你不需要害怕。不是吗，塔尼娅?<br />
塔尼娅:是的，玛丽萨，你并没有什么危险。<br />
玛丽萨:(玛丽萨和索尼娅拥抱)是的，我知道，但我还是害怕，我害怕，夜里，我经常做噩梦，可怕的噩梦!(尖叫声)<br />
索尼娅:啊!<br />
玛丽萨:您听见了吗，夫人!您听见了吗?又来了!两天来一直这样<br />
索尼娅:玛丽萨，留下来陪我，不要离开我<br />
塔尼娅:呆在这里需要勇气和耐心，也许这样的情况不会永远持续下去。<br />
玛丽萨:哦，夫人<br />
索尼娅:去看看汽车准备好了没有。然后你给我拿我的皮大衣来。<br />
玛丽萨:(脚步声+门打开关上+玛丽萨离开)好的，夫人。<br />
索尼娅:风真大啊 塔尼娅:你不喜欢这个国家吗?<br />
索尼娅:哦!不，特别是冬天!冬天总是阴沉沉的，一片漆黑。<br />
塔尼娅:不，你看，外面阳光明媚。<br />
索尼娅:啊!我有相反的感受，这是这个房子的气氛。你知道，在这里人们总是这样认为<br />
米琴:(门打开，米琴进来)对不起，夫人，医生要求我来拿钥匙，他要去车库。<br />
索尼娅:车库的钥匙?我没有。<br />
米琴:夫人，医生说您应该有的。<br />
索尼娅:我真的没有。<br />
塔尼娅:是不是丢了?钥匙通常在哪里?<br />
米琴:在他卧室的小书柜里。<br />
索尼娅:那么它们应该还在那里，你去看看<br />
米琴:(门关上，米琴离开)好的，夫人。<br />
索尼娅:他想要这些钥匙干什么?他想自己保管吗?这肯定又是引发什么阴谋的借口!<br />
塔尼娅:他常常对你这样吗?索尼娅<br />
米琴:(门打开关上)夫人，我找到钥匙了。<br />
索尼娅:米琴先生，这钥匙的事是怎么回事?<br />
米琴:我不知道，夫人。医生很生气，因为他觉得有人进了实验室。<br />
塔尼娅:进了实验室?那车库的钥匙又是为什么?<br />
米琴:他现在想要拿到整个房子的所有钥匙。<br />
索尼娅:这肯定又是为了折磨我<br />
塔尼娅:你说有人进了他的实验室。<br />
米琴:他是这么认为的。<br />
索尼娅:那么是谁，为什么这样做?<br />
塔尼娅:难道里面有什么值得偷的东西吗?<br />
米琴:偷，没有，你知道，小姐，医生是很多疑的。他总是认为人们很好奇，他不想让人插手他在家里做的实验，他的工作<br />
塔尼娅:天哪!那个实验室里到底有什么这么不同寻常?<br />
米琴:什么也没有，小姐，什么也没有!总之，我不知道，就像其他地方一样，有实验，化学分析，X光检查，.(尖叫声)<br />
索尼娅:我丈夫，现在正在手术吗?<br />
米琴:不，夫人。<br />
塔尼娅:但那些尖叫声是哪来的?<br />
米琴:现在正在包扎某些病人的伤口..您知道，医生可能手法不太<br />
索尼娅:我知道，他常常很粗暴，对吗?<br />
米琴:对他来说，疼痛是不存在的。<br />
塔尼娅:尤其是别人的疼痛。你的手怎么样了?<br />
米琴:(门打开关上)像您看到的那样，X光烧伤很深。伤口现在好了，但我想我的手可能是废了，必须学会忍受痛苦，为了科学，还有，为了谋生。(沉默，小提琴声)<br />
戈尔利茨医生:(门进入)塔尼娅!(小提琴声)<br />
塔尼娅:哦!你吓了我一跳!<br />
戈尔利茨:你知道这个时候我不想有任何噪音。<br />
塔尼娅:这会打扰病人吗?<br />
戈尔利茨:不!不是他们，而是我!<br />
索尼娅:啊!连演奏音乐都不行!<br />
戈尔利茨:(语气温和)索尼娅<br />
索尼娅:怎么这样?<br />
戈尔利茨:我从事的工作是一项伟大的杰作，是科学，我正走向伟大的发现，划时代的发现，我为科学而工作，为自己，也为你。如果你不那么轻浮，你就会理解我对你的爱<br />
索尼娅:你的爱，哦!求求你，别用那种话来对付我!<br />
戈尔利茨:索尼娅，我禁止你用这种方式与我说话，尤其是在其他人面前。索尼娅<br />
索尼娅:(戈尔利茨双臂交叉)让我安静点。你把我带到这个野蛮的国家，我要无聊死了，我会死在这里，你迫使我住在这个充满痛苦和哀嚎的房子里<br />
塔尼娅:你知道农民们是怎么称呼它的吗?痛苦之院!<br />
戈尔利茨:胡说!<br />
索尼娅:现在连演奏一点点音乐都不行了，只是想分散一下注意力<br />
戈尔利茨:你在说什么?是我让你邀请你的表姐来的。而且你们也不是被关在这里。你可以随意使用汽车。这个国家很漂亮。<br />
塔尼娅:阴郁!<br />
戈尔利茨:总之，我会继续我的工作，这些工作会给我带来荣誉，你有一天会为之自豪!你看，我真诚地，深深地，爱着你，(戈尔利茨抓住她的手腕)疯狂地，来，吻我!(索尼娅不动。他扭她的手腕)吻我!(她挣脱开来)<br />
索尼娅:哦，你弄疼我了!<br />
塔尼娅:你太粗暴了!<br />
索尼娅:我告诉你，我再说一遍，我只要求一件事，让我安静地一个人待着!<br />
戈尔利茨:索尼娅!我向你道歉!<br />
塔尼娅:现在道歉已经太迟了!<br />
戈尔利茨:是的，我，我确实有些粗鲁，总之，我先走了。你们应该去外面散散步，今天天气真好。我需要去完成包扎工作。<br />
玛丽萨:(门打开，德摩拉进来)德摩拉先生。<br />
德摩拉:亲爱的夫人，医生。<br />
索尼娅:你好，先生。这位是我的表姐卡托娃小姐。<br />
德摩拉:卡托娃小姐，您好吗?医生，您的病人怎么样?我相信在您的手下，他们一定都能痊愈，让自己的继承人大失所望!<br />
戈尔利茨:(用奇怪的语气)但有些人永远无法痊愈。<br />
德摩拉:真遗憾。我们都应该康复啊!因为生命是如此美好!<br />
索尼娅:然而，也有人希望能死去<br />
塔尼娅:哦，索尼娅，这些是阴郁的想法!<br />
德摩拉:医生，这样的想法是不应该被容忍的。<br />
戈尔利茨:阴郁的想法?我完全不了解!把这些想法留给那些既不喜欢工作也不喜欢学习的人吧!<br />
德摩拉:您说得很对。我希望您能让我参观一下您的实验室。<br />
索尼娅:别想了，那是禁地!<br />
德摩拉:禁地?<br />
戈尔利茨:这话不完全正确。我会让您参观我的实验室，总有一天，是的，当里面有值得您观看的东西的时候。<br />
塔尼娅:这可是件稀罕事。我这位妹夫从不允许任何人进入。<br />
戈尔利茨:你们在说什么，当然可以进。只是我不希望那些记者胡说八道，让大众把我当成一个江湖骗子。<br />
德摩拉:当然，您是对的。(尴尬的沉默)<br />
索尼娅:我们本来打算参观那些废墟<br />
德摩拉:是的。柏树谷的罗马废墟非常有趣。既然您慷慨地让我们使用您的汽车。<br />
戈尔利茨:当然可以。我的妻子和表姐在这里缺乏娱乐。我们离任何城市都很远，日子太单调了，什么也不会发生<br />
米琴:(门打开)医生，我们要给昨天进来的那个病人打针<br />
戈尔利茨:好的，我这就去。祝你们玩得开心。你们打算走哪条路?<br />
德摩拉:我想最好是先走林中小道，然后沿瓦尔谷的路回来，那条路真漂亮。<br />
戈尔利茨:确实很美，不过路况不太好。<br />
索尼娅:我已经准备好了。走吧，出发吧。(对塔尼娅)你真的不想和我们一起去吗?(塔尼娅摇头表示不想去)<br />
德摩拉:再见，小姐。再见，医生，我们就不打扰您的研究了。(脚步声+门关上)<br />
戈尔利茨:(对塔尼娅)你真的不想陪他们去吗?给我们弹奏点音乐来慰藉他们的离去?(塔尼娅困惑)<br />
塔尼娅:但是你刚才说，我先走了。(急促的脚步声+门打开关上)<br />
米琴:医生，打针?<br />
戈尔利茨:好的，我这就去。<br />
米琴:新的X光图刚刚送来了。贝洛医生的那个。您要看看吗?<br />
戈尔利茨:稍后吧，现在不急。好了，米琴，打完针后，我们去看看6号病房的那个病人。<br />
米琴:6号?<br />
戈尔利茨:对，那个肿瘤病人。<br />
米琴:肿瘤?<br />
戈尔利茨:怎么了?<br />
米琴:但是，现在，对于那个病人来说，治疗已经太迟了。<br />
戈尔利茨:那你难道忘了我跟你说过那个病人是注定会死的?这是尝试新疗法的好机会。<br />
米琴:啊!不!不!不可能的，我做不到。<br />
戈尔利茨:什么!<br />
米琴:听着，不!我不能参与这种实验。你想拉我去，不!太危险了。我已经<br />
戈尔利茨:已经?<br />
米琴:我已经，在这里做了一些，一些不应该做的事情，总之，不!我不要!我宁愿离开。<br />
戈尔利茨:离开!离开!就在我需要你的时候，就在我即将取得成功的时候!离开!好像你真的能这么做一样，.好像你有自由去做你想做的事!有自己的意志去反对我的命令!<br />
米琴:但你不能强迫我!<br />
戈尔利茨:(戈尔利茨的目光)<br />
米琴:可是，看在上帝的份上，没有什么能强迫我去做我认为，认为是，是犯罪的事情!<br />
戈尔利茨:犯罪!犯罪!你竟然把它称为犯罪，白痴!你的多疑也来得太晚了!听着:我了解你的过去。在我接纳你之前，我就已经了解了<br />
米琴:啊!<br />
戈尔利茨:够了，闭嘴，否则，好了，过来!把这些东西都拿到实验室去。(脚步声+门打开)我们开始工作吧!<br />
米琴:工作!(脚步声+门关上的声音)</p>
<h3 id="act2">act2</h3>
<p>(手术室)<br />
(小提琴声)<br />
戈尔利茨:过来，米琦!(大脑X光)肿瘤就在这里。我们要进行第三次手术，但这个病人是救不回来的。肿瘤肯定会复发，这是必然的结果!趁这次手术，我们进行A字型切口(手术刀)一直切到这条对角线(再次手术刀)。我确信通过这个切口，30多年来我对大脑的研究，让我获得了充分的信心!啊!大脑，多么奇妙的机器!这里孕育着一切知识，没有这些知识，外界世界不过是空洞的词语，还有幻觉、幻想、幻听，而这一切都被隐藏着，不，是被遮蔽着，对，就是被遮蔽着。而我已经揭开了这层面纱!我敢于做那些科学家们不敢尝试的事。现在的医生都太过胆小。但是我不胆小!我的经验是毋庸置疑的。这一定会成功。一定会成功!一切准备好了吗?<br />
米琦:是的。<br />
戈尔利茨:氯仿?面罩?皮带? 米琦:都准备好了。<br />
戈尔利茨:好，去把病人带来，你听到我说的了吗?<br />
米琦:是的，我听到了<br />
戈尔利茨:那就去!(脚步声+门打开+病人进来)<br />
米琦:坐在那里。<br />
病人:不，不<br />
戈尔利茨:来，你要坐下!(椅子)<br />
病人:(病人的眼睛)哦!我不想被触碰!我不想!我不想<br />
米琦:好啦，看着，你要安静下来，这是什么表演?<br />
病人:不，医生，不!我不想再受伤害了!<br />
戈尔利茨:但是我不会伤害你。<br />
病人:是的，我知道，我知道<br />
戈尔利茨:你一无所知!来，米琦，看看这双眼睛<br />
米琦:别动!是的<br />
戈尔利茨:现在你要听话!你知道我不会伤害你，我们会让你睡着的<br />
病人:不!不!我不想被弄昏!不!你们已经折磨我两次了!<br />
米琦:你在说什么?.你疯了!<br />
病人:我一点也不疯。在这间医院里，没有安全感，他们会让你睡着，让你睡着，然后你就不知道发生了什么<br />
戈尔利茨:当你睡着的时候，我们是在治疗你，为了你好。<br />
病人:这不一定!有人说你们在做实验<br />
戈尔利茨:蠢货!<br />
病人:我要离开，我要离开这里，我已经痊愈了!<br />
戈尔利茨:痊愈了!你真以为是这样吗?(病人站起)米琦，把她扶起来。(米琦帮助她站起来。)好了，让她走，(对病人)走走看，(病人试着走几步，停下来摇晃。)你说你好了!<br />
病人:我在外面就会好起来!<br />
米琦:外面?什么"外面"?你在公路上只会饿死的，可怜的女孩。在这里，你身处一家高级疗养院。戈尔利茨医生是出于善意接纳你的。<br />
戈尔利茨:而且你在这里得到很好的照顾。来，告诉我，你在这里有没有得到很好的照顾? 病人:是的，但是你照顾我是因为<br />
戈尔利茨:那不是重点，当你被送到这里来的时候，你已经同意接受治疗了。你同意了!<br />
病人:哦!我痛苦的时候比不痛的时候还多，我不知道该<br />
戈尔利茨:我向你保证，你不会有任何危险。而且，如果你想要钱的话，好吧!你会得到钱!<br />
病人:不，我不要钱，我要<br />
戈尔利茨:够了!现在，米琦!皮带，面罩<br />
病人:(挣扎)不!不!<br />
戈尔利茨:啊!(拳头)<br />
病人:哦! (吵闹声)<br />
米琦:这是什么声音?<br />
戈尔利茨:这是什么声音?真让人恼火!这什么意思?<br />
米琦:我不知道，我，(敲门声)什么?(又有敲门声)医生正忙。是谁?<br />
索尼娅(在外面):是我!戈尔利茨夫人!开门!<br />
米琦:什么，你想要什么?你知道医生不允许任何人来这里!<br />
索尼娅(在外面):求你们，开门!出事了。<br />
戈尔利茨:什么，出事了?<br />
索尼娅(在外面):是的!出事了，汽车，哦，天哪!<br />
戈尔利茨:(对病人)你走吧。今天我们不会对你进行治疗了<br />
病人:今天不行，以后也不行<br />
戈尔利茨:(对米琦)把她带走!<br />
病人:不，不，今天不行，以后也不行 戈尔利茨:把她带走!(解锁+门打开)怎么回事?怎么回事?<br />
索尼娅:哦，天哪!<br />
戈尔利茨:快说!说啊!<br />
索尼娅:汽车，在那里，在路上!就在这附近，哦，太可怕了!太可怕了!德·摩拉先生，受伤了<br />
戈尔利茨:受伤，重伤?<br />
索尼娅:我，我不知道<br />
戈尔利茨:啊!他在哪里?<br />
索尼娅:他们正把他送来，(送来德·摩拉)哦!求求你，要看看他怎么样，赶快救救他。哦，太可怕了。<br />
戈尔利茨:还好你没有受伤!<br />
塔尼娅:他的脸上全是血，他已经说不了话了，他就像<br />
戈尔利茨:好了，冷静下来<br />
索尼娅:如果他死了怎么办!<br />
塔尼娅:他来了!<br />
索尼娅:啊!啊!天哪!<br />
戈尔利茨:冷静!你怎么了?<br />
索尼娅:不，不，我没事，我没事<br />
戈尔利茨:你没事?胡说!你面色苍白，走开。你在这里无事可做。走开。米琦，拿些醚。(对斯蒂克)这次事故是怎么发生的?<br />
斯蒂克:我也不知道是怎么发生的，先生!我开得很慢，挂着中档，汽车突然不受控制，飞出去了。(汽车事故+图像)轮胎一定是打滑，或者是什么东西坏掉了。但是我发誓，先生<br />
米琦:他头部受到撞击，我担心有什么东西穿进去了<br />
戈尔利茨:我们来看看，斯蒂克和玛丽萨，你们能把他抬进来吗?你们准备好了吗?好的，离挡板远一点， 好了。保持他稳定。就这样。(对米琦)关灯。 (黑暗)斯蒂克，当他被抬起来时，伤员是什么姿势?<br />
斯蒂克:趴在地上，两条腿被引擎盖压住了<br />
米琦:他的头附近有金属物品吗?<br />
斯蒂克:肯定有，方向盘都碎了，到处都是碎片，(对医生)但我发誓，先生<br />
医生:我们要给他做头部X光检查。(对斯蒂克和玛丽萨)你们要好好扶住他，明白吗?通电!(嘶嘶声+X光)米琦，你看到这个阴影了吗?<br />
米琦:我看到了。看起来像方向盘或轮胎的碎片。是的，是的，很清楚。头骨被敲碎，伤及顶叶。<br />
医生:好，够了。(开关+手术室)把病人抬走，放下来。(病人呻吟)<br />
玛丽萨:他在叫痛!<br />
德·摩拉:索，尼，娅<br />
玛丽萨:他在说什么?<br />
塔尼娅:他在呼唤某个人。<br />
德·摩拉:索，尼，娅<br />
医生:没什么，他在胡言乱语!(对塔尼娅和玛丽萨)好了，不要这样围着他，去照顾我妻子去。<br />
德·摩拉:索尼娅<br />
医生:走吧!(对斯蒂克)你也可以走了。米琦，送他们出去，但快点回来。我需要你。(脚步声+门关上)<br />
德·摩拉:索尼娅!哦，索尼娅，我的挚爱， (戈尔利茨在病人身上找到一封信)<br />
医生:这是什么信?(沙沙声)可恶!可恶!<br />
索尼娅:(门开)那么，那么，他怎么样?你检查过了吗?伤势严重吗?告诉我<br />
医生:你为什么要回来?你知道你该待在别的地方。<br />
索尼娅:原谅我。我，我只是想知道<br />
医生:你想知道什么?<br />
索尼娅:他有生命危险吗?<br />
医生:我们要为他动手术。<br />
索尼娅:动手术!<br />
医生:是的，我们要进行开颅手术<br />
索尼娅:哦!那，那是个危险的手术吗?<br />
米琦:非常危险<br />
索尼娅:他不会死吧?<br />
医生:不，他不会死的。<br />
索尼娅:哦!你知道的，要是他死了，那就太可怕了，这都是因为我，是的，都是因为我才导致他受伤的，我觉得，我应该为他的死负责!<br />
医生:是的，是的，我理解，我完全理解，现在走吧，让我一个人，一个人静一静!(脚步声+门关上+小提琴声)</p>
<h3 id="act3">act3</h3>
<p>(几周后) 塔尼娅:(停下演奏)不，艾尔玛女士，请留下来，我求你。你还是不知道米琦的下落吗?<br />
护士:不，我们没有任何消息<br />
玛丽萨:他已经失踪40天了<br />
护士:确切地说，41天了!我担心他不会再回来了!<br />
塔尼娅:为什么?<br />
护士:我不知道，但是<br />
塔尼娅:但是什么?<br />
护士:在他失踪的前一天，他在实验室和病房里徘徊，就像疯了一样，我们能听到他自言自语，"不!不!太可怕了!我不能再，太可怕了!"<br />
斯蒂克:他性格古怪，行为举止非常奇怪。我很早就注意到了。<br />
护士:他离开的那一天 — 也就是那个伤员(指德·摩拉)手术后的第二天 — 你知道，那辆汽车出了事故<br />
塔尼娅:是的，可怜的德·摩拉先生<br />
护士:那一天，我被他脸上痛苦的表情吓到了。我觉得他遇到了什么事，很不寻常的事，也许是一件惨事，能让人走向自杀的那种悲惨。<br />
塔尼娅和玛丽萨: 不!<br />
斯蒂克:对于像他这样的神经失常的人来说，什么都有可能!但医生一定会感到遗憾!他跟我说米琦是个很能干的助手<br />
塔尼娅:那么德·摩拉先生怎么样了?<br />
护士:不太好。病情越来越严重。发病越来越频繁。<br />
塔尼娅:发作之后呢?<br />
护士:发作越厉害，抑郁情况就越重。上次发病，就在昨天，真很可怕。<br />
塔尼娅:可怕?是怎么回事?<br />
护士:我从未见过这种情况。他很安静，非常安静，似乎在睡觉，突然，他站了起来，(德·摩拉发作)沿着墙壁静悄悄地走动，就像困在笼子里的野兽<br />
塔尼娅:然后呢?.. 护士:然后，他停了下来，跌坐在椅子上，开始说话，说话<br />
塔尼娅:他说些什么?<br />
护士:他说头痛，说他在痛苦中煎熬，频繁看到幻觉。<br />
塔尼娅:什么样的幻觉?<br />
护士:哦!太可怕了!活生生的噩梦，无法名状的恐怖，粘稠地包裹着他，鬼魂，死人，尤其是死人，他到处都能看到死人!从他的手开始到全身都开始发抖..他发出粗哑的声音，像在咆哮一样!他喘不过气来，流着口水，然后就是可怕的痉挛，我以为他要死了。<br />
玛丽萨:哦!<br />
斯蒂克:不，医生告诉我他不会死的，他没有这么脆弱<br />
护士:医生让我把他带到这里来<br />
塔尼娅:这里?<br />
护士:是的，(对玛丽萨)请去请夫人过来。<br />
玛丽萨:但她正在休息，我这就去。(脚步声+门关上)<br />
护士:(对塔尼娅)小姐，昨晚发生了一些奇怪的事<br />
塔尼娅:昨晚?<br />
护士:是的，我值夜班照看那位病人，我听到有声音，好像有人在花园里踱步，在围着这栋房子转悠。<br />
塔尼娅:啊!啊!<br />
护士:我出去看了，瞥见有什么一个黑影在逃跑。<br />
塔尼娅:你一定弄错了!<br />
护士:哦!我可不这么认为<br />
医生:(门打开)艾尔玛女士，你去找德·摩拉先生?塔尼娅，你知道音乐会打扰我的!<br />
塔尼娅:是的，我<br />
医生:索尼娅在哪里?<br />
塔尼娅:她<br />
索尼娅:(脚步声)我在这里。(门关上)你已经好几天把自己关在实验室里了。<br />
医生:是的，我有很多工作要做。<br />
索尼娅:有人告诉我米琦走了。是真的吗?<br />
医生:是的。<br />
索尼娅:我很奇怪为什么再也见不到他了。他们还告诉我，他前一段时间突然离开了<br />
医生:那又怎么样?<br />
索尼娅:这是怎么回事?你们之间发生了什么?<br />
医生:没什么，他只是个有些古怪、有些狂热的孩子，这就是我想告诉你的全部了吗?<br />
索尼娅:是的。<br />
医生:你不想知道德·摩拉的情况吗?<br />
索尼娅:我当然想知道。他好些了吗?<br />
医生:他现在能起来走动了。他马上就会来这里。如果你愿意等一会儿的话，很快就能见到他。<br />
索尼娅:(压抑住喜悦的叫声)啊!<br />
医生:我想这会让你很高兴的<br />
索尼娅:哦!是的，当然，我很高兴这个可怜的家伙好些了!是的，我有些愧疚，这可怕的事故都是因为我们。发生在我们的车上。在某种程度上我也有责任 医生:是的，是的<br />
索尼娅:幸好你救了他。<br />
医生:是的，我救了他一命。<br />
索尼娅:那么，他痊愈了吗?<br />
医生:啊!痊愈<br />
索尼娅:总之，他已经脱离危险了?<br />
医生:是的，但你会发现他有些变化，你知道的。经过那样的手术，受了那么大的创伤<br />
医生:(门打开)他来了，好吧，德·摩拉先生，您这次外出感觉如何?<br />
德·摩拉:我还是虚弱。<br />
医生:请坐下。<br />
德·摩拉:(坐下)谢谢。<br />
索尼娅:我丈夫告诉我，您现在已经康复得很好了，您还在痛苦吗?<br />
德·摩拉:是的，很痛苦<br />
索尼娅:您会得到很好的治疗的，您看着吧!您会康复的，我向您保证您一定会康复的，只需要耐心和勇气。您受到了如此沉重的打击<br />
医生:请原谅我。我得去照顾一位病人。斯蒂克，您愿意帮我一把吗?没有米琦在，您知道的，(脚步声)(对妻子)我请求你不要让他说太多话，(门关上)<br />
索尼娅:总之，您现在好多了。<br />
德·摩拉:我很痛苦<br />
索尼娅:我也很痛苦!啊!可怜的摩拉，如果您知道，我一直在围着您的病房打转，您在那里饱受折磨，游离在生死边缘，让我听听您的声音吧，现在只有我们两个人 德·摩拉:是的<br />
索尼娅:哦!我的朋友，您一定受了多大的痛苦!<br />
德·摩拉:是的，我很痛苦，我痛苦得很，我感受到了可怕的痛楚，就在这里，您看，(他指着头)仿佛全世界的痛苦都在我这里，在我的头里!就像有人在把我头里的东西都挖出来一样，然后就是一阵阵的剧痛，就像被斧头砍过一样，就像有人用红烧的铁棍戳我的眼睛<br />
索尼娅:多么痛苦啊!您还记得您从前对我说过的话吗，不记得了?我们谈论过幸福，您说您爱我，我们一起寻找逃离这里开始美好生活的办法，远离这里，生活在欢乐和爱中，原谅我，我让您疲惫了<br />
德·摩拉:我好痛苦!但你在哪里?我看不到你了，我害怕，我害怕，不!不要害怕，我看得见，是的，我能看到，棺材的木板，殡衣，尸体。是的，.生命已经远去很久了，这不是我的错，不是我的错，等等，现在有人在对我说话，在命令我说话，(他用拳头砸自己的头)我不要，我不要!(德·摩拉试图杀死索尼娅。)走开，我要杀了你!走开!走开!我要杀了你。<br />
索尼娅:救命啊!<br />
德·摩拉:走开，走开，否则我要杀了你，我要掐死你<br />
索尼娅:救命!救命!(门打开)<br />
医生:这太可怕了，不是吗?<br />
塔尼娅:哦!太可怕了，这是什么?这是什么?<br />
医生:伤口的后果!碎片深入进去了，伤势很严重。<br />
索尼娅:太可怕了!太可怕了，那双眼睛!哦!那张颤抖的嘴!他在流口水，我已经认不出来他，这不是他。<br />
医生:是吗?<br />
索尼娅:难道他要死了!<br />
医生:不，他的生命没有危险，我救了他的生命，但是此外就难说了!人的本质在于大脑，当大脑受损时，就什么也没有了，他会恢复意识，重拾理智。然后发作越来越频繁，最终会完全沦为一个可怜的废人，除了痛苦，什么也感知不到了<br />
索尼娅:但是，你好像，好像对此感到高兴，是的，对他的痛苦感到高兴!<br />
医生:高兴?当然会<br />
索尼娅:但是<br />
医生:我做了我应该做的手术。我取出了伤口里的异物，(戈尔利茨的笑声)然后，.(望着索尼娅)然后，一下子就消去了他的理智!<br />
塔尼娅:什么?<br />
医生:是的，我需要一个实验对象，并且，有米琦的协助<br />
塔尼娅:米琦!<br />
医生:我做了一个小小的切口，于是，于是我打开了通往疯狂的大门，我造就了幻觉与邪恶。现在，看到了吗!我的理论是正确的!<br />
塔尼娅:你竟敢犯下这种罪行?<br />
医生:我当然敢。<br />
索尼娅:但为什么?为什么?<br />
医生:(纸的沙沙声，医生从口袋里掏出一封信递给索尼娅)为了报复。这不是你写的信吗?他不是你的情人吗?<br />
索尼娅:你竟然这样想?于是你就犯下了这种罪行！这种令人发指的罪行！！没错，我爱他!我本打算和他一起远走他乡，远离你，我恨你!<br />
医生:(嘲笑地指着德·摩拉)看看你所爱的人，好好看看他<br />
塔尼娅:你是最卑鄙的罪犯，我会控告你<br />
医生:控告我!没人会相信你们，没有证据，哪怕一点点证据!<br />
玛丽萨:杀人犯!(德·摩拉听明白了，突然站起来，冲向医生，抓住他的喉咙。)<br />
德·摩拉:啊!就是你让我受苦!让我被折磨，(推开戈尔利茨，杀了他)<br />
医生:放开我!(其他人围住他，设法把他制住。斯蒂克从桌上找到一把剪刀，递给德·摩拉。)<br />
德·摩拉:我要折磨你!(他开始用剪刀狠狠砍医生的头颅，大喊:)我要扩大开口，抹去智力，什么都没有了，只剩下痛苦，只剩下痛苦!(小提琴)</p>
<h2 id="疯人院的罪行">疯人院的罪行</h2>
<p>1925</p>
<p>该剧在诺曼底一家疯人院的一个小房间里展开。疯人院的墙壁粉刷一新，两侧各有一扇门。一扇窗户朝向左侧，墙上的架子上放着一个黑色的十字架。这里有三张床，每张床边都有一张小桌子。第二张床和第三张床之间放着一个铸铁炉子</p>
<h3 id="act-1">act 1</h3>
<p>(幕布拉开时，修女坐在一个角落里，拿着念珠祈祷。远处传来钟声)<br />
(罗宾女士从左边进来)<br />
罗宾女士：修女！<br />
修女：(祈祷正要结束)请稍等片刻！<br />
罗宾女士：(神秘地)请原谅我，修女! 我不知道您正忙着。<br />
修女：(放下念珠，画十字)那么，有什么事吗?<br />
罗宾女士：医生说他很快就会带着实习医生过来。<br />
修女：很好，谢谢你。你已经用过晚餐了吗?<br />
罗宾女士：没吃呢，修女，但我今晚没什么胃口，我先走了。<br />
修女：(戴上眼镜)请帮我拿那边书架上的针线盒过来。<br />
罗宾女士：好的，修女。(递给她针线盒。)我要去收拾一下准备熄灯了。<br />
修女：记得把东西都放回原处，不要到处乱放!<br />
罗宾女士：(整理床铺)您不用提醒我，我可是这里最有条理的人。自从我有了自己的房间，我大部分时间都在整理东西，这是我的兴趣。而且我在这里待了已经很长时间。啊，真的很久了!<br />
修女：(走来走去)你在这个疗养院待了多久了?<br />
罗宾女士：四十年。(思考)四十年前!那会戴尔贝克先生管理这儿，现在他已经去世了。他的实习医生叫贝尼耶先生，之后他也去世了。还有一位修女，费利西特修女，她也去世了。每个人都死了，真好玩!(点亮床头灯，从架子上取出夜间用品。)<br />
修女：为什么你已经痊愈了还要留在这里?你没有家人吗?<br />
罗宾女士：啊，修女，您知道，在疗养院待了这么长时间，适应外面的世界很困难。家人会奇怪地看着你，担心你的病会复发。人们知道你来自疯人院，就会认为你受到了污染。所以我很乐意留在圣莱杰，只希望能在这里度过终生。(此时远处传来一阵痛苦的呼喊声)<br />
修女：那是什么声音?<br />
罗宾女士：(望向窗外)没什么，那是玛丽，她又发作了! (转念一想)要是我是那个女孩就好了<br />
修女：哪个女孩?<br />
罗宾女士：(指向靠窗的床)就是睡在那里的小路易丝。她比我幸运得多。她还年轻!她还可以找到幸福。修女，当她完全痊愈后，能不能让她回家?<br />
修女：(冷淡地)听说会这样<br />
罗宾女士：您知道，修女，她的家人都很友善。我认识他们，来自乡下。<br />
修女：(藐视地把针线盒放在桌上)哼，他们把女儿教得太奇怪了。<br />
罗宾女士：啊!<br />
修女：她是个一无所知的孩子。<br />
罗宾女士：可是她会识字。<br />
修女：她会识字，却不会背诵祈祷文。我甚至怀疑她是否相信上帝!<br />
罗宾女士：别对她生气，修女。她父母的教养方式不对，并不是她的错。<br />
修女：不信上帝，你说这叫自然?<br />
罗宾女士：修女，修道院之外还有许多您不知道的事情!<br />
修女：固执得像头驴子!她的灵魂已经疯了!我无数次请求她去教堂，但没有用!等她出去后，她必须要像个虔诚的天主教徒那样行事，这个小无赖!她敢不这么做，没有信仰的人不过是披着人皮的禽兽罢了!<br />
(铃声响起)<br />
罗宾女士：(望向窗外)啊，餐点结束了。我必须走了，这里有些人我不想见到。<br />
修女：你说的是谁?<br />
罗宾女士：(指着两张床)睡在这里的那两个肮脏的疯子:驼背女和诺曼底女人。什么贱人!<br />
修女：够了!听着，罗宾夫人!<br />
罗宾女士：对不起，修女。真的很抱歉，我不自觉就冲口而出了。<br />
修女：你为什么对她们有意见?她们只是两个可怜的疯女人。<br />
罗宾女士：两个危险的老妖婆。邪恶的疯女人。<br />
修女:在我面前，她们都是很乖顺温和的。<br />
罗宾女士:在您面前是这样，修女。疯子跟其他人一样，有些人坏脾气，有些人阴险狡诈。必须时刻提高警惕!那两个女巫是从哪里来的?<br />
修女:我不知道。<br />
罗宾女士:我听说她们都是因为失去女儿而发疯的。是真的吗?<br />
修女:是的。<br />
罗宾女士:现在她们一看到年轻女孩就会嫉妒，产生伤害的冲动，好像在重复她们的经历!<br />
修女:她们想伤害谁?<br />
罗宾女士:(指着一张床)她!<br />
修女:小路易丝?<br />
罗宾女士:是的。在打扫房间的时候，我发现了一些事情。在隔壁房间，那个只有一只眼睛的老女人，您知道，就是躺在门后面的那个?<br />
修女:啊，是的!独眼女!<br />
罗宾女士:您不会觉得她是个虔诚的天主教徒吧!她因谋杀儿童而被判死刑，人们还给她起了个绰号:食人魔!<br />
修女:她只是一个可怜的精神错乱的女人。医生已经宣布她精神失常，法院也免除了她的刑事责任。<br />
罗宾女士:无论如何，被指控犯罪的人不应该和疯子关在一起。他们应该被关在单独的疯人院。不然会出现很不幸的事情!<br />
修女:那个女人已经瘫痪六年了，六年没有从床上下来过。没什么好担心的。<br />
罗宾女士:您好像很有信心!<br />
修女:你为什么这么焦虑?这里没有人会有危险。疯人院有十名修女专门照看女性病房。<br />
罗宾女士:是的，白天是这样。但是晚上病人们都是独自一人。<br />
修女:那就是规矩。<br />
罗宾女士:我明白。这不是您的错，白天工作太忙，晚上需要休息。<br />
修女:晚上我们也会祈祷，为你们而祈祷。<br />
罗宾女士:然而，在其他疯人院，他们会定期巡查夜间病房。但是这里没有。<br />
修女:这里从来没有发生过什么坏事。<br />
罗宾女士:但只要发生一次就够了!<br />
(左右传来轻微的脚步声，疯子们正回到自己的房间。)<br />
修女:罗宾夫人，你能在这里看着病人们一会儿吗?我要去通知普拉西德修女今晚的弥撒。<br />
罗宾女士:什么弥撒?<br />
修女:苏尔皮斯修女今天早上去世了，全体修女会在教堂为她守夜。(她离开了。)<br />
罗宾女士:(独自)可怜的苏尔皮斯修女!她是这里唯一的好修女。<br />
(从右边，诺曼底女人和驼背女进来了。她们是两个看起来矮小而恶毒的老妇人，脸上带着魔鬼般的表情。)<br />
罗宾女士:啊，她们来了，那些老女巫!<br />
诺曼底女人:(环视四周)嘘，她还没来!<br />
驼背女:(压低声音)她想来这得经过院子。<br />
诺曼底女人:对，那我们就去找独眼女。<br />
驼背女:她在等着我们。<br />
诺曼底女人:她在掌控一切。<br />
驼背女:当她尖叫的时候<br />
诺曼底女人:那就是死亡的信号!<br />
罗宾女士:你们在嘀咕些什么?(诺曼底女人大笑。)你们为什么笑?<br />
诺曼底女人:你是尚博西的私生子吗?<br />
驼背女:他给了看守坟墓的人一笔贿赂。看守对他说:"从晚上九点到早上八点都会关闭，就在我母亲的墓旁。"阿门。<br />
诺曼底女人:阿门。(两人都画十字。)<br />
罗宾女士:(耸耸肩膀，笑了)她们完全疯了!有时候就算你不想在意，她们也会把你逗得发笑!<br />
诺曼底女人:(走到路易丝的床前，转向驼背女)喏，看!<br />
驼背女:头在这边。<br />
诺曼底女人:脚在那边。<br />
驼背女:哈!哈!<br />
诺曼底女人:哈!哈!<br />
罗宾女士:你们玩够了吗?睡觉吧!对你们两个来说，这会更健康。你们对那个女孩有什么意见?她做了什么伤害你们的事吗?<br />
诺曼底女人:有些事是不能说的。你懂吗?<br />
驼背女:如果谈论这些，说的人就会被诅咒!<br />
罗宾女士:对，说得很对!所以听着，如果你们继续用手势吓唬她，让她感到痛苦，之前有天我看到你们试图绊倒她。我可能会告诉医生!也许他会再次给你们穿上约束衣。(对诺曼底女人)就像前几晚那样!<br />
诺曼底女人:(害怕)啊!闭嘴!闭嘴，愚蠢的女人!(她从左边走出去。)<br />
驼背女:(跟着她)臭蛙!粘糊糊的臭蛙!<br />
罗宾女士:(自言自语)没什么能让她们害怕了。她们去哪里了?(她望向开着的门。)在那里!她们去了独眼女的床边。她们三个在谈论什么?她们看着我。她们的眼神好可怕!就连我也害怕这些讨厌的老女巫。(她砰地关上左边的门，路易丝从右边进来。)我可不想睡在这个病房里!<br />
(路易丝，一个18岁的女孩，漂亮，有金发，但看起来害羞而病弱。)<br />
路易丝:晚上好，罗宾夫人。很高兴见到您。您为什么还在这里?<br />
罗宾女士:我在等修女，她很快就回来。晚上好，亲爱的。你还好吗?<br />
路易丝:很好!<br />
罗宾女士:你终于能从这里离开了，真好。最好能早点离开。<br />
路易丝:结束了，罗宾夫人!我终于康复了。<br />
罗宾女士:你开心吗?<br />
路易丝:噢，是的。但如果离开这里，我会想念您的。您对我很好!<br />
罗宾女士:我也这么想!知道吗，这是我应该做的。你这么温柔善良!每次从外面收到礼物，你都会与我分享。<br />
路易丝:疗养院真是无聊至极。因此一点点快乐也值得分享。(她四处张望。)<br />
罗宾女士:你在找什么?<br />
路易丝:她们还没回来吗?<br />
罗宾女士:是的，她们在那边，和独眼女在一起。<br />
路易丝:啊!<br />
罗宾女士:我不知道她们在搞什么鬼。她们总是在计划着阴谋。<br />
路易丝:是的。听着，罗宾夫人，我得向您坦白。每次我靠近那三个女人，都会非常害怕。当她们盯着我看的时候，眼神很奇怪。尤其是独眼女，我感到后背发凉。她们想对我做什么?<br />
罗宾女士:没什么。她们是病人。不要理会她们。<br />
路易丝:我尽量不去理她们，罗宾夫人。但我就是感到不安全!<br />
罗宾女士:如果这么让你困扰，为什么不跟修女说说?<br />
路易丝:她不会听我说的。我们的关系不太好。<br />
罗宾女士:那就与上帝处好关系吧，这是我的建议。去见医生吧，你可以跟他说这件事。他是个很好的人!<br />
路易丝:是的，但我不敢。我只有—<br />
罗宾女士:(听到声音)嘘!修女来了!<br />
(两人都安静下来。)<br />
修女:(从左边进来，看到路易丝)啊，是你!医生告诉我他决定提前让你出院。<br />
路易丝:是的，修女。我相信—<br />
修女:他应该重新检查一遍。<br />
路易丝:修女<br />
修女:昨天是星期日。但你没有来教堂。为什么?(沉默)现在找不到借口了，对吗?我碰到了阁下(对天主教高级神职人员的尊称)他问责我:"修女，在整个疗养院里，只有一个病人从未忏悔过。她就在你管辖的病房里!"你认为我听到这责备会高兴吗?<br />
路易丝:不，修女。<br />
修女:你病得很重。有两次你差点死掉。<br />
路易丝:这是事实。<br />
修女:假如病症复发，你会很难痊愈的。那时死神就会敲你的门，你会感到害怕。你会希望自己已经忏悔过了。但那时就太晚了，我的小异教徒!<br />
路易丝:我的天啊!<br />
罗宾女士:(低声对路易丝说)看，应承她的话吧!你知道，修女是出于好意。这是她的工作。(大声)那么晚安，我的小宝贝，你不会在这里待太久了，一切都会很快过去。晚安，修女。<br />
修女:晚安。<br />
(远处传来为死者而鸣的钟声。)<br />
罗宾女士:(从右边走出去)听，钟声响了!可怜的苏尔皮斯修女!<br />
路易丝:(听到钟声颤抖)那些钟声!好可怕!<br />
(医生和实习医生从左边进来。)<br />
医生:为死者而鸣的钟声是怎么回事?有人死了吗?<br />
修女:是的，医生。苏尔皮斯修女，今天上午十一点，在圣徒弥撒期间去世了。全体修女都在她的床前。<br />
医生:(讽刺地)那么在那段时间里，病人们怎么办?谁来照顾他们?<br />
修女:我们离开的时间并不长!<br />
医生:希望如此。这里有什么新情况吗?<br />
修女:没有，医生。一切都很安静，一如往常。<br />
医生:没有发烧，骚乱，痉挛?<br />
修女:一切正常。<br />
医生:很好，太好了。(对实习医生)来吧，勒布朗。<br />
他们准备离开。<br />
路易丝:修女!<br />
修女:你想要什么?<br />
路易丝:我想和医生谈谈!<br />
修女:医生没时间。<br />
医生:(回来)当然，修女，当然。亲爱的，你有什么想问我的吗?<br />
路易丝:是的，医生。哦，是的。<br />
实习医生:(对医生说)那个小女孩很可爱，。<br />
医生:不是吗?<br />
实习医生:金发和乞求的神情，让人想到奥菲利亚。不是吗，修女?<br />
修女:(漠不关心)我不知道。<br />
医生:好了，亲爱的，你想要什么?修女，帮我们拿对椅子来。坐下吧。我猜你想讨论一下你的出院事宜。<br />
路易丝:是的，医生。<br />
医生:你为什么想要出院?<br />
路易丝:因为我痊愈了。是您治好了我。<br />
医生:是的，也许吧。我觉得你看起来好多了。你的眼睛也更健康了，是不是?(转向实习医生)<br />
实习医生:确实，她的神情更有生气，更灵气了。<br />
医生:你看!我根据克莱佩林的诊断，把她归为抑郁—躁狂症。而你<br />
实习医生:我倾向于认为她更像是早发性精神分裂症。<br />
医生:如果真是那样，她现在也不会是这种状况了。<br />
实习医生:有时候也会有缓和期。<br />
医生:可能性不大。<br />
(左边的门开了，一个女人的头探了进来，对修女说。)<br />
一个女人:修女，是时候<em>移柩</em>(不了解西方殡葬风俗，未必准确)了。<br />
修女:好的，我这就去。<br />
(修女离开了，远处传来丧钟声。)<br />
医生:(对路易丝)那么，你不再受焦虑或幻觉的折磨了?<br />
路易丝:我吗?<br />
医生:你已经不记得它们了?更好!<br />
路易丝:不，我很好，医生。我感到—我是—我该怎么说，我感觉自己重获新生。我想回家。<br />
医生:我理解。但还是要理性一些。(对实习医生)她是从哪里来的?<br />
实习医生:我记得是费卡姆。<br />
路易丝:是的，我父母住在那里。<br />
医生:当发病时，你一直和他们在一起?<br />
路易丝:哦，不!我不是和他们在一起。我一直在旅行。从10岁开始我就在旅行。我被—<br />
医生:所以是你的养父母发现你有精神问题的?<br />
路易丝:是的。<br />
医生:你觉得，回去之后，他们会接纳你吗?<br />
路易丝:我不知道。<br />
医生:整个地区的人都知道你在圣莱杰待过。现在要找到另一个家庭会很困难。你看，对于从疯人院出来的病人来说，生活会格外艰难。<br />
路易丝:(突然坚定)但既然我已经痊愈了，你不能把我永远关在疯人院里!这不是正常人的生活方式。<br />
医生:当然不是，但请等待一段时间。<br />
路易丝:等待?<br />
医生:是的，多待一段时间。虽然你可能不会喜欢这样，但确实会有帮助。<br />
路易丝:哦，不!<br />
医生:这会给我们更多时间来观察你的病情。<br />
路易丝:不，医生，我必须离开这。<br />
医生:你离开后要去哪里?你有什么打算吗?<br />
路易丝:我会去巴黎。<br />
医生:去巴黎!<br />
路易丝:那是个大城市，总能找到工作的。<br />
医生:你在那里认识人吗?<br />
路易丝:不，但这并不重要。我会自己安排。<br />
医生:你对巴黎一无所知!可怜的小姑娘，你虽然很漂亮，但巴黎会把你吞噬掉。你会变得痛苦和抑郁，你的病情会复发!我不会允许那样的事发生!<br />
路易丝:医生<br />
医生:不，不，请理性一点。<br />
路易丝:您不希望我离开?<br />
医生:当然我希望你离开，但不是现在。首先，你会接受我的私人治疗。(对实习医生)提醒我一下。(对路易丝)然后，等我为你找到一个好的住处<br />
路易丝:什么时候?<br />
医生:什么时候?我不知道。也许两周后，也许一周后。<br />
路易丝:(激动)我不想等了!<br />
医生:什么?<br />
路易丝:再待一周!不，我做不到!<br />
医生:冷静下来，冷静下来!<br />
路易丝:我不想再留在这里了!我想离开!(压低声音)我不想再睡在这个房间里了。<br />
医生:(被她的语气震惊)我明白，还有其他事情，其他你没有告诉我的事情!(他注意到路易丝在四处张望。)你为什么在看那里?<br />
路易丝:我在看修女有没有在听。<br />
医生:你和她有矛盾?(路易丝低下头，没有回答。)这并不奇怪。但她做了什么让你生活如此痛苦?是因为你没有去弥撒吗?<br />
路易丝:是的，可能吧。但不是这个!<br />
医生:那是什么?你可以告诉我们。是她在照顾你时发生的事情吗?<br />
路易丝:是的，就在这个房间里。<br />
医生:发生了什么?<br />
路易丝:那天晚上，这里没有人<br />
医生:没有人?其他病人呢?<br />
路易丝:他们在，但修女都走了。然后<br />
医生:是什么?别发抖了。(他以父亲般的方式握住她的手。)告诉我们。<br />
路易丝:我不知道该怎么说。光是想到就让我胃疼!<br />
医生:请冷静下来。<br />
路易丝:好的。当修女离开，灯光熄灭时，如果你知道这个病房里发生了什么变化就好了。<br />
医生:发生了什么变化?<br />
路易丝:有一些无法理解的事情发生了。首先，那扇门(指左边的门)你看见了吗?<br />
医生:是的?<br />
路易丝:修女离开时会把门锁上。昨天凌晨，那扇门自己开了。<br />
医生:你看见有人打开那扇门吗?<br />
路易丝:是门自己打开的。就像一个信号。那两个睡在那里的老女人，你认识她们吗?<br />
医生:是的，继续说。<br />
路易丝:她们起床了。<br />
医生:什么?她们起床了?<br />
路易丝:因为没有人阻止她们。<br />
医生:抱歉，但是那个女人，诺曼底女人，我亲自给她穿上了约束衣。<br />
路易丝:有什么用?另一个人把她从里面拽了出来。<br />
医生:需要钥匙。<br />
路易丝:她有钥匙。她有一切可以—(她停住了。)<br />
医生:可以什么?<br />
路易丝:我看到你们两个人都在盯着我!<br />
医生:(对实习医生)我担心她还无法承受任何刺激。<br />
实习医生:显然如此。<br />
路易丝:天哪!你们以为我在说谎或者还在发疯吗?<br />
医生:不，我的孩子。那么从头开始，她们做了什么?<br />
路易丝:她们悄无声息地靠近我的床边。她们俯身看着我，目光如钉，好像要伤害我。<br />
实习医生:要伤害她!<br />
路易丝:但她们没敢。她们望向门口，摇头说:"不，不，"好像在害怕什么。好像是在跟别人说话。还有别的人。<br />
医生:是谁?<br />
路易丝:独眼女，向她们做了手势。<br />
医生:你这么认为?<br />
路易丝:哦!我立刻就认出了她，她那个遮住眼睛的黑眼罩。她在做手势。<br />
医生:这不可能。<br />
路易丝:医生，我确实看见了她。<br />
医生:我告诉你，这是不可能的!是的，另外两个女人并非残疾。但所谓的独眼女已经瘫痪六年了。她一直卧床不起。所以她不可能站起来。<br />
路易丝:但我确实看见她了，医生。她就站在门前!<br />
医生:看来，我的孩子，你还没有痊愈!<br />
路易丝:我已经痊愈了。我的心智已经恢复正常。<br />
医生:不，因为你声称了一些不可能的事情—<br />
路易丝:我不知道该怎样让你相信，但我确实看见她了。我没有睡着。我睁大眼睛看着。我确实看见她了。她对另两个人做了手势。她们都很害怕。我确实看见了!<br />
实习医生:(对医生)她又出现幻觉了。<br />
医生:我也是这么认为的。<br />
实习医生:她告诉我们的可能是真的—<br />
医生:(打断)这是新发作的警示。可怜的小姑娘!<br />
路易丝:(害怕)不，医生。(对实习医生)不，先生，我告诉你，我确实看见了她。<br />
医生:(对实习医生低语)我已经下定决心了。<br />
实习医生:我也是。<br />
医生:幻觉又回来了。<br />
路易丝:不，医生。不!我已经不再发疯了!医生，您现在就能看出我是清醒的!<br />
医生:冷静下来!<br />
路易丝:我很激动，但不是疯了。我不是在编故事。(对实习医生)是不是，先生?我从不编故事。求你们相信我!<br />
医生:(安抚她)当然，我相信你!我只是需要在接下来的几天里再观察几次。<br />
路易丝:接下来的几天?如果晚上再次发生这样的事呢?<br />
医生:你会告诉我的。<br />
路易丝:但你不会把我留在这里吧?如果不能立即离开，至少也换个病房!<br />
医生:现在所有床位都已经满了。<br />
路易丝:求求你!<br />
医生:那么明天就换个病房，我向你保证。<br />
路易丝:是的，但是今晚，我好害怕!太害怕了!<br />
实习医生:她把自己吓成这样!<br />
医生:今晚修女不会离开你。<br />
路易丝:她会离开的!<br />
医生:我会给她下命令。<br />
路易丝:她还是会走的!<br />
医生:让她试试看!<br />
路易丝:一旦你们离开，她就会走的!<br />
医生:(严厉)够了!如果你还这么固执，那就证明你还没有痊愈，我将被迫把你留在疗养院里很长时间。<br />
路易丝:我的天啊!<br />
(修女从左边进来。)<br />
医生:(喊她)修女!<br />
修女:医生<br />
医生:我来是要训斥这个孩子，因为她行为不合理。她还很神经质。她总是无缘无故地害怕。但无论如何，她都在痛苦，我们必须减轻她不必要的痛苦。今晚你要照顾她。<br />
修女:但是，医生<br />
医生:拜托了!你在场的话就能预防她做噩梦。<br />
修女:噩梦无关痛痒!<br />
医生:照顾做噩梦的病人也很重要。<br />
修女:如果她太兴奋，我们可以给她两勺水合氯醛。<br />
医生:不，我希望你能留在这里陪着她。<br />
修女:这对我来说很难办，尤其是今晚。<br />
医生:为什么?<br />
修女:我们有仪式。<br />
医生:什么仪式?<br />
修女:为苏尔皮斯修女守灵。<br />
医生:啊，是的!<br />
修女:整夜都要守灵，所有修女都要参加。<br />
医生:你必须找人来替换你。<br />
修女:(直白地)这是不可能的。<br />
医生:只要你愿意，这是完全可能的。<br />
修女:院长是不会容忍任何人缺席这个仪式的。<br />
医生:我必须告诉你，人道主义的事情比教堂里的仪式更重要。<br />
修女:我不这么认为。这取决于你的观点。<br />
医生:不要犹豫了，我坚持你的职责是留在这里。<br />
修女:我的职责是服从院长。<br />
医生:守护死者的确好，但还有更重要的事情，那就是照顾活着的人。<br />
修女:(固执地)我的职责是服从院长。<br />
医生:你首先必须服从我。院长并不掌管这个疯人院。掌管的人是我，医生!你明白吗?<br />
修女:(茫然)是的，医生。<br />
医生:我坚持要你整夜都留在这个房间里。你是照我说的去做，还是不照做?<br />
修女:我只是一个仆人。我的职责就是服从。(她低声嘀咕了几句。)<br />
医生:你说什么?<br />
修女:什么也没说，医生。<br />
医生:(严厉)很好。(亲切地对路易丝)希望你终于放下心中的忧虑了。(路易丝没有回应。)祝你晚安，我的孩子。(对实习医生)啊，修女们!修女们!(离开时)她们有许多好品质。很安静，很认真，很投入。但是一到仪式，就变得很固执!<br />
(医生和实习医生从右边离开，修女跟着他们。)<br />
路易丝:(独自坐在床上)他们不相信我。(哀叹)我的天啊!我的天啊!(诺曼底女人和驼背女从左边重新出现，在黑暗中慢慢向路易丝走来，她再次感到害怕，发出一声尖叫。)啊!<br />
诺曼底女人:你不应该这样害怕，亲爱的。<br />
驼背女:我们甚至都还没有碰你，你就尖叫了。<br />
诺曼底女人:再等一会儿。<br />
驼背女:稍等一下。<br />
诺曼底女人:夜还长着呢!<br />
驼背女:是的，夜晚。夜晚是好的。<br />
路易丝:你们为什么这样看着我?<br />
诺曼底女人:我们不能看你吗?<br />
驼背女:你很漂亮。<br />
诺曼底女人:尤其是你的眼睛—<br />
驼背女:它们不是你的。<br />
诺曼底女人:当然不是。<br />
驼背女:老太婆说过，"里面有只布谷鸟。"<br />
诺曼底女人:有一天，它会飞走的。<br />
驼背女:(做拍翅膀的动作)啪嗒!啪嗒!<br />
路易丝:走开。别靠近我。(呼救)修女!<br />
诺曼底女人:不要害怕，小姑娘，布谷鸟很快就会被释放!<br />
(她们笑着向路易丝走去。)<br />
(修女从右边门重新出现，两个老妇人悄悄爬回了自己的床上。)<br />
修女:怎么回事?谁叫我?是你吗?<br />
路易丝:(激动)是的，修女。<br />
修女:总是那些爱投诉的人浪费我们的时间。现在又怎么了?<br />
路易丝:(指着那两个女人)她们在这里。<br />
修女:当然，她们在这里，因为和你睡在一个房间里。那么现在，你们三个都去睡觉吧。(她点燃一根火柴，点亮床头灯。房间亮了起来。她环顾四周。能听到隔壁房间传来的声音和话语。)嘿，你们那边!(她拿着床头灯，打开左边的门，看进去。)安静!不要再吵了!该睡觉了，听到了吗?<br />
(噪音慢慢消失，陷入沉寂。她用钥匙锁上门。两个老妇人准备睡觉。路易丝安静地坐在床上。修女把灯放在架子上。然后跪在十字架前，低声祷告。)<br />
(驼背女和诺曼底女人低声祷告，能听到几个词:"圣母玛利亚，在我们死亡的时刻，阿门!")<br />
修女:阿门。(她站起来。这时传来远处的钟声。修女听了，犹豫了一下，慢慢走到路易丝的床边，后者仍然没有动。用柔和的语气)路易丝?<br />
路易丝:修女?<br />
修女:你要去睡觉了吗，我的孩子?<br />
路易丝:(犹豫)当然，修女。<br />
修女:你不再害怕了，我希望如此?你看，一切都很平静。你今晚会睡得好吧?<br />
路易丝:是的，修女。钟声又开始了。<br />
修女:你听见那个召唤我的钟声了吗?它要求我去履行对死者的职责。<br />
路易丝:但是，修女<br />
修女:你明白我不能留在这里。你不是一个自私的人。你有宽广的心胸。你知道死者需要我们的祷告。死者应该优先于生者。<br />
路易丝:但是医生—<br />
修女:如果你不告诉医生，他是永远不会知道的。如果你告诉他，你会给我带来很多麻烦。我的孩子，想想那会引起多大的丑闻!他会把一切都夸大。他会向管理层投诉，要求调查。院长不喜欢这样。绝对不喜欢。我们不应该做任何让她不高兴的事情。事实上，是她在这里发号施令。你明白吗?<br />
路易丝:(泰然接受)是的，修女。<br />
修女:好孩子，要理性一些。我们两个人仍将是好朋友。这对你有利，相信我。我可以帮助你离开。所以要理性一些。晚安!<br />
(她走向右边的门，帷幕缓缓落下，远处的钟声仍在响起。)</p>
<h3 id="act2-1">act2</h3>
<p>通过窗户洒进来一片略带绿色的月光，桌面上的夜灯在窗前摇曳。周边一片死寂，远处的钟声敲响了十下。整幕中，不时能听到从教堂传来管风琴的声音和祈祷诵唱声。突然，在床上的驼背女和诺曼底女人沉默地转过身来。<br />
诺曼底女人:(用深沉的声音，打破寂静)嘘!<br />
驼背女:(用同样的方式回应)什么事?<br />
诺曼底女人:(坐起来)她睡着了吗?<br />
驼背女:(同样的语气)我想是的。<br />
诺曼底女人:确认一下!<br />
驼背女:我去看看。<br />
诺曼底女人:等等!有人在走动，有人在走廊里说话。<br />
驼背女:也许是修女回来了?<br />
诺曼底女人:也许吧。(她们重新躺下。寂静再次笼罩这里;声音渐行渐远。她们坐起来。)她们没有进来! )<br />
驼背女:不，她们下了楼梯。<br />
诺曼底女人:对。<br />
(停顿)<br />
驼背女:那么，今晚就这样办。<br />
诺曼底女人:这就是她想要的。<br />
驼背女:必须服从她。绝对!<br />
诺曼底女人:否则她会伤害我们。<br />
驼背女:就像那个小姑娘。<br />
诺曼底女人:还记得她要求的是什么吗?<br />
驼背女:你是什么意思?<br />
诺曼底女人:毛巾。<br />
驼背女:我没有。<br />
诺曼底女人:用牙齿从床单上撕一块下来!<br />
驼背女:好主意。<br />
(撕扯床单的声音传来。)<br />
路易丝:(迷迷糊糊地坐起来)什么?<br />
驼背女:她醒过来了。<br />
诺曼底女人:安静。<br />
(她们保持安静一段时间。)<br />
路易丝:我听到了。有什么东西，就在这里。(她环视房间。)<br />
驼背女:(把布条藏在枕头下面)先这样。<br />
诺曼底女人:等信号。<br />
驼背女:等着。<br />
(寂静)<br />
路易丝:那边有人在说话?是她们。她们没有睡觉!她向前探身仔细听。<br />
驼背女:瞧，她醒了!<br />
诺曼底女人:她能听到我们。<br />
(她们坐起来)<br />
路易丝:她们在干什么，坐得那么安静?(大声)怎么回事?你们想做什么?<br />
诺曼底女人:不要害怕，亲爱的。<br />
驼背女:当然。<br />
诺曼底女人:是布谷鸟的叫声把你吵醒的吗?<br />
驼背女:(笑)这是死亡的信号。她们大笑。<br />
路易丝:安静!和疯子待在一起真可怕—<br />
诺曼底女人:那你才更疯了，你这个!<br />
驼背女:(大笑)她以为自己不再疯了!<br />
诺曼底女人:因为她即将离开疯人院!<br />
驼背女:你永远也走不出去。<br />
诺曼底女人:如果你走出去，也是双脚先出去!她们大笑。<br />
路易丝:(害怕)我再也待不下去了!一个人<br />
诺曼底女人:你并不孤单!<br />
驼背女:因为你和我们在一起!<br />
(她们从床上下来。)<br />
路易丝:离开我，不然我就叫<br />
(左边房间传来喘息声。受惊的路易丝停下来。两个老妇人害怕地保持静止。)<br />
诺曼底女人:安静!是她!<br />
驼背女:闭嘴!她来了!<br />
诺曼底女人:如果她听到我们，她会发怒的!<br />
驼背女:如果她发怒，保护好自己!<br />
诺曼底女人:是的，一定要保护好自己!<br />
驼背女:(祈祷)慈悲的主啊!<br />
诺曼底女人:救救我们吧<br />
驼背女:当你离开<br />
诺曼底女人:，是双脚先出去<br />
驼背女:(指着左边的门)她来了!在那里!<br />
路易丝:(站在窗前)门自己开了!救救我!救救我!<br />
(她想往右边的门跑去，但两个老妇人挡住她，把她推开。惊慌失措的路易丝像困兽一样转向另一边。突然，一个黑影出现在她面前。独眼女从左边的门进来，悄悄关上门，冲向路易丝，把她推倒在床上。传来一声闷哼。)<br />
(独眼女压住挣扎的路易丝，驼背女把床头灯凑过来。)<br />
独眼女:灯!<br />
驼背女:这里!<br />
独眼女:再亮一点!(她用手捂住路易丝的嘴，让她安静。)<br />
驼背女:(用床头灯)好了!<br />
(驼背女和诺曼底女人都俯身凑近路易丝。)<br />
诺曼底女人:(对驼背女)她抓得真牢。<br />
驼背女:是啊!<br />
诺曼底女人:她要做什么?<br />
驼背女:我不知道，但她知道!<br />
独眼女:诺曼，你有布条吗?<br />
诺曼底女人:在这里。<br />
她递给她撕下来的床单布条。<br />
独眼女:(对诺曼底女人)抓住她的手!给我一根长针!<br />
驼背女:(寻找)针?<br />
诺曼底女人:修女的针织针!在架子上!<br />
驼背女:(转身)啊，在架子上。<br />
诺曼底女人:在圣母像前面。<br />
驼背女:在那里!<br />
(她把针织针递给独眼女。)<br />
独眼女:我看不太清楚，做不好工作!<br />
(她把针插进自己的病号服口袋里。)<br />
诺曼底女人:我同意，这里太黑了。<br />
独眼女:把床头灯凑近一点!<br />
驼背女:在这里。<br />
独眼女:再近一点!<br />
(驼背女照做。)<br />
诺曼底女人:(盯着路易丝)人们说她已经死了。是的，就像具尸体一样。<br />
独眼女:不，等我完成后，布谷鸟就会回到我们这里!<br />
路易丝:(挣扎着)啊!<br />
独眼女:(揭开路易丝的嘴)你知道我是谁吗，孩子?<br />
路易丝:我在哪里?<br />
独眼女:别动!<br />
路易丝:(瞥见她们)你们在对我做什么?<br />
独眼女:不要尖叫。我们不想伤害你，只是想对付这两只眼睛。<br />
路易丝:我的眼睛!<br />
独眼女:那不是你的眼睛!<br />
诺曼底女人:她以为那是她的眼睛。<br />
驼背女:哈!哈!<br />
诺曼底女人:哈!哈!<br />
独眼女:(有威严地)安静，你们两个!你明白吗，我的孩子，这是我想为你效劳。你曾经疯过，不是吗?你不记得了吗?<br />
诺曼底女人:她当然记得!<br />
驼背女:她不记得!<br />
独眼女:你疯的时候，一只野兽钻进了你的身体，一只布谷鸟。它藏在你的头里。就在你的眼睛后面!<br />
路易丝:(挣扎)啊!<br />
独眼女:如果你继续尖叫，我就得把你的嘴彻底封住。所以听好了!我要把那只鸟赶走。你明白吗?它偷走了你的眼睛。那只鸟把它的眼珠塞进了你的眼眶里!现在你明白了吗?(尖叫)该死的布谷鸟的眼睛打算抢走我的视力!<br />
路易丝:(充满恐惧)不，不!求求你们!<br />
独眼女:(平静地)现在你明白了。<br />
路易丝:求求你!我不想死!<br />
独眼女:你不会死的!<br />
路易丝:(挣扎)救命!救救我!<br />
独眼女:(用手捂住路易丝的嘴)闭嘴!(对女人们)快，在她尖叫之前!(独眼女用布条堵住路易丝的整个脸。)<br />
路易丝:(抵抗)啊!<br />
独眼女:别动，小姑娘!很快就结束了。我只需要摸到你的眼睛在哪里。(停顿)但这块布太硬了!它已经被淀粉硬化了!<br />
诺曼底女人:什么?<br />
独眼女:布条里的淀粉太多了，笨蛋!把它浸在水里，在炉子上晾干!我必须精确地知道她的眼睛在哪里，诺曼!<br />
(独眼女从路易丝脸上抓下布条，扔给诺曼底女人。独眼女再次用手捂住路易丝的嘴。现在诺曼底女人慌张地不停地把布条浸在水盆里，然后扔在炉子上，冒出阵阵蒸汽。)<br />
独眼女:你为什么给我一块硬布?<br />
诺曼底女人:现在柔软了!看，完全柔软了!<br />
(诺曼底女人把冒着热气的布条覆盖在路易丝的脸上。)<br />
路易丝:(尖叫)啊!<br />
(独眼女用手指触摸被遮住的路易丝的脸，露出微笑。她用另一只手从口袋里拿出针织针，快速地穿过布条，刺进路易丝的眼眶。)<br />
路易丝:(剧烈尖叫)不!!!!<br />
独眼女:好了!对了!血流到我的手上了。温热，很好!和婴儿的血一样!一个小巧可爱的孩子!(独眼女刺穿路易丝另一只眼睛。)<br />
路易丝:啊!<br />
独眼女:就像从前一样!<br />
(独眼女歇斯底里地大笑，做出拍击翅膀的动作，在被折磨的路易丝周围跳舞。)<br />
(失明的路易丝下意识地从眼睛上拔出针织针，从床上飞起，血淋淋的布条掉落在地。眼球的体液沿着她被毁容的脸流下，她张大嘴无声地尖叫。)<br />
诺曼底女人:(困惑地向路易丝跑去)那只鸟?那只鸟在哪里?<br />
独眼女:哈!哈!哈!哈!<br />
(路易丝本能地无视了诺曼底女人，扑向正在大笑的独眼女，手持针织针倒在地上，死去了。)<br />
诺曼底女人:(检查路易丝的尸体)布谷鸟没有飞出来!驼背，你看到那只鸟了吗?<br />
(两个老妇人呆呆地看着对方，因为疯狂的独眼女还在继续起舞。意识到自己被骗了，驼背女突然压制住狂喜的独眼女，把那个神志不清的怪物拽到房间另一头的炉子前。驼背女把独眼女看不见的那一侧脸颊强行按在炽热的炉板上。脸部发出噼啪声，喷出一股血腥的蒸汽，独眼女发出了野兽般的尖叫。被刺耳的尖叫声吓到，驼背女用手抓住独眼女流着血的头发，把她那只眼睛砸在炉子上，把她杀死。)<br />
(漫长的停顿。驼背女看向诺曼底女人。)<br />
诺曼底女人:(从震惊中恢复过来)从来就没有什么布谷鸟!<br />
(右边传来噪音。)<br />
驼背女:诺曼，听!脚步声!<br />
(驼背女吹灭床头灯，钻回自己的床上。房间被月光照亮。)<br />
诺曼底女人:(意识到她们的困境)他们来了!他们来了!(她赶忙爬上床，把被单蒙在头上。停顿，脚步声传来。)<br />
修女:(在外面)我向你保证，阿格尼斯修女，我确实听到了声音。(她拿着一盏灯进来。)怎么回事?有人喊叫吗?(她停在门口。一片寂静)<br />
苏西修女:(进来)没有，就像我说的那样。<br />
修女:(照向正在睡觉的诺曼底女人和驼背女)她们睡着了。一切都很安静。<br />
苏西修女:我告诉过你!什么也没有。你知道院长不喜欢我们在仪式结束前离开。<br />
(远处传来女声的赞美诗吟唱。)<br />
修女:(离开时)是的，我弄错了。我们回去参加圣餐吧!<br />
(修女们拿着灯离开。门关上后，帷幕缓缓落下，诺曼底女人和驼背女从床上坐起，在月光下发出咯咯的笑声。)</p>
<h2 id="解剖">解剖</h2>
<p>根据目前能查到的非常有限的资料，洛德出身在医生家庭，当时的医生是收入颇丰的职业，可想而知洛德自幼起并不会有太大经济压力，洛德曾在短时间内当过律师，之后在图书馆担任图书管理员(一个非常适合写作者的职业)，在他的父母离婚后，洛德开始试着以写作为职业。据称他有一定的心理问题，其对恐怖猎奇的痴迷让他的心理治疗医生抱怨不止，但最后他们还是合作写了一篇以疯人院为主题的戏剧。<br />
洛德据称有150部左右的剧本创作，但流传下来的则不多(也可能是我没找到)，也没有当时演出的录像能传下来，让我们姑且相信能找到的几部剧本是洛德写作生涯中比较有代表性的(部分有不适宜情节的剧作我没翻，可自行谷歌)<br />
正如我们之前所介绍的，洛德大体上是所谓自然主义的拥护者(尽管我认为现实中没有那么多疯狂科学家和变态杀人魔)，至少洛德笔下犯人的凶器和杀人手法确实很现实，其剧作节奏很紧凑，大致都可以分为“人物登场，揭露矛盾——冲突高潮——收尾(可选)”三个阶段，其中，第一阶段并不会出现什么猎奇场景，而是普通的人物间互动，在此过程中埋下不安的种子，并在戏剧中间或偏后部分引爆，收尾部分往往非常简短，或者不需要收尾，直接以冲突的高潮结束，完全不留给观众缓解恐惧的时间。<br />
需要声明的是，戏剧的最终效果很大程度上取决于演出，只看剧作，特别是强调视听效果的恐怖剧，肯定是没多么惊艳的，何况这是100多年前的剧本了，以现在的眼光看可能有过于套路，人物模板化之类的问题，对历史人物应该以历史眼光看待，所以即使其剧本现在看比较平庸无趣，也请抱有一些宽容。此外，其中部分是洛德与其他人合著的剧本，因为我们讨论的主角是洛德，这种细节就先略过了，感兴趣的可以自行了解。<br />
顺着时间轴，能找到的最早剧作，也可能是英语世界里最著名的一篇是《电话中》。这篇剧作涉及了当时比较时兴的技术——电话(1877年在美国开始商业业务，在欧洲普及则要更晚)，并巧妙地使用这种技术创造戏剧效果，从而有一定的历史价值。<br />
作为洛德的早期作品，这部的口味相当清淡，甚至到了完全不见血的程度，但其写作思路非常有典型性，很适合作为引入。故事开头，用一个五人家庭的对话交代了基本信息，一家人来到一个偏僻的乡间别墅度假，在一个暴风雨之夜，男主人，一位事业有成的商人，需要出门谈合同。尽管开局并没有什么危机，但洛德还是设置了一个小小的悬念，约好的马车迟迟未到……用来促使人物间自然地对话来交代信息，而不是过于刻意地自报家门。对话中，洛德简单地交代了各个角色的性格，男仆人沉稳可靠，女仆人比较胆小，还有些神经质，声称在附近看到了流浪汉；男女主人之间非常恩爱，女主人坚强勇敢；这是一个幸福的家庭，很显然，这被用来激起观众(尤其是有家室的那些)的同情心。在完成了这些任务后，马车很识趣地赶到并带走了能带来安全感的男主人。<br />
当然，此时的家庭中依旧有两道安全屏障，一个是可靠的男仆，一个是男主人留下的抽屉里的枪；可想而知，接下来洛德会自然地移除掉这两道保险，此时女主人开始主持大局，她安慰有些害怕的女仆人，并卸下心防地声称自己也没那么装得那么胆大，突然，老仆人听到了外面的动静，原来是一个流浪汉突然从侧门溜了进来，这时两道保险还在，因此这只是虚晃一枪，流浪汉带来了男仆母亲病危的消息，心善的女主人当即让男仆前去探望，趁她不注意，流浪汉将抽屉里的枪带走了。<br />
现在，一举两得，两道保险都被移走了，家中留下的只有孤儿寡母和一个老佣人，观众很容易就能猜到接下来会发生什么，但正如希区柯克所说，桌底有定时炸弹不可怕，有不知道何时爆炸的炸弹，并且附近的人浑然不觉才可怕。因此洛德没有选择立刻动手，女仆人依旧怀疑附近的动静，两人为了壮胆决定和男主人通电话，第一幕结束。<br />
场景一转，视角转到了男主人，此时观众已经意识到家中两人的险境了，这是一种非常经典的心理现象，当一件事发生的要素齐全时，不论好坏，观众内心里都会期待其发生，如果是坏事则会纠结着期待其发生，当视角切换到第三方时更是如此，于是在观众的期待中，男主人接起了电话，但第一通电话什么也没有发生，两人秀了一波恩爱，嘲笑一下女佣人的胆小，然后就平稳的挂断了。此时，老佣人已经喊了三次狼来了，心理惯性下，部分观众或许已经开始放松警惕，于是洛德决定趁此良机收网，没几句台词的功夫，第二通电话打来了，狼真的来了，而男主人只能在电话中听着惨剧的发生却无力阻止，戏剧就在其发狂中落幕。<br />
总体来说，这部剧本对悬念的铺垫和回收可以说不错，但只能算悬疑剧，很难说有多少恐怖成分，最后的谋杀使用了不在现场的第三方视角，这能增强悬疑感，但想象力不强的人很难感到恐怖；此外，危险的源头缺少铺垫，在女主人打着电话的情况下流浪汉还敢当场直接杀人，就不怕警方或者男主人立马来追捕吗？何况要洗劫财物的话把两人绑起来就好了，反正她们也没什么反抗能力，还有小孩这个软肋，何必背上谋杀的罪名呢？可以说，为了凑出恐怖情节，洛德笔下经常生硬地出现一些工具人Npc，就像被操控的人偶一般。<br />
总体来说，这部剧本的优点和缺点都有强烈的洛德风格，你能在后续的剧作里看到相似的特点。</p>
<p>一年后洛德根据爱伦坡同名小说改编出剧作:《焦油博士和羽毛教授的系统》，作为改编剧，这部的情节没什么创新性，几乎完全照搬原作，但也因此像原作一样显得非常有趣，由于压缩了篇幅更增加了其荒诞感，除了里面的一些见血情节，颇有点喜剧效果，但由于硬在搞笑情节里加恐怖情节，最后的恐怖效果不怎么样还很突兀，完全不如爱伦坡的搞笑部分；不过可以推荐爱伦坡的粉丝看一遍，这里不多赘述。<br />
有意思的是，原著是爱伦坡一个美国人写的用来黑法国的短篇小说(也有人说是在影射美国)，里面有不少地域黑笑话，结果法国人洛德奉行拿来主义把里面地域黑的部分删掉了大部分，但名字还留着。涂焦油和粘羽毛是近代欧洲的一种私刑(美国也干了)，具体可以百度。<br />
这两部作品可以算洛德的前期创作，仍有不少稚嫩之处，恐怖或者猎奇情节也不多，此时不能叫恐怖王子，最多叫悬疑王子，在洛德之后的创作中血浆元素才会被大大加强</p>
<p>恐怖的实验，这部戏剧上演于1909年，大致可以视为洛德创作的中期，也是我能找到的第一篇疯狂医生题材剧作，同样有着典型的三段式结构，其中篇幅最大的第一幕用来铺垫，引入矛盾和矛盾爆发则压缩到第二幕。类似于《电话中》，在第一幕，洛德依旧先刻画出一个温馨的大家庭来拷打观众的同情心，三位主角分别是一对已经订婚的情侣基恩和珍妮以及女方的父亲————医学教授夏尔，夏尔是一位鰥夫，妻子在生下女儿不久后去世，夏尔和女儿相依为命，女儿体弱多病夏尔更需要费心照顾，这让父女间感情尤为深厚，因此女儿出嫁也让他尤为痛苦，纠结后他还是下定决心正式将女儿托付给未婚夫，同时也是夏尔得意门生的基恩，这段的描写非常感人，占据了整本剧作的近一半篇幅，让人感觉在看家庭伦理剧，在洛德的作品里，这种篇幅的感情描写可谓非常奢侈，也是我个人认为翻译的五部中最细腻感人的一部分。<br />
岳婿交心后，夏尔和基恩谈起了工作，而珍妮在不久后出门办事，夏尔一直在研究一种在死后电击心脏从而让死者复活的疗法，他约见了刽子手，让其在最近的处刑后把新鲜尸体送过来，商谈中，刽子手说起了一位受刑者断头后疑似回魂掐住他手臂的往事，此处的伏笔可谓相当明显，果不其然，下一场就有一通电话打来，珍妮出了车祸，年轻的基恩当即前往抢救，留下年迈的夏尔。<br />
进入第二幕，珍妮抢救无效已经死去，夏尔几乎陷入绝望，他执着地一个人守卫着遗体，此时，大概很多人能猜到会发生什么，于是洛德飞快让节奏推进到夏尔胁迫基恩进行复活实验的终局阶段，漆黑寂静的房间，偶尔闪现的电火花，疯狂的老父亲与不安的助手，以及禁忌的人体实验，这幕场景很有氛围感，顺理成章的，夏尔被疑似回魂的女儿掐住喉咙，窒息而死<br />
总的来说，这部剧作相比《电话中》恐怖效果更进一步，但悬念较为薄弱，还有一个非常经典的车祸情节(顺便一提,这不是洛德唯一一次用车祸这个梗)，几乎只有一个实验能否成功可以算作悬念，当然这是以现代套路化的恐怖小说电影来说的，在当时，死者回魂带走生者的桥段或许尚未泛滥。但恐怖戏剧不是悬疑戏剧，在恐怖效果上本作可以说相比前两部更好，即使猜到最后夏尔必然身死，最后一幕的恐怖实验氛围塑造依旧出色，试想黑暗中一具胸腔敞开，插着电极管的尸体突然暴起掐住手术者的脖子，这样的场景可谓非常有冲击力……此外，由于本作的感情描写非常细腻，老教授为复活女儿的尝试更添了一份悲剧感<br />
夏尔不惜沾染禁忌也要挑战死亡，他最后的死可能是死神的复仇，也可能是某种神经作用，真相就此埋葬在黑暗中……除了《电话中》，翻译的五部作品有四部和医生有关，可见洛德的作品有很浓重的医生情节，或许和他小时候目睹父亲病人的惨状有关，在1909的这部剧作中，夏尔教授和他的学徒基本都是正面或者中性形象，夏尔研究电击疗法的初衷是为了拯救更多生命，找尸体做实验虽然不道德但也是为了医学进步，结局里一位老父亲绝望之下想复活自己的女儿，比起疯狂猎奇，不如说更令人同情，但之后登场的医生就没有这么好的运气了……</p>
<p>洛德的两大招牌菜就是疯人院和医生，在1916年的《幻觉实验室》我们终于可以见到经典的疯人院场景了，或许是进入了自己的舒适区，洛德在营造氛围上更加得心应手，他在那篇对爱伦坡的改编剧作中尝到了疯人院环境声的甜头，于是这篇剧作全程伴随着病人的惨叫声(虽然在现在这不算新鲜手法，但寿司勇者可能也借鉴了这点)，尽管作为读者我们听不到。<br />
开篇，伴随着忧郁的小提琴声，幕布揭开，我们看到了两个愁眉苦脸的女人，女主角索尼娅和她的表姐塔尼娅，索尼娅自从嫁给了神经科医生戈尔利茨后一直闷闷不乐，医生忙于自己的实验，对妻子没有好脸色，精神病院环境压抑，四周也是偏僻的乡下，于是索尼娅叫来了表姐陪伴。<br />
想描写一个影响力强大且性格强势的角色，使用大量侧面描写是个好方法，因此洛德借用了女主姐妹，女主的仆人以及医生的助手相继对话来逐渐交代现状，四人中，索尼娅刻薄又憔悴，塔尼娅忙于安抚表妹，女佣人请求辞职，助手低声下气又有些神经质，通过这四种精神面貌，观众已经对医生建立起足够的印象了，于是医生的第一次出场直接用于揭露第一重矛盾————索尼娅对医生的厌恶。索尼娅抱怨这里无聊的生活，医生与其争吵，但这种家长里短在恐怖剧里没什么看头，因此这次冲突不过是虚晃一枪，外来的客人德莫拉出现，平息了冲突，并带着索尼娅一起去散步，如果医生做实验没把脑子做坏就该想到比起刻薄自私的自己，温文尔雅的德莫拉明显更有吸引力，但医生可能研究地走火入魔了，对妻子极其明显的移情别恋视而不见，胁迫助手助他进行禁忌实验。自此第一幕结束，妻子一方的矛盾已经交代得差不多了。<br />
第二幕则用来展现医生方的矛盾，并铺垫矛盾的全面爆发，开场先公式化地交代了医生的禁忌实验有多恐怖，即通过大脑手术来改造人的心智。完成这个任务后，妻子所在的车就非常识趣地出了车祸，却只有我们可怜的德莫拉先生受了重伤，医生发现了他身上的示爱信(非得等有明确证据才怀疑，这就是医生的实证精神吗)当即决定把本来就几乎没有的良心抛开，爆改这位可怜的病人。医生通过黑科技让他终日见到幻觉，永无宁日，呼应了标题。此时，医生虽说是对妻子挑起的矛盾的被动接受者，但相比妻子他明显有更强的能力来制造猛烈冲突，此消彼长，第二幕后戏剧的矛盾重心转移到了医生的复仇。<br />
铺垫完双方的矛盾后，第三幕就可以逐步添柴引火了，洛德娴熟地一步步火上浇油，同第一幕一样通过弱势的妻子方视角一步步了解德莫拉手术后的悲惨状况，观众更容易代入信息更多的医生方，简直让人想偷笑计划的顺利进行，颇有点希区柯克式的反派视角感觉，逐步过渡到伪高潮，妻子见到了深受折磨的德莫拉，医生得意地揭露自己的杰作，我要是观众就会鼓掌叫好了(不是)。此时双方的信息终于对等，矛盾才能真正地全面引爆，得知真相的德莫拉燃起复仇的业火，冲上去残酷地杀死了医生，戏剧在他绝望的喊叫和飞溅的鲜血中落幕。<br />
在戏剧效果方面，本作颇有亮点，视角来回在妻子和丈夫间切换，信息上的优势方也来回切换，弥补了《恐怖的实验》中缺少的悬疑感，恐怖情节上手术过程和最后的复仇也非常血腥残暴，避免了《电话中》缺少血浆的问题。此外，病人惨叫和提琴声作为环境声也非常适合，相比之前的俗套的暴风雨之夜更加有创意，人物塑造上也比较有意思，不算完全的木偶角色，相比其他作品的好坏分明，这是第一部洛德使用善恶难辨的双方作为主角的剧本，表达的情感也更为复杂。<br />
例如男主角医生，洛德笔下的疯狂科学家形象可以视为对浮士德，弗兰肯斯坦这些戏剧形象的致敬，但为了服务于恐怖情节，一般只有疯狂不怎么科学，如果抛开科学家身份，但作为丈夫其实还是有一些细节描写的，例如在惹恼妻子后医生立刻道歉挽留；虽然胁迫助手，但从两人对话可知似乎米琴有什么黑历史，欠医生收留他的人情；医生挑选实验者似乎都是他认定无药可救之人；在找到出轨证据前，看上去也是认真想抢救德莫拉，可见医生有较强的职业能力，还有点些微的职业道德，并且确实爱着自己的妻子，在发现出轨后才为了报复拿不是必死的人做实验<br />
此外，医生致力于开创未来，德莫拉却带着索尼娅观赏历史遗迹，这也是一处有趣的对比，可见洛德对医学等现代“科学”或许有着既憧憬又畏惧的心态，这也是二十世纪初的一种常见的大众心理。联系这点再看故事中的矛盾，医生自诩理性的研究者，却无法舍弃感性，无法压抑对妻子情夫的嫉妒，最后间接死于这种嫉妒心；他用现代科学改造了德莫拉的大脑，但依旧无法改变人类本性中的复仇心，最后死于这种原始的感情，颇有些因果报应的味道。听起来有着科学理性无法彻底舍弃人心感性这样的寓意，当然这只是个人想法。<br />
总得来说，这部剧本的题材在当时应该颇有新意(十九世纪末才逐渐产生了神经元学说)，故事情节在道德上处于灰色地带，有点类似于巫师3的血腥男爵家庭故事，不乏一些耐人寻味的细节，矛盾的演变发展节奏流畅，最后一幕的转折颇多，恐怖情节也较有新意，血浆还不少，是洛德的一部集大成之作。</p>
<p>1925年，此时已经是洛德写作生涯的末期，他与其心理主治医师合作写作了《疯人院的罪行》这篇可能是洛德最有名气的剧作，在延续了洛德一贯风格的同时，这篇剧作在残忍血腥上达到了一个新高度(当然这里说的是我翻译的几部剧作)，同时可能启发了后世泛滥的精神病人杀人题材，很适合作为对其解剖的终幕<br />
很少见的，洛德没有让主角在一开始登场，这或许是恐怖王子的怜悯，不希望观众过于代入主角之后被吓出心脏病。但不管怎么说，开幕我们只能看到两个配角的对话，修女和罗宾女士，罗宾女士是精神病院的老病人，已经痊愈但因为社会对病人的歧视选择留在病院帮助看护病人，这算是洛德为数不多的公益行为，揭露了歧视这种较为严肃的议题，不过我怀疑是心理医生加入的。这间精神病院同时兼职修道院，而修女负责女性病房的看护，看护戏剧中这间病房的修女是标准的宗教狂热者，因为小姑娘路易斯不皈依而处处刁难她，尽管如此，一位修女不可能因为这种原因就要害死一个小姑娘，因此这依旧是个用来勾起观众同情心的花招。<br />
事实上，这次的主角路易斯可能是五幕戏剧中最弱势的一位，她出身在乡下，但似乎幼时被父母送给了其他人家，即使出院也会过得很艰难，但在医院她会遇到更近在眼前的危险——和她同病房的两个疯女人，她唯二的保护者只有修女等看护人员和医生，负责看护的修女与她关系不好，更巧的是今天有位修女去世，晚上修女们要去守灵，可怜的路易斯只有医生能够指望了，医生总体来说是个好人，他以难以安身为由驳回了路易斯出院的请求，并承诺为她安排一个去处，虽然这让路易斯无法逃离危险，但为了安抚路易斯的不安，他命令修女在今晚陪着路易斯一起，作为洛德的资深观众，我们很容易就能猜到所有保险终归都得被拔下去，因此在这波小小的插曲后，修女就无视了医生的命令急匆匆地去参加仪式了。对熟悉洛德套路的我们来说，其实这段已经显得有些啰嗦了，真正在推进剧情的其实是两个疯女人令人不安的台词，但与之前剧作不同的是，疯子作为危险的施加者没有理性，同样也没什么悬念，反正她们肯定会发狂然后实施暴行。<br />
步入到第二幕，在修道院的唱诗班歌声中(顺便一提，作为背景音这倒是很有氛围)，两个疯女人在月夜下苏醒，她们打开房门迎接了独眼女，这群疯子中的头目，独眼女曾因为谋杀儿童被审判，但因为精神问题被释放，三人控制住了路易斯，独眼女告诉两人一只布谷鸟带着她的眼睛飞进了路易斯的脑子里，三人致力于把布谷鸟解放出来，细节就不赘述了，最后两人发现并没有布谷鸟存在，于是恼羞成怒地谋杀了独眼女人；值得一提的是，洛德少见的使用了某种意义上的反高潮结尾，似乎听到动静的修女赶来，却并没有发现疯子们的罪行，戏剧就在充斥着罪恶的黑夜中结束，正义并没有得到伸张。<br />
总的来说，这部剧作的优缺点依旧延续了洛德过往的风格，钟声，唱诗班，月夜，疯狂的老妇人种种恐怖场景依旧很有舞台效果，但除此以外的人物形象和谋害动机都很单薄，前文提到这是三个老病人，居然能完美控住年轻的路易斯，简直是超人，最后的收尾也比较牵强，修女站在门口没有理由不闻到烧肉味或者血腥味；虽然对疯子，尤其是洛德笔下的疯子讲不了什么道理，但戏剧中角色缺少交互，行为逻辑难以推测，作为观众只能坐等着疯子们发狂也是挺无聊的，就故事来说我个人认为还不如之前三作，但疯人题材的优点就是能大大增加血腥度，从这个角度来说，依旧是一部成功的戏剧，因此在后日被经常重演。</p>
<p>说完洛德的戏剧，我们来说说bs和东方里对其的neta，东方对古兰的neta很单纯，也就是永夜抄爱丽丝的终符——【猎奇剧团的怪人】，了解蓬莱人形和东方旧作的都知道，早年的神主非常中二，经常喝了假⑨再做游戏，还很喜欢黑深残，给新作爱丽丝做一个来源这么血腥暴力的符卡也不算奇怪，在此我就不负责任的为以这个视角口胡一下东方里爱丽丝形象的演变史。<br />
爱丽丝是一个非常特殊的角色，神主的社团名就包含了爱丽丝，上海表示东西方文化交融，爱丽丝代表童话与幻想，幻乐团表示主要做的是音乐，游戏是买音乐附送的，因此东方project是个东西文化交融的幻想音游(迫真)，而体现这个特点的爱丽丝是少见的旧作和新作都有出场的角色，也是少见被神主确认可能新旧作是同一人的角色。旧作时期神主经常neta其他作品，旧作爱丽丝的一个原型就是真女神转生系列的魔人爱丽丝，这里不讨论爱丽丝形象的演变史，但魔人爱丽丝身上有两个要素被东方的爱丽丝所继承——也就是魔法和人偶(虽然旧作爱丽丝没什么人偶要素)<br />
进入新作时代，神主的中二病还没有完全痊愈，为了东西交融这个主题，也可能是受奎因国名系列启发（毕竟神主应该挺喜欢看推理小说的），他把爱丽丝的人偶以全球各个著名地名命名，同时，爱丽丝的符卡也用了不少关于全球各种人偶木偶的neta，可能为了给符卡找资料，神主查法国人偶的资料查到了吉涅尔，而知道吉涅尔很容易就能查到古兰吉涅尔，古兰黑深残的风格深得中二神主的欣赏，于是被做成了爱丽丝终符【猎奇剧团的怪人】，被魔理沙评价为爱丽丝的全力出手，成为爱丽丝又一大黑化设定来源……以上只是我不负责任的猜测</p>
<p>而bs中古兰和洛德的戏份可能来自于作者东方众的身份，因为将古兰剧场和人偶戏扯上关系的明显是东方要更早，事实上，寿司画的东方异形乡也有类似场景，具体到游戏中，地狱王子这个头衔明显neta恐怖王子的称号，洛德的猫头鹰形象可能是源于他白天工作晚上写剧本的习惯，也不排除是寿司作为东方厨献礼东方神灵庙十周年(2021)，而蛇腹剑，额，可能neta血源？洛德出场于dlc3，而dlc3除了冬之钟，还有一个地图——谜团重重的克里米亚墓地，虽然洛德没有在此出场，墓地以及本体的精神病院地图都非常有洛德的风格。院长弗洛伦斯，化身博士也几乎是与洛德同时代的存在。星虫手术，疯狂医生，无助的小女孩，蜡像，修女这些地方都和我们之前介绍的洛德戏剧有相似之处，可能受了洛德影响，当然，这些都是猜测。<br />
此外，洛德的技能，恐怖手术，泼硫酸等都源自其戏剧，虽然泼硫酸那部只能找到大致介绍，150部剧作，挖下眼睛等威胁台词应该也是同理，但部分台词我没找到出处，可能在日版的洛德剧作里。<br />
值得一提的是，现实的洛德并不只为古兰剧院供稿，甚至很多剧作都不是他独著，嘲讽童话作家也没什么道理，部分童话作者例如格林兄弟整理的是民间故事，不完全是给小孩看的，其中不乏r18内容，原版故事尺度未必比洛德小多少，（当然这部分考据也很麻烦，感兴趣的人可以自己去查查相关论文研究）；而安徒生，王尔德等人的童话虽然不血腥，悲剧情节也不少，游戏里夸张的性格主要还是二设，硬要说的话，洛德的人气远不如格林等著名童话作者，还没被这个世界的古兰选中，游戏洛德完全是嫉妒格林而出言挑衅。当然，洛德和童话作家的主要分歧在于幻想和现实，但正如我们之前所见，洛德的剧作不乏刻意的发展和科幻的医疗技术，他并不是纯粹的自然主义信徒，而童话里也未必没有现实成分，总之，这种二设看个乐就好</p>
<p>即使已经历经百年，古兰剧场依旧是恐怖文化的一个经典符号，或许未来还会有不同的作品引用古兰剧场，正如疯帽子所说：“童话不会就此死去。而是在你所不曾知晓的地方，继续生长下去”</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>基于斯坦福cs106b的c++数据结构笔记</title>
    <url>/thinklive/16615/</url>
    <content><![CDATA[<h2 id="一些查找和排序算法">一些查找和排序算法</h2>
<p>二分查找法 <img src="/images/obsidian/20230226101843.png" title="image" alt="图片" /> 最坏情况：log2n <span id="more"></span> 寻找最小排序 <img src="/images/obsidian/20230224172126.png" title="image" alt="图片" /> 向前插入算法 <img src="/images/obsidian/20230226090109.png" title="image" alt="图片" /></p>
<p>合并算法接受两个排序的 列出并将它们组合成一个 排序列表。 ● 虽然两个列表都是非空的，但比较它们的 第一要素。 删除较小的元素 并将其附加到输出。 ● 一旦一个列表为空，添加所有元素 另一个列表输出。 ● 它运行时间为 O(n)，其中 n 是总数 合并的元素数量。 <img src="/images/obsidian/20230226090958.png" title="image" alt="图片" /> 无限递归后的合并算法 <img src="/images/obsidian/20230226093232.png" title="image" alt="图片" /> 复杂度：nlog2n</p>
<h2 id="容器类">容器类</h2>
<p><code>set（集合）：无序不允许重复的容器类，可以添加删除元素 You can add a value to a Set by writing   set += value;  s. ● You can remove a value from a Set by writing   set -= value;   ● You can check if a value exists in a Set by writing   set.contains(value)</code>map(键值对的集合) 如果没有对应key的value，返回默认值（见定义文件） `vector vector的remove根据移除元素的索引有1-n的复杂度，移除尾部为O(1)，如果不在意索引，可以交换要移除元素和尾部元素再移除</p>
<h1 id="哈希表">哈希表</h1>
<p>哈希表的负载因子α表示元素和表格键数量的比，决定了查找速度</p>
<h2 id="检查表中是否存在元素">检查表中是否存在元素</h2>
<p>● 计算元素的散列码。 ● 跳转到表格中的那个位置。 ● 向前扫描——必要时环绕——直到项目或一个 发现空插槽。</p>
<h2 id="将元素插入表中">将元素插入表中</h2>
<p>● 如果项目已经存在，什么也不做。 ● 否则，跳转到元素哈希码给定的槽。 向前走——必要时环绕——直到一个空白点或 找到墓碑插槽。 然后，将项目放在那里。</p>
<h2 id="从表中删除一个元素">从表中删除一个元素</h2>
<p>● 跳转到由元素的散列码给定的槽。 ● 向前走——必要时环绕——直到物品或 发现空插槽。 如果找到该项目，请将其替换为 墓碑。</p>
<h2 id="罗宾汉哈希表">“罗宾汉哈希表”</h2>
<ul>
<li>如果插入的值比其将插入的位置的值距离索引更远，则替换插入值和当前值</li>
<li>删除值时，将后其离原键远的元素前移</li>
<li>★ 罗宾汉哈希一览 ★</li>
<li>检查表中是否存在元素：</li>
<li>● 跳转到表中由元素的散列码给出的位置。</li>
<li>● 向前扫描——如有必要环绕——记录有多少步 你拿走了。 当您找到该项目、找到一个空白槽或找到一个 离家更近的空位比你走的步数还多。</li>
<li>将元素插入表中：</li>
<li>● 如果该元素已在表中，则什么也不做。</li>
<li>● 跳转到由元素的散列码给出的表槽。 向前扫描 - 换行 如有必要，四处走走——记录所走的步数。 如果你找到一个 空插槽，将元素放在那里。 否则，如果当前插槽已满并且 比您插入的元素更靠近家，将要插入的项目放在那里， 替换那个位置的元素，然后继续插入，就好像你 正在插入被置换的元素。</li>
<li>从表中删除一个元素：</li>
<li>● 跳转到由元素的散列码给定的槽。</li>
<li>● 向前走——如有必要，环绕——直到物品或空槽被放置 成立。 如果找到该项目，请将其删除。 然后，继续前进——包裹 around as necessary – 将表中的元素向后移动一个槽位，直到 找到空插槽或位于其原始位置的项目</li>
</ul>
<h2 id="string类">string类</h2>
<p>str::npos表示容器的最后一个成员位置 if (s.find("e") != string::npos) //find函数找不到时返回npos if s in str: string obj; obj.substr(int pos) //pos为要包含的第一个字符串的位置 <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> a = "0123456789abcdefghij";</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    // count is npos, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub1 = a.substr(10);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub1 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // both pos and pos+count are within bounds, returns [pos, pos+count)</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub2 = a.substr(5, 3);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub2 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // pos is within bounds, pos+count is not, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub4 = a.substr(a.size()-3, 50);</span><br><span class="line">    // this is effectively equivalent to</span><br><span class="line">    // std::string sub4 = a.substr(17, 3);</span><br><span class="line">    // since a.size() == 20, pos == a.size()-3 == 17, and a.size()-pos == 3</span><br><span class="line"></span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub4 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // pos is out of bounds, throws</span><br><span class="line">        [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub5 = a.substr(a.size()+3, 50);</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub5 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125; catch(const [std::out_of_range](http://en.cppreference.com/w/cpp/error/out_of_range)&amp; e) &#123;</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; &quot;pos exceeds string size\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">abcdefghij</span><br><span class="line">567</span><br><span class="line">hij</span><br><span class="line">pos exceeds string size</span><br></pre></td></tr></table></figure>
<p>`replace和insert str1.insert(start, str2) str1.replace(start, length, str2)</p>
<h2 id="一些实现">一些实现</h2>
<h3 id="优先队列">优先队列</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &quot;HeapPQueue.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">HeapPQueue::HeapPQueue() &#123;</span><br><span class="line">    elems = new DataPoint[INITIAL_SIZE] &#123;&#125;;</span><br><span class="line">    for (int i=0;i&lt;INITIAL_SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[i].weight=0;</span><br><span class="line">    &#125;</span><br><span class="line">    allocatedSize=INITIAL_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapPQueue::~HeapPQueue() &#123;</span><br><span class="line">    delete [] elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int HeapPQueue::size() const &#123;</span><br><span class="line">    return logicalSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool HeapPQueue::isEmpty() const &#123;</span><br><span class="line">    return logicalSize==0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapPQueue::enqueue(const DataPoint&amp; data) &#123;</span><br><span class="line">    if (logicalSize+1&lt;allocatedSize)</span><br><span class="line">    &#123;</span><br><span class="line">        if (logicalSize==0)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[1]=data;</span><br><span class="line">            logicalSize++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            logicalSize++;</span><br><span class="line">            int i=1;</span><br><span class="line">            while (data.weight&gt;elems[i].weight &amp;&amp; i&lt;=logicalSize &amp;&amp; elems[i].weight!=0)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i&lt;logicalSize)</span><br><span class="line">            &#123;</span><br><span class="line">                DataPoint temp=elems[i];</span><br><span class="line">                elems[i]=data;</span><br><span class="line">                for(i;i&lt;logicalSize;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    DataPoint temp_plus=elems[i+1];</span><br><span class="line">                    elems[i+1]=temp;</span><br><span class="line">                    temp=temp_plus;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                elems[i]=data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::peek() const &#123;</span><br><span class="line">    return elems[logicalSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::dequeue() &#123;</span><br><span class="line">    DataPoint to_return=elems[1];</span><br><span class="line">    if(!isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (int i=1;i&lt;logicalSize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[i]=elems[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        elems[logicalSize]=&#123;&#125;;</span><br><span class="line">        logicalSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    return to_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计数排序">计数排序</h3>
<p>首先算出最大值，然后用一个数组的索引存储待排序数组的成员，其索引对应值存储出现次数，然后用两个同步的for循环和递增的next参数表示排序中的索引值来进行排序（也就是重新赋值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Given a Vector&lt;int&gt;, returns the largest number in that Vector. */</span><br><span class="line">int maxOf(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Bounds-check inputs. */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        error(&quot;Can&#x27;t find the maximum of no values.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = values[0];</span><br><span class="line">    for (int i = 1; i &lt; values.size(); i++) &#123;</span><br><span class="line">        result = max(result, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a list of numbers, creates a histogram from those numbers. */</span><br><span class="line">Vector&lt;int&gt; histogramFor(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Create a histogram with the right number of slots. Initially, all values</span><br><span class="line">     * in the histogram will be zero.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; histogram(maxOf(values) + 1);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the input vector, incrementing the histogram values. */</span><br><span class="line">    for (int value: values) &#123;</span><br><span class="line">        histogram[value]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return histogram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void countingSort(Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Edge Case: If the array is empty, then it&#x27;s already sorted. This is</span><br><span class="line">     * needed because we can&#x27;t take the maximum value of an empty vector.</span><br><span class="line">     */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Form the histogram. */</span><br><span class="line">    auto histogram = histogramFor(values);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the histogram writing out the appropriate number of copies</span><br><span class="line">     * of each value. We track the index of the next free spot to write to,</span><br><span class="line">     * as it varies based on how many items we&#x27;ve written out so far.</span><br><span class="line">     */</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (int value = 0; value &lt; histogram.size(); value++) &#123;</span><br><span class="line">        /* Write out the right number of copies. */</span><br><span class="line">        for (int copy = 0; copy &lt; histogram[value]; copy++) &#123;</span><br><span class="line">            values[next] = value;</span><br><span class="line">            next++;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="错题集">错题集</h2>
<h3 id="递归的效率优化">递归的效率优化</h3>
<p>每次递归都会创造所有变量的临时复制 基于递归的这种性质，它会需要巨大的时间和空间来完成任务，并且会造成算力上的浪费。 通过记忆表机制能部分解决这个问题，方法是每次递归的返回值都会按索引存入一个表格，并且每次递归前查询表格中是否有结果，这样可以让每个临时副本的运算结果能被所有函数共享。</p>
<h3 id="递归计算给定元素的不同结构哈夫曼树的数量">递归计算给定元素的不同结构哈夫曼树的数量</h3>
<p>对每个给定元素集来说，首先要做到是确定根节点元素是第几个大的元素，确定之后，左子树和右子树的元素数也随之确定，在此之后分别对左节点和右节点作为根节点做同样的递归</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int numBSTsOfSize(int n) &#123;</span><br><span class="line"></span><br><span class="line">  /* Base case: There’s only one tree of size 0, namely, the empty BST. */</span><br><span class="line">  if (n == 0) return 1;</span><br><span class="line">  </span><br><span class="line">  /* Recursive case: Imagine all possible ways to choose a root and build the</span><br><span class="line">   * left and right subtrees.</span><br><span class="line">  */</span><br><span class="line">  int result = 0;</span><br><span class="line">  </span><br><span class="line">  /* Put the the nodes at indices 0, 1, 2, ..., n-1 up at the root. */</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    /* Each combination of a BST of i elements and a BST of n - 1 - i elements</span><br><span class="line">     * can be used to build one BST of n elements. The number of pairs of</span><br><span class="line">     * trees we can make this way is given by the product of the number of</span><br><span class="line">     * trees of each type.</span><br><span class="line">     */</span><br><span class="line">     result += numBSTsOfSize(i) * numBSTsOfSize(n - 1 - i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决吃巧克力问题">递归解决吃巧克力问题</h3>
<h1 id="求出吃法数量">求出吃法数量</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (numSquares&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">    error(&quot;输入数据不能为负数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (numSquares&lt;=1)</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    return numWaysToEat(numSquares-1)+numWaysToEat(numSquares-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打印每种吃法">打印每种吃法</h1>
<p>`需要一个辅助向量储存历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Print all ways to eat numSquares more squares, given that we&#x27;ve</span><br><span class="line"> * already taken the bites given in soFar.</span><br><span class="line"> */</span><br><span class="line">void printWaysToEatRec(int numSquares, const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /* Base Case: If there are no squares left, the only option is to use</span><br><span class="line">     * the bites we&#x27;ve taken already in soFar.</span><br><span class="line">     */</span><br><span class="line">    if (numSquares == 0) &#123;</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If there is one square lfet, the only option is to eat</span><br><span class="line">     * that square.</span><br><span class="line">     */</span><br><span class="line">    else if (numSquares == 1) &#123;</span><br><span class="line">        cout &lt;&lt; soFar + 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Otherwise, we take take bites of size one or of size two. */</span><br><span class="line">    else &#123;</span><br><span class="line">        printWaysToEatRec(numSquares - 1, soFar + 1);</span><br><span class="line">        printWaysToEatRec(numSquares - 2, soFar + 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printWaysToEat(int numSquares) &#123;</span><br><span class="line">    if (numSquares &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me some chocolate!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We begin without having made any bites. */</span><br><span class="line">    printWaysToEatRec(numSquares, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决翻煎饼问题">递归解决翻煎饼问题</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isSorted(Stack&lt;double&gt; pancakes) &#123;</span><br><span class="line">    double last = -1; // No pancakes have negative size;</span><br><span class="line"></span><br><span class="line">    while (!pancakes.isEmpty()) &#123;</span><br><span class="line">        /* Check the next pancake. */</span><br><span class="line">        double next = pancakes.pop();</span><br><span class="line">        if (next &lt; last) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Pancakes are in increasing order! */</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a stack of pancakes and a flip size, flips that many pancakes</span><br><span class="line"> * on the top of the stack.</span><br><span class="line"> */</span><br><span class="line">Stack&lt;double&gt; flip(Stack&lt;double&gt; pancakes, int numToFlip) &#123;</span><br><span class="line">    /* Take the top pancakes off the stack and run them into a queue.</span><br><span class="line">     * This preserves the order in which they were removed.</span><br><span class="line">     */</span><br><span class="line">    Queue&lt;double&gt; buffer;</span><br><span class="line">    for (int i = 0; i &lt; numToFlip; i++) &#123;</span><br><span class="line">        buffer.enqueue(pancakes.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Move the pancakes back. */</span><br><span class="line">    while (!buffer.isEmpty()) &#123;</span><br><span class="line">        pancakes.push(buffer.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pancakes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; sortStack(Stack&lt;double&gt; pancakes, int numFlips) &#123;</span><br><span class="line">    /* Base Case: If the stack is sorted, great! We&#x27;re done, and no flips</span><br><span class="line">     * were needed.</span><br><span class="line">     */</span><br><span class="line">    if (isSorted(pancakes)) &#123;</span><br><span class="line">        return &#123; &#125;; // No flips</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If the stack isn&#x27;t sorted and we&#x27;re out of flips, then</span><br><span class="line">     * there is no way to sort things.</span><br><span class="line">     */</span><br><span class="line">    else if (numFlips == 0) &#123;</span><br><span class="line">        return Nothing;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive Case: The stack isn&#x27;t sorted and we still have flips left.</span><br><span class="line">     * The next flip could flip 1, 2, 3, ..., or all N of the pancakes.</span><br><span class="line">     * Try each option and see whether any of them work.</span><br><span class="line">     */</span><br><span class="line">    for (int numToFlip = 1; numToFlip &lt;= pancakes.size(); numToFlip++) &#123;</span><br><span class="line">        /* Make the flip and see if it works. */</span><br><span class="line">        auto result = sortStack(flip(pancakes, numToFlip), numFlips - 1);</span><br><span class="line">        if (result != Nothing) &#123;</span><br><span class="line">            /* The result holds all the remaining flips but doesn&#x27;t know about</span><br><span class="line">             * the flip we just did. Insert that flip at the beginning.</span><br><span class="line">             */</span><br><span class="line">            result.value().insert(0, numToFlip);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we&#x27;re here, then no matter which flip we make first, we cannot</span><br><span class="line">     * get the pancakes sorted. Give up.</span><br><span class="line">     */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决天平问题">递归解决天平问题</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isMeasurableRec(int amount, const Vector&lt;int&gt;&amp; weights, int index) &#123;</span><br><span class="line">  if (index == weights.size()) &#123;</span><br><span class="line">      return amount == 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      return isMeasurableRec(amount,                  weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount + weights[index], weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount - weights[index], weights, index + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMeasurable(int amount, const Vector&lt;int&gt;&amp; weights) &#123;</span><br><span class="line">    return isMeasurableRec(amount, weights, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象一下，我们首先将要测量的数量（称为 <em>n</em> ）放在天平的左侧。 这使得规模上的不平衡等于 <em>n</em> 。 想象一下，有某种方法可以测量 <em>n</em> 。 如果我们一次将一个重量放在秤上，我们可以查看第一个重量的放置位置（假设它的重量为 <em>w</em> ）。 它必须：</p>
<ul>
<li>向左走，使规模上的净不平衡 <em>n + w</em> ，或</li>
<li>向右走，使规模上的净不平衡 <em>n – w</em> ，或</li>
<li>根本不习惯，留下净不平衡 <em>n</em> 。</li>
</ul>
<p>如果确实有可能测量 <em>n</em> ，那么这三个选项之一必须是实现它的方法，即使我们不知道它是哪一个。 然后我们要问的问题是，是否有可能使用剩余的权重来衡量新的净失衡——我们可以递归地确定！ 另一方面，如果无法测量 <em>n</em> ，那么无论我们选择哪个选项，我们都会发现没有办法使用剩余的权重来使一切平衡！</p>
<p>如果我们递归地进行，我们在这里，我们需要考虑我们的基本情况。 我们可以选择的选项有很多。 一个简单的方法如下：假设我们根本没有任何重量，我们被要求查看是否可以不使用重量来测量某些重量。 在什么情况下我们可以这样做？ 好吧，如果我们称重的东西有一个非零重量，我们就不可能测量它——把它放在秤上会使它倾斜到某一边，但这并不能告诉我们它有多少重量。 另一方面，如果我们称量的东西是完全失重的，那么把它放在秤上也不会导致它倾斜，让我们相信它确实是失重的！ 因此，作为我们的基本情况，我们会说当我们减少到没有剩余权重时， <em>，我们可以精确测量n</em> 如果 <em>n = 0</em> 。 考虑到这一点，这是我们的代码：</p>
<h3 id="递归解决找零问题">递归解决找零问题</h3>
<h1 id="不使用记忆的情况">不使用记忆的情况</h1>
<p>`从第一个硬币开始遍历，并穷举它的所有枚数，将其作为下一枚硬币的参数传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    else if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (coins.isEmpty()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins.first();</span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsFor(cents - copies * coin,</span><br><span class="line">                                                     coins - coin);</span><br><span class="line">          /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用记忆进行优化">使用记忆进行优化</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* How few coins are needed to make the total, given that we can only use</span><br><span class="line"> * coins from index startIndex and onward?</span><br><span class="line"> */</span><br><span class="line">int fewestCoinsRec(int cents, const Vector&lt;int&gt;&amp; coins, int startIndex,Grid&lt;int&gt;&amp; memo) &#123;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (startIndex == coins.size()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: We already know the answer. */</span><br><span class="line">    else if (memo[cents][startIndex] != -1) &#123;</span><br><span class="line">        return memo[cents][startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line"></span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins[startIndex];</span><br><span class="line"></span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsRec(cents - copies * coin,</span><br><span class="line">                                                     coins, startIndex + 1,</span><br><span class="line">                                                     memo);</span><br><span class="line"></span><br><span class="line">            /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        memo[cents][startIndex] = bestSoFar;</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Convert from a Set&lt;int&gt; to a Vector&lt;int&gt; so we have a nice ordering</span><br><span class="line">     * on things.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; coinVec;</span><br><span class="line">    for (int coin: coins) &#123;</span><br><span class="line">        coinVec += coin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build our memoization table. Since the number of cents left ranges from</span><br><span class="line">     * 0 to cents, we need cents+1 rows. Since the start index of the coin</span><br><span class="line">     * ranges from 0 to coins.size(), we make coins.size() + 1 columns.</span><br><span class="line">     *</span><br><span class="line">     * -1 is used as a sentinel to indicate &quot;nothing has been computed here</span><br><span class="line">     * yet.&quot;</span><br><span class="line">     */</span><br><span class="line">    Grid&lt;int&gt; memo(cents + 1, coins.size() + 1, -1);</span><br><span class="line"></span><br><span class="line">    /* Now ask how many coins are needed to make the total, using any coins</span><br><span class="line">     * from index 0 onward.</span><br><span class="line">     */</span><br><span class="line">    return fewestCoinsRec(cents, coinVec, 0, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归穷举付账单">递归穷举付账单</h3>
<p>递归机制：对第一个人来说，0-total所有金额都会付一遍，随后传递给下一个人，当只有一人时，付清所有余额并打印账单 传递参数：string,int的映射存储目前为止的账单，string集合存储所有付账者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void listPossiblePaymentsRec(int total, const Set&lt;string&gt;&amp; people,const Map&lt;string, int&gt;&amp; payments) &#123;</span><br><span class="line">    /* Base case: if there&#x27;s one person left, they have to pay the whole bill. */</span><br><span class="line">    if (people.size() == 1) &#123;</span><br><span class="line">        Map&lt;string, int&gt; finalPayments = payments;</span><br><span class="line">        finalPayments[people.first()] = total;</span><br><span class="line">        cout &lt;&lt; finalPayments &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: The first person has to pay some amount between 0 and the</span><br><span class="line">     * total amount. Try all of those possibilities.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int payment = 0; payment &lt;= total; payment++) &#123;</span><br><span class="line">            /* Create a new assignment of people to payments in which this first</span><br><span class="line">             * person pays this amount.</span><br><span class="line">             */</span><br><span class="line">            Map&lt;string, int&gt; updatedPayments = payments;</span><br><span class="line">            updatedPayments[people.first()] = payment;</span><br><span class="line">            listPossiblePaymentsRec(total - payment, people - people.first(),updatedPayments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void listPossiblePayments(int total, const Set&lt;string&gt;&amp; people) &#123;</span><br><span class="line">    /* Edge cases: we can&#x27;t pay a negative total, and there must be at least one</span><br><span class="line">     * person.</span><br><span class="line">     */</span><br><span class="line">    if (total &lt; 0) error(&quot;Guess you&#x27;re an employee?&quot;);</span><br><span class="line">    if (people.isEmpty()) error(&quot;Dine and dash?&quot;);</span><br><span class="line"> listPossiblePaymentsRec(total, people, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归寻找完全平方数列">递归寻找完全平方数列</h3>
<p>主要参数为sofar——用于存储目前的序列和一个set用于存储还没放入数列的数字，`确保这两者同时被传递，且其并集为所有数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSquareSequence(int n) &#123;</span><br><span class="line">    /*Validate input.*/</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        error(&quot;Don&#x27;t be so negative!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build a set of the numbers 1, 2, 3, ..., n. */</span><br><span class="line">    Set&lt;int&gt; options;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        options += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return findSequenceRec(options, &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSequenceRec(const Set&lt;int&gt;&amp; unused,</span><br><span class="line">                                      const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /*Base Case: If all numbers are used, we have our sequence!*/</span><br><span class="line">    if (unused.isEmpty()) &#123;</span><br><span class="line">        return soFar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Recursive Case: Some number comes next. Try each of them and see which</span><br><span class="line">     * one we should pick.</span><br><span class="line">     */</span><br><span class="line">    for (int next: unused) &#123;</span><br><span class="line">        /* We can use this if either</span><br><span class="line">         *</span><br><span class="line">         * 1. the sequence is empty, so we&#x27;re first in line, or</span><br><span class="line">         * 2. the sequence is not empty, but we sum to a perfect square</span><br><span class="line">         *    with the previous term.</span><br><span class="line">         */</span><br><span class="line">        if (soFar.isEmpty() ||</span><br><span class="line">            isPerfectSquare(next + soFar[soFar.size() - 1])) &#123;</span><br><span class="line">            /* See what happens if we extend with this number. */</span><br><span class="line">            auto result = findSequenceRec(unused - next, soFar + next);</span><br><span class="line">            if (result != Nothing) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Tried all options and none of them worked. Oh well! */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="汉诺塔递归">汉诺塔递归</h3>
<p>假设有三座汉诺塔，<code>start ,temp ,finish</code> 对n层的汉诺塔问题，先考虑n-1层的，随后考虑n-2层，到最后只需要考虑两层问题，两层的汉诺塔非常容易解决，起点为start,终点是temp,临时塔为finish，最后我们得到temp上的两层汉诺塔 这时将start的3移动到finish塔，这时只要将两层汉诺塔转移到finish则完成了三层汉诺塔，这个过程中的起点为temp,终点是finish,临时塔是start 以此类推，四层塔基于三层塔，<code>n</code>层塔基于<code>n-1</code>塔，汉诺塔问题解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int moveTower(int numDisks, char start, char finish, char temp) &#123;</span><br><span class="line">    if (numDisks == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int movesOne = moveTower(numDisks - 1, start, temp, finish);</span><br><span class="line">        moveSingleDisk(start, finish);</span><br><span class="line">        int movesTwo = moveTower(numDisks - 1, temp, finish, start);</span><br><span class="line"></span><br><span class="line">        return 1 + movesOne + movesTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据结构与算法</tag>
        <tag>c++</tag>
        <tag>斯坦福</tag>
      </tags>
  </entry>
  <entry>
    <title>苏州大学计算机网络复习70问</title>
    <url>/thinklive/19859/</url>
    <content><![CDATA[<ol type="1">
<li><p>在TCP/IP协议栈的层次中，解决计算机之间通信问题的是在哪个层次<br />
网际层</p></li>
<li><p>IP协议提供的服务类型是什么<br />
为IP数据报提供无连接，不可靠，尽力交付的路由选择和传输服务</p></li>
</ol>
<span id="more"></span>
<ol start="3" type="1">
<li><p>IPv4向IPv6过渡时，可以采用什么策略<br />
1.隧道技术，将ipv6数据报作为ipv4数据报的数据部分传递<br />
2.双协议栈，设备可以同时提供两种协议的服务，按需选择</p></li>
<li><p>IPv4首部长度字段的数值范围<br />
最短为20B，使用可选字段最长可以拓展到60B</p></li>
<li><p>合法的电子邮件地址<br />
邮箱名@邮箱所在主机的域名<br />
其中邮箱名对于这个邮箱范围唯一，域名在全球唯一</p></li>
<li><p>路由信息协议（RIP）使用的路由算法是什么<br />
距离向量算法:从路由器自身到其他每个目的网络的距离，记为距离向量，任意两个路由固定时间交换路由表，如果有更短路径就更新</p></li>
<li><p>默认的HTTP服务的端口号<br />
80</p></li>
<li><p>IP地址为140.111.0.0的B类网络，若要分为9个子网，子网掩码应为什么<br />
255.255.240.0</p></li>
<li><p>IPv6的基本首部长度为多少个字节<br />
40B</p></li>
<li><p>如果访问Internet时只能使用IP地址，可能是因为没有配置<br />
dns解析服务器</p></li>
<li><p>传输层向上层提供的是什么样的数据传输服务<br />
分为UDP和TCP;<br />
UDP提供无连接不可靠服务<br />
TCP提供有连接的可靠服务</p></li>
<li><p>数据通信系统由哪三个子系统构成<br />
1、中央计算机系统：由通信控制器（或前置处理机）、主机及其外围设备组成，具有处理从数据终端设备输入的数据信息，并将处理结果向相应的数据终端设备输出的功能。<br />
2、数据终端设备（DTE）：由数据输入设备（产生数据的数据源）、数据输出设备（接收数据的数据宿）和传输控制器组成。<br />
3、数据电路：由传输信道（传输线路）及其两端的数据电路终接设备（DCE）组成。传输信道可以是专用信道或交换信道，也可以是模拟信道或数字信道。</p></li>
<li><p>对于带有回路的互连局域网，网桥执行什么算法来消除回路<br />
生成树协议（SPT）</p></li>
<li><p>IEEE 802委员会规定的VLAN标准是什么<br />
IEEE 802.1Q<br />
标准以太网帧插入 4 字节的 VLAN 标记成为 802.1Q 帧</p></li>
<li><p>物理层的网络互连设备主要包括哪些<br />
集线器hub,相当于一个多端口的中继器。一个端口接收到数据信号后，hub将其整型放大，转发到其他所有工作端口，没有定向传送功能，是共享设备<br />
也就是无法划分冲突域</p></li>
<li><p>负责互联网有关协议开发的国际组织叫什么<br />
互联网协会 ISOC</p></li>
<li><p>在OSI参考模型中，负责提供可靠的端到端数据传输的是哪个层次<br />
传输层</p></li>
<li><p>IP数据报的总长度理论上最大为多少字节<br />
65535B，但无法超过以太网MTU</p></li>
<li><p>在一个不划分VLAN的局域网中，以太网帧的最小和最大长度是多少<br />
最小64B(包括FCS)，最大1518B</p></li>
<li><p>合法的域名<br />
最多四级，各级之间用<code>.</code>隔开，每级不超过 63 个字符,不区分大小写字母，必须唯一</p></li>
<li><p>TCP连接双方的数据传递过程 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client                                             Server</span><br><span class="line">   |                                                   |</span><br><span class="line">   | -----------------SYN------------&gt;                 |</span><br><span class="line">   |                                                   |</span><br><span class="line">   | &lt;----------------SYN+ACK-----------               |</span><br><span class="line">   |                                                   |</span><br><span class="line">   | -----------------ACK------------&gt;                 |</span><br><span class="line">   |                                                   |</span><br><span class="line">   | -----------------DATA------------&gt;                |</span><br><span class="line">   |                                                   |</span><br><span class="line">   | &lt;----------------ACK--------------                |</span><br><span class="line">   |                  ...                              |</span><br><span class="line">   |                Data Transfer                      |</span><br><span class="line">   |                  ...                              |</span><br><span class="line">   |                                                   |</span><br><span class="line">   | -----------------FIN------------&gt;                 |</span><br><span class="line">   |                                                   |</span><br><span class="line">   | &lt;----------------ACK--------------                |</span><br><span class="line">   |                                                   |</span><br><span class="line">   | &lt;----------------FIN--------------                |  </span><br><span class="line">   |                                                   |</span><br><span class="line">   | -----------------ACK------------&gt;                 |</span><br><span class="line">   |                                                   |</span><br></pre></td></tr></table></figure></p></li>
<li><p>一TCP连接发送4个TCP报文段，每个报文段中的数据字段皆为10个字节，第1个TCP报文段首部中的序列号为XXX。那么，接收端为表明其接收到第1、2两个报文段而返回的一个确认号是多少？<br />
XXX+2</p></li>
<li><p>IPv6地址的合法性<br />
使用冒号十六进制记法,16 位的值用十六进制值表示，各值之间用冒号分隔<br />
一串连续的零可以用一对冒号取代,但一个地址只能使用一次零压缩</p></li>
<li><p>每一个Web页面，包括主页都有一个唯一的地址，通常称该地址为<br />
统一资源定界符(url)</p></li>
<li><p>从FTP服务器下载文件，则对数据进行封装的五个转换步骤是什么<br />
数据，数据段，数据报，数据帧，比特</p></li>
<li><p>TCP/IP协议栈中，保证可靠通信的是哪一层<br />
传输层</p></li>
<li><p>计算机网络采用的数据交换方式是什么<br />
电路交换，分组交换，报文交换中的分组交换最常用</p></li>
<li><p>数据链路层的网络互连设备主要包括哪些<br />
网桥和交换机</p></li>
<li><p>TCP/IP协议栈提供了哪两个传输层协议<br />
TCP/UDP</p></li>
<li><p>在长距离数据传输时，更适合采用的导向性传输介质是什么<br />
光纤</p></li>
<li><p>网络协议三要素中，规定数据与控制信息的结构或格式的要素是什么<br />
语法<br />
其他两个为语义和时序</p></li>
<li><p>光纤通信中会用到单模和多模光纤，其中存在多条不同入射角度光线的光纤属于什么光纤<br />
多模光纤</p></li>
<li><p>在物理层，数据传输的基本单位<br />
bit</p></li>
<li><p>100M以太网的争用期的长度为多少μs<br />
51.2μs</p></li>
<li><p>对于术语10base-T，其中base表示传输介质上的信号是什么信号<br />
基带信号<br />
10 表示传输速率为 10 Mbps。<br />
base 表示采用基带信号传输。<br />
T 表示使用的传输介质是双绞线电缆。</p></li>
<li><p>IP数据报封装成帧的时候，其总长度不能超过数据链路层什么值的限制。 Maximum Transmission Unit，最大传输单元,指链路层帧的数据部分最大值</p></li>
<li><p>某个IP数据报首部MF标志为1时，则DF标志为多少。 只有当DF= 0时才允许分片,MF==1时必然有分配，因此DF必为0</p></li>
<li><p>在OSI参考模型中，网络节点中的最高层是什么。 应用层</p></li>
<li><p>TCP的流量控制和拥塞控制都是基于什么机制实现的。<br />
调整发送方发送窗口大小</p></li>
<li><p>在Internet中能够提供任意两台计算机之间传输文件的协议是什么。<br />
FTP协议</p></li>
<li><p>计算机网络采用分组交换的方式，其本质与什么方式是一致的。</p></li>
<li><p>划分VLAN之后，以太网最大帧长增加了多少个字节。<br />
4B</p></li>
<li><p>UDP的首部长度为多少字节。<br />
固定为8B</p></li>
<li><p>IP数据报中的TTL字段规定了一个数据报在被丢弃之前所允许经过的什么。 路由器数量</p></li>
<li><p>在数据链路层，数据传输的基本单位是什么。<br />
帧</p></li>
<li><p>TCP/IP把物理层和数据链路层合称为什么。<br />
网络接口层</p></li>
<li><p>网络中每个独立主机的每个网络接口，以及路由器的每个端口必须有一个唯一的互联网地址，也称什么。<br />
IP地址</p></li>
<li><p>CIDR地址块0.0.0.0/0，表示什么。<br />
默认路由,包含整个IPv4地址空间</p></li>
<li><p>DNS系统中，主机在本地域名服务器的查询一般采用什么方式。<br />
迭代查询</p></li>
<li><p>互联网完整域名总共不超过多少个字符。<br />
253</p></li>
<li><p>P2P<br />
peer to peer,允许互联网上的每一台主机既是客户端又是服务器,可以点对点直接通信</p></li>
<li><p>多路复用技术<br />
不同信号在同一条物理信道传输</p></li>
<li><p>Email系统<br />
pop3,smtp</p></li>
<li><p>ARP协议<br />
解析IP地址到MAC地址的协议,工作在网络层</p></li>
<li><p>端口<br />
用来标识应用程序或进程的一个逻辑通信接口。通过端口号标识来通信</p></li>
<li><p>TCP/IP协议栈<br />
TCP/UDP/IP/SMTP/FTP……</p></li>
<li><p>数据通信系统<br />
数字计算机与其他数字终端的通信，可以分为信源(数据源，发出后先通过变换器转换成适合信道传输的信号)，信道(逻辑部件，往往一条发送信道与接收信道组合)，信宿(传输终点，接受信道信号前需要反变换器转换成原始信息)三个部分</p></li>
<li><p>拥塞控制和流量控制<br />
阻塞：防止过多的数据注入网络，保证网络中的路由器或链路不致过载 流量：限制发送方的数据流量，使其发送速率不超过接收方的接收能力</p></li>
<li><p>RIP协议</p></li>
</ol>
<p>路由信息协议:</p>
<ol type="1">
<li>每个路由器都要维护从它自身到其他每个目的网络的距离，记为距离向量，规定从一个路由器到直接连接网络的距离(跳数)为1，每经过一个路由器，距离（跳数）加1</li>
<li>一条路径最多只能包含15跳，16时表示网络不可达</li>
<li>默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表</li>
</ol>
<hr />
<ol start="60" type="1">
<li><p>DNS系统<br />
将易于记忆的网址转化为IP地址,运行于53端口</p></li>
<li><p>面向连接服务与无连接服务各自的特点是什么？</p></li>
</ol>
<p>面向连接服务的特点:</p>
<ul>
<li>需要建立连接:在数据传输开始前,通信双方需要建立逻辑连接。</li>
<li>保证可靠传输:通过确认、重传等机制来保证数据传输的可靠性。</li>
<li>有序性:能够保证数据包按顺序到达接收端。</li>
<li>开销较大:建立和维护连接状态需要消耗更多的系统资源。</li>
<li>典型协议:TCP (Transmission Control Protocol)</li>
</ul>
<p>无连接服务的特点:</p>
<ul>
<li>无需建立连接:数据包可以独立发送而无需事先建立连接。</li>
<li>尽最大努力交付:不保证数据可靠传输,可能会丢失或乱序。</li>
<li>开销较小:无需建立和维护连接状态,处理效率更高。</li>
<li>适合实时性要求高的应用:如视频会议、在线游戏等。</li>
<li>典型协议: UDP (User Datagram Protocol)</li>
</ul>
<ol start="62" type="1">
<li>当前网络的体系结构结合OSI和TCP/IP两种体系结构将网络分为五层，论述一下各层的作用。</li>
</ol>
<ul>
<li>物理层：负责在物理信道上传输比特流，对上层屏蔽物理细节</li>
<li>数据链路层：将网络层传来的IP数据报组装成帧，提供点到点的传输服务</li>
<li>网络层：提供主机到主机的数据报传输，以及相应的路由选择，流量，阻塞控制等</li>
<li>传输层：提供端到端(主机上进程之间)的数据传输，分为无连接的udp(用户数据报)和有连接的tcp(报文段)两种</li>
<li>应用层：为用户提供直观的使用接口，屏蔽下层的细节</li>
</ul>
<ol start="63" type="1">
<li><p>用图示法简述TCP连接的拆除过程<br />
<img src="https://thinklive1.github.io/resources/Pasted%20image%2020240414114522.png" /></p></li>
<li><p>比较拥塞控制和流量控制的相同点与不同点<br />
相同点:</p></li>
</ol>
<ul>
<li>都是为了提高网络通信的效率和性能。</li>
<li>都涉及对数据发送速率的动态调整。</li>
<li>都需要接收端和发送端进行协调配合。</li>
</ul>
<p>不同点:</p>
<ul>
<li>目标不同:
<ul>
<li>拥塞控制主要目标是防止和缓解网络中的拥塞状况。</li>
<li>流量控制主要目标是防止接收端缓存溢出。</li>
</ul></li>
<li>作用范围不同:
<ul>
<li>拥塞控制是针对整个网络的全局性控制。</li>
<li>流量控制是针对单个接收端的局部性控制。</li>
</ul></li>
<li>实现方式不同:
<ul>
<li>拥塞控制通常基于丢包、延迟等网络状态信息作出反馈。</li>
<li>流量控制通常基于接收端的缓存使用情况作出反馈。</li>
</ul></li>
</ul>
<ol start="65" type="1">
<li><p>使用比特填充的起止标记法组帧时，帧边界是怎样的比特序列？若接收方从链路上收到的比特序列为：XXXXXXXXXX，给出去掉填充比特之后的原始比特序列。<br />
<code>01111110 (数据部分) 01111110</code><br />
数据的5个1后添加一个0</p></li>
<li><p>根据Wireshark捕获的数据包原始内容（从帧开始，不含前导码和定界符），试分析该数据包。<br />
<img src="/assets/resources/Pasted%20image%2020240518210354.png" alt="arp" /></p></li>
</ol>
<p>ARP数据报格式:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 9%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 14%" />
<col style="width: 13%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>6B</th>
<th>6B</th>
<th>2B</th>
<th>2B</th>
<th>2B</th>
<th>1B</th>
<th>1B</th>
<th>2B</th>
<th>6B</th>
<th>4B</th>
<th>6B</th>
<th>4B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目的mac地址(6B)</td>
<td>源mac地址(6B)</td>
<td>协议类型(0806)</td>
<td>硬件类型(以太网 0x0001)</td>
<td>协议类型(ipv4 0x0800)</td>
<td>硬件地址长度</td>
<td>协议地址长度</td>
<td>可选字段代码</td>
<td>源mac地址</td>
<td>源ip地址</td>
<td>目的mac地址</td>
<td>目的ip地址</td>
</tr>
</tbody>
</table>
<figure>
<img src="/assets/resources/Pasted%20image%2020240518210545.png" alt="" /><figcaption>tcp</figcaption>
</figure>
<p>以太网帧头部格式:</p>
<table>
<thead>
<tr class="header">
<th>6B</th>
<th>6B</th>
<th>2B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目的 MAC 地址</td>
<td>源 MAC 地址</td>
<td>协议类型</td>
</tr>
</tbody>
</table>
<p>IP 头部格式:</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 6%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 10%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>4 bits</th>
<th>4 bits</th>
<th>8 bits</th>
<th>16 bits</th>
<th>16 bits</th>
<th>3 bits</th>
<th>13 bits</th>
<th>8 bits</th>
<th>8 bits</th>
<th>16 bit</th>
<th>32 bits</th>
<th>32 bits</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>版本</td>
<td>头部长度</td>
<td>服务类型</td>
<td>总长度</td>
<td>标识</td>
<td>标志</td>
<td>片偏移</td>
<td>生存时间</td>
<td>协议</td>
<td>校验和</td>
<td>源 IP 地址</td>
<td>目的 IP 地址</td>
</tr>
</tbody>
</table>
<p>TCP 报文格式:</p>
<table>
<thead>
<tr class="header">
<th>14B</th>
<th>20B</th>
<th>2B</th>
<th>2B</th>
<th>4B</th>
<th>4B</th>
<th>4bit</th>
<th>6bit</th>
<th>6bit</th>
<th>2B</th>
<th>2B</th>
<th>2B</th>
<th>可变</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>以太网帧头部(14B)</td>
<td>IP 头部(20B)</td>
<td>源端口号</td>
<td>目的端口号</td>
<td>序列号</td>
<td>确认号</td>
<td>数据偏移</td>
<td>保留</td>
<td>标志位</td>
<td>窗口大小</td>
<td>TCP 校验和</td>
<td>紧急指针</td>
<td>数据部分</td>
</tr>
</tbody>
</table>
<figure>
<img src="/assets/resources/Pasted%20image%2020240518210650.png" alt="" /><figcaption>udp</figcaption>
</figure>
<p>UDP 用户数据报格式:</p>
<table>
<thead>
<tr class="header">
<th>14B</th>
<th>20B</th>
<th>2B</th>
<th>2B</th>
<th>2B</th>
<th>2B</th>
<th>可变</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>以太网帧头部(14B)</td>
<td>IP 头部(20B)</td>
<td>源端口号</td>
<td>目的端口号</td>
<td>UDP 长度</td>
<td>UDP 检验和</td>
<td>数据部分</td>
</tr>
</tbody>
</table>
<ol start="67" type="1">
<li>论述并对比IPv4到IPv6的两种过渡策略</li>
</ol>
<ul>
<li>双协议栈：设备同时支持两种协议
<ul>
<li>无需大规模更换设备和网络基础设施</li>
<li>适合 IPv4 和 IPv6 并存阶段的过渡需求</li>
<li>设备和网络开销较大,需同时支持两种协议栈</li>
</ul></li>
<li>隧道：在 IPv4 网络中封装 IPv6 数据包,通过 IPv4 网络进行传输
<ul>
<li>部署成本较低，无需大规模更换设备和网络基础设施</li>
<li>带来拆装的性能损失</li>
</ul></li>
</ul>
<ol start="68" type="1">
<li><p>TCP建立连接的过程称为三次握手，能否改成四次握手？ 会增加额外成本，因此不应该这么做，三次握手可以确认双方都有正常收发能力和连接意愿，增加一次握手没有必要</p></li>
<li><p>接收端接收到的PPP信息字段的十六进制数为：XXXXXXXX，试根据字节填充规则还原出发送的数据。</p></li>
</ol>
<p>PPP 使用字节填充的方式来标记帧的边界和转义特殊字符。具体规则如下:</p>
<ul>
<li>当数据中出现字节 0x7E(十进制 126)时,会在其前插入一个 0x7D(十进制 125)作为转义字符。</li>
<li>当数据中出现字节 0x7D(十进制 125)时,会在其前插入一个 0x7D 作为转义字符。</li>
<li>帧的开始和结束使用 0x7E 作为标记。</li>
<li>收到的十六进制数据为 XXXXXXXX。根据上述规则还原出原始的数据。
<ul>
<li>首先,去掉帧开始和结束的 0x7E。</li>
<li>然后,对于任何 0x7D 前的 0x7D 字节,删除前面的 0x7D 转义字符。</li>
<li>最后,得到的就是发送端原始发送的数据。</li>
</ul></li>
</ul>
<ol start="70" type="1">
<li>为了防止网络拥塞，TCP/IP协议采取了哪些措施？</li>
</ol>
<p>如以下所示：</p>
<ol type="1">
<li>拥塞控制(Congestion Control)：
<ol type="1">
<li>通过感知网络拥塞状况,动态调整发送速率,避免过多数据流入网络。</li>
<li>常用的拥塞控制算法包括慢开始、拥塞避免、快速重传和快速恢复等。</li>
</ol></li>
<li>流量控制(Flow Control)：
<ol type="1">
<li>接收端根据自身的缓存情况,反馈给发送端适当的发送窗口大小。</li>
<li>防止发送端向接收端发送过多数据,导致接收端缓存溢出。</li>
</ol></li>
<li>分片与重组(Fragmentation and Reassembly)：
<ol type="1">
<li>当数据包大小超过链路 MTU(最大传输单元)时,进行分片传输。</li>
</ol></li>
<li>确认与重传(ACK and Retransmission)：
<ol type="1">
<li>接收端对收到的数据包发送确认(ACK)。</li>
<li>发送端根据 ACK 信息判断是否需要重传丢失的数据包。</li>
</ol></li>
<li>优先级机制：
<ol type="1">
<li>对不同类型的数据流施加不同的优先级,优先处理重要性较高的数据。</li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>苏州大学</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo建立个人博客指北</title>
    <url>/thinklive/22586/</url>
    <content><![CDATA[<h1 id="概要">概要</h1>
<p>本文用于简要阐释我个人关于使用hexo建个人博客的经验，和解释hexo的各种自定义功能，也可以说是我个人的备忘录。网上很多教程都是直接告诉你怎么做，这在建站时很方便，但如果你要自定义就要知道hexo是怎么自定义的，本文可以帮你对此有一些了解<br />
<span id="more"></span> 在进入正文前，我需要补充一些其他东西</p>
<h2 id="hexo的原理">hexo的原理</h2>
<p>网站分为静态和动态，简单地说，静态网站就是写好了不会改变的页面，可以利用js实现一些小的动态效果，但不会有后台服务，动态网站就是用户发送请求，后台处理后更新网站给用户反馈，大部分商业网站都是此类。<br />
hexo搭建的博客属于典型的静态网站，因此很容易搭建和自定义。可以说，hexo就是根据你的设置和写作，用一定规则渲染出静态页面的一个工具</p>
<h2 id="如何网上访问你的页面">如何网上访问你的页面</h2>
<p>一般来说网站搭建在服务器上，但对静态页面来说，如Github之类的网站后提供免费的托管功能，只要你建一个github账号名.github.io的公共仓库，把静态页面放进去，就可以托管页面，用这个域名访问它(由于众所周知的原因，墙内有时候访问不太稳定)</p>
<h2 id="涉及的工具">涉及的工具</h2>
<h3 id="linux">linux</h3>
<p>我个人推荐你用linux虚拟机来做这件事，一是linux的包管理工具让装各种框架和插件很方便，二是linux的轻量级可以让你如果要切换生产环境，直接导出一个最多10gb左右的镜像拷贝走，就能换到另一台电脑，保留所有装好的环境,三是如果你是cs学生或者有编程需要,linux都是你几乎必学的系统。<br />
这个博客就搭在微软提供的wsl(windows上的linux子系统)上<br />
<a href="https://dowww.spencerwoo.com/">wsl的教程看这个</a> <a href="https://101.lug.ustc.edu.cn/">linux的教程看这个</a></p>
<h3 id="git">git</h3>
<p>git和linux是同一个作者，是当下最流行的版本控制工具，如果我们要用github托管页面，也需要用git来推送页面<br />
git也可以帮我们很方便地给你的博客做备份，推送到github的仓库，切换生产环境后把备份拉过来就能继续维护博客</p>
<h3 id="markdown">markdown</h3>
<p>markdown是一门轻量级标记性语言，很容易学习，被用于hexo渲染出html页面<br />
网上教程很多，比如<br />
<a href="https://www.zhihu.com/question/276209281/answer/3045412944">如何优雅地使用 Markdown？</a></p>
<h1 id="建站和自定义">建站和自定义</h1>
<h2 id="建站">建站</h2>
<p>假设你有了一个linux系统，并且掌握了一些基本操作，那么建站教程看这个<br />
<a href="https://zhuanlan.zhihu.com/p/552639819">【保姆级教程】含泪搭建hexo博客</a></p>
<h3 id="主题选择">主题选择</h3>
<p>hexo的大部分页面渲染工作由主题决定，直观地说，主题决定你的博客外观<br />
<a href="https://hexo.io/themes/">hexo主题列表</a><br />
我建议新手选择一些比较流行的主题，比如next,butterfly，一般这些主题自定义比较方便，文档易读并且出了问题网上有解决方案</p>
<h3 id="以next为例讲讲主题的自定义">以next为例讲讲主题的自定义</h3>
<p><a href="https://brian-zzz.github.io/2022/05/02/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/">next的简单设置这篇博客有教程</a><br />
<a href="https://theme-next.js.org/docs/getting-started/">next的官方文档</a><br />
hexo的大部分设置有两个yml文件控制，一个是根目录下的_config.yml，可以设置语言，作者名，网站名，网站链接等，还有一个是主题目录的_config.yml，设置主题自己的功能，next的评论，访问统计等等功能都在这里设置<br />
主题的目录一般是根目录/node_modules/hexo-theme-主题名/，但也有主题的配置文件放在根目录的命名成_config.主题名.yml<br />
关于部分主题功能的详解我会放在下文的主题使用说明</p>
<h2 id="hexo的工作流程">hexo的工作流程</h2>
<p>如果想进一步的自定义，就需要了解hexo的大致原理</p>
<h3 id="前端三件套">前端三件套</h3>
<ul>
<li>HTML（超文本标记语言）是一种用来描述网页内容的语言，它使用一系列的标签（tag）来定义网页中的元素，如标题，段落，图片，链接等。</li>
<li>CSS（层叠样式表）是一种用来控制网页外观的语言，它可以定义网页中元素的颜色，大小，位置，边框等属性。</li>
<li>JavaScript（简称JS）是一种用来实现网页交互的脚本语言，它可以在浏览器中运行，响应用户的操作，修改网页内容，发送和接收数据等。<br />
hexo目录内的public文件夹就放着最后生成的页面，其中，你看到的页面就是一个个html文件，样式和动态效果则引用js和css文件夹中的文件，hexo g生成和你在github托管的也就是这个文件夹下的文件</li>
</ul>
<h3 id="源文件">源文件</h3>
<p>那么是什么文件会被推送到public文件夹呢？</p>
<ol type="1">
<li>根目录下的source文件夹，有下划线<code>_</code>打头的文件夹一般有特殊性质，如根目录下的_data存放一些自定义样式文件，_post则存放具体文章，这些文件夹不会直接放进public，除此以外的文件夹都会被放进public，但如果文件可以被渲染的话，会经过解析然后储存到 <code>public</code> 文件夹，否则会直接拷贝到 <code>public</code> 文件夹。</li>
<li>主题目录下的source文件夹，一般来说这些文件夹用来放js,css和主题自定义的一些图片,同样，有下划线开头的不会被直接放进public，其他文件夹下会被放进去</li>
</ol>
<h4 id="如何跳过渲染">如何跳过渲染</h4>
<p>在根目录下设置skip_render，以下设置让source的webstack目录全部跳过渲染</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">- webstack/**</span><br></pre></td></tr></table></figure>
<h2 id="写作">写作</h2>
<h3 id="文章布局">文章布局</h3>
<p>hexo有三种文章布局，其中post是普通的博文，page是带文件夹的新页面，比如tags,categories，如果主题支持的话，你可以设置page被特别渲染成目录，标签之类的特色页面并放进菜单，draft是草稿，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，默认不会被显示在页面中<br />
你也可以禁用布局，根据 <code>_config.yml</code> 中 <a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>default_layout</code></a> 的设置，默认布局是 <code>post</code> 。当文章中的布局被禁用(<code>layout: false</code>)，它将不会使用主题处理。然而，它仍然会被任何可用的渲染引擎渲染：如果一篇文章是用 Markdown 写的，并且安装了 Markdown 渲染引擎（比如默认的 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>)，它将被渲染成HTML。</p>
<table>
<thead>
<tr class="header">
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>post</code></td>
<td><code>source/_posts</code></td>
</tr>
<tr class="even">
<td><code>page</code></td>
<td><code>source</code></td>
</tr>
<tr class="odd">
<td><code>draft</code></td>
<td><code>source/_drafts</code></td>
</tr>
</tbody>
</table>
<h3 id="文章标头">文章标头</h3>
<p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：<br />
hexo用文章标头来识别文章，因此你可以不用命令行创建文章，把有标头的md文件放进_post就能发布博文了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于斯坦福cs106b的c++数据结构笔记</span><br><span class="line">tags:</span><br><span class="line">- 课程笔记</span><br><span class="line">- c++</span><br><span class="line">categories: 课程笔记</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 58%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>layout</code></td>
<td>布局</td>
<td><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td>
</tr>
<tr class="even">
<td><code>title</code></td>
<td>标题</td>
<td>文章的文件名</td>
</tr>
<tr class="odd">
<td><code>date</code></td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr class="even">
<td><code>updated</code></td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr class="odd">
<td><code>comments</code></td>
<td>开启文章的评论功能</td>
<td><code>true</code></td>
</tr>
<tr class="even">
<td><code>tags</code></td>
<td>标签（不适用于分页）</td>
<td></td>
</tr>
<tr class="odd">
<td><code>categories</code></td>
<td>分类（不适用于分页）</td>
<td></td>
</tr>
<tr class="even">
<td><code>permalink</code></td>
<td>覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td>
<td><code>null</code></td>
</tr>
<tr class="odd">
<td><code>excerpt</code></td>
<td>纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td>
<td></td>
</tr>
<tr class="even">
<td><code>disableNunjucks</code></td>
<td>启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>/ <code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td>
<td>错误的</td>
</tr>
<tr class="odd">
<td><code>lang</code></td>
<td>设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td>
<td>继承自 <code>_config.yml</code></td>
</tr>
<tr class="even">
<td><code>published</code></td>
<td>文章是否发布</td>
<td>对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td>
</tr>
</tbody>
</table>
<h4 id="目录和标签">目录和标签</h4>
<p>只有文章支持分类和标签，可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。<br />
eg.如下的标头形成目录是（课程笔记/操作系统）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于恐龙书和苏大ppt的操作系统笔记</span><br><span class="line">tags:</span><br><span class="line">- 课程笔记</span><br><span class="line">- 操作系统</span><br><span class="line">categories:</span><br><span class="line">- 课程笔记</span><br><span class="line">- 操作系统</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>也可以并列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并列分类 </span><br><span class="line">类别：  </span><br><span class="line">- [Linux]  </span><br><span class="line">- [工具]</span><br><span class="line"></span><br><span class="line">并列+子分类</span><br><span class="line">类别：  </span><br><span class="line">- [Linux, Hexo]  </span><br><span class="line">- [工具，PHP]</span><br></pre></td></tr></table></figure>
<h3 id="文章缩略">文章缩略</h3>
<p>一般来说我们不会希望首页显示全文，而是开头的一小部分或者是摘要，摘要可以在标头加上取代缩略，而文章的缩略可以由主题决定，也可以用hexo自己的方式，比如next现在就不支持自动缩略，你只能自己在觉得差不多的地方加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<p>每个主题怎么决定缩略或者摘要基本也会在文档里写</p>
<h2 id="主题说明">主题说明</h2>
<p>既然大部分渲染由主题决定，那么自定义往往也会取决于主题，以下是我本人用过的主题的一些经验</p>
<h3 id="next">next</h3>
<p><code>next</code>是一款典型的黑白简约风主题，并且提供了丰富的自定义性，因此迪瑞克拉的主站就使用了自定义非常方便的next<br />
next的文档比较易读，全部看一遍就知道设置里那些选项怎么用了<br />
这里说说next的自定义<br />
next的渲染由主题文件夹下"layout"目录中的njk文件控制(一些老版本是swig)，你也可以使用next提供的自定义文件，去掉注释符号就可以去_data文件新建自定义文件来控制渲染<br />
比如说你想在所有页面加个js特效，就可以在主题文件夹下的layout/_layout.njk文件新增一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;/js/jsname.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下是next提供的自定义文件接口，可以对网站各个位置自定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  #postBodyStart: source/_data/post-body-start.njk</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>
<h3 id="webstack">webstack</h3>
<p>webstack主题基于github的一个开源项目，用来做一个导航页面，作为子站非常合适，自定义虽然没有next那么丰富，但作者慷慨地提供了一个随便插入html的head或者body的接口，可以使用html标签进行自定义，就在webstack的配置文件末尾<br />
怎么做子站看下文的多主题<br />
<a href="https://github.com/HCLonely/hexo-theme-webstack/blob/master/README_CN.md">使用方法看github主页的文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom:</span><br><span class="line">  head: |- # 以下内容插入到&lt;head&gt;&lt;/head&gt;标签内，可设置多行，注意每行开头至少四个空格</span><br><span class="line">    &lt;!-- 直接添加html内容即可 --&gt;</span><br><span class="line">    &lt;!-- 可设置多行 --&gt;</span><br><span class="line">  body: |- # 以下内容插入到&lt;/body&gt;标签之前，可设置多行，注意每行开头至少四个空格</span><br><span class="line">    &lt;!-- 直接添加html内容即可 --&gt;</span><br><span class="line">    &lt;!-- 可设置多行 --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="icarus">icarus</h3>
<p>伊卡洛斯也是个简约风的主题，特色是两列或者三列式的美观布局，但最让我中意的是它的赛博朋克风格，伊卡洛斯使用jsx定义渲染，因此自定义比较麻烦，可以自己导入js和css，但没有直接插入html标签的接口 <a href="https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/">使用文档</a> 文档没说那些七七八八的窗口怎么关，但我亲测你不想要的直接在配置文件里删掉就行了 <a href="https://blog.mchook.cn/2021/07/22/icarus%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89/">自定义js和css</a> 顺便一提对md的渲染基本都会会直接把正文中的html标签放进最后生成的html文件,所以直接在文章里放html标签基本也能用，如果你想要一个效果只在文章页面出现可以试试，迪瑞克拉神龛的骇入文字特效就是此类</p>
<h3 id="多主题">多主题</h3>
<p>理论上讲，既然主题只是决定了渲染的方法，你自己可以调用主题的各种样式渲染实现 一个主题下渲染出另一个主题效果的页面，但这样做很麻烦，那么有没有更容易实现多主题的方法呢？ 前文说了，source文件夹所有目录都会推送到public，我们可以利用这点把其他主题的网站推送到主站的source文件夹，然后在主站开一个菜单跳转到该子站对应目录的index实现子站用不同主题的功能 具体步骤如下</p>
<ol type="1">
<li>如之前的教程一样再建一个站，设置好想要的主题</li>
<li>根目录的设置这么改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: 主站目录/子站目录名</span><br><span class="line">index_generator:</span><br><span class="line"> path: &#x27;/子站目录名/&#x27;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>主站子站各自加一个跳转子站，返回主站的菜单 比如next这么改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resourcemap: /webstack/ || fa fa-sitemap</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>如果你会写脚本，就写个子站生成网站后自动推送的练练手，不会或者嫌麻烦就拿我的改改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">rm -rf /home/thinkliving/hexoblog/source/webstack/*</span><br><span class="line"></span><br><span class="line">cp -r /home/thinkliving/hexochild/public/* /home/thinkliving/hexoblog/source/webstack/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="其他自定义">其他自定义</h2>
<h3 id="图标">图标</h3>
<p>大部分hexo主题使用fontawesome的图标，类似这种格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fas fa-tools//s指solid图标</span><br></pre></td></tr></table></figure>
<p>想自定义可以在css文件里定义图标再使用，比如next中是这样在styl里定义,不过不是所有主题都提供自定义css</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.thanks &#123;</span><br><span class="line">  background-image: url(&#x27;/images/thanks.svg&#x27;);</span><br><span class="line">  background-size: 1em 1em;</span><br><span class="line">  background-position: 0.05rem 0.2rem;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  height: 1rem;</span><br><span class="line">  width: 1rem; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thanks: /thanks/ || fa custom thanks</span><br></pre></td></tr></table></figure>
<h3 id="hexo-s时自动刷新">hexo s时自动刷新</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g browser-sync</span><br><span class="line">npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure>
<h3 id="加密博客">加密博客</h3>
<p><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">[hexo-blog-encrypt](https://github.com/D0n9X1n/hexo-blog-encrypt/tree/master)</a></p>
<h3 id="js动效">js动效</h3>
<p><a href="https://blog.csdn.net/qq_44036990/article/details/104932173">鼠标移动特效</a> 这种js小特效很多，好奇的话自己去探索吧</p>
<h3 id="黑夜模式">黑夜模式</h3>
<p>想在半夜刷博客，又被白色背景闪瞎眼？听起来你需要一个可以切换的黑夜模式<br />
如何实现呢？你可能听说过darkmode.js等一键切换时的黑夜模式，这些脚本的原理似乎是给网站盖一层样式来覆盖原有内容，但用在hexo next上呢？你会发现很多地方覆盖不到，或者背景直接来了个吓人的反色<br />
省去废话，最简单的方法就是css+js直接更改网站的样式，在hexo next里可以用以下基本轻松且轻量的实现(说的很好听，但缺点是能用的补集)</p>
<ol type="1">
<li>在next的设置文件里把style.styl , body-end.njk等配置文件开启，如果你没有建过的话，在source文件夹下的_data文件夹建立这些文件</li>
<li>覆盖部分css样式，在styles.styl加入：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attr">--note-warning-bg-color</span>: <span class="number">#fdf8ea</span></span><br><span class="line">    --note-info-bg-color: <span class="number">#eef7fa</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-class">.note</span><span class="selector-class">.warning</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--note-warning-bg-color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-class">.note</span><span class="selector-class">.info</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--note-info-bg-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>在body-end.njk加入以下代码，但需要注意<code>isLightMode</code>对这个变量的判断需要改成你自己网站的'--content-bg-color'的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toggleMode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;change!&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> root1 = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前 color-scheme</span></span><br><span class="line">    <span class="keyword">const</span> isLightMode = <span class="title function_">getComputedStyle</span>(root1).<span class="title function_">getPropertyValue</span>(<span class="string">&#x27;--content-bg-color&#x27;</span>).<span class="title function_">trim</span>() === <span class="string">&#x27;#fff&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLightMode) &#123;</span><br><span class="line">        <span class="comment">// 切换到暗模式</span></span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--content-bg-color&#x27;</span>, <span class="string">&#x27;#000&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--text-color&#x27;</span>, <span class="string">&#x27;#fff&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--highlight-background&#x27;</span>, <span class="string">&#x27;#444&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--highlight-foreground&#x27;</span>, <span class="string">&#x27;#bbb&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--btn-default-bg&#x27;</span>, <span class="string">&#x27;#777&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--menu-item-bg-color&#x27;</span>, <span class="string">&#x27;#777&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--note-warning-bg-color&#x27;</span>, <span class="string">&#x27;#777&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--note-info-bg-color&#x27;</span>, <span class="string">&#x27;#777&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;all 0.5s ease&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--content-bg-color&#x27;</span>, <span class="string">&#x27;#fff&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--text-color&#x27;</span>, <span class="string">&#x27;#111&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--highlight-background&#x27;</span>, <span class="string">&#x27;#eaeef3&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--highlight-foreground&#x27;</span>, <span class="string">&#x27;#00193a&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--btn-default-bg&#x27;</span>, <span class="string">&#x27;#fff&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--menu-item-bg-color&#x27;</span>, <span class="string">&#x27;#f5f5f5&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--note-warning-bg-color&#x27;</span>, <span class="string">&#x27;#fdf8ea&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--note-info-bg-color&#x27;</span>, <span class="string">&#x27;#eef7fa&#x27;</span>);</span><br><span class="line">        root1.<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;all 0.5s ease&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&quot;background: #868686;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  width: 3rem;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  height: 3rem;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  position: fixed;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  border-radius: 50%;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  border: none;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  right: unset;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  bottom: 2rem;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  left: 2rem;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  cursor: pointer;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  transition: all 0.5s ease;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  display: flex;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  justify-content: center;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">  align-items: center;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;darkmode-toggle&quot;</span> <span class="attr">role</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;toggleMode()&quot;</span>&gt;</span>🌓<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>enjoy</li>
</ol>
]]></content>
      <categories>
        <category>建站经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>webstack</tag>
        <tag>icarus</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls人物解析</title>
    <url>/thinklive/30989/</url>
    <content><![CDATA[<h1 id="尸龙贾巴沃克">尸龙贾巴沃克</h1>
<blockquote>
<p><strong><em>在天之繁星哟！命数已定之众哟！尽管去为爱所煎熬吧，为嫉妒之苦吧！呜呼！感激涕零吧！为这幸灾乐祸暗黑舞台点缀色彩就好！！！</em></strong></p>
</blockquote>
<p>象征着腐败与神秘的紫黑色，遍布全身的缝合痕迹与绷带，恶魔一样的卷曲角，晦暗如死尸的肤色，以及左眼燃烧着的灵魂之火（致敬黑岩射手可能性微存），<code>尸龙</code>姐姐的人物形象无时无刻不在传达着神秘强大而阴暗的气氛，本视频将对<code>尸龙</code>的整个人物进行解析<br />
<span id="more"></span><br />
<code>尸龙</code>在爱丽丝镜中奇遇的原型是一首小诗，这首诗的大意是勇者手提沃伯尔之剑斩杀邪龙<code>贾巴沃克</code>，游戏中也承袭了这一设定，<code>贾巴沃克</code>一直都以死尸的形象登场<br />
要解析这一角色，我们首先从最直接的行为说起，按游戏的时间线，<code>尸龙</code>姐姐大概做了以下这些事<br />
1把童话（具体哪本未知，根据混沌迷宫的狼外婆信息推测可能是小红帽）给了渴望母爱的玛丽.苏，从而激发了虫虫的创作能力，导致她创造出一代的箱庭。顺便一提，关于<code>尸龙</code>和<code>玛丽苏</code>的关系，游戏里没有直接证据支持姐妹说，混沌迷宫提到黑山羊有两个子嗣，米兰达认为<code>尸龙</code>有黑山羊的气息，且明显<code>尸龙</code>和<code>玛丽苏</code>有一定关系，这些是确定的，但并未明说姐妹，有人从克苏鲁的设定中寻找论据，但本人对克系了解不多在此不评价。<br />
2红偶像约会中电影《三人的茶会》提及茶会时期的三人曾经打倒过贾巴沃奇，不知是否和<code>尸龙</code>有关，此外<code>尸龙</code>也曾被昔日的勇者，如今的猎头兔打倒，自称在之后洗心革面，但相关资料太少，我们不知道是不是她放水或另有隐情<br />
3格林被引导进<code>玛丽苏</code>的箱庭开始一代的故事，此时<code>尸龙</code>（不知道<code>玛丽苏</code>是否知情）已经乱入到一代的不思议之国，为格林一行人提供帮助，通关d结局后找她对话，她会直接把二代给剧透了，不过由于时间线上d结局应该直接接上二代，所以“正史”上可能没有这件事，顺便一提，一代的不思议之国是爱丽丝的箱庭，或者说<code>玛丽苏</code>的仿造品，也没有定论，所以很难推测<code>尸龙</code>是入侵还是本来就在那里<br />
4来到二代时间线，由于不思议之国是奈亚的箱庭，而黑山羊则是奈亚的“配偶”，所以<code>尸龙</code>出现在这倒是理所应当，此时的<code>尸龙</code>以四噩梦之一的身份登场，，但工作内容则是在卡罗尔川上堆雪人，以及在格林面前装出温柔大姐姐的形象，十足的关系户做派。<br />
里路线中，格林和米兰达等人可以先后对战三噩梦，以及杀死其余两个噩梦后现出真身的<code>尸龙</code>，值得一提的是这似乎是她全系列中唯一一次全力出手，并且在此战中死亡，但考虑到支配者的特性，是否死透了依旧存疑<br />
以上就是<code>尸龙</code>在系列中的行动，接下来我将对这些行动的目的与<code>尸龙</code>的性格进行归纳。<br />
<code>尸龙</code>首先是一个安静的观察者，一代中她只是在一棵树下扮尸体，二代则在河边堆雪人，如果格林不找她，在里线之前不会和她有任何交集，然而，隐藏和善表面下的真相是<code>尸龙</code>其实是个性格扭曲唯恐天下不乱的乐子人，是她启发了<code>玛丽苏</code>创造自己的黑童话箱庭，间接引发之后所有的故事，而一开始的目的可能只是以<code>玛丽苏</code>面对求而不得的母爱痛苦挣扎的样子为乐，也是她诅咒了狩猎邪龙的英雄，使兔子一族成为贪食尸体的魔兽，其中被沃波尔斩下头颅可能是她行事风格的分界线，其自述死前曾是无恶不作的邪龙，在复活后变得收敛，但其实依旧不改邪龙本质，只是变得只在关键时刻推波助澜<br />
而将这两种性格统一起来的则是她的创作欲，没错，和<code>玛丽苏</code>一样，<code>尸龙</code>对创作也有自己的执念，在<code>玛丽苏</code>涌现起黑暗的创作力之后，<code>尸龙</code>意识到，<code>玛丽苏</code>那邪恶的灵魂一定程度其实是自己的作品，如果说<code>玛丽苏</code>是支配者中第一个创造故事的人，<code>尸龙</code>就是第一个“创作者”，这激发出她内心最深层的欲望，那就是创作出足够黑暗污秽的灵魂，方法则是让一个灵魂在无尽的痛苦与求而不得中循环。<br />
可以说在这点上<code>尸龙</code>和奈亚有一定的共同点，就是让格林经历无数次的痛苦循环，但二者还是有着分歧，奈亚想要的是格林求而不得的爱，<code>尸龙</code>则想要格林本就污秽的灵魂更加黑暗。<br />
这时我们就可以理解<code>尸龙</code>的行为了，由于里线实际上也处于轮回之中，所以对<code>尸龙</code>来说，告诉格林一些真相只会让他的反抗更加激烈，也会在反抗之后更加绝望，这样才符合她的目的。<br />
而以上依旧是<code>贾巴沃克</code>的表层性格，而她隐藏最深的性格则是扭曲的独占欲，在卡罗尔川的地牢中有个四个雪人，分别是<code>玛丽苏</code>，小红帽，爱丽丝和格林，此外，班达斯奈奇的住处也有着一个写着想将其变为收藏品的雪人（sen0才能看到真相），可见<code>尸龙</code>内心最深的欲望其实是独占欲，培育最污秽的灵魂，随后将其收藏起来，这才是<code>尸龙</code>的愿景，但她为何要隐藏这一欲望呢，在qf<code>尸龙</code>失败的逆监禁剧情里，由于<code>尸龙</code>发现格林的灵魂已经黑暗到想要独占自己，<code>尸龙</code>就会唯一一次直接暴露自己的独占欲来收割这个丰硕的成果，然而，奈亚或者其他支配者绝不会容忍这种行为，所以一旦<code>尸龙</code>试图独占格林就会立刻被排除出世界，这就是<code>尸龙</code>一直压抑着独占欲的原因。<br />
此外，根据dlc3入口处的对话以及数量庞大的雪人，或许可以猜测<code>尸龙</code>曾经一边观察一边玩弄过很多灵魂，但这些灵魂最后都因为经历过多的痛苦和绝望后变得麻木，因此才会对有着无穷成长性的格林视若珍宝<br />
一切温柔的言语都不过是为了将格林引导向更绝望的结局，独占污秽的黑之魂，玩到腻后就扔掉，对<code>贾巴沃克</code>之魂的描述为包藏在虚伪的母性之下的独占欲之影可谓恰如其分。<br />
值得一提的是，独占欲这种感情不止在<code>尸龙</code>一人上出现，大部分支配者都有着这种感情，如白之女王诺登就承认自己多次有独占格林的想法，爱丽丝01也曾吐露自己害怕不可控制地想要独占格林，但她们与<code>尸龙</code>的区别则是，她们能够理解人类的爱，并为了人类的幸福选择放手，与红白女王的对比或许也是<code>尸龙</code>人物形象设计的一个目的<br />
现在可以做一个总结了，<code>尸龙</code>姐姐是一个对格林有着强烈爱意的角色，她的母性是虚伪的，但这种爱意却不是，尽管她扭曲，残酷，自私，虚伪，但是她始终知道自己要做什么并理性地付出行动，即使失败了也不失风度从容自若，相较于虫虫几乎写在脸上的扭曲性格，直截了当的作恶行径，以及一有挫败就大呼小叫的行径，<code>尸龙</code>的感情更加内敛，行事也更加隐秘，但可谓是个很有恶人魅力的反派角色<br />
同时，由于bs的碎片化叙事并且尚未完结，关于<code>尸龙</code>依旧有很多谜团，例如她和<code>玛丽苏</code>以及其他支配者的具体关系，里线中她是不是仍然在演戏，她究竟为何会给<code>玛丽苏</code>童话书，<code>尸龙</code>等三噩梦和三个爱丽丝的关系等等，就期待续作的解答了<br />
大家都来和<code>尸龙</code>姐姐做朋友吧，尸门</p>
<h1 id="玛丽苏">玛丽苏</h1>
<p><code>玛丽苏</code>，作为bs中自称的女主角，是bs唯二个三代都有出场（包括红森）的支配者，还有一个是<code>贾巴沃克</code>），在此过程中做过的好事可谓数不胜数，罄竹难书，我们来按着时间线整理一下<br />
1一开始的<code>玛丽苏</code>是个渴望母爱的孩子，尽管我们不知道bs设定下一开始的支配者到底会不会有类似人类的亲情，她掌管自己的世界，倾听子民的祈祷，开始感到厌烦，这时<code>贾巴沃克</code>不知出于什么目的，送了她一本童话书，这本书，我们不知道是哪个童话，但本人猜测很可能这本书的作者是<code>玛丽苏</code>第一个抓住的，并在黑之魂的融合中有重要地位，根据青鸟的文本，卡罗尔并不是第一个抓住的素材，所以基本可以排除梦游仙境，结合男主角格林的名字和混沌迷宫的狼外婆，我个人猜测是小红帽，她开始渴望创作自己的故事来打动母亲，至少一开始是这样，她派遣属下四处收集童话作者的灵魂作为素材，同时肆意进行同人创作。<br />
2<code>玛丽苏</code>的处女作是小红帽，也是她第二得意的作品，根据一些信息，小红帽的灵魂可能以现实世界的一个女学生为素材，在魔改剧情的同时，她还给了小红帽注定20岁早逝的设定，并可能赋予了小红帽通过镜子穿梭位面之类的特殊能力来担任女主角，但不知道为什么她又不满意，想做一个男主角出来，但她对小红帽的善后却颇有些问题，小红帽不仅杀穿了红森，而且还能意识到她这个黑幕的存在。<br />
3缝合了众多童话作家灵魂的格林诞生了，并被赋予了给周围的女主角带来不幸的设定，格林污秽的黑之魂有成为支配者的潜质，<code>玛丽苏</code>甚至还大胆地保留了他的部分创作能力，因为最关键的改变权能在她手上，为什么叫做格林则未知，可能是最初的童话书就是格林童话的一本，这之后格林不知道为什么，以什么身份在一个叫不思议之国的地方和叫爱丽丝和祈祷主的存在开起了茶会，随后格林与爱丽丝01相恋，嫉妒的祈祷主呼唤了<code>玛丽苏</code>，导致格林被带走了，连同格林不知何时创造出的故事们也被篡改<br />
4基于以上提到的各种童话故事素材，<code>玛丽苏</code>魔改出了失落帝国的箱庭，把格林放进去经历一次次绝望故事的轮回，自己则担任女主角欣赏故事，还设计把母亲叫了进来欣赏自己的大作。不知多少次循环后，这个大好局面被打破了，母亲黑山羊为了逃离这个世界和她战斗，连圣森都磨灭了，战胜母亲后，奈亚丽丝前来捡漏带走格林进行新一轮追寻爱的游戏，本来想顺带着把<code>玛丽苏</code>也灭了，但在诺登的劝阻以及可能的其他考量下放过了她<br />
5奈亚，红女王，白女王中的某位或若干位剥夺了她的改变权能，把她囚禁在库因兰德，失去权能的她改名为玛丽安，但不知何时也不知何人前来探访了她，到格林试图从梦中醒来的里线，玛丽安乘乱逃出，由于正史上不太可能发生f结局，所以此时应该是g结局，也有可能正史上g结局有少许与游戏不同，不管怎么说此时的玛丽安应该被格林小红帽两人打败，但h结局中可以看到她没有死，而且不知道怎么逃了出来<br />
可以说，bs中的一切悲剧，<code>玛丽苏</code>至少有五成功劳，接下来让我们来分析一下<code>玛丽苏</code>的角色特质。<br />
首先，最直接的一点，<code>玛丽苏</code>是个典型的支配者，高高在上地支配着人类这样的低等种族，但<code>玛丽苏</code>特殊之处在于，她可能是最能理解人类感情的支配者之一，首先我们就可以看到她居然渴望所谓的母爱，而根据2代大部分支配者的表现，即使因融入皮套逐渐有了感情，也没有第二个有亲情这种非常类似人类感情的支配者，此外，她还以玩弄人类的灵魂为乐，当然有这种兴趣的支配者恐怕不少，但这股风气可以说是<code>玛丽苏</code>带起来的，也是她最先玩出各种花样。<br />
因此可以引出<code>玛丽苏</code>的第二个特点了，她是很像人类的一个支配者，尽管理解非常片面，但她确实懂得并拥有不少人性，而她为什么这么喜欢玩弄人类呢？这也很容易理解，一般来说越通人性的动物越被人类亲近，逗猫逗狗远远比逗蚂蚁有意思，因为这些宠物的智力和人类更接近，人类可以很容易地理解它们在想什么，然后在逗弄它们的过程中获得一种智力上的优越感，以及一种“支配感”，这恐怕就是<code>玛丽苏</code>看到自己编排的好戏上演的感觉。<br />
这点可以说是我们对<code>玛丽苏</code>进行解析的基石，毕竟任何角色首先都是人的投影，而人性越丰富，就有越多的性格侧面。<br />
<code>玛丽苏</code>第三个特点就是由此衍生的纯粹性，当然，此处并不是说纯洁善良云云，而是某种意义上的纯粹之恶，很多支配者在扮演人类后都会被皮套影响而恐慌或纠结，但<code>玛丽苏</code>却没有这种烦恼，她以融入人类扮演人类为乐（小精灵也算类人种族），她作为支配者的漆黑本性和人性之恶完美地兼容了，不会有徘徊二者之间的身份认同问题，而她大部分所作所为也就是为了践行人性之恶，什么是恶呢，比较狭隘的解释就是为了为了自己的利益或者取乐而伤害他人，而<code>玛丽苏</code>的邪恶就很纯粹，就是为了取乐，甚至有损自己利益也要作恶，如果解救了被囚禁的<code>玛丽苏</code>，此时她会自认为东山再起，但她想的不是第一时间抹杀已经成长了的格林或者藏起来，而是想再让格林经历一次悲惨的故事，可以说她作恶的动机相当纯粹，也相当执着。<br />
在此之上的第四个特点，就是她的创作者身份，很多支配者都会赞扬她的创作能力，连奈亚构建的不思议之国都有不少<code>玛丽苏</code>箱庭的影子，但这种创造力也只是对于支配者来说了，如果我们用人类的视角看如何呢？寿司在访谈时轻蔑地说到“她说到底也只是<code>玛丽苏</code>，也只能整点二次创作了”可以说道出了<code>玛丽苏</code>所谓创作的本质，说到底，<code>玛丽苏</code>就是那种典型的黑深残小鬼，把一个可能有很多种解释的作品曲解为单一的猎奇世界观，当然不是说这样不行，如果原创一个黑深残世界观自娱自乐当然是可以接受的，但<code>玛丽苏</code>的行为就是最恶劣的一种同人女行为，魔改原来的作品，把自己做成角色代入进去搞cp，还要把所有其他角色踩一遍，情节和人物关系只要对自己代入的角色有利就行，然后把这部除了自己看谁也不会喜欢的同人拿给原作者看，我就不详细说这种行为的恶劣程度了，但这种作品折射出来的创作观我必须要辩驳一下。<br />
当然，本视频所有讨论只局限于二次元文化内，<br />
荒木飞吕彦认为漫画有四要素，角色、剧情、世界观、主题，我们就用这四个维度来剖析<code>玛丽苏</code>的所谓创作。<br />
首先是角色，直接创作一个鲜活的灵魂对强大的支配者来说也是一件难事，所以对于角色的选取，<code>玛丽苏</code>很可能都是使用现实存在的灵魂然后再魔改来适配进童话或者传说的人物，因此她笔下所谓角色虽然很多但其实并不是她自己的功劳，而她为了把这些灵魂塞进角色对设定随意删改，把小红帽的外婆和母亲缝成了一笔烂账，人物关系更是一团乱麻，怎么方便怎么来，角色设定连基本的自洽也做不到，水平着实不敢恭维<br />
随后是世界观，失落帝国这个箱庭本质上来说就是个童话故事的缝合体，没有历史演化，没有详细设定，这并不是一个鲜活的世界观，只不过是一个临时搭建的舞台而已，当然，很多线性的故事并不需要一个多详尽的世界观，在这点上<code>玛丽苏</code>只能说无功无过<br />
最后是剧情和主题，<code>玛丽苏</code>的主题是简单粗暴的黑深残，剧情则是当常规的rpg剧本演到最后的happy end时毫无铺垫伏笔地急转直下变成bad end，当然，能设置这么大规模的箱庭，还写了不少支线剧情，证明<code>玛丽苏</code>确实是有一些笔力的，但首先，她的角色基本靠抓人，故事则都有童话原型，故事演变她只需要把握大方向，其他可以让角色自己来，而最后没有任何铺垫的bad end依旧表明了她创作的失败，如果一个设定没有任何铺垫和暗示，直到使用时才抛出，那只能证明这部作品情节编排的失败，因为一部作品的生命周期不是作者创作出来就结束了的，而要等到读者看完理解了故事才会结束，这个过程作者读者应该处于相对公平的地位，根据故事的设定，人物有充分的理由这样行动，这样才能让读者认同这个故事，而<code>玛丽苏</code>却完全相反，滥用作者的权能让故事不仅没有逻辑，还自相矛盾，很明显，对<code>玛丽苏</code>来说她是作者也自认为是唯一的读者，那些被抓走被改造的灵魂不过是用完即扔的工具罢了，不需要自圆其说，只要自己看得高兴就行了，或许就支配者的立场来说她不过是自娱自乐罢了，但对人类（至少灵魂上是人类），以及同样作为创作者的格林来说，首先就绝不可能认同这种恶行，更不可能认同自己的作品被改成这样的烂作<br />
说到这里，就可以讨论一下<code>玛丽苏</code>对于格林的看法了，直观地说，是<code>玛丽苏</code>创造了名为格林的污秽黑之魂，但其实在最初，是格林等童话作家激发了<code>玛丽苏</code>的创作欲，因此，事实上，两者是相互创造的关系，<code>玛丽苏</code>创造格林的目的，首先是为了成为她作品的男主角，让她能够代入女主角的位置欣赏这个故事，这样说来似乎格林除了男主角的身份和其他角色也没什么本质的不同。但格林还有一点对<code>玛丽苏</code>有着重大意义，就是他童话作家灵魂集合体的身份，即使自我中心如<code>玛丽苏</code>这种存在，也会有对别人欣赏自己作品的渴望，因此<code>玛丽苏</code>特地设置了一个c结局，用演戏的形式让格林得以了解她的整个创作生涯，至于目的，除了单纯的表现欲和欣赏格林的痛苦以外，恐怕也有一丝希望作为原作者的格林认同自己的心情，哪怕是厌恶，<code>玛丽苏</code>也想得到一些对创作的反馈，而格林是唯一能在创作这个领域和她有一些共鸣的人，作者，读者，男主角，格林三位一体的身份对<code>玛丽苏</code>来说，可以说是难得的知己，尽管这种关系非常扭曲，但不能否认，在这点上<code>玛丽苏</code>作为创作者的心情是有些真心的。而<code>玛丽苏</code>会渴望认同这点，一开始是希望得到母爱，但在得到格林这个玩具之后，<code>玛丽苏</code>就一点也不在意黑山羊的死活了，这也是佐证。<br />
最后不得不提的是，<code>玛丽苏</code>的特殊性质，很大程度上她是寿司这个作者的投影，我个人觉得<code>玛丽苏</code>这个角色有不少表达寿司自己创作观的成分，这也解释了寿司为何这么偏爱她当然，一部好的作品，任何角色都是基于自己的设定和世界观行动，不可能因为是作者的投影就有特别待遇，所以可以说，<code>玛丽苏</code>虽然很大程度上是寿司的投影，但投影的目的其实是对比，<code>玛丽苏</code>的创作肤浅，笔下的故事只是无聊的黑深残，但寿司却喜欢在绝望时写一些希望，在希望中铺设绝望，最后的反转再怎么说都是有因可循，单论创作的层次来说就高出绿虫子太多了，当然，我也不是在吹寿司笔力多高，因为高出<code>玛丽苏</code>这个水平的创作者多如牛毛。<br />
寿司设置<code>玛丽苏</code>这个角色，其实是使用了一种嵌套的结构来讲故事，首层是童话的原作，这些是毋庸置疑的好故事，随后是虫子和奈亚魔改出的箱庭，是烂故事的典型，最后一层寿司想讲的重点其实是格林怎么察觉真相，挣脱出烂故事的循环，书写自己的结局的故事，在这三层中，第一层<code>玛丽苏</code>是读者，格林等人是作者，只出现在设定层面，第二层<code>玛丽苏</code>是一半作者一半角色，格林是一半读者一半角色，体现在abc结局，最后一层中寿司是唯一的作者，<code>玛丽苏</code>和格林就都是角色了，体现在d结局以及之后的二代，这种层层演变虽然有些炫技，但确实非常有意思。<br />
就<code>玛丽苏</code>这个角色而言，整个泛二次元文化里她这样的反派也不常见，究其原因，则是因为一个有能力玩弄主角取乐的boss必然会导致战力失衡，冲突不起来，让读者感到憋屈，因此想要打败这种boss要么机械降神唯心爆发，比如一代c结局（虽然是演的），要么引入新的boss和同伴体系取代她如d结局，也因此，虽然我个人很喜欢一代，但一代的真结局d结局远没有2代h结局震撼<br />
来做个总结吧，<code>玛丽苏</code>无疑是个纯粹邪恶的支配者，一个烂到骨子里的创作者，她作为创作者无疑是失败的，但作为bs这个故事里的角色反而是很成功的，不仅纯粹有特点，还有很多角色侧面可以挖掘，寿司巧妙地利用她读者，创作者和角色的三重身份来塑造她的多面性，颇有荒木在漫画术中写的“在作恶道路上高歌猛进”的成功反派角色风格。</p>
<h1 id="题外话">题外话</h1>
<p>人与人之间的信任是很脆弱的呢，例如我，一般来说就不会给未完结的作品写评论，会不会下一部就开始情节崩坏呢，而理论上永不完结的网游，对我来说更是洪水猛兽，避之不及<br />
这样的我要破例的情况还真是寥寥无几，不过最近的话，大概只有寿司得到了我的信任，我相信贾巴沃克的任务已经阶段性完成了，如果bs3出场的她不会和12里被打倒的贾巴沃克是同样的人，所以写了尸龙的人物解析，同理我也相信玛丽安不会再次变成之前的玛丽苏或者莉耶芙，新的玛丽安也不会和之前设定冲突，所以对莉耶芙和玛丽苏也做了总结<br />
当然格林小红帽之类的角色，他们的故事完全没有结束，h结局与其说阶段性的结束不如说是新阶段开始，因此完全无法做总结<br />
这样一来，也就是说如果bs3成了烂作，我就会被打脸，也会被这种信任伤害，这是多么危险的事，但我依旧选择了相信，我对bs就是有这种程度的爱❤️啊<br />
当然，我也不是真被爱冲昏头脑，美末2恶评，但一代还是有很多爱好者，这就是所谓的切割，除了部分例外，单机游戏都是离散发布的，所以续作很烂就不承认好了……<br />
总之，所谓的爱啊，信任这些东西，本质上讲都是赌博，上赌桌前总得意识到这点……</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉世界观设定集</title>
    <url>/thinklive/3998/</url>
    <content><![CDATA[<blockquote>
<p>起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生……</p>
</blockquote>
<p>这是邪神辛克莱温教徒传颂的创世神话，也是目前为止我们所知最早的创世神话，可以说后世诸多关于创世的传说都有它的影子。 <span id="more"></span></p>
<p>邪神辛克莱温的信徒有着自己的语言，这种符号文字晦涩难懂，虽然给传播教义造成了困难，却成为维系着邪神教绵延几千年信仰的纽带。<br />
邪神辛克莱温是……</p>
<p>——选自帝国学者载丝莉《邪神起源探究》</p>
<h2 id="克雷多斯族">克雷多斯族</h2>
<blockquote>
<p>平庸是进化论所给我们最后的仁慈——帝国医学教科书扉页</p>
</blockquote>
<p>奥诺斯是社会达尔文主义者的神，他的教义就是物竞天择，适者生存，让优秀的种族淘汰低劣的种族。放到现在他肯定会被当做邪神。奥诺斯创造过很多种族，大部分在穷兵黩武中走向了灭亡，然而其中有一个民族最为他所垂青——克雷多斯族。这一种族刚出现时平平无奇，但他们的眼中只有强者，尊严的力量促使着他们不断发挥着潜力，追逐着比自己强大无数倍的敌人。他们逐渐走向强盛，但后来因为自相残杀导致族人寥寥无几。这时，一位天才创造出了一种把他们一分为二的方法，以此来把自己当做对手，起初，克雷多斯族凭借这一方法几乎成为世界上最令人恐惧的种族，深深地让奥诺斯感到自豪。然而，在与自己的斗争中，有的族人学会了“阴谋”，将另一个自己与其他敌人算计致死，有的人学会了“隐忍”，进而学会了妥协与认输，最终，他们都选择了“平庸”。为了心爱的子民惋惜不止的奥诺斯神来到了最后一个保持着绝对尊严的战士面前：</p>
<p>“我也给予你选择平庸的权利。”</p>
<p>“你要我变得和他们一样吗?绝不！！！”</p>
<p>战士怒吼着冲向了最后一个对手。从此，奥诺斯和他的战士消失于迪瑞克拉世界。</p>
<h2 id="沉默峡谷">沉默峡谷</h2>
<p>沉默不是逃避，而是一种选择——沉默沼泽路牌上的涂鸦</p>
<p>沉默峡谷被命名并正式标在官方地图上是帝国历387年的事了，在此之前它只是个普通的荒凉之处而已，当然，还是偶尔进入的旅客发现这里——但他们有的没能走出来，有的在出来后被别人或自己当成了疯子。</p>
<p>沉默峡谷的土壤和两侧的山岩有种特殊的性质，能几乎把所有的声音消除，巴比伦塔的学者曾对此展开研究，然而他们一无所获。除此以外，沉默峡谷就是个普通的荒凉峡谷，稀疏的杂草养不出大型动物，对一个经验丰富的旅行者而言，找到水源，辨别方向和驱散毒虫都不算难 ——只要他能忍受无尽的沉默</p>
<p>在被载入地图后，这里逐渐成了修士的圣地，当然，也有人进去后再也没有出来</p>
<h2 id="幻影沼泽">幻影沼泽</h2>
<p>警告！魔术师慎入！</p>
<p>这是沉默峡谷一处著名的景点，和峡谷本身一样，这里也几乎没什么异常，对有防备的旅行者而言并没什么危险。传说中一位善于擅长表演幻影魔术的魔术师来到这里时，将自己当做了幻影，而把幻影当成了真实。于是他迷失在这里，将此处化成了一片沼泽，如果一位有真才实学的魔术师来到这里，那么他绝对无法精神正常地离开，尽管对其他人而言，这里能看到的异象仅仅是偶尔出现魔术师忧郁的身影而已。</p>
<h2 id="沉默王国">沉默王国</h2>
<p>………………………………</p>
<p>沉默王国一直是个传说，一开始只是有少数人怀疑那些进了峡谷再没有出来的人到底去了哪里？这些怀疑逐渐被时间埋葬，直到帝国标记了沉默峡谷的存在导致一批旅行者来此游览，，有些旅行家发现了沉默王国的存在，很难想象一个王国会存在于荒野，事实上，那里只是寥寥几个人的聚居处。住民们给了旅行家一些食物和饮水，并为他指明了道路，从始至终，他们都带着沉默，从未试图张开嘴唇过。</p>
<p>此后又陆陆续续地出现了类似住民目击报告，但都被帝国封锁，最终，这一切成为了传说或是怪谈，奇怪的是，帝国似乎对此颇为忌惮，从此以后沉默峡谷再也没有出现在官方文件上过。</p>
<p>我们认为那些住民的存在涉及了达瑞克拉世界的源论，可以肯定那是一些向往沉默的人，不知何时他们聚集起来，用各自的思虑创造了一个无声的世界——或许跟0号研究所揭示的结果一致，这十分危险，一旦被人们知道，达瑞克拉世界或许会因此毁灭。</p>
<pre><code>                                 ——《关于沉默王国的报告》</code></pre>
<h2 id="号研究所">0号研究所</h2>
<p>我思故我在，我在故我思。——帝国哲学家卡尔迪</p>
<p>0号研究是科学组织浮士德所进行的一场实验，没错，与大多数我同事的想法相反，它并不是个邪教组织，从同行的角度来说，我很佩服他们的开创性。</p>
<p>0号研究所本是个普通的小镇，如果不是那件事的发生，我们永远不会知道这里曾发生过这样的实验。</p>
<p>帝国的审讯所抓到过一个浮士德的高层，今天他们终于设法让他开口了，由此我们终于知道他们是怎么进行实验的。首先，小镇只是出现了一些以屠戮人民，掠夺财物为乐的人，他们穿着迥异的衣服，却意外有着纯正的当地口音，经过一番协力，这些人不久就被送上了断头台。</p>
<p>奇怪的是，他们面对死亡毫无畏惧，自称“玩家”的他们发出了下次进犯的预告，然后在断头台上化成白光消失了。</p>
<p>当天，一切有关他们的消息被政府封锁，几乎同时不少“智者”跳了，要求让民众得知真相，惴惴不安中，很多小册子在民众中传阅——上面说这个世界只是虚构，完全为了让那些玩家取乐而存在（至于为何能让民众了解虚幻的概念，或许浮士德的教育机制还是挺有成效的）</p>
<p>第二天，更多所谓的“玩家从天而降”，所有住民都陷入了绝望与怀疑，就在这时我们所知的异变发生了，没人知道这是怎么做到的，但整个克罗利安镇就这么化为一片混沌之地，我们的不少调查员在第一眼看到它的遗址时就发疯了——我们没人知道为什么。</p>
<p>现在那里应该已经封闭了，我的建议是，永远封闭下去，或许邪神辛克莱温是对的，这个世界确实由我们的思想决定。我希望所有人都能对此提高警惕，永远不要让类似的事故重演</p>
<h2 id="帕斯卡王国">帕斯卡王国</h2>
<p>世上哪有不建立在剥削上的幸福？</p>
<p>帝国前36年，在正片大陆一个名不见经传的角落有一个小国，这个国家物资贫瘠，人口稀疏，尽管气候不算恶劣，但人民常常处于食不果腹的状态。</p>
<p>国王帕列斯是位平庸的君主，他的儿子——王子恩西斯却是位有想法的年轻人，尽管刚刚成年，他已经开始思索如何壮大自己的国家，这位王子曾经游学诸国，每次看到国民因营养不良而矮小纤弱的身材，他都会在心中发誓一定要找到让子民过上幸福快乐生活的方法</p>
<p>有一天，他带着这个愿望，带着几位侍从出门远行，在一番艰难跋涉后，王子在荒野中迷路了，他仿徨了几天，终于有一天他发现了一个村落</p>
<p>这个村落贫瘠弱小，王子注意到他们大量以烤制生肉，野菜，甚至昆虫而食，他们没有国王或者地位高于其他居民的人，尽管如此，他们的脸上却常常洋溢着笑容</p>
<p>王子作为外来人并没有对这些野人产生太多影响，于是他也学着野人的样子，用茅草和树枝搭起简易的居所，尝试融入野人的生活</p>
<p>一个月后，当国王派出的宫廷军顺着王子迷路时留下的标记找到他时，王子正喃喃自语道：我要找到的道路，就在这里啊</p>
<p>归国后几月，王子继位成为了国王，他实现了自己的诺言，在他的治理下，他的子民过上了物质丰富，精神充足的生活——凭借着王子制定并实现的驯养土著成为奴隶的方法。建立帕索斯帝国后五年，王子临终，面对伏在病榻前痛苦的子孙，他淡淡地说：他们以前就没有国王，以后也不会有吧。随后他保持着沉默，任凭御医记录他由有到无的脉搏直至最后</p>
<p>帝国历364年，历经三百年的不懈斗争，萨曼人杰出的领袖终于为族人争取到了自由，帝国，这一最先实现奴隶制的国家，最终成为了民主共和的起源…… ——《帝国通史》</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>基于恐龙书和苏大ppt的操作系统笔记</title>
    <url>/thinklive/2910/</url>
    <content><![CDATA[<h1 id="概论">概论</h1>
<pre><code>计算机系统可以分为四个部分  
硬件(Hardware) – 提供基本的计算资源  
CPU, memory, I/O devices  
操作系统(Operating System)  
控制和协调各用户的应用程序对硬件的使用  
应用程序(Application programs) – 规定了用户按何种方式使用系统资源  
字处理程序, 编译器, 网络浏览器, 数据库系统, 视频游戏  
用户(Users)  
人, 机器, 其他计算机  
操作系统的目标:  
运行用户程序  ---核心目标  
更方便使用计算机 ---面向用户  
更高效使用计算机 ---面向系统  </code></pre>
<span id="more"></span>
<p>计算机启动时，会启动引导程序，来初始化系统的各个组件，加载操作系统并开始执行<br />
操作系统加载到内存后，开始为系统和用户提供服务，成为系统进程或者后台程序该阶段完成后系统完全启动并且等待事件发生。<br />
事件发生通过”中断“机制来通知，cpu被中断时，停止正在做的事，并立即转到固定位置继续执行中断服务程序，执行完后继续执行被中断的计算</p>
<ul>
<li>中断：指当出现需要时，CPU暂时停止当前程序的执行，转而执行处理新情况的程序和执行过程<br />
</li>
<li>中断号：外部设备进行I/O操作时产生的中断信号，发送给CPU<br />
</li>
<li>中断向量：中断服务程序的入口地址<br />
</li>
<li>中断服务程序：执行中断处理的代码<br />
</li>
<li>陷阱(trap):是由于出错或用户请求引起的软件生成的中断<br />
操作系统是中断驱动</li>
</ul>
<pre><code>在冯·诺依曼体系结构( von Neumann architecture)上执行时，一个典型的指令执行周期是，首先从内存中获取指令，并存到指令寄存器( instruction register)。接着，该指令被解码，也可能会从内存中获取操作数据并且存到内部寄存器。在指令完成对操作数据的执行后，结果也可存到内存。注意:内存单元只能看到内存地址的流，而并不知道它们如何产生(通过指令计数器、索引、间接、常量地址或其他方式)或它们是什么样（指令或数据）的地址。相应地，我们可以忽略程序如何产生内存地址，而只关注由程序运行所生成的地址序列。  </code></pre>
<p>集群系统</p>
<p>由两个或多个独立的系统耦合起来<br />
共享数据 storage-area network (SAN)。<br />
提供高可用性。<br />
一定的冗余<br />
非对称集群(Asymmetric Clustering)：一台机器运行应用程序，而其他机器处于热备份模式。<br />
对称集群(Symmetric Clustering)：多个主机都运行应用程序<br />
提供high-performance computing (HPC)<br />
用专门的应用程序利用集群，并行计算parallelization</p>
<pre><code>多道程序设计：在内存中同时存在多道作业，在管理程序控制下相互穿插运行  
通过作业调度(Job Scheduling)选中一个作业并运行  
当该作业必须等待时 (如等待I/O), 切换到另一个作业  
目的:提高CPU的利用率，充分发挥计算机系统部件的并行性  </code></pre>
<p>分时系统：控制响应时间较短，使计算机可交互，一般采用时间片轮转方式使一台计算机为多个用户服务<br />
并行：两个或者多个作业在同一时刻运行<br />
并发：两个或多个作业在同一时间间隔内依次运行<br />
双重模式：允许OS保护自身和其他系统部件<br />
用户模式(user mode)和内核模式(kernel mode)，由硬件提供模式位<br />
特权指令：可能引起系统崩溃的指令，只能运行在内核模式</p>
<pre><code>如果操作系统不能获得CPU控制权，就无法管理系统  
eg.用户程序死循环，用户程序不调用系统调用  
解决方法：定时器  
在一段时间后发生中断，CPU控制权返回操作系统  
固定时间和可变时间定时器  
利用时钟和计数器实现  </code></pre>
<p>I/O保护<br />
防止用户程序执行非法I/O<br />
解决方法：所有I/O指令都是特权指令<br />
用户程序通过系统调用进行I/O操作<br />
内存保护<br />
防止内存非法访问<br />
解决方法：存储保护机制<br />
硬件支持<br />
程序运行必须的存储设备<br />
CPU只能直接访问寄存器、高速缓存和内存<br />
处理前和处理后的所有数据都在内存<br />
执行的指令都在内存<br />
内存管理：提供内存的分配、回收、地址转换、共享和保护等功能<br />
提高内存利用率<br />
提高内存访问速度<br />
从而提高计算机运行效率</p>
<p>操作系统服务提供对用户很有用的函数:</p>
<ul>
<li><p>用户界面 – 所有的操作系统都有用户界面(UI)<br />
形式有命令行界面(CLI)、图形用户界面(GUI)、批界面</p></li>
<li><p>程序执行 – 系统必须能将程序转入内存并运行程序。程序必须能结束执行，包括正常或不正常结束（指明错误）</p></li>
<li><p>I/O 操作 -  运行程序可能需要I/O,这些I/O可能涉及文件或设备.</p></li>
<li><p>文件系统操作 -  文件系统特别重要。很明显，程序需要读写文件和目录，创建和删除文件，搜索文件，列出文件信息，访问管理</p></li>
<li><p>通信 – 进程间可能需要交换信息，发生同一台计算机运行的进程间或由网络连接的不同计算机上的进程间(消息传递和共享内存)<br />
通信可以通过共享内存或消息交换技术来实现 (消息包由OS移动)</p></li>
<li><p>错误检测 – OS 需要知道可能出现的错误<br />
错误可能发生在CPU 或内存硬件、I/O设备和用户程序中<br />
对于每种类型的错误，OS 应该采取适当的动作以确保正确和一致的计算<br />
调试工具可以在很大程度上加强用户和程序员有效使用系统的能力</p></li>
</ul>
<p><code>层次结构</code>：操作系统划分为若干层，在低层上构建高层，底层（0层）为硬件，最高层（ N层）为用户层，每层只使用低层次的功能和服务<br />
优点<br />
简化了系统设计和实现，便于调试和升级维护<br />
缺点<br />
层定义困难，效率差<br />
<code>微内核</code>：<br />
问题：内核越来越大，越来越难管理<br />
内核微型化：核内移出尽可能多功能到用户空间<br />
好处:<br />
便于扩充，便于移植操作系统到新架构系统上，更稳定 (更少的代码运行在核心态)，更安全<br />
坏处:<br />
用户空间和内核空间通信的系统开销增加<br />
解决方法：提出消息传递机制<br />
<code>模块化</code>：<br />
大部分现代操作系统采用模块结构(Linux, Solaris)<br />
使用面向对象方法<br />
每个核心部件分开<br />
每个与其他模块的会话被称为接口<br />
每个模块在需要时被加载到内核<br />
总体而言，类似于分层方法，但更灵活</p>
<pre class="进程是程序的一个实例，是程序的一次执行"><code>一个程序可对应一个或多个进程，同样一个进程可对应一个或多个程序  
程序是进程的代码部分  
进程是活动(active)实体，程序静止（被动passive）实体  
进程在内存，程序在外存  </code></pre>
<p><code>进程控制块(Process Control Block)   PCB包含同进程有关的信息，包括：   进程状态   程序计数器   CPU寄存器   CPU调度信息   内存管理信息   计账信息   I/O状态信息</code></p>
<p><img src="/images/obsidian/20230529221113.png" title="image" alt="图片" /><br />
<code>进程调度队列</code>：<br />
作业队列 - 在系统中的所有进程的集合<br />
就绪队列 - 在主内存中的，就绪并等待执行的所有进程的集合<br />
设备队列 - 等待某一I/O设备的进程队列<br />
在各种队列之间进程的迁移<br />
<code>进程终止</code>：</p>
<ul>
<li>进程执行最后一项并退出（exit）<br />
从子进程向父进程输出数据（通过wait）<br />
操作系统收回进程的资源<br />
父进程可中止子进程的执行（ abort）<br />
</li>
<li>子进程超量分配资源<br />
赋予子进程的任务不再需要<br />
若父进程终止，一些系统不允许子进程继续存在<br />
所有子进程终止-- 级联终止<br />
</li>
<li>父进程可以等子进程结束<br />
调用wait()系统调用<br />
<code>进程通信</code></li>
</ul>
<pre><code>消息传递在微内核中的应用  
远程通信无法采用共享内存  
  
发送send(message) - 固定或可变大小消息  
接收receive(message)  
若P与Q要通信，需要:  
建立通信连接  
通过send/receive交换消息  
通信连接的实现  
物理的（如，共享存储，硬件总线）  
逻辑的（如，逻辑特性）  
消息传递可阻塞（blocking）或非阻塞（non-blocking）  
阻塞-同步  
阻塞send：发送进程阻塞，直到消息被接收  
阻塞receive：接受者进程阻塞，直到有消息可用  
非阻塞-异步  
非阻塞send：发送进程发送消息并继续操作  
非阻塞receive: 接收者收到一个有效消息或空消息  
如果通过信箱，则可分为直接和间接通信  </code></pre>
<p><code>线程</code>（轻型进程lightweight process, LWP ）是CPU使用的一个基本单元，包括</p>
<ul>
<li>线程ID<br />
</li>
<li>程序计数器<br />
</li>
<li>寄存器集<br />
<code>栈空间</code><br />
一个线程与它的对等线程共享：<br />
</li>
<li>代码段<br />
</li>
<li>数据段<br />
</li>
<li>操作系统资源<br />
总体作为一个任务<br />
多线程的优点：<br />
</li>
<li>响应性<br />
</li>
<li>资源共享<br />
</li>
<li>经济<br />
</li>
<li>可伸缩性：可在多处理核上并行运行</li>
</ul>
<pre><code>调度  
线程是调度的基本单位，同一进程中的线程切换不会引起进程切换。  
并发  
线程可以提高系统的并发性。  
资源  
进程拥有资源，是资源分配的基本单位，而线程则不拥有资源，但它可以访问创建它的进程所拥有的资源  
上下文切换  
线程的上下文切换的代价比进程小。  </code></pre>
<p>可分为数据并行和任务并行<br />
<img src="/images/obsidian/20230530184144.png" title="图片" alt="图片" /><br />
<img src="/images/obsidian/20230530184243.png" title="图片" alt="图片" /><br />
<img src="/images/obsidian/20230530185433.png" title="图片" alt="图片" /><br />
//S是应用程序的一部分，N是它在N个处理器上串行运行<br />
<code>线程的分类</code>：</p>
<ul>
<li>用户线程：由用户线程库进行管理的线程<br />
内核看不到用户线程<br />
用户线程的创建和调度在用户空间中，不需要内核的干预<br />
应用于传统的只支持进程的操作系统<br />
</li>
<li>内核线程：内核进行管理的线程<br />
需要内核支持<br />
由内核完成线程调度<br />
由内核进行创建和撤销<br />
<code>多线程模型的分类</code>：<br />
</li>
<li>多对一模型：<br />
不支持内核线程的操作系统<br />
内核只有进程<br />
内核只看到一个进程<br />
多个线程不能并行运行在多个处理器上<br />
进程中的用户线程由进程自己管理<br />
进程内线程切换不会导致进程切换<br />
一个线程的系统调用会导致整个进程阻塞<br />
</li>
<li>一对一模型<br />
用于支持线程的操作系统<br />
用户线程一对一映射到内核线程<br />
操作系统管理这些线程<br />
并发性好：多个线程可并行运行在多个处理器上<br />
内核开销大<br />
</li>
<li>多对多模型：<br />
多个用户线程映射为相等或更小数目的内核线程<br />
并发性和效率兼顾<br />
增加复杂度<br />
<code>线程库</code><br />
为程序员提供API来创建和管理线程<br />
两种模式：<br />
</li>
<li>用户库（用户线程）<br />
存在于用户空间<br />
没有内核支持<br />
调用线程库不会产生系统调用<br />
</li>
<li>内核库（内核线程）<br />
存在于内核<br />
操作系统支持<br />
调用线程库会产生系统调用<br />
<code>隐式线程</code>：在编译或者运行的时候由编译器或者运行库决定而不是编程者<br />
<code>线程池</code>：在池中创建一批线程，等待任务<br />
优点：<br />
利用线程池中的线程来响应请求比创建一个线程更加快速<br />
允许一个应用程序中的线程数量达到线程池的上限<br />
<code>大中央调度</code>:<br />
Apple 技术用于Mac OS X 和 iOS<br />
扩展C, C++ languages, API, 和 run-time library<br />
允许辨认可并行区段<br />
管理线程的大多数细节<br />
块格式“^{ }” -   ˆ{ printf("I am a block"); }<br />
块放置在调度队列中<br />
在线程池中有可用的线程的时候离开队列<br />
<code>线程撤销</code>在完成前终止线程<br />
要取消的线程称为目标线程 target thread<br />
大体两种方法:<br />
异步取消Asynchronous cancellation 立刻终止目标线程<br />
延迟取消Deferred cancellation 允许目标线程周期性检查它是否应该被终止<br />
<code>调度程序激活</code><br />
</li>
<li>通常用一种中间数据结构在用户和内核线程间 – 轻量级进程 lightweight process (LWP)<br />
类似虚拟处理器<br />
每个 LWP 和内核进行相连<br />
一定数量的LWP<br />
</li>
<li>调度器激活提供 upcalls – 一种线程库中内核使用upcall处理句柄 upcall handler 来告知特定事件<br />
<img src="/images/obsidian/20230530200404.png" title="image" alt="图片" /><br />
这种通讯允许一个应用程序保持正确数目的内核线程</li>
</ul>
<p>需要调度的四种情况</p>
<ul>
<li>进程从运行状态切换到等待状态<br />
</li>
<li>进程从运行切换到就绪状态（eg.出现中断）<br />
</li>
<li>进程从等待状态切换到就绪状态(eg.IO完成)<br />
</li>
<li>进程终止时<br />
调度只发生在1，4情况下是非抢占调度<br />
<code>非抢占调度   一旦把CPU分配给某进程后，系统不可以抢占已分配的CPU并分配该其它进程   只有进程自愿释放CPU，才可把CPU分配给其他进程   优点：易实现，调度开销小，适合批处理系统   缺点：响应时间长，不适合交互式系统</code>抢占调度<br />
调度程序可根据某种原则暂停某个正在执行的进程，将已分配给它的CPU重新分配给另一进程<br />
可防止单一进程长时间独占CPU<br />
系统开销大<br />
抢占式与非抢占式的区分<br />
运行进程是否是自愿放弃CPU<br />
<code>长程调度   又称作业调度、高级调度   “新建”状态转换到“就绪”状态   由调度程序选择   控制多道程序的“道/度”（Degree）</code>短程调度<br />
又称CPU调度、低级调度<br />
调度程序选择下一个执行进程<br />
</li>
<li>切换频率<br />
短程调度切换频率高<br />
长程调度切换频率低<br />
</li>
<li>切换开销<br />
短程调度开销小(milliseconds，切换快)<br />
长程调度开销大(seconds/minutes，切换慢)<br />
</li>
<li>操作系统中应用<br />
短程调度：必需<br />
长程调度：可选<br />
中程调度<br />
又称交换<br />
将进程在内存和外存间换进换出<br />
目的：节省内存空间<br />
<code>就绪队列</code> - 在主内存中处于就绪状态并等待执行的所有进程集合<br />
<code>设备队列</code> - 等待某一I/O设备的进程队列<br />
进程的执行过程实际上就是进程在各种队列之间的迁移<br />
基本指标<br />
</li>
<li>CPU利用率 – 固定时间内CPU运行时间的比例<br />
</li>
<li>吞吐量 – 单位时间内运行完的进程数<br />
</li>
<li>周转时间 – 进程从提交到运行结束的全部时间<br />
</li>
<li>等待时间 – 进程等待调度（不运行）的时间片总和<br />
</li>
<li>响应时间 – 从进程提交到首次运行[而不是输出结果]的时间段，也就是第一段的等待时间</li>
</ul>
<h1 id="进程调度">进程调度</h1>
<p><code>等待时间</code>=开始处理时间-到达时间<br />
<code>周转时间</code>=等待时间+处理时间</p>
<h2 id="先来先服务-fcfs">先来先服务-FCFS</h2>
<p>优点：实现简单<br />
缺点：长进程在前会使多个短进程等待过久，增加平均等待时间</p>
<h2 id="短作业优先-sjf">短作业优先-SJF</h2>
<p>SJF是最优的 – 对一组指定的进程而言，它给出了最短的平均等待时间</p>
<h3 id="抢占式调度">抢占式调度</h3>
<p>有比当前进程所需时间更短进程到达时，更换目前进行进程<br />
常用于长进程调度，缺点在于进程的cpu区间难以估计<br />
通常用指数平均估计</p>
<h3 id="非抢占式调度">非抢占式调度</h3>
<p>进程只在结束后让出cpu</p>
<h2 id="优先级调度">优先级调度</h2>
<p>基于进程紧迫程度赋予优先级，cpu分配给最高优先级进程<br />
优点<br />
实现简单，考虑了进程的紧迫程度<br />
灵活，可模拟其它算法</p>
<ul>
<li>静态优先级<br />
进程创建时确定，运行期间不变<br />
</li>
<li>动态优先级<br />
优先级随着进程推进或者等待时间增加而改变</li>
</ul>
<p>问题</p>
<ul>
<li>饥饿：低优先级进程可能永远无法运行<br />
</li>
<li>老化：视进程等待时间延长提高优先级</li>
</ul>
<h3 id="响应比高者优先调度">响应比高者优先调度</h3>
<p>响应比=（开始时间-到达时间）/运行时间</p>
<ul>
<li>如等待时间相同，运行时间越短，优先级越高，类似于SJF<br />
</li>
<li>如运行时间相同，优先级取决于其等待时间，类似于FCFS<br />
</li>
<li>长进程的优先级可随等待时间的增加而提高，最终可得到服务<br />
</li>
<li>缺点：每次调度之前，都需要计算响应比，增加系统开销</li>
</ul>
<h2 id="轮转调度-rr">轮转调度-RR</h2>
<p>将较小的时间单元定义为时间片，就绪队列为循环队列，调度程序循环整个队列，为每个进程分配不超过一个时间片的cpu</p>
<h2 id="多级队列调度">多级队列调度</h2>
<p>进程分为前台进程（交互进程）和后台进程（批处理进程）<br />
不同类型的进程需要不同策略<br />
交互进程需要短的响应时间<br />
批处理进程需要短的等待时间<br />
<code>多级队列梯度</code>系统中存在多个就绪队列，每个队列有自己的调度算法</p>
<h3 id="多级反馈序列-mlfq">多级反馈序列-MLFQ</h3>
<p><em>(MultiLevel Feedback Queue Scheduling)</em><br />
多级队列的延伸<br />
不同：</p>
<ul>
<li>多级队列：进程不能在不同队列间移动<br />
</li>
<li>多级反馈队列：进程能在不同队列间移动<br />
</li>
<li>多级反馈队列调度需要考虑以下问题：<br />
队列数<br />
每一队列的调度算法<br />
决定进程升级（低级队列到高级队列）的方法<br />
决定进程降级（高级队列到低级队列）的方法<br />
决定新进程将进入哪个队列的方法<br />
`最常用的调度算法</li>
</ul>
<pre><code>eg.  
Q0-RR时间片8ms  
Q1-RR时间片16ms  
Q2-FCFS  </code></pre>
<p>缺点：优先级一开始确定，无法调整</p>
<h1 id="线程调度">线程调度</h1>
<p>区别用户层和内核层<br />
调度线程而不是进程<br />
多对多和多对一模型，线程库在可用的LWP上调度用户层线程<br />
process-contention scope (PCS) 在进程中进行调度竞争<br />
通常由程序员通过优先级设置<br />
内核线程通过system-contention scope (SCS) 在CPU上调度– 系统中统一竞争<br />
一对一模型仅使用SCS，如Windows， Linux</p>
<h2 id="局部调度">局部调度</h2>
<p>[[线程库]]决定哪个线程列入轻量级进程LWP</p>
<h2 id="全局调度">全局调度</h2>
<p>内核决定下一个运行的内核线程</p>
<h1 id="多处理器调度">多处理器调度</h1>
<p>调度类似单处理器，但需要将任务平均分配</p>
<h2 id="对称多处理器-smp">对称多处理器-SMP</h2>
<h3 id="单队列多核调度方法sqmp">单队列多核调度方法(SQMP)</h3>
<p>系统有一个就绪队列。当任意一个CPU空闲时，就从就绪队列中选择一个进程到该CPU上运行<br />
优点：<br />
容易从单核调度算法推广到多核/多处理器、<br />
实现简单，负载均衡<br />
缺点：<br />
不具有亲和性<br />
加锁问题</p>
<h3 id="多队列调度方法mqmp">多队列调度方法(MQMP)</h3>
<p>系统有多个就绪队列，一般每个CPU一个。每个就绪队列有自己的调度算法，并且每个就绪队列的调度相对独立<br />
优点：<br />
亲和性好<br />
不需要加锁<br />
缺点：<br />
负载不均衡<br />
策略：“偷”进程<br />
<code>每个处理器决定自己调度方式   定期检测每个cpu负载，分配任务给空闲处理器</code>亲和性：进程倾向于在给定cpu上运行</p>
<ul>
<li>软亲和性：不强制禁止迁移<br />
</li>
<li>硬亲和性：禁止迁移</li>
</ul>
<h3 id="单队列调度">单队列调度</h3>
<p>共享队列，分配给不同cpu<br />
不具有亲和性</p>
<h3 id="多队列调度">多队列调度</h3>
<p>不同cpu有各自队列<br />
<code>优点</code>：亲和性较好，不需要加锁<br />
<code>缺点</code>：负载不均匀</p>
<h2 id="非对称处理器-asmp">非对称处理器-ASMP</h2>
<p>仅一个处理器处理系统数据结构，减轻共享需求</p>
<h1 id="实时cpu调度">实时cpu调度</h1>
<ul>
<li>软实时系统：不保证调度关键实时进程<br />
</li>
<li>硬实时系统：任务必须在截止期限前完成<br />
对实时调度，必须支持抢占式、优先级调度<br />
但仅仅支持软实时<br />
对硬实时必须提供满足截止时间的能力<br />
需要调度进程的新特性：<br />
周期性 periodic 定期需要CPU<br />
有进程时间 t, 截止时间 d, 周期 p<br />
0 ≤ t ≤ d ≤ p<br />
周期任务的速率Rate 1/p</li>
</ul>
<h2 id="单速速度调度">单速速度调度</h2>
<p>依照周期倒数分配一个优先级<br />
<code>优点</code>：最大化cpu利用率<br />
<code>缺点</code>：不保证每个进程都赶上截止期限(周期内执行不完)</p>
<h2 id="最早截止期限优先调度-edf">最早截止期限优先调度-EDF</h2>
<p>根据截止时间分配优先级<br />
越早截止期限，优先级越高</p>
<h2 id="比例分享调度">比例分享调度</h2>
<p>所有应用中分配T股，确保所有进程有固定的cpu时间，如果新加入进程大于T股剩余量，则不允许进入</p>
<h1 id="实例">实例</h1>
<h2 id="linux">linux</h2>
<ul>
<li>实时任务有静态优先级（友好值）<br />
</li>
<li>抢占式<br />
没有真正的线程</li>
</ul>
<h2 id="windows">windows</h2>
<ul>
<li>抢占调度<br />
</li>
<li>优先级</li>
</ul>
<p>对共享数据的并发访问可能导致数据的不一致性，需要保证并发进程正确执行顺序的机制<br />
<code>竞争条件</code>：多个进程并发访问同一共享数据</p>
<ul>
<li><code>同步</code>：协调执行次序<br />
</li>
<li><code>互斥</code>：进程排他性运行，可以独占资源<br />
<code>临界资源</code>：一次只允许一个进程使用的资源，又称互斥资源、独占资源或共享变量<br />
<code>共享资源</code>：一次允许多个进程使用的资源</li>
</ul>
<h2 id="临界区">临界区</h2>
<ul>
<li><code>互斥</code>：临界区执行的进程排斥其他进程（有相同临界资源）<br />
</li>
<li><code>进步</code>:临界区无进程执行，不能无限期延长下一个需要临界区进程的等待时间<br />
</li>
<li><code>优先等待</code>：一个进程进入临界区时，其他进程进入<code>临界区</code>有次数限制<br />
</li>
<li>进入区：互斥<br />
</li>
<li>退出区：有空让进<br />
</li>
<li>每个临界区不能过大：有限等待<br />
空闲则入：其他进程均不处于临界区；<br />
忙则等待：已有进程处于其临界区；<br />
有限等待：等待进入临界区的进程不能"死等"；<br />
让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li>
</ul>
<pre><code>Peterson算法  
do &#123;  
  
  flag [i]:= true;    
  turn = j;    
  while (flag [j] and turn == j) ;  
  
  critical section  
  
  flag [i] = false;  
  
  remainder section  
  
  &#125; while (1);  </code></pre>
<h2 id="锁">锁</h2>
<pre><code>acquire() &#123;    
       while (!available)  
          ; /* busy wait */  
       available = false;;  
    &#125;  
   release() &#123;  
       available = true;  
    &#125;  
   do &#123;  
  
    acquire lock  
  
       critical section  
  
    release lock  
  
      remainder section  
  
 &#125; while (true);  </code></pre>
<h3 id="互斥锁自旋锁">互斥锁（自旋锁）</h3>
<p>原子执行acquire(),release()<br />
acquire：while(!available) waiting;<br />
available=false<br />
release:available=false</p>
<h3 id="面包店算法">面包店算法</h3>
<ul>
<li>在进入临界区前，每个进程接收一个号码。具有最小号码的进程进入临界区。<br />
</li>
<li>如果进程Pi和Pj接收到同样的号码，如果i &lt; j ，则Pi先得到服务，否则Pj先得到服务。<br />
</li>
<li>这种号码方案总是以递增序列产生号码；如： 1,2,3,3,3,3,4,5...</li>
</ul>
<pre><code>do &#123;  
  choosing[i] = true;  
  number[i] = max(number[0], number[1], …, number [n – 1])+1;  
  choosing[i] = false;  
  for (j = 0; j &lt; n; j++) &#123;  
  while (choosing[j]) ;  
  while ((number[j] != 0) &amp;&amp; (number[j,j] &lt; number[i,i])) ;  
  &#125;  
  critical section  
  number[i] = 0;  
  remainder section  
&#125; while (1);  </code></pre>
<h2 id="信号量软件解决方案">信号量（软件解决方案）</h2>
<ul>
<li>保证多个代码段不被并发调用<br />
</li>
<li>进入关键代码段前，进程必须获取信号量，否则不能运行<br />
</li>
<li>执行完关键代码段，必须释放信号量<br />
</li>
<li>信号量有值，说明空闲，为负说明忙碌</li>
</ul>
<pre><code>信号量S – 整型变量  
提供两个不可分割的[原子操作]访问信号量  
wait (S):  
     while S&lt;= 0 do no-op;    
     S--;    
signal(S):  
     S++;  
wait (S)又称为P(S)  
signal(S)又称为V(S)  </code></pre>
<p>`分类</p>
<ul>
<li>计数信号量：没有限制的整型值计数信号量=同步信号量<br />
</li>
<li>二值信号量：0 || 1 二值信号量=互斥信号量<br />
`使用<br />
必须取一次且仅有一次初值<br />
初值不为负<br />
除了初始化，只能通过执行P、V操作来访问S</li>
</ul>
<pre><code>例子：P1  和 P2 需要 C1 比C2先运行  
       semaphore s=0  
P1:  
   C1;  
   signal(s);  
  
P2:  
   wait(s);  
   C2;  </code></pre>
<p>死锁 – 两个或多个进程无限期地等待一个事件的发生，而该事件正是由其中的一个等待进程引起的.<br />
P0  P1<br />
  P(S);  P(Q);<br />
  P(Q);  P(S);<br />
  V(S);  V(Q);<br />
  V(Q)  V(S);<br />
饥饿 – 无限期地阻塞。进程可能永远无法从它等待的信号量队列中移去.</p>
<h3 id="实例-1">实例</h3>
<h4 id="生产者消费者问题">生产者消费者问题</h4>
<p><code>生产者   把产品放入指定缓冲区   in:所有的生产者对in指针需要互斥   counter：所有生产者消费者进程对counter互斥</code>消费者<br />
从指定缓冲区取出产品<br />
out:所有的消费者对out指针需要互斥<br />
counter：所有生产者消费者进程对counter互斥</p>
<pre><code>buffer[in] = nextProduced;  
in = (in + 1) % BUFFER_SIZE;  
counter++;  
  
nextConsumed = buffer[out];  
out = (out + 1) % BUFFER_SIZE;  
counter--;  
  
生产者：  
 &#123;  
  …  
  生产一个产品  
  …  
  wait(empty);  
  wait(m);  
   …  
  C1：把产品放入指定缓冲区  
   …  
  signal(m);  
  signal(full);  
  &#125;  
  
消费者：  
 &#123;  
  …  
  wait(full)；  
  wait(m);  
   …  
  C2：从指定缓冲区取出产品  
   …  
  signal(m);  
  signal(empty);  
   …  
  消费取出的产品  
   …  
  &#125;  </code></pre>
<p>`同步分析</p>
<ul>
<li>找出需要同步的代码段<br />
</li>
<li>分析片段执行顺序<br />
</li>
<li>增加同步信号量并赋初始值<br />
</li>
<li>关键代码前后加wait和signal操作<br />
`生产者<br />
</li>
<li>判断是否能获得空缓冲区，否则阻塞<br />
</li>
<li>满缓冲区数量++，如果有消费者由于等待阻塞，唤醒该消费者<br />
`消费者<br />
</li>
<li>判断能否获得满缓冲区，否则阻塞<br />
</li>
<li>空缓冲区数量++，如果有生产者等待，唤醒该生产者</li>
</ul>
<h4 id="读者写者问题">读者写者问题</h4>
<p>两组并发进程读者和写者,共享一组数据区进行读写<br />
`要求</p>
<ul>
<li>允许多个读者同时读<br />
</li>
<li>不允许读者、写者同时读写<br />
</li>
<li>不允许多个写者同时写<br />
`读者<br />
</li>
<li>无读者写者，新读者可读<br />
</li>
<li>有写者等，其他读者读，新读者可读<br />
</li>
<li>有写者写，新读者等<br />
`写者<br />
</li>
<li>无读者写者，新写者可写<br />
</li>
<li>有读者读，写者等<br />
</li>
<li>有其他写者，写者等待</li>
</ul>
<pre><code>增加一个读者计数器rc，设置初始值为0；  
读者：Repeat  
P(mutex);  
readcount:=readcount+1;  
if readcount=1  
then P (w);  
V(mutex);//mutex为互斥信号量，初始值为1  
读  
P(mutex);  
readcount:=readcount-1;  
if readcount=0  
then V(w);  
V(mutex);  
Until false  
  
  
Writers  
……  
P(W);  
写  
V(W);  
…...  </code></pre>
<p>`问题：写者可能饥饿</p>
<ul>
<li>读者写者互斥，写者直到读者count为0才进入进程</li>
</ul>
<h4 id="哲学家就餐问题">哲学家就餐问题</h4>
<p>5个哲学家、5根筷子，每个哲学家左右各有一根筷子，每个哲学家只有拿起左右两个筷子才能吃饭<br />
五个元素数组储存筷子，对每个哲学家有拿起左右筷子，放下左右筷子的函数<br />
`防止死锁</p>
<h5 id="方法1">方法1</h5>
<p>最多允许四个哲学家同时坐在桌子周围</p>
<pre><code>semephore *chopstick[5];   //初始值为1  
semaphore *seat;  //初始值为4  
哲学家 i:  
  ……  
  P(seat);  //看看4个座位是否有空  
  P(chopStick[i]);  //拿左边筷子  
  P(chopStick[(i + 1) % 5]);  //拿右边筷子  
   吃饭  
   V(chopStick[i]);  //放下左边筷子  
   V(chopStick[(i + 1) % 5]);  //放下右边筷子  
   V(seat);  //释放占据的位置  </code></pre>
<ul>
<li>左右筷子都可用时才拿起筷子<br />
</li>
<li>非对称解决，单号哲学家优先拿左边筷子，双号优先拿右边</li>
</ul>
<h5 id="方法2">方法2</h5>
<p>仅当一个哲学家左右两边筷子都可用时，才允许他拿筷子<br />
哲学家分为三个状态thinking,hungry,eating<br />
设置5个信号量代表所有哲学家，仅当自身hungry且左右都不在吃饭时才开始eating</p>
<pre><code>void test(int i);  
    &#123;  
        if (state[i] == hungry) &amp;&amp;  //是否饿了  
          (state[(i+4)%5]!=eating) &amp;&amp; //左边哲学家是否在吃饭  
          (state[(i+1)%5]!=eating)  //右边哲学家是否在吃饭  
          &#123;  
                 state[i]=eating;  //设置哲学家状态为eating  
                 V(ph[i]);  //ph[i]设置为1  
           &#125;       
     &#125;  
     state[i]=hungry；  
            P(m);  
            test(i);  
            V(m);  
            P(ph[i]);  </code></pre>
<h5 id="方法3">方法3</h5>
<p>给所有哲学家编号，奇数号哲学家必须首先拿左边筷子，偶数号哲学家则反之</p>
<h3 id="信号量总结">信号量总结</h3>
<p>S&gt;0：有S个资源可用<br />
S=0：无资源可用<br />
S&lt;0：则|S|表示S等待队列中的进程个数<br />
P(S)：申请一个资源<br />
V(S)：释放一个资源<br />
互斥信号量初始值：一般为1<br />
同步信号量初始值：0-N<br />
`P、V操作成对出现<br />
互斥操作：P、V操作处于同一进程内<br />
同步操作：P、V操作在不同进程内<br />
两个一起的P操作的顺序至关重要<br />
同步与互斥P操作一起时，同步P操作要在互斥P操作前<br />
两个V操作的次序无关紧要</p>
<p><code>缺点</code>：同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如P、V操作的次序错误、重复或遗漏）<br />
易读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序；<br />
不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局；<br />
正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误；</p>
<h2 id="管程">管程</h2>
<p>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据<br />
封装数据以及对数据的操作<br />
确保每次只要一个进程在管程内活动<br />
<code>互斥   管程中的变量只能被管程中的操作访问   任何时候只有一个进程在管程中操作   类似临界区   由编译器完成</code>同步<br />
条件变量<br />
唤醒和阻塞操作<br />
x.wait(): 进程阻塞直到另外一个进程调用x.signal()<br />
x.signal()：唤醒另外一个进程</p>
<h3 id="问题">问题</h3>
<p>管程内可能存在不止1个进程<br />
如：进程P调用signal操作唤醒进程Q后<br />
存在的可能<br />
P等待直到Q离开管程 （Hoare）<br />
Q等待直到P离开管程（Lampson &amp; Redll，MESA语言）<br />
P的signal操作是P在管程内的最后一个语句 (Hansen，并行Pascal)</p>
<h2 id="内存概念">内存概念</h2>
<ul>
<li>程序必须装入内存才能被执行<br />
</li>
<li>CPU可以直接访问的存储器只有主存和寄存器<br />
</li>
<li>寄存器通常可以在一个（或少于一个）CPU时钟周期内完成访问<br />
</li>
<li>完成主存访问可能需要多个CPU时钟周期<br />
</li>
<li>CPU暂停（Stall）：在读取内存数据时，CPU空闲<br />
</li>
<li>Cache 位于主存和CPU寄存器之间，协调速度差异<br />
</li>
<li>内存保护需要保证正确的操作<br />
</li>
<li>基址寄存器（ Base）：进程最小的合法物理内存地址<br />
</li>
<li>界限寄存器（Limit）：进程地址的长度<br />
</li>
<li>CPU在执行指令时，需要进行地址合法性验证<br />
<code>给进程提供一段地址</code>：基地址寄存器（最小地址）和界限地址寄存器（地址范围）<br />
物理地址对进程是隐藏的<br />
<code>地址绑定（程序加载地址）</code>：可以静态绑定也可以动态绑定，动态绑定生成可重定位代码<br />
<code>动态加载</code>，所有程序以可重定位格式存储在磁盘，只有在调用时才被加载<br />
<code>动态链接和共享库</code>:每个库程序都有一个存根，指出如何定位内存驻留库程序，或者程序不在内存时如何家在程序，执行存根时检查程序是否在内存，若不是，则加载程序到内存</li>
</ul>
<h3 id="地址绑定">地址绑定</h3>
<p>地址绑定（重定位）：把程序中的相对地址转换为内存中的绝对地址的过程<br />
指令和数据绑定到内存地址可在三个不同阶段：<br />
<code>编译时期（ Compile time）   如果内存位置已知，可生成绝对代码   如果开始位置改变，需要重新编译代码</code>加载时期（ Load time）<br />
如果存储位置在编译时不知，则必须生成可重定位（ relocatable ）代码<br />
`执行时期（ Execution time）<br />
如果进程执行时可在内存移动，则地址绑定可延迟到运行时<br />
需要硬件对地址映射的支持（例如基址和限长寄存器）<br />
大部分操作系统用这个方法</p>
<h3 id="逻辑地址和物理地址">逻辑地址和物理地址</h3>
<p>逻辑地址空间的概念同物理地址空间相关联，它是正确内存管理的中心<br />
逻辑地址Logical address<br />
由CPU产生<br />
在进程内的相对地址<br />
也称：虚拟地址、程序地址<br />
物理地址Physical address<br />
内存地址<br />
所有内存统一编址<br />
也称：绝对地址、实地址</p>
<h3 id="内存管理单元">内存管理单元</h3>
<p>把虚拟地址映射到物理地址的硬件<br />
是CPU用来管理内存的控制线路<br />
在MMU策略中，基址寄存器中的值在其送入内存的时候被加入到由一个用户进程所产生的每个地址中<br />
用户程序所对应到的是逻辑地址，物理地址对它从来都不可见</p>
<h3 id="动态加载和链接">动态加载和链接</h3>
<p><code>加载   例程在调用之前并不加载   更好的内存空间利用率   没有被使用的例程不被载入   当需大量代码来处理不经常使用的功能时非常有用</code>链接<br />
和各种库文件的链接被推迟到执行时期<br />
需要动态装载技术支持<br />
一小段代码 - 存根，用来定位合适的保留在内存中的库程序<br />
存根用例程地址来替换自己，并开始执行例程<br />
操作系统需要检查例程是否在进程的内存空间，所以需要操作系统支持</p>
<h3 id="交换">交换</h3>
<p>一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行。<br />
<code>备份区</code>—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问。</p>
<pre><code>滚入，滚出(Roll out, roll in )—交换由于基于优先级的算法而不同，低优先级的进程被换出，这样高优先级的进程可以被装入和执行。  
交换时间的主要部分是转移时间，总的转移时间直接同交换的内存的数量成比例。  
在许多系统如：UNIX，Linux，Windows中，可以找到一些被修正过的交换措施。  
系统维持一个就绪队列，它包括在备份存储或在内存中准备运行的所有进程  </code></pre>
<h2 id="连续内存分配">连续内存分配</h2>
<p>为一个用户程序分配一个连续的内存空间</p>
<ul>
<li>单一连续分配：单道程序环境下，仅装有一道用户程序，即整个内存的用户空间由该程序独占<br />
</li>
<li>固定分区分配<br />
固定分配多个区域，用于放置单个进程<br />
预先把可分配的主存空间分割成若干个连续区域，称为一个分区。<br />
每个分区的大小可以相同也可以不同。但分区大小固定不变，每个分区装一个且只能装一个程序<br />
内存分配：如果有一个空闲分区, 则分配给进程<br />
</li>
<li>可变分区分配：<br />
用表格记录内存使用情况，根据内存块和孔调度进程<br />
当一个进程到来的时候，它将从一个足够容纳它分区中分配内存。<br />
操作系统包含以下信息:<br />
</li>
</ul>
<ol type="a">
<li>已分配的分区-已分配分区表   b) 空的分区-空闲分区表</li>
</ol>
<h3 id="选择孔">选择孔</h3>
<ul>
<li>首次适应（First-fit）: 分配最先找到的合适的分区<br />
</li>
<li>最佳适应（Best-fit）: 搜索整个列表，找到适合条件的最小的分区进行分配<br />
</li>
<li>最差适应（Worst-fit）: 搜索整个列表，寻找最大的分区进行分配</li>
</ul>
<p><code>碎片</code>：</p>
<ul>
<li>外部碎片：存储被分为大量小孔<br />
</li>
<li>内部碎片：分配给进程的孔，进程不需要使用的部分则成为内部碎片<br />
外碎片 –整个可用内存空间可以用来满足一个请求，但它不是连续的<br />
内碎片 –分配的内存可能比申请的内存大一点，这两者之间的差别是在分区内部，但又不被使用<br />
`可通过紧缩来减少外碎片<br />
把一些小的空闲内存结合成一个大的块。<br />
只有重定位是动态的时候，才有可能进行紧缩，紧缩在执行时期进行</li>
</ul>
<h2 id="分段">分段</h2>
<p>一个程序是一些段的集合，一个段是一个逻辑单位<br />
每个段用段名称和段偏移指定位置<br />
一个逻辑地址是两个向量的集合:<br />
&lt;segment-number, offset&gt;</p>
<p>段表 - 映射二维用户地址，每个表项包括:<br />
基址 - 包含内存中段物理地址的起始地址<br />
限长 - 指定段的长度<br />
段表基址寄存器(STBR)指向段表在内存中的地址<br />
段表限长寄存器(STLR)表明被一个程序所使用的段的数目<br />
如果 s &lt; STLR，段号s 是合法的</p>
<p>由于段的长度各不相同，内存分配是一个动态存储-分配问题</p>
<p>`内存分配<br />
首先/最佳适应法<br />
外碎片问题</p>
<p>`重定位<br />
动态<br />
由段表来执行</p>
<p>`共享<br />
共享的段<br />
同样的段号</p>
<h2 id="分页">分页</h2>
<p>允许进程的物理地址不连续<br />
<code>基本方法</code>：将物理内存分为固定大小的块，称为帧或页帧，逻辑内存分为同样大小的块，称为页或页面<br />
进程物理地址空间可能不连续<br />
如果有可用的物理内存，它将分给进程<br />
把物理内存分成大小固定的块，称为帧（Frame）<br />
大小为2的幂<br />
早期：512字节至8192字节<br />
现在：4K-64K<br />
把逻辑内存也分为同样大小的块，称为页（Page）<br />
系统保留所有空闲帧的记录<br />
运行一个有N页大小程序，需要找到N个空帧来装入程序<br />
建立一个页表，把逻辑地址转换为物理地址<br />
存在内碎片<br />
<code>内存保护   内存的保护由与每个帧相连的保护位来实现   有效-无效位附在页表的每个表项中:   “有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页   “无效”表示页不在进程的逻辑地址空间中</code>共享代码<br />
如果代码是可重入代码（只读），可以在进程间共享 (如文本编辑器, 编译器, 数据库系统)<br />
共享代码必须出现在所有进程的逻辑地址空间的相同位置<br />
`私有代码和数据<br />
每个进程保留一个代码和数据副本<br />
存有私有数据和代码的页能够出现在逻辑地址空间的任意位置</p>
<h3 id="页表的层次结构">页表的层次结构</h3>
<h4 id="二层页表">二层页表</h4>
<p>内存的保护由与每个帧相连的保护位来实现<br />
有效-无效位附在页表的每个表项中:<br />
“有效”表示相关的页在进程的逻辑地址空间，并且是一个合法的页<br />
“无效”表示页不在进程的逻辑地址空间中<br />
<img src="/images/obsidian/20230605104632.png" title="image" alt="图片" /></p>
<h4 id="哈希页表">哈希页表</h4>
<p>虚拟页号被散列到一个页表中。这种页表的每一个条目都包括了一个链表元素，这些元素哈希成同一<br />
虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。<br />
虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。</p>
<h4 id="反向页表">反向页表</h4>
<p>对于每个真正的内存页或帧有一个条目。<br />
每个条目保存在真正内存位置的页的虚拟地址，以及包括拥有这个页的进程的信息。<br />
`优缺点<br />
减少了需要储存每个页表的内存，但是当访问一个页时，增加了寻找页表需要的时间。<br />
使用哈希表来将查找限制在一个或少数几个页表条目。<br />
实现共享内存困难</p>
<h4 id="段页式原理">段页式原理</h4>
<p>分段和分页原理的结合<br />
先将用户程序分成若干个段，再把每个段分成若干个页，并为每个段赋予一个段号<br />
逻辑地址：&lt;段号，页号，页内偏移&gt;<br />
存在内碎片<br />
无外碎片</p>
<h3 id="内存扩充技术">内存扩充技术</h3>
<ol type="1">
<li>紧缩Compaction（可变分区）<br />
</li>
<li>覆盖技术Overlaying<br />
</li>
<li>交换技术Swapping<br />
</li>
<li>虚拟内存Virtual Memory</li>
</ol>
<h4 id="覆盖">覆盖</h4>
<p>解决问题à程序大小超过物理内存总和<br />
程序执行时<br />
只在内存中保留那些在任何时间都需要的指令和数据<br />
程序的不同部分在内存中相互替换<br />
由程序员声明覆盖结构，不需要操作系统的特别支持<br />
覆盖结构的程序设计很复杂<br />
应用于早期的操作系统</p>
<h4 id="交换-1">交换</h4>
<p>在多道程序环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况<br />
另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况<br />
浪费资源，降低系统吞吐量。<br />
一个进程可以暂时被交换（swap）到内存外的一个备份区，随后可以被换回内存继续执行<br />
备份区—是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘；必须提供对这些内存映像的直接访问<br />
交换（备份区）：系统指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问</p>
<h2 id="系统模型">系统模型</h2>
<p>资源类型 R1, R2, . . ., Rm<br />
CPU周期，内存空间，I/O设备<br />
每一种资源Ri 有Wi  种实例<br />
每一个进程通过如下方法来使用资源<br />
申请，使用，释放<br />
资源动态申请-常用方法<br />
在进程运行过程中申请资源<br />
资源静态申请<br />
在进程运行前一次申请所有资源</p>
<h2 id="必要条件">必要条件</h2>
<p>死锁指一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组中其他进程所持有的资源</p>
<ul>
<li>互斥：一次只有一个进程可以使用一个资源<br />
</li>
<li>占用并等待：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源<br />
</li>
<li>非抢占：一个资源只有当持有它的进程完成任务后，自由的释放<br />
</li>
<li>循环等待：等待资源的进程之间存在环 {P0, P1, …, P0}</li>
</ul>
<h2 id="资源分配图">资源分配图</h2>
<p>被分为两个部分<br />
P = {P1, P2, …, Pn}, 含有系统中全部的进程<br />
R = {R1, R2, …, Rm}, 含有系统中全部的资源<br />
请求边：有向边Pi-&gt;Rj<br />
分配边：有向边Ri-&gt;P</p>
<ul>
<li>如果图没有环，那么不会有死锁<br />
</li>
<li>如果图有环<br />
如果每一种资源类型只有一个实例，那么死锁发生<br />
如果一种资源类型有多个实例，可能死锁<br />
<img src="/images/obsidian/20230604203017.png" title="image" alt="图片" /></li>
</ul>
<h2 id="死锁处理的分类">死锁处理的分类</h2>
<ul>
<li>确保系统永远不会进入死锁状态<br />
死锁预防<br />
死锁避免<br />
</li>
<li>允许系统进入死锁状态，然后检测它，并加以恢复<br />
死锁检测<br />
死锁恢复<br />
</li>
<li>忽略这个问题，假装系统中从未出现过死锁。<br />
这个方法被大部分的操作系统采用，包括UNIX、Windows<br />
由开发人员自行处理死锁</li>
</ul>
<h3 id="预防">预防</h3>
<p>`抑制死锁发生的必要条件</p>
<ul>
<li>互斥：可共享资源不涉及死锁，互斥资源必须强制互斥<br />
</li>
<li>持有并等待：保证进程申请资源时不占有其他资源，要求进程在执行前一次性申请全部资源，或者只有不占有资源时才可以分配资源，`可能出现饥饿<br />
</li>
<li>抢占：</li>
</ul>
<ol type="1">
<li>如果一个进程的申请没有实现，它要释放所有占有的资源<br />
</li>
<li>先占的资源放入进程等待资源列表中<br />
</li>
<li>进程在重新得到旧的资源的时候可以重新开始<br />
</li>
<li>进程申请资源时，如果资源可用则分配，如果不可用，检查资源是否被分配给等待额外资源的其他进程，如果是，抢占资源，否则，申请进程等待</li>
</ol>
<ul>
<li>循环等待:对所有资源完全排序，进程按顺序申请资源<br />
银行家算法</li>
</ul>
<h3 id="避免">避免</h3>
<ul>
<li>一个简单而有效的模型要求每一个进程声明它所需要的资源的最大数<br />
</li>
<li>死锁避免算法动态检查资源分配状态以确保循环等待条件不可能成立<br />
</li>
<li>资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量所决定</li>
</ul>
<h4 id="安全状态">安全状态</h4>
<p>当进程申请一个有效的资源的时候，系统必须确定分配后是安全的<br />
如果存在一个安全序列，系统处于安全态<br />
进程序列&lt;P1, P2, …, Pn&gt;是安全的，如果每一个进程Pi所申请的可以被满足的资源数加上其他进程所持有的该资源数小于系统总数<br />
如果 Pi 需要的资源不能马上获得，那么Pi 等待直到所有的Pi-1进程结束。<br />
当Pi-1 结束后， Pi获得所需的资源，执行、返回资源、结束。<br />
当Pi结束后， Pi+1获得所需的资源执行，依此类推。<br />
`定理<br />
如果一个系统在安全状态，就没有死锁<br />
如果一个系统不是处于安全状态，就有可能死锁<br />
避免=&gt;确保系统永远不会进入不安全状态</p>
<h4 id="银行家算法">银行家算法</h4>
<ul>
<li>多个实例<br />
</li>
<li>每一个进程必须事先声明使用的最大量<br />
</li>
<li>当一个进程请求资源，它可能要等待<br />
</li>
<li>当一个进程得到所有的资源，它必须在有限的时间释放它们</li>
</ul>
<pre><code>Available:  长度为 m的向量。 如果available[j]=k,那么资源Rj有k个实例有效  
Max: n x m 矩阵。 如果Max[i,j]=k,那么进程Pi最多可以请求k个资源Rj的实例  
Allocation:  n x m 矩阵。 如果Allocation[i,j]=k,那么进程Pj当前分配了k个资源Rj的实例  
Need:  n x m 矩阵。如果Need[,j]=k,那么进程Pj还需要k个资源Rj的实例  
Need [i,j] = Max[i,j] – Allocation [i,j].  
1.让Work和Finish作为长度为m和n的向量初始化：  
Work := Available  
Finish [i] = false for i - 1,2,3, …, n.  
2.  查找i  
(a) Finish [i] = false  
(b) Needi £ Work  
If no such i exists, go to step 4.  
3.  Work := Work + Allocationi    
Finish[i] := true    
go to step 2.  
4.  如果对所有i的 Finish [i] = true, 则系统处在安全状态。  </code></pre>
<p>   Requesti =进程 Pi 的资源请求向量.  如果Requesti [m] = k 则进程 Pi 想要资源类型为Rjm的k个实例<br />
1.  如果 Requesti £ Needi 转 step 2.  否则报错, 因为进程请求超出了其声明的最大值<br />
2.  如果 Requesti £ Available, 转 step 3.  否则 Pi  必须等待, 因为资源不可用.<br />
3.  假设通过修改下列状态来分配请求的资源给进程Pi :<br />
  Available := Available - Requesti;<br />
  Allocationi := Allocationi + Requesti;<br />
  Needi := Needi – Requesti;;<br />
 <br />
•如果系统安全 Þ 将资源分配给 Pi.<br />
•如果系统不安全 Þ Pi 必须等待，恢复原有的资源分配状态</p>
<h3 id="死锁检测和恢复">死锁检测和恢复</h3>
<p><code>每个资源类型有一个实例</code>：维护进程等待图<br />
<code>每个资源类型有多个实例</code>：用available和finished数组探查是否死锁<br />
允许进入死锁状态并加以恢复<br />
维护等待图<br />
节点是进程<br />
Pi-&gt;Pj表明Pi在等待Pj<br />
定期调用算法来检查是否有环<br />
一个检查图中是否有环的算法需要n^2的操作来进行，n为图中的节点数<br />
Available ：一个长度为m的向量，表示每一种资源类型可用的实例数目<br />
Allocation:  一个n x m 的矩阵，定义了当前分配的每一种资源类型的实例数目<br />
Request: 一个n x m 的矩阵，表明了当前的进程请求。如果Request[i，j]=k，那么进程Pi请求k个资源Rj的实例</p>
<pre><code>1.  让Work和Finish作为长度为m和n的向量初始化  
(a) Work = Available  
(b)  For i = 0,2, …, n-1, if Allocationi ¹ 0, thenFinish[i] = false;otherwise, Finish[i] = true.  
  
2.  找到满足下列条件的下标i  
(a)  Finish[i] = false  
(b)  Requesti &lt;= Work  
如果没有这样的i存在，转4  
  
3.  Work = Work + Allocationi    
Finish[i] = true    
转 2.  
  
4.如果有一些i (0 £ i &lt; n) , Finish[i] = false, 则系统处在死锁状态。而且， 如果 Finish[i] = false, 则进程 Pi 是死锁的。  </code></pre>
<p>`算法需要m x n^2 次操作来判断是否系统处于死锁状态</p>
<h4 id="恢复">恢复</h4>
<p>可以一次中断所有进程排查，也可以一个一个终结进程<br />
选择牺牲进程：最小化代价<br />
回滚：返回到安全的状态，然后重新开始进程<br />
饥饿：同样进程的可能总是被选中。在代价因素中加入回滚次数</p>
<h2 id="虚拟内存概念">虚拟内存概念</h2>
<p><code>局部性原理</code>：在一较短的时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域<br />
一个程序只要部分装入内存就可以运行<br />
整个程序不是同一时间都要运行<br />
`程序部分装入技术优点<br />
进程大小不再受到物理内存大小限制<br />
每个进程需要的内存更小<br />
更多进程可以并发运行<br />
I/O更少</p>
<ul>
<li>虚拟存储技术：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存执行。<br />
</li>
<li>虚拟地址空间：分配给进程的虚拟内存<br />
</li>
<li>虚拟地址：在虚拟内存中指令或数据的位置<br />
</li>
<li>虚拟内存：把内存和磁盘有机结合起来使用，得到一个容量很大的“内存”，即虚存<br />
<code>特点   只有部分运行的程序需要在内存中   逻辑地址空间能够比物理地址空间大   允许多个进程享同一地址空间   允许更有效的进程创建</code>虚拟内存能够通过以下手段来执行实现:<br />
虚拟页式（虚拟存储技术+页式存储管理）<br />
虚拟段式（虚拟存储技术+段式存储管理）<br />
`虚拟页式有两种方式<br />
按需调页（ Demand paging ）<br />
预调页（Prepaging）</li>
</ul>
<h2 id="虚拟页式存储管理">虚拟页式存储管理</h2>
<p><code>基本思想   进程开始运行之前，不是装入全部页面，而是装入一个或零个页面   运行之后，根据进程运行需要，动态装入其他页面   当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面</code>请求分页（按需调页）<br />
只有在一个页需要的时候才把它换入内存<br />
需要很少的I/O<br />
需要很少的内存<br />
快速响应<br />
多用户<br />
<code>懒惰交换</code>:只有在需要页时，才将它调入内存<br />
交换程序(swapper)对整个进程进行操作<br />
调页程序(pager)只是对进程的单个页进行操作</p>
<h3 id="有效无效位">有效无效位</h3>
<p>每一个页表的表项有一个有效- 无效位相关联：<br />
1表示在内存，0表示不在内存<br />
在所有的表项中，这个位被初始化为0<br />
一个页表映象的例子</p>
<h3 id="缺页中断的处理">缺页中断的处理</h3>
<p>1.访问指令或数据<br />
2.查看另一个表来决定:<br />
无效引用 Þ 终止<br />
仅仅不在内存<br />
3.找到页在后备存储上的位置<br />
4.得到空的页框，把页换入页框<br />
5.重新设置页表，把有效位设为v<br />
6.重启指令</p>
<pre><code>极端情况：进程执行第一行代码时，内存内没有任何代码和数据  
进程创建时，没有为进程分配内存，仅建立PCB  
导致缺页中断  
纯请求分页（纯粹按需调页）  
  
一条指令可能导致多次缺页（涉及多个页面）  
幸运的是，程序具有局部性（locality of reference）  
  
请求调页需要硬件支持  
带有效无效位的页表  
交换空间  
指令重启  
  
缺页率（缺页的概率）：0 &lt;= p &lt;= 1.0  
如果 p = 0 ，没有缺页  
如果 p = 1， 每次访问都缺页  
  
有效访问时间（ EAT ）  
    EAT = (1 – p) x 内存访问时间+ p x 页错误时间  
  
页错误时间=处理缺页中断  
  + [页交换出去时间 ]  
  + 读入页时间  
  + 重启进程开销  </code></pre>
<p><code>性能优化</code>：<br />
页面转换时采用交换空间，而不是文件系统<br />
交换区的块大，比文件系统服务快速</p>
<p>在进程装载时，把整个进程拷贝到交换区<br />
基于交换区调页<br />
早期的 BSD Unix</p>
<p>利用文件系统进行交换<br />
Solaris和当前的BSD<br />
部分内容仍旧需要交换区（堆栈等）<br />
<code>写时复制</code>:允许父进程和子进程在初始化时共享页面<br />
如果其中一个进程修改了一个共享页面，会产生副本<br />
更加高效<br />
应用在Windows，Linux，macOS等系统</p>
<h3 id="需要页置换的情况">需要页置换的情况</h3>
<p>页置换—找到内存中当前没有使用的一些页，换出<br />
同一个页可能会被装入内存多次<br />
基本页置换方法</p>
<ol type="1">
<li>查找所需页在磁盘上的位置<br />
</li>
<li>查找一空闲帧<br />
如果有空闲帧，就使用它<br />
如果没有空闲帧，使用页置换算法选择一个“牺牲”页框<br />
将“牺牲”帧的内容写到磁盘上，更新页表和帧表<br />
</li>
<li>将所需页读入（新）空闲帧，更新页表和帧表<br />
</li>
<li>重启用户进程</li>
</ol>
<p>如果发生页置换，则缺页处理时间加倍<br />
使用修改位modify bit或脏 (dirty bit) 来防止页面转移过多—只有被修改的页面才写入磁盘<br />
页置换完善了逻辑内存和物理内存的划分—在一个较小的物理内存基础之上可以提供一个大的虚拟内存</p>
<h2 id="页面置换算法">页面置换算法</h2>
<h3 id="先进先出fifo算法">先进先出(FIFO)算法</h3>
<p>置换在内存中驻留时间最长的页面<br />
容易理解和实现、但性能不总是很好<br />
实现：使用FIFO队列管理内存中的所有页<br />
FIFO算法可能会产生Belady异常<br />
更多的页框 =&gt;更多的缺页</p>
<h3 id="最优置换算法opt">最优置换算法OPT</h3>
<p>被置换的页是将来不再需要的或最远的将来才会被使用的页<br />
实现？<br />
作用：作为一种标准来衡量其它算法的性能</p>
<h3 id="最近最少使用算法lru">最近最少使用算法(LRU)</h3>
<p>置换最长时间没有使用的页<br />
性能接近OPT<br />
实现：计数器（时间戳）或栈<br />
开销大、需要硬件支持<br />
栈实现—在一个双链表中保留一个记录页数目的栈:<br />
被访问的页:<br />
移到栈顶<br />
需要改变6个指针<br />
没有为置换进行查找</p>
<p>在没有硬件支持的系统中，可使用LRU近似算法访问位<br />
每个页都与一个位相关联，初始值为0<br />
当页访问时设位1</p>
<ul>
<li>附加引用位算法<br />
</li>
<li>二次机会算法<br />
</li>
<li>增强型二次机会算法</li>
</ul>
<h3 id="二次机会算法">二次机会算法</h3>
<p>需要访问位<br />
如果访问位为0，直接置换<br />
如果将要交换的页访问位是1，则:<br />
把访问位设位0<br />
把页留在内存中<br />
以同样的规则，替换下一个页</p>
<p>实现：时钟置换（顺时针方式）</p>
<h3 id="基于计数的页面置换">基于计数的页面置换</h3>
<p>用一个计数器记录对每一个页的访问次数<br />
LFU 以最小的计数置换一个页</p>
<h3 id="页面缓冲算法">页面缓冲算法</h3>
<ol type="1">
<li>总是保留一个空闲帧缓冲池</li>
</ol>
<ul>
<li>在缺页错误时有帧可用<br />
</li>
<li>读页面到空闲帧，无需等待写出牺牲帧<br />
</li>
<li>牺牲帧以后被写出后，添加到缓冲池</li>
</ul>
<ol start="2" type="1">
<li>扩展之一，维护一个修改页面的列表</li>
</ol>
<ul>
<li>当设备空闲时选择一个修改页面写到磁盘上，然后重置它的修改位</li>
</ul>
<ol start="3" type="1">
<li></li>
<li>另一种修改,保留一个空闲帧池，并且记着哪些页面在哪些帧内</li>
</ol>
<ul>
<li>如果在重用之前被再次需要，就不需要从磁盘上重新装载了<br />
</li>
<li>降低因错误选择牺牲页面而引起的开销</li>
</ul>
<h2 id="帧分配">帧分配</h2>
<p>两种主要分配策略</p>
<ul>
<li>固定分配<br />
</li>
<li>优先分配</li>
</ul>
<h3 id="固定分配">固定分配</h3>
<p>平均分配 Equal allocation– 例如，如果有100帧和5个进程，给每个进程20帧<br />
在缓冲池里保存空闲帧<br />
比例分配 Proportional allocation – 根据进程大小分配内存<br />
按照多道程度而动态分配，进程分得的数量变化</p>
<h3 id="优先级分配">优先级分配</h3>
<p>优先级分配:用优先级而不是大小来进行比例分配<br />
如果进程 Pi 跑出页面错误,<br />
从自己的帧里选择一个替代<br />
从优先级较低的进程里选择一个替代</p>
<h3 id="全局-vs.-局部分配">全局 vs. 局部分配</h3>
<p>全局置换 Global replacement – 允许进程从所有帧的集合中选择一个置换帧；一个进程可以从另一个进程那里获取帧<br />
但是进程执行时间可能变化很大，不能控制缺页错误率<br />
有更好的系统吞吐量，更常用<br />
局部置换 Local replacement – 每个进程只从它自己分配的帧中进行选择<br />
对每个进程的表现更一致<br />
但是可能内存低利用</p>
<h4 id="非均匀内存访问numa">非均匀内存访问（NUMA）</h4>
<pre><code>v以上假设所有内存可以被平等访问  
  
v很多系统如 NUMA – 内存访问速度变化的  
  
考虑CPU和内存在系统中通过总线互连  
  
v让分配的内存帧‘尽可能地靠近’运行进程的CPU  
  
通常意味着位于同一系统扳  
  
Solaris通过在内核中创建延迟组 lgroups  
  
v将相近的CPU和内存聚集在一起  
  
v在组内调度进程的所有线程，并分配它的所有内存  
  
v最大限度减少总体内存延迟，最大化CPU缓存命中率  </code></pre>
<h2 id="抖动">抖动</h2>
<p>如果一个进程没有足够的页，那么缺页率将很高，这将导致:<br />
CPU利用率低下.<br />
操作系统认为需要增加多道程序的道数<br />
系统中将加入一个新的进程<br />
颠簸（抖动）=一个进程的页面经常换入换出<br />
原因：分配的帧数 &lt; 局部大小之和</p>
<h3 id="工作集模型">工作集模型</h3>
<p>工作集窗口 º 固定数目的页的引用<br />
WSSi (进程Pi的工作集) = 最近D中所有页的引用 (随时间变化)<br />
<img src="/images/obsidian/20230605190700.png" title="image" alt="图片" /><br />
vExample: D = 10,000</p>
<p>每5000个时钟单位时钟中断</p>
<p>为每个页在内存中保留两个位</p>
<p>任何时候一个时钟中断拷贝，把所有访问位设为0</p>
<p>如果一个在内存中的位是0，说明页在工作集</p>
<h3 id="内存映射文件">内存映射文件</h3>
<p>通过映射一个磁盘块成内存的一页，内存映象文件I/O 允许文件I/O 作为普通内存访问。<br />
开始的文件访问按普通请求分页来进行，一页大小的部分文件从文件系统读入物理页。以后文件的读、写操作就按通常的内存访问来处理。<br />
由于通过内存的文件操作而不是使用系统调用read() write() ，简化了文件访问和使用。<br />
多个进程可以允许将同一文件映射到各自的虚拟内存中，以允许数据共享</p>
<h2 id="内核内存分配">内核内存分配</h2>
<p>通常从空闲内存池中获取<br />
内核需要为不同大小的数据结构分配内存<br />
一些内核内存需要连续的物理页</p>
<pre><code>v内核在使用内存块时有如下特点：  
  
    (1)内存块的尺寸比较小；  
  
    (2)占用内存块的时间比较短；  
  
    (3)要求快速完成分配和回收；  
  
    (4)不参与交换。  
  
    (5)频繁使用尺寸相同的内存块，存放同一结构的数据；  
  
    (6)要求动态分配和回收。  
   ```  
### 伙伴(Buddy)系统  
v主要用于Linux早期版本中内核底层内存管理  
v一种经典的内存分配方案  
v从物理上连续的大小固定的段上分配内存  
v主要思想：内存按2的幂的大小进行划分，即4KB、8KB等，组成若干空闲块链表；查找链表找到满足进程需求的最佳匹配块  
满足要求是以2的幂为单位的  
如果请求不为2的幂，则需要调整到下一个更大的2的幂  
当分配需求小于现在可用内存时，当前段就分为两个更小的2的幂段，继续上述操作直到合适的段大小  
`算法  
首先将整个可用空间看作一块: 2^n  
假设进程申请的空间大小为s，如果满足  
2^(n-1)&lt;s&lt;=2^n，则分配整个块  
   否则，将块划分为两个大小相等的伙伴，大小为2^(n-1)  
一直划分下去直到产生大于或等于s的最小块  
  
### Slab 分配  
v内核分配的另一方案  
vSlab 是由一个或多个物理上连续的页组成  
vCache 含有一个或多个 slab  
v每个内核数据结构都有一个cache  
每个 cache 含有内核数据结构的对象实例  
  
v当创建 cache 时, 包括若干个标记为空闲的对象  
v当内核对象时，从cache上直接获取，并标识对象为使用  
v当一个slab充满了已使用的对象时，下一个对象的分配从空的slab开始分配  
如果没有空的slab, 则从物理连续页上分配新的slab  
v优点  
①没有因碎片而引起的内存浪费  
  
②内存请求可以快速满足  
  
## 杂项  
`预调页面  
v在进程启动初期，减少大量的缺页中断  
v在引用前，调入进程的所有或一些需要的页面  
v如果预调入的页面没有被使用，则内存被浪费  
`页面尺寸大小  
v碎片 – 需要小的页  
v表大小 – 需要大的页  
vI/O 开销 – 需要大的页  
v程序局部 – 需要小的页  
v缺页次数 – 需要大的页  
v其他因素  
没有最佳答案，总的来说，趋向更大的页  
`TLB 范围  
vTLB 范围 – 通过TLB所访问的内存量  
vTLB 范围 = (TLB 大小) X (页大小)  
v理想情况下，一个进程的工作集应存放在 TLB中  
否则会有大量的缺页中断  
v增加页的大小  
对于不需要大页的应用程序而言，这将导致碎片的增加  
v提供多种页的大小  
这允许需要大页的应用程序有机会使用大页而不增加碎片的大小  
`倒置页表  
v倒置页表降低了保存的物理内存  
v不再包括进程逻辑地址空间的完整信息  
v为了提供这种信息，进程必须保留一个外部页表  
v外部页表可根据需要换进或换出内存  
`I/O 联锁与页面锁定  
v允许某些页在内存中被锁住  
  
vI/O时，正在进行I/O的页面不允许被置换算法置换出内存  
`linux  
vSLAB  
vDemand paging  
vGlobal page replacement(LRU)  
v两个帧列：active_list和inactive_list  
vKswapd daemon  
定期检查  
`windows10  
vBoth IA-32 and x86-64  
v32bit支持4GB，64bit支持128TB内存  
vShared memory, demand paging, copy-on-write, paging和memory compression  
v按需调页-clustering，预调入3-7页  
vWorking-Set 管理（最少50-最多345页）  
  
## 文件概念  
`文件  
计算机中信息存储的基本组织形式  
相关信息结合  
具有文件名  
`文件名  
按名存取：文件名     存储位置  
文件名由一串ASCII码或(和)汉字构成  
名字长度  
v8.3规则：文件名8个字符，类型3个字符，之间有“.”分割  
v长文件名：可以最多输入255多个字符作为文件名  
文件名可能大小写敏感  
`文件的打开  
v需要数据结构  
打开文件表：跟踪打开文件  
文件指针:指向最后一次读写的位置，每个进程1个  
打开文件计数器：打开文件次数（调用open次数）  
文件存储位置：文件存放在存储设备上的位置信息  
访问权限：每个进程的访问权限  
v优点  
方便文件共享  
提高文件存取效率  
`文件锁  
共享锁 Shared lock 类似于读者锁– 多个进程可以并发获取它。  
独占锁 Exclusive lock 类似于写者锁  
`文件结构  
v目的：便于程序理解文件内容  
无结构：文字流、字节流等  
简单记录结构：线性、固定长度、可变长度等  
复杂结构：格式化文档、多媒体文件等  
v谁决定了文件结构  
操作系统  
程序  
  
## 文件访问  
  
### 逻辑文件  
v文件呈现在用户面前的组织结构  
v又称为文件逻辑结构  
v逻辑文件决定了文件访问方法  
`文件访问方式  
- 顺序访问  
最简单的访问方式  
文件信息按照存放顺序，一个记录一个记录地依次访问  
顺序文件  
典型存储设备：磁带  
- 直接（随机）访问  
可以直接定位到文件的某条记录进行访问  
直接文件  
典型设备：磁盘  
v访问方式：直接（随机）访问  
v直接通过计算得到需要读写记录的位置，直接跳转进行文件读写  
- 索引文件  
v基本方法：为顺序文件建立索引表  </code></pre>
<p>记录平均长度：40B   索引表项大小：4B   1M条记录长度：44MB</p>
<p>访问第1万条记录：</p>
<p>       1）计算得到第1万条记录的索引项在索引表中首址：10000*4=40000</p>
<p>       2）从索引表地址40000处读入4个字节，内容为第1万条记录在顺序文件中的首址P</p>
<p>       3）从顺序文件地址P处读入40个字节（假如第1万条记录长度为40B）</p>
<p>合计读入：4+40=44B</p>
<p>```</p>
<h2 id="目录结构">目录结构</h2>
<h3 id="文件控制块fcb">文件控制块（FCB）</h3>
<p>存放操控文件所需的各类文件属性信息<br />
文件名<br />
长度<br />
创建时间<br />
存放位置<br />
访问控制权限<br />
类似一个索引项<br />
v目录项<br />
存放一个文件的各类属性<br />
有的系统等同于文件控制块<br />
v目录<br />
包含着所有文件信息的节点集合<br />
根据文件名检索文件的桥梁<br />
目录项的有序集合<br />
v目录文件<br />
目录组织形式<br />
目录作为一个文件存在于文件系统<br />
v每个目录项中存放了文件在存储设备的存放地址<br />
v目录和文件都驻留在存储设备（如磁盘）</p>
<h3 id="文件检索">文件检索</h3>
<p>v文件检索是一个遍历目录项的过程<br />
1.打开目录文件<br />
2.从磁盘读入该目录文件的1个(物理)块，该块包含若干个目录项<br />
3.根据文件名遍历内存中的该块，如找到则结束<br />
4.判断该目录文件是否还有物理块没有读入，如果是转2；否则，结束。表示该目录中没有此文件名的文件<br />
v目录项由于经常变化，一般不排序<br />
v平均遍历目录项数：       （1+n）/2<br />
  不包括文件查不到的情况<br />
  <br />
  目录项大小= ds bytes<br />
目录中最多文件数 = n<br />
物理块大小 = b<br />
v那么<br />
目录文件大小 = ds*n bytes<br />
目录文件需要的物理块数目 = ds*n/b<br />
检索一个文件需要平均读入的块数=(ds*n/b+1)/2</p>
<h3 id="目录结构-1">目录结构</h3>
<p><code>设计目标   v效率   快速定位文件位置   提高文件访问效率   v命名   方便用户使用   同名的不同文件   不同名的相同文件   v分组   文件分组（子目录）   兼顾效率和方便性</code>单层目录<br />
v所有文件在同一目录中，只有一级目录：根目录<br />
v根目录（/）：一个文件系统最顶层的目录<br />
v优点：结构简单<br />
v缺点<br />
检索效率差（目录下文件过多）<br />
不能有同名文件，一个文件只能有一个名称<br />
不能分组<br />
<code>双层目录   v每个用户有自己的目录结构   v目录下的目录   v缺点：1）无法分组；2）同一用户不能有相同文件名的文件   v优点：1）不同用户可有相同文件名的文件；2）比单层目录提高检索效率（文件分布在多个用户目录中）</code>树形目录<br />
v特点<br />
检索高效（子目录增多导致每个目录下文件减少）<br />
可以分组<br />
允许重名<br />
v当前目录：工作目录<br />
cd /spell/mail/prog<br />
type list<br />
v绝对路径<br />
从根开始的路径名<br />
v相对路径<br />
从当前目录开始的路径名<br />
提高检索效率<br />
<code>（有向）无环图目录   v文件共享：不同目录中的文件指向同一个物理文件，也就是它们内容相同   v树型目录不能实现文件共享   v解决方法：图型目录   无环图目录   通用图目录（有环图）   v无环图：有向边无环</code>如何保证无环？<br />
仅允许指向文件的链接，不允许指向子目录的链接<br />
垃圾回收<br />
每当加入新链接时，使用环路检测算法判断是否正确<br />
优化遍历目录算法，避免对环的重复搜索</p>
<h2 id="杂项">杂项</h2>
<p>v要访问一个文件系统，必须先安装它。<br />
一个未安装的文件系统将被安装在一个安装点(mount point)上。</p>
<h3 id="远程文件系统">远程文件系统</h3>
<p>v用网络使得远程计算机之间的联系成为可能<br />
手动传输文件如 FTP<br />
自动，直接访问文件用分布文件系统 distributed file systems<br />
半自动用万维网 world wide web<br />
vClient-server 客户机-服务器模型允许客户机登录远程服务器的文件系统<br />
服务器可以服务多台客户机<br />
识别客户可能是不安全和复杂的<br />
NFS 是标准 UNIX 下客户机-服务器的文件共享协议<br />
CIFS 是Windows下标准协议<br />
标准操作系统文件调用翻译为远程调用<br />
v分布式信息系统 (分布式命名服务 distributed naming services) 如LDAP, DNS, NIS。</p>
<h3 id="故障">故障</h3>
<p>v所有文件系统都有故障模式<br />
例如目录结构或者其他磁盘管理信息（元数据 metadata 损坏。<br />
v远程文件系统加入新的故障模式，来自网络故障或者服务器故障<br />
v从故障中恢复包含维护状态信息 state information<br />
vStateless 无状态协议如NFC在每个请求里包含所有信息，允许较为容易的故障恢复但是不够安全</p>
<h3 id="共享">共享</h3>
<p>v规定系统的多个用户如何访问共享文件<br />
类似于第六章的进程同步算法<br />
v由于磁盘和网络的巨大延迟和很慢的传输速率，倾向于没这么复杂<br />
Andrew File System (AFS) 实现了复杂共享语义<br />
Unix file system (UFS) 使用:<br />
v一个用户对已打开文件的写入，对于打开同一文件的其他用户立即可见。<br />
v一种共享模式允许用户共享文件的当前位置指针。<br />
AFS 有会话语义<br />
v一旦文件关闭，对其所作的更改只能被后来打开的会话可见。</p>
<h3 id="访问控制权限和分组">访问控制权限和分组</h3>
<p>v访问模式：读/写/执行<br />
v三种类型的用户<br />
  RWX<br />
  a) 所有者  7  =&gt;1 1 1    RWX<br />
  b) 组用户  6  =&gt;  1 1 0 RWX<br />
  c) 公共用户  1  =&gt;  0 0 1<br />
v建立一个组，加入一些用户<br />
v对特定的文件或目录(game) ，定义适当的访问权限</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>苏州大学</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls剧情解析</title>
    <url>/thinklive/48368/</url>
    <content><![CDATA[<h1 id="彩蛋">彩蛋</h1>
<p>作为博客的特别彩蛋，来说说在bgm选取上的小心思，当然，放bgm是个人兴趣，会刻意地选一些与文案内容互相对照的东方曲</p>
<h2 id="冬之钟">冬之钟</h2>
<p>开场音乐： 雪原烟海(原曲：驹草盛开的万年积雪)<br />
因为说的是冬之钟，放这首曲子很贴切</p>
<p>forget me(原曲：熙攘市场今何在)<br />
歌词立意和h结局最后与爱丽丝的告别很切合</p>
<p>梅贝尔部分bgm:<br />
帕琪的世界(原曲：少女密室)<br />
知识与避世的紫色少女和沉迷混沌迷宫的梅贝尔很像吧</p>
<p>红偶像部分bgm:<br />
A.L.I.C.E(原曲：不可思议之国的爱丽丝)<br />
爱丽丝爱丽丝爱丽丝爱丽丝爱丽丝爱丽丝</p>
<p>白兔诺登bgm:<br />
不可視隠月 - Pupil of Frenzy(原曲:狂气之瞳)<br />
都是让人疯狂的兔子，以及狂气之瞳魔性的旋律和齿轮声很配</p>
<p>光之都(原曲:千年幻想乡)<br />
永琳身为神明，却舍弃了一切帮助辉夜逃走，看到诺登不可避免地会想到这段故事</p>
<span id="more"></span>
<h2 id="人物解析部分">人物解析部分</h2>
<p>尸龙姐姐的bgm:<br />
Eternal garden(原曲:笼中鸟)<br />
永远的禁锢与独占</p>
<p>虫虫的bgm:<br />
Purlieu(原曲：神圣庄严的古战场)<br />
这是一首描述反叛不公命运的歌</p>
<p>祈りの器(原曲:寄世界于偶像)<br />
是一首描述造物主与其造物的歌，当然袿姬可比虫虫鉴多了，其实同专另一首寄世界同人曲在歌词上更合适，但太激烈了不适合做bgm</p>
<p>欲见(原曲：古老的元神)<br />
欲见的歌词比较抽象，但在我看来是顺应欲望，从心所欲之人的自白，也很适合虫虫，当然我还是要说，娘娘哪怕作为反派也比虫虫鉴多了(大概？)</p>
<h2 id="原著梗解析部分">原著梗解析部分</h2>
<p>原著梗的选曲其实比较随意，毕竟没有特定主题，不好发挥</p>
<p>01:<br />
Artful Colors(原曲:人偶裁判 ~ 玩弄人形的少女)<br />
旧作爱丽丝要用，新作爱丽丝也要用，这样才称得上健全</p>
<p>02:<br />
Which one(原曲:魔法使的忧郁)<br />
其实曲子和内容没什么关系，但这首歌轻幻缥缈的曲风很喜欢</p>
<p>03：<br />
White Pieces(原曲:少女密室)<br />
书，梦，轮回，歌词的要素过于齐全，所以用了</p>
<p>ENDLESS FANTASY(原曲：死亡狂想曲)<br />
无尽的幻想，弑神，无法原谅的背叛，世界的终结，要素齐全</p>
<p>04：<br />
Timeless Dissonance(原曲:法界之火)<br />
歌词很适合用来描述罗丽娜，事实上为了更切合，我改动了一些网易云上的翻译</p>
<p>拾遗篇：<br />
Redeemer(原曲:亡失的感情)<br />
一首描写至死不渝爱恋的歌</p>
<p>如梦中浮现的我(原曲:少女幻葬)<br />
八云家bgm一直傻傻分不清(悲)，不过歌词描写的是如浮沫般消散的幻梦之爱，和bs中的0号爱丽丝很切合(大概)</p>
<p>ex01:<br />
静寂ラストダンス(原曲:哈德曼的妖怪少女)<br />
她是谎言编织的噩梦，终与黑暗融为一体。</p>
<p>ex02:<br />
Common destiny ~ 一蓮托生(原曲:未知の花 魅知の旅)<br />
描述了虚幻缥缈的消失，很适合作为对爱丽丝原著部分的收尾</p>
<p>ex03:<br />
End of Daylight(原曲:同名)<br />
蛇鲨记这种难以理解的小说，很适合配上多少有点晦暗的音乐</p>
<h2 id="npc-dreams">npc dreams</h2>
<p>桃始华,仓庚鸣,鹰化为鸠(原曲:魔法少女百年祭)<br />
"余念 不息 似不变 绝境里复燃 业火"很好地概括世界观与剧情</p>
<h1 id="冬之钟-1">冬之钟</h1>
<p>由于black souls的故事远远没有完结，因此现阶段我们很难对<code>红白女王</code>与<code>梅贝尔</code>这些与格林牵扯极深的支配者们进行什么定论，只能就已有的剧情和文本进行一些归纳，本期视频我将就bs2比较难懂的一处地方，冬之钟的主线事件，进行一些个人向的分析。<br />
在冬之钟最后一章地图能遇到5个白熊，白熊的身份迄今为止依然是谜团，但他们提供了整整五段发生在支配者之间的重要对话，我将概括一下这五段对话提供的主要信息以便进一步的分析<br />
我们按解包后的地图顺序开始，<br />
第一段对话发生于<code>梅贝尔</code>和妹妹爱丽丝之间，可以猜测妹妹爱丽丝属于支配者之一，数量众多的支配者都在奈亚的箱庭占据一个角色以便和格林繁殖，但随着时间推移，支配者们发现扮演角色的同时，他们也在被角色同化（<code>梅贝尔</code>所言），因此纷纷退场，妹妹爱丽丝也逐渐被角色影响对格林产生好感，此外，姐姐爱丽丝不知何故地退场。<br />
第二场对话发生于<code>梅贝尔</code>和白之女王之间，对话中提及冬之钟正是白女王的箱庭，而白之女王由于爱上了格林自愿放弃女王的身份去守护他，而<code>梅贝尔</code>则对这场追寻爱的闹剧，以及陪着胡闹的其他支配者感到无聊，向白女王提出一个让格林摆脱循环，并且能够独占他的计划。<br />
第三第四场对话都发生于红白女王之间，<code>红女王</code>为陷入痛苦轮回的格林而痛苦，不断进行自残，白女王制止了她，两人由于同样爱上格林而心意相通<br />
第四场对话则告诉我们，<code>红女王</code>接过了白女王的权王冠（推测为箱庭权限），并以此创造出库因兰德，并使其能排除奈亚的监视，两人密谋让格林挣脱循环的方法，<code>红女王</code>恳请白女王放弃对格林的独占欲，白女王同意了，此外，<code>梅贝尔</code>也知晓这一计划，并根据后面的行动来看，她不知为何也参与了这个计划<br />
第五场对话发生于白女王和玛丽苏之间，白女王夺走了玛丽苏的改变能力，并且根据混沌迷宫的情报，将其赋予了古兰剧场，玛丽苏察觉白女王爱上了格林，并且等待着格林的到来，结尾，玛丽苏等到了一个神秘人（黑山羊？）<br />
总结这些信息，我们可以推测出针对格林，一共提出了两个计划，一个是<code>梅贝尔</code>怂恿的独占计划，一个是红偶像策划的拯救计划，这两个计划都必须有<code>诺登</code>的参与，但此时我们并不知道<code>诺登</code>的真正想法是哪个<br />
在推进h结局的过程后，格林会有两个选择，1是和暗黑舞台合二为一2是打败舞台，夺取舞台的改变能力， “此时”的冬之钟虽然沉睡，但相信<code>诺登</code>依旧有一定的控制能力，然而不同于G结局的阻拦，此时的<code>诺登</code>选择了旁观，并在最后支持格林任意一个选择<br />
总结一下大致发生的事件（以下事件的时间顺序难以具体确定）<br />
1<code>诺登</code>作为支配者之一管理着自己的箱庭冬之钟，和奈亚创造自己箱庭的时间关系未知<br />
2奈亚将格林带到箱庭，邀请支配者们参加繁殖游戏，根据牛津学院人偶爱丽丝的说法，是舞台装置创造出了让格林在舞台上登场的皮套（格林的灵魂出自玛丽苏的手笔，因此推测只能创造皮套），并且在创造格林时两者间确立了深远的联系，白女王也参加了这个游戏，可以肯定白女王为了心爱的格林才舍弃了王冠（王冠可能指代管理箱庭的权能），因此推测白女王在爱上格林后可能以放弃王冠为代价，得到了管理奈亚箱庭的权限和陪伴在格林身边的权力<br />
3红偶像被奈亚切割，由于茶会时期她曾经打倒初代红之女王，因此此刻可以说她的身份是第二任红之女王，为格林自责的她不断紫餐，得到了白女王的同情，白女王将自己原来的王冠权能移交给被奈亚切割的<code>红女王</code>，让她在原冬之钟的地盘上创造出自己的箱庭。<br />
4红白女王合谋，或者其中之一从奈亚手中夺走了玛丽苏并囚禁起来，为了避免红白女王相互猜疑，二者将从玛丽苏手上得到的改变能力赋予舞台装置古兰，创造出一个新的支配者暗黑舞台，藏于处于过去时间线的冬之钟，同时由于处于过去的时间线，冬之钟几乎没有被发现的风险，通过dlc3经常出现的齿轮与其他信息可以推测，舞台装置拥有着影响整个箱庭以及舞台上大部分“演员”的能力，即在部分地图的bg和格林脑中的“齿轮声”，是不思议之国这场戏的核心，此外，由于<code>诺登</code>为了管理这个箱庭必须借助舞台的力量，而红白女王理论上权能接近，因此本视频中猜测红白女王都有部分操控舞台的权限<br />
4由于支配者们发现扮演箱庭的角色会改变自己的本质，因此纷纷退出，白女王被迫用自己和格林的子嗣填补空缺<br />
5<code>梅贝尔</code>认为这场游戏无聊透顶，一场剧本烂透的戏剧重复多少遍也只会让人厌倦（她自己是这么说的），因此她怂恿白女王让格林脱出循环，并抢先独占他<br />
6<code>红女王</code>努力让自己的领域能排除奈亚的监视，并在此向白女王提出了拯救格林的计划，这个计划<code>梅贝尔</code>也知情，白女王同意了拯救计划，我们不知道白女王听到这两个计划的顺序，但他们明显是冲突的<br />
7可能是人为，可能是自发，舞台觉醒了自我意识呼唤着格林的爱，同时在<code>梅贝尔</code>的指引下格林也朝着舞台进发，一场死斗在所难免，可以推测，在夺取舞台能力的结局中，<code>诺登</code>执行了<code>红女王</code>的拯救计划，舍身为格林断后，使其在爱丽丝01，即现在的红偶像的帮助下回到现实。在舞台与格林合一的bad end中，<code>诺登</code>执行了<code>梅贝尔</code>提出的独占计划，该结局中<code>诺登</code>辅佐着通过合体得到创作能力的格林与奈亚进行斗争，并且前往世界尽头来逃避一切纷争和毁灭，顺便一提，我觉得这结局也不算坏，白女王很可能会确保格林在融合中占据主导，此时格林成为了名副其实的支配者，和白女王的结合甚至能和奈亚势均力敌，不过寿司在采访中提到执着于爱丽丝身份的奈亚无法发挥全力就是了，毫无疑问这时的格林是目前为止的（格林）战力巅峰。<br />
这就是冬之钟里发生的主要事件了，下面我将对事件的主要参与者，红白女王和虚无的少女进行分析。<br />
首先是参与程度较低的<code>梅贝尔</code>，<code>梅贝尔</code>虽然入局较浅，但却是格林的引导者，并帮助拖延了一下奈亚，也是她告诉我们打破这一循环只能正面和舞台装置对决，那么她的目的是什么呢？<br />
首先，<code>梅贝尔</code>在混沌迷宫中会直接提及支配者间不可避免将爆发战争，并且导致阿撒托斯的苏醒毁灭一切，而身份不是支配者却可能得到支配者之器的格林，才能发动不会惊醒阿撒托斯的箱庭战争，这可能是她帮助格林的首要目的<br />
其次，<code>梅贝尔</code>是个不可救药的收藏狂，她的箱庭是个巨大的垃圾场，什么都有，因此她也想把格林培养成一个完美收藏品或者棋子<br />
最后，在个人感情上，很难定论<code>梅贝尔</code>到底产生了多少感情，她自称对永无止境的劣质戏剧循环感到厌倦，才会帮助格林创造自己的故事，但又在背叛剧情中声称想要让格林得到更高的器随后利用他，最后如果试图救她又会说自己涌现出了一些对格林的爱，由于信息过少，很难知道她到底觉醒了多少感情。<br />
不过可以肯定的是，如果是<code>梅贝尔</code>真有意背叛动机是不充分的，如果她只需要格林成为拥有支配者之器的棋子，那么独占和拯救计划都能实现这个目的，并且由于白女王看着，融合后大概率是格林占主导地位，无非是好不好操控的问题，因此猜测<code>梅贝尔</code>实际上是真心帮助格林，只是在用激将法，或者习惯性毒舌。<br />
冬之钟的棋局不管怎么走<code>梅贝尔</code>都不是输家，如果独占计划成功，白女王和格林则会成为一股对抗奈亚甚至其他支配者的强大力量，如果拯救计划成功，格林则会成为一个有着支配者的器，却对大部分支配者恨之入骨的棋子或潜在盟友，不论哪个结果都对<code>梅贝尔</code>阻止阿撒托斯苏醒的目的有利，而她的损失不过是万千分身中的一个而已<br />
随后则是红之女王，尽管游戏中没有直接说<code>红女王</code>就是一代的爱丽丝01，以及茶会中的爱丽丝，但大量证据表明她和爱丽丝01有着千丝万缕的关系，爱丽丝01也极有可能就是茶会爱丽丝，所以本视频采纳这一说法，可以说最早钻进人类皮套的她是人性化最深的支配者，她人类的一面深爱格林，但又恐惧支配者的一面暴露，因此自觉配不上格林，甚至认为是自己导致了格林的一切悲剧，顺便一提关于茶会以及更早时期的资料实在太少，所以我们现在对这段剧情的讨论很可能是不完整甚至有较大误解的，因此在此我只能尽可能保守地做一些推测，由于支配者本性难以剥离，在她身上有着强烈的自毁倾向，想爱，却又自觉没有资格去爱，因此她只能用紫餐的方式填补内心的负罪感，H结局中，她以几乎自杀的方式当着奈亚的面帮助格林逃离了奈亚的掌控，可以说为了格林，<code>红女王</code>自降身份把自己变成了棋子，而且是必死的棋子，只为了能在后续将奈亚一军。<br />
等待着这个叛徒的是什么结局，我们只能发挥一下想象力了<br />
最后则是冬之钟的核心人物，白之女王<code>诺登</code>，<code>诺登</code>的原型之一是爱丽丝梦游仙境的白兔先生，白兔最明显的元素就是他永远匆忙的样子和怀表，这点也在<code>诺登</code>身上得以体现，白女王作为这场繁殖游戏事实上的管理者，为了协调任性的演员们可谓操碎了心，在轮回的最后，台上的演员几乎全部是她的子嗣（兔子可是繁殖力非常强的生物），可以猜测在制定剧本和排练上她也得下不少功夫，而dlc3的核心意象，齿轮，其实可以说既指着暗黑舞台的齿轮带动了戏码的上演，也指着<code>诺登</code>怀表的齿轮，<code>诺登</code>就是那个负责在指针快点到达终点前让齿轮倒转，重新开始计时的人，这也是为何她会在结局中说为齿轮停止感到害怕，让齿轮转动是她的职责，在她的内心深处或许也有着对无尽循环中格林真正爱上自己并一起逃到世界尽头的希望，但最后她选择成全格林真正的爱，而放弃管理齿轮的职责则意味着她与自己支配者的身份完全决裂，将一切奉献给人类的爱。此外，<code>诺登</code>的支配者原型则是所谓的幻梦境之主，这或许解释了为何是她在实际上管理着二代这个巨大的梦境<br />
我在尸龙的人物解析说，类似尸龙的独占欲在红白女王身上也出现过，但<code>红女王</code>由于害怕自己的支配者本性选择放手，那么白女王呢？在h结局中，<code>梅贝尔</code>被古兰（推测，也可能是奈亚）针对性的陷阱解决，但拥有舞台权限的红白女王应该不受影响，<code>红女王</code>为了最后拯救格林必须蛰伏，因此辅助格林对抗古兰以及奈亚的任务只能交给白女王，但即使在此时此刻，白女王依旧有着独占格林的选项，如果她控制或者协助舞台装置强迫和格林融合，就可以抢先一步独占所有支配者都垂涎的格林，但如果把舞台的改变能力给予格林，那么失去王冠和舞台的<code>诺登</code>则会失去自己在棋局上的几乎所有棋子，面对这种选择，<code>诺登</code>将选择权给了格林，不能说她是完全无私的，但面对这样的诱惑，她也会尊重格林的选择，这不得不说是非常伟大的爱<br />
可以说白女王是一个有着两面性的角色，她支配者的一面始终对格林有着独占欲，但她人性的一面始终压抑着这些黑暗的感情，她是一个徘徊于人与神界限的存在，但无论如何，她都尊重并支持着格林的选择，所以她闪耀着人性光辉的一面始终是压过支配者的黑暗一面的。<br />
让我们给这幕疯狂剧场的落幕做一个总结吧，这局棋是红白女王和<code>梅贝尔</code>设下的，目的是为了让格林得到古兰的改变能力并逃离奈亚的箱庭，其中没有舞台权限的<code>梅贝尔</code>负责引导格林，<code>红女王</code>则在最后帮助得到改变能力的格林摆脱奈亚掌控，而白女王则有着最关键的决策权，即是否利用舞台独占格林，但她最后将决定权给了格林，而格林真正的选择应该是夺取舞台的改变能力，因此最后白女王舍弃了一切帮助格林逃离崩坏的舞台。<br />
这场棋局中，<code>梅贝尔</code>横竖不亏，<code>红女王</code>陷入必死之局，最关键的棋手就是白女王，只要她愿意，随时可以下出必赢的一着，但最后她依旧选择了放弃自己的棋子，把终结棋局的希望留给了格林<br />
在经历如此多的牺牲之后，格林终于从棋子升为了棋手，只是不知道他又会下出怎样的一着</p>
<h1 id="npc-dreams-1">npc dreams</h1>
<p>一直以来，我都被允许看着你。</p>
<p>你不想接受这样的结局吗？<br />
从头再来，看看你能做些什么。......<br />
如果你这么想，你就有机会了。</p>
<p>你目前所看到的<br />
就是世界的未来<br />
你刚刚亲身经历了它</p>
<p>但，并非如此。<br />
你以为自己所经历的肯定是一种现实吧？<br />
但是，你看，这仍然是梦，不是现实。<br />
换句话说，你一旦醒来，就都会化作泡影。</p>
<p>但是，健全的你似乎完全没有注意到这一点、<br />
你似乎完全没有注意到 甚至丝毫没有<br />
你可以自己重新开始<br />
你还在沉睡之中</p>
<p>...... 哦。 你听不懂我的话。<br />
我有点难过。<br />
但别担心，你的灵魂在倾听。<br />
来，让我帮你一下。</p>
<p>今天我们来简单地整理一下npcd的剧情线索，先开始做个总评，npc.d虽然更多地被视作bs代餐，但其实还是有明显不同的，相比bs有个存在感强烈的主线，npcd更细碎，地图也更绕，正统上说更像魂游，但总的来说没有过于恶意的地图，设定的完成度也算尚可，问题在于提示太少，不看攻略支线不怎么好做，甚至主线也不怎么好走，打完结局也只能对剧情有个大概想法，因此需要特别地整理一下。<br />
当然这游戏也没有做完，在此只是简单进行一些梳理和猜测<br />
主要的剧情我整理成脑图的形式，现在我开始讲一下各个线索的出处</p>
<p>先说疫碧天，这个区域是最谜团重重的地方，关键的梅尔夫父女都不知所踪，侵蚀骑士不知是谁，唯一的线索就是迦娜，梅尔夫箱庭的画与迦娜立绘几乎可以定为一致，同时从迦娜的台词推测她应该曾是孤儿院的孤儿，生产奇迹则可以通过梦之钥的描述推出。贤者是什么人，为什么要入侵箱庭，则完全没有线索。<br />
然后是梦玄天，梦玄天最大的信息来源就是宠爱馆隐藏房间(图书馆)中的术士日记，补充了非常多的信息，此外猎眼者支线也提供了一些信息，梦境之主研究宠爱仪式的目的应该就是为了让人成为黑暗的不死者(格林？)，从末日幸存，但最后依旧失败了，似乎依然无法抵抗赫怒带来的毁灭<br />
随后是冥白天，其中的莉丝似乎一直在监视玩家，并且是自我意识最高的一个角色，她为了逃避末日夺取了所有人的相貌和记忆，随后就一直等待末日来临，最后将一切托付给主角两人。根据各种物品描述，紫色的她几乎可以确实就是莉丝。据她所说，梦醒后菲图斯就会死去，但未来结局菲图斯依旧存活，而莉丝不在<br />
泄赫天是破坏性最强的一个区域，封印着最终boss，赫怒之女的身份可从黄金战士的支线与未来结局菲图斯的记忆推测，梦之剑的死因来自于术士的日记，我怀疑院长通过入梦让整个世界循环在赫怒带来的破灭前夕，让主角收集所有幸存者的力量击败赫怒<br />
回到孤儿院，院长真实之眼是全游戏最神秘的人，只有几个区域头目的对话零星提到她在梦中等信息。此外，游戏中提到的母亲，应该都是指院长，似乎文本中蓝色字体也都是她的口吻<br />
一个神秘势力时隐时现，即使在真结局时也告诉我们事情还没有结束，这些的信息来源是：拉乌线结局告诉我们有个神秘声音操控她；开二周目的黑影乱码文字,其实真实内容写在解包文件的注释里，翻译出来如图；梅尔夫的箱庭的新boss魔藏书对话；如果开局选隐秘者，未来结局会遇到一个揭露真相的人；以及最后在孤儿院的迦娜对话与黑水晶。<br />
总之，这些谜团应该只能在新dlc里能解决了</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利cs61b的java数据结构笔记</title>
    <url>/thinklive/59735/</url>
    <content><![CDATA[<h1 id="ppt部分">ppt部分</h1>
<h2 id="java基础">java基础</h2>
<p>类内static方法可以被类名调用，对象定义方法只有对象能调用<br />
当类不独立时，嵌套类很有用,并且显然隶属于另一个类。</p>
<ul>
<li>如果其他类不应该使用嵌套类，则将嵌套类设为私有类<br />
<img src="/assets/61b总和笔记/image-20230920083903996.png" alt="img" /><br />
<span id="more"></span></li>
</ul>
<p>接口</p>
<pre><code>public interface List61B&lt;Item&gt; &#123;  
public void addFirst(Item x);  
public void addLast(Item y);  
public Item getFirst();  
public Item getLast();  
public Item removeLast();  
public Item get(int i);  
public void insert(Item x, int position);  
public int size();  
&#125;  
public static String longest(List61B&lt;String&gt; list) &#123;  
int maxDex = 0;  
for (int i = 0; i &lt; list.size(); i += 1) &#123;  
String longestString = list.get(maxDex);  
String thisString = list.get(i);  
if (thisString.length() &gt; longestString.length()) &#123;  
maxDex = i;  
&#125;  
&#125;  
return list.get(maxDex);  
&#125;  </code></pre>
<p>override重写：特征值不变，子类重写父类<br />
overload重载：特征值改变<br />
Java 有 8 种基本类型。 所有其他类型都是引用类型。<br />
对于每个基本类型，都有一个相应的引用类型，称为<br />
包装类。</p>
<ul>
<li>例如，boolean的包装类是Boolean。<br />
基本类型不能用在模板上，包装类可以<br />
</li>
<li>如果 Java 代码需要包装类型并获取原语，则会自动装箱。<br />
</li>
<li>如果代码需要一个原语并获得一个包装器，则它会被拆箱。<br />
</li>
<li>数组永远不会自动装箱/拆箱，例如 Integer[] 不能用于<br />
int[] 的位置（反之亦然）。<br />
</li>
<li>自动装箱/拆箱会对性能产生可衡量的影响！<br />
</li>
<li>包装类型比原始类型使用更多的内存。<br />
public final ArrayDeque&lt;String&gt; d = new ArrayDeque&lt;String&gt;();<br />
</li>
<li>The d variable can never change, but the referenced deque can<br />
Arrays are covariant:<br />
</li>
<li>A FrenchDog is-a Dog.<br />
</li>
<li>An FrenchDog[] is-a Dog[].<br />
Generic types are invariant:<br />
</li>
<li>A List&lt;FrenchDog&gt; is NOT a List&lt;Dog&gt;.</li>
</ul>
<h3 id="java实现链表">java实现链表</h3>
<pre><code>import java.util.Objects;  
public class LinkedListDeque&lt;T&gt; &#123;  
  
    public class Node &#123;  
  
        Node next,prev=null;  
  
        T value;  
  
        public Node(T val) &#123;  
  
            value=val;  
  
        &#125;  
  
        public Node() &#123;  
  
    
  
        &#125;  
  
    &#125;  
  
    int size=0;  
  
    Node firstnode = new Node();  
  
    public LinkedListDeque() &#123;  
  
    &#125;  
  
    public boolean isEmpty() &#123;  
  
        return Objects.equals(size,0);  
  
    &#125;  
  
    public void addFirst(T item) &#123;  
  
        Node new_node=new Node(item);  
  
        if (isEmpty()) &#123;  
  
            firstnode.next=firstnode.prev=new_node;  
  
            new_node.next=new_node.prev=firstnode;  
  
        &#125;  
  
        else &#123;  
  
            firstnode.next.prev=new_node;  
  
            new_node.next=firstnode.next;  
  
            firstnode.next=new_node;  
  
            new_node.prev=firstnode;  
  
        &#125;  
  
        size++;  
  
    &#125;  
  
    public void addLast(T item) &#123;  
  
        Node new_node=new Node(item);  
  
        if (isEmpty()) &#123;  
  
            firstnode.next=firstnode.prev=new_node;  
  
            new_node.next=new_node.prev=firstnode;  
  
        &#125;  
  
        else &#123;  
  
            new_node.prev=firstnode.prev;  
  
            firstnode.prev.next=new_node;  
  
            firstnode.prev=new_node;  
  
            new_node.next=firstnode;  
  
        &#125;  
  
        size++;  
  
    &#125;  
  
    public int size() &#123;  
  
        return size;  
  
    &#125;  
  
    public void printDeque() &#123;  
  
        Node temp=firstnode.next;  
  
        while (temp!= firstnode) &#123;  
  
            System.out.println(temp.value);  
  
            temp=temp.next;  
  
        &#125;  
  
    &#125;  
  
    public T removeFirst() &#123;  
  
        if (isEmpty()) &#123;  
  
            return null;  
  
        &#125;  
  
        else if (size()==1) &#123;  
  
            T val=firstnode.next.value;  
  
            firstnode.prev=firstnode.next=null;  
  
            size--;  
  
            return val;  
  
        &#125;  
  
        else &#123;  
  
            T val= firstnode.next.value;  
  
            firstnode.next.next.prev=firstnode;  
  
            firstnode.next=firstnode.next.next;  
  
            size--;  
  
            return val;  
  
        &#125;  
  
    &#125;  
  
    public T removeLast() &#123;  
  
        if (isEmpty()) &#123;  
  
            return null;  
  
        &#125;  
  
    
  
        else if (size()==1) &#123;  
  
            T val;  
  
            val=firstnode.next.value;  
  
            firstnode.prev=firstnode.next=null;  
  
            size--;  
  
            return val;  
  
        &#125;  
  
        else &#123;  
  
            T val;  
  
            val=firstnode.prev.value;  
  
            firstnode.prev.prev.next=firstnode;  
  
            firstnode.prev=firstnode.prev.prev;  
  
            size--;  
  
            return val;  
  
        &#125;  
  
    &#125;  
  
    public T get(int index) &#123;  
  
        if (index&gt;size()-1) &#123;  
  
            return null;  
  
        &#125;  
  
        else &#123;  
  
            Node temp = firstnode;  
  
            for (int i=0;i&lt;index;i++) &#123;  
  
                temp=temp.next;  
  
            &#125;  
  
            return temp.value;  
  
        &#125;  
  
    &#125;  
  
    
    
  
&#125;  </code></pre>
<h3 id="java单元测试">java单元测试</h3>
<pre><code>@test  
public void testMethod() &#123;  
    assertEquals(&lt;expected&gt;, &lt;actual&gt;);  
&#125;  </code></pre>
<p>创建 JUnit 测试文件时，应在每个测试方法前面加上 <code>@Test</code>注解，并且可以有一个或多个 <code>assertEquals</code>或者 <code>assertTrue</code>方法（由 JUnit 库提供）。 <strong>所有测试必须是非静态的。</strong> 这可能看起来很奇怪，因为您的测试不使用实例变量并且您 可能不会实例化该类。 然而，设计师们却是这样的 JUnit 决定应该编写测试，所以我们就这么做。</p>
<h3 id="权限控制">权限控制</h3>
<p><img src="/assets/61b总和笔记/image-20230920090532017.png" /></p>
<h2 id="bst-in-java">BST IN JAVA</h2>
<p><img src="/assets/61b总和笔记/image-20230920081714565.png" /><br />
表示连接的数组：若数字相同则这些节点互相可达<br />
<img src="/assets/61b总和笔记/image-20230920081830858.png" /><br />
增加父节点后形成bst</p>
<h2 id="加权bst">加权bst</h2>
<p><img src="/assets/61b总和笔记/image-20230920082840743.png" /><br />
维护一个size数组，只能将较小的树加到较大的树上<br />
<img src="/assets/61b总和笔记/image-20230920083245937.png" /></p>
<h3 id="完整代码">完整代码</h3>
<pre><code>public class WeightedQuickUnionDSWithPathCompression implements DisjointSets &#123;  
private int[] parent; private int[] size;  
public WeightedQuickUnionDSWithPathCompression(int N) &#123;  
parent = new int[N]; size = new int[N];  
for (int i = 0; i &lt; N; i++) &#123;  
parent[i] = i;  
size[i] = 1;  
&#125;  
&#125;  
private int find(int p) &#123;  
if (p == parent[p]) &#123;  
return p;  
&#125; else &#123;  
parent[p] = find(parent[p]);  
return parent[p];  
&#125;  
&#125;  
public boolean isConnected(int p, int q) &#123;  
return find(p) == find(q);  
&#125;  
public void connect(int p, int q) &#123;  
int i = find(p);  
int j = find(q);  
if (i == j) return;  
if (size[i] &lt; size[j]) &#123;  
parent[i] = j; size[j] += size[i];  
&#125;   
else &#123;  
parent[j] = i; size[i] += size[j];  
&#125;  
&#125;  </code></pre>
<h3 id="树的旋转">树的旋转</h3>
<p><img src="/assets/61b总和笔记/image-20230920093054610.png" /><br />
右旋同理</p>
<h3 id="如果叶节点有最大负载限制">如果叶节点有最大负载限制</h3>
<p><img src="/assets/61b总和笔记/image-20230920175806667.png" /><br />
分裂树(B树)具有完美的平衡。</p>
<ul>
<li>如果我们分裂根，每个节点都会被下推一层。<br />
</li>
<li>如果我们分割叶节点或内部节点，高度不会改变<br />
所有操作Θ(log N)</li>
</ul>
<h3 id="红黑树">红黑树</h3>
<p>任何与 2-3 树保持等距的 BST 都具有以下属性：</p>
<ul>
<li>没有节点有两个红色链接（否则它就像一个 4 节点）。<br />
</li>
<li>从根到叶子的每条路径都有相同数量的黑色链接。<br />
</li>
<li>红色链接向左倾斜。<br />
</li>
<li>也称为“左倾红黑二叉搜索树（LLRB）<br />
<img src="/assets/61b总和笔记/image-20230920180350334.png" /></li>
</ul>
<h2 id="hash">hash</h2>
<p>如果 N 个项目分布在 M 个桶中，则平均时间取决于<br />
N/M = L，也称为 负载系数 .<br />
○ 平均运行时间为 Θ (L)。<br />
<img src="/assets/61b总和笔记/image-20230920222654955.png" /></p>
<h2 id="最小堆">最小堆</h2>
<p>二叉最小堆：二叉树完整，并服从 最小堆属性 .</p>
<ul>
<li>最小堆：每个节点都小于或等于其两个子节点。<br />
</li>
<li>完整：仅在底层（如果有）缺少项目，所有节点都尽可能远<br />
尽可能左。<br />
<img src="/assets/61b总和笔记/image-20230921103325455.png" /></li>
</ul>
<h3 id="遍历">遍历</h3>
<ul>
<li>节点遍历：前中后序<br />
</li>
<li>层次遍历<br />
实现指针接口——使用栈<br />
<img src="/assets/61b总和笔记/image-20230921112835278.png" /><br />
两个类的equals实现，如果是哈希，一般需要同时确保hashcode方法对内容相同的类返回相同的哈希码</li>
</ul>
<pre><code>public boolean equals(Object o) &#123;    
    if (o==this) return true;    
    if (o==null) return false;    
    if (o.getClass()!=this.getClass()) return false;    
    SimpleOomage new_o=(SimpleOomage) o;    
    return new_o.blue==this.blue &amp;&amp;new_o.red==this.red &amp;&amp; new_o.green==this.green;    
&#125;  </code></pre>
<h2 id="图论">图论</h2>
<h3 id="迪杰斯特拉">迪杰斯特拉</h3>
<p><a href="https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&amp;loop=false&amp;delayms=3000#slide=id.g771336078_0_180">演示</a><br />
<img src="/assets/61b总和笔记/image-20230923101738378.png" /><br />
<img src="/assets/61b总和笔记/image-20230923101849254.png" /><br />
<a href="https://algs4.cs.princeton.edu/44sp/DijkstraSP.java.html">伯克利实现</a></p>
<h3 id="最小生成树mst">最小生成树（MST)</h3>
<p>最短路径树取决于起始顶点：</p>
<ul>
<li>因为它告诉你如何从源头到达一切。<br />
MST 没有来源。<br />
尽管如此，MST 有时恰好是特定顶点的 SPT</li>
</ul>
<h2 id="排序">排序</h2>
<p><code>稳定性</code>：如果保留等价项的顺序，则称排序是稳定的。</p>
<ul>
<li>选择排序：找到最小的项并将其放在前面。<br />
</li>
<li>插入排序：找出当前项插入的位置。<br />
</li>
<li>归并排序：将两个已排序的半部分合并为一个已排序的整体。<br />
</li>
<li>分区（快速）排序：围绕枢轴对项目进行分区。<br />
<img src="/assets/61b总和笔记/image-20231006205748498.png" /></li>
</ul>
<h3 id="快速排序">快速排序</h3>
<p><a href="https://docs.google.com/presentation/d/1DOnWS59PJOa-LaBfttPRseIpwLGefZkn450TMSSUiQY/pub?start=false&amp;loop=false&amp;delayms=3000#slide=id.g12b16fb6b6_0_2">演示</a><br />
不严谨地证明快排性能<br />
<img src="/assets/61b总和笔记/image-20231006204101527.png" /><br />
<code>Quicksort is BST Sort</code><br />
<img src="/assets/61b总和笔记/image-20231006204242323.png" /></p>
<h3 id="优化">优化</h3>
<ul>
<li>切换到插入排序:- 当子问题大小减小到15或更小时,使用插入排序。<br />
</li>
<li>使排序自适应:<strong>利用数组中已有的顺序</strong>(插入排序,平滑排序,TimSort(Python和Java中的排序))。<br />
</li>
<li>利用键集的限制。如果键的个数是某个常数,例如[3, 4, 1, 2, 4, 3, ..., 2, 2, 2, 1, 4, 3, 2, 3],可以更快排序(参见三路快速排序,如果你好奇可以看这里:<a href="http://goo.gl/3sYnv3">http://goo.gl/3sYnv3</a>)。<br />
</li>
<li>对于快速排序:使算法具有自我检查能力,如果递归太深则切换到不同的排序方法。这只是确定性快速排序的问题。</li>
</ul>
<p>在 Java 中，Arrays.sort(someArray) 使用：</p>
<ul>
<li>合并排序（特别是 TimSort 变体）如果 someArray 包含<br />
对象。<br />
</li>
<li>如果 someArray 由基本类型组成，则进行快速排序。</li>
</ul>
<h3 id="证明">证明</h3>
<ol type="1">
<li>We have that N! &gt; (N/2) N/2</li>
</ol>
<ul>
<li>Taking the log of both sides, we have that log(N!) &gt; log((N/2) N/2 ).<br />
</li>
<li>Bringing down the exponent we have that log(N!) &gt; N/2 log(N/2).<br />
</li>
<li>Discarding the unnecessary constant, we have log(N!) ∈ Ω(N log (N/2)).<br />
</li>
<li>From there, we have that log(N!) ∈ Ω(N log N).</li>
</ul>
<ol start="2" type="1">
<li><ul>
<li>log(N!) = log(N) + log(N-1) + log(N-2) + …. + log(1)</li>
</ul></li>
</ol>
<ul>
<li>N log N = log(N) + log(N) + log(N) + … log(N)<br />
</li>
<li>Therefore N log N ∈ Ω(log(N!))<br />
结论：</li>
</ul>
<pre><code>N log N ∈ Θ(log N!)  
log N! ∈ Θ(N log N)  </code></pre>
<p>比较排序中：</p>
<ul>
<li>Decision tree needs N! leaves.<br />
</li>
<li>So we need lg(N!) rounded up levels, which is Ω(log(N!))</li>
</ul>
<h2 id="数据集">数据集</h2>
<h3 id="digit-by-digit">Digit-by-Digit</h3>
<p><a href="https://www.cs.princeton.edu/courses/archive/spring15/cos226/demo/52DemoTrie.mov">演示</a><br />
Given a Trie with N keys, and a key with L digits. What is the:</p>
<ul>
<li>Worst case insert runtime? Θ(L)<br />
</li>
<li>Worst case search runtime? Θ(L)<br />
</li>
<li>Best case search runtime? Θ(1)</li>
</ul>
<p><img src="/assets/61b总和笔记/image-20231006215117117.png" /><br />
<img src="/assets/61b总和笔记/image-20231006215302639.png" /><br />
优化:</p>
<ul>
<li>Data-indexed array: Max speed, max memory.<br />
</li>
<li>TreeMap/HashMap: Slower query performance, but less memory wasted.<br />
<img src="/assets/61b总和笔记/image-20231006215646467.png" /><br />
<img src="/assets/61b总和笔记/image-20231006215851901.png" /></li>
</ul>
<h4 id="三元搜索">三元搜索</h4>
<p><a href="https://algs4.cs.princeton.edu/52trie/TST.java.html">实现</a></p>
<ul>
<li>为每个节点分配一个字符。<br />
</li>
<li>给每个节点 3 个链接：<br />
○ 如果键的下一个字符 &lt; 节点的字符，则左链接。<br />
○ 如果键的下一个字符 == 节点的字符，则中间链接。<br />
○ 如果键的下一个字符 &gt; 节点的字符，则右链接。</li>
</ul>
<pre><code>public class TST&lt;Value&gt; &#123;  
    private int n;              // size  
    private Node&lt;Value&gt; root;   // root of TST  
  
    private static class Node&lt;Value&gt; &#123;  
        private char c;                        // character  
        private Node&lt;Value&gt; left, mid, right;  // left, middle, and right subtries  
        private Value val;                     // value associated with string  
    &#125;  </code></pre>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th>平均复杂度</th>
<th>最坏情况</th>
<th>最好情况</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>哈希表</td>
<td>Θ(L)*</td>
<td></td>
<td> </td>
<td>Θ(NL)</td>
</tr>
<tr class="even">
<td>二叉搜索树</td>
<td></td>
<td>Θ(L log N)</td>
<td>Θ(1)</td>
<td>Θ(NL)</td>
</tr>
<tr class="odd">
<td>Trie (数组)</td>
<td></td>
<td>Θ(L)</td>
<td>Θ(1)</td>
<td>Θ(NLR)</td>
</tr>
<tr class="even">
<td>Trie (哈希表)</td>
<td></td>
<td>Θ(L)</td>
<td>Θ(1)</td>
<td>Θ(NL)</td>
</tr>
<tr class="odd">
<td>Trie (树)</td>
<td></td>
<td>Θ(L log R)</td>
<td>Θ(1)</td>
<td>Θ(NL)</td>
</tr>
<tr class="even">
<td>TST</td>
<td></td>
<td>Θ(NL)</td>
<td>Θ(1)</td>
<td>Θ(NL)</td>
</tr>
</tbody>
</table>
<p><strong>N keys, L digits per key, R alphabet size. A miss means the key isn’t present.</strong></p>
<h2 id="编码和压缩">编码和压缩</h2>
<p>A prefix-free code is one in which no codeword is a prefix of any other. Example for<br />
English:</p>
<table>
<thead>
<tr class="header">
<th>字符</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>space</td>
<td>111</td>
</tr>
<tr class="even">
<td>E</td>
<td>010</td>
</tr>
<tr class="odd">
<td>T</td>
<td>1101</td>
</tr>
<tr class="even">
<td>A</td>
<td>1011</td>
</tr>
<tr class="odd">
<td>O</td>
<td>1001</td>
</tr>
<tr class="even">
<td>I</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>I ATE: 100011110111101010</p>
<h3 id="shannon-fano编码">Shannon-Fano编码</h3>
<ul>
<li>Count relative frequencies of all characters in a text.<br />
</li>
<li>Split into ‘left’ and ‘right halves’ of roughly equal frequency.<br />
○ Left half gets a leading zero. Right half gets a leading one.<br />
○ Repeat.</li>
</ul>
<h3 id="huffman编码">Huffman编码</h3>
<ul>
<li>Assign each symbol to a node with weight = relative frequency.<br />
</li>
<li>Take the two smallest nodes and merge them into a super node with weight<br />
equal to sum of weights.<br />
</li>
<li>Repeat until everything is part of a tree.<br />
</li>
<li>将每个符号分配给一个节点，权重=相对频率。<br />
</li>
<li>取两个最小的节点，合并成一个带权重的超级节点<br />
等于权重之和。<br />
</li>
<li>重复直到所有东西都是树的一部分。</li>
</ul>
<h3 id="霍夫曼压缩">霍夫曼压缩</h3>
<p>使用霍夫曼压缩的两种可能的原理：</p>
<ol type="1">
<li>为每种输入类型构建一个语料库。<br />
</li>
<li>对于每个可能的输入文件，仅为该文件创建一个唯一的代码。 发送<br />
代码与压缩文件一起。</li>
</ol>
<p>实例：<a href="https://docs.google.com/presentation/d/1DWuSkE9MxQPUTjbSJCMe54rCim4eAwM4aFRvhqq5_Hs/edit#slide=id.g2159afc5e6_0_1044">演示</a><br />
编码：<br />
第 1 步：计算频率。<br />
步骤2：构建编码数组和解码树。<br />
步骤3：将解码trie写入output.huf。<br />
步骤4：将每个符号的码字写入output.huf。<br />
解码：<br />
步骤1：读入解码树。<br />
步骤 2：沿着 trie 遍历，每次都输出符号 当到达一片叶子。</p>
<pre><code>Given a file X.txt that we’d like to compress into X.huf:  
- Consider each b-bit symbol (e.g. 8-bit chunks, Unicode characters, etc.) of  
X.txt, counting occurrences of each of the 2 b possibilities, where b is the size  
of each symbol in bits.  
- Use Huffman code construction algorithm to create a decoding trie and  
encoding map. Store this trie at the beginning of X.huf.  
- Use encoding map to write codeword for each symbol of input into X.huf.  
To decompress X.huf:  
- Read in the decoding trie.  
- Repeatedly use the decoding trie’s longestPrefixOf operation until all bits in  
X.hug have been converted back to their uncompressed form.  </code></pre>
<h3 id="lzw压缩">LZW压缩</h3>
<p><a href="https://docs.google.com/presentation/d/1U8XO6CWfcU4QgrFOZmGjAgmaKxLc8HXk6qB1JQVlqrg/edit#slide=id.g53705ba95_0259">演示</a><br />
Key idea: Each codeword represents multiple symbols.</p>
<ul>
<li>Start with ‘trivial’ codeword table where each codeword corresponds to<br />
one ASCII symbol.<br />
</li>
<li>Every time a codeword X is used, record a new codeword Y corresponding<br />
to X concatenated with the next symbol<br />
</li>
<li>从“简单”码字表开始，其中每个码字对应<br />
一个 ASCII 符号。<br />
</li>
<li>每使用一个码字X，记录一个对应的新码字Y<br />
到 X 与下一个符号连接。</li>
</ul>
<h3 id="总结">总结</h3>
<p>霍夫曼编码：</p>
<ul>
<li>将公共符号表示为具有较少位的码字。<br />
</li>
<li>使用诸如 Map&lt;Character, BitSeq&gt; 之类的东西进行压缩。<br />
</li>
<li>使用 TrieMap&lt;Character&gt; 之类的东西进行解压缩。<br />
LZW:<br />
</li>
<li>用单个码字表示多个符号。<br />
</li>
<li>使用 TrieMap&lt;Integer&gt; 之类的东西进行压缩。<br />
</li>
<li>使用诸如 Map&lt;Character, SymbolSeq&gt; 之类的东西进行解压缩。</li>
</ul>
<h2 id="附加内容">附加内容</h2>
<h3 id="柯尔莫哥洛夫复杂度">柯尔莫哥洛夫复杂度</h3>
<p>Given a target bitstream B, what is the shortest bitstream C B that outputs B.</p>
<ul>
<li>Definition: The Java-Kolmogorov complexity K J (B) is the length of the<br />
shortest Java program (in bytes) that generates B.<br />
○ There IS an answer. It just might be very hard to find.</li>
</ul>
<ol type="1">
<li>柯尔莫哥洛夫复杂度实际上与语言无关。</li>
</ol>
<ul>
<li>对于任何比特流，Java-Kolmogorov 复杂度不超过 大于 Python-Kolmogorov 复杂度的常数因子。—— I could just write a Python interpreter in Java and then run Kevin’s program.<br />
○ K J (B) ≤ K P (B) + size(python interpreter)</li>
</ul>
<ol start="2" type="1">
<li>It is impossible to write a program that calculates the Kolmogorov<br />
Complexity of any bitstream. Proof available here</li>
</ol>
<h3 id="独立集问题">独立集问题</h3>
<p>独立集是一组顶点，其中没有两个顶点相邻。<br />
独立集问题：</p>
<ul>
<li>是否存在大小为 k 的独立集合？<br />
</li>
<li>即，k 个顶点的颜色为红色，这样就没有接触。</li>
</ul>
<pre><code>Give an algorithm for solving this problem.  
- For each of the possible 2 N colorings:  
○ Check if number of colored vertices is equal to k: O(N)  
○ For every red vertex, check that neighbors are all white: O(k*N)  
○ If both checks succeed, return true.  
○ If either check fails, go on to next coloring.  
- Runtime: O(k*N*2 N ). Since k ≤ N, O(N 2 *2 N )  </code></pre>
<h3 id="npp">np=p</h3>
<p>We say that a problem is in the complexity class P if:</p>
<ul>
<li>It is a decision problem.<br />
</li>
<li>An answer can be found in O(N k ) time for some k</li>
</ul>
<p>We say that a problem is in the complexity class NP if:</p>
<ul>
<li>It is a decision problem.<br />
</li>
<li>A “yes” answer can be verified in O(N k ) time for some k. More precisely, we<br />
can verify a specific example of a “yes” answer in O(N k ) time</li>
</ul>
<p>Many (most?) practical problems can be cast as a problem in NP:</p>
<ul>
<li>Is there a way to route my airplanes at a total cost of less than $1B/yr?<br />
</li>
<li>Is there a way to route the wires inside this microchip with a total path<br />
length of less than 1 micrometer?<br />
</li>
<li>Given Z, are there two primes such that X*Y = Z?<br />
</li>
<li>Is there a protein configuration for amino acid sequence X whose total<br />
energy is less than Y?</li>
</ul>
<p>Nice features of P:</p>
<ul>
<li>O(N k ) is closed under addition and multiplication.<br />
○ Run two P algorithms, overall still in P.<br />
○ Run a P algorithm in N times, still in P<br />
<img src="/assets/61b总和笔记/image-20231006223527363.png" /><br />
共识意见<br />
</li>
<li>83%：P ≠ NP（126 名受访者）<br />
</li>
<li>9%：P = NP（12 名受访者）<br />
</li>
<li>9%：其他（13 名受访者）</li>
</ul>
<pre><code>“[针对我们现在所说的 NP 完全问题的线性或二次时间过程将会产生]最严重的后果。[对于这样的程序]将 明确表明，尽管Entscheidungs问题无法解决，数学家在回答是或否问题时的脑力劳动可以是完全被机器取代了。”  ——库尔特·哥德尔  </code></pre>
<h2 id="总结-1">总结</h2>
<ul>
<li><p>基于对象的编程：围绕对象进行组织。<br />
</p></li>
<li><p>面向对象编程：<br />
○ 接口继承。<br />
○ 实现继承。<br />
</p></li>
<li><p>动态类型与静态类型。<br />
</p></li>
<li><p>泛型编程，例如ArrayList&lt;Integer&gt;等。<br />
</p></li>
<li><p>内存模型是包含位的盒子。<br />
</p></li>
<li><p>正整数的位表示。<br />
</p></li>
<li><p>java<br />
</p></li>
<li><p>一些标准的编程习惯/模式：<br />
○ 作为函数容器的对象（例如比较器、IntUnaryFunctions）。<br />
○ 接口中的默认方法规范（链接）。<br />
○ 迭代器和视图（例如keySet）。</p></li>
<li><p>Java 中重要的数据结构<br />
重要数据结构接口：<br />
</p></li>
<li><p>java.util.Collection（及其子类型）。<br />
○ 特别强调 Map（及其子类型）。<br />
</p></li>
<li><p>我们自己的集合（例如Map61B、Deque）：实际上并没有扩展集合。</p></li>
<li><p>运行时间分析<br />
时间复杂度表示<br />
渐进分析<br />
数学证明<br />
最好，最坏，平均情况</p></li>
<li><p>数据结构<br />
Array-Based Data Structures:<br />
</p></li>
<li><p>ArrayLists and ArrayDeque<br />
</p></li>
<li><p>HashSets, HashMaps, MyHashMap: Arrays of ‘buckets’<br />
</p></li>
<li><p>ArrayHeap (tree represented as an array)<br />
Linked Data Structures<br />
</p></li>
<li><p>Linked Lists<br />
○ LinkedList, IntList, LinkedListDeque, SLList, DLList<br />
</p></li>
<li><p>Trees: Hierarchical generalization of a linked list. Aim for bushiness.<br />
○ TreeSet, TreeMap, BSTMap, Tries (trie links often stored as arrays)<br />
</p></li>
<li><p>Graphs: Generalization of a tree (including many algorithms).</p></li>
<li><p>编程实践<br />
</p></li>
<li><p>Java 语法和习惯用法。<br />
</p></li>
<li><p>JUnit 测试（及其更极端的形式：测试驱动开发）。<br />
</p></li>
<li><p>挖掘网络代码。<br />
</p></li>
<li><p>调试：<br />
○ 确定受错误影响的最简单的情况。<br />
○ 追捕它，让它无处藏身。<br />
○ 有了正确的方法，即使通过查找bug也能找到bug<br />
手动代码检查是不可能的（参见lab3中的Horrible Steve）。<br />
</p></li>
<li><p>真正的工具：IntelliJ、git、命令行、Maven<br />
</p></li>
<li><p>数据结构选择（和API设计）<br />
○ 推动整个计划的绩效和实施。<br />
</p></li>
<li><p>使用复杂的 API、规范：项目 2 和项目 3<br />
○ 项目 3 还涉及与现有代码库的交互。</p></li>
<li><p>其他<br />
压缩：</p></li>
<li><p>霍夫曼编码，以及霍夫曼编码的数据结构选择。</p></li>
<li><p>其他方法：LZW 和游程编码（额外的幻灯片）。</p></li>
<li><p>观察：比特流的最佳压缩将提供 该位流的有用模型（例如，hugPlant.bmp -&gt; HugPlant.java）。<br />
不可能且棘手的问题：<br />
</p></li>
<li><p>不可能：为任何输入找到最佳压缩的算法。<br />
</p></li>
<li><p>棘手问题：3SAT、独立集、NP 完备性。<br />
○ P = NP 吗？ “是”的答案具有戏剧性的意义。</p></li>
</ul>
<p><img src="/assets/61b总和笔记/image-20231006224146653.png" /></p>
<h1 id="作业中的实现">作业中的实现</h1>
<h2 id="bstmap">BSTMap</h2>
<p>remove思路：删除节点要把左子树最大值或者右子树最小值提上来，deletemin的代码为</p>
<pre><code>private Node removeMin(K key, Node p) &#123;  
        if (p.left == null) &#123;  
            return p.right;  
        &#125;  
        p.left = removeMin(key, p.left);  
        return p;  
    &#125;  </code></pre>
<pre><code>package lab9;    
    
import java.util.Iterator;    
import java.util.Set;    
import java.util.HashSet;    
/**    
 * Implementation of interface Map61B with BST as core data structure. * * @author Your name here    
 */public class BSTMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map61B&lt;K, V&gt; &#123;    
    private int size=0;    
    private class Node &#123;    
        /* (K, V) pair stored in this Node. */    
        private K key;    
        private V value;    
    
        /* Children of this Node. */    
        private Node left;    
        private Node right;    
    
        private Node(K k, V v) &#123;    
            key = k;    
            value = v;    
            left=right=null;    
        &#125;    
        private boolean isEmpty() &#123;    
            return !(left==null &amp;&amp; right==null);    
        &#125;    
    &#125;    
    
    private Node root;  /* Root node of the tree. */    
    /* Creates an empty BSTMap. */    public BSTMap() &#123;    
        this.clear();    
    &#125;    
    
    /* Removes all of the mappings from this map. */    
    @Override    
    public void clear() &#123;    
        root = null;    
        size = 0;    
    &#125;    
    
    /** Returns the value mapped to by KEY in the subtree rooted in P.    
     *  or null if this map contains no mapping for the key.     */    private V getHelper(K key, Node p) &#123;    
        if (p==null) return null;    
        if (key.compareTo(p.key)==0) return p.value;    
        if (p.key.compareTo(key)&gt;0) &#123;    
            return getHelper(key,p.left);    
        &#125;    
        else return getHelper(key,p.right);    
    &#125;    
    
    /** Returns the value to which the specified key is mapped, or null if this    
     *  map contains no mapping for the key.     */    @Override    
    public V get(K key) &#123;    
        V val=getHelper(key,this.root);    
        return val;    
    &#125;    
    
    
    /** Returns a BSTMap rooted in p with (KEY, VALUE) added as a key-value mapping.    
      * Or if p is null, it returns a one node BSTMap containing (KEY, VALUE).     */    private Node putHelper(K key, V value, Node p) &#123;    
        if (p==null) return new Node(key,value);    
        int compare=key.compareTo(p.key);    
        if (compare&lt;0) p.left = putHelper(key,value,p.left);    
        else if (compare&gt;0) p.right = putHelper(key,value,p.right);    
        else p.value=value;    
        return p;    
    &#125;    
    
    /** Inserts the key KEY    
     *  If it is already present, updates value to be VALUE.     */    @Override    
    public void put(K key, V value) &#123;    
        root = putHelper(key,value,this.root);    
        size++;    
    &#125;    
    
    /* Returns the number of key-value mappings in this map. */    
    @Override    
    public int size() &#123;    
        return size;    
    &#125;    
    
    //////////////// EVERYTHING BELOW THIS LINE IS OPTIONAL ////////////////    
    
    /* Returns a Set view of the keys contained in this map. */    private void traverseAdd(Node p, Set&lt;K&gt; keys) &#123;    
        if (p == null) &#123;    
            return;    
        &#125;    
        keys.add(p.key);    
        traverseAdd(p.left, keys);    
        traverseAdd(p.right, keys);    
    &#125;    
    @Override    
    public Set&lt;K&gt; keySet() &#123;    
        Set&lt;K&gt; keys = new HashSet&lt;&gt;() &#123;    
        &#125;;    
        traverseAdd(root, keys);    
        return keys;    
    &#125;    
    
    /** Removes KEY from the tree if present    
     *  returns VALUE removed,     *  null on failed removal.     */    @Override    
    public V remove(K key) &#123;    
        V val = get(key);    
        if (val == null || key == null) return null;    
        remove_helper(root,key);    
        size--;    
        return val;    
    &#125;    
    public Node remove_helper(Node x,K key) &#123;    
        if (x == null) return null;    
    
        int cmp = key.compareTo(x.key);    
        if      (cmp &lt; 0) x.left  = remove_helper(x.left,  key);    
        else if (cmp &gt; 0) x.right = remove_helper(x.right, key);    
        else &#123;    
            if (x.right == null) return x.left;    
            if (x.left  == null) return x.right;    
            Node t = left_max(x.left);    
            x.key=t.key;    
            x.value=t.value;    
        &#125;    
        return x;    
    
    &#125;    
    /** Removes the key-value entry for the specified key only if it is    
     *  currently mapped to the specified value.  Returns the VALUE removed,     *  null on failed removal.     **/    public Node left_max(Node p) &#123;    
        if (p==null) return null;    
        Node temp=p;    
        while (p.right!=null) &#123;    
            temp=p;    
            p=p.right;    
        &#125;    
        temp.right=null;    
        return p;    
    &#125;    
    @Override    
    public V remove(K key, V value) &#123;    
        throw new UnsupportedOperationException();    
    &#125;    
    
    @Override    
    public Iterator&lt;K&gt; iterator() &#123;    
        return keySet().iterator();    
    &#125;    
    private Node removeMin(K key, Node p) &#123;  
        if (p.left == null) &#123;  
            return p.right;  
        &#125;  
        p.left = removeMin(key, p.left);  
        return p;  
    &#125;  
    public static void main(String[] args) &#123;    
        BSTMap&lt;String, Integer&gt; bstmap = new BSTMap&lt;&gt;();    
        bstmap.put(&quot;hello&quot;, 5);    
        bstmap.put(&quot;cat&quot;, 10);    
        bstmap.put(&quot;fish&quot;, 22);    
        bstmap.put(&quot;zebra&quot;, 90);    
        bstmap.remove(&quot;hello&quot;);    
    &#125;    
&#125;  </code></pre>
<h2 id="hashmap">hashmap</h2>
<p>由于put操作不确保成功，需要用操作前后差值作为size变化量</p>
<pre><code>        int hashCode = hash(key);    
        size -= buckets[hashCode].size;    
        buckets[hashCode].put(key, value);    
        size += buckets[hashCode].size;    </code></pre>
<pre><code>package lab9;    
    
import java.util.HashSet;    
import java.util.Iterator;    
import java.util.Set;    
    
/**    
 *  A hash table-backed Map implementation. Provides amortized constant time *  access to elements via get(), remove(), and put() in the best case. * *  @author Your name here    
 */public class MyHashMap&lt;K, V&gt; implements Map61B&lt;K, V&gt; &#123;    
    
    private static final int DEFAULT_SIZE = 16;    
    private static int now_size=DEFAULT_SIZE;    
    private static final double MAX_LF = 0.75;    
    
    private ArrayMap&lt;K, V&gt;[] buckets;    
    private int size=0;    
    
    private int loadFactor() &#123;    
        return size / buckets.length;    
    &#125;    
    
    public MyHashMap() &#123;    
        buckets = new ArrayMap[DEFAULT_SIZE];    
        this.clear();    
    &#125;    
    public MyHashMap(int new_size) &#123;    
        buckets = new ArrayMap[new_size];    
        this.clear();    
    &#125;    
    /* Removes all of the mappings from this map. */    
    @Override    
    public void clear() &#123;    
        this.size = 0;    
        for (int i = 0; i &lt; this.buckets.length; i += 1) &#123;    
            this.buckets[i] = new ArrayMap&lt;&gt;();    
        &#125;    
    &#125;    
    
    /** Computes the hash function of the given key. Consists of    
     *  computing the hashcode, followed by modding by the number of buckets.     *  To handle negative numbers properly, uses floorMod instead of %.     */    private int hash(K key) &#123;    
        if (key == null) &#123;    
            return 0;    
        &#125;    
    
        int numBuckets = buckets.length;    
        return Math.floorMod(key.hashCode(), numBuckets);    
    &#125;    
    
    /* Returns the value to which the specified key is mapped, or null if this    
     * map contains no mapping for the key.     */    @Override    
    public V get(K key) &#123;    
        if (key==null) throw new IllegalArgumentException(&quot;argument to get() is null&quot;);    
        return buckets[hash(key)].get(key);    
    &#125;    
    
    /* Associates the specified value with the specified key in this map. */    
    @Override    
    public void put(K key, V value) &#123;    
        int hashCode = hash(key);    
        size -= buckets[hashCode].size;    
        buckets[hashCode].put(key, value);    
        size += buckets[hashCode].size;    
        if (loadFactor()&gt;MAX_LF) &#123;    
            now_size*=2;    
            MyHashMap&lt;K, V&gt; newHashMap = new MyHashMap&lt;&gt;(now_size);    
            for (ArrayMap&lt;K, V&gt; bucket : buckets) &#123;    
                for (K one_key : bucket) &#123;    
                    newHashMap.put(one_key, bucket.get(one_key));    
                &#125;    
            &#125;    
            this.buckets = newHashMap.buckets;    
            this.size = newHashMap.size;    
        &#125;    
    &#125;    
    
    /* Returns the number of key-value mappings in this map. */    
    @Override    
    public int size() &#123;    
        return size;    
    
    &#125;    
    
    //////////////// EVERYTHING BELOW THIS LINE IS OPTIONAL ////////////////    
    
    /* Returns a Set view of the keys contained in this map. */    @Override    
    public Set&lt;K&gt; keySet() &#123;    
        Set&lt;K&gt; keys =new HashSet&lt;&gt;();    
        for (int i =0;i&lt;buckets.length;i++) &#123;    
            keys.addAll(buckets[i].keySet());    
        &#125;    
        return keys;    
    &#125;    
    
    /* Removes the mapping for the specified key from this map if exists.    
     * Not required for this lab. If you don&#39;t implement this, throw an     * UnsupportedOperationException. */    @Override    
    public V remove(K key) &#123;    
        if (buckets[hash(key)].containsKey(key)) &#123;    
            V val = buckets[hash(key)].get(key);    
            buckets[hash(key)].remove(key);    
            size--;    
            return val;    
        &#125;    
        else return null;    
    &#125;    
    
    /* Removes the entry for the specified key only if it is currently mapped to    
     * the specified value. Not required for this lab. If you don&#39;t implement this,     * throw an UnsupportedOperationException.*/    @Override    
    public V remove(K key, V value) &#123;    
        throw new UnsupportedOperationException();    
    &#125;    
    
    @Override    
    public Iterator&lt;K&gt; iterator() &#123;    
        return keySet().iterator();    
    &#125;    
    
&#125;  </code></pre>
<h2 id="拓扑排序">拓扑排序</h2>
<pre><code>public class DepthFirstOrder &#123;  
private boolean[] marked;  
private Stack&lt;Integer&gt; reversePostorder;  
public DepthFirstOrder(Digraph G) &#123;  
reversePostorder = new Stack&lt;Integer&gt;();  
marked = new boolean[G.V()];  
for (int v = 0; v &lt; G.V(); v++) &#123;  
if (!marked[v]) &#123; dfs(G, v); &#125;  
&#125;  
private void dfs(Digraph G, int v) &#123;  
marked[v] = true;  
for (int w : G.adj(v)) &#123;  
if (!marked[w]) &#123; dfs(G, w); &#125;  
&#125;  
reversePostorder.push(v);  
&#125;  
public Iterable&lt;Integer&gt; reversePostorder()  
&#123; return reversePostorder; &#125;  
  </code></pre>
<h2 id="最小堆-1">最小堆</h2>
<pre><code>public class ArrayHeap&lt;T&gt; implements ExtrinsicPQ&lt;T&gt; &#123;    
    private Node[] contents;    
    private int size;    
    
    public ArrayHeap() &#123;    
        contents = new ArrayHeap.Node[16];    
    
        /* Add a dummy item at the front of the ArrayHeap so that the getLeft,    
         * getRight, and parent methods are nicer. */        contents[0] = null;    
    
        /* Even though there is an empty spot at the front, we still consider    
         * the size to be 0 since nothing has been inserted yet. */        size = 0;    
    &#125;    
    
    /**    
     * Returns the index of the node to the left of the node at i.     */    private static int leftIndex(int i) &#123;    
        /* TODO: Your code here! */    
        return i*2;    
    &#125;    
    
    /**    
     * Returns the index of the node to the right of the node at i.     */    private static int rightIndex(int i) &#123;    
        /* TODO: Your code here! */    
        return i*2+1;    
    &#125;    
    
    /**    
     * Returns the index of the node that is the parent of the node at i.     */    private static int parentIndex(int i) &#123;    
        /* TODO: Your code here! */    
        return (int) i/2;    
    &#125;    
    
    /**    
     * Gets the node at the ith index, or returns null if the index is out of     * bounds.     */    private Node getNode(int index) &#123;    
        if (!inBounds(index)) &#123;    
            return null;    
        &#125;    
        return contents[index];    
    &#125;    
    
    /**    
     * Returns true if the index corresponds to a valid item. For example, if     * we have 5 items, then the valid indices are 1, 2, 3, 4, 5. Index 0 is     * invalid because we leave the 0th entry blank.     */    private boolean inBounds(int index) &#123;    
        if ((index &gt; size) || (index &lt; 1)) &#123;    
            return false;    
        &#125;    
        return true;    
    &#125;    
    
    /**    
     * Swap the nodes at the two indices.     */    private void swap(int index1, int index2) &#123;    
        Node node1 = getNode(index1);    
        Node node2 = getNode(index2);    
        contents[index1] = node2;    
        contents[index2] = node1;    
    &#125;    
    
    
    /**    
     * Returns the index of the node with smaller priority. Precondition: not     * both nodes are null.     */    private int min(int index1, int index2) &#123;    
        Node node1 = getNode(index1);    
        Node node2 = getNode(index2);    
        if (node1 == null) &#123;    
            return index2;    
        &#125; else if (node2 == null) &#123;    
            return index1;    
        &#125; else if (node1.myPriority &lt; node2.myPriority) &#123;    
            return index1;    
        &#125; else &#123;    
            return index2;    
        &#125;    
    &#125;    
    
    
    /**    
     * Bubbles up the node currently at the given index.     */    private void swim(int index) &#123;    
        // Throws an exception if index is invalid. DON&#39;T CHANGE THIS LINE.    
        validateSinkSwimArg(index);    
    
        /** TODO: Your code here. */    
        while (index!=1 &amp;&amp; min(index,parentIndex(index))==index) &#123;    
            swap(index,parentIndex(index));    
            index=parentIndex(index);    
        &#125;    
    &#125;    
    
    /**    
     * Bubbles down the node currently at the given index.     */    private void sink(int index) &#123;    
        // Throws an exception if index is invalid. DON&#39;T CHANGE THIS LINE.    
        validateSinkSwimArg(index);    
    
        /** TODO: Your code here. */    
        if (inBounds(rightIndex(index))) &#123;    
            int min_index=min(leftIndex(index),rightIndex(index));    
            if (min(index,min_index)==min_index) &#123;    
                swap(index,min_index);    
                sink(min_index);    
            &#125;    
        &#125; else if (inBounds(leftIndex(index))) &#123;    
            int min_index = leftIndex(index);    
            if (min(index,min_index)==min_index) &#123;    
                swap(index,min_index);    
                sink(min_index);    
            &#125;    
        &#125;    
    &#125;    
    
    /**    
     * Inserts an item with the given priority value. This is enqueue, or offer.     * To implement this method, add it to the end of the ArrayList, then swim it.     */    @Override    
    public void insert(T item, double priority) &#123;    
        /* If the array is totally full, resize. */    
        if (size + 1 == contents.length) &#123;    
            resize(contents.length * 2);    
        &#125;    
    
        /* TODO: Your code here! */    
        contents[size+1]=new Node(item,priority);    
        size++;    
        swim(size);    
    
    &#125;    
    
    /**    
     * Returns the Node with the smallest priority value, but does not remove it     * from the heap. To implement this, return the item in the 1st position of the ArrayList.     */    @Override    
    public T peek() &#123;    
        /* TODO: Your code here! */    
        return contents[1].myItem;    
    &#125;    
    
    /**    
     * Returns the Node with the smallest priority value, and removes it from     * the heap. This is dequeue, or poll. To implement this, swap the last     * item from the heap into the root position, then sink the root. This is     * equivalent to firing the president of the company, taking the last     * person on the list on payroll, making them president, and then demoting     * them repeatedly. Make sure to avoid loitering by nulling out the dead     * item.     */    @Override    
    public T removeMin() &#123;    
        /* TODO: Your code here! */    
        T val=peek();    
        swap(1,size);    
        contents[size]=null;    
        size--;    
        sink(1);    
        return val;    
    &#125;    
    
    /**    
     * Returns the number of items in the PQ. This is one less than the size     * of the backing ArrayList because we leave the 0th element empty. This     * method has been implemented for you.     */    @Override    
    public int size() &#123;    
        return size;    
    &#125;    
    
    /**    
     * Change the node in this heap with the given item to have the given     * priority. You can assume the heap will not have two nodes with the same     * item. Check item equality with .equals(), not ==. This is a challenging     * bonus problem, but shouldn&#39;t be too hard if you really understand heaps     * and think about the algorithm before you start to code.     */    @Override    
    public void changePriority(T item, double priority) &#123;    
        /* TODO: Your code here! */    
        changePriority_helper(item,priority,1);    
    &#125;    
    
    public void changePriority_helper(T item, double priority,int index) &#123;    
        if (!inBounds(index)) return;    
        if (contents[index].myItem.equals(item)) contents[index].myPriority=priority;    
        else&#123;    
            changePriority_helper(item, priority,leftIndex(index));    
            changePriority_helper(item,priority,rightIndex(index));    
        &#125;    
    
    &#125;    
    /**    
     * Prints out the heap sideways. Provided for you.     */    @Override    
    public String toString() &#123;    
        return toStringHelper(1, &quot;&quot;);    
    &#125;    
    
    /* Recursive helper method for toString. */    
    private String toStringHelper(int index, String soFar) &#123;    
        if (getNode(index) == null) &#123;    
            return &quot;&quot;;    
        &#125; else &#123;    
            String toReturn = &quot;&quot;;    
            int rightChild = rightIndex(index);    
            toReturn += toStringHelper(rightChild, &quot;        &quot; + soFar);    
            if (getNode(rightChild) != null) &#123;    
                toReturn += soFar + &quot;    /&quot;;    
            &#125;    
            toReturn += &quot;\n&quot; + soFar + getNode(index) + &quot;\n&quot;;    
            int leftChild = leftIndex(index);    
            if (getNode(leftChild) != null) &#123;    
                toReturn += soFar + &quot;    \\&quot;;    
            &#125;    
            toReturn += toStringHelper(leftChild, &quot;        &quot; + soFar);    
            return toReturn;    
        &#125;    
    &#125;    
    
    
    /**    
     * Throws an exception if the index is invalid for sinking or swimming.     */    private void validateSinkSwimArg(int index) &#123;    
        if (index &lt; 1) &#123;    
            throw new IllegalArgumentException(&quot;Cannot sink or swim nodes with index 0 or less&quot;);    
        &#125;    
        if (index &gt; size) &#123;    
            throw new IllegalArgumentException(&quot;Cannot sink or swim nodes with index greater than current size.&quot;);    
        &#125;    
        if (contents[index] == null) &#123;    
            throw new IllegalArgumentException(&quot;Cannot sink or swim a null node.&quot;);    
        &#125;    
    &#125;    
    
    private class Node &#123;    
        private T myItem;    
        private double myPriority;    
    
        private Node(T item, double priority) &#123;    
            myItem = item;    
            myPriority = priority;    
        &#125;    
    
        public T item()&#123;    
            return myItem;    
        &#125;    
    
        public double priority() &#123;    
            return myPriority;    
        &#125;    
    
        @Override    
        public String toString() &#123;    
            return myItem.toString() + &quot;, &quot; + myPriority;    
        &#125;    
    &#125;    
    
    
    /** Helper function to resize the backing array when necessary. */    
    private void resize(int capacity) &#123;    
        Node[] temp = new ArrayHeap.Node[capacity];    
        for (int i = 1; i &lt; this.contents.length; i++) &#123;    
            temp[i] = this.contents[i];    
        &#125;    
        this.contents = temp;    
    &#125;  
      </code></pre>
<h2 id="最佳优先搜索bms">最佳优先搜索BMS</h2>
<p>从概念上讲，这个想法非常简单：</p>
<ul>
<li>保留“移动序列”的优先级队列。<br />
</li>
<li>从 PQ 中删除“最佳”移动序列，我们称之为 BMS。<br />
</li>
<li>令 F 为 BMS 中的最后一个状态。<br />
</li>
<li>如果 F 是目标状态，则完成，因此返回 BMS。<br />
</li>
<li>如果F不是目标，则对于F的每个邻居N，创建一个由BMS + N组成的新移动序列并将其放入PQ中。</li>
</ul>
<p>该算法也称为 <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*搜索算法</a></p>
<pre><code>public class Solver &#123;    
    int times = 0;    
    SearchNode final_node;    
    private class SearchNode implements Comparable&lt;SearchNode&gt;  &#123;    
        private WorldState now_state;    
        private int mov_times = 0;    
        private SearchNode ref_state;    
        public SearchNode(WorldState ws,int times,SearchNode ref) &#123;    
            this.now_state=ws;    
            this.mov_times=times;    
            this.ref_state=ref;    
        &#125;    
    
        @Override    
        public int compareTo(SearchNode o) &#123;    
            return this.mov_times+now_state.estimatedDistanceToGoal()-o.mov_times-o.now_state.estimatedDistanceToGoal();    
        &#125;    
    &#125;    
    public Solver(WorldState initial) &#123;    
        MinPQ&lt;SearchNode&gt; pq = new MinPQ&lt;&gt;();    
        pq.insert(new SearchNode(initial,0,null));    
        while (true) &#123;    
            SearchNode a_node = pq.delMin();    
            if (a_node.now_state.isGoal()) &#123;    
                final_node=a_node;    
                break;    
            &#125;    
            for (WorldState nb : a_node.now_state.neighbors()) &#123;    
                if (a_node.ref_state == null || !nb.equals(a_node.ref_state.now_state)) pq.insert(new SearchNode(nb, a_node.mov_times + 1, a_node));    
            &#125;    
        &#125;    
    
    &#125;    
    public int moves() &#123;    
        return final_node.mov_times;    
    &#125;    
    public Iterable&lt;WorldState&gt; solution() &#123;    
        int movTimes = final_node.mov_times;    
        List&lt;WorldState&gt; ret = new ArrayList&lt;&gt;();    
        SearchNode temp= final_node;    
        ret.add(final_node.now_state);    
        while (temp.ref_state != null) &#123;    
            ret.add(temp.ref_state.now_state);    
            temp=temp.ref_state;    
        &#125;    
        return ret;    
    &#125;    
&#125;  </code></pre>
<h2 id="深度和广度优先搜索">深度和广度优先搜索</h2>
<pre><code>public MazeDepthFirstPaths(Maze m, int sourceX, int sourceY, int targetX, int targetY) &#123;    
    super(m);    
    maze = m;    
    s = maze.xyTo1D(sourceX, sourceY);    
    t = maze.xyTo1D(targetX, targetY);    
    distTo[s] = 0;    
    edgeTo[s] = s;    
&#125;    
    
private void dfs(int v) &#123;    
    marked[v] = true;    
    announce();    
    
    if (v == t) &#123;    
        targetFound = true;    
    &#125;    
    
    if (targetFound) &#123;    
        return;    
    &#125;    
    
    for (int w : maze.adj(v)) &#123;    
        if (!marked[w]) &#123;    
            edgeTo[w] = v;    
            announce();    
            distTo[w] = distTo[v] + 1;    
            dfs(w);    
            if (targetFound) &#123;    
                return;    
            &#125;    
        &#125;    
    &#125;    
&#125;  
private void bfs() &#123;    
    // TODO: Your code here. Don&#39;t forget to update distTo, edgeTo, and marked, as well as call announce()    
    ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;Integer&gt;(maze.V());    
    for (int v = 0; v &lt; maze.V(); v++) &#123;    
        distTo[v] = Integer.MAX_VALUE;    
    &#125;    
    distTo[s] = 0;    
    marked[s] = true;    
    announce();    
    q.add(s);    
    while (!q.isEmpty()) &#123;    
        int v = q.remove();    
        for (int w : maze.adj(v)) &#123;    
            if (!marked[w]) &#123;    
                edgeTo[w] = v;    
                distTo[w] = distTo[v] + 1;    
                marked[w] = true;    
                announce();    
                q.add(w);    
            &#125;    
        &#125;    
    &#125;    
&#125;  </code></pre>
<h2 id="归并排序">归并排序</h2>
<pre><code>private static &lt;Item extends Comparable&gt; Item getMin(    
        Queue&lt;Item&gt; q1, Queue&lt;Item&gt; q2) &#123;    
    if (q1.isEmpty()) &#123;    
        return q2.dequeue();    
    &#125; else if (q2.isEmpty()) &#123;    
        return q1.dequeue();    
    &#125; else &#123;    
        // Peek at the minimum item in each queue (which will be at the front, since the    
        // queues are sorted) to determine which is smaller.        Comparable q1Min = q1.peek();    
        Comparable q2Min = q2.peek();    
        if (q1Min.compareTo(q2Min) &lt;= 0) &#123;    
            // Make sure to call dequeue, so that the minimum item gets removed.    
            return q1.dequeue();    
        &#125; else &#123;    
            return q2.dequeue();    
        &#125;    
    &#125;    
&#125;    
    
    
/** Returns a queue of queues that each contain one item from items. */    
private static &lt;Item extends Comparable&gt; Queue&lt;Queue&lt;Item&gt;&gt;    
        makeSingleItemQueues(Queue&lt;Item&gt; items) &#123;    
    // Your code here!    
    Queue&lt;Queue&lt;Item&gt;&gt; qq = new Queue&lt;&gt;();    
    for (Item it:items) &#123;    
        Queue&lt;Item&gt; qe= new Queue&lt;&gt;();    
        qe.enqueue(it);    
        qq.enqueue(qe);    
    &#125;    
    return  qq;    
&#125;    
    
/**    
 * Returns a new queue that contains the items in q1 and q2 in sorted order. * * This method should take time linear in the total number of items in q1 and q2.  After * running this method, q1 and q2 will be empty, and all of their items will be in the * returned queue. * * @param   q1  A Queue in sorted order from least to greatest.    
 * @param   q2  A Queue in sorted order from least to greatest.    
 * @return      A Queue containing all of the q1 and q2 in sorted order, from least to    
 *              greatest. * */private static &lt;Item extends Comparable&gt; Queue&lt;Item&gt; mergeSortedQueues(    
        Queue&lt;Item&gt; q1, Queue&lt;Item&gt; q2) &#123;    
    // Your code here!    
    Queue&lt;Item&gt; qi = new Queue&lt;&gt;();    
    while (!q1.isEmpty() || !q2.isEmpty()) &#123;    
        qi.enqueue(getMin(q1,q2));    
    &#125;    
    return  qi;    
&#125;    
    
/** Returns a Queue that contains the given items sorted from least to greatest. */    
public static &lt;Item extends Comparable&gt; Queue&lt;Item&gt; mergeSort(    
        Queue&lt;Item&gt; items) &#123;    
    // Your code here!    
    if (items.size()==1) return items;    
    Queue&lt;Queue&lt;Item&gt;&gt; temp = makeSingleItemQueues(items);    
    while (temp.size() &gt; 1) &#123;    
            Queue&lt;Item&gt; lft = temp.dequeue();    
            Queue&lt;Item&gt; rht = temp.dequeue();    
            Queue&lt;Item&gt; q = mergeSortedQueues(lft,rht);    
            temp.enqueue(q);    
        &#125;    
    return temp.dequeue();    
&#125;  </code></pre>
<h2 id="三元快速排序">三元快速排序</h2>
<pre><code>private static &lt;Item extends Comparable&gt; void partition(    
        Queue&lt;Item&gt; unsorted, Item pivot,    
        Queue&lt;Item&gt; less, Queue&lt;Item&gt; equal, Queue&lt;Item&gt; greater) &#123;    
    // Your code here!    
    while (!unsorted.isEmpty()) &#123;    
        Item it = unsorted.dequeue();    
        if (it.compareTo(pivot)&lt; 0) less.enqueue(it);    
        else if (it.compareTo(pivot)==0) equal.enqueue(it);    
        else greater.enqueue(it);    
    &#125;    
&#125;    
    
/** Returns a Queue that contains the given items sorted from least to greatest. */    
public static &lt;Item extends Comparable&gt; Queue&lt;Item&gt; quickSort(    
        Queue&lt;Item&gt; items) &#123;    
    // Your code here!    
    Item piv = getRandomItem(items);    
    Queue&lt;Item&gt; less = new Queue&lt;&gt;();    
    Queue&lt;Item&gt; equal = new Queue&lt;&gt;();    
    Queue&lt;Item&gt; greater = new Queue&lt;&gt;();    
    partition(items,piv,less,equal,greater);    
    if (!less.isEmpty()) less = quickSort(less);    
    if (!greater.isEmpty()) greater=quickSort(greater);    
    return catenate(catenate(less,equal),greater);    
&#125;  </code></pre>
<h2 id="计数排序">计数排序</h2>
<pre><code> public static int[] betterCountingSort(int[] arr) &#123;    
        // TODO make counting sort work with arrays containing negative numbers.    
        int max = Integer.MIN_VALUE;    
        int min = Integer.MAX_VALUE;    
        int neg = 0;    
        for (int i : arr) &#123;    
            if (i&lt;0) neg++;    
            max = Math.max(max, i);    
            min = Math.min(min, i);    
        &#125;    
        int[] posicounts = new int[max + 1];    
        if (min &lt; 0) &#123;    
            int[] negacounts = new int[-min + 1];    
            for (int i : arr) &#123;    
                if (i &gt;= 0) posicounts[i]++;    
                else negacounts[-i]++;    
            &#125;    
            int[] negsorted = new int[neg];    
            int k = 0;    
            for (int i = -min ; i &gt;0 ; i -= 1) &#123;    
                for (int j = 0; j &lt; negacounts[i]; j += 1, k += 1) &#123;    
                    negsorted[k] = -i;    
                &#125;    
            &#125;    
            k=0;    
            int[] posisorted = new int[arr.length - neg];    
            for (int i = 0; i &lt; posicounts.length; i += 1) &#123;    
                for (int j = 0; j &lt; posicounts[i]; j += 1, k += 1) &#123;    
                    posisorted[k] = i;    
                &#125;    
            &#125;    
            int[] result = Arrays.copyOf(negsorted,  posisorted.length + negsorted.length);    
            System.arraycopy(posisorted, 0, result, posisorted.length, negsorted.length);    
            return result;    
            &#125;    
        else &#123;    
            for (int i: arr) &#123;    
                posicounts[i]++;    
            &#125;    
            int[] sorted = new int[arr.length];    
            int k = 0;    
            for (int i = 0; i &lt; posicounts.length; i += 1) &#123;    
                for (int j = 0; j &lt; posicounts[i]; j += 1, k += 1) &#123;    
                    sorted[k] = i;    
                &#125;    
            &#125;    
            return sorted;    
        &#125;    
    &#125;    
&#125;  </code></pre>
<p>另一种实现</p>
<pre><code>public static int[] betterCountingSort(int[] arr) &#123;  
  
        int max = Integer.MIN_VALUE;  
  
        int min = Integer.MAX_VALUE;  
  
        for (int i : arr) &#123;  
  
            max = max &gt; i ? max : i;  
  
            min = min &lt; i ? min : i;  
  
        &#125;  
  
    
  
        int[] counts = new int[max - min + 1];  
  
        for (int i : arr) &#123;  
  
            counts[i - min]++;  
  
        &#125;  
  
    
  
        int[] starts = new int[max - min + 1];  
  
        int pos = 0;  
  
        for (int i = 0; i &lt; starts.length; i += 1) &#123;  
  
            starts[i] = pos;  
  
            pos += counts[i];  
  
        &#125;  
  
    
  
        int[] sorted = new int[arr.length];  
  
        for (int i = 0; i &lt; arr.length; i += 1) &#123;  
  
            int item = arr[i];  
  
            int place = starts[item - min];  
  
            sorted[place] = item;  
  
            starts[item - min] += 1;  
  
        &#125;  
  
    
  
        return sorted;  
  
    &#125;  </code></pre>
<h2 id="基数排序lsd">基数排序lsd</h2>
<pre><code>public static String[] sort(String[] asciis) &#123;    
    // TODO: Implement LSD Sort    
    String[] result = new String[asciis.length];    
    String[] temp = asciis.clone();    
    int max =Integer.MIN_VALUE;    
    for (String str:asciis) &#123;    
        if (max &lt; str.length()) max = str.length();    
    &#125;    
    for (int i = max-1; i &gt;=0; i--) &#123;    
        temp = sortHelperLSD(temp, i);    
    &#125;    
    return temp;    
&#125;    
    
/**    
 * LSD helper method that performs a destructive counting sort the array of * Strings based off characters at a specific index. * @param asciis Input array of Strings    
 * @param index The position to sort the Strings on.    
 */private static String[] sortHelperLSD(String[] asciis, int index) &#123;    
    
    // Optional LSD helper method for required LSD radix sort    
    String[] tempstrs = asciis;    
    String[] result = new String[asciis.length];    
    int[] indexes = new int[256];    
    for (String str : tempstrs) &#123;    
        if (str.length() - 1 &lt; index) &#123;    
            indexes[0]++;    
        &#125;    
        else &#123;    
            char ch = str.charAt(index);    
            indexes[(int) ch]++;    
        &#125;    
    &#125;    
    int pos = 0;    
    int[] starts = new int[256];    
    for (int i = 0; i &lt; indexes.length; i += 1) &#123;    
        starts[i] = pos;    
        pos += indexes[i];    
    &#125;    
    for (String str:tempstrs) &#123;    
        if (str.length() -1 &lt; index) &#123;    
            int place = starts[0];    
            result[place] = str;    
            starts[0] += 1;    
        &#125;    
        else &#123;    
            int place = starts[str.charAt(index)];    
            result[place] = str;    
            starts[str.charAt(index)] += 1;    
        &#125;    
    &#125;    
    return result;    
&#125;  </code></pre>
<h2 id="seamcarver">SeamCarver</h2>
<pre><code>public  double energy(int x, int y) &#123;    
    if (x&lt;0 || x&gt;= width() || y&lt; 0 || y&gt;= height()) throw  new IndexOutOfBoundsException();    
    int lft = x-1 &lt; 0 ? width()-1 : x-1;    
    int rht = x+1 &gt;= width() ? 0 : x+1;    
    int up = y-1 &lt; 0 ? height()-1 : y-1;    
    int down = y+1 &gt;= height() ? 0 : y+1;    
    Picture pic =this.picture();    
    double detx = Math.pow((pic.get(rht,y).getRed()-pic.get(lft,y).getRed()),2)  +Math.pow((pic.get(rht,y).getBlue()-pic.get(lft,y).getBlue()),2)    
            +Math.pow((pic.get(rht,y).getGreen()-pic.get(lft,y).getGreen()),2);    
    double dety = Math.pow((pic.get(x,up).getRed()-pic.get(x,down).getRed()),2)  +Math.pow((pic.get(x,up).getBlue()-pic.get(x,down).getBlue()),2)    
            +Math.pow((pic.get(x,up).getGreen()-pic.get(x,down).getGreen()),2);    
    return detx +dety;    
    
&#125;  
  
public  int[] findVerticalSeam() &#123;    
    double[][] en = new double[width()][height()];    
    int[][] path =new int[width()][height()];    
    for (int i =0;i&lt;width();i++) &#123;    
        for (int j= 0;j&lt;height();j++) &#123;    
            en[i][j] = energy(i,j);    
        &#125;    
    &#125;    
    double[][] M = new double[width()][height()];    
    for (int i =0;i&lt; width();i++) &#123;    
        M[i][0] = en[i][0];    
    &#125;    
    for (int j = 1;j &lt; height();j++) &#123;    
        M[0][j] = min(M[1][j-1],M[0][j-1]);    
        if (M[0][j] == M[1][j-1]) path[0][j] = 1;    
        else path[0][j]=0;    
        M[0][j]+=en[0][j];    
        M[width()-1][j] = min(M[width()-1][j-1],M[width()-2][j-1]);    
        if (M[width()-1][j] == M[width()-1][j-1]) path[width()-1][j] = 0;    
        else path[0][j]=-1;    
        M[width()-1][j]+=en[width()-1][j];    
        for (int i =1;i&lt;=width()-2;i++) &#123;    
            M[i][j] =  min(min(M[i-1][j-1],M[i][j-1]),M[i+1][j-1]);    
            if (M[i][j] == M[i-1][j-1]) path[i][j]=-1;    
            else if (M[i][j] == M[i][j-1]) path[i][j] = 0;    
            else path[i][j] = 1;    
            M[i][j]+=en[i][j];    
        &#125;    
    &#125;    
    double min = Double.MAX_VALUE;    
    int xindex = 0;int yindex = height()-1;    
    for (int i = 0;i&lt;width();i++)&#123;    
        min = Math.min(min, M[i][height() - 1]);    
        if (min == M[i][height()-1]) xindex = i;    
    &#125;    
    int[] finalpath =new int[height()];    
    while (yindex&gt;=0) &#123;    
        finalpath[yindex] = xindex;    
        xindex+=path[xindex][yindex];    
        yindex--;    
    &#125;    
    return finalpath;    
    
&#125;  </code></pre>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>数据结构与算法</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>blacksouls原著梗解析</title>
    <url>/thinklive/29916/</url>
    <content><![CDATA[<h1 id="section">01</h1>
<p>众所周知，black souls的原型，或者说最重要的灵感来源就是爱丽丝梦游仙境以及它衍生的爱丽丝镜中奇遇，我本人一直对游戏和原著的对应关系感到很好奇，但由于工作量很大，一直没下定决心做这件事，但最近突然想到，如果分期做一些整理会不会就没那么麻烦了呢，于是决定开启这个系列。<br />
<span id="more"></span><br />
由于是第一期，我就扯一些闲话，爱丽丝的原著可谓有着非常深远的影响，首先，他就是最著名的童话之一，在儿童里的传播极为广泛，在我小时候就听说并读过这个作品，但说实话爱丽丝的原著对孩童来说实在太过思维跳脱，导致我虽然通读了几遍但完全没看进去，考虑到当时的儿童文学相比现在的完善可以说几乎不存在，这本书可谓有着相当的意义，不过我毕竟没有研究过相关文学史所以不多评价了，对于爱丽丝的原著，我最深刻的印象就是其无比丰富的想象力以及跳脱的情节（由于卡罗尔是数学家，他还塞了不少数学梗进去），可能这就是莉耶芙喜欢这本书的初衷吧。<br />
此外，爱丽丝这一形象与整个不思议之国以无数的二次创作形象疯狂地在各种娱乐作品里传播，关于这点，我认为是爱丽丝原著符号性强烈的特点导致的，永无止境的茶会，跳进兔子洞等元素非常具有符号性，它们奇怪到引人注目，但谁也不知道到底指的什么，可能有意义，可能没有意义，二次创作者可以非常自由地阐释这些元素，因此导致了在二次元文化里，爱丽丝近乎成了最常见的一个人名或者说符号<br />
最后则是它的现实作者，金属冶炼在欧美文化里是个很敏感的话题，关于原作者此方面的谣言可以说满天飞，但对此我只能说疑罪从无，没有直接证据表明这一点，就连一些间接证据在我看来也很明显是牵强附会，基于道德的角度，我们不该用一些间接证据指责两个世纪前人物的私事，此外，black souls是毋庸置疑的架空世界观作品，不管怎么编故事也和现实中的卡罗尔毫无关系。<br />
当然black souls设定下的卡罗尔也是个经常被讨论的问题，由于冬之钟那个崩坏的adv，很多人认为black souls的卡罗尔是个炼金术师，但是很明显小剧场不过是哪个支配者的大作，而且是个很有虫虫风格的作品，没有任何证据表明black souls设定下现实的卡罗尔干了相同的事，总的来说我认为black souls世界观的卡罗尔，除了他一直深爱爱丽丝以外和爱丽丝一家的关系是没有确切信息的，而且这种爱也可能不是男女之爱，只是柏拉图之恋罢了。<br />
好吧，关于原著以外的讨论就说到这里，接下来我们开始具体情节的对照分析。<br />
第一章的开头，小爱丽丝和姐姐一起坐在河边，姐姐在看一本没有插图没有对话的书，让小爱丽丝感到无聊。<br />
书在black souls中是个很常见的意象，没有插图的书只在牛津学院的回忆中提到过一次，读书的倒是有几个，一代的爱丽丝02一直看着书，书上的内容似乎是格林被玛丽苏毁灭时的遗言，此外，一代的尸龙也在读着书，而且二代时她也在河边，根据她念出来的部分，其实就是我们这个世界的卡罗尔描写邪龙贾巴沃克被打倒的那首诗，个人猜测有可能black souls中卡罗尔没有给爱丽丝送出去的礼物其实是他的作品集，后来卡罗尔被玛丽苏捉走，这本书则被尸龙拿走，最后，二代的白女王诺登也是个看书人,这本书格林无法阅读，但0sen下能看到轮回次数<br />
由于02不是任何人的姐姐，白女王虽然很御姐，但原型明显是白兔先生，所以对应度最高的其实是贾巴沃克，此外尸龙摸鱼的时候摘花，而此时的爱丽丝也有摘花的意图，可能暗指温柔的尸龙姐姐摘花编成花环想送给爱丽丝（迫真）<br />
随后就是经典的爱丽丝跟着匆忙的白兔先生进了兔子洞的环节，此时的白兔先生声称自己是急着去找公爵夫人<br />
兔子洞在一二代都有对应，一代追寻着原著顺序，跟着白兔，从兔子洞跳下就能到达不思议之国，二代却是相反的，格林先到坠落之间，然后才到兔子洞<br />
此外，原著对坠落的描述是，途中有很多书架以及各种柜子，这点在坠落之间和兔子洞都有体现，爱丽丝在坠落后第二次见到了匆忙的白兔先生，而按通常的流程，也是格林过了兔子洞后进行度为1才能见到白兔诺登，此外原著中爱丽丝第一次来到的门厅顶上有一排灯，这可能是图书馆的进行度灯的灵感来源，原著中爱丽丝用钥匙打开一扇门后来到了放有变大变小药的房间，游戏可以直接到达，喝了我和吃了我是非常经典的原作梗。<br />
以上是爱丽丝原著第一章和游戏的对应关系，那么今天就到此为止了</p>
<h1 id="section-1">02</h1>
<p>接下来开始第二章的分析<br />
吃下蛋糕后的爱丽丝身形变得非常巨大，也因此挤不进她想去的花园，此时她哭泣的眼泪形成了泪水池，对应bs的血泪之池，有种说法是红偶像紫餐产生的血泪形成了血泪之池，如果从致敬原著看的角度倒是不无可能<br />
这时白兔先生经过，被爱丽丝吓跑，留下了手套和扇子，扇子有着让人变小的能力，但此时不知情的爱丽丝一边扇扇子一边开始自我怀疑，正是这时她提到了梅贝尔这个名字。<br />
根据爱丽丝的说法，梅贝尔什么都不知道，住在又破又小的房子，没有玩具还要天天念书，对应bs中的梅贝尔，某种程度上讲还挺还原的<br />
随后被扇子变小的爱丽丝掉进了泪水池，并在池子里遇到了一只耗子以及其他动物，她们一起游上了岸。<br />
接下来就是第三章了<br />
此时耗子开始上起了历史课，这段剧情在bs有两个对应点，一个就在酒馆里耗子直接出场给我们上课，而则是牛津学院的回忆提到爱丽丝讨厌历史课。<br />
随后为了让湿透的衣服变干，渡渡鸟为她的动物朋友们召开了一场赛跑会，跑完宣布大家都赢了，但奖品让爱丽丝颁发，甚至包括爱丽丝自己的奖品，于是爱丽丝给所有人每人一颗糖，给自己发了一只丁真，很对应游戏血泪之池的渡渡赛跑会，但游戏中只有杀害渡渡会得到一颗糖果,杀害其它动物没有奖品（私藏奖品的屑），附近可以捡到糖果，此外，游戏和原著中的赛跑参与者是不完全对应的，赛跑中白鹅会提到鹦鹉和鹰缺席了，原因吗，因为涉及一些书本以外的东西我们以后再说<br />
此后螃蟹母子的对话会提到好脾气的牡蛎，可能对应bs的dlc1嚣张的牡蛎<br />
第四章中爱丽丝被白兔错认为了玛丽.安，白兔家的女仆，这就是为什么被白兔诺登剥夺神力的虫虫改名成玛丽.安并且穿着女仆装。<br />
爱丽丝喝了让自己再次变大的药水，然后被挤进了房子里无法动弹，此时她吐露了自己不想长大的愿望，随后，蜥蜴比尔被派去搬来梯子，爬进烟囱里查探情况，被爱丽丝一脚踢飞出去，这段对应bs大圣堂里比尔搭梯子的剧情，顺便一提，比尔除了倒霉蛋属性外在bs里几乎全被魔改了，合理怀疑是莉耶芙加了什么私货进去。<br />
随后爱丽丝吃下了被扔进来的蛋糕，再次变小，并逃进了一个长着高大蘑菇的森林，并在蘑菇上遇到了抽烟的青虫，对应游戏中的孢子之森，第四章结束<br />
也就是说原作爱丽丝的路线就是兔子洞-血泪之池-孢子之森，这也是为什么进行度0时会在森林遇到爱丽丝的幻象，虽然这一路线并不一定遇到比尔<br />
格林和希夏的对话基本对应原作爱丽丝和它的见面，一开始不理不睬，但离去时希夏开口挽留，原著毛虫让爱丽丝背了首威廉老爹的诗，对应孢子之森的boss，游戏与原作不同的是，原作的虫子告诉爱丽丝吃下蘑菇可以变大变小，游戏中直接让格林去找公爵夫人<br />
爱丽丝见过青虫后有段剧情，爱丽丝吃下蘑菇后脖子变得很长，被一只孵蛋的鸽子认作来吃蛋的长虫，这里译本的长虫其实就是大蛇的意思，这段剧情在游戏也有两个对应，一是游戏中的物品鸽子蛋，孢子之森能捡到鸽子蛋，杀害希夏会掉落鸽子蛋，正好符合原作顺序，对其的描述是少女不吃生蛋，蛇却很喜欢吃，也符合原作，bs中的蛇只有蛇神，而0sen下看到他的脖子很长，也对应原著情节；第二个疑似的对应点则是卡罗尔川的矮胖子，可以孵化出雏鸟，但除此以外和原著没什么对应</p>
<h1 id="section-2">03</h1>
<p>接下来我们开始第六章，公爵夫人的章节<br />
公爵夫人馆外能遇到名为幼犬的怪物，这应该对应书中第四章，遇到青虫前爱丽丝遇到的小狗，馆内可以遇到鱼和蛙之听差，原作中他们分别是女王派来邀请打縋球和公爵夫人处接受邀请信的佣人。<br />
公爵夫人是比较还原原著的一个角色，基本上所有行为举止都有对应。爱丽丝初见她的场景和游戏中几乎完全对得上，婴儿和猪的转化则用sen值来实现（顺便一提屠宰场也有类似的转换），只有柴郡猫没有出现，但馆内一张挂画上则会出现柴郡猫，这张挂画上随着sen值不同也会出现猪和婴儿的转变，此外，由于公爵夫人还原度很高，我把台词中的对应点用图整理如下<br />
公爵夫人另一个原型，也是她名字和贪食属性的由来则是一幅画作，这幅画作（比较哈人就不放了）可能的历史原型是一位贵族女性，她在历史上有大嘴的外号，并且和丈夫并不恩爱（甚至没同过房？），这解释了里线中她的台词<br />
游戏中柴郡猫瞬忽隐忽现，还有标志性的微笑都出自此章，不过对她来说似乎更认同爱丽丝家的猫的身份，然而她又部分否定了戴娜的身份<br />
值得一提的是，此前我们提到的原作路线都是有着某种程度上的认证的，到森林的路线有爱丽丝幻影，随后有希夏的指引，但从公爵夫人开始跳脱出了梦游仙境，让我们去了镜中奇遇，并且地图到了这里也确实是死路，如果继续按公爵夫人的指引，到达库因兰德这条死路后也确实找到了爱丽丝，虽然格林并不知情。<br />
而如果我们想要继续原著路线，就要踏上不同的路，经过牛津学院到达永不终焉的茶会，为什么呢？<br />
关于茶会我很有些个人想法，但我们先从原著的角度说起<br />
虽然一二代都有茶会，但比较对应原著茶会一段的是二代的茶会，原著中帽匠和三月兔被柴郡猫钦定为疯子，可以说是整部作品里最荒诞的一段，在bs中也不遑多让，我们先从三人的现实原型说起，帽子屋的原型是中世纪的帽匠，由于工艺会用到水银，所以有着疯疯癫癫的形象（游戏也提到这点），三月兔的原型是一句俗语，这句俗语的由来据说是兔子三月处于繁殖期而狂躁不安，所以会有这种人设，睡鼠原型则是一种常见的宠物，非常嗜睡，当时人们喜欢把它养在茶壶里。<br />
我们分人物说起，首先是帽匠<br />
原著一见到爱丽丝，帽匠就大喊没位置了，并且抛出了乌鸦桌子的谜语，和游戏一样，这段谜语若干年后卡罗尔才公布答案，所以游戏的帽子屋说不知道答案。<br />
随后，爱丽丝说自己说的和想的一样，三人一人一句地反驳了她，其中除了三月兔抛出的两句话，都是主语宾语单项包含关系，但游戏中爱丽丝的话由帽子屋说出，并只有睡鼠保留着这种逻辑关系。<br />
面包黄油的对话几乎完全致敬原著。<br />
原著爱丽丝与柴郡猫对话提及此刻是五月，和帽子屋对话提及今天是4号，游戏中时计塔的密码1852正是爱丽丝的生年，所以游戏中帽子屋会说擅长happy birthday<br />
帽匠会提及，自己和时间闹翻了（红心女王的说法是谋杀时间），所以茶会被永远定格到这个时间，餐盘只能越积越多，这可能是游戏中帽子屋不死能力的来源，监禁后她离开了茶会，所以又可以杀死了，此外，游戏中狂鸟一定程度上和时间有着关系，并且帽子屋很讨厌她，或许和原著这段情节有关（但帽子屋又称呼时间为先生）<br />
随后是三月兔，原著中三月兔头顶缠着稻草，卡罗尔说这表示她疯了，游戏致敬了这点。<br />
原著的三月兔打翻了牛奶，游戏中是红茶<br />
最后是睡鼠，睡鼠在原著中唱歌和讲故事都和游戏里对应，故事中三个小姑娘的名字对应利德尔三姐妹，讲故事时，三人责怪爱丽丝打岔，在游戏中里线战斗对话有体现。<br />
好了，以上是和游戏原著比较对应的地方，接下来我就说说对茶会的个人理解，再强调一下，都是个人理解。<br />
茶会可以说是bs2中一个很重要的地图，它和牛津学院直接相连，并且两张地图连续有一个回忆，而进入牛津学院主流的路线就是从精神病院开始通过路德维希市街，见证伊迪斯和杰克的悲剧，顺便一提关于利德尔三姐妹，我之后会出个特辑，这里先不谈，漫布迷雾的街道明显是在neta伦敦，并且卡罗尔是英国人，曾在牛津学院任职，这条路线可以说是最贴近现实的一条路。<br />
此外，如果要防止狂鸟唱歌，就必须先来到茶会去往时计塔，并且时计和箱庭的运转息息相关，而狂鸟唱歌的目的应该就是让格林别乱跑了去找爱丽丝，此外，不思议之国的大部分地方都很有着阴森的氛围，而且弯弯绕绕，只有茶会非常狭小却坐拥一个篝火而且阳光明媚氛围悠闲，几乎可以磨灭格林的斗志了，茶会的三个参与者就更有意思了<br />
如果我们给三人归纳一个关键词，一个是疯狂，一个是爱欲，一个是睡梦，三者加在一起几乎概括出了整个二代的特点，这恐怕是奈亚不想让格林意识到的，此外，来到茶会必然会遇到伊迪斯，按原作顺序之后就是红心女王罗丽娜，两人是乱入者，且都曾和卡罗尔关系亲密，奈亚不希望她们引发卡罗尔的回忆，所以才会让夫人把我们支开。<br />
对这三人和她们的象征意义，疯狂和爱欲其实不必多说，但睡梦其实是一条相对的暗线，我一直认为寿司是一个很喜欢前后对照的作者，所以就让我们来分析一下，不少npc会提及此处是个梦境，但最早是在op，游戏的开头是格林苏醒，看到爱丽丝，然后不知道为什么再次睡去，因此我们如果认真看开头就会知道不思议之国是个梦境，那么为什么设定成梦境呢，首先是由于协助创造箱庭的诺登的原型是所谓的幻梦境之主，其次呢就是因为原著的结局会发现爱丽丝的奇遇是一场梦，光是这点就很有意思，两者揭露梦境的时间点完全相反。<br />
那么问题来了，已经在梦境了，如果再次做梦不就有了梦中梦？而如果是梦境是虚假，梦中梦则是虚假的虚假，会不会是真实呢？格林做过几次梦中梦呢，第一次是精神病院看到师匠，第二次是孢子之森的幻觉爱丽丝，第三次是海底的旅社，第四次是冬之钟adv，牛津学院的月面比较特殊就不论了，这几次梦中梦，虽然未必都是真实，但都揭示了部分真相或者现实。<br />
既然如此，有一个人就很奇怪了，睡鼠，她是格林外唯一一个能在梦境中沉睡的人，如果是格林自己的梦还可以做梦中梦，但睡鼠一个梦境中的角色怎么还能入梦呢？除非她只是装睡，对话中睡鼠会说她没有睡，所有人的对话她都没有听漏，这很有可能就是真相（虽然里线又说真在睡），并且她随后说了一句要杀了所有人，然后辩解说是梦话，结果全监禁后她真的这么做了。<br />
因此个人猜测睡鼠表面虽然入梦，但其实是最清醒敏锐的，她有着监视格林的任务，一旦格林不照着剧本做梦，滞留在一次轮回中，就会把风险清除掉，逼迫他进入下个轮回。<br />
而h结局中在冬之钟我们能看到三月兔和帽子屋，她们的对话反过来看就是冬之钟的本质，为什么只有这两个人呢？一是三人的对话提到除了睡鼠两人都想来冬之钟，二则是根据我的想法，此时格林意识上已经从梦里醒来，剩下的问题就是奈亚的爱欲，以及舞台带来的疯狂，也就是茶会的这两个人的象征。<br />
当然，以上不过是个人解读，大家看个乐就行。<br />
可能有人问，那么一代的茶会呢？这个由于时间线的原因我们以后再讲。</p>
<h1 id="section-3">04</h1>
<p>让我们开始第八章的分析<br />
七章末尾，爱丽丝被疯疯癫癫的三人惹恼，离开了茶会，进入了一片森林，在她迷路时出现了一道门，让她回到了最初的兔子洞大厅，随后她利用变大变小的能力走进了最初看到的庭院。<br />
这段路线，如果我们忽略茶会怎么回到兔子洞这个问题，可能对应利德尔墓地到心脏庭院，墓地这块确实是森林，并且进入庭院的入口确实是一道门，虽然顺序颇有些问题。<br />
原著中，入口旁的三个扑克园丁忙着把种错的白玫瑰刷成红心王后喜欢的红色，随后被王后发现要杀头，游戏中只有一个庭师在干活，而且不是上漆而是上血，另外两个则在说格里芬的闲话。可能是rpgmaker的素材问题，原著和游戏的扑克种类对不上<br />
原著中红心王后杀头的表达翻译过来大概是这样的：他们的头没了吗？士兵的回答是：“他们的头不见了”由此王后认为确实杀头了，这里是个文字游戏，原著中这三个园丁藏了起来，头确实看不见了，但没有杀头，这可能是游戏中红心女王不看处刑场面的由来。<br />
杀头后王后邀请爱丽丝打追球，但是球棍是火烈鸟，球是刺猬，两者都会在游戏出现，区别是火烈鸟0sen变成弯曲的球棍，球则在0sen才出现<br />
打球的时候公爵夫人来向爱丽丝搭话送了她几句教训，对应游戏中公爵夫人出现在追球场并且满口教训，随后王后再次出现在爱丽丝面前，带她回去打球，这次过程中王后把除了国王的所有人判了死刑，随后国王赦免了他们。<br />
可能是由于实际上外来者的缘故，红心王后也被魔改得很厉害，基本上只有性格和杀头的口头禅是还原原著的，此外，原著的红心王后虽然没杀过一个人的头（狮鹫的说法），但被所有身边人畏惧，这点也沿用到了游戏中，红心王后可能的原型是当时的英国女王，这也是为什么游戏中红城bgm是掷弹兵进行曲。公爵夫人会说红女王和红心女王一样残暴，这段可能来自于卡罗尔自己对两位皇后的解释。原著的红心国王直接删掉了，是梦游仙境唯二个游戏里没有对应的主要人物（还有个是红桃杰克），当然也有可能对应格林（笑）。<br />
之后，王后让狮鹫带爱丽丝去听假海龟的故事，对应游戏里罗丽娜发布布告让部下去讨伐食尸鬼，因为会在那里见到假海龟。原著中在女王走远后，狮鹫说到女王从来没有成功杀过一个人的头，对应游戏中格里芬说女王不敢看处刑场面<br />
这里顺便一提，狮鹫是卡罗尔任职的牛津学院的三一学院的院徽，假海龟出自当时用牛肉汤代替昂贵海龟汤的习惯，原著中狮鹫懒散，假海龟则惶恐不安，和游戏对应，假海龟哭哭啼啼地讲起了自己的故事，它曾在深海的学校上课云云，这里是非常典型卡罗尔造生词环节，游戏中有原台词化用<br />
说完上课的事后，狮鹫提出跳龙虾方块舞，游戏中则是龙虾舞，为什么呢，我给大家三秒钟猜一下，因为格里芬是方块骑士，所以已经有方块了，这很可能是方块骑士身份的来源，因为除此以外原著只有一些方块廷臣，其中的歌是假海龟唱的，游戏中也有体现，格里芬说自己不记得歌词<br />
随后狮鹫让爱丽丝背了几首诗，最后假海龟唱了一首海龟汤，对应游戏中让假海龟做料理的台词<br />
关于爱丽丝的线索，女王和格里菲会引导格林去市街，市街的卡面来打会引导格林去墓地方向，随后线索就断了。<br />
这之后就是梦游仙境最后一个场景，审判庭，关于审判这件事的信息，翻遍二代也只能找到狮鹫去邀请比尔当陪审员这件事，其中，他们会说审判已经发生过一遍，那么是在哪呢？<br />
很有可能是在一代的不思议之国。已然终结的茶会，最明显的是守门的班达斯奈奇，他提出的问题和答案部分和原著的审判相对应，茶会中的一只兔子会提到疯帽子三人以及爱丽丝的消失，这正是原著剧情，收集童话出现的里门，爱丽丝排列成类似法庭陪审团的形式面朝格林，这很有可能也是表示审判。<br />
此外，我也有些个人想法，杀害02得到的缎带物品描述是追寻梦中的爱丽丝，这几乎可以肯定指的二代，而爱丽丝原著正是在最后的审判后告诉我们一切都是梦，然后见到了姐姐，而这和一代也在读书的尸龙姐姐勉强对得上，审判后的爱丽丝消失了，奈亚丽丝用格林取代了她的位置一直梦游到了审判剧情前，这样一来就构成了一个循环，爱丽丝梦游仙境结束后开始格林梦游仙境，这是很有寿司风格的前后对照。<br />
此外，还有一种可能的解读是，审判其实是奈亚丽丝内部召开的，最后判决结果是把爱丽丝01驱逐出去，产生了红偶像<br />
总之，审判这段原著情节在bs有没有对应大家就见仁见智吧<br />
好了，这样一来对梦游仙境的解析就结束了，下一期作为拾遗篇，我会说说卡罗尔和利德尔三姐妹在游戏中的暗线。</p>
<h1 id="拾遗篇">拾遗篇</h1>
<p>查尔斯·道奇森，一个天赋型的数学家，笔名刘易斯.卡罗尔，最知名的作品是两本以知名幻想角色爱丽丝为主角的作品，与同时代知名的柯南道尔（福尔摩斯系列的作者）同是一个灵异研究学会的成员，还有一个较晚出生的知名的同时代人是克苏鲁体系的作者洛夫克拉夫特<br />
有意思的是以上提到的三人分别是三种文学流派的奠基人，并且这三种衍生文化不同程度地影响了bs系列<br />
1855年，卡罗尔23岁，结识了自己任职学院的院长一家，一年后认识了三姐妹，随后的时间他时常和这家的三姐妹一起聚会，1962年7月4日，一个黄金的午后，当时三姐妹的长女罗丽娜13岁，次女10岁，三女8岁，与卡罗尔一起泛舟湖上，卡罗尔讲了一个日后成为梦游仙境原稿的故事，两年后整理成了一部名为地底冒险的手稿送给次女。<br />
1863 年 6 月，利德尔一家和卡罗尔之间的关系突然破裂，没有直接证据能说明原因，几个月后有所缓和，但已经无法还原如初的美好了。<br />
再之后，长女没有在历史上留下痕迹，次女和三女都和一位王子有过绯闻，但可能因为身份原因没有成，可怜的三女在即将结婚时22岁因病早逝（精神病院的开门次数），似乎最受上天关爱的次女于28岁结婚，成为哈格里夫斯夫人。<br />
这是我们这个世界历史上的卡罗尔和三姐妹的故事。那么bs世界里这四人发生了什么呢？</p>
<p>最直接的证据是六段苦涩的回忆，虽然对他们的来龙去脉或是真假完全没有确论，但它们提供了大部分相关信息，我们按现实时间顺序一个一个说起。<br />
卡罗尔川的回忆直接用了梦游仙境的卷首诗，描述了这个故事的原初，并且由于卡罗尔生活时期正是英国盛世，泰晤士河污染严重，黄金午后的那条河流从属于泰晤士河，和游戏中污染的描述也对得上<br />
按现实顺序随后的应该是牛津学院的回忆，卡罗尔和利德尔一家的交恶<br />
随后则是槌球场，这里应该对应现实中黄金午后的两年后，卡罗尔送给了爱丽丝地底冒险手稿，这部手稿有卡罗尔自己的插画，但并非圣诞礼物，卡罗尔曾和爱丽丝一家打槌球玩，因此会出现在槌球场，但游戏中此时二家似乎没有交恶，因此bs中可能存在顺序调换。<br />
之后就是纯粹的架空时间线了<br />
之后是叹息的海边，回忆中摄影的阁楼有现实对应，正是牛津大学的建筑，回忆描述了两人的再次重逢，至于为什么是海边，可能是因为卡罗尔在1876年出版的《猎蛇鲨记》，这是他最后一部知名作品，次女和卡罗尔的重逢历史上没有什么资料，事实上，即使卡罗尔逝世时，次女也就46岁，不可能是老婆婆，但梦游仙境的改编的戏剧于1886年圣诞节期间上映，卡罗尔也去看了，顺便一提，演睡鼠的是一位叫多萝西的女士。这是有记载的卡罗尔最后一次见到次女，而有记载的次女最后一次与卡罗尔有交集，是在1932年卡罗尔逝后的100年诞辰，这时她已经80岁了<br />
再后面是库因兰德的回忆，库因兰德的女王原型是镜中奇遇的红女王，而镜中奇遇出版于1871年。这段回忆似乎提到卡罗尔把另一个人当做代餐，可能是bs世界观的罗丽娜？<br />
最后是完全架空的茶会回忆，和现实基本没有关系了。<br />
其次还有若干原著彩蛋在游戏中使用，如卷首诗，也就是第一段回忆的little和利德尔同音，血泪之池的鹦鹉和小鹰分别是长女和三女的书中化身，睡鼠的故事也化用了三姐妹的名字等</p>
<p>卡罗尔在bs中和现实基本对应得上，但还有的问题是，猎蛇鲨记，贾巴沃克等作品的来源没有交代，其中贾巴沃克这首诗尸龙基本给我们念了一遍，有可能原稿在她手上，此外卡罗尔虽然终身未婚，但依然有很多朋友，如猎蛇鲨记就受一位忘年交的启发，可能是冬之钟小剧场那张照片中的女人<br />
顺便一提，现实中的弗朗西斯.利德尔1965年出生，自他记事起卡罗尔和利德尔一家应该都不怎么来往了，现实中的三姐妹和当时的大部分贵族女性一样在家中由私教授课，不可能叫卡罗尔老师</p>
<p>之后我们来分别探讨一下三姐妹在bs的暗线<br />
现实中的长女资料最少，但书中的鹦鹉有卖弄自己年纪大的特点，并且有一种说法是，当年的长女对卡罗尔非常依恋，这些特点沿用到了游戏中，有可能bs中的卡罗尔倾吐虚假爱意的对象就是她。根据其自述，罗丽娜向邪神献祭灵魂才会来到不思议之国，但时间点未知，如果是在次女后，那么游戏中的罗丽娜是完全的少女心性就很奇怪了。还有一种说法是，罗丽娜和她的母亲名字一样，所以小剧场那张照片的真身有可能是……不过我觉得这可能很小就是了<br />
心脏女王也是个谜点重重的角色，如果我们给有梦游仙境原型的誓约角色所需魂数量排序，那么由小到大依次是白兔，渡渡，比尔，希夏，公爵夫人与假海龟，帽子屋，心脏女王<br />
其中除了假海龟都参照原作出场顺序，她虽然是乱入者，但不思议之国大部分住民都会提到并认同女王是名义上的统治者，她不知为何能指挥魔兽化的手下，让唯一有理智的格里菲去全国巡逻，每天用审判来控制人口，还给大工批了大把建筑费用来上达天听，不知道是奈亚的命令还是什么其他原因，她确实做了很多管理不思议之国的事，此外，还是唯一一个非格林子女却有里线战斗的<br />
三女伊迪丝在游戏中是精神病院的boss，对于她怎么来到箱庭，仅有的线索是混沌迷宫和电影院的两段没头没尾的故事，游戏里和三女私奔的王子，很可能也是杰克，这位角色现实原型之一很可能是利奥波德王子，正如前文所说，据传他曾与伊迪丝相爱，伊迪丝22岁早夭后，王子为她抬棺，王子和伊迪丝一样病弱，患有血友病，三女辞世的8年后，王子以30岁的年龄逝世，这或许是游戏中他也住院的原因，另外两个明显原型是开膛手杰克和福尔摩斯，或许是因为卡罗尔曾被看做开膛手杰克的嫌疑人，而同时代柯南道尔也曾经研究过这个案件，顺便一提上文王子的一个侄子也是一大嫌疑人<br />
伊迪丝在冬之钟小剧场里头戴着枯萎的花圈，可能暗示着她的早逝，并且多次有小鹰的元素出现，但罗丽娜除了大姐作风却没有明显的鹦鹉元素，这点也有些让人在意<br />
最后是次女，这里的次女指的是观星引来奈亚的人类个体，关于这个个体的信息反而是最少的，只知道她和卡罗尔心心相惜却被拆散，她和现实次女的履历是否一样未知，她的最终去向未知，牛津学院的学寮长是否就是她父亲的灵魂所化也未知。<br />
关于现实中的对应，现实的次女并非常见的金发形象而是黑发，并且和梦游仙境的爱丽丝有很多差异，游戏中似乎没怎么提到过发色，不知道如何设定，次女和南丁格尔是同时代的人，因此院长认识爱丽丝可能是认识人类状态的次女，此外，小剧场的次女会有很多致敬原著的台词，出示如下<br />
在群星之夜后，似乎她的名字成为了禁忌，也是里线剧情的关键，关于次女我还有一个，，<br />
等等，次女的名字，为什么，我想不起来次女的名字，对了，她的名字，她的名字不就是<br />
爱丽丝.利德尔<br />
勿呼其名，唤则得知，蠕动前行而来<br />
縺ｩ縺?＠縺ｦ遘√＇谤｢縺辅↑縺代ｌ縺ｰ縺ｪ繧峨↑縺??縺ｧ縺呐°<br />
繧｢繝ｪ繧ｹ繧呈尔縺励※缧ゅい繝ｪ繧ｹ繧呈?縺励※缧ゅい繝ｪ繧ｹ繧贞ｿ倥ｌ縺ｪ縺?〒缧<br />
诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ<br />
诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ诨帙＠縺ｦ</p>
<h1 id="ex01">ex01</h1>
<p>相较梦游仙境，镜中奇遇在bs中的对应情节明显变少，但依旧有分析的价值<br />
首先是镜中奇遇的卷首诗，这首诗提到了卡罗尔此时和现实的爱丽丝年龄相差一倍，语气中某种程度上可能透露了卡罗尔对无法回到往日时光的惋惜，不管怎么说，此时爱丽丝已经长大了，看童话故事的美好时光已经不会回来了<br />
开篇剧情中爱丽丝在和戴娜生下的小猫玩，对应普通结局少女的房间中柴郡猫说自己产下小猫后死去，虽然我们不知道现实的戴娜是怎么死的。<br />
随后爱丽丝会提到镜子屋，也就是镜子里的相反的房间，这在之后成为整本书的主题，在bs中镜子屋对应公爵夫人提到了通过血泪之池镜子才能到达的镜之国，但同样和镜子有莫大关系的还有一位小红帽，值得一提的是，镜之国库因兰德是为数不多没有柴郡猫出现的篝火。<br />
随后爱丽丝在镜子屋看到了一些会说话的棋子，并随意摆布它们，这段有点像bs奈亚的作风<br />
她翻到了一首叫贾巴沃克的诗，当然这里其实是卡罗尔引用之前的作品，贾巴沃克这首诗非常晦涩难懂，以后有机会我会谈谈在它在bs里的对应。<br />
之后爱丽丝飞跃滑下楼梯，想跑去屋外的花园，这里的下楼梯法在冬之钟小剧场有对应</p>
<p>爱丽丝想走到一座小山丘俯视花园上，但怎么走都会回到原点，这 里可能对应精神病院的走法，也可能对应库因兰德的迷宫，于是她只能转而去往一个小花园，遇到了一群会说话的花，这些花对应一代圣森和不思议之国的会说话的花，以及在bs2中，红女王的房间里的花，一些花很吵闹，爱丽丝威胁把它们拔下来，对应道具咒骂之花，<br />
随后爱丽丝遇到了红王后，原著中的红王后被卡罗尔描述为典型的家庭教师，原型可能就是爱丽丝的家教，bs中红女王的名字直接用了这位家教的名字，有一种说法是卡罗尔利用三姐妹来追求她造成两家决裂<br />
爱丽丝羡慕地说想成为王后，红王后告诉她需要前进八格，然后拉着她全力奔跑，贡献了一句经典台词，前进八格成后这是国际象棋的规则，而红王后的台词在bs中对应库因兰德的一个留言和冬之钟柴郡猫的台词<br />
值得一提的是在原著中有重要意义的棋盘在bs中也有同样的重要性，红女王的库因兰德遍布着棋子，梅贝尔在自己的箱庭部下棋局，而白女王则把王冠，也就是走了八步后成王的关键放在了冬之钟，可以推测原著中想要成后的爱丽丝其实对应着bs中想要得到改变权能而成王的格林。<br />
红王后指引爱丽丝成后的走法，提到了需要乘火车，对应去库因兰德的火车<br />
火车上爱丽丝遇到了一只会说话的虫子，在一阵颠簸后她们发现自己安静地坐在树下，爱丽丝和它讨论了一下命名学，虫子告诉爱丽丝前方有着无名之森，对应bs里的那张地图，这只虫子可能也对应无名之森的一只虫形怪物<br />
无名之森里爱丽丝遇到了一只小鹿，对应bs中无名之森的小鹿，但bs中通过无名之森才能坐火车，与原著相反<br />
本章的末尾，爱丽丝遇到了双子</p>
<h1 id="ex02">ex02</h1>
<p>爱丽丝接下来遇到的是崔德尔双子，二者一开始站立不动，让爱丽丝觉得他们是蜡人偶，也就是蜡像，游戏中反了过来，游戏中双子提到了站立不动的格林是蜡像的可能<br />
两兄弟的原型是一首英国童谣，童谣提到了丢失的拨浪鼓和飞来筑巢的乌鸦，在游戏双子的台词有体现，筑巢的大鸟应该就是伊迪丝<br />
随后两兄弟给爱丽丝背了首海象和木匠的诗，大意是海象和木匠偏小牡蛎来做客，然后把它们吃完了，游戏中很明显海象对应希伏契，木匠对应大工，吃牡蛎的剧情也在希伏契对话中有体现，且，双子誓约对话会提到两人<br />
之后，爱丽丝发现了附近正在做梦的红王，在双子对话中有原意复用<br />
双子中的蒂看到了他弄坏的拨浪鼓，让两兄弟起了矛盾，对应游戏中的台词，随后两人约定决斗，可能对应游戏里的双子相残，就在这时乌鸦飞了过来，打断了决斗<br />
书中的两兄弟按棋谱来说是白方，这解释了她们为何与dlc3的克里米亚有一定关系</p>
<p>为了躲避大鸟，爱丽丝逃进树林遇到了白王后，与严肃的红王后不同，白王后非常随和友好，并且她声称自己是倒着过日子的，这解释了白女王诺登管理重启轮回的职能<br />
交谈一会后，爱丽丝突然转移到了一间商店里，店主是一只绵羊，发生了很多怪事后爱丽丝又闪现到了小船上和绵羊一起划船，对应游戏里老羊的台词<br />
书中这段空间转换非常频繁，可能因此寿司在老羊商店里放了一堆来源不明的谏言</p>
<p>一连串的转换后爱丽丝看到了矮胖子，这位角色也来自于一首英国民谣，矮胖子很多台词台词在游戏里有直接对应，整理如下<br />
值得一提的是矮胖子解释了一些贾巴沃克诗的生造词，为后世的译者提供了不少信息。<br />
在爱丽丝和它不欢而散后，听到了蛋壳碎裂的声音，暗示它的跌落，但游戏中矮胖子是因为孵化而裂开</p>
<p>爱丽丝再次前进，遇到了白国王和他的部下，信差告诉了他独角兽和狮子为了王冠争斗，这里的两只动物对应苏格兰和英格兰，并且依旧来源于一首民谣，游戏中冬之钟小剧场长女会引用，并且冬之钟也有很多争斗的对应情节，整理如下<br />
独角兽傲慢，狮子凶恶，游戏中有一定程度上的体现，两者对应的棋子走法一个诡异难测，一个横冲直撞，也在游戏中对应</p>
<p>随后，爱丽丝遇到了前来将她军的红骑士，但埋伏在旁的白骑士反吃了红骑士，护送爱丽丝成王前的最后一段路，这段几乎没有在游戏里的直接对应，除了冬之钟小剧场he中卡罗尔让三姐妹为他挥手帕用了原台词，并且也有说法是白骑士是作者的投影。<br />
但我个人对此有一些猜测，这段很可能对应整个冬之钟剧场，根据一些主流猜测，这段其实是梅贝尔和古兰合谋困住了追击的奈亚，如果我们认为红方是敌方，那么就对应奈亚，指引爱丽丝成王的红王后对应反水的红女王，红骑士表示前来追击的奈亚，白骑士就可能是白女王方的梅贝尔，那么这段剧情就成了，奈亚前来将住格林，梅贝尔前来解围，护送格林到了成王之路</p>
<p>终于，爱丽丝戴上了王冠，格林成了“王”，在此之后的剧情对应很少，青蛙佣人招待爱丽丝去了晚宴，对应游戏中去往古兰晚宴前向海因里希托付女儿，爱丽丝梦醒后红白王后成了黑白两只小猫，对应红女王的台词，可能会在续作有进一步的阐释</p>
<p>至此，对卡罗尔爱丽丝系列的作品就完全结束了，之后有机会可以说说贾巴沃克和猎蛇鲨记</p>
<h1 id="ex03">ex03</h1>
<p>猎蛇鲨记是卡罗尔最后一部知名作品，讲述了一群船员狩猎一种幻想怪物——蛇鲨的故事，不知道为什么，这些船员的称呼都是B开头(织帽人除外)，最后他们寻找到了蛇鲨，然而这个蛇鲨其实是一种名为博基姆的怪物，所有遇到它的人都会离奇失踪，诗中还补充了对两个原创词语贾布加布与班达斯奈奇的设定，我们分人物说起</p>
<ol type="1">
<li><p>弁护士<br />
原诗中，律师梦到蛇鲨在法庭上为一头猪辩护，法官让它把判决书也一起写了，但当判决完后，狱警通告说被告已经死了<br />
游戏中可以在红城的处刑场捡到弁护士的面具，描述是，死刑在前，判决在后，与原著相对应</p></li>
<li><p>银行家<br />
原著中银行家掌管船上的所有资产，在终章前的最后一节，被班达斯奈奇抓住，虽然船长救下了他，但已经疯掉了<br />
游戏里就没有这么好运了，可以在班达斯奈奇的洞穴里看到他的尸体，搜尸得到银行家戒指</p></li>
<li><p>屠夫<br />
屠夫是原著最后介绍的船员，他声称自己只会杀海狸，这让船上的海狸非常害怕，在之后狩猎蛇鲨时，他们遇到了贾布加布，这里补充了它的歌声让人发狂的设定，但屠夫给海狸上了数学课和自然历史课，所以他们从精神攻击里幸存了，成为了好朋友<br />
在游戏里屠夫是屠宰场的boss，杀了海狸后精分地扮演海狸，可能是被狂鸟的歌声影响了，同时台词也大量引用原文</p></li>
<li><p>擦鞋人布茨<br />
布茨这个名字其实是对boots直接音译，这个单词同时有鞋子和擦鞋人两种意思<br />
原著中布茨没有台词，或者说几乎没有单独描写，但在最后的蛇鲨狩猎中，面包师找到蛇鲨时喊出了"boo"音，唯一与这个音相同的只有boots，并且布茨也是唯一没有原版插图的人，所以有布茨就是博基姆的说法，在游戏中采用，也就是说攻击布茨就会触发博基姆Boos战<br />
此外，boots还有一层意思，如果带着船员服去找他，会出现隐藏对话提到幽冥号，这是航海史上的著名惨案，简单地说有位叫富兰克林的探险家，曾经在一次探险中遇难，为了充饥不得不吃自己的靴子，由此得到外号吃靴子的人，之后在他的一次去北极的探险中被冰层困住，全船遇难。<br />
富兰克林可能就是布茨灵魂的真正原型，而擦鞋人和博基姆则是角色身份</p></li>
<li><p>唤铃人<br />
游戏中的唤铃人是鱼市场的boss，并且会召唤织帽人，计分人，经纪人三个原著中也没什么存在感的船员出来，boss战的对话基本上都是引用原文<br />
为什么只有这四个人可以成为亡者继续狩猎也是个谜</p></li>
<li><p>面包师<br />
原著中面包师是比较像主角的一个存在，他上船时是失忆的，随后想起来博基姆这种怪物的存在，并在最后因为遇到了博基姆而失踪<br />
有人认为面包师的原型是卡罗尔一个叔叔，并且用来影射自己，如果用这种说法来看，面包师就是格林自己，而且失忆也对得上，甚至寻找蛇鲨却遇到了博基姆也像是对二代剧情的一个隐喻</p></li>
</ol>
<p>总结：<br />
与卡罗尔的大部分作品一样，猎蛇鲨记也充斥着意义不明的各种名词和迷幻的叙事，bs2中的猎蛇鲨记角色是只是彩蛋，还是与没有解答的其他谜题有关，这就有待续作了<br />
值得一提的是，猎蛇鲨记唯一没有涉及到的人物就是卡罗尔在序言诗中执意的忘年交——格特鲁德·查塔维，正如爱丽丝的待遇一样，序言诗的每行首字母可以拼出她的名字，但这位现实中的重要角色在游戏中难觅其踪</p>
]]></content>
      <categories>
        <category>游戏杂谈</category>
        <category>black souls</category>
      </categories>
      <tags>
        <tag>游戏杂谈</tag>
        <tag>black souls</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb备忘录</title>
    <url>/thinklive/27780/</url>
    <content><![CDATA[<h1 id="javase">javase</h1>
<p><strong>static</strong></p>
<ul>
<li>静态方法属于类，所以在静态方法中，无法获取成员变量的值,但是静态方法可以访问到静态变量<br />
</li>
<li>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</li>
</ul>
<span id="more"></span>
<p><strong>package</strong><br />
包类似于C++中的namespace</p>
<table>
<thead>
<tr class="header">
<th>当前类</th>
<th>同一个包下的类</th>
<th>不同包下的子类</th>
<th>不同包下的类</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr class="even">
<td>protected</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr class="odd">
<td>默认</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr class="even">
<td>private</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p><strong>类的继承</strong></p>
<ul>
<li>标记为<code>final</code>的类不允许被继承：</li>
<li>父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问，但是依然继承了这个属性</li>
<li>如果父类存在一个有参构造方法，子类必须在构造方法中调用</li>
<li>在使用子类时，可以将其当做父类来使用，也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类</li>
<li><code>a instanceof b</code> 判断a是否是b的一个子类或者实例</li>
<li>子类可以定义和父类同名的属性，这时可以使用<code>super</code>关键字来表示父类</li>
<li>所有类都默认继承自Object类</li>
<li><code>a.equals(b)</code>用于比较a,b是否是同一个对象</li>
</ul>
<p><strong>重写override</strong></p>
<ul>
<li>方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现</li>
<li>重写方法要求与父类的定义完全一致</li>
<li>静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。</li>
<li>我们如果不希望子类重写某个方法，我们可以在方法前添加<code>final</code>关键字,如果父类中方法的可见性为<code>private</code>，那么子类同样无法访问</li>
<li>在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用<code>super</code>关键字</li>
<li>子类在重写父类方法时，不能降低父类方法中的可见性,但是可以在子类中提升权限</li>
</ul>
<p><strong>抽象类</strong></p>
<ul>
<li>子类，必须要实现抽象类中所有抽象方法，无法直接通过new关键字来直接创建对象</li>
<li>抽象方法的访问权限不能为<code>private</code></li>
</ul>
<p><strong>接口</strong></p>
<ul>
<li>接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能</li>
<li>从Java8开始，接口中可以存在方法的默认实现</li>
<li>接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，接口中定义的静态变量只能是public static final</li>
<li>接口是可以继承其他接口，相当于是对接口功能的融合</li>
</ul>
<p><strong>深浅复制</strong></p>
<ul>
<li>虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的<code>clone</code>方法只会进行浅拷贝</li>
<li>枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量，可以给枚举类型添加独有的成员方法</li>
</ul>
<p><strong>包装类</strong></p>
<ul>
<li>byte -&gt; Byte</li>
<li>boolean -&gt; Boolean</li>
<li>short -&gt; Short</li>
<li>char -&gt; Character</li>
<li>int -&gt; Integer</li>
<li>long -&gt; Long</li>
<li>float -&gt; Float</li>
<li>double -&gt; Double</li>
</ul>
<p>包装类型支持自拆装箱，可以直接将一个对应的基本类型值作为对应包装类型引用变量的值,当然也可以相反<br />
<code>Integer i = 10;</code><br />
<code>Integer i = 10; int a = i;</code><br />
通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为存在IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象，IntegerCache会默认缓存-128~127之间的所有值，如果超出这个缓存范围的话，就会得到不同的对象了<br />
BigDecimal可以实现小数和极大树的精确计算。<br />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[]&#123;...&#125;; <span class="comment">//静态初始化（直接指定值和大小） </span></span><br><span class="line">类型[] 变量名称 = &#123;...&#125;; <span class="comment">//同上，但是只能在定义时赋值</span></span><br></pre></td></tr></table></figure> 创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的</p>
<p><strong>字符串</strong><br />
Java中没有字符串这种基本类型，因此只能使用类来进行定义,每个用双引号括起来的字符串，都是String类型的一个实例对象<br />
如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象<br />
字符串的内容比较，一定要用equals<br />
字符串和字符数组的转换<br />
<code>char[] chars = str.toCharArray();</code><br />
<code>String str = new String(chars);</code><br />
<code>str.matches("[abc]*")</code>调用正则表达式进行匹配，返回bool值</p>
<p><strong>类</strong><br />
成员内部类中，可以访问到外层的变量<br />
静态内部类就像静态方法和静态变量一样，是属于类的，可以直接创建使用,但无法访问到外部类的非静态内容 不需要依附任何对象，就可以直接创建静态内部类的对象<br />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123; </span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; </span><br><span class="line">			System.out.println(<span class="string">&quot;我是静态内部类！&quot;</span>); </span><br><span class="line">			&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在new的时候，后面加上花括号，内部可以定义一个匿名类<code>Student student = new Student() &#123;&#125;</code>此时创建出来的Student对象，就是一个已经实现了抽象方法的对象</p>
<p><strong>Lambda表达式</strong></p>
<ul>
<li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li>
<li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li>
<li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">//待实现的求和方法 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a, b) -&gt; a + b; </span><br><span class="line">&#125;			</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a, b) -&gt; Integer.sum(a, b); <span class="comment">//直接使用Integer为我们通过好的求和方法 </span></span><br><span class="line">    System.out.println(study.sum(<span class="number">10</span>, <span class="number">20</span>)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> Integer::sum; <span class="comment">//使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式</span></span><br><span class="line">    System.out.println(study.sum(<span class="number">10</span>, <span class="number">20</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现<br />
成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式<br />
构造方法也可以被引用，使用new表示</p>
<p>所有的运行时异常都继承自<code>RuntimeException</code> 断言表达式需要使用到<code>assert</code>关键字，如果assert后面的表达式判断结果为false，将抛出AssertionError错误。</p>
<p><strong>泛型</strong><br />
泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。<br />
<code>public class Score&lt;T&gt;</code>类似cpp的模板<br />
因为是具体使用对象时才会明确具体类型，所以静态方法中无法使用<br />
如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用<code>?</code>通配符<br />
<code>Test&lt;?&gt; test = new Test&lt;Integer&gt;();</code><br />
泛型只能确定为一个引用类型，基本类型是不支持的(不包括数组，数组本身是引用类型),如果要存放基本数据类型的值，只能使用对应的包装类<br />
当子类实现泛型接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型，继承等同理</p>
<p>在泛型变量的后面添加<code>extends</code>关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类<code>public class Score&lt;T extends Number&gt;</code><br />
在进行类型判断时，不允许使用泛型，只能使用原始类型<br />
泛型类不支持创建参数化类型数组(类型擦除导致的，运行时不会检查具体类型是什么)<br />
<code>Test&lt;String&gt; test = new Test&lt;&gt;(); System.out.println(test instanceof Test);</code></p>
<p><strong>函数式接口</strong><br />
函数式接口就是JDK1.8专门为我们提供好的用于Lambda表达式的接口，这些接口都可以直接使用Lambda表达式</p>
<p>**Supplier供给型函数式接口：这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象<br />
Consumer消费型函数式接口：这个接口专门用于消费某个对象的。<br />
Function函数型函数式接口：这个接口消费一个对象，然后会向外供给一个对象（前两个的融合体）<br />
Predicate断言型函数式接口：接收一个参数，然后进行自定义判断并返回一个boolean结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span></span><br><span class="line">&#123;</span><br><span class="line">	Optional .ofNullable(str) <span class="comment">//将传入的对象包装进Optional中 </span></span><br><span class="line">		.ifPresent(s -&gt; System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+s.length())); <span class="comment">//如果不为空，则执行这里的Consumer实现 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Optional</strong><br />
<code>String s = Optional.ofNullable(str).get(); //get方法可以获取被包装的对象引用，但是如果为空的话，会抛出异常</code><br />
<code>String s = Optional.ofNullable(str).orElse("我是为null的情况备选方案");</code></p>
<p><strong>java的集合类</strong>(如果两个对象使用<code>equals</code>方法相等，那么集合中就是相同的两个对象)：</p>
<ul>
<li><p>ArrayList</p></li>
<li><p>List，有序线性表</p></li>
<li><p>LinkedList,双向链表</p></li>
<li><p>只要是实现了迭代器接口的类（可以自己实现），都可以使用<code>foreach</code>语法： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) </span><br><span class="line">&#123; <span class="comment">//每次循环一定要判断是否还有元素剩余 </span></span><br><span class="line">    System.out.println(iterator.next()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>ListIterator是对list类的特化双向迭代器</p></li>
<li><p>Queue队列，Deque双向队列,其中deque有正反向的迭代器<code>descendingIterator</code>和<code>iterator</code></p></li>
<li><p>PriorityQueue优先级队列，可以自己实现<code>Comparator</code>接口</p></li>
<li><p>Set集合，不允许出现重复元素，不支持随机访问</p>
<ul>
<li>HashSet，哈希实现，无法维持插入顺序</li>
<li>TreeSet，元素插入时排序</li>
</ul></li>
<li><p>Collections是专用于集合操作的工具类，类似Array</p></li>
<li><p>Map映射，新插入的相同键会覆盖原来的，在获取一个不存在的映射时，默认会返回null作为结果(可以设置默认值)</p>
<ul>
<li>默认不维护插入顺序，LinkedHashMap实现维护</li>
</ul></li>
<li><p>Stream流水线，有点像numpy的管道 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list = list <span class="comment">//链式调用 </span></span><br><span class="line">.stream() <span class="comment">//获取流 </span></span><br><span class="line">.filter(e -&gt; !e.equals(<span class="string">&quot;B&quot;</span>)) <span class="comment">//只允许所有不是B的元素通过流水线 </span></span><br><span class="line">.collect(Collectors.toList()); <span class="comment">//将流水线中的元素重新收集起来，变回List</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong>I/O操作</strong></p>
<ul>
<li><code>FileInputStream inputStream = new FileInputStream("路径");</code></li>
<li><code>inputStream.available(); //查看剩余数量</code></li>
<li><code>inputStream.read((byte[]) bytes); //一次性读取全部内容（返回值是读取的字节数）</code></li>
<li>输出流使用<code>write()</code>类似read</li>
<li>字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用<code>FileReader | FileWriter</code></li>
<li>为了避免频繁I/O,可以使用缓冲字节流<code>BufferedInputStream</code>缓冲字符流<code>BufferedReader</code></li>
<li>转换流<code>InputStreamReader和OutputStreamWriter</code>用于将字符信息转换成字节用于流的输入输出</li>
<li>打印流<code>PrintStream</code>可以控制打印到的对象(向文件打印则是一个文件输出流对象)，默认是控制台，<code>Scanner</code>默认接受系统输入流，也可以指定输入流</li>
<li>数据流<code>DataInputStream | dataOutputStream</code>用于写入基本数据类型</li>
<li>对象流<code>ObjectOutputStream</code>用序列化形式存储对象(也可以让某些属性不序列化)，用<code>private static final long serialVersionUID</code>作为类的标识用于区分版本，并且用于从流式数据还原出对象</li>
</ul>
<p><strong>java的多线程</strong></p>
<ul>
<li>创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（在另一个线程执行的内容逻辑）</li>
<li>调用<code>sleep()</code>方法来将当前线程进入休眠；<code>interrupt()</code>方法给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理</li>
<li>优先级
<ul>
<li>MIN_PRIORITY 最低优先级</li>
<li>MAX_PRIORITY 最高优先级</li>
<li>NOM_PRIORITY 常规优先级</li>
</ul></li>
<li><code>yield()</code>方法来将当前资源让位给其他同优先级线程;使用<code>join()</code>方法来实现线程的加入,让一个线程等待加入的线程执行完成后再继续进行</li>
<li>synchronized关键字创造一个线程锁;<code>jstack</code>命令来检测死锁;</li>
<li>对象的<code>wait()</code>方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的<code>notify()</code>方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。必须是在持有锁的情况下使用</li>
<li>ThreadLocal类，来创建工作内存中的变量，不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量</li>
<li>可以通过创建一个Timer类来让它进行定时任务调度,并且该类维护<code>TaskQueue</code>和<code>TimerThread</code>循环读取任务，闲则<code>wait</code>,调用<code>cancel()</code>方法来关闭工作线程</li>
<li>其他所有的非守护线程结束之后，守护线程自动结束,守护线程中产生的新线程也是守护的<code>t.setDaemon(true)</code></li>
</ul>
<p><strong>反射</strong></p>
<ul>
<li><p>反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。</p></li>
<li><p>在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应 <img src="/assets/resources/Pasted%20image%2020240103102915.png" /></p></li>
<li><p>反射机制利用这些存放的类信息Class对象，来获取类的信息和操作类。</p></li>
<li><p>通过反射可以对类进行精准的判断，精细区分子类，父类</p></li>
<li><p>可以通过反射来创造类对象，调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用,并且这些对类的操作可以无视权限控制，也可以去除final关键字</p></li>
<li><p>这样一来，就可以通过编译完的class文件来反向操作其中的类</p></li>
</ul>
<p><strong>注解</strong></p>
<p>注解可以被标注在任意地方,与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。<br />
可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型.如<code>String value();</code><br />
可以使用<code>getAnnotations()</code>方法来快速获取我们标记的注解。</p>
<ul>
<li><span class="citation" data-cites="Override">@Override</span> - 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li><span class="citation" data-cites="Deprecated">@Deprecated</span> - 标记过时方法。如果使用该方法，会报编译警告。</li>
<li><span class="citation" data-cites="SuppressWarnings">@SuppressWarnings</span> - 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时）</li>
<li><span class="citation" data-cites="FunctionalInterface">@FunctionalInterface</span> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li><span class="citation" data-cites="SafeVarargs">@SafeVarargs</span> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
</ul>
<p>元注解是作用于注解上的注解，用于我们编写自定义的注解：</p>
<ul>
<li><span class="citation" data-cites="Retention">@Retention</span> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li><span class="citation" data-cites="Documented">@Documented</span> - 标记这些注解是否包含在用户文档中。</li>
<li><span class="citation" data-cites="Target">@Target</span> - 标记这个注解应该是哪种 Java 成员。</li>
<li><span class="citation" data-cites="Inherited">@Inherited</span> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li>
<li><span class="citation" data-cites="Repeatable">@Repeatable</span> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<p><strong>java新特性</strong>：</p>
<ul>
<li>8：只有一个方法要实现的类可以直接传入一个匿名函数，匿名函数的写法也可以简化，比如只有一个参数时省略括号</li>
<li>方法引用，包括静态方法，对象的方法，构造函数等</li>
<li>Optional用于处理空指针异常</li>
<li>9：创建一个新的项目，并在<code>src</code>目录下，新建<code>module-info.java</code>文件表示此项目采用模块管理机制，模块内部对能够对库以模块为单位调用</li>
<li>如果模块没有明确授权给其他模块使用反射的权限，那么其他模块是不允许使用反射进行修改的，也可以用<code>open</code>开放反射</li>
<li>模块可以指定对某些接口的依赖</li>
<li><code>jshell</code>可以进行交互式编程</li>
<li>接口可以提供private实现</li>
<li>集合类可以用<code>of</code>方法快速创建，但创建后无法修改</li>
<li>10:<code>var</code>自动类型推断，类似c++，只发生在编译期间</li>
<li>11:全新的<code>Http Client API</code>,支持最新的HTTP2和WebSocket协议</li>
<li>12-16:更简洁的switch,有类似python的yield</li>
<li>三引号表示复杂字符串，特殊符号不需要转义</li>
<li>类似<code>if(obj instanceof Student student)</code>的语法可以直接进行安全的类型转化</li>
<li>Account类可以直接提供一个有name和passwd大部分功能的类</li>
<li>17：秘封类可以指定能继承的子类，其他类无法继承<code>public sealed class A permits B //在class关键字前添加sealed关键字，表示此类为密封类型，permits后面跟上允许继承的类型，多个子类使用逗号隔开</code></li>
</ul>
<p><strong>gui组件</strong></p>
<p>awt:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">better_gui</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>();   <span class="comment">//Frame是窗体，我们只需要创建这样一个对象就可以了，这样就会直接创建一个新的窗口  </span></span><br><span class="line">        <span class="type">Dimension</span> <span class="variable">screenSize</span> <span class="operator">=</span> Toolkit.getDefaultToolkit().getScreenSize();  <span class="comment">//获取到屏幕尺寸  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) ((screenSize.getWidth() - frame.getWidth()) / <span class="number">2</span>);   <span class="comment">//居中位置就是：屏幕尺寸/2 - 窗口尺寸/2  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) ((screenSize.getHeight() - frame.getHeight()) / <span class="number">2</span>);  </span><br><span class="line">        frame.setSize(<span class="number">500</span>, <span class="number">300</span>);   <span class="comment">//可以使用setSize方法设定窗体大小  </span></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);    <span class="comment">//默认情况下窗体是不可见的，我们如果要展示出来，还需要设置窗体可见性  </span></span><br><span class="line">        frame.setLocation(x, y);   <span class="comment">//位置设置好了之后再展示出来  </span></span><br><span class="line">        frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;   <span class="comment">//windowClosing方法对应的就是窗口关闭事件  </span></span><br><span class="line">                frame.dispose();    <span class="comment">//当我们点击X号关闭窗口时，就会自动执行此方法了  </span></span><br><span class="line">                <span class="comment">//使用dispose方法来关闭当前窗口  </span></span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosed</span><span class="params">(WindowEvent e)</span> &#123;   <span class="comment">//对应窗口已关闭事件  </span></span><br><span class="line">                System.out.println(<span class="string">&quot;窗口已关闭！&quot;</span>);   <span class="comment">//当窗口成功关闭后，会执行这里重写的内容  </span></span><br><span class="line">                System.exit(<span class="number">0</span>);    <span class="comment">//窗口关闭后退出当前Java程序  </span></span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;);  </span><br><span class="line">        frame.addKeyListener(<span class="keyword">new</span> <span class="title class_">KeyAdapter</span>() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span> &#123;    <span class="comment">//监听键盘输入事件，当我们在窗口中敲击键盘输入时会触发  </span></span><br><span class="line">                System.out.print(e.getKeyChar());   <span class="comment">//可以通过KeyEvent对象来获取当前事件输入的对应字符  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        frame.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent e)</span> &#123;   <span class="comment">//mouseClicked是监听鼠标点击事件（必须要用真的鼠标点击，不知道为啥，笔记本的触摸板不行，可能是MacOS的BUG吧）  </span></span><br><span class="line">                System.out.println(<span class="string">&quot;鼠标点击：&quot;</span> + e.getX() + <span class="string">&quot;,&quot;</span> + e.getY());  </span><br><span class="line">                System.out.println(<span class="string">&quot;鼠标点击的按键：&quot;</span> + e.getButton());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//边界布局：  </span></span><br><span class="line">        <span class="type">BorderLayout</span> <span class="variable">borderLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BorderLayout</span>();  </span><br><span class="line">        borderLayout.setHgap(<span class="number">50</span>);   <span class="comment">//Hgap是横向间距  </span></span><br><span class="line">        borderLayout.setVgap(<span class="number">50</span>);   <span class="comment">//Vgap是纵向间距  </span></span><br><span class="line"><span class="comment">/*        frame.add(new Button(&quot;1号按钮&quot;), BorderLayout.WEST);  //在添加组件时，可以在后面加入约束  </span></span><br><span class="line"><span class="comment">        frame.add(new Button(&quot;2号按钮&quot;), BorderLayout.EAST);  </span></span><br><span class="line"><span class="comment">        frame.add(new Button(&quot;3号按钮&quot;), BorderLayout.SOUTH);  </span></span><br><span class="line"><span class="comment">        frame.add(new Button(&quot;4号按钮&quot;), BorderLayout.NORTH);  </span></span><br><span class="line"><span class="comment">        frame.add(new Button(&quot;5号按钮&quot;), BorderLayout.CENTER);*/</span>  </span><br><span class="line">        <span class="comment">//frame.setLayout(borderLayout);   //使用边界布局  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//流式布局:  </span></span><br><span class="line">        <span class="type">FlowLayout</span> <span class="variable">flowLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.RIGHT);<span class="comment">//采用流式布局,指定为右对齐  </span></span><br><span class="line">        flowLayout.setHgap(<span class="number">50</span>);  </span><br><span class="line">        flowLayout.setVgap(<span class="number">0</span>);  </span><br><span class="line">        <span class="comment">//frame.setLayout(flowLayout);  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//卡片布局：  </span></span><br><span class="line">        <span class="comment">//CardLayout layout = new CardLayout();  </span></span><br><span class="line"><span class="comment">/*        frame.add(new Label(&quot;我是1号&quot;));  </span></span><br><span class="line"><span class="comment">        frame.add(new Label(&quot;我是2号&quot;));*/</span>  </span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);  </span><br><span class="line">        <span class="comment">//frame.setLayout(layout);  </span></span><br><span class="line">        <span class="comment">/*while (true) &#123;            Thread.sleep(3000);            layout.next(frame);    //我们需要使用CardLayout对象来进行切换  </span></span><br><span class="line"><span class="comment">        &#125;*/</span>  </span><br><span class="line">        <span class="comment">//网格布局：  </span></span><br><span class="line">       <span class="comment">/* GridLayout gridLayout = new GridLayout();  </span></span><br><span class="line"><span class="comment">        gridLayout.setRows(2);        frame.setLayout(gridLayout);        for (int i = 0; i &lt; 10; i++)            frame.add(new Button(i + &quot;号按钮&quot;));*/</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//GridBagLayout是网格布局的更自由版本  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//面板是更高层的一级容器  </span></span><br><span class="line">        <span class="type">GridLayout</span> <span class="variable">layout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridLayout</span>();   <span class="comment">//先设置整个窗口的布局  </span></span><br><span class="line">        layout.setRows(<span class="number">2</span>);     <span class="comment">//设置行数为2，一会就会分成两行了  </span></span><br><span class="line">        frame.setLayout(layout);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Panel</span> <span class="variable">top</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();  </span><br><span class="line">        top.setBackground(Color.PINK);  </span><br><span class="line">        top.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());    <span class="comment">//面板默认会采用FlowLayout，所以说这里指不指定都一样  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)    <span class="comment">//面板就像窗口一样，可以设定布局和添加组件  </span></span><br><span class="line">            top.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;流式&quot;</span>+i));  </span><br><span class="line">        frame.add(top);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Panel</span> <span class="variable">bottom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();  </span><br><span class="line">        bottom.setBackground(Color.ORANGE);  </span><br><span class="line">        bottom.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>());   <span class="comment">//下半部分我们采用网格布局  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)  </span><br><span class="line">            bottom.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;网格&quot;</span>+i));  </span><br><span class="line">        frame.add(bottom);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">ScrollPane</span> <span class="variable">scrollPane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollPane</span>();   <span class="comment">//创建滚动面板  </span></span><br><span class="line">        frame.add(scrollPane);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//滚动条  </span></span><br><span class="line"><span class="comment">/*        GridLayout layout = new GridLayout();    //创建滚动面板内部的要展示的面板  </span></span><br><span class="line"><span class="comment">        layout.setRows(20);        Panel panel = new Panel();        panel.setLayout(layout);        for (int i = 0; i &lt; 20; i++)            panel.add(new Button(&quot;我是按钮&quot;+i));   //为面板添加按钮  </span></span><br><span class="line"><span class="comment">        scrollPane.add(panel);*/</span>  </span><br><span class="line">        <span class="comment">//菜单  </span></span><br><span class="line">        <span class="type">MenuBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuBar</span>();    <span class="comment">//创建菜单栏  </span></span><br><span class="line">        <span class="type">Menu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;我是1号菜单&quot;</span>);  </span><br><span class="line">        menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试1&quot;</span>));  </span><br><span class="line">        menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试2&quot;</span>));  </span><br><span class="line">        bar.add(menu);  </span><br><span class="line">        frame.setMenuBar(bar);    <span class="comment">//为窗口设定刚刚定义好的菜单栏  </span></span><br><span class="line">        <span class="type">MenuItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试1&quot;</span>);  </span><br><span class="line">        item.addActionListener(e -&gt; System.out.println(<span class="string">&quot;一号选项被点击了！&quot;</span>));  </span><br><span class="line">        menu.add(item);  </span><br><span class="line">       <span class="comment">/* MenuItem item = new MenuItem(&quot;测试1&quot;);  </span></span><br><span class="line"><span class="comment">        item.setShortcut(new MenuShortcut(&#x27;A&#x27;));   //MenuShortcut就是指定快捷键组合，默认情况下是Ctrl+指定按键  </span></span><br><span class="line"><span class="comment">//item.setShortcut(new MenuShortcut(&#x27;A&#x27;, true));   //第二个参数指定为true表示需要Ctrl+Shift+指定按键*/</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*        Dialog dialog = new Dialog(frame, &quot;我是对话框&quot;, true);  </span></span><br><span class="line"><span class="comment">        dialog.setResizable(false);        dialog.add(new Label(&quot;确定是否要退出程序？&quot;), BorderLayout.NORTH);   //对话框默认采用的是边界布局  </span></span><br><span class="line"><span class="comment">        dialog.add(new Button(&quot;取消&quot;), BorderLayout.WEST);  </span></span><br><span class="line"><span class="comment">        dialog.add(new Button(&quot;不退出&quot;), BorderLayout.EAST);  </span></span><br><span class="line"><span class="comment">        dialog.setSize(200, 80);*/</span>  </span><br><span class="line">        <span class="type">FileDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDialog</span>(frame, <span class="string">&quot;请选择一个文件&quot;</span>, FileDialog.LOAD);  </span><br><span class="line">  </span><br><span class="line">        frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;  </span><br><span class="line">                dialog.setVisible(<span class="literal">true</span>);   <span class="comment">//注意，需要将对话框展示出来之后，才能进行选择  </span></span><br><span class="line">                <span class="comment">//选择完成之后getDirectory和getFile方法就可以返回结果了，否则会阻塞  </span></span><br><span class="line">                System.out.println(<span class="string">&quot;选择的文件为：&quot;</span>+dialog.getDirectory() + dialog.getFile());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swing:<br />
Swing 是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT 所能够提供的所有功能，并且用纯粹的Java代码对AWT 的功能进行了大幅度的扩充。通常把Swing控件称为轻量级控件<br />
swing不依赖操作系统，可以跨平台实现统一的外观效果<br />
Swing在没有设定布局时，组件的坐标原点并不是窗口的左上角，而是窗口标题栏下方的左上角：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">swing_gui</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);  </span><br><span class="line">        frame.setSize(<span class="number">500</span>, <span class="number">300</span>);  </span><br><span class="line">        frame.setLayout(<span class="literal">null</span>);  </span><br><span class="line">        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);  </span><br><span class="line">        button.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);  </span><br><span class="line">  </span><br><span class="line">        frame.add(button);  </span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">JMenuBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuBar</span>();    <span class="comment">//JMenuBar对应的就是MenuBar  </span></span><br><span class="line">        <span class="type">JMenu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenu</span>(<span class="string">&quot;我是菜单&quot;</span>);  </span><br><span class="line">        menu.add(<span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;选项1&quot;</span>));  </span><br><span class="line">        menu.add(<span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;选项2&quot;</span>));  </span><br><span class="line">        bar.add(menu);  </span><br><span class="line">        frame.setJMenuBar(bar);  </span><br><span class="line">        frame.setSize(<span class="number">500</span>, <span class="number">300</span>);  </span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">JProgressBar</span> <span class="variable">pbar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JProgressBar</span>();   <span class="comment">//进度条显示文件拷贝进度  </span></span><br><span class="line">        pbar.setMaximum(<span class="number">1000</span>);  </span><br><span class="line">        pbar.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;点击开始&quot;</span>);   <span class="comment">//点击按钮开始拷贝文件  </span></span><br><span class="line">        button2.setBounds(<span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">30</span>);  </span><br><span class="line">        button2.setToolTipText(<span class="string">&quot;这个按钮用来复制！&quot;</span>);  </span><br><span class="line">        button2.addActionListener(e -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="comment">//注意，不能直接在这个线程里面处理，因为这个线程是负责图形界面的，得单独创建一个线程处理，否则图形界面会卡死  </span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;in.iso&quot;</span>);  </span><br><span class="line">            <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);  </span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.iso&quot;</span>))&#123;  </span><br><span class="line">                <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> file.length(), current = <span class="number">0</span>;  </span><br><span class="line">                <span class="type">int</span> len;  </span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">                <span class="keyword">while</span> ((len = in.read(bytes)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    current += len;  </span><br><span class="line">                    pbar.setValue((<span class="type">int</span>) (pbar.getMaximum() * (<span class="type">double</span>)current / size));   <span class="comment">//每次拷贝都更新进度条  </span></span><br><span class="line">                    pbar.repaint();  <span class="comment">//因为并不是每次更新值都会使得组件重新绘制，如果视觉上比较卡，可以每次拷贝都重新绘制组件  </span></span><br><span class="line">                    out.write(bytes, <span class="number">0</span>, len);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException exception) &#123;  </span><br><span class="line">                exception.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).start());  </span><br><span class="line">        frame.add(button2);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//这里我们让JTree展示.idea目录下所有文件  </span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.idea&quot;</span>);   <span class="comment">//这里我们列出.idea目录下所有文件  </span></span><br><span class="line">        <span class="type">DefaultMutableTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(file.getName()); <span class="comment">//既然是树形关系，肯定有一个根结点  </span></span><br><span class="line"><span class="comment">//拿到当前目录下所有文件和文件夹  </span></span><br><span class="line">        File[] files = Optional.ofNullable(file.listFiles()).orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">File</span>[<span class="number">0</span>]);  </span><br><span class="line">        <span class="keyword">for</span> (File f : files)  </span><br><span class="line">            root.add(<span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(f.getName()));    <span class="comment">//构造子结点并连接  </span></span><br><span class="line">  </span><br><span class="line">        <span class="type">JTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTree</span>(root);    <span class="comment">//设定默认的根结点  </span></span><br><span class="line">        tree.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);  </span><br><span class="line">        frame.add(tree);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">JTabbedPane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTabbedPane</span>();  </span><br><span class="line">        pane.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">300</span>);  </span><br><span class="line">        pane.addTab(<span class="string">&quot;一号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JColorChooser</span>());   <span class="comment">//一号面板当颜色选择器  </span></span><br><span class="line">        pane.addTab(<span class="string">&quot;二号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JFileChooser</span>());    <span class="comment">//二号面板当文件选择器  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="javaweb">javaweb</h1>
<ul>
<li>使用PreparedStatement防止sql注入</li>
<li>数据库的查询结果映射为java类时，为了进行类型转换需要一个无参数构造方法</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>基于mit6.006和hello-algo的算法笔记</title>
    <url>/thinklive/42594/</url>
    <content><![CDATA[<h1 id="基础">基础</h1>
<figure>
<img src="/assets/mit6.006总和笔记/algo.png" alt="" /><figcaption>算法合订本</figcaption>
</figure>
<h2 id="数据结构">数据结构</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231016191822017.png" /></p>
<h2 id="算法性质">算法性质</h2>
<p><code>循环不变式</code>主要用来帮助我们理解算法的正确性。关千<code>循环不变式</code>，我们必须证明三条<br />
性质：<br />
初始化：循环的第一次迭代之前，它为真。<br />
保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。<br />
终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助千证明算法是正确的。</p>
<span id="more"></span>
<p>f(n) = O(g(n)) 类似于 a&lt;=b</p>
<p>f(n) = Ω (g(n)) 类似于 a&gt;=b</p>
<p>f(n) = θ (g(n)) 类似于 a=b</p>
<p>f(n) = o(g(n)) 类似于 a&lt;b</p>
<p>f(n) = w(g(n)) 类似于 a&gt;b <img src="/images/obsidian/20230519150021.png" title="image" alt="图片" /></p>
<h2 id="分治法递归">分治法（递归）</h2>
<h3 id="选择排序">选择排序</h3>
<ul>
<li>在A[:i+1]内找到最大的元素，和A[i]交换</li>
<li>递归地排序A[:i]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def selection_sort(A, i = None): # T(i)</span><br><span class="line">’’’Sort A[:i + 1]’’’</span><br><span class="line">    if i is None: i = len(A) - 1 # O(1)</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        j = prefix_max(A, i) # S(i)</span><br><span class="line">        A[i], A[j] = A[j], A[i] # O(1)</span><br><span class="line">        selection_sort(A, i - 1) # T(i - 1)</span><br><span class="line"></span><br><span class="line">def prefix_max(A, i): # S(i)找到最大元素的索引值</span><br><span class="line">’’’Return index of maximum in A[:i + 1]’’’</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        j = prefix_max(A, i - 1) # S(i - 1)</span><br><span class="line">        if A[i] &lt; A[j]: # O(1)</span><br><span class="line">            return j # O(1)</span><br><span class="line">    return i # O(1)</span><br></pre></td></tr></table></figure>
<p>python实现(迭代)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        k = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[k]:</span><br><span class="line">                k = j  <span class="comment"># 记录最小元素的索引</span></span><br><span class="line">        <span class="comment"># 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        nums[i], nums[k] = nums[k], nums[i]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• prefix max analysis:</span><br><span class="line">– Base case: for i = 0, array has one element, so index of max is i</span><br><span class="line">– Induction: assume correct for i, maximum is either the maximum of A[:i] or A[i],</span><br><span class="line">returns correct index in either case</span><br><span class="line">• selection sort analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, last number of a sorted output is a largest number of</span><br><span class="line">the array, and the algorithm puts one there; then A[:i] is sorted by inductio</span><br></pre></td></tr></table></figure>
<p>性质：O(n^2)，非稳定原地排序</p>
<h3 id="插入排序">插入排序</h3>
<ul>
<li>类似扑克牌，从右侧选择未排序元素，逐个插入左侧的已排序部分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def insertion_sort(A, i = None): # T(i)</span><br><span class="line">’’’Sort A[:i + 1]’’’</span><br><span class="line">    if i is None: i = len(A) - 1 # O(1)</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        insertion_sort(A, i - 1) # T(i - 1)</span><br><span class="line">        insert_last(A, i) # S(i)</span><br><span class="line"></span><br><span class="line">def insert_last(A, i): # S(i)</span><br><span class="line">’’’Sort A[:i + 1] assuming sorted A[:i]’’’</span><br><span class="line">    if i &gt; 0 and A[i] &lt; A[i - 1]: # O(1)</span><br><span class="line">        A[i], A[i - 1] = A[i - 1], A[i] # O(1)</span><br><span class="line">        insert_last(A, i - 1) # S(i - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• insert last analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, if A[i] &gt;= A[i - 1], array is sorted; otherwise,</span><br><span class="line">swapping last two elements allows us to sort A[:i] by induction</span><br><span class="line"></span><br><span class="line">• insertion sort analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, algorithm sorts A[:i] by induction, and then</span><br><span class="line">insert last correctly sorts the rest as proved above</span><br></pre></td></tr></table></figure>
<p>python实现（迭代）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        base = nums[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; base:</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]  <span class="comment"># 将 nums[j] 向右移动一位</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = base  <span class="comment"># 将 base 赋值到正确位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性：复杂度O(n^2)，原地稳定排序</p>
<h3 id="归并排序">归并排序</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">A, a = <span class="number">0</span>, b = <span class="literal">None</span></span>): <span class="comment"># T(b - a = n)</span></span><br><span class="line">’’’Sort A[a:b]’’’</span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span>: b = <span class="built_in">len</span>(A) <span class="comment"># O(1)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> &lt; b - a: <span class="comment"># O(1)</span></span><br><span class="line">        c = (a + b + <span class="number">1</span>) // <span class="number">2</span> <span class="comment"># O(1)</span></span><br><span class="line">        merge_sort(A, a, c) <span class="comment"># T(n / 2)</span></span><br><span class="line">        merge_sort(A, c, b) <span class="comment"># T(n / 2)</span></span><br><span class="line">        L, R = A[a:c], A[c:b] <span class="comment"># O(n)</span></span><br><span class="line">        merge(L, R, A, <span class="built_in">len</span>(L), <span class="built_in">len</span>(R), a, b) <span class="comment"># S(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">L, R, A, i, j, a, b</span>): <span class="comment"># S(b - a = n)</span></span><br><span class="line">’’’Merge <span class="built_in">sorted</span> L[:i] <span class="keyword">and</span> R[:j] into A[a:b]’’’</span><br><span class="line">    <span class="keyword">if</span> a &lt; b: <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= <span class="number">0</span>) <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] &gt; R[j - <span class="number">1</span>]): <span class="comment"># O(1)</span></span><br><span class="line">            A[b - <span class="number">1</span>] = L[i - <span class="number">1</span>] <span class="comment"># O(1)</span></span><br><span class="line">            i = i - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># O(1)</span></span><br><span class="line">        A[b - <span class="number">1</span>] = R[j - <span class="number">1</span>] <span class="comment"># O(1)</span></span><br><span class="line">        j = j - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line">    merge(L, R, A, i, j, a, b - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• merge analysis:</span><br><span class="line">– Base case: for n = 0, arrays are empty, so vacuously correct</span><br><span class="line">– Induction: assume correct for n, item in A[r] must be a largest number from remaining</span><br><span class="line">prefixes of L and R, and since they are sorted, taking largest of last items suffices;</span><br><span class="line">remainder is merged by induction</span><br><span class="line"> merge sort analysis:</span><br><span class="line">– Base case: for n = 1, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for k &lt; n, algorithm sorts smaller halves by induction, and then merge merges into a sorted array as proved above.</span><br></pre></td></tr></table></figure>
<p>python实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, mid: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并左子数组和右子数组&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 左子数组区间 [left, mid], 右子数组区间 [mid+1, right]</span></span><br><span class="line">    <span class="comment"># 创建一个临时数组 tmp ，用于存放合并后的结果</span></span><br><span class="line">    tmp = [<span class="number">0</span>] * (right - left + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 初始化左子数组和右子数组的起始索引</span></span><br><span class="line">    i, j, k = left, mid + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 当左右子数组都还有元素时，比较并将较小的元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将左子数组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        tmp[k] = nums[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">        tmp[k] = nums[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tmp)):</span><br><span class="line">        nums[left + k] = tmp[k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;归并排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 当子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="comment"># 划分阶段</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span>  <span class="comment"># 计算中点</span></span><br><span class="line">    merge_sort(nums, left, mid)  <span class="comment"># 递归左子数组</span></span><br><span class="line">    merge_sort(nums, mid + <span class="number">1</span>, right)  <span class="comment"># 递归右子数组</span></span><br><span class="line">    <span class="comment"># 合并阶段</span></span><br><span class="line">    merge(nums, left, mid, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性：O(nlgn)，稳定排序</p>
<h3 id="寻峰算法">寻峰算法</h3>
<p>一维情况： 实际上是一种二分查找，先查看中点是不是峰值，如果不是则选取邻居节点较大的一侧递归寻找 复杂度lgn</p>
<p>二维情况下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• Pick middle column j = m/2</span><br><span class="line">• Find global maximum on column j at (i, j)</span><br><span class="line">• Compare (i, j − 1), (i, j), (i, j + 1)</span><br><span class="line">• Pick left columns of (i, j − 1) &gt; (i, j)</span><br><span class="line">• Similarly for right</span><br><span class="line">• (i, j) is a 2D-peak if neither condition holds</span><br><span class="line">• Solve the new problem with half the number of columns.</span><br><span class="line">• When you have a single column, find global maximum and you‘re done.</span><br><span class="line"></span><br><span class="line">T (n, m) = T (n, m/2) + Θ(n) (to find global maximum on a column — (n rows))</span><br><span class="line">T (n, m) = (Θ(n) + . . . + Θ(n))log m= Θ(n log m) = Θ(n log n) if m = n</span><br></pre></td></tr></table></figure>
<p>这种解法思路是：</p>
<ol type="1">
<li><p>对数组的中间一列寻找最大值</p></li>
<li><p>如果最大值是峰值，可以返回</p></li>
<li><p>否则对数组最大的邻居所在的一侧进行递归(即子问题大小为原来的一半)</p></li>
</ol>
<p>除此以外还有一种贪心解法：从(0,0)开始，不断寻找当前节点的最大邻居，并不断迭代，时间复杂度O(n^2) 还有一种θ(n)的解法，详见<a href="https://thinklive1.github.io/2023/11/20/mit6.006%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/">作业解析</a></p>
<h3 id="最大子数组">最大子数组</h3>
<p>算法思路： 元素和最大的子数组有三种情况：在左半数组，右半数组，或者跨越中点，第一和第二种情况可以用递归遍历解决，第三种情况则分为两个半边数组的组合，只要从中点出发寻找最大子数组，然后组合就可以了</p>
<p><code>时间复杂度分析</code>：，其中线性时间为跨越中点的子数组，最终需要时间为O(NlogN) <img src="/images/obsidian/20230522103507.png" title="image" alt="图片" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, low， high)  </span><br><span class="line">    if high== low  </span><br><span class="line">        return (low, high, A[low])  </span><br><span class="line">    else mid=mod((low 十 high)/2) </span><br><span class="line">        (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)  </span><br><span class="line">    </span><br><span class="line">        (right-low, right-high, right-sum) =  FIND-MAXIMUM-SUBARRAY(A, mid+l. high)  </span><br><span class="line">    </span><br><span class="line">        (cross-low, cross-high, cross-sum) =  FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)  </span><br><span class="line">    </span><br><span class="line">    if left-sum&gt;=right-sum and left-sum&gt;=cross-sum  </span><br><span class="line">        return (left-low, left-high, left-sum)  </span><br><span class="line">    </span><br><span class="line">    elseif rightr-sum&gt;= left-sum and right-sum&gt;= cross-sum  </span><br><span class="line">        return (right-low, right-high, right-sum)  </span><br><span class="line">    </span><br><span class="line">    else return (cross-low, cross-high, cross-sum)</span><br><span class="line"></span><br><span class="line">FIND-MAX-CROSSING--SUBARRAY(A, low, mid, high)  </span><br><span class="line">    left-sum = -oo  </span><br><span class="line">    sum=O  </span><br><span class="line">    for i = mid downto low  </span><br><span class="line">        sum=sum+A[i]  </span><br><span class="line">        if sum&gt; left-sum  </span><br><span class="line">            left-sum = sum  </span><br><span class="line">            max-left = i  </span><br><span class="line">    right-sum= -oo  </span><br><span class="line">    sum=O  </span><br><span class="line">    for j = mid + 1 to high</span><br><span class="line">        sum=sum + A[j]  </span><br><span class="line">        if sum &gt; right-sum  </span><br><span class="line">            right-sum = sum  </span><br><span class="line">            max-right = j  </span><br><span class="line">    return (max-left, max-right, left-sum + right-sum)</span><br></pre></td></tr></table></figure>
<h1 id="选择和查找">选择和查找</h1>
<h2 id="二分搜索">二分搜索</h2>
<p>普通的二分查找：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_lcro</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找（左闭右开）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 循环，当搜索区间为空时跳出（当 i = j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            i = m + <span class="number">1</span>  <span class="comment"># 此情况说明 target 在区间 [m+1, j) 中</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">            j = m  <span class="comment"># 此情况说明 target 在区间 [i, m) 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> m  <span class="comment"># 找到目标元素，返回其索引</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标元素，返回 -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样的二分查找只适用于不重复元素，如果有重复元素，需要寻找到左边界作为插入点，则需要进一步处理 即：当找到等于目标的索引值后，进一步在左侧区间运行二分查找，直到找到最左侧的值 循环完成后， i指向最左边的 <code>target</code> ， j指向首个小于 <code>target</code> 的元素，<strong>因此索引</strong> <code>i</code><strong>就是插入点</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_insertion</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找插入点（存在重复元素）&quot;&quot;&quot;</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            i = m + <span class="number">1</span>  <span class="comment"># target 在区间 [m+1, j] 中</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">            j = m - <span class="number">1</span>  <span class="comment"># target 在区间 [i, m-1] 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = m - <span class="number">1</span>  <span class="comment"># 首个小于 target 的元素在区间 [i, m-1] 中</span></span><br><span class="line">    <span class="comment"># 返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查找左边界</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_left_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找最左一个 target&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 等价于查找 target 的插入点</span></span><br><span class="line">    i = binary_search_insertion(nums, target)</span><br><span class="line">    <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[i] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到 target ，返回索引 i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p>我们可以利用查找最左元素的函数来查找最右元素，具体方法为：<strong>将查找最右一个 <code>target</code> 转化为查找最左一个 <code>target + 1</code></strong>。搜索结束后<code>j</code>指向最右一个 <code>target</code> ，<strong>因此返回</strong><code>j</code> <strong>即可</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_right_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找最右一个 target&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 转化为查找最左一个 target + 1</span></span><br><span class="line">    i = binary_search_insertion(nums, target + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># j 指向最右一个 target ，i 指向首个大于 target 的元素</span></span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> nums[j] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到 target ，返回索引 j</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当数组不包含 <code>target</code> 时，最终 <code>i</code>和<code>j</code></p>
<p>会分别指向首个大于、小于 <code>target</code> 的元素。</p>
<p>因此，可以构造一个数组中不存在的元素，用于查找左右边界。</p>
<ul>
<li>查找最左一个 <code>target</code> ：可以转化为查找 <code>target - 0.5</code> ，并返回指针<code>i</code></li>
<li>查找最右一个 <code>target</code> ：可以转化为查找 <code>target + 0.5</code> ，并返回指针<code>j</code></li>
</ul>
<h2 id="哈希查找">哈希查找</h2>
<p>Q:给定一个整数数组 <code>nums</code> 和一个目标元素 <code>target</code> ，请在数组中搜索“和”为 <code>target</code> 的两个元素，并返回它们的数组索引。返回任意一个解即可。</p>
<p>借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组</p>
<ol type="1">
<li>判断数字 <code>target - nums[i]</code> 是否在哈希表中，若是则直接返回这两个元素的索引。</li>
<li>将键值对 <code>nums[i]</code> 和索引 <code>i</code> 添加进哈希表。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_brute_force.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_sum_hash_table</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;方法二：辅助哈希表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 辅助哈希表，空间复杂度 O(n)</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="comment"># 单层循环，时间复杂度 O(n)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> [dic[target - nums[i]], i]</span><br><span class="line">        dic[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n),由于需要维护一个额外的哈希表，因此空间复杂度为O(n)</p>
<h2 id="随机查找">随机查找</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RANDOMIZED-SELECT (A, p, r, i)</span><br><span class="line">    if p==r</span><br><span class="line">        return A[p]</span><br><span class="line">    q = RANDOMlZED-PARTITION(A, p, r)</span><br><span class="line">    k = q-p+I</span><br><span class="line">    if i == k // the pivot value is the answer</span><br><span class="line">        return A[q]</span><br><span class="line">    else if i&lt;k</span><br><span class="line">        return RANOOMIZED-SELECT(A, p, q-1, i)</span><br><span class="line">    else return RANOOMIZED-SELECT(A, q+l, r, i-k</span><br></pre></td></tr></table></figure>
<h2 id="期望线性时间的查找">期望线性时间的查找</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RANDOMIZED-SELECT(A, p, r, i)  </span><br><span class="line">if p == r  </span><br><span class="line">	return A[p]  </span><br><span class="line">q = RANDOMIZED-PARTITION(A, p, r)  </span><br><span class="line">k = q - p + 1  </span><br><span class="line">if i == k  // the pivot value is the answer  </span><br><span class="line">	return A[q]  </span><br><span class="line">else if i &lt; k  </span><br><span class="line">	return RANDOMIZED-SELECT(A, p, q - 1, i)  </span><br><span class="line">else return RANDOMIZED-SELECT(A, q + 1, r, i - k)</span><br></pre></td></tr></table></figure>
<h2 id="最坏运行时间为线性的中位数查找">最坏运行时间为线性的中位数查找</h2>
<ol type="1">
<li>将输入数组的 n 个元素划分为 ⌊n/5 ⌋组，每组 5 个元素，且至多只有一组由剩下的 nmod5 个元素组成。</li>
<li>寻找这⌈ n/5⌉ 组中每一组的中位数：首先对每组元素进行插入排序，然后确定每组有序元 素的中位数。</li>
<li>对第 2 步中找出的「 n/5 ⌉个中位数，递归调用 SELECT 以找出其中位数 x( 如果有偶数个中 位数，为了方便，约定 x 是较小的中位数）。</li>
<li>利用修改过的 PARTITION 版本，按中位数的中位数 x 对输入数组进行划分。让 K 比划 分的低区中的元素数目多 1, 因此 x 是第 k 小的元素，并且有 n-k 个元素在划分的高区。</li>
<li>如果 i=k, 则返回 x 。如果 i&lt;k, 则在低区递归调用 SELECT 来找出第 i 小的元素。如果 i&gt;k, 则在高区递归查找第 i-k 小的元素。</li>
</ol>
<p>在第 2 步找出的中位数中，至少有一半大千或等于中位数的中位数户。因此，在这「n/5⌉个组中，除了当 n 不能被 5 整除时产生的所含元素少于 5 的那个组和包含 x 的那个组之外，至少有一半的组中有 3 个元素大千 x 。不算这两个组，大于 x 的元素个数至少为： <span class="math inline">\(3\Bigl(\biggl\lceil\frac{1}{2}\biggl\lceil\frac{n}{5}\biggr\vert-2\Bigr)\ge\frac{3n}{10}-6\)</span> 也至少有这个数的元素小于x</p>
<p><span class="math inline">\(T(n)&lt;={T([n/5])+T(7n/10+6)+O(n)}\)</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">A</span>):</span><br><span class="line">    array_num=<span class="built_in">len</span>(A)//<span class="number">5</span></span><br><span class="line">    matrix=[]</span><br><span class="line">    index=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (array_num):</span><br><span class="line">        new_array=[]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            new_array.append(A[index])</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">        matrix.append(new_array)</span><br><span class="line">    <span class="keyword">if</span> index==<span class="built_in">len</span>(A): <span class="keyword">return</span> matrix</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_array=[]</span><br><span class="line">        <span class="keyword">while</span> index&lt;<span class="built_in">len</span>(A):</span><br><span class="line">            new_array.append(A[index])</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">        matrix.append(new_array)</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        base = nums[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; base:</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]  </span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = base  </span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">A,i,j</span>):</span><br><span class="line">    temp=A[i]</span><br><span class="line">    A[i]=A[j]</span><br><span class="line">    A[j]=temp</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, left, right,x</span>):</span><br><span class="line">    i, j = left, right</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; x:</span><br><span class="line">            j -= <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= x:</span><br><span class="line">            i += <span class="number">1</span>  </span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">A,ith</span>):</span><br><span class="line">    matrix = divide(A)<span class="comment">#划分n/5个数组</span></span><br><span class="line">    medium_nums=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):<span class="comment">#产生中位数数组</span></span><br><span class="line">        matrix[i]=insertion_sort(matrix[i])</span><br><span class="line">        medium_nums.append(matrix[i][(<span class="built_in">len</span>(matrix[i])-<span class="number">1</span>)//<span class="number">2</span>])</span><br><span class="line">    medium_nums=insertion_sort(medium_nums)<span class="comment">#对中位数数组排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(medium_nums)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        medium=(<span class="built_in">len</span>(medium_nums)-<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>: medium=<span class="built_in">len</span>(medium_nums)//<span class="number">2</span><span class="comment">#计算出中位数数组的中位数索引并向下取整</span></span><br><span class="line">    x=medium_nums[medium]</span><br><span class="line">    k=partition(A,<span class="number">0</span>,<span class="built_in">len</span>(A)-<span class="number">1</span>,x)+<span class="number">1</span><span class="comment">#划分数组</span></span><br><span class="line">    <span class="keyword">if</span> k==ith: <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">elif</span> ith&lt;k: <span class="keyword">return</span> select(A[<span class="number">0</span>:k],ith)</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> select(A[k:],ith-k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    A=[<span class="number">41</span>,<span class="number">5</span>,<span class="number">46</span>,<span class="number">48</span>,<span class="number">456</span>,<span class="number">1</span>,<span class="number">56</span>,<span class="number">1448</span>,<span class="number">21</span>,<span class="number">84</span>,<span class="number">49</span>,<span class="number">11</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(A)+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;个元素是：&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(select(A,i))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p>
<h1 id="比较排序">比较排序</h1>
<p><img src="/assets/mit6.006总和笔记/image-20231016192215938.png" /></p>
<h2 id="决策树">决策树</h2>
<p>决策树</p>
<ul>
<li>任何算法都可以被视为所执行操作的决策树</li>
<li>内部节点表示二进制比较，分支为 True 或 False</li>
<li>对于比较算法，决策树是二元的</li>
<li>叶子代表算法终止，产生算法输出</li>
<li>根到叶路径表示算法在某些输入上的执行</li>
<li>比较排序的决策树是完全二叉树，因此高度h&gt;=lg(叶节点数)</li>
<li>叶结点数是排列数量，即n!</li>
<li>决策树高度，或者说每条路径的长度就是时间复杂度 <span class="math display">\[n! = \sqrt{2\pi n}\Bigl(\frac{n}{\mathrm{e}}\Bigr)^{n}\Bigl(1 + \frac{1}{12n} + \frac{1}{288n^2} + \cdots\Bigr),\]</span> <span class="math display">\[\ln n! = n\ln n - n +\frac{1}{2}\ln(2\pi n) + \frac{1}{12n} - \frac{1}{360n^3} + \cdots.\]</span> 因此排序下界是nlgn</li>
</ul>
<p>对应的，搜索算法的叶节点数为n个，因此下界是lgn</p>
<h2 id="堆排序">堆排序</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231017150534371.png" /> <strong>本质上是在序列数据结构（数组）之上实现集合数据结构</strong></p>
<p>二叉堆：将数组解释为完全二叉树，深度 i 处最多有 2i 个节点，除了 在最大深度，所有节点均左对齐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left(i) = 2i + 1</span><br><span class="line">right(i) = 2i + 2</span><br><span class="line">parent(i) = mod(i-1/2)</span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231014112423645.png" /></p>
<h3 id="最大堆的生成">最大堆的生成</h3>
<p>本质上是自底向上建堆，从下到上维护最大堆属性，即从倒数第二层由大索引值向顶部进行最大堆性质的维护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Max_Heapify(A,i)</span><br><span class="line">    l = left(i)</span><br><span class="line">    r = right(i)</span><br><span class="line">    if (l &lt;= heap-size(A) and A[l] &gt; A[i])</span><br><span class="line">        then largest = l </span><br><span class="line">    else largest = i</span><br><span class="line">    if (r &lt;= heap-size(A) and A[r] &gt; A[largest])</span><br><span class="line">        then largest = r</span><br><span class="line">    if largest != i</span><br><span class="line">        then exchange A[i] and A[largest]</span><br><span class="line">    Max_Heapify(A, largest)</span><br><span class="line"></span><br><span class="line">//Converts A[1…n] to a max heap</span><br><span class="line">Build_Max_Heap(A):</span><br><span class="line">    for i=n/2 downto 1</span><br><span class="line">        do Max_Heapify(A, i)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Why start at n/2?</span><br><span class="line">Because elements A[n/2 + 1 … n] are all leaves of the tree</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度分析">时间复杂度分析</h3>
<p>每层的时间代价等于节点数乘以节点高度 <img src="https://www.hello-algo.com/chapter_heap/build_heap.assets/heapify_operations_count.png" /> <span class="math display">\[\begin{aligned}
T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \dots + 2^{(h-1)}\times1 \newline
2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \dots + 2^{h-1} + 2^h \newline
\end{aligned}\]</span> <span class="math display">\[\begin{aligned}
T(h) &amp; = 2 \frac{1 - 2^h}{1 - 2} - h \newline
&amp; = 2^{h+1} - h - 2 \newline
&amp; = O(2^h)
\end{aligned}\]</span> 综上得到 <span class="math display">\[O(2^h) = O(n)\]</span></p>
<h3 id="排序策略">排序策略</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorting Strategy:</span><br><span class="line">1. 从未排序数组中构建一个堆</span><br><span class="line">2. 找到最大元素 A[1]并与A[n]交换;</span><br><span class="line">3. n索引处元素出堆，从顶部节点开始维护最大堆属性</span><br><span class="line">4. 顶部节点开始和比它大的最大子节点交换，直到叶节点</span><br></pre></td></tr></table></figure>
<h3 id="top-k问题">top-k问题</h3>
<p>基于堆更加高效地解决 Top-K 问题</p>
<ol type="1">
<li><p>初始化一个最小堆</p></li>
<li><p>前k个元素入堆</p></li>
<li><p>对之后的元素，如果有比堆顶大的元素，则堆顶出堆，该元素入堆</p></li>
<li><p>最后得到top-k元素组成的堆</p></li>
</ol>
<p>时间复杂度是nlgk，不超过nlgn</p>
<h2 id="动态规划和二分搜索树">动态规划和二分搜索树</h2>
<p>实例——机场的动态规划：</p>
<ol type="1">
<li>机场维护一个跑道队列</li>
<li>未来的着陆预定登记到队列</li>
<li>一架飞机着陆后就出队</li>
<li>有新的请求且需要着陆时间t时，如果k时间内没有其他需求，则需求t时间的请求入队(k可以实时改变)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init: R = [ ]</span><br><span class="line">req(t): if t &lt; now: return &quot;error&quot;</span><br><span class="line">for i in range (len(R)):</span><br><span class="line">    if abs(t-R[i]) &lt; k: return &quot;error&quot;</span><br><span class="line">R.append(t)</span><br><span class="line">R = sorted(R)</span><br><span class="line">land: t = R[0]</span><br><span class="line">if (t != now) return error</span><br><span class="line">R = R[1: ] (drop R[0] from R)</span><br></pre></td></tr></table></figure>
<p>Goal: Run this system efficiently in O(lg n) time 常见数据结构运行时间分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">排序链表</span><br><span class="line">- 添加元素并排序需要Θ(nlgn)时间。但是,可以找到插入新时间/航班的位置而不需要添加并排序,但是插入需Θ(n)时间。一旦找到插入位置,k分钟检查可以在O(1)时间内完成。</span><br><span class="line"></span><br><span class="line">排序数组</span><br><span class="line">- 可以使用二分搜索在O(lg n)时间内找到插入位置。使用二分搜索,找到插入索引i,即大于或等于t的最小元素。然后将R[i]和R[i-1]与t进行比较。然而,实际插入需要移位元素,需Θ(n)时间。</span><br><span class="line"></span><br><span class="line">未排序链表/数组</span><br><span class="line">- k分钟检查需要O(n)时间。</span><br><span class="line"></span><br><span class="line">最小堆</span><br><span class="line">- 可以在O(lg n)时间内插入。但是,k分钟检查仍需O(n)时间。</span><br><span class="line"></span><br><span class="line">字典或Python集合</span><br><span class="line">- 插入需要O(1)时间。k分钟检查需要Ω(n)时间</span><br></pre></td></tr></table></figure>
<p>BST的定义： 每个节点都有一个key,左节点的key小于等于父节点，右节点的key大于等于父节点</p>
<p>所有操作都是O(h)即O(lgn)</p>
<p>动态规划中需要找到比一个值大的值中的最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next-larger(x) # x is a node in the BST</span><br><span class="line">if right child not NIL, return minimum(right)</span><br><span class="line">else y = parent(x)</span><br><span class="line">while y not NIL and x = right(y)</span><br><span class="line">    x = y; y = parent(y)</span><br><span class="line">return(y);</span><br></pre></td></tr></table></figure>
<p><code>子问题</code>：如何计算小于等于时间t内着陆的飞机数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历树找到目标时间</span><br><span class="line">2. 从左子树开始遍历，把左侧节点的数量加一则是当前节点的排名，排名则是问题的答案</span><br></pre></td></tr></table></figure>
<p><strong>搜索二叉树可以使用set或者sequence两种数据结构</strong></p>
<p>set:遍历顺序由key的顺序决定</p>
<p>sequence:数组索引就是遍历顺序</p>
<p><img src="/assets/mit6.006总和笔记/image-20231017101953076.png" /> <strong>查找第i大的节点(sequence)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 查找当前节点的排序rank</span><br><span class="line">2. 如果rank &lt; i在右子树寻找排名i-rank的节点</span><br><span class="line">3. 如果rank &gt; i在左子树递归寻找</span><br><span class="line">4. 如果等于，则找到了目标</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以对每个节点维护一个size属性，用左子树的size确认排名</li>
<li>搜索二叉树插入节点很容易实现，但删除节点，如果是有子树的节点，就需要把左子树的最大值或者右子树的最小值与其交换后删除</li>
<li>二叉树的中序遍历正好就是一个排序数组</li>
</ul>
<h2 id="平衡二叉搜索树avl">平衡二叉搜索树AVL</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231017102411122.png" /> • 在动态操作下保持 O(log n) 高度的二叉树称为平衡二叉树 – 有许多平衡方案（红黑树、八字树、2-3 树……） – 第一个提出的平衡方案是 AVL 树 <strong>树的旋转</strong> <img src="/assets/mit6.006总和笔记/image-20231017102819736.png" /> • 定理：O(n) 次旋转可以将二叉树转换为具有相同遍历顺序的任何其他二叉树。 • 证明：按照遍历顺序重复执行最后可能的右旋转； 结果树是 规范链。 每次旋转都会使最后一个节点的深度增加 1。 最后一个节点的深度最多为 n − 1，因此最多执行 n − 1 次旋转，就可以将输入树旋转为目标树。</p>
<p><strong>平衡</strong> AVL 树保持高度平衡（也称为 AVL 属性）</p>
<ul>
<li>如果一个节点的左右子树的高度最多相差 1，则该节点是高度平衡的</li>
<li>节点的倾斜为其右子树的高度减去左子树的高度</li>
<li>如果节点的倾斜度为 −1、0 或 1，则该节点是高度平衡的</li>
</ul>
<p><strong>平衡的维持</strong> 每次对树的修改最多导致左右子树高度相差2，如果相差2，一次旋转就可以重新平衡树 <img src="/assets/mit6.006总和笔记/image-20231017105216748.png" /> <img src="/assets/mit6.006总和笔记/image-20231018222936126.png" /> <img src="/assets/mit6.006总和笔记/image-20231018223015529.png" /> <img src="/assets/mit6.006总和笔记/image-20231018223211763.png" /></p>
<p>AVL 树通过在每个节点存储额外的高度信息,并在每个节点做平衡操作来保持平衡。其平衡调整原则如下:</p>
<ol type="1">
<li>如果左右子树高度相差大于 1,进行旋转操作调整;</li>
<li>进行左旋转的情况:左子树高度 - 右子树高度 &gt; 1,即左子树比右子树高(左重),需要右旋;</li>
<li>进行右旋转的情况:右子树高度 - 左子树高度 &gt; 1,即右子树比左子树高(右重),需要左旋;</li>
<li>旋转后更新节点的高度信息。</li>
<li>每进行一次插入或删除节点后,从该节点开始向上遍历,如果发现任一节点的左右子树高度差大于 1,则在该节点进行旋转操作,调整树的平衡。 由于树的高度最高为lgn，所以logn时间内就可以完成增删节点的操作 <strong>高度属性的维护</strong> 必须确保每个节点的height属性可以通过对height属性的一个O(1)操作完成，这样维护height就不会改变动态操作的复杂度</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">balanceFactor</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>旋转的实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rightRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;left;</span><br><span class="line">    TreeNode *grandChild = child-&gt;right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;right;</span><br><span class="line">    TreeNode *grandChild = child-&gt;left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一共有四种需要平衡的情况 <img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png" /></p>
<table>
<thead>
<tr class="header">
<th>失衡节点的平衡因子</th>
<th>子节点的平衡因子</th>
<th>应采用的旋转方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;1（即左偏树）</td>
<td>&gt;=0</td>
<td>右旋</td>
</tr>
<tr class="even">
<td>&gt;1（即左偏树）</td>
<td>&lt;0</td>
<td>先左旋后右旋</td>
</tr>
<tr class="odd">
<td>&lt;-1（即右偏树）</td>
<td>&lt;=0</td>
<td>左旋</td>
</tr>
<tr class="even">
<td>&lt;-1（即右偏树）</td>
<td>&gt;0</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<p><strong>数据结构的选取</strong> • Set AVL trees achieve O(lg n) time for all set operations, except O(n log n) time for build and O(n) time for iter • Sequence AVL trees achieve O(lg n) time for all sequence operations, except O(n) time for build and iter <strong>插入和删除</strong> 此外，插入节点和删除节点在搜索二叉树基础上，需要分别自底向上和自上向下进行恢复平衡的操作</p>
<h1 id="哈希">哈希</h1>
<p>哈希有可能产生碰撞，需要特定处理或者数据结构，检索元素时间最后会由负载因数(n/m)决定 <img src="/assets/mit6.006总和笔记/image-20231016200400451.png" /> 一般有<strong>链表</strong>和<strong>开放寻址</strong>两种方式解决碰撞</p>
<ul>
<li>链表 期望的查找时间，θ(1+α)，1是哈希函数用时，阿尔法则是查找具体链表需要的时间（链表的期望长度）</li>
<li>开放寻址</li>
</ul>
<h2 id="哈希函数">哈希函数</h2>
<p>常见的哈希函数</p>
<ol type="1">
<li><code>h(k) = k mod m（m是素数，慢)</code></li>
<li><code>h(k) = [(a · k) mod 2w] &gt;&gt; (w − r)</code>(where a is random, k is w bits, and m = 2r.且需要a处于2<sup>(w-1)和2</sup>w之间，且不靠近端点)</li>
<li><code>h(k) = [(ak + b) mod p]</code> mod m where a and b are random ∈ {0, 1, . . . p − 1}, and p is a large prime (&gt; |U|).(了解即可,6.046内容)</li>
</ol>
<h2 id="哈希的优化">哈希的优化</h2>
<p><strong>rehash</strong></p>
<p>Θ(n + m) time = Θ(n) if m = Θ(n)</p>
<p><strong>shrink</strong></p>
<p>当n到达m/4时，收缩到n/2</p>
<h2 id="利用哈希的字符串匹配算法">利用哈希的字符串匹配算法</h2>
<h3 id="karp-rabin-algorithm">Karp-Rabin Algorithm</h3>
<p>Rabin-Karp算法是一种字符串匹配算法,利用滚动哈希技术实现。其基本思想是:</p>
<ol type="1">
<li>对文本和模式分别计算哈希值;</li>
<li>滚动文本,每次比较文本窗口和模式的哈希值;</li>
<li>如果哈希值相同,则进行字符匹配确认;</li>
<li>如果不相同,则可以直接跳到下一位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• Compare h(s) == h(t[i : i + len(s)])</span><br><span class="line">• If hash values match, likely so do strings</span><br><span class="line">– can check s == t[i : i + len(s)] to be sure ∼ cost O(|s|)</span><br><span class="line">– if yes, found match — done</span><br><span class="line">– if no, happened with probability &lt; 1/|s|</span><br><span class="line">= expected cost is O(1) per i.</span><br><span class="line">⇒</span><br><span class="line">• need suitable hash function.</span><br><span class="line">• expected time = O(|s| + |t| · cost(h)).</span><br><span class="line">– naively h(x) costs |x|</span><br><span class="line">– we’ll achieve O(1)!</span><br><span class="line">– idea: t[i : i + len(s)] ≈ t[i + 1 : i + 1 + len(s)]</span><br></pre></td></tr></table></figure>
<p><strong>rolling hash</strong></p>
<p>Rolling Hash ADT</p>
<p>Maintain string x subject to</p>
<ul>
<li>r(): reasonable hash function h(x) on string x</li>
<li>r.append(c): add letter c to end of string x</li>
<li>r.skip(c): remove front letter from string x, assuming it is</li>
</ul>
<p>伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for c in s: rs.append(c)</span><br><span class="line">for c in t[:len(s)]: rt.append(c)</span><br><span class="line">if rs() == rt(): ...</span><br><span class="line">//This first block of code is O( s )</span><br><span class="line">for i in range(len(s), len(t)):</span><br><span class="line">rt.skip(t[i-len(s)])</span><br><span class="line">rt.append(t[i])</span><br><span class="line">if rs() == rt(): ...</span><br><span class="line">//The second block of code is O(|t|) + O(# matches − |s|) to verify.</span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231019194313076.png" /></p>
<h2 id="开放寻址">开放寻址</h2>
<p>哈希时需要引入哈希次数i，持续哈希直到找到空槽 <strong>插入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in xrange(m):</span><br><span class="line">    if T [h(k, i)] is None: #empty slot</span><br><span class="line">        T [h(k, i)] = (k, v) #store item</span><br><span class="line">        return</span><br><span class="line">raise ‘full&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>查找</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in xrange(m):</span><br><span class="line">    if T [h(k, i)] is None: #empty slot?</span><br><span class="line">        return None #end of “chain”</span><br><span class="line">    elif T [h(k, i)][∅] == k: #matching key</span><br><span class="line">        return T [h(k, i)] #return item</span><br><span class="line">    return None ˙ #exhausted table</span><br></pre></td></tr></table></figure>
<p><strong>删除</strong></p>
<p>由于防止查找操作误判，需要特定的删除标志，把待删除函数设置为已删除，让插入视为None,查找视为存在 <img src="/assets/mit6.006总和笔记/image-20231019195835085.png" /></p>
<h3 id="优化">优化</h3>
<p>问题：可能出现<em>簇</em>现象，某些元素连续聚集于一处，导致查找操作耗时较高</p>
<p>eg.线性哈希h(k, i) = (h′(k) +i)</p>
<p>更好的解决方案：<code>h(k, i) =(h1(k) +i·h2(k)) mod m</code> where h1(k) and h2(k) are two ordinary hash func-tions.</p>
<h3 id="性能">性能</h3>
<p>第一次查找成功的概率p=m-n/m</p>
<p>第二次概率为m-n/m-1大于p</p>
<p>由此类推，成功概率至少为p</p>
<p>1/p=1/1-α</p>
<p>所以期望时间为O(1/(1 − α))</p>
<h3 id="与链表的比较">与链表的比较</h3>
<p>优点：更有效地利用空间，不需要储存指针</p>
<p>缺点：链表对哈希函数和负载值的要求更低，开放寻址高负载时性能大降，且无法有大于一的α</p>
<h2 id="安全领域的哈希">安全领域的哈希</h2>
<p>哈希在加密上应用广泛，例如：</p>
<ol type="1">
<li>加密密码，存储密码的哈希码来防止泄露的危害</li>
<li>文件完整性校验，利用哈希来给出文件几乎唯一的哈希值来防止对文件的暗中篡改，也用于git之类的版本控制软件</li>
<li>数字签名，用私钥加密数据，其他人可以用公钥检验，来确保发信者身份正规 <a href="https://thinklive1.github.io/2023/10/12/sysadmin/">详细可见Sysadmin decal笔记</a></li>
</ol>
<h1 id="没涉及的其他排序">6.006没涉及的其他排序</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>「冒泡排序 bubble sort」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。 设数组的长度为n，冒泡排序的步骤</p>
<ol type="1">
<li>首先，对 <code>n</code> 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>，</li>
<li>接下来，对剩余<code>n-1</code>个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li>
<li>以此类推，经过<code>n-</code>轮“冒泡”后，<strong>前</strong><code>n-1</code> <strong>大的元素都被交换至正确位置</strong>。</li>
<li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_sort_overview.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>性能和特性</strong>：</p>
<ul>
<li>最差和平均都是O(n^2)，但比较适合数组有一定秩序性的时候</li>
<li>原地稳定排序</li>
</ul>
<h2 id="快速排序">快速排序</h2>
<p>「快速排序 quick sort」是一种基于分治策略的排序算法，核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</p>
<ol type="1">
<li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li>
<li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li>
<li>循环执行步骤 <code>2.</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PARTITION(A, p, r)</span><br><span class="line"> i =RANOOM(p, r)</span><br><span class="line"> exchange A[r] with A[i]</span><br><span class="line"> x = A[r]</span><br><span class="line"> i = p —1</span><br><span class="line"> for j=p to r-1</span><br><span class="line">  if A[j]&lt;=x</span><br><span class="line">  i = i + 1</span><br><span class="line">  exchange A[i] with A[j]</span><br><span class="line"> exchange A[i+ l] with A[r]</span><br><span class="line"> return i + 1</span><br><span class="line"></span><br><span class="line">QUICKSORT(A, p, r)</span><br><span class="line">if p&lt;r</span><br><span class="line"> q = PARTITION(A, p, r)</span><br><span class="line"> QUICKSORT(A, p, q-1)</span><br><span class="line"> QUICKSORT(A, q+ 1, r)</span><br></pre></td></tr></table></figure>
<p>python实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;哨兵划分&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 以 nums[left] 作为基准数</span></span><br><span class="line">    i, j = left, right</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt;= nums[left]:</span><br><span class="line">            j -= <span class="number">1</span>  <span class="comment"># 从右向左找首个小于基准数的元素</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[left]:</span><br><span class="line">            i += <span class="number">1</span>  <span class="comment"># 从左向右找首个大于基准数的元素</span></span><br><span class="line">        <span class="comment"># 元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    <span class="comment"># 将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i  <span class="comment"># 返回基准数的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 哨兵划分</span></span><br><span class="line">    pivot = self.partition(nums, left, right)</span><br><span class="line">    <span class="comment"># 递归左子数组、右子数组</span></span><br><span class="line">    self.quick_sort(nums, left, pivot - <span class="number">1</span>)</span><br><span class="line">    self.quick_sort(nums, pivot + <span class="number">1</span>, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化：</p>
<ul>
<li>对主元选取可以用随机数或者取样一些元素选取中位数来实现稳定的nlgn性能</li>
<li>对相等元素较多的数组，可以进行三路快排，只需要递归排序不等于主元的两路</li>
<li>尾递归优化,在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过n/2 ，因此这种方法能确保递归深度不超过lgn ，从而将最差空间复杂度优化至lgn。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序（尾递归优化）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 子数组长度为 1 时终止</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 哨兵划分操作</span></span><br><span class="line">        pivot = self.partition(nums, left, right)</span><br><span class="line">        <span class="comment"># 对两个子数组中较短的那个执行快排</span></span><br><span class="line">        <span class="keyword">if</span> pivot - left &lt; right - pivot:</span><br><span class="line">            self.quick_sort(nums, left, pivot - <span class="number">1</span>)  <span class="comment"># 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>  <span class="comment"># 剩余未排序区间为 [pivot + 1, right]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.quick_sort(nums, pivot + <span class="number">1</span>, right)  <span class="comment"># 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>  <span class="comment"># 剩余未排序区间为 [left, pivot - 1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="堆排序-1">堆排序</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, i: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;堆的长度为 n ，从节点 i 开始，从顶至底堆化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">        ma = i</span><br><span class="line">        <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> nums[l] &gt; nums[ma]:</span><br><span class="line">            ma = l</span><br><span class="line">        <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> nums[r] &gt; nums[ma]:</span><br><span class="line">            ma = r</span><br><span class="line">        <span class="comment"># 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 交换两节点</span></span><br><span class="line">        nums[i], nums[ma] = nums[ma], nums[i]</span><br><span class="line">        <span class="comment"># 循环向下堆化</span></span><br><span class="line">        i = ma</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;堆排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 建堆操作：堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift_down(nums, <span class="built_in">len</span>(nums), i)</span><br><span class="line">    <span class="comment"># 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 交换根节点与最右叶节点（即交换首元素与尾元素）</span></span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 以根节点为起点，从顶至底进行堆化</span></span><br><span class="line">        sift_down(nums, i, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>性质：nlgn,原地非稳定</p>
<h2 id="计数排序">计数排序</h2>
<ol type="1">
<li>遍历数组，找出数组中的最大数字，记为 ，然后创建一个长度为- 的辅助数组 <code>counter</code> 。</li>
<li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加即可。</li>
<li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经被排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字的出现次数，将它们按从小到大的顺序填入 <code>nums</code> 即可。 <img src="https://www.hello-algo.com/chapter_sorting/counting_sort.assets/counting_sort_overview.png" /></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COUNTlNG-SORT(A, B, k)</span><br><span class="line">let C[O .. k] be a new array</span><br><span class="line">for i=O to k</span><br><span class="line"> C[i] = O</span><br><span class="line">for j = 1 to A. length</span><br><span class="line"> C[A[j]]=C[A[j]J+ 1</span><br><span class="line">//C[i] now contains the number of elements equal to i.</span><br><span class="line">for i=1 to k</span><br><span class="line"> C[i]=C[i]+C[i-1]</span><br><span class="line">//C[i] now contains the number of elements less than or equal to i.</span><br><span class="line">for j = A. length downto 1</span><br><span class="line"> B[C[A[j]J]=A[j]</span><br><span class="line"> C[A[j]]=C[A[j]]-1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计数排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 完整实现，可排序对象，并且是稳定排序</span></span><br><span class="line">    <span class="comment"># 1. 统计数组最大元素 m</span></span><br><span class="line">    m = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="comment"># 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment"># counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter = [<span class="number">0</span>] * (m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        counter[num] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span><br><span class="line">    <span class="comment"># 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        counter[i + <span class="number">1</span>] += counter[i]</span><br><span class="line">    <span class="comment"># 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span><br><span class="line">    <span class="comment"># 初始化数组 res 用于记录结果</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        num = nums[i]</span><br><span class="line">        res[counter[num] - <span class="number">1</span>] = num  <span class="comment"># 将 num 放置到对应索引处</span></span><br><span class="line">        counter[num] -= <span class="number">1</span>  <span class="comment"># 令前缀和自减 1 ，得到下次放置 num 的索引</span></span><br><span class="line">    <span class="comment"># 使用结果数组 res 覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>特性</strong>：虽然是线性时间O(n+m)，实际上时间复杂收到输入数据大小范围的影响,不能直接支持负数，需要将负数数组转换成非负数的排序,非原地稳定排序，空间也是O(n+m)</p>
<h2 id="基数排序">基数排序</h2>
<p>假设数字的最低位是第1位，最高位是第8位，基数排序的流程:</p>
<ol type="1">
<li>初始化位数`k=1</li>
<li>对学号的第<code>k</code>位执行“计数排序”。完成后，数据会根据第<code>k</code> 位从小到大排序。</li>
<li>将<code>k</code>增加 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_sorting/radix_sort.assets/radix_sort_overview.png" /> 获取第k位数的方法： <span class="math display">\[x_k = \lfloor\frac{x}{d^{k-1}}\rfloor \bmod d\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">digit</span>(<span class="params">num: <span class="built_in">int</span>, exp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取元素 num 的第 k 位，其中 exp = 10^(k-1)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num // exp) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort_digit</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], exp: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计数排序（根据 nums 第 k 位排序）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 十进制的位范围为 0~9 ，因此需要长度为 10 的桶</span></span><br><span class="line">    counter = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        d = digit(nums[i], exp)  <span class="comment"># 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d] += <span class="number">1</span>  <span class="comment"># 统计数字 d 的出现次数</span></span><br><span class="line">    <span class="comment"># 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        counter[i] += counter[i - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    res = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        d = digit(nums[i], exp)</span><br><span class="line">        j = counter[d] - <span class="number">1</span>  <span class="comment"># 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i]  <span class="comment"># 将当前元素填入索引 j</span></span><br><span class="line">        counter[d] -= <span class="number">1</span>  <span class="comment"># 将 d 的数量减 1</span></span><br><span class="line">    <span class="comment"># 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基数排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    m = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="comment"># 按照从低位到高位的顺序遍历</span></span><br><span class="line">    exp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> exp &lt;= m:</span><br><span class="line">        <span class="comment"># 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment"># k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment"># k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment"># 即 exp = 10^(k-1)</span></span><br><span class="line">        counting_sort_digit(nums, exp)</span><br><span class="line">        exp *= <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性： - 时间复杂度O(k(n+d))，k是位数，d是进制,d会决定计数排序需要的数组长度，k决定进行几次计数排序 - 空间复杂度O(n+d),稳定排序(从低到高排序)</p>
<h2 id="桶排序">桶排序</h2>
<ol type="1">
<li>初始化 <code>k</code> 个桶，将<code>n</code>个元素分配到<code>k</code>个桶中</li>
<li>对每个桶分别执行排序</li>
<li>按照桶的从小到大的顺序，合并结果 <img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/bucket_sort_overview.png" /></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">float</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;桶排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span><br><span class="line">    k = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    <span class="comment"># 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">        i = <span class="built_in">int</span>(num * k)</span><br><span class="line">        <span class="comment"># 将 num 添加进桶 i</span></span><br><span class="line">        buckets[i].append(num)</span><br><span class="line">    <span class="comment"># 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="comment"># 使用内置排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        bucket.sort()</span><br><span class="line">    <span class="comment"># 3. 遍历桶合并结果</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特性：</p>
<ol type="1">
<li><strong>时间复杂度</strong><code>O(n+k)</code> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为<code>n/k</code> 。假设排序单个桶使用<code>(n/k)*lg(n/k)</code>时间，则排序所有桶使用<code>n*lg(n/k)</code>时间。<strong>当桶数量</strong><code>k</code><strong>比较大时，时间复杂度则趋向于<code>O(n)</code></strong> 。合并结果时需要遍历所有桶和元素，花费<code>O(n+k)</code>时间。在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用<code>O(n^2)</code>时间。</li>
<li><strong>空间复杂度</strong>O(n+k)</li>
<li><strong>非原地排序</strong>：需要借助<code>k</code>个桶和总共<code>n</code> 个元素的额外空间。</li>
<li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li>
</ol>
<p>改良： 平均分配可以对较大的桶递归 <img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/scatter_in_buckets_recursively.png" /> 或者根据概率正态分布划分桶</p>
<h2 id="总结">总结</h2>
<p><img src="https://www.hello-algo.com/chapter_sorting/summary.assets/sorting_algorithms_comparison.png" /></p>
<h1 id="数值运算">数值运算</h1>
<h2 id="catalan-numbers">Catalan numbers</h2>
<p>Set P of balanced parentheses strings(平衡括号字符串) are recursively defined as • λ ∈ P (λ is empty string) • If α, β ∈ P , then (α)β ∈ P Cn: number of balanced parentheses strings with exactly n pairs of parentheses 也等于n+1个叶节点构成满二叉树的形状个数 <img src="/assets/mit6.006总和笔记/image-20231020131123959.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印前 n 个卡特兰数</span></span><br><span class="line">ans, n = <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br></pre></td></tr></table></figure>
<h2 id="newtons-method牛顿迭代法">Newton’s Method牛顿迭代法</h2>
<p><span class="math display">\[
x_{i+1} = x_{i} - \frac{f(x_{i})}{f&#39;(x_{i})}
\]</span></p>
<h3 id="高精度乘法">高精度乘法</h3>
<p>Multiplying two n-digit numbers (radix r = 2, 10) 0 ≤ x, y &lt; rn x1 = high half;x0 = low half <span class="math display">\[
x = x_{1} \cdot r^{\frac{n}{2}} + x_{0}
\]</span> <span class="math display">\[
y = y_{1} \cdot r^{\frac{n}{2}} + y_{0}
\]</span> <span class="math display">\[
z = x · y = x_1y_1 · r^n + (x_0 · y_1 + x_1 · y_0)r^{n/2} + x_0 · y_0
\]</span></p>
<p>θ(n^2) time</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Schönhage-Strassen算法是一种快速整数乘法算法,由Arnold Schönhage和Volker Strassen在1971年提出。它比传统的乘法算法要快得多,其时间复杂度为O(n log n log log n)。</span><br><span class="line">Schönhage-Strassen算法的基本思想是:</span><br><span class="line">1. 将两个n位数a和b拆分成大约n/2位数的块。例如,1234 = 12, 34;   2345 = 23, 45。</span><br><span class="line">2. 计算所有块之间的乘积,得到4个结果:a1b1, a1b2, a2b1, a2b2。这可以用递归方式计算。</span><br><span class="line">3. 根据分块的位数 Shift 加上进位,得到a1b1*(10^n), a1b2*10^n/2, a2b1*10^n/2, a2b2。</span><br><span class="line">4. 最后将4个结果相加,得到a*b。</span><br><span class="line">5. 例如,计算12345 * 6789:</span><br><span class="line">6. 分块:12, 34,   67, 892. 计算块间乘积:12 * 67 = 804,   12 * 89 = 1068, 34 * 67 = 2298, 34 * 89 = 3026 </span><br><span class="line">7. Shift并加进位:804 * 10000, 1068 * 5000, 2298 * 5000, 30264. </span><br><span class="line">8. 相加:8040000 + 5340000 + 11490000 + 15130000 = 123456791这种算法通过分块和递归减少每一步的计算量,在计算两个大整数的乘积时有很高的效率,尤其适用于超长整数的相乘。它在一定程度上简化了超长整数运算,是数论和计算机科学中很有价值的一种算法。</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong> <img src="/assets/mit6.006总和笔记/image-20231020135416200.png" /> <strong>误差分析</strong> <img src="/assets/mit6.006总和笔记/image-20231020140715299.png" /> <span class="math display">\[
ε_{n+1} =  \frac{ε_n^2}{2*(1+ε_n)}
\]</span></p>
<h3 id="高精度除法">高精度除法</h3>
<p>a/b -&gt; 1/b*a - &gt; mod(R/b) // R是一个容易除的较大值</p>
<p><img src="/assets/mit6.006总和笔记/image-20231020141331913.png" /> <img src="/assets/mit6.006总和笔记/image-20231020141401286.png" /> 除法的复杂度等于乘法 To understand this, assume that the complexity of multiplication is Θ(nα) for n- digit numbers, with α ≥ 1. Division requires multiplication of different-sized numbers at each iteration. Initially the numbers are small, and then they grow to d digits.</p>
<p>We apply a first level of Newton’s method to solve f (x) = x2 − a. Each iteration of this first level1 requires a division. If we set the precision to d digits right from the beginning, then convergence at the first level will require lg d iterations. This means the complexity of computing a square root will be Θ(dα lg d) if the complexity of multiplication is Θ(dα), given that we have shown that the complexity of division is the same as the complexity of multiplication. However, we can do better, if we recognize that the number of digits of precision we need at beginning of the first level of Newton’s method starts out small and then grows. If the complexity of a d-digit division is Θ(dα), then a similar summation to the one above tells us that the complexity of computing square roots is Θ(dα)</p>
<h1 id="图论">图论</h1>
<h2 id="概念">概念</h2>
<p>图：for each vertex u ∈ V, Adj[u] stores u’s neighbors, i.e., {v ∈ V | (u, v) ∈ E}. Adj 的大小为 θ(|V |)，而每个 Adj(u) 的大小为 θ(deg(u))</p>
<p>表示分为邻接表和邻接矩阵 <img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png" /> <img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png" /> <img src="/assets/mit6.006总和笔记/QQ图片20231121160100.png" /></p>
<h3 id="路径">路径</h3>
<ul>
<li>路径是顶点序列p=(v1,v2,...,vk),其中(vi,vi+1)∈E, 1≤i&lt;k<br />
</li>
<li>如果路径上没有重复顶点,则为简单路径<br />
</li>
<li>路径p的长度为路径上的边数<br />
</li>
<li>u到v的距离δ(u,v)为从u到v的最短路径长度</li>
</ul>
<p><strong>路径问题</strong>:</p>
<ul>
<li>图中的多种路径问题:<br />
  - 单源可达性:s是否可达t<br />
  - 单源最短路径:返回δ(s,t)和s到t的最短路径<br />
  - 单源最短路径:返回从s到所有v的δ(s,v)和最短路径树<br />
</li>
<li>如何对每个顶点返回从源s的最短路径?<br />
</li>
<li>返回所有路径需Ω(|V|^2)时间<br />
</li>
<li>只存储每个v的父节点P(v),s的父节点为空<br />
</li>
<li>父节点构成包含从s可达所有最短路径的最短路径树,大小为O(|V|)</li>
</ul>
<h2 id="bst">BST</h2>
<p><strong>应用</strong></p>
<ul>
<li>网络抓取（Google 如何查找页面）</li>
<li>社交网络（Facebook 好友查找器）</li>
<li>网络广播路由</li>
<li>垃圾收集</li>
<li>模型检查（有限状态机）</li>
<li>检查数学猜想</li>
<li>解决谜题和游戏</li>
</ul>
<p>如何计算图中所有顶点v的δ(s,v)和P(v)?</p>
<ul>
<li>使用集合数据结构来存储每个顶点v对应的δ(s,v)距离和P(v)父节点。<br />
</li>
<li>如果从起点s到v没有路径,则不存储在P中,δ(s,v)设为无穷大。</li>
</ul>
<p><strong>基本思路</strong>: - 按照与起点s的距离依次增大的顺序探索图的节点。</p>
<p><strong>目标</strong>:<br />
- 计算所有与起点s距离为i的顶点的集合Li。结论:<br />
- Li中的任意顶点v必须与L_{i-1}中的某个顶点u相连。<br />
- 不会有任何距离起点距离为j(j&lt;i)的顶点出现在Li中。</p>
<p><strong>循环不变量:</strong><br />
- 在计算到Li之前,δ(s,v)和P(v)对于所有Lj(j&lt;i)中的顶点v都已正确赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BFS (V,Adj,s): See CLRS for queue-based implementation</span><br><span class="line">    level = &#123; s: 0 &#125;</span><br><span class="line">    parent = &#123;s : None &#125;</span><br><span class="line">    i = 1</span><br><span class="line">    frontier = [s] # previous level, i − 1</span><br><span class="line">    while frontier:</span><br><span class="line">        next = [ ] # next level, i</span><br><span class="line">        for u in frontier:</span><br><span class="line">            for v in Adj [u]:</span><br><span class="line">                if v not in level: # not yet seen</span><br><span class="line">                    level[v] = i # = level[u] + 1</span><br><span class="line">                    parent[v] = u</span><br><span class="line">                    next.append(v)</span><br><span class="line">        frontier = next</span><br><span class="line">        i + =1</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">graph_bfs</span>(<span class="params">graph: GraphAdjList, start_vet: Vertex</span>) -&gt; <span class="built_in">list</span>[Vertex]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;广度优先遍历 BFS&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">    <span class="comment"># 顶点遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    visited = <span class="built_in">set</span>[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 队列用于实现 BFS</span></span><br><span class="line">    que = deque[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(que) &gt; <span class="number">0</span>:</span><br><span class="line">        vet = que.popleft()  <span class="comment"># 队首顶点出队</span></span><br><span class="line">        res.append(vet)  <span class="comment"># 记录访问顶点</span></span><br><span class="line">        <span class="comment"># 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> adj_vet <span class="keyword">in</span> graph.adj_list[vet]:</span><br><span class="line">            <span class="keyword">if</span> adj_vet <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 跳过已被访问过的顶点</span></span><br><span class="line">            que.append(adj_vet)  <span class="comment"># 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adj_vet)  <span class="comment"># 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment"># 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本情况(i=1):</p>
<ul>
<li>L0={s},δ(s,s)=0,P(s)=None归纳步骤: (L表示level)</li>
<li>计算Li时:<br />
  - 对Li-1中的每个顶点u:<br />
    - 对于任一不在Lj(j&lt;i)中的相邻顶点v:<br />
      - 将v加入Li,设置δ(s,v)=i,P(v)=u重复计算:</li>
<li>按i递增顺序重复计算Li,直到Li为空集<br />
</li>
<li>对任一不可达顶点v,设置δ(s,v)=∞</li>
<li>因此通过归纳证明,广度优先搜索可以正确计算所有δ(s,v)和P(v)。</li>
</ul>
<p><strong>时间复杂度分析</strong>:</p>
<ul>
<li>用支持快速遍历和插入的数据结构存储Li<br />
</li>
<li>通过检查P来判断一个顶点是否在Lj(j&lt;i)中<br />
</li>
<li>用支持O(1)操作的字典结构存储δ和P<br />
</li>
<li>每个顶点u最多加入一个Li,并对每个邻点v做O(1)操作<br />
</li>
<li>以上这些部分是O(|E|)</li>
<li>最后处理不可达顶点需O(|V|)<br />
</li>
<li>所以总时间复杂度是O(|V|+|E|)</li>
</ul>
<p><span class="math display">\[
level[v] = \begin{cases}
           level &amp; \text{if } v \text{ assigned level} \\\\
           \infty &amp; \text{else (no path)}
\end{cases}
\]</span></p>
<h2 id="dst">DST</h2>
<p>基本思想:</p>
<ul>
<li>递归访问出边邻接顶点,但不重复访问已访问过的顶点。<br />
</li>
<li>尽可能深入探索路径,直到无法继续,然后回溯找到未探索的路径。 执行步骤:</li>
<li>初始化P(s)=None,执行visit(s)过程:<br />
  - 对每个未在P中出现的邻接顶点v:设P(v)=u并递归调用visit(v)<br />
  - 标记访问完顶点u(用于拓扑排序) 不用返回distance,因此时间是O(E)</li>
</ul>
<p>全BFS和全DFS:</p>
<ul>
<li>目标是探索整个图,而不仅仅是一个源点可达的部分。<br />
</li>
<li>重复在任一未访问顶点s上运行BFS或DFS,直到所有顶点都被访问。<br />
</li>
<li>时间复杂度都是O(|V| + |E|)</li>
</ul>
<p>连通分量:</p>
<ul>
<li>将无向图的顶点集分割成子集Vi,使每个Vi内部连通,Vi之间无边。连通性算法:<br />
</li>
<li>任意单源可达性算法A都可以求解连通分量。<br />
</li>
<li>重复运行全A,每次A访问的顶点集就是一个连通分量。</li>
</ul>
<p>连通性算法:</p>
<ul>
<li>任意单源可达性算法A都可以求解连通分量。<br />
</li>
<li>重复运行全A,每次A访问的顶点集就是一个连通分量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parent = &#123;s: None&#125;</span><br><span class="line">DFS-visit (V, Adj, s):</span><br><span class="line">    for v in Adj [s]:</span><br><span class="line">        if v not in parent:</span><br><span class="line">            parent [v] = s</span><br><span class="line">            DFS-visit (V, Adj, v)</span><br><span class="line">DFS (V, Adj):</span><br><span class="line">    parent = &#123; &#125;</span><br><span class="line">    for s in V:</span><br><span class="line">        if s not in parent:</span><br><span class="line">            parent [s] = None</span><br><span class="line">            DFS-visit (V, Adj, s)</span><br></pre></td></tr></table></figure>
<p>O(V + E)</p>
<p><strong>总结</strong>：</p>
<ul>
<li>Single-Source Shortest Paths with BFS in O(|V | + |E|) time (return distance per vertex)</li>
<li>Single-Source Reachability with BFS or DFS in O(|E|) time (return only reachable vertices)</li>
<li>Connected components with Full-BFS or Full-DFS in O(|V | + |E|) time</li>
<li>Topological Sort of a DAG with Full-DFS in O(|V | + |E|) time</li>
</ul>
<h3 id="拓扑排序算法">拓扑排序算法</h3>
<ul>
<li>DFS访问每个顶点v时,记录DFS结束顺序finish[v]<br />
</li>
<li>按finish[v]递减顺序输出顶点具体步骤:</li>
</ul>
<ol type="1">
<li>通过DFS遍历图<br />
</li>
<li>将顶点按finish[v]时间降序插入order<br />
</li>
<li>将order反转 <strong>正确性证明</strong>:<br />
对任意边(u,v)有u在v之前</li>
</ol>
<ul>
<li>如果u先访问:<br />
  - 在访问u结束前会访问v(直接或间接)<br />
  - 因此v结束时间在u之前<br />
</li>
<li>如果v先访问:<br />
  - 图无环<br />
  - 无法从v访问u<br />
  - 因此v结束时间在u之前因此DFS结束时间递减顺序即为拓扑排序顺序。</li>
</ul>
<h3 id="循环检测算法">循环检测算法</h3>
<p><strong>利用全DFS检测环</strong>:</p>
<ul>
<li>如果无向图无环,全DFS的反序order就是拓扑排序。<br />
</li>
<li>对每条边 (u, v)，反序中如果v不在u前，就有环<br />
</li>
<li>可以在O(|E|)时间内检测反序是否有环（哈希或者数组的数据结构）</li>
</ul>
<p><strong>定位环的算法</strong>:</p>
<ul>
<li>在全DFS过程中维护当前顶点的祖先集合</li>
<li>如果DFS遍历到一条从v到其祖先的边,则存在环。</li>
</ul>
<p><strong>正确性证明</strong>:</p>
<ul>
<li>设图包含环(v0,v1,...,vk,v0),假设v0首先被DFS访问。<br />
</li>
<li>对每个vi,在访问vi结束前会访问vi+1并结束。<br />
</li>
<li>最后在访问vk结束前会访问v0,此时v0是vk的祖先。</li>
</ul>
<h2 id="最短路径">最短路径</h2>
<p><img src="/assets/mit6.006总和笔记/image-20231024194703867.png" /></p>
<ul>
<li>路径π的权重w(π)是路径上所有边权重之和<br />
</li>
<li>s到t的最短路径是从s到t权重最小的路径</li>
<li>δ(s,t)表示从s到t的最短路径权重</li>
<li>对一般权图,还不知道O(|V|+|E|)的最短路径算法<br />
</li>
<li>但对DAG可以在O(|V|+|E|)时间内求解</li>
</ul>
<h3 id="简单最短路径">简单最短路径</h3>
<p>简单的最短路径 • 如果图表包含循环和负权重，则可能包含负权重循环 • 如果图形不包含负权环，则最短路径很简单！ • 主张 1：如果 δ(s, v) 是有限的，则存在一条到 v 的最短路径，该路径很简单 • 证明： 通过反证法： – 假设没有简单的最短路径； 设 π 为顶点最少的最短路径 – π 不简单，所以 π 中存在环 C； C 具有非负权重（或者 δ(s, v) = −∞） – 从 π 中删除 C 形成路径 π0，具有更少的顶点和权重 w(π0) ≤ w(π) • 由于简单路径不能重复顶点，因此有限最短路径最多包含 |V | − 1 条边</p>
<h3 id="有权图基础">有权图基础</h3>
<h4 id="最小生成树">最小生成树</h4>
<p>If know δ(s, v) for all vertices v ∈ V , can construct shortest-path tree in O(|V | + |E|) time</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initialize empty parent pointer P and set P(s) = NoneFor each vertex u ∈ V where δ(s, u) is finite:  </span><br><span class="line">  For each outgoing neighbor v ∈ Adj+(u):  </span><br><span class="line">    If P(v) is not assigned and δ(s, v) = δ(s, u) + w(u, v):  </span><br><span class="line">      There exists a shortest path through edge (u, v), so set P(v) = uParent pointers may traverse cycles of zero weight. Mark each vertex in such a cycle.For each unmarked vertex u ∈ V (including vertices later unmarked):  </span><br><span class="line">  For each v ∈ Adj+(u) where v is marked and δ(s, v) = δ(s, u) + w(u, v):  </span><br><span class="line">    Unmark vertices in cycle containing v by traversing parent pointers from v  </span><br><span class="line">    Set P(v) = u, breaking the cycle</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>初始化父节点指针P，设置P(s)为空</li>
<li>对u的每条出边通向的节点v</li>
<li>如果P(v)为空且s-&gt;v最短路径是s-&gt;u-&gt;v,则P(v)=u</li>
<li>父节点可能导致一个权值为0的循环，如果有环则标记出来</li>
<li>对每个没有被标记的u(包括之后会被标记的)</li>
<li>如果有标记的邻居v满足最短路径条件</li>
<li>通过遍历v的父节点清除对它和它的父节点的标记</li>
<li>设置P(v)=u，打破循环</li>
</ol>
<h4 id="dag松弛算法">DAG松弛算法:</h4>
<ol type="1">
<li><p>对每个顶点v维护一个距离估计d(s,v),初始化为无穷大,始终上界真实最短距离δ(s,v)</p></li>
<li><p>当边(u,v)违反三角不等式时,通过松弛操作将d(s,v)降低为d(s,u)+w(u,v)</p></li>
<li><p>松弛操作保证了d(s,v)始终是到v的某条路径的权重(或无穷大)</p></li>
<li><p>算法流程:<br />
  - 初始化d(s,v)=无穷大,d(s,s)=0<br />
   - 按拓扑排序顺序遍历每个顶点u<br />
     - 对每个出边(u,v),如果d(s,v) &gt; d(s,u)+w(u,v),执行松弛操作</p></li>
<li><p>可以证明当算法结束时,d(s,v)=δ(s,v),即正确计算出最短距离</p></li>
<li><p>时间复杂度为O(V+E),是线性时间算法</p></li>
<li><p>主要思想是利用DAG没有环的特点,通过松弛操作逐步收紧距离上界,直到使其等于最短距离</p></li>
<li><p>利用拓扑排序的顺序,保证每次松弛时通过的顶点u的d(s,u)已经是最短距离</p></li>
</ol>
<h3 id="generic-s.p.-algorithm通用最短路径算法">Generic S.P. Algorithm通用最短路径算法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Initialize:            for v in V:</span><br><span class="line">                            d[v] ← ∞</span><br><span class="line">                            Π[v] ← NIL</span><br><span class="line">                        d[s] ← 0</span><br><span class="line"></span><br><span class="line">Main:                  Repeat</span><br><span class="line">                       select edge (u, v)</span><br><span class="line">Relax edge (u, v):         if d[v] &gt; d[u] + w(u, v):</span><br><span class="line">                               d[v] ← d[u] + w(u, v)</span><br><span class="line">                               Π[v] ← u</span><br><span class="line">                        until you can’t relax any more edges or you’re tired or . .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 u 到 v 的最短路径权重是 δ(u, v)。 如果从 u 无法到达 v，则 δ(u, v) 为 Infini， 如果从 u 到 v 的某个路径上存在负循环，则未定义。 <img src="/assets/mit6.006总和笔记/image-20231023103416467.png" /> <img src="/assets/mit6.006总和笔记/image-20231023104514707.png" /> PATHological示例:设置n个节点,前3对节点的边权为2<sup>n/2,第二组节点边权为2</sup>(n/2)-1,以此类推。这样设置权重,从v0到vn-1的距离约为2<sup>n。算法可能每次只将距离减少1,需重复2</sup>n次,时间复杂度为O(2^n)。 因此最短路径算法的性能很大程度上取决于图的结构,存在PATHological情况时算法效率很低。需设计改进的算法,避免指数时间复杂度。</p>
<h3 id="迪杰斯特拉无负数边的图">迪杰斯特拉（无负数边的图）</h3>
<ol type="1">
<li>初始化:对每个顶点v,设置d(s,v)=∞,d(s,s)=0。</li>
<li>构建一个优先队列Q,每个顶点v以(v,d(s,v))为项加入Q。</li>
<li>循环直到Q为空:<br />
   - 出队Q中key最小的顶点u<br />
   - 对每个出边(u,v):<br />
      - 如果d(s,v) &gt; d(s,u) + w(u,v):<br />
         - 进行松弛操作         -  降低Q中v的key值到新的d(s,v)</li>
<li>时间复杂度O(E+VlogV),使用二叉堆可以达到O(E+VlogV)</li>
</ol>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html">演示</a> 1. 对每个边(u,v),假设权重w(u,v)≥0,维护一个集合S,包含已确定最短路径权重的顶点。 2. 重复地从V-S中选择一个离源点最近的顶点u,将u加入S,松弛u的所有出边,即比较点u连通的其他节点，从点u出发的路径是否比距离表内的短 3. 伪代码: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Dijkstra (G, W, s) //uses priority queue Q</span><br><span class="line"> Initialize (G, s)</span><br><span class="line"> S ← φ</span><br><span class="line"> Q ← V [G] //Insert into Q</span><br><span class="line"> while Q != φ</span><br><span class="line">  do u ← EXTRACT-MIN(Q) //deletes u from Q</span><br><span class="line">  S = S ∪ &#123;u&#125;</span><br><span class="line">  for each vertex v ∈ Adj[u]</span><br><span class="line">   do RELAX (u, v, w) ← this is an implicit DECREASE KEY operation</span><br><span class="line"></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RELAX(u, v, w)</span><br><span class="line"> if d[v] &gt; d[u] + w(u, v)</span><br><span class="line">  then d[v] ← d[u] + w(u, v)</span><br><span class="line">  Π[v] ← u</span><br><span class="line">放松是安全的</span><br><span class="line"> 引理：松弛算法对于所有的情况都保持 d[v] ≥ δ(s, v) 的不变量</span><br><span class="line"> v ∈ V 。</span><br><span class="line"> 证明：通过步数归纳。</span><br><span class="line"> 考虑 RELAX(u, v, w)。  通过归纳法 d[u] ≥ δ(s, u)。  通过三角形 -</span><br><span class="line"> 等式，δ(s, v) ≤ δ(s, u) + δ(u, v)。  这意味着 δ(s, v) ≤ d[u] + w(u, v)，因为</span><br><span class="line"> d[u] ≥ δ(s, u) 且 w(u, v) ≥ δ(u, v)。  因此设置 d[v] = d[u] + w(u, v) 是安全的。</span><br><span class="line"></span><br></pre></td></tr></table></figure> 4. 通过重复选择最近顶点,逐步确定最短路径,时间复杂度为O(|E|+|V|log|V|)。 <img src="/assets/mit6.006总和笔记/image-20231024112814756.png" /></p>
<h4 id="证明">证明</h4>
<p>归纳法证明当顶点v从Q中取出时,d(s,v) = δ(s,v)成立: 基础:s第一个取出,d(s,s)=0 = δ(s,s)成立 - 归纳假设:对前k-1个顶点成立 - 考虑第k个顶点v0:    - 取v0到s的最短路径π,w(π)=δ(s,v0)   - 设(x,y)是π中第一个y不在前k-1个顶点的边    - 当x取出时,d(s,x)=δ(s,x)(归纳假设)    - 所以取出x时松弛(x,y),d(s,y) ≤ δ(s,x) + w(x,y) = δ(s,y)   - 由于松弛操作的安全性,d(s,v0) ≤ δ(s,v0)    - 又因为v0是Q中key最小的,d(s,v0) ≥ δ(s,v0)    - 所以d(s,v0) = δ(s,v0)</p>
<h4 id="时间复杂度">时间复杂度</h4>
<div class="line-block">操作 | 时间复杂度 | 在Dijkstra中的出现次数|</div>
<p>|-|-|-| <br />
|Q.build(X) (n = |X|)| Bn | 1 |<br />
|Q.delete min()| Mn | |V| |<br />
|Q.decrease key(id, k)| Dn | |E| | 总计O(B|V | + |V | · M|V | + |E| · D|V |) 对一个对顶点所有节点可达的图（修建过）： <img src="/assets/mit6.006总和笔记/image-20231025202308176.png" /> 对不同稀疏密度的图,使用不同的数据结构实现Dijkstra算法可以得到不同的时间复杂度: - 如果图是密集的,即 |E| = Θ(|V|<sup>2),使用数组实现优先队列Q,时间复杂度为O(|V|</sup>2) - 如果图是稀疏的,即 |E| = Θ(|V|),使用二叉堆实现Q,时间复杂度为 O(|V|log|V|) - Fibonacci堆在理论上对任意图都很好,但是实践中不常用 - 在理论分析中,通常假设Dijkstra算法的时间复杂度为O(|E| + |V|log|V|) 总结 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Dijkstra Complexity</span><br><span class="line"> Θ(v) inserts into priority queue</span><br><span class="line"> Θ(v) EXTRACT MIN operations</span><br><span class="line"> Θ(E) DECREASE KEY operations</span><br><span class="line">Array impl:</span><br><span class="line"> Θ(v) time for extra min</span><br><span class="line"> Θ(1) for decrease key</span><br><span class="line"> Total: Θ(V.V + E.1) = Θ(V 2 + E) = Θ(V 2)</span><br><span class="line">Binary min-heap:</span><br><span class="line"> Θ(lg V ) for extract min</span><br><span class="line"> Θ(lg V ) for decrease key</span><br><span class="line"> Total: Θ(V lg V + E lg V )</span><br><span class="line">Fibonacci heap (not covered in 6.006):</span><br><span class="line"> Θ(lg V ) for extract min</span><br><span class="line"> Θ(1) for decrease key</span><br><span class="line"> amortized cost</span><br><span class="line"> Total: Θ(V lg V + E)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="优化双向搜索">优化——双向搜索</h4>
<p>如果只需要s到t的最短路径，则只需要进行到t出队时结束算法 1. 双向搜索可以加速搜索,但不改变最坏时间复杂度,实际上可以减少访问的节点数。 2. 双向搜索同时进行:     - 从s节点进行正向搜索    - 从t节点进行反向搜索(沿边反向移动) 3. 正向搜索距离标记为df(u),反向为db(u) 4. 当一个节点w同时被两边搜索删除出队列时,搜索终止。 5. 终止后,找到df(x)+db(x)最小的节点x,x不一定是终止节点w。 6. 使用正向predecessor树Πf找到s到x的最短路径,使用反向树Πb找到t到x的最短路径。 7. 节点x一定已经被某一边搜索删除出队列。 <img src="/assets/mit6.006总和笔记/image-20231024193957638.png" /></p>
<h4 id="a算法">A*算法</h4>
<ol type="1">
<li>A*通过势函数修改边权重指引搜索方向:w'(u,v) = w(u,v) - λ(u) + λ(v)</li>
<li>选择势函数使修改后的权重保持最短路径不变,且权重非负,以适用于Dijkstra算法。</li>
<li>设定目标势值为0,源点势值足够大,可以引导搜索方向。</li>
<li>使用landmark技巧:预计算顶点到一些landmark节点的最短距离δ(u,l)。定义势函数λ(u)=δ(u,l)-δ(t,l),可以证明是可行的。</li>
<li>对每个landmark l计算势函数λ,取最大值作为最终势函数,仍可行。</li>
<li>A*相比普通搜索可以显著减少搜索范围,提高效率。但最坏情况时间复杂度未改变。</li>
</ol>
<p>Modify edge weights with potential function over vertices <span class="math display">\[
\overline{w}(u, v) = w(u, v) - λ(u) + λ(v)
\]</span></p>
<p>So shortest paths are maintained in modified graph with w(overline) weights <span class="math display">\[
\overline{w}(p) = w(p) - λ_t(u) + λ_t(t)
\]</span> Small set of landmarks LCV . For all u ∈ V, l ∈ L, pre-compute δ(u, l). Potential <span class="math display">\[
λ_t^{(l)}(u) = δ(u, l) − δ(t, l)
\]</span> <img src="/assets/mit6.006总和笔记/image-20231024193915317.png" /></p>
<h3 id="贝尔曼福特">贝尔曼福特</h3>
<h4 id="负循环检测">负循环检测</h4>
<ol type="1">
<li>定义k边距离δk(s,v):从s到v的路径中最多包含k条边的最小路径权重。</li>
<li>计算出δ|V|-1(s,v)和δ|V|(s,v),如果δ|V|(s,v)&lt;δ|V|-1(s,v),则v是一个负环见证人(witness)。</li>
<li>任意有向图中，对每个v∈V，计算δ(s,v)和δ|V|-1(s,v):<br />
   - 如果δ(s,v)&lt;δ|V|-1(s,v),则δ|V |(s, v) =- ∞，把v视为负循环见证人    - 如果δ(s,v)!=−∞,则δ(s,v)=δ|V|-1(s,v)(简单最短路径原理)    - 如果δ(s,v)=−∞,v可以从某个见证人出发而到达</li>
<li>证明思路:<br />
</li>
</ol>
<ul>
<li>假设某个负环C可达且不包含见证人,则对C中任一顶点v有:<br />
δ|V|(s,v) ≤ δ|V|-1(s,v的前驱)+w(v的前驱,v) &lt; δ|V|-1(s,v)<br />
</li>
<li>矛盾,所以C中必须存在见证人。</li>
<li><img src="/assets/mit6.006总和笔记/image-20231025082230441.png" /></li>
</ul>
<h4 id="定义">定义</h4>
<p><img src="/assets/mit6.006总和笔记/image-20231025092945965.png" /> 正确性： s到vk(k表示层数)的最短路径是每层可能的路径的最短者，贝尔曼福特算法穷举每一种可能，所以最后能得出最短的|V|-1层路径，从|V|-1到|V|则取决于图有没有负循环，如果有负循环，则s到见证人可达的结点路径为负无穷长 运行时间 1. 构建多层图G'需O(|V|(|V|+|E|)) 2. 在G'上运行DAG最短路径算法需O(|V|(|V|+|E|))，即G'大小的线性时间 3. 处理每个负环见证人需O(1),找到一个见证人的所有可达结点是O(|E|)见证人最多V个，找到所有见证人的可达性需O(|V||E|) 4. 如果把G修整成s开始的s可达子图，时间复杂度为O(|V||E|)</p>
<p>扩展思考: <img src="/assets/mit6.006总和笔记/image-20231025093817635.png" /></p>
<p><img src="/assets/mit6.006总和笔记/image-20231025080815803.png" /> • |V | + 1 levels: vertex vk in level k represents reaching vertex v from s using ≤ k edges • If edges only increase in level, resulting graph is a DAG • Construct new DAG G0 = (V 0, E0) from G = (V, E): – G' has |V |(|V | + 1) vertices v_k for all v ∈ V and k ∈ {0, . . . , |V |} – G' has |V |(|V | + |E|) edges: ∗ |V | edges (vk−1, vk) for k ∈ {1, . . . , |V |} of weight zero for each v ∈ V ∗ |V | edges (uk−1, vk) for k ∈ {1, . . . , |V |} of weight w(u, v) for each (u, v) ∈ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Bellman-Ford(G,W,s)</span><br><span class="line"> Initialize ()</span><br><span class="line"> for i = 1 to |V | − 1</span><br><span class="line">  for each edge (u, v) ∈ E:</span><br><span class="line">   Relax(u, v)</span><br><span class="line"> for each edge (u, v) ∈ E</span><br><span class="line">  do if d[v] &gt; d[u] + w(u, v)</span><br><span class="line">   then report a negative-weight cycle exists</span><br><span class="line">//At the end, d[v] = δ(s, v), if no negative-weight cycles</span><br><span class="line"></span><br></pre></td></tr></table></figure> 1. 初始化,进行|V|-1轮松弛操作,每轮对每个边(u,v)做relax操作，非负的图最多需要|V|-I次操作就可以松弛到任意点出发的任意路径都是最短路径 2. 如果第|V|轮还可以relax任意边,说明存在负权环。 3. 如果图中无负权环,Bellman-Ford执行结束后d[v]=δ(s,v)。 4. 推论:如果d[v]在|V|-1轮未收敛,说明存在从s可达的负权环。 5. Bellman-Ford时间复杂度为O(|V||E|),适合稠密图。</p>
<h4 id="最长简单路径和最短简单路径">最长简单路径和最短简单路径</h4>
<p>在具有非负边权重的图中找到最长的简单路径是一个 NP- hard问题，不存在已知的多项式时间算法。 假设一个 只需否定每个边权重并运行 Bellman-Ford 来计算最短 路径。 贝尔曼-福特不一定会计算原始路径中的最长路径 图，因为可能存在可从源到达的负权重循环，并且 算法将中止。 类似地，如果我们有一个具有负循环的图，并且我们希望找到最长的 从源 s 到顶点 v 的简单路径，我们不能使用 Bellman-Ford。 最短的 简单路径问题也是NP- hard问题</p>
<h2 id="johnsons-algorithm">Johnson’s Algorithm</h2>
<h3 id="all-pairs-shortest-paths-apsp">All-Pairs Shortest Paths (APSP)</h3>
<ul>
<li>输入:有向带权图G=(V,E),权值函数w:E→Z</li>
<li>输出:对所有u,v∈V,求出δ(u,v),如果有负权回路则报错</li>
<li>应用:理解整个网络,如交通、电路布线、供应链等</li>
<li>直接运行|V|次单源算法时间复杂度:     - DAG松弛: |V|·O(|V|+|E|),无环<br />
  - BFS: |V|·O(|V|+|E|),非负权值<br />
  - Dijkstra: |V|·O(|V|log|V|+|E|),非负权值<br />
  - Bellman-Ford: |V|·O(|V||E|),一般图</li>
</ul>
<p>思路：重构权值函数,使G变为G',其中G'没有负权边,且G的最短路径在G'上也是最短路径。如果成功,就可以在G'上运行Dijkstra 实现： 对每个顶点v:<br />
- 从v出发的边权加上h<br />
- 进入v的边权减去h<br />
- 这样可以保证最短路径不变<br />
- 证明:<br />
  - 任意从v开始的路径权值改变了h<br />
  - 任意到v结束的路径权值改变了-h<br />
  - 通过v的路径权值局部不变</p>
<p><img src="/assets/mit6.006总和笔记/image-20231025213904004.png" /></p>
<h3 id="算法">算法</h3>
<ul>
<li>构造含新顶点x的图Gx,x到每个顶点v有权值为0的边</li>
<li>对Gx运行Bellman-Ford算法计算δx(x,v)</li>
<li>如果δx(x,v)为无穷大,说明G中有负权回路,报错退出</li>
<li>否则,用δx重新调整每个边的权值构造G'</li>
<li>对G'运行Dijkstra算法|V|次计算每个顶点的最短路径 </li>
<li>从G'的最短路径恢复G的最短路径</li>
</ul>
<h3 id="时间复杂度-1">时间复杂度</h3>
<ul>
<li>构造Gx需O(|V|+|E|)</li>
<li>Bellman-Ford需O(|V||E|)</li>
<li>构造G'需O(|V|+|E|)</li>
<li>|V|次Dijkstra需O(|V|(|V|log|V| + |E|))</li>
<li>用G'恢复G的距离需O(|V|^2)</li>
<li>总计O({|V|^2}log|V| + |V||E|)</li>
</ul>
<h1 id="概率">概率</h1>
<p>雇佣问题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">best = 0</span><br><span class="line">hired = null</span><br><span class="line">for i = 1 to n</span><br><span class="line">if candidates[i] &gt; best</span><br><span class="line"> best = candidates[i]</span><br><span class="line"> hired = i</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="指示器随机变量">指示器随机变量</h2>
<p>指示器随机变量可以用于对随机输入的算法分析 <span class="math display">\[I(A) = \begin{cases}  
           1 &amp; \text{event A occurs} \\  
           0 &amp; \text{otherwise}  
\end{cases}\]</span> 把期望转化成指示器期望的相加</p>
<h2 id="随机算法">随机算法</h2>
<p>在此基础上可以在算法中进行随机数处理，排除输入的影响 比如在雇佣问题中，对输入的候选者数组进行随机排序 随机排序： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">n = A.length</span><br><span class="line">let P[1-n] be a new array</span><br><span class="line">for i=1 to n</span><br><span class="line"> P[i] = RANDOM(1,n^3)</span><br><span class="line">sort A,use P</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="递归和动态规划">递归和动态规划</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># recursive solution (top down)</span><br><span class="line">def fib(n):</span><br><span class="line"> memo = &#123;&#125;</span><br><span class="line"> def F(i):</span><br><span class="line">  if i &lt; 2: return i # base cases</span><br><span class="line">  if i not in memo: # check memo</span><br><span class="line">   memo[i] = F(i - 1) + F(i - 2) # relation</span><br><span class="line">  return memo[i]</span><br><span class="line"> return F(n) # original</span><br><span class="line"># iterative solution (bottom up)</span><br><span class="line">def fib(n):</span><br><span class="line"> F = &#123;&#125;</span><br><span class="line"> F[0], F[1] = 0, 1 # base cases</span><br><span class="line"> for i in range(2, n + 1): # topological order</span><br><span class="line">  F[i] = F[i - 1] + F[i - 2] # relation</span><br><span class="line"> return F[n] # original</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231027103835269.png" /> <img src="/assets/mit6.006总和笔记/image-20231027112657842.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># recursive solution (top down)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bowl</span>(<span class="params">v</span>):</span><br><span class="line"> memo = &#123;&#125;</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">B</span>(<span class="params">i</span>):</span><br><span class="line">  <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(v): <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># base cases</span></span><br><span class="line">  <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> memo: <span class="comment"># check memo</span></span><br><span class="line">  memo[i] = <span class="built_in">max</span>(B(i+<span class="number">1</span>), <span class="comment"># relation: skip pin i</span></span><br><span class="line">   v[i] + B(i+<span class="number">1</span>), <span class="comment"># OR bowl pin i separately</span></span><br><span class="line">   v[i] * v[i+<span class="number">1</span>] + B(i+<span class="number">2</span>)) <span class="comment"># OR bowl pins i and i+1 together</span></span><br><span class="line">   <span class="keyword">return</span> memo[i]</span><br><span class="line">  <span class="keyword">return</span> B(<span class="number">0</span>) <span class="comment"># original</span></span><br><span class="line"><span class="comment"># iterative solution (bottom up)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bowl</span>(<span class="params">v</span>):</span><br><span class="line"> B = &#123;&#125;</span><br><span class="line"> B[<span class="built_in">len</span>(v)] = <span class="number">0</span> <span class="comment"># base cases</span></span><br><span class="line"> B[<span class="built_in">len</span>(v)+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(v))): <span class="comment"># topological order</span></span><br><span class="line">  B[i] = <span class="built_in">max</span>(B[i+<span class="number">1</span>], <span class="comment"># relation: skip pin i</span></span><br><span class="line">   v[i] + B(i+<span class="number">1</span>), <span class="comment"># OR bowl pin i separately</span></span><br><span class="line">   v[i] * v[i+<span class="number">1</span>] + B(i+<span class="number">2</span>)) <span class="comment"># OR bowl pins i and i+1 together</span></span><br><span class="line"> <span class="keyword">return</span> B[<span class="number">0</span>] <span class="comment"># original</span></span><br></pre></td></tr></table></figure>
<p>如何关联子问题解决方案 • 我们遵循的一般方法来定义子问题解决方案的关系： - 确定一个有关子问题解决方案的问题，如果知道答案，则该问题将减少到“更小的”子问题 - 在打保龄球的情况下，问题是“我们如何打第一对球瓶？” - 然后通过尝试所有可能的答案并采取最好的答案来本地暴力解决问题 - 在保龄球的情况下，我们取最大值，因为问题要求最大化 - 或者，我们可以考虑正确猜测问题的答案，然后 直接递归； 但随后我们实际上检查所有可能的猜测，并返回“最佳” • 效率的关键是问题有少量（多项式）可能的可能性。答案，所以暴力破解并不太昂贵 • 通常（但并非总是）计算关系的非递归工作等于数字 我们正在尝试的答案</p>
<h2 id="动态规划">动态规划</h2>
<h3 id="lcs">LCS</h3>
<p>• x(i, j) = A[i :] 和 B[j :]的最大公共子序列 • For 0 &lt;= i &lt;= |A| and 0 &lt;=0 j &lt;= |B| 最长公共子序列问题(LCS): 1. 定义了子问题x(i,j),表示 A[i:]和B[j:]的最长公共子序列长度。 2. 列出了递归关系 - 如果A[i]==B[j],那么x(i,j)等于x(i+1,j+1)+1,否则等于x(i+1,j)和x(i,j+1)的最大值。 3. 指出了拓扑顺序,子问题依赖更大的i或j。 4. 给出了 base cases —— 当一个字符串为空时,LCS长度为0。x(i, |B|) = x(|A|, j) = 0 5. 原问题可以通过x(0,0)求解,同时需要parent pointers构建最长子序列。 6. 时间复杂度分析也正确,子问题数为O(|A|*|B|),每件工作为O(1),所以总时间为O(|A|*|B|)。 <span class="math display">\[
x(i,j) =
\begin{cases}
   x(i+1,j+1)+1, &amp; \text{if }A[i]=B[j] \\
   max(x(i + 1, j), x(i, j + 1)) , &amp; otherwise
\end{cases}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">A, B</span>):</span><br><span class="line"> a, b = <span class="built_in">len</span>(A), <span class="built_in">len</span>(B)</span><br><span class="line"> x = [[<span class="number">0</span>] * (b + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a + <span class="number">1</span>)]<span class="comment">#x 的最终形状是一个 (a + 1) x (b + 1) 的二维列表,每个元素初始化为 0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(b)):</span><br><span class="line">   <span class="keyword">if</span> A[i] == B[j]:</span><br><span class="line">    x[i][j] = x[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">    x[i][j] = <span class="built_in">max</span>(x[i + <span class="number">1</span>][j], x[i][j + <span class="number">1</span>])</span><br><span class="line"> <span class="keyword">return</span> x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment">#如果A[i] == B[j],那么最长公共子序列可以在A[i+1:]和B[j+1:]的基础上再加上A[i]这个字符,所以x[i][j] = x[i+1][j+1] + 1。</span></span><br><span class="line"><span class="comment">#如果A[i] != B[j],那么A[i]和B[j]不可能同时在最长公共子序列中,需要舍弃一个字符。所以x[i][j]取x[i+1][j]和x[i][j+1]中的最大值。</span></span><br><span class="line"><span class="comment">#依次遍历,直到i或j变为-1,即遍历完两个字符串。</span></span><br></pre></td></tr></table></figure>
<h3 id="lis">LIS</h3>
<p><code>Longest Increasing Subsequence (LIS)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lis</span>(<span class="params">A</span>):</span><br><span class="line"> a = <span class="built_in">len</span>(A)</span><br><span class="line"> x = [<span class="number">1</span>] * a</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, a):</span><br><span class="line">   <span class="keyword">if</span> A[j] &gt; A[i]:</span><br><span class="line">    x[i] = <span class="built_in">max</span>(x[i], <span class="number">1</span> + x[j])</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">max</span>(x)</span><br></pre></td></tr></table></figure>
<p>x(i)是A[i:]的最长递增子数组 O(|A|^2) running time - 外层循环i是在寻找以每个元素结尾的LIS长度。 - 内层循环j是在寻找可以接在A[i]后面的最大LIS长度。 - x数组缓存了每个位置的LIS长度,避免重复计算。 - 通过从后向前遍历,可以保证每个x[i]都是最新的最大LIS长度。</p>
<h3 id="alternating-coin-game">Alternating Coin Game</h3>
<ul>
<li>两名玩家（“我”和“你”）轮流</li>
<li>轮流取出剩余硬币中的第一个或最后一个硬币</li>
<li>我的目标是最大化我所拿走的硬币的总价值，这是我首先要做的 x(i, j) =我可以从 vi, . . . , vj中拿走的最大硬币总价值 <img src="/assets/mit6.006总和笔记/image-20231027200057225.png" /> 子问题: O(n^2) • 每个子问题相加: O(n) to compute sums • O(n^3) running time</li>
</ul>
<h4 id="优化-1">优化</h4>
<ol type="1">
<li>扩展定义子问题x(i,j,p),添加了一个表示下一步该谁走的状态p。</li>
<li>列出了四个递归关系式,区分我方走与对方走的不同情况。</li>
<li>拓扑顺序及base case与第一种解法相同。</li>
<li>计算原问题时,状态为我方走。</li>
</ol>
<p>x(i, j, p) = maximum total value I can take when player p ∈ {me, you} starts from coins of values vi, . . . , vj</p>
<p>Player p must choose either coin i or coin j • If p = me, then I get the value; otherwise, I get nothing • Then it’s the other player’s turn • x(i, j, me) = max{vi + x(i + 1, j, you), vj + x(i, j + 1, you)} • x(i, j, you) = min{x(i + 1, j, me), x(i, j + 1, me)} <img src="/assets/mit6.006总和笔记/image-20231027200227456.png" /> <strong>时间</strong> • subproblems: ⇥(n2) • work per subproblem: ⇥(1) • ⇥(n2) running time 扩展子问题可以提供递归所需信息,但代价是子问题数目增加,计算复杂度上升。需要权衡取舍。</p>
<h3 id="rod-cutting">Rod Cutting</h3>
<p>切一根棍子，切割长度产生的收益如表</p>
<table>
<thead>
<tr class="header">
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>0</td>
<td>1</td>
<td>10</td>
<td>13</td>
<td>18</td>
<td>20</td>
<td>31</td>
<td>32</td>
</tr>
</tbody>
</table>
<p>x(l): maximum value obtainable by cutting rod of length x(l) = max{v(p) + x(l-p) | p 2 {1, . . . ,l }} time: - subproblems: L + 1 - work per subproblem: O(l) = O(L) - O(L^2) running time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># recursive</span></span><br><span class="line">x = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">l, v</span>):</span><br><span class="line"> <span class="keyword">if</span> l &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># base case</span></span><br><span class="line"> <span class="keyword">if</span> l <span class="keyword">not</span> <span class="keyword">in</span> x: <span class="comment"># check memo</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + cut_rod(l - piece, v) <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> (l <span class="keyword">not</span> <span class="keyword">in</span> x) <span class="keyword">or</span> (x[l] &lt; x_): <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line"> <span class="keyword">return</span> x[l]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterative</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">L, v</span>):</span><br><span class="line"> x = [<span class="number">0</span>] * (L + <span class="number">1</span>) <span class="comment"># base case</span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>): <span class="comment"># topological order</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + x[l - piece] <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> x[l] &lt; x_: <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line"> <span class="keyword">return</span> x[L]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iterative with parent pointers</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod_pieces</span>(<span class="params">L, v</span>):</span><br><span class="line"> x = [<span class="number">0</span>] * (L + <span class="number">1</span>) <span class="comment"># base case</span></span><br><span class="line"> parent = [<span class="literal">None</span>] * (L + <span class="number">1</span>) <span class="comment"># parent pointers</span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>): <span class="comment"># topological order</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + x[l - piece] <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> x[l] &lt; x_: <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line">    parent[l] = l - piece <span class="comment"># update parent</span></span><br><span class="line"> l, pieces = L, []</span><br><span class="line"> <span class="keyword">while</span> parent[l] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># walk back through parents</span></span><br><span class="line">  piece = l - parent[l]</span><br><span class="line">  pieces.append(piece)</span><br><span class="line">  l = parent[l]</span><br><span class="line"> <span class="keyword">return</span> piece</span><br></pre></td></tr></table></figure>
<h3 id="subset-sum">Subset Sum</h3>
<p><a href="https://www.jianshu.com/p/0322014dc357?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes">相关博客</a> A = {a0, a1, . . . , an} 是否存在A的子集A'，A'的元素总和为T x(i, j): True if can make sum j using items 1 to i, False otherwis <span class="math display">\[
x(i,j) =
\begin{cases}
   x(i - 1, j - A[i]), &amp; \text{if j &gt;= A[i] } \\
   x(i - 1, j), &amp; always
\end{cases}
\]</span> - x(i, 0) = True for i ∈ {0, . . . , n} (trivial to make zero sum!) - x(0, j) = False for j ∈ {1, . . . , T} (impossible to make positive sum from empty set - for i ∈ {0, . . . , n}, j ∈ {0, . . . , T}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp_subset</span>(<span class="params">arr,S</span>):</span><br><span class="line">    </span><br><span class="line">    subset = np.zeros((<span class="built_in">len</span>(arr),S+<span class="number">1</span>),dtype=<span class="built_in">bool</span>) <span class="comment">#构造二维数组</span></span><br><span class="line">    subset[:,<span class="number">0</span>] = <span class="literal">True</span> <span class="comment"># 第一列 设为True</span></span><br><span class="line">    subset[<span class="number">0</span>,: ] = <span class="literal">False</span> <span class="comment">#第一列 设为 False</span></span><br><span class="line">    subset[<span class="number">0</span>,arr[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, S+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; s:</span><br><span class="line">                subset[i , s] = subset[i-<span class="number">1</span> , s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = subset[i-<span class="number">1</span> , s ]</span><br><span class="line">                B = subset[i-<span class="number">1</span> , s - arr[i]]</span><br><span class="line">                subset[i,s] = A <span class="keyword">or</span> B</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    row ,cell = subset.shape</span><br><span class="line">    <span class="keyword">return</span> subset[row-<span class="number">1</span>,cell-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">arr  = [<span class="number">1</span>,<span class="number">2</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]            </span><br><span class="line">dp_subset(arr,<span class="number">7</span>) </span><br><span class="line">out:<span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><img src="/assets/mit6.006总和笔记/image-20231028110550677.png" /></p>
<p>subproblems: O(nT ), O(1) work per subproblem, O(nT ) time</p>
<h1 id="其他">其他</h1>
<h2 id="多项式时间的判定">多项式时间的判定</h2>
<p>只有在算法时间复杂度仅与问题规模有多项式关系时，才可称为多项式时间复杂度算法。 存在如基数排序之类时间复杂度依赖于输入数据的算法，称为伪多项式时间复杂度，此时算法的时间复杂度是输入数据大小的多项式时间表达，但却是输入数据长度（输入规模）的指数时间表达</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">冒泡排序：给定 n 个64位的数字，进行 n-1 次扫描交换，将数字从小到大排序。</span><br><span class="line">素数测试：给定数字 n，通过从 2 到根号 n 的整数遍历，判断 n 是否为素数。</span><br><span class="line">字面上看，两者复杂度都是 O(n^k) ( k 为整数) 。但区别在于，前者的 n 是数字个数的多少，后者的 n 是数字的大小。</span><br><span class="line">因此，前者输入总规模 s1 增长与数字大小无关，s1 = 64n；后者增长规模与数字大小紧密相关，输入总规模为 s2 = logn 。</span><br><span class="line">所以可知冒泡排序中复杂度 O(n^2) = O(s1^2/64^2) 为多项式算法，后者素数测试O(n) = O(2^(s2)) 为伪多项式算法</span><br></pre></td></tr></table></figure>
<h2 id="复杂度">复杂度</h2>
<ul>
<li>决策问题:将输入归类为YES或NO的问题。</li>
<li>算法/程序:能够在一定时间内解决问题的常量长度代码。</li>
<li>如果问题有算法可以在有限时间内解决,则该问题是可判定的。</li>
<li>程序是有限的,问题是无限的,因此大多数决策问题是不可判定的。</li>
<li>即使可判定,也以不同的时间复杂度分类:</li>
</ul>
<ol type="1">
<li>R类:有限时间可判定</li>
<li>EXP类:指数时间可判定</li>
<li>P类:多项式时间可判定(我们关注的)</li>
</ol>
<ul>
<li>这些类满足 P⊆EXP⊆R 的包含关系。 NP与P问题参考<a href="https://thinklive1.github.io/2023/10/06/61b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/">61b笔记</a></li>
</ul>
<p>mit的后续课程 <img src="/assets/mit6.006总和笔记/image-20231027201108930.png" /> <img src="/assets/mit6.006总和笔记/image-20231027201117355.png" /></p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据结构与算法</tag>
        <tag>麻省理工</tag>
      </tags>
  </entry>
  <entry>
    <title>爱丽丝的回忆</title>
    <url>/thinklive/40355/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励" data-whm="縺ｫ縺ｯ繧｢繝ｪ繧ｹ縺励">
  <script id="hbeData" type="hbeData" data-hmacdigest="24f9310fabe519f2ef1fc607999275d5c3362bd67eed8264a350e82ac6de5c38">13aef8e3a4d2474cb9cd233c644c735c7ce62820bf86f805363ad09d940c013f15e271153cdb8f8975b916cf9d1be65d1dfd56bed1f75e0cce9bc945d854b7df8b1c35b68bed377064d0601e6bfe625ae7d8cd2d3736700c00508d2a6a645e1fe125eef8e2f3bb6e5e8dd040b3807272144439ea1b98d0662ba7d17b1d51b57b45bc4137781e59a0b0a63914ea0d85fc7833fc370356cf12132dc520ace76a00a3708e886451d4cf00eddb280dc9aec3b0387f05c42217a6a20147657c6c490310d479384dfc83571b3c46d5c54ca1cd6a00f36b4696ad48a35d03b23bebbd04c64087855bdc7744308770d82e7cd5edb9de0b92eb25bce1a53f4df417ec79d3c8310a88a04574986dcb2484596d5cd0fc89d22dfc95bd5a5add453edd098362f7ef79b135fe0d1b6bd38ab6a21a97c164f7113dce2e86146681550f7897d39779664588967f71287a755297d00061e098572eafcc3305825b27a83a959f71231d8d50268e3a4ba19f418ae502f72553b06af133618a0df82afecbb08f7f9330c84ed3701266cf82bb4fe298b6fb1f1014b4b72b4c9a8562c108eaa8524ad87daab1d90435b2530f5457a881ccac1177e2492f1481c13f400b89544d1fcdb077da7870d89112cd0c7ada9893a0d111e0a84c7b0710ac269a6410556d1ed0c4fe7cb73d2d948df72adad33d70eb1fcb11df29db5a7d31a604181586212f1deb4524761fa3f2da7a8b9a988088b20de28cdceb1759247f421ea5a190910eb1e4208f03fcc01a55ff418a24a7b3c716bb752e1f04ba63766309dd7c56be1bd3c483f49b643d3285c017292fabef71a394f2883add4d8cfeadb05b0fe164eeb3c13242b397162a0f75e142d79f2169e199bb48f8f018789ca402b8c513b395b9f96ce8da364b792a9d68e22ad09b245b564547f1bacf3bf09f6e7a5fcfff9ef9534a9d6b283a65e9ee1689ffe8a528c48f4154f5ade68f755dae38be49c96889ec92712ec3967dfa9e3c03bf838ecbba5f696863b4331e1c3a8b3b527909eb65814292b0a14d7d39ab880524800beb88d573abbd380c644c3d537c0d30a621b2f2ed7199a507b2063d11abf4bb2102644321d8b446df028990b961f66d5056f5a56126c3a9a0986ef86f0475103e696a2444a65c7472409150c610dc82c90db2d5e55706f9236e37a8241b01233b7ff6caad0e44e6581497927676df920f468c83046e53cc402b14d8f53067955f8e3a1aa03996fa4cfb05136669439b388f988d91b37c77e1f1d45df960bf533c49d6afb9775e769039a649fe4c74ddc7089c04fc4a390fb690548585e3c8c23275fbc898b4c5b76b6d94cfd59d34d7a3fa83622e285f93fe5f3580b9becf16be588db16c6718a800a7d2873886f7f7b5efeabbde77a8595afdb9967e490376d3855be3fead1aeef75510179f131e3c3ba05f64ed43bf8a3488ccb59211d5815ab80fd75fa42ab8b49e7fe817222926c50c24706e40a98f49af88489b61c7eff618f94a10263ab98aefa3657f2f4a3d88d046dbfff536b5fea6371bf6938f8ed2e0c9ad00a0805761c36794579a92088a5b39d2bc08425a75f06840e4589772fa1877c6b834658735ce0ad02ea83662b189ba5157449b867d3fb77d97ce16ba7a392798b90b7711353d8037c5d0b76844fae99c476b145c90f4e77319cdc1788455777890c68ce930779f02602169f067e1f370586cb783a9bb5664dafec9c2d84cb8a3e817a07689bc2d4c25cb4718fb72e0858d85419bafac9bc8324681d299ad4ff9c80bd3be62eb163ca386bee0de34c6d1bca7761c8a4ed367ea4d775521c38243a7bcdc8c0775ecc217656aeebc79e0fa6d03fb268af6cc8d2b503b841f28f4389fa86f3b641650da6f3b85a6cb0c0976a99d920557527e1d2fbdbc5aeb75149a6130ade4672215792efbfcdd411524ceaa5a8ce3726315968110300c573d5802f2e31d8957fca161db2d06fbfeaf80636fd7414ad61e5f5fb3011ca214215b65c791e330fdb7b2e02f3b8841a2984d2b7206bb73bd807edae367e9ef141ed4bc9ee294c822fed8a0a43e11a6343d0bed4411ea989b2b4071ada6dd443dd18f7147e979725a231372ed4cd5e1ab064e3ece688a3d9943c07ac3524c24e84927627edc93125e20cac1c3f407e495f93710b03dbc1249b465db4d7103baba381bd02714afcbb79a30b1f60e252fba9d7a974027e970a7d605f3fbabb713c5a62183e15b8b937229173826ba27d4fcd42daf7e8e86671368281a9ddcb40356aba4109a2e910fe56204164f4c7b8e17cfea1f27bc4f3f20fc3cf8efd4e51293770d4ddd55e17c66386e770ff3eb651d0efccd809f03c6ca416f421516e58fd793d29df68096978412469186ae48d3b0c8d0c5ff38dca519c1a18c388e71411ca4c412a4a20c3bfa6227e0792d5cb87b2bb44bf0d30961a6b6fe5c9f6431844379739f0a0e08e0463e9929ea8a24860145d5587000b889fa64603d109ab0da62c027894f90aeaa0e31079c9e0124a78770e71fd20361c20db37f09f13dc7ba7584b2546734bbf7b997c7ae020f37507e99016639fa1b3583423a43edb1b78e52fa6ccea01d9a20c272e340059507096e18524ae01e2c420bce2db312d0631b62f45b00926dc5bd9b2524406d2f1319c13fa8d89519ee2244da16cf7269fa518f3bf6cb43162edbcd286f4b783631a4fcbccc76c9efc610854df49f8aed1e93040817395e3e34ec2d61c70b4a4b68ac2f40d1e7bc23024dc2900565d52fefbb24dcf3e5afa577a85dd6de3a06cc9d223994bc9679823a9f1b00958e72761fc56c5f4a8e3b41c8235de052bdd03152020755db863946488ed839ada092bd2f25f1718fda411d6d84b0dc9ba5f68c94475ff3799847612213d475b44a555052db688ef9d0a6cffd187e60097ecf55b827c6d707c7a53c7d492c773ad89112ced5522ce9d5c2b85eb00d9aec38c539b85b5cde32638b4033984a95d1236145bcc5d7d7558d5d52a5bb047c2771ef52a503dc9d572ad606671679e77d0b83a7072c9ade8f4a79b8798d2f5a0730b2eada92f4cc3ca5669f7b96713185aa6941dcc875a9699d6e5ffdafca8619f489ad4a5faa1b7ec076a6b2be6f83e6d63275b4014d99a6b25b816c32f91d76547c3eed9605dde738e694efa7a3483d6c733570de95ee58f335f6a67b547dc28450feccf26188e5c267a807db1bba849f805d83c7ab96aaa62f639e0170cc264323d081b0974756f19fe10a99a813cc24b0d2a5d861387cb0a47904ad6d96354508cbf5219147de6f738c56da8c770282e1b8c17fa9c221412c483f5ba8d7c09aeb9467c90d20bc6c766e0ea4069134f813b9c2d770c41e84fbe3a5e6fef37ac41ef6300eee4832347eddebb5e16148d19a132a1e6f7ae006fff253591c0e1274344e7bd7dbc690f98c08c15f7cac61b4a92205db274a6a64fcdfded7ef5c0fb30251e7896b1a210dcda6e44278194b1626d725ffd86a4be7350b2a5202cffe2446b17d65a285a203953ad61ce0f2335b5a2c8563e49e02849630ff3b66f5c50c5128b9a1708bdd54d7dc90613b6dddcc4b3594687aa858d5ce67d83c6bc10c2bec6da98c197e794b518fdeeba4a968673ebb8e6eb380711d05e37bb4abffbaa0d264983bdf308aea11a6be3477884ce3e04dec2d54f2730e7257804881b41a6ead6a252c34354536726324257497239455c877f4dfe075121f811fa4b4d540b68d0e7dc5479ae1f29b317333dc0c157d24b480a515e06ecfe4c9734ebcf480dd36b3a8b258ab514d3045183773d8e145406e1cb5f5ad22a36a286f6c1cb645a0b20506911d2e3d08ed2fdaf75c1becfad60b64831cbe68eefd80b22adac1e8286f7ee0b5e3d798571d5b4aadffec67a02b2b154640a034343ee12b5ec777f812fa7a1dc9aaa9b9a5d7d5731bb2315b408f671c531c4feee4b6e5b23a0217cbd56dcc689f902366187c3827b0435aa4678eabca5b24c4f7947678bed992729f557db56ce622e23e534b71e1f7df9273a2c8fc76a87f09116df09b59885192e9aba7ff1f1368748e6bcfcf8fa1d14e47cf075a531a8733e6c93b3f883c398eecabecd6fc366f0c94c206781945a3ae4d8a786f0ad9c97d01ddec215a0e9700e63174251f799578524cb28feb30f6bd306d6242cd028f5e3b911940e2de157482f745abf54e6929df7878</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-wave">
      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">摇曳着苦闷光辉的火焰在跳动着……心爱的少女，她诞生的时日是？</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>秘密</category>
      </categories>
      <tags>
        <tag>秘密</tag>
      </tags>
  </entry>
  <entry>
    <title>基于中科大linux101和苏大ppt的linux笔记</title>
    <url>/thinklive/59610/</url>
    <content><![CDATA[<h1 id="苏大部分">苏大部分</h1>
<h2 id="概念">概念</h2>
<p>软件可以粗略分为系统，工具，应用<br />
软件的发行模式有：</p>
<ul>
<li>商业软件</li>
<li>共享软件,免费给用户使用的商业软件，比如入门版杀毒软件，不一定开源</li>
<li>开源软件，开放源代码的软件，但不代表用户有自由分发修改源代码的权力</li>
<li>自由软件，开源，任何用户都有权使用、拷贝、扩散、修改该软件，但有义务公布修改后的代码 <img src="/assets/resources/Pasted%20image%2020231227114417.png" /></li>
</ul>
<p>Linux系统提供多个虚拟控制台（默认6个字符界面，1个图形界面），可以独立使用，自由切换</p>
<span id="more"></span>
<h2 id="文件">文件</h2>
<h3 id="命名">命名</h3>
<ul>
<li>除/之外，所有的字符都合法</li>
<li>大小写敏感</li>
<li>有些字符最好不用，如空格符、制表符、退格符和字符：？, @ # $ &amp; ()  | ; ‘ ’ “ ” &lt; &gt;</li>
<li>避免使用＋、－或. 来作为普通文件名的第一个字符</li>
<li>可以使用长文件名或目录名（255个字符）</li>
<li>包括完整路径的文件名不超过4096字符</li>
</ul>
<p>主要的文件类型</p>
<ul>
<li>普通文件
<ul>
<li>文本</li>
<li>二进制</li>
<li>数据格式</li>
</ul></li>
<li>目录(同一个文件夹下不可能同时存在相同名称的文件和文件夹)</li>
<li>符号链接</li>
<li>字符设备文件,键盘、鼠标等串行接口设备</li>
<li>块设备文件,存储数据的设备，如硬盘、软盘等</li>
<li>套接字,socket文件，用于网络数据连接。</li>
<li>命名管道，用于进程间通信，解决多个程序同时访问一个文件造成的错误</li>
</ul>
<h3 id="目录">目录</h3>
<table>
<thead>
<tr class="header">
<th><br><br></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bin</td>
<td>存放二进制的可执行程序</td>
</tr>
<tr class="even">
<td>boot</td>
<td>存放用于系统引导时使用的各种文件</td>
</tr>
<tr class="odd">
<td>dev</td>
<td>存放设备文件，用户通过这些文件访问外部设备</td>
</tr>
<tr class="even">
<td>etc</td>
<td>存放系统的配置文件</td>
</tr>
<tr class="odd">
<td>home</td>
<td>存放用户文件的目录，每个用户在该目录下有一个与该用户名对应的子目录</td>
</tr>
<tr class="even">
<td>root</td>
<td>超级用户目录</td>
</tr>
<tr class="odd">
<td>sbin</td>
<td>类似于/bin目录，存放二进制文件，只有root才能访问</td>
</tr>
<tr class="even">
<td>tmp</td>
<td>用于放置各种临时文件</td>
</tr>
<tr class="odd">
<td>var</td>
<td>用于存放需要随时改变的文件，如系统日志、脱机工作目录等</td>
</tr>
<tr class="even">
<td>mnt</td>
<td>系统管理员安装临时文件系统的安装点</td>
</tr>
<tr class="odd">
<td>opt</td>
<td>一般情况下，该目录不属于系统的基本文件系统，是额外安装的应用程序包所放置的地方</td>
</tr>
<tr class="even">
<td>usr</td>
<td>用于存放系统应用程序</td>
</tr>
<tr class="odd">
<td>lib</td>
<td>存放根文件系统中的程序运行所需要的共享库及内核模块</td>
</tr>
<tr class="even">
<td>proc</td>
<td>是一个虚拟文件系统，存放当前内存的映射，主要用于在不重启机器的情况下管理内核</td>
</tr>
<tr class="odd">
<td>lost+ found</td>
<td>存放一些系统检查结果，发现不合法的文件或数据都存放在这里，通常此目录是空的，除非硬盘遭到损坏</td>
</tr>
</tbody>
</table>
<h3 id="链接文件">链接文件</h3>
<ul>
<li><p>硬链接 将两个文件名指向硬盘上同一个存储空间（inode），对任何一个文件的修改都将影响到另一个文件。<br />
特性：</p>
<ul>
<li>文件有相同的 inode 及 data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统进行硬链接的创建；</li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
</ul></li>
<li><p>符号链接</p></li>
</ul>
<p>又称软链接，是指将一个文件指向另外一个文件的文件名。<br />
特性：</p>
<ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>软链接可对文件或目录创建；</li>
<li>可对不存在的文件或目录创建软链接；</li>
<li>软链接可交叉文件系统；</li>
<li>若被指向的原文件被删除，则相关软连接被称为死链接</li>
<li>删除软链接并不影响被指向的文件，若被指向路径文件被重新创建，死链接可恢复为正常的软链接</li>
</ul>
<p><strong>符号链接可以跨文件系统，即可以跨磁盘分区。硬链接不可以跨文件系统。它只能建立对文件的链接。</strong><br />
链接文件命令  <code>ln</code></p>
<table>
<tbody>
<tr class="odd">
<td>ln file1 file2</td>
<td>创建源文件file1的硬链接file2</td>
</tr>
<tr class="even">
<td>ln -s file1 file2</td>
<td>创建源文件file1的软链接file2</td>
</tr>
</tbody>
</table>
<p>符号链接可以跨文件系统，即可以跨磁盘分区。<br />
硬链接不可以跨文件系统，只能建立对文件的链接。<br />
硬链接删除只原文件或硬链接不影响文件内容<br />
软连接删除源文件导致链接失效</p>
<p><img src="/assets/resources/Pasted%20image%2020231227153516.png" /></p>
<h3 id="通配符">通配符</h3>
<table>
<thead>
<tr class="header">
<th><code>*</code></th>
<th>任意长度字符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>?</code></td>
<td>任意单个字符</td>
</tr>
<tr class="even">
<td><code>[…]</code></td>
<td>匹配任何包含在括号内的单个字符，可以是范围（-）<br>或多个字符</td>
</tr>
<tr class="odd">
<td><code>!</code>/<code>^</code></td>
<td>匹配任何不包含在[]括号内的字符</td>
</tr>
<tr class="even">
<td><code>&#123;…&#125;</code></td>
<td>匹配任何包含在括号内的模式，模式间用,隔开<br>支持遍历查询、创建、删除、修改文件</td>
</tr>
</tbody>
</table>
<p><code>ls [!abc]*</code>//首字符不是a或b或c的所有文件<br />
<code>ls a&#123;0,1&#125;&#123;ab,ba&#125;</code>//列出当前目录下符合a0ab、a0ba、a1ab、a1ba名称的文件<br />
<code>ls [a-zA-Z]*</code></p>
<h3 id="一些命令">一些命令</h3>
<p><code>find .</code> 查找当前目录下所有文件和文件夹<br />
<code>find . -name ‘my*’</code>查找当前目录下所有my开头的文件和文件夹<br />
<code>find . -type f -name my*</code>在当前目录下查找以my开头的普通文件<br />
<code>find . -size +25k</code>在当前目录下查找大于25k的文件</p>
<p><code>scp /home/user/a.txt user1@192.168.1.2:/home/user1</code> 复制a.txt到远程设备user的主目录下<br />
<code>rm -ri usr/</code> 删除usr目录及其内容,删除时有提示<br />
<code>rm -d usr/</code> 删除usr目录,usr是一个空目录<br />
查找系统文件所在路径命令 <code>whereis</code></p>
<p>more 只能向下翻页，<br />
less可以上下翻页,可以通过输入/pattern方式查找匹配<br />
tac mylist 从后往前显示mylist的内容<br />
统计文本文件的行数,字数,字符数 wc//l行,w单词,c字节数,m字符数</p>
<p><code>tar [-cxtzZjvC] [-f 文档名称] 文件与目录</code><br />
c:压缩，x:解压,t:查看 三选一<br />
zZj是压缩算法，z的后缀是gz最常用<br />
f后接文件名，v表示过程中打印信息，C接目录<br />
<code>tar -zxvf myusr.tar.gz -C /home/CentOS/a</code> 解压到指定目录/home/CentOS/a<br />
<code>tar -zcvf myusr.tar.gz mydoc</code> 用gzip将mydoc目录打包后压缩</p>
<p>显示文件使用磁盘空间量 du<br />
显示文件系统磁盘空间的使用情况 df ,-h容易阅读的形式</p>
<p>显示和编辑历史命令 history<br />
记录历史命令的数目:HISTSIZE<br />
记录历史命令的文本文件:HISTFILE<br />
默认的记录文件:.bash_history<br />
<code>alias [别名]='[命令]'</code><br />
<code>unalias [-a] 别名</code></p>
<h2 id="文件系统">文件系统</h2>
<p><img src="/assets/resources/Pasted%20image%2020231227155809.png" /> <code>硬盘容量=柱面数（磁道数）*磁头数（盘片数）*扇区数*512B</code><br />
<code>总扇区=磁道数*磁头数*扇区数</code><br />
<code>总磁道=磁道数*磁头数</code></p>
<h3 id="硬盘分区表">硬盘分区表</h3>
<h4 id="mbr">MBR</h4>
<p>硬盘的第一个扇区存有主引导记录(Master boot record, MBR)及分区表(partition table)</p>
<ul>
<li>MBR用于引导操作系统</li>
<li>partition table用于记录分区信息 一个MBR分区表类型的硬盘最多存在4个主分区，每个分区项占用16个字节<br />
如果分区超过4个，则需要使用扩展分区，即一个物理硬盘上最多有3个主分区和1个扩展分区。<br />
扩展分区不能直接使用，必须分割成为逻辑分区，一个扩展分区中的逻辑分区可以任意多个。</li>
</ul>
<h4 id="gpt">GPT</h4>
<p>全称全局唯一标识分区表 GUID Partition Table</p>
<ul>
<li>主分区数量任意（Win 128个）</li>
<li>支持最大18EB（NTFS 256TB） 1EB=1024PB<br />
可能需要EFI支持（Win、Mac）</li>
</ul>
<h3 id="linux文件系统">linux文件系统</h3>
<p>磁盘分区完毕后还需要进行格式化(format)，不同操作系统默认的文件系统不同，所以需要格式化成不同格式的分区。<br />
EXT2（second extended filesystem）是LINUX内核默认的文件系统。<br />
EXT2中的主要构成：</p>
<ul>
<li>SuperBlock  记录文件系统的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；</li>
<li>Block   实际记录文件的内容，若文件较大，则占用多个 block。</li>
<li>Inode   记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码</li>
</ul>
<h4 id="inode">inode</h4>
<p>ext2 创建一个目录时，分配1个 inode 与至少1块 block 给目录<br />
•inode 记录目录权限与属性，并记录分配到 block号码<br />
•block 记录目录下文件名与该文件名占用的 inode</p>
<p>在读取时会先找到inode，定位到相应block，如果还有子文件就继续定位其inode，这样递归下去<br />
inode 数量与大小在格式化时固定，记录存取模式，拥有者和组，容量，block的地址，修改创建时间等<br />
inode包括：</p>
<ul>
<li>12个直接block号码记录区</li>
<li>1个间接block号码记录区</li>
<li>1个双间接block号码记录区</li>
<li>1个三间接block号码记录区</li>
</ul>
<p>特征：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes；</li>
<li>每个文件仅占用一个 inode；</li>
<li>文件系统能够创建的文件数量与 inode 的数量有关；</li>
<li>系统读取文件时先找到 inode，分析 inode 所记录的权限与用户是否符合，若符合读取 block 的内容。</li>
</ul>
<p><img src="/assets/苏大linux_ppt/image-20231014145226727.png" /> 默认一个block为 4KB大小</p>
<ul>
<li>12个直接连接可以记录<code>12*4=48KB内容</code></li>
<li>1个间接连接可以记录<code>1024*4=4096KB内容</code></li>
</ul>
<h4 id="升级">升级</h4>
<p><code>EXT2</code>文件系统高效稳定，但不提供日志<br />
<code>EXT3</code><br />
提供日志模式：<br />
data=journal模式<br />
对所有的文件数据及metadata（定义文件系统中数据的数据,即数据的数据）进行日志记录<br />
data=ordered或data=writeback模式<br />
只对metadata记录日志，而不对数据进行日志记录</p>
<p><code>EXT4</code><br />
EXT3的扩展升级，可以提供更佳的性能和可靠性，包括支持更大的分区和文件大小，更快的文件操作速度。</p>
<ul>
<li>EXT2文件系统高效稳定、安全性高</li>
<li>FAT文件系统磁盘利用率高，性能一般</li>
</ul>
<h3 id="实例">实例</h3>
<h4 id="fdisk">fdisk</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           fdisk      [-options]     &lt;disk&gt;</span><br><span class="line">选项：</span><br><span class="line">l 列出分区信息表</span><br><span class="line">m 查看本选项列表</span><br><span class="line">d 删除一个分区（partition）</span><br><span class="line">n 新增一个分区（partition）</span><br><span class="line">g 新建GPT分区表</span><br><span class="line">p 在屏幕上显示磁盘分割表</span><br><span class="line">q 不保存操作并退出fdisk程序</span><br><span class="line">t 切换分区类型（8e为Linux LVM）</span><br><span class="line">w 保存分区操作并退出fdisk</span><br><span class="line">o 新建DOS分区</span><br><span class="line">/dev/sda    对sda磁盘进行分区</span><br></pre></td></tr></table></figure>
<p>中科大的xubuntu镜像<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ustc@ustclug-linux101:~/桌面$ sudo fdisk -l</span><br><span class="line">[sudo] ustc 的密码： </span><br><span class="line">Disk /dev/sda：5 GiB，5368709120 字节，10485760 个扇区</span><br><span class="line">Disk model: VMware Virtual S</span><br><span class="line">单元：扇区 / 1 * 512 = 512 字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：gpt</span><br><span class="line">磁盘标识符：12526913-E330-4CA7-A379-90A87EF858B0</span><br><span class="line"></span><br><span class="line">设备         起点     末尾    扇区  大小 类型</span><br><span class="line">/dev/sda1    2048   499711  497664  243M EFI 系统</span><br><span class="line">/dev/sda2  499712 10483711 9984000  4.8G Linux 文件系统</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="mkfs格式化">mkfs格式化</h4>
<p><code>mkfs      [-t 磁盘格式名]     &lt;partition&gt;</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs  -t ext3  /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<h4 id="mount挂载">mount挂载</h4>
<p>文件系统在访问时，必定需要一个访问地址，也就是要能够链接到目录树才能被使用。<br />
将文件系统与目录树结合的动作称为『挂载』 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [-t vfstype] [-o options]    device    <span class="built_in">dir</span></span><br><span class="line">-t 指定文件系统的类型,通常不必指定</span><br><span class="line">mount                         显示所有挂载的信息</span><br><span class="line">mount –a                   将所有未挂载设备挂载</span><br><span class="line">mount   /dev/hda2   /mnt/myhd2    将hda2设备挂载到/mnt/myhd2</span><br><span class="line">mount -t iso9660 /dev/cdrom  /media/cdrom  挂载光驱</span><br><span class="line"></span><br><span class="line">umount [选项] <span class="built_in">dir</span></span><br><span class="line">选项：</span><br><span class="line">-f     强制卸载</span><br><span class="line">-all   卸载所有挂载</span><br><span class="line">例：</span><br><span class="line">umount  /media/cdrom     卸载刚才挂载的光驱</span><br></pre></td></tr></table></figure></p>
<h2 id="shell">shell</h2>
<p>Shell是系统的用户界面，提供了用户和操作系统内核进行交互操作的接口，位于应用与内核之间<br />
shell命令可以分为内部和外部，内部可以直接执行，外部则需要查找<br />
格式为<code>cmd [-options] [arguments]</code><br />
普通用户提示符是$,超级用户是#<br />
常用命令：ls,clear,type(查询命令类型)<br />
关机与重新启动本质是切换运行级别，6是重启，1是关机<br />
init 6|init 0<br />
reboot| halt<br />
shutdown -r +5|shutdown -h +5<br />
帮助程序有:help,man,iinfo,whatis(man -f)</p>
<h3 id="重定向">重定向</h3>
<p>Linux启动后，默认打开3个文件描述符<br />
•标准输入：standard input   0<br />
•标准输出：standard output  1<br />
•错误输出：error output     2<br />
每条shell命令执行，都会继承父进程的文件描述符。因此，所有运行的shell命令，都会有默认3个文件描述符。<br />
默认的标准输出端口和标准错误端口为控制台的屏幕,标准输入端口是控制台的键盘<br />
<code>重定向</code> 是指不使用系统的标准输入，标准输出或标准错误端口，而重新指定输入输出。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入重定向</span><br><span class="line">&lt;          输入重定向，从普通文件获取</span><br><span class="line">&lt;&lt;!...!    输入重定向， here文件，即从命令行获取</span><br><span class="line">wc &lt;&lt;!</span><br><span class="line">&gt;This text forms the content of heredocument</span><br><span class="line">&gt;which continues until the end of delimiter</span><br><span class="line">&gt;!</span><br><span class="line">输出重定向</span><br><span class="line">&gt;          输出重定向，覆盖模式</span><br><span class="line">&gt;&gt;         输出重定向，追加模式</span><br><span class="line">2&gt;         错误重定向，覆盖模式</span><br><span class="line">2&gt;&gt;        错误重定向，追加模式</span><br><span class="line">&amp;&gt;         同时实现输出重定向和错误重定向，覆盖模式</span><br><span class="line">&amp;&gt;&gt;        同时实现输出重定向和错误重定向，追加模式</span><br></pre></td></tr></table></figure></p>
<h3 id="管道">管道</h3>
<p>管道是一种两个进程间进行单向通信的机制<br />
每个命令的输出作为下一条命令的输入，管道线中的命令从左到右顺序执行的，管道线是单向的<br />
因为管道传递数据的单向性，管道又称为半双工管道<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls –l | wc -l</span><br></pre></td></tr></table></figure></p>
<h3 id="命令替换">命令替换</h3>
<p>Shell中的命令参数可以由另一个命令执行的结果来替代</p>
<p>命令格式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cmd1 `cmd2  arguments`</span><br><span class="line">或</span><br><span class="line">$cmd1 $(cmd2 arguments)//$()形式可嵌套命令替换</span><br></pre></td></tr></table></figure> 其中cmd2  arguments的输出作为cmd1的参数y</p>
<h3 id="命令聚合">命令聚合</h3>
<p>在一个命令行上使用若干shell元字符将若干命令聚合在一起运行。</p>
<p>执行聚合的几种方式：</p>
<p>•<code>cmd1;cmd2</code>   顺序执行若干命令<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd;date;ls</span><br></pre></td></tr></table></figure></p>
<p>•<code>cmd1&amp;&amp;cmd2 </code> 当cmd1运行成功时才运行cmd2<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip mylargefile&amp;&amp;echo &quot;OK.&quot;</span><br></pre></td></tr></table></figure> •<code>cmd1||cmd2</code>   当cmd1运行失败时才运行cmd2<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip mylargefile||echo &quot;FALSE.&quot;</span><br></pre></td></tr></table></figure> •<code>(cmdlist)</code>   在子shell中执行命令序列，命令不影响当前shell<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(date;who|wc -l)&gt;~/login-users.log</span><br></pre></td></tr></table></figure></p>
<h2 id="文本编辑">文本编辑</h2>
<h3 id="vim">vim</h3>
<p><code>:n1,n2 s/old/new/g</code> g代表所有，不加则只替换一次<br />
<code>[Ctrl] + [f] | [Ctrl] + [b]</code> 屏幕『向前/后』移动一页<br />
r 取代(replace)光标所在的那一个字符；<br />
R 一直取代光标所在的文字，直到按下 ESC 为止；<br />
:set number 在编辑文件时显示行号<br />
:set nonumber 不显示行号<br />
:set ruler 在屏幕底部显示光标所在的行,列位置<br />
:set noruler 不显示光标所在的行,列位置</p>
<h3 id="grep">grep</h3>
<p>正则表达式是字符串的一种表达方式，用于字符串的处理，查找删除特定模式的字符串。<br />
语法详细见101部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] [-EFGP] &#x27;PATTERN&#x27; filename</span><br><span class="line">-a ：将 binary 文件以 text 文件的方式搜寻数据</span><br><span class="line">-c ：计算找到 &#x27;搜寻字符串&#x27; 的次数</span><br><span class="line">-i ：忽略大小写的不同，所以大小写视为相同</span><br><span class="line">-n ：顺便输出行号</span><br><span class="line">-v ：反向选择</span><br><span class="line">--color=auto ：可以将找到的关键词部分加上颜色的显示</span><br><span class="line">-E或--extended-regexp PATTERN 是一个可扩展的正则表达式(缩写为 ERE)</span><br><span class="line">-F或--fixed-strings PATTERN 是一组由断行符分隔的定长字符串，用</span><br><span class="line">于匹配多个表达式。</span><br><span class="line">-G或--basic-regexp PATTERN 是一个基本正则表达式(缩写为 BRE)</span><br><span class="line">-P或--perl-regexp PATTERN 是一个 Perl 正则表达式</span><br><span class="line">不选则默认为-G BRE</span><br></pre></td></tr></table></figure>
<h3 id="sed">sed</h3>
<p>sed是一个过滤模式的文本处理工具，可以对数据按行进行替换、删除、新增、选取等处理<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [-nri] [-e script] [-f scriptfile] filename</span><br><span class="line">-n 静默模式，即只有经过sed处理的那一行(或者动作)</span><br><span class="line">才输出。默认会输出所有内容。</span><br><span class="line">-e script 运行命令中的脚本</span><br><span class="line">-f &lt;文件名&gt; 运行文件内的脚本</span><br><span class="line">-r 使用扩展正规表达式(默认使用基本表达式)</span><br><span class="line">-i 直接修改文件，而不是输出到标准输出</span><br><span class="line">如果不选相当于预览修改效果</span><br><span class="line"></span><br><span class="line">[addr]X[options]</span><br><span class="line">addr 行地址</span><br><span class="line">X 表示sed支持的单字符操作命令,如果设定行地址</span><br><span class="line">则操作命令只对选择的行进行处理</span><br><span class="line">options 某些操作命令所需的额外选项</span><br><span class="line"></span><br><span class="line">n 指定命令对第n行进行动作</span><br><span class="line">n1,n2 指定命令对第n1行到第n2行进行动作</span><br><span class="line">$ 最后一行</span><br><span class="line"></span><br><span class="line">a ∶新增（append）， a 的后面可以接字串，而这些字串会在新的一行出现 （所选行的下一行）</span><br><span class="line">i ∶插入（insert）， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">c ∶取代， c 的后面可以接字串</span><br><span class="line">d ∶删除，通常命令后面不接任何东西；</span><br><span class="line">sed &#x27;1a Hi&#x27; file #第一行后新增Hi</span><br><span class="line">sed &#x27;a Hi&#x27; file #每行后新增Hi</span><br><span class="line">sed &#x27;1i Hi&#x27; file #第一行前新增Hi</span><br><span class="line">sed &#x27;1c Hi&#x27; file #第一行代替为Hi</span><br><span class="line">sed &#x27;1,20d&#x27; file #删除第1-20行</span><br><span class="line"></span><br><span class="line">s ：查找并替换</span><br><span class="line">s/regex/replacement/flags</span><br><span class="line">regex 正则表达式</span><br><span class="line">replacement 替换的内容</span><br><span class="line">flags 设置符号</span><br><span class="line">包括 g全局替换 p打印 =打印行号</span><br><span class="line">sed &#x27;s/old/new/’ file</span><br><span class="line">sed &#x27;s/old/new/g’ file</span><br><span class="line"></span><br><span class="line">\L 将后面的内容转为小写，直到遇到\U或\E结束</span><br><span class="line">\l 将后面的一个字符转为小写</span><br><span class="line">\U 将后面的内容转为大写，直到遇到\L或\E结束</span><br><span class="line">\u 将后面的一个字符转为大写</span><br><span class="line">\E 结束\L,\U的转换</span><br><span class="line">s/(.*)/\U\1/g # 将所有字符大写</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/123/1234/g&#x27; a.txt 将 a.txt 文件中所有行中的 123 用 1234 替换</span><br><span class="line">cat a.txt | sed &#x27;s/offcie/ofiice/g&#x27;</span><br><span class="line">cat telephone.data | sed &#x27;s/^[0-9]\&#123;3\&#125;/(&amp;)/&#x27; &gt; newTelephone.data</span><br></pre></td></tr></table></figure></p>
<h3 id="tr">tr</h3>
<p>tr是一个过滤模式的文本处理工具</p>
<ul>
<li>用于替换（translate）、压缩和删除标准输入中的 字符</li>
<li>使用字符集来描述替换、压缩和删除的字符</li>
<li>通过管道接收待处理文本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tr [-cdst] SET1 [SET2]</span><br><span class="line">set1 待匹配的字符集 [set2] 转换后的字符集</span><br><span class="line">-c 取代所有不属于第一字符集(SET1)的字符</span><br><span class="line">-d 删除所有属于第一字符集的字符</span><br><span class="line">-s 把连续重复的字符使用一个字符表示</span><br><span class="line">-t 先将SET1的长度截为和SET2相等（然后再匹配）</span><br><span class="line"></span><br><span class="line">字符1-字符2 从字符1 到字符2 的升序递增过程中经历的所有字符</span><br><span class="line">[字符*] 在SET2中适用，指定字符会被连续复制直到吻合设置1的长度</span><br><span class="line">[字符*次数] 对字符执行指定次数的复制，若次数以0开头则被视为八进制数</span><br><span class="line">[:alnum:] 所有的字母和数字</span><br><span class="line">[:alpha:] 所有的字母</span><br><span class="line">[:blank:] 所有呈水平排列的空白字符</span><br><span class="line">[:cntrl:] 所有的控制字符</span><br><span class="line">[:digit:] 所有的数字</span><br><span class="line">[:graph:] 所有的可打印字符，不包括空格</span><br><span class="line">[:lower:] 所有的小写字母</span><br><span class="line">[:print:] 所有的可打印字符，包括空格</span><br><span class="line">[:punct:] 所有的标点字符</span><br><span class="line">[:space:] 所有呈水平或垂直排列的空白字符</span><br><span class="line">[:upper:] 所有的大写字母</span><br><span class="line">[:xdigit:] 所有的十六进制数</span><br><span class="line">[=字符=] 所有和指定字符相等的字符</span><br><span class="line"></span><br><span class="line">\n 换行</span><br><span class="line">\r 回车</span><br><span class="line">\t 水平制表符</span><br><span class="line"></span><br><span class="line">echo &#x27; Hello &#x27; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;</span><br><span class="line">echo &#x27; Hello 123 World&#x27; | tr -d &#x27;0-9&#x27;</span><br><span class="line">echo &#x27; Hello 123 123 World&#x27; | tr -s &#x27;123&#x27; &#x27;a&#x27;</span><br><span class="line">echo &#x27;Hello 123 123 World&#x27; | tr -c &#x27;123&#x27; [?*] 将不等于字符串的部分，全部用另外一个字符重复替换</span><br><span class="line">??????123?123???????</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="awk">awk</h3>
<p>awk是一个强大的文本分析工具</p>
<ul>
<li>逐行读入文件，并假定输入的文本是一个结构化文本</li>
<li>每一行称为一个记录(Record)，每一列称为一个域(Field)</li>
<li>默认空格为分隔符进行行列切片，切开部分进行各种分析处理</li>
<li>支持样式装入、流控制、数学运算、进程控制语句，提供内置变量和函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk [-Ffv] &#x27; pattern&#123;action&#125;&#x27; &#123;filenames&#125;</span><br><span class="line">pattern 数据查找内容的模式，例如正则表达式，用斜杠括起来。</span><br><span class="line">action 是在找到匹配内容时所执行的一系列命令。action不是必须的，如果不写则默认打印模式匹配的结果</span><br><span class="line">-F fs fs指定输入分隔符，fs可以是字符串或正则表达式，</span><br><span class="line">如-F: -F, 默认是空格</span><br><span class="line">-v var=value 赋值一个用户定义变量，例如将外部变量传递给awk</span><br><span class="line">-f scripfile 从脚本文件中读取awk命令</span><br><span class="line"></span><br><span class="line">print 直接输出变量</span><br><span class="line">printf 和c语言一样的格式化输出</span><br><span class="line">awk &#x27;&#123;print $1,$2&#125;&#x27; 23dat.data</span><br><span class="line">awk &#x27;&#123;printf &quot;name:%s,age:%d\n&quot;,$1,$2&#125;&#x27; 23dat.data</span><br><span class="line">%c 字符型 %d 整数型</span><br><span class="line">%e 浮点科学计数法 %f 浮点</span><br><span class="line">%o 八进制 %x 十六进制</span><br><span class="line">%s 字符串</span><br><span class="line"></span><br><span class="line">内置变量</span><br><span class="line">FS 域的分隔符,默认的是以空白符分隔</span><br><span class="line">RS 记录的分隔符,默认是以换行符来分隔</span><br><span class="line">FILENAME 文件名</span><br><span class="line">NF 当前记录的域数（fields）</span><br><span class="line">NR 输入的记录数,相当于行号一样,多个文件时会接着递增.</span><br><span class="line">FNR 输入的当前记录数,每个文件单独计算</span><br><span class="line">$0 当前整个记录</span><br><span class="line">$n 当前记录和第n个域</span><br><span class="line"></span><br><span class="line">内置函数</span><br><span class="line">1、算数函数</span><br><span class="line">sqrt()、sin()、log()等</span><br><span class="line">2、字符串函数</span><br><span class="line">length [(String)]、tolower( String )等</span><br><span class="line">3、时间函数</span><br><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">tstamp=mktime(&quot;2001 01 01 12 12 12&quot;);print</span><br><span class="line">strftime(&quot;%c&quot;,tstamp);&#125;&#x27;</span><br><span class="line"></span><br><span class="line">awk &#x27;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#x27;</span><br><span class="line">BEGIN表示在awk开始从输入流中读取行之前被执行，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</span><br><span class="line">END表示在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果。这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</span><br><span class="line">pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行&#123; print &#125;，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</span><br><span class="line"></span><br><span class="line">if(表达式)</span><br><span class="line">&#123;语句1&#125;</span><br><span class="line">else if(表达式) &#123;语句2&#125;</span><br><span class="line">else &#123;语句3&#125;</span><br><span class="line"></span><br><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">	test=100;</span><br><span class="line">	if(test&gt;90)&#123;</span><br><span class="line">		print &quot;very good&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(test&gt;60)&#123;</span><br><span class="line">		print &quot;good&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		print &quot;no pass&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">结果：very good</span><br><span class="line"></span><br><span class="line">while(表达式)</span><br><span class="line">&#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">	test=100;</span><br><span class="line">	total=0;</span><br><span class="line">	i=0;</span><br><span class="line">	while(i&lt;=test)&#123;</span><br><span class="line">		total+=i;</span><br><span class="line">		i++; </span><br><span class="line">	&#125;</span><br><span class="line">	print i;</span><br><span class="line">	print total; </span><br><span class="line">&#125;&#x27;</span><br><span class="line">结果： 5050</span><br><span class="line"></span><br><span class="line">for(变量 in 数组) &#123;语句&#125;</span><br><span class="line">awk &#x27;BEGIN&#123;</span><br><span class="line">	total=0;</span><br><span class="line">	for(i=0;i&lt;=100;i++)&#123;</span><br><span class="line">		total+=i;</span><br><span class="line">	&#125;</span><br><span class="line">	print total;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">结果：5050</span><br></pre></td></tr></table></figure>
<h3 id="sort">sort</h3>
<p>sort是一个用于排序的文本处理工具</p>
<ul>
<li>以行为单位进行排序</li>
<li>以指定分隔符对内容进行分列</li>
<li>对指定列进行升序或降序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort [选项] [文件]</span><br><span class="line">• 常用排序选项</span><br><span class="line">-r 按降序排序（默认升序）</span><br><span class="line">-t &lt;分隔符&gt; 指定分隔符</span><br><span class="line">默认的分隔符为空白字符和非空白字符之间的空字符</span><br><span class="line">-n 依照数值排序（默认按字符）</span><br><span class="line">-f 忽略大小写</span><br><span class="line">-b 忽略每行开始的空格字符</span><br><span class="line">-d 只处理英文字母、数字及空格</span><br><span class="line">-i 忽略非打印字符</span><br><span class="line">-M 按照月份排序（与系统日期表示方式有关）</span><br><span class="line">• 其他常用选项</span><br><span class="line">-c 检查文本是否有序</span><br><span class="line">-k 根据某个键进行排序</span><br><span class="line">-o &lt;文件名&gt; 将结果保存到文件（默认输出到标准输出）</span><br><span class="line"></span><br><span class="line">sort file.txt 默认排序（按第一列升序）</span><br><span class="line">sort -c file.txt 检查是否有序</span><br><span class="line">sort -r file.txt 第一列降序排列</span><br><span class="line">sort -n -k 3 file.txt 第三列按数值升序排列</span><br><span class="line">sort -k 4M file.txt 第四列按月升序排列</span><br></pre></td></tr></table></figure>
<h2 id="用户系统">用户系统</h2>
<p>账户的实质上是一个用户在系统上的标识,系统依据账户来区分每个用户的文件、进程、任务</p>
<ul>
<li><p>普通用户账户：在系统上的任务是进行普通工作</p></li>
<li><p>超级用户账户：在系统上的任务是对普通用户和整个系统进行管理。</p></li>
<li><p>系统用户账户：伪用户，并不能登录，由操作系统自己操作。 每个用户都被分配了一个唯一的用户ID号（UID）</p></li>
<li><p>超级用户：UID=0，GID=0</p></li>
<li><p>普通用户：UID&gt;=500(有的系统是1000)</p></li>
<li><p>系统用户（伪用户，不可登录）：0&lt;UID&lt;500（有的系统是1000）</p></li>
</ul>
<p>用户名和 UID 被保存在 /etc/passwd 这个文件中</p>
<h3 id="组">组</h3>
<ul>
<li>组是用户的集合</li>
<li>每个组都被分配了一个唯一的组ID号（GID）</li>
<li>组和GID 被保存在 /etc/group 文件中</li>
<li>每个用户都有他们自己的私有组</li>
<li>每个用户都可以被添加到其他组中来获得额外的存取权限</li>
<li>组中的所有用户都可以共享属于该组的文件</li>
<li>当一个用户同属于多个组时，将这些组分为：
<ul>
<li>主组（初始组）：用户登录系统时的组</li>
<li>附加组：可切换的其他组</li>
</ul></li>
</ul>
<h3 id="权限管理">权限管理</h3>
<p>口令文件 /etc/passwd</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>password</th>
<th>uid</th>
<th>gid</th>
<th>description</th>
<th>home</th>
<th>shell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>用户名</td>
<td>在此文件中的口令是X,这表示用户的口令是被/etc/shadow文件保护的</td>
<td>用户的识别号,是一个数字。每个用户的UID都是唯一的</td>
<td>用户的组的识别号,也是一个数字。每个用户账户在建立好后都会有一个主组。主组相同的账户其GID相同。</td>
<td>用户的个人资料,包括地址、电话等信息</td>
<td>用户的主目录,通常在/home下,目录名和账户名相同</td>
<td>用户登录后启动的shell,默认是/bin/bash</td>
</tr>
</tbody>
</table>
<p>组账号文件 /etc/group<br />
被加密后的密码实际上储存在/etc/shadow中(包括修改密码时间，修改密码的最小最大时间间隔，警告修改时间等)<br />
组口令则储存在/etc/gshadow<br />
用户管理相关命令：<br />
useradd , userdel, usermod ,passwd ,chage ,su,sudo<br />
groupadd, groupdel, groupmod<br />
权限管理相关命令：</p>
<ul>
<li>权限设定命令 chmod</li>
<li>修改文件的属主和/或组命令 chown</li>
<li>修改文件的所属组命令 chgrp</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd [&lt;选项&gt;] &lt;用户名&gt;</span><br><span class="line">-g group 指定新用户的主（私有）组。</span><br><span class="line">-d directory 指定新用户的主目录。</span><br><span class="line">-s shell 指定新用户使用的Shell，默认为bash。</span><br><span class="line">-e expire 指定用户的登录失效时间，例如：08/10/2001</span><br><span class="line">-M 不建立新用户的主目录。</span><br><span class="line"></span><br><span class="line">userdel [&lt; -r &gt;] &lt;用户名&gt;</span><br><span class="line">-r 用于删除用户的主目录</span><br><span class="line"></span><br><span class="line">usermod [&lt;选项&gt;] &lt;用户名&gt;</span><br><span class="line">-l newname 修改登录用户名，但文件夹名称等不会改变</span><br><span class="line">-G groupname 增加附加组。</span><br><span class="line">-L 锁定账户，不能登录</span><br><span class="line">-U 解锁账户，恢复登录</span><br><span class="line">-d home_dir 设置新的主目录</span><br><span class="line"></span><br><span class="line">passwd [&lt;用户账号名&gt;]</span><br><span class="line">-l 锁定账户</span><br><span class="line">-u 解锁账户</span><br><span class="line">-d 删除口令</span><br><span class="line"></span><br><span class="line">修改用户账户密码过期信息 chage</span><br><span class="line">chage [选项] [&lt;用户账户名&gt;]</span><br><span class="line">-m days 设置最小天数，0表示永不过期</span><br><span class="line">-M days 设置最/大天数</span><br><span class="line">-W days 设置警告天数</span><br><span class="line">-l 查询过期信息</span><br><span class="line">-d days 设置密码最后修改的天数</span><br><span class="line"></span><br><span class="line">id 显示用户当前的uid、gid和用户所属的组列表</span><br><span class="line">groups 显示指定用户所属的组列表</span><br><span class="line">whoami 显示当前用户的名称</span><br><span class="line">w/who 显示登录用户及相关信息</span><br><span class="line">newgrp 用于转换用户的当前组到指定的组账号，用户必须属</span><br><span class="line">于该组才可以正确执行该命令</span><br></pre></td></tr></table></figure>
<p>sudo的权限配置存在/etc/sudoers,用<code>visudo</code>配置<br />
<img src="/assets/resources/Pasted%20image%2020231227224944.png" /></p>
<p>权限对应数字：</p>
<table>
<thead>
<tr class="header">
<th>r</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>w</td>
<td>2</td>
</tr>
<tr class="even">
<td>x</td>
<td>1</td>
</tr>
<tr class="odd">
<td>-</td>
<td>0</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```chmod [who] [+| - |=] [permission] 文件或目录名</span><br><span class="line">u 属主（user） </span><br><span class="line">g 同组（group） </span><br><span class="line">o 其他（others） = 直接赋予某权限并取消其他所有权限</span><br><span class="line">a 所有（all） </span><br><span class="line"></span><br><span class="line">chmod u+rw myfile</span><br><span class="line">chmod a+rx,u+w myfile</span><br><span class="line">chmod u+rwx,g+rx,o+rx myfile</span><br><span class="line">chmod a+rwx ,g-w,o-w myfile</span><br><span class="line">chmod a=rwx myfile</span><br><span class="line">chmod go=rx myfile</span><br><span class="line">chmod u-wx,go-x myfile</span><br><span class="line"></span><br><span class="line">修改属主或属组//root</span><br><span class="line">chown [-R] &lt;用户名[:组名]&gt; &lt;文件｜目录&gt;</span><br><span class="line">chown user1 myfile</span><br><span class="line">chown -R user1:softgrp mydir</span><br><span class="line"></span><br><span class="line">修改属组//root</span><br><span class="line">chgrp [-R] &lt;组名&gt; &lt;文件｜目录&gt;</span><br><span class="line">chgrp softgrp myfile</span><br><span class="line"></span><br><span class="line">修改查看默认创建权限 umask</span><br><span class="line">查看当前 umask 值：</span><br><span class="line">umask [-S]</span><br><span class="line">修改当前 umask 值：</span><br><span class="line">umask u1u2u3</span><br><span class="line"></span><br><span class="line">umask值被777减去则是新建目录权限：</span><br><span class="line">022</span><br><span class="line">root用户默认</span><br><span class="line">002</span><br><span class="line">普通用户默认</span><br></pre></td></tr></table></figure>
<h2 id="系统管理">系统管理</h2>
<h3 id="进程">进程</h3>
<p>进程是正在运行的程序的实例。Linux是多任务系统，可以同时运行多个进程<br />
PID ：进程识别号<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程状态命令 ps</span><br><span class="line">BSD风格:</span><br><span class="line">a 显示与终端tty有关的所有进程信息</span><br><span class="line">x 显示所有非控制终端上的进程信息</span><br><span class="line">u 显示面向用户的信息列（用户名、CPU、内存等）</span><br><span class="line">pid号 显示指定进程pid信息</span><br><span class="line"></span><br><span class="line">UNIX风格</span><br><span class="line">-a 显示同一终端下的所有进程信息</span><br><span class="line">-A或-e 显示所有进程</span><br><span class="line">-l 显示长格式</span><br><span class="line">-H 显示进程的树状结构。</span><br><span class="line">-w 宽输出</span><br><span class="line">-f 完全显示信息，即增加显示用户名、PPID等信息</span><br><span class="line">-pid号 显示指定进程pid信息</span><br><span class="line"></span><br><span class="line">• 标准字段</span><br><span class="line">PID 进程标志号</span><br><span class="line">TTY 进程创建时对应的终端，？表示不占用终端</span><br><span class="line">TIME CPU累计使用时间</span><br><span class="line">CMD 执行进程的命令名称</span><br><span class="line">• 扩展字段</span><br><span class="line">UID 进程的用户ID</span><br><span class="line">PPID 父进程ID</span><br><span class="line">• BSD扩展字段</span><br><span class="line">USER 启动进程的用户</span><br><span class="line">%CPU 进程占用CPU时间与该进程总的运行时间的比例</span><br><span class="line">%MEM 进程占用的内存与总内存的比例</span><br><span class="line">VSZ 进程占用的虚拟内存大小</span><br><span class="line">STAT 进程运行状态（D、R、S、T、Z等）</span><br><span class="line">START 开始的时间</span><br><span class="line"></span><br><span class="line">进程终止命令 kill</span><br><span class="line">kill [选项] 进程号</span><br><span class="line">常用选项：</span><br><span class="line">-l 列出全部的信号名称。</span><br><span class="line">-a 当处理当前进程时，不限制命令名和进程号的对应关系。</span><br><span class="line">-p 指定kill 命令只打印相关进程的进程号，而不发送任何信号。</span><br><span class="line">-s 指定发送信号。</span><br><span class="line">-u 指定用户。</span><br><span class="line">-信号 描述进程终止发送的信号编号</span><br><span class="line">kill -9 2277 9号信号代表强制终止</span><br><span class="line"></span><br><span class="line">显示资源消耗最多的进程 top</span><br><span class="line">显示当前内存和交换空间的使用情况 free</span><br></pre></td></tr></table></figure></p>
<h3 id="网络">网络</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试网络的连通性 ping</span><br><span class="line">显示网络状态信息 netstat</span><br><span class="line">显示Socket信息 ss</span><br><span class="line">显示/临时配置网络接口信息 ip</span><br><span class="line"></span><br><span class="line">ping -c 10 192.168.1.100 进行10次ping</span><br><span class="line">ping www.suda.edu.cn 连续不停ping</span><br><span class="line"></span><br><span class="line">netstat 显示所有连接状态</span><br><span class="line">netstat -r 显示路由信息</span><br><span class="line"></span><br><span class="line">ss 显示所有连接状态</span><br><span class="line">ss -l 只显示listening连接</span><br><span class="line">ss -t 只显示TCP连接</span><br><span class="line"></span><br><span class="line">ip address show 显示所有网络接口信息</span><br><span class="line">ip a 简写显示所有网络接口信息</span><br><span class="line">ip add 192.168.1.2 dev eth0 为eth0增加IP地址</span><br><span class="line">ip del 192.168.1.2 dev eth0 为eth0增加IP地址</span><br><span class="line">ip link set eth0 up 启用eth0</span><br><span class="line">ip link set eth0 down 禁用eth0</span><br><span class="line">ip route 查询路由信息</span><br><span class="line"></span><br><span class="line">显示/临时配置网络接口信息 ifconfig</span><br><span class="line">ifconfig 显示所有网络接口信息</span><br><span class="line">ifconfig eth0 显示eth0设备接口信息</span><br><span class="line">ifconfig eth0 add 192.168.1.2 为eth0增加IP地址</span><br><span class="line">ifconfig eth0 up 启用eth0</span><br><span class="line">ifconfig eth0 down 禁用eth0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="内核与软件">内核与软件</h3>
<ul>
<li>二进制软件包 优点：安装简单，可以本地安装也可以在线安装<br />
缺点：灵活性一般，通常与平台或系统有关联<br />
</li>
<li>源代码包 优点：按需配置，可以适应多种平台系统<br />
缺点：源代码无法直接运行，需要先编译再安装安装过程难度较大，对操作人员有一定要求</li>
</ul>
<p>gz,tgz,bz2等后缀压缩包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➢ 安装</span><br><span class="line">1、将压缩包解压到指定位置</span><br><span class="line">2、如果程序无需安装则直接可以运行程序</span><br><span class="line">3、如果需要安装则运行压缩包内的安装脚本或二进制的</span><br><span class="line">安装向导程序（setup、install、install.sh等）安装</span><br><span class="line">➢ 卸载</span><br><span class="line">1、如果程序无需安装则直接删除整个文件夹</span><br><span class="line">2、如果程序是安装的，则运行反安装脚本或程序</span><br></pre></td></tr></table></figure>
<p>Red Hat、CentOS 和 Fedora 等使用 rpm 系统,rpm后缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm [-ivhe] rpm包名</span><br><span class="line">-i 显示套件的相关信息</span><br><span class="line">-v 显示指令执行过程</span><br><span class="line">-h 显示安装进度</span><br><span class="line">-e 卸载套件</span><br><span class="line">rpm –ivh software.rpm 安装</span><br><span class="line">rpm –e software 卸载</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Debian、Ubuntu、Mint 等系统使用 dpkg系统，deb后缀<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpkg [-irPL] deb包名</span><br><span class="line">-i： 安装软件包；</span><br><span class="line">-r： 删除软件包；</span><br><span class="line">-P： 删除软件包的同时删除其配置文件；</span><br><span class="line">-L： 显示于软件包关联的文件；</span><br><span class="line">-l： 显示所有安装的包</span><br><span class="line">dpkg –i software.rpm 安装</span><br><span class="line">dpkg –r software 卸载</span><br><span class="line"></span><br><span class="line">apt [选项] 软件名称</span><br><span class="line">intall 安装</span><br><span class="line">update 检查升级</span><br><span class="line">upgrade 升级</span><br><span class="line">remove 卸载</span><br><span class="line">list 列出当前安装的软件</span><br><span class="line">search 搜索软件</span><br><span class="line"></span><br><span class="line">apt list --upgradeable</span><br><span class="line">apt list --installed </span><br></pre></td></tr></table></figure></p>
<p><strong>内核编译概念</strong>：</p>
<ul>
<li>内核是硬件与软件之间的一个中间层</li>
<li>内核模块是内核的一部分</li>
<li>内核模块可以单独编译</li>
<li>内核更新可以自定义功能或者优化系统</li>
</ul>
<h2 id="shell编程">shell编程</h2>
<p>利用Shell提供的高级命令语言功能所写的程序称为Shell脚本。是纯文本文件，由shell解释执行，所以是解释型编程语言<br />
可分为交互性与非交互性<br />
退出脚本或当前Shell ：<code>exit n</code>,返回0表示成功，0-255是某种失败</p>
<p>变量分类</p>
<ul>
<li>用户变量,由用户自己定义、修改和使用</li>
<li>环境变量，由系统维护，用于设置用户的Shell工作环境,部分变量用户可以修改,用户也可以新增自定义的环境变量</li>
<li>特殊参数变量（Special Parameters）,Bash 预定义的特殊变量，用户不能直接修改，但可以使用</li>
</ul>
<h3 id="用户变量">用户变量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量替换</span><br><span class="line">把命令运行结果以字符串形式传递给变量</span><br><span class="line">1、var=`pwd` 用倒引号``</span><br><span class="line">2、var=$(pwd) 用$()</span><br><span class="line"></span><br><span class="line">如果值中间包含空格、制表符或换行符则必须用引号引起来</span><br><span class="line">单引号不会进行变量引用，双引号会引用，使用\进行转义</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了直接赋值，也可以declare:<br />
<code>declare [选项] variable[=value]</code></p>
<table>
<tbody>
<tr class="odd">
<td>-r</td>
<td>只读 ( readonly )</td>
<td>-a</td>
<td>数组 ( array )</td>
</tr>
<tr class="even">
<td>-x</td>
<td>环境变量（export 为全局变量）</td>
<td>-p</td>
<td>列出变量</td>
</tr>
<tr class="odd">
<td>-i</td>
<td>整型 ( integer )</td>
<td>-f -F</td>
<td>列出函数 ( function )</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /mnt/c/Program Files/</span></span><br><span class="line">ls: cannot access /mnt/c/Program: No such file or directory</span><br><span class="line">ls: cannot access Files/: No such file or directory</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment"># 对于 ls 来说，它接收到了两个参数：/mnt/c/Program 和 Files/，因此会报错。</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment"># 可以使用反斜杠来转义空格</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /mnt/c/Program\ Files/  <span class="comment"># 输出省略</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="comment"># 或者使用双引号或单引号包裹</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> <span class="string">&quot;/mnt/c/Program Files/&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> <span class="string">&#x27;/mnt/c/Program Files/&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span>  <span class="comment"># 双引号中仍然可以使用各种 shell 特殊符号</span></span></span><br><span class="line">/home/ustc</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;$PWD&#x27;</span>  <span class="comment"># 但是单引号则不行</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PWD</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lh `<span class="built_in">which</span> <span class="built_in">ls</span>`  <span class="comment"># 查看 ls 命令对应的程序信息，使用反引号语法</span></span></span><br><span class="line">-rwxr-xr-x 1 root root 139K Sep  5  2019 /usr/bin/ls</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lh $(<span class="built_in">which</span> <span class="built_in">ls</span>) <span class="comment"># 使用 $(command) 语法也是一样的</span></span></span><br><span class="line">-rwxr-xr-x 1 root root 139K Sep  5  2019 /usr/bin/ls</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>数组</strong><br />
申明：</p>
<ul>
<li>variable=(item1 item2 item2 ... )</li>
<li>declare -a variable=(item1 item2 item2 ... ) 引用：${variable[n]}</li>
</ul>
<p>取消变量命令 <strong>unset</strong><br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -a stu                       定义数组变量</span><br><span class="line">stu=(math1101 math1102 math1103)     数组赋值</span><br><span class="line">stu[1]=math                          单个赋值</span><br><span class="line">echo $&#123;stu[0]&#125;                       列出stu的第一个元素</span><br><span class="line">echo $&#123;stu[*]&#125;                       列出stu的所有元素</span><br><span class="line">echo $&#123;#stu[*]&#125;                      给出数组stu中元素的个数</span><br><span class="line">unset stu[1]                         删除stu的第二个元素</span><br><span class="line">unset stu                            删除整个数组</span><br></pre></td></tr></table></figure></p>
<h3 id="环境变量">环境变量</h3>
<p>比较重要的有</p>
<table>
<thead>
<tr class="header">
<th>历史信息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HISTFILE</td>
<td>用于存储历史命令的文件</td>
</tr>
<tr class="even">
<td>HISTSIZE</td>
<td>历史命令列表的大小</td>
</tr>
<tr class="odd">
<td>HOME</td>
<td>当前用户的用户目录</td>
</tr>
<tr class="even">
<td>USER</td>
<td>当前用户名</td>
</tr>
<tr class="odd">
<td>UID</td>
<td>当前用户的UID</td>
</tr>
<tr class="even">
<td>LANG</td>
<td>当前用户的主语言环境</td>
</tr>
<tr class="odd">
<td>TERM</td>
<td>当前用户的终端类型</td>
</tr>
<tr class="even">
<td>PATH</td>
<td>Bash寻找可执行文件的搜索路径</td>
</tr>
<tr class="odd">
<td>PWD</td>
<td>当前工作目录</td>
</tr>
<tr class="even">
<td>ENV</td>
<td>Linux查找配置文件的路径</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• 系统环境设置文件(对所有用户有效)</span><br><span class="line">登录环境设置文件：/etc/profile</span><br><span class="line">非登录环境设置文件：/etc/bashrc</span><br><span class="line">• 个人环境设置文件(只对用户自身生效)</span><br><span class="line">登录环境设置文件：$HOME/.bash_profile</span><br><span class="line">非登录环境设置文件： $HOME/.bashrc</span><br><span class="line"></span><br><span class="line">export 变量名=变量值</span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br><span class="line">export设置的环境变量只在当此登录的Shell中有效</span><br></pre></td></tr></table></figure>
<h3 id="位置变量">位置变量</h3>
<p>$n 表示第n个参数值<br />
<code>ls -l a*中，$1=-l $2=a*</code><br />
左移参数命令 <code>shift [n]</code></p>
<h3 id="变量操作">变量操作</h3>
<p>判断变量是否存在或是否为空，并能对不存在或为空的变量作出相应的动作，这类操作称之为变量测试<br />
<img src="/assets/resources/Pasted%20image%2020231227233342.png" /> <img src="/assets/resources/Pasted%20image%2020231227233431.png" /></p>
<p>变量的间接引用<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(!varname) </span><br><span class="line">aaa=123</span><br><span class="line">Bbb=aaa</span><br><span class="line">Echo $bbb</span><br><span class="line">Echo $&#123;!bbb&#125;</span><br><span class="line">#运行结果</span><br><span class="line">aaa</span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">eval \$$varname</span><br><span class="line">eval newstr=\$$str2</span><br><span class="line">echo $newstr</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">告知shell取出参数，并重新运算参数内容 eval</span><br><span class="line">eval arg1 [arg2] ... [argN]</span><br><span class="line">eval会对参数进行扫描和替换</span><br><span class="line">1.将所有的参数连接成一个表达式，并计算或执行该表达式</span><br><span class="line">2.参数中的任何变量都将被展开</span><br></pre></td></tr></table></figure></p>
<p><strong>算术运算</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num2=4+1</span><br><span class="line">• 赋值符号和运算符两边不能留空格！</span><br><span class="line">• 如果将字符串赋值给一个整型变量时，则变量的值为 0</span><br><span class="line">• 如果变量的值是字符串，则进行算术运算时设为 0</span><br><span class="line"></span><br><span class="line">expr</span><br><span class="line">#表达式中参数与操作符必须以空格分开。表达式中的运算可以是算术运算，比较运算，字符串运算和逻辑运算</span><br><span class="line">expr 5 \* 3 # 乘法符号必须被转义</span><br><span class="line">expr \( 2 + 5 \) \* 2 – 3 # 括号必须被转义</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="输入输出">输入输出</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read [参数] [var1 var2 ...]</span><br><span class="line">-p &quot;文字&quot; 后面跟提示信息，即在输入前打印提示信息</span><br><span class="line">-n num 定义输入的长度</span><br><span class="line"></span><br><span class="line">cat test.txt | while read line</span><br><span class="line"># cat 命令的输出作为read命令的输入,read读到&gt;的值放在line中</span><br><span class="line">do</span><br><span class="line">echo &quot;Content: $line&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo [选项] [文本]</span><br><span class="line">-n 不输出行尾的换行符.</span><br><span class="line">-e 允许加反斜线转义的字符进行解释.</span><br><span class="line">-E 禁止对在STRINGs中的那些序列进行解释</span><br><span class="line"></span><br><span class="line">printf [文本和格式] [参数列表]</span><br><span class="line">printf &quot;The number is: %.2f\n&quot; 100</span><br><span class="line">printf &quot;%-20s|%12.5f|\n&quot; &quot;Joy&quot; 10</span><br><span class="line">printf &quot;%-10d%010o%+10x\n&quot; 20 20 20</span><br><span class="line">printf &quot;%6d\t%6o\&quot;%6x\&quot;\n&quot; 20 20 20</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/assets/resources/Pasted%20image%2020231227234149.png" /></p>
<table>
<thead>
<tr class="header">
<th>转义符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\\</code></td>
<td>反斜线</td>
</tr>
<tr class="even">
<td><code>\a</code></td>
<td>报警符(BEL)</td>
</tr>
<tr class="odd">
<td><code>\b</code></td>
<td>退格符</td>
</tr>
<tr class="even">
<td><code>\c</code></td>
<td>禁止尾随的换行符</td>
</tr>
<tr class="odd">
<td><code>\f</code></td>
<td>换页符</td>
</tr>
<tr class="even">
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr class="odd">
<td><code>\r</code></td>
<td>回车符</td>
</tr>
<tr class="even">
<td><code>\t</code></td>
<td>水平制表符</td>
</tr>
<tr class="odd">
<td><code>\v</code></td>
<td>纵向制表符</td>
</tr>
</tbody>
</table>
<h3 id="逻辑和流程运算">逻辑和流程运算</h3>
<p>条件测试可以判断某个特定条件是否满足，Bash中没有布尔类型变量，0表示真，非0表示假</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test &lt;测试表达式&gt;</span><br><span class="line">[ &lt;测试表达式&gt; ]</span><br><span class="line">[[ &lt;测试表达式&gt; ]] （bash 2.x 版本以上）</span><br><span class="line">格式1 和 格式2 是等价的，格式3是扩展的 test 命令</span><br><span class="line">在 [[ ]] 中可以使用通配符进行模式匹配</span><br><span class="line">例如&amp;&amp;, ||, &lt;, 和&gt;能够正常存在于[[ ]]中，但不能在 [] 中出现</span><br><span class="line">[和[[之后的字符必须为空格，]和]]之前的字符必须为空格</span><br><span class="line">要对整数进行关系运算也可以使用 (()) 进行测试</span><br><span class="line"></span><br><span class="line">[ -f fname ] fname 存在且是普通文件时，返回真 ( 即返回 0 )</span><br><span class="line">[ -L fname ] fname 存在且是链接文件时，返回真</span><br><span class="line">[ -d fname ] fname 存在且是一个目录时，返回真</span><br><span class="line">[ -e fname ] fname（文件或目录）存在时，返回真</span><br><span class="line">[ -s fname ] fname 存在且大小大于 0 时，返回真</span><br><span class="line">[ -r fname ] fname（文件或目录）存在且可读时，返回真</span><br><span class="line">[ -w fname ] fname（文件或目录）存在且可写时，返回真</span><br><span class="line">[ -x fname ] fname（文件或目录）存在且可执行时，返回真</span><br><span class="line"></span><br><span class="line">[ -z string ] 如果字符串string长度为0，返回真</span><br><span class="line">[ -n string ] 如果字符串string长度不为0，返回真</span><br><span class="line">[ str1 = str2 ] 两字符串相等（也可使用 == ）返回真</span><br><span class="line">[ str1 != str2 ] 两字符串不等返回真</span><br><span class="line">[[ str1 == str2 ]] 两字符串相同返回真</span><br><span class="line">[[ str1 != str2 ]] 两字符串不相同返回真</span><br><span class="line">[[ str1 =~ str2 ]] str2是str1的子串返回真</span><br><span class="line">[[ str1 &gt; str2 ]] str1大于str2返回真</span><br><span class="line">[[ str1 &lt; str2 ]] str1小于str2返回真</span><br><span class="line">字符串按从左到右对应字符的ASCII码进行比较</span><br><span class="line"></span><br><span class="line">• 检查空值</span><br><span class="line">[ &quot;$name&quot; = &quot;&quot; ]</span><br><span class="line">[ -z &quot;$name&quot; ]</span><br><span class="line">[ ! &quot;$name&quot; ]</span><br><span class="line">[ &quot;X$&#123;name&#125;&quot; = &quot;X&quot; ]</span><br><span class="line">• 检查非空值</span><br><span class="line">[ &quot;$name&quot; != &quot;&quot; ]</span><br><span class="line">[ -n &quot;$name&quot; ]</span><br><span class="line">[ &quot;$name&quot; ]</span><br><span class="line">[ &quot;X$&#123;name&#125;&quot; != &quot;X&quot; ]</span><br><span class="line">• 比较相等</span><br><span class="line">[ $ans = &quot;Yes&quot; ]</span><br><span class="line">[[ $ans == &quot;Yes&quot; ]]</span><br><span class="line">[[ $ans == [Yy]es ]]</span><br><span class="line"></span><br><span class="line">[[ int1 -eq int2 ]] int1 等于 int2 返回真</span><br><span class="line">[[ int1 -ne int2 ]] int1 不等于 int2 返回真</span><br><span class="line">[[ int1 -gt int2 ]] int1 大于 int2 返回真</span><br><span class="line">[[ int1 -ge int2 ]] int1 大于或等于 int2 返回真</span><br><span class="line">[[ int1 -lt int2 ]] int1 小于 int2 返回真</span><br><span class="line">[[ int1 -le int2 ]] int1 小于或等于 int2 返回真</span><br><span class="line">((int1 == int2)) int1 等于 int2 返回真</span><br><span class="line">((int1 != int2)) int1 不等于 int2 返回真</span><br><span class="line">((int1 &gt; int2)) int1 大于 int2 返回真</span><br><span class="line">((int1 &gt;= int2)) int1 大于或等于 int2 返回真</span><br><span class="line">((int1 &lt; int2)) int1 小于 int2 返回真</span><br><span class="line">((int1 &lt;= int2)) int1 小于或等于 int2 返回真</span><br><span class="line"></span><br><span class="line">[ expr1 -a expr2 ] 逻辑与，都为真时，结果为真</span><br><span class="line">[ expr1 -o expr2 ] 逻辑或，有一个为真时，结果为真</span><br><span class="line">[ ! expr ] 逻辑非</span><br><span class="line">[[ pattern1 &amp;&amp; pattern2 ]] 逻辑与</span><br><span class="line">[[ pattern1 || pattern2 ]] 逻辑或</span><br><span class="line">[[ ! pattern ]] 逻辑非</span><br><span class="line">(( expr1 &amp;&amp; expr2 )) 逻辑与</span><br><span class="line">(( expr1 || expr2 )) 逻辑或</span><br><span class="line">(( ! expr )) 逻辑非</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>流程控制</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if expr1 # 如果 expr1 为真(返回值为0)</span><br><span class="line">then # 那么</span><br><span class="line">	commands1 # 执行语句块 commands1</span><br><span class="line">elif expr2 # 若 expr1 不真，而 expr2 为真</span><br><span class="line">then # 那么</span><br><span class="line">	commands2 # 执行语句块 commands2</span><br><span class="line">... ... # 可以有多个 elif 语句</span><br><span class="line">else # else 最多只能有一个</span><br><span class="line">	commands4 # 执行语句块 commands4</span><br><span class="line">fi # if 语句必须以单词 fi 终止</span><br><span class="line"></span><br><span class="line">myhost=centos1.ls-al.me</span><br><span class="line">if ping -c1 -w2 $myhost &amp;&gt;/dev/null</span><br><span class="line">then</span><br><span class="line">echo &quot;$myhost is UP.&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;$myhost is DOWN.&quot;</span><br><span class="line">fi</span><br><span class="line">if ((age&gt;=0&amp;&amp;age&lt;13)) ; then echo &quot;Child !&quot;</span><br><span class="line">elif ((age&gt;=13&amp;&amp;age&lt;20)); then echo &quot;Callan !&quot;</span><br><span class="line">elif ((age&gt;=20&amp;&amp;age&lt;30)); then echo &quot;P III !&quot;</span><br><span class="line">elif ((age&gt;=30&amp;&amp;age&lt;40)); then echo &quot;P IV !&quot;</span><br><span class="line">else echo &quot;Sorry I asked.&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case expr in # expr 为表达式，关键词 in 不要忘！</span><br><span class="line">pattern1) # 若 expr 与 pattern1 匹配，注意括号</span><br><span class="line">commands1 # 执行语句块 commands1</span><br><span class="line">;; # 跳出 case 结构</span><br><span class="line">pattern2) # 若 expr 与 pattern2 匹配</span><br><span class="line">commands2 # 执行语句块 commands2</span><br><span class="line">;; # 跳出 case 结构</span><br><span class="line">... ... # 可以有任意多个模式匹配</span><br><span class="line">*) # 若 expr 与上面的模式都不匹配</span><br><span class="line">commands # 执行语句块 commands</span><br><span class="line">;; # 跳出 case 结构</span><br><span class="line">esac # case 语句必须以 esac 终止</span><br><span class="line"></span><br><span class="line">echo &quot;What is your preferred scripting language?&quot;</span><br><span class="line">echo &quot;1) bash&quot;</span><br><span class="line">echo &quot;2) perl&quot;</span><br><span class="line">echo &quot;3) python&quot;</span><br><span class="line">echo &quot;4) ruby&quot;</span><br><span class="line">echo &quot;5) I do not know !&quot;</span><br><span class="line">read lang</span><br><span class="line">case $lang in</span><br><span class="line">1) echo &quot;You selected bash&quot; ;;</span><br><span class="line">2) echo &quot;You selected perl&quot; ;;</span><br><span class="line">3) echo &quot;You selected python&quot;;;</span><br><span class="line">4) echo &quot;You selected ruby&quot; ;;</span><br><span class="line">5) exit</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">read yn</span><br><span class="line">case $yn in</span><br><span class="line">1|[Ss]) echo &quot;You selected $yn&quot; ;;</span><br><span class="line">2|[Rr]) echo &quot;You selected $yn&quot; ;;</span><br><span class="line">3|[Ee]) echo &quot;You selected $yn&quot; ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">for variable in list</span><br><span class="line"># 每一次循环，依次把列表 list 中的一个值赋给循环变量</span><br><span class="line">do # 循环体开始的标志</span><br><span class="line">commands # 循环变量每取一次值，循环体就执行一遍</span><br><span class="line">done # 循环结束的标志，返回循环顶部</span><br><span class="line"></span><br><span class="line">for day in Mon Tue Wed Thu Fri ; do</span><br><span class="line">echo &quot;Weekday $((i++)) : $day&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for ((expr1;expr2;expr3)) # 执行 expr1</span><br><span class="line">do # 若 expr2的值为真时进入循环，否则退出 for循环</span><br><span class="line">commands # 执行循环体，之后执行 expr3</span><br><span class="line">done # 循环结束的标志，返回循环顶部</span><br><span class="line"></span><br><span class="line">for ((i=0;i&lt;10;i++))</span><br><span class="line">do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">while expr # 执行 expr</span><br><span class="line">do # 若expr的退出状态为0，进入循环，否则退出while</span><br><span class="line">commands # 循环体</span><br><span class="line">done # 循环结束标志，返回循环顶部</span><br><span class="line"></span><br><span class="line">num =99</span><br><span class="line">while ((num&gt;10))</span><br><span class="line">do</span><br><span class="line">	echo &quot;num is above 10&quot;</span><br><span class="line">	num=$((RANDOM%100))</span><br><span class="line">done</span><br><span class="line">echo &quot;find a num below 10,the num is $num&quot;</span><br><span class="line"></span><br><span class="line">until ((num&lt;=10))</span><br><span class="line">do</span><br><span class="line">echo &quot;num is above 10&quot;</span><br><span class="line">num=$((RANDOM%100))</span><br><span class="line">done</span><br><span class="line">echo &quot;find a num below 10,the num is $num&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select name in &quot;Linux&quot; &quot;Windows&quot; &quot;MacOS&quot; &quot;Android&quot; &quot;HarmonyOS&quot;</span><br><span class="line">do</span><br><span class="line">	case $name in</span><br><span class="line">		&quot;Linux&quot;)</span><br><span class="line">			echo &quot;Linux is the best os!&quot;</span><br><span class="line">			break</span><br><span class="line">			;;</span><br><span class="line">		&quot;Windows&quot;)</span><br><span class="line">			echo &quot;Windows is good!&quot;</span><br><span class="line">			break</span><br><span class="line">			;;</span><br><span class="line">		&quot;MacOS&quot;)</span><br><span class="line">			echo &quot;Mac OS is good!&quot;</span><br><span class="line">			break</span><br><span class="line">			;;</span><br><span class="line">		&quot;Android&quot;)</span><br><span class="line">			echo &quot;Android is a mobile os!&quot;</span><br><span class="line">			break</span><br><span class="line">			;;</span><br><span class="line">		&quot;MacOS&quot;)</span><br><span class="line">			echo &quot;Android is a mobile os!&quot;</span><br><span class="line">			break</span><br><span class="line">			;;</span><br><span class="line">		&quot;HarmonyOS&quot;)</span><br><span class="line">			echo &quot;HarmonyOS is a mobile os!&quot;</span><br><span class="line">			break</span><br><span class="line">			;;</span><br><span class="line">			esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p><strong>函数</strong></p>
<ol type="1">
<li>函数在使用前必须先定义</li>
<li>返回值$？（0~255） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ function ] funname [()] //申明函数</span><br><span class="line">&#123;</span><br><span class="line">	action; //函数内部语句</span><br><span class="line">	[return int;] //返回值，如不带则返回最后一条命令的执行状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="linux101">linux101</h1>
<p><img src="/assets/苏大linux_ppt/clitool.png" /></p>
<h2 id="apt">apt</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt search firefox</span><br><span class="line">Sorting... Done</span><br><span class="line">Full Text Search... Done</span><br><span class="line">(Output omitted)</span><br><span class="line"></span><br><span class="line">firefox/bionic-updates,bionic-security,now 72.0.2+build1-0ubuntu0.18.04.1 amd64</span><br><span class="line">  Safe and easy web browser from Mozilla</span><br><span class="line"></span><br><span class="line">(Output omitted)</span><br></pre></td></tr></table></figure>
<p>中间两行每个字段的含义：</p>
<table>
<thead>
<tr class="header">
<th>样例中的字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>firefox</code></td>
<td>即为在软件仓库中的包名</td>
</tr>
<tr class="even">
<td><code>bionic-updates,bionic-security,now</code></td>
<td>为包含这个软件包的仓库源</td>
</tr>
<tr class="odd">
<td><code>72.0.2+build1-0ubuntu0.18.04.1</code></td>
<td>为软件包的版本</td>
</tr>
<tr class="even">
<td><code>amd64</code></td>
<td>软件包的架构；还可能为<code>i386</code>、<code>all</code>等</td>
</tr>
<tr class="odd">
<td><code>Safe and easy web browser from Mozilla</code></td>
<td>在软件仓库中对这个软件包的描述</td>
</tr>
</tbody>
</table>
<div class="note warning"><p>请避免直接使用 <code>dpkg -i</code> 安装 deb 包。 在绝大多数情况下，都应该使用 <code>apt</code> 来安装 deb 文件。 如果不小心执行了 <code>dpkg -i</code> 导致系统出现依赖问题，可以尝试通过如下的方式调用 <code>apt</code> 帮助修复依赖管理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt -f install</span><br></pre></td></tr></table></figure>
</div>
<h2 id="环境变量-1">环境变量</h2>
<p>我们不能每次在需要编译程序的时候输入如此长的路径找到 <code>clang</code> 和 <code>clang++</code>，而更希望的是能够像 <code>apt</code> 那样在任何地方都可以直接运行。</p>
<p>我们可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将 clang+llvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04 目录下的所有内容复制到 /usr/local/ 下</span><br><span class="line">sudo cp -R * /usr/local/</span><br></pre></td></tr></table></figure>
<p>为什么是 <code>/usr/local</code> 呢？因为 <code>/usr/local/bin</code> 处在 PATH 环境变量下。当我们在终端输入命令时，终端会先判断是否为终端的内建命令，如果不是，则会在 $PATH 环境变量中包含的目录下进行查找。因此，只要我们将一个可执行文件放入了 $PATH 中的目录下面，我们就可以像 <code>apt</code> 一样，在任意地方调用我们的程序。 通过这个命令可以看到当前的 PATH 环境变量有哪些目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>
<p>在上面的复制过程中，源目录和目标目录的两个 <code>bin</code> 目录会相互合并，<code>clang</code> 和 <code>clang++</code> 两个可执行文件也就被复制到了 <code>/usr/local/bin/</code> 目录中。这样子也就达到了我们希望能够在任意地方调用我们的可执行文件的目的。此外，在复制的时候 lib、doc 等文件夹也会和 <code>/usr/local</code> 下的对应目录合并，将 clang 的库和文档加到系统当中。</p>
<h2 id="模式匹配">模式匹配</h2>
<p>许多现代的 shell 都支持一定程度的模式匹配。举个例子，bash 的匹配模式被称为 <a href="https://mywiki.wooledge.org/glob">glob</a>，支持的操作如下：</p>
<table>
<thead>
<tr class="header">
<th>模式</th>
<th>匹配的字串</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*</code></td>
<td>任意字串</td>
</tr>
<tr class="even">
<td><code>foo*</code></td>
<td>匹配 foo 开头的字串</td>
</tr>
<tr class="odd">
<td><code>*x*</code></td>
<td>匹配含 x 的字串</td>
</tr>
<tr class="even">
<td><code>?</code></td>
<td>一个字符</td>
</tr>
<tr class="odd">
<td><code>a?b</code></td>
<td><code>acb</code>、<code>a0b</code> 等，但不包含 <code>a00b</code></td>
</tr>
<tr class="even">
<td><code>*.[ch]</code></td>
<td>以 .c 或 .h 结尾的文件</td>
</tr>
</tbody>
</table>
<div class="note info no-icon"><p>除了上面提到的 glob，bash 还支持 <a href="https://www.linuxjournal.com/content/bash-extended-globbing">extglob</a>，不过需要先用 <code>shopt -s extglob</code> 启用。</p>
</div>
<h2 id="进程-1">进程</h2>
<h3 id="htop">htop</h3>
<p>Htop 可以简单方便查看当前运行的所有进程，以及系统 CPU、内存占用情况与系统负载等信息。</p>
<p>使用鼠标与键盘都可以操作 htop。Htop 界面的最下方是一些选项，使用鼠标点击或按键盘的 F1 至 F10 功能键可以选择这些功能，常用的功能例如搜索进程（F3, Search）、过滤进程（F4, Filter，使得界面中只有满足条件的进程）、切换树形结构/列表显示（F5, Tree/List）等等。</p>
<p><strong>进程标识符</strong>（PID，Process Identifier（是一个数字，是进程的唯一标识。在 htop 中，最左侧一列即为 PID。当用户想挂起、继续或终止进程时可以使用 PID 作为索引。</p>
<p>在 htop 中，直接单击绿色条内的 PID 栏，可以将进程顺序按照 PID 升序排列，再次点击为降序排列，同理可应用于其他列。</p>
<div class="note info no-icon"><p>按照 PID 排序时，我们可以观察系统启动的过程。Linux 系统内核从引导程序接手控制权后，开始内核初始化，随后变为 <strong>init_task</strong>，初始化自己的 PID 为 0。随后创建出 1 号进程（init 程序，目前一般为 systemd）衍生出用户空间的所有进程，创建 2 号进程 kthreadd 衍生出所有内核线程。随后 0 号进程成为 idle 进程，1 号、2 号并非特意预留，而是产生进程的自然顺序使然。</p>
<p>由于 kthreadd 运行于内核空间，故需按大写 K（Shift + k）键显示内核进程后才能看到。然而无论如何也不可能在 htop 中看到 0 号进程本体，只能发现 1 号和 2 号进程的 PPID 是 0。</p>
</div>
<h4 id="linux对进程的分类">linux对进程的分类</h4>
<p><code>Status: R: running; S: sleeping; T: traced/stopped; Z: zombie; D: disk sleep</code> S 对应的 sleeping 又称 interruptible sleep，字面意思是「可以被中断」；而 D 对应的 disk sleep 又称 uninterruptible sleep，不可被中断，一般是因为阻塞在磁盘读写操作上。 Zombie 是僵尸进程，该状态下进程已经结束，只是仍然占用一个 PID，保存一个返回值。而 traced/stopped 状态正是下文使用 Ctrl + Z 导致的挂起状态（大写 T），或者是在使用 gdb 等调试（Debug）工具进行跟踪时的状态（小写 t）。</p>
<table>
<thead>
<tr class="header">
<th>状态</th>
<th>缩写表示</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Running</td>
<td>R</td>
<td>正在运行/可以立刻运行</td>
</tr>
<tr class="even">
<td>Sleeping</td>
<td>S</td>
<td>可以被中断的睡眠</td>
</tr>
<tr class="odd">
<td>Disk Sleep</td>
<td>D</td>
<td>不可被中断的睡眠</td>
</tr>
<tr class="even">
<td>Traced / Stopped</td>
<td>T</td>
<td>被跟踪/被挂起的进程</td>
</tr>
<tr class="odd">
<td>Zombie</td>
<td>Z</td>
<td>僵尸进程</td>
</tr>
</tbody>
</table>
<h3 id="ps">ps</h3>
<p>ps（<strong>p</strong>rocess <strong>s</strong>tatus）是常用的输出进程状态的工具。直接调用 <code>ps</code> 仅会显示本终端中运行的相关进程。如果需要显示所有进程，对应的命令为 <code>ps aux</code>。</p>
<h3 id="优先级与-nice-值">优先级与 nice 值</h3>
<p>有了进程，谁先运行？谁给一点时间就够了，谁要占用大部分 CPU 时间？这又是如何决定的？这些问题之中体现着优先权的概念。如果说上面所介绍的的那些进程属性描述了进程的控制信息，那么<strong>优先级</strong>则反映操作系统调度进程的手段。在 htop 的显示中有两个与优先级有关的值：Priority（PRI）和 <strong>nice（NI）</strong>。以下主要介绍用户层使用的 nice 值。</p>
<p>Nice 值越高代表一个进程对其它进程越 "nice"（友好），对应的优先级也就更低。Nice 值最高为 19，最低为 -20。通常，我们运行的程序的 nice 值为 0。我们可以打开 htop 观察与调整每个进程的 nice 值。</p>
<p>用户可以使用 <code>nice</code> 命令在运行程序时指定优先级，而 <code>renice</code> 命令则可以重新指定优先级。当然，若想调低 nice 值，还需要 <code>sudo</code>（毕竟不能随便就把自己的优先级设置得更高，不然对其他的用户不公平）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nice -n 10 vim # 以 10 为 nice 值运行 vim</span><br><span class="line">renice -n 10 -p 12345 # 设置 PID 为 12345 的进程的 nice 值为 10</span><br></pre></td></tr></table></figure>
<div class="note info no-icon"><p>如果你在 htop 中测试调整进程的 nice 值，可能会发现一个公式：<code>PRI = nice + 20</code>。这对于普通进程是成立的——普通进程的 PRI 会被映射到一个非负整数。</p>
<p>但在正常运行的 Linux 系统中，我们可能会发现有些进程的 PRI 值是 RT，或者是负数。这表明对应的进程有更高的实时性要求（例如内核进程、音频相关进程等），采用了与普通进程不同的调度策略，优先级也相应更高。</p>
</div>
<h3 id="用户进程控制">用户进程控制</h3>
<p><img src="https://101.lug.ustc.edu.cn/Ch04/images/signal_slide.png" /> 信号是 Unix 系列系统中进程之间相互通信的一种机制。发送信号的 Linux 命令叫作 <code>kill</code>。被称作 "kill" 的原因是：早期信号的作用就是关闭（杀死）进程。</p>
<h3 id="前后台">前后台</h3>
<p><img src="https://101.lug.ustc.edu.cn/Ch04/images/bg.gif" /> 默认情况下，在 shell 中运行的命令都在前台运行，如果需要在后台运行程序，需要在最后加上 <code>&amp;</code> 而如果需要将前台程序切换到后台，则需要按下 Ctrl + Z 发送 SIGTSTP 使进程挂起，控制权还给 shell 我们可以使用 <code>jobs</code> 命令，看到当前 shell 上所有相关的进程 任务前的代号在 fg，bg，乃至 kill 命令中发挥作用。使用时需要在前面加 <code>%</code>，如将 2 号进程放入后台，则使用 <code>bg %2</code> <div class="note info no-icon"><p>然而我们也许会关注一个细节，在图中显示的编号后面跟着的加号和减号是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1]  - running    ./signal handle</span><br><span class="line">[2]  + suspended  ping localhost</span><br></pre></td></tr></table></figure>
<p>这里的加号标记了 fg 和 bg 命令默认作用到的任务为 2，所以这里 <code>bg %2</code> 也可以直接简化为 <code>bg</code>。减号表示如果加号标记的进程退出了，它就会成为加号标记进程。我们也可以用 <code>%+</code> 和 <code>%-</code> 指代这两个任务。</p>
</div></p>
<h3 id="终止进程">终止进程</h3>
<p>标准的终止进程信号是 SIGTERM，意味着一个进程的自然死亡</p>
<ul>
<li>htop 中自带向进程发送信号的功能。按下 K 键，在左侧提示栏中选择需要的信号，按下回车发送。同时可以使用空格对进程进行标记，被标记的进程将改变显示颜色。此时重复上述过程，可对被标记进程批量发送信号。</li>
<li>如果不加任何参数，只有 PID，<code>kill</code> 命令将自动使用 15（SIGTERM）作为信号参数。</li>
<li>在信号中，9 代表 SIGKILL，收到这个信号之后，程序会立刻退出。在使用时，直接 <code>kill -9 PID</code> 即可。</li>
</ul>
<h3 id="其他类-kill-命令">其他类 kill 命令</h3>
<ul>
<li><p><code>pgrep</code> / <code>pkill</code> 后面接模糊名称，实际上类似于对名称进行 <code>grep</code> 命令。<code>pgrep</code> 仅列出搜索到的进程名称符合用户输入的进程标识符，而 <code>pkill</code> 会根据用户的输入向进程发送信号。</p></li>
<li><p><code>killall</code> 与 <code>pkill</code> 有一些类似，会向指定名字的进程发送信号。</p></li>
<li><p><code>xkill</code> <code>xkill</code> 是针对窗口的 kill，运行该命令后，鼠标点击程序对应的窗口，就可以杀死该程序。</p></li>
</ul>
<h3 id="脱离终端">脱离终端</h3>
<p>如果你使用过 SSH 连接到远程服务器执行任务，那么你会发现，你在 shell 中执行的程序在 SSH 断开之后会被关闭。这是因为终端一旦被关闭会向其中每个进程发送 SIGHUP（Signal hangup），而 SIGHUP 的默认动作即退出程序运行。</p>
<h4 id="nohup">nohup</h4>
<p>nohup，字面含义，就是「不要被 SIGHUP 影响」。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ nohup ping 101.ustclug.org &amp;</span><br><span class="line">[1] 19258</span><br><span class="line">nohup: ignoring input and appending output to &#x27;/home/ustc/nohup.out&#x27;</span><br></pre></td></tr></table></figure>
<p>在需要屏蔽 SIGHUP 的程序前添加 nohup，则运行时的输出将被<a href="https://101.lug.ustc.edu.cn/Ch06/#redirect">重定向</a>到 nohup.out，也可以通过重定向手段自定义输出的文件。</p>
<h2 id="服务">服务</h2>
<h3 id="服务管理">服务管理</h3>
<p>目前绝大多数 Linux 发行版的 init 方案都是 systemd，其管理系统服务的命令是 <code>systemctl</code>。</p>
<p>若想了解全部服务内容，可以运行 <code>systemctl list-units</code> 来查看。该命令将显示所有 systemd 管理的单元，同时右面还会附上一句注释来表明该服务的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tldr systemctl</span><br><span class="line">systemctl</span><br><span class="line">Control the systemd system and service manager.</span><br><span class="line"></span><br><span class="line">    - List failed units:  # 列出运行失败的服务</span><br><span class="line">    systemctl --failed</span><br><span class="line"></span><br><span class="line">    - Start/Stop/Restart/Reload a service:  # 开启/关闭/重启/重载服务。Reload 代表重载配置文件而不重启进程。</span><br><span class="line">    systemctl start/stop/restart/reload &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Show the status of a unit:  # 显示服务状态</span><br><span class="line">    systemctl status &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Enable/Disable a unit to be started on bootup:  # 设置（Enable）/取消（Disable）服务开机自启</span><br><span class="line">    systemctl enable/disable &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Mask/Unmask a unit, prevent it to be started on bootup:  # 阻止/取消阻止服务被 enable</span><br><span class="line">    systemctl mask/unmask &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Reload systemd, scanning for new or changed units:  # 重载 systemd，需要在创建或修改服务文件后执行</span><br><span class="line">    systemctl daemon-reload</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info no-icon"><p>wsl默认不支持systemctl,可以使用传统的service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tldr service</span><br><span class="line">service</span><br><span class="line">Manage services by running init scripts.</span><br><span class="line">The full script path should be omitted (/etc/init.d/ is assumed).</span><br><span class="line"></span><br><span class="line"> - Start/Stop/Restart/Reload service (start/stop should always be available):</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; &#123;&#123;start|stop|restart|reload&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Do a full restart (runs script twice with start and stop):</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; --full-restart</span><br><span class="line"></span><br><span class="line"> - Show the current status of a service:</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; status</span><br><span class="line"></span><br><span class="line"> - List the status of all services:</span><br><span class="line">   service --status-all</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者手动打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/wsl.conf</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[boot]</span><br><span class="line">systemd=true</span><br></pre></td></tr></table></figure>
<p>然后在windows终端wsl --shutdown再重启</p>
</div>
<div class="note info no-icon"><p><strong>编写 .service 文件并运行（以 Jupyter Notebook 为例）</strong></p>
<p>Jupyter Notebook 是基于浏览器的交互式编程平台，在数据科学领域非常常用。</p>
<p>首先使用文本编辑器在 <code>/etc/systemd/system</code> 目录下创建一个名为 <code>jupyter.service</code> 的文件。并填入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jupyter Notebook    # 该服务的简要描述</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">PIDFile=/run/jupyter.pid        # 用来存放 PID 的文件</span><br><span class="line">ExecStart=/usr/local/bin/jupyter-notebook --allow-root</span><br><span class="line">                                # 使用绝对路径标明的命令及命令行参数</span><br><span class="line">WorkingDirectory=/root          # 服务启动时的工作目录</span><br><span class="line">Restart=always                  # 重启模式，这里是无论因何退出都重启</span><br><span class="line">RestartSec=10                   # 退出后多少秒重启</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target      # 依赖目标，这里指进入多用户模式后再启动该服务</span><br></pre></td></tr></table></figure>
<p>将写好的配置文件保存为 <code>/etc/systemd/system/jupyter.service</code>，然后运行 <code>systemctl daemon-reload</code>，就可以使用 <code>systemctl</code> 命令来管理这个服务了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start jupyter</span><br><span class="line">systemctl stop jupyter</span><br><span class="line">systemctl enable jupyter  # enable 表示标记服务的开机自动启动</span><br><span class="line">systemctl disable jupyter # 取消自启</span><br></pre></td></tr></table></figure>
</div>
<h3 id="例行性任务">例行性任务</h3>
<p>可以用at，crontab等工具创建例行性任务 详见<a href="https://101.lug.ustc.edu.cn/Ch04/#crontab">linux101</a></p>
<div class="note info no-icon">
</div>
<h2 id="用户权限和文件系统">用户权限和文件系统</h2>
<p>可以查看 <code>/etc/passwd</code> 文件，来得到系统中用户的配置信息。 普通用户的文件存储于位于 <code>/home/username/</code>路径</p>
<div class="note info no-icon"><p>你是否常常忘记敲 <code>sudo</code>，结果还要把后面的整条命令重新敲一遍？在发现权限不足之后有一个方便的「补救方案」：<code>sudo !!</code>，效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt update</span><br><span class="line">Reading package lists... Done</span><br><span class="line">E: Could not open lock file /var/lib/apt/lists/lock - open (13: Permission denied)</span><br><span class="line">E: Unable to lock directory /var/lib/apt/lists/</span><br><span class="line">W: Problem unlinking the file /var/cache/apt/pkgcache.bin - RemoveCaches (13: Permission denied)</span><br><span class="line">W: Problem unlinking the file /var/cache/apt/srcpkgcache.bin - RemoveCaches (13: Permission denied)</span><br><span class="line">$ sudo !!</span><br><span class="line">sudo apt update</span><br><span class="line">[sudo] password for ustc:</span><br><span class="line">Hit:1 http://mirrors.ustc.edu.cn/ubuntu bionic InRelease</span><br><span class="line">（以下内容省略）</span><br></pre></td></tr></table></figure>
<p>其实，在 Shell 中，<code>!!</code> 即代表上一条命令，可以和其他的命令结合使用。</p>
</div>
<p>以 <code>root</code> 之外的用户的身份执行命令：加上 <code>-u 用户名</code> 的参数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo -u nobody id</span><br><span class="line">uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)</span><br></pre></td></tr></table></figure>
<h3 id="用户组">用户组</h3>
<p>用户组是用户的集合。通过用户组机制，可以为一批用户设置权限。可以使用 <code>groups</code> 命令，查看自己所属的用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ groups</span><br><span class="line">ustc adm cdrom sudo dip plugdev lxd</span><br></pre></td></tr></table></figure>
<p>用户组和用户一样，也有编号：GID (Group ID)。 <div class="note info no-icon"><p><code>adduser</code> 是 Debian 及其衍生发行版中附带的一个方便的用户管理脚本。它可以用来向系统添加用户、添加组，以及将用户加入组。输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser 用户名</span><br></pre></td></tr></table></figure>
<p>即可添加此用户。而输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser --group 组名</span><br></pre></td></tr></table></figure>
<p>即可添加此用户组。将用户加入指定用户组也非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser 用户名 组名</span><br></pre></td></tr></table></figure>
<p>在通过 <code>adduser</code> 创建了新的用户后，直接使用 <code>sudo</code> 以 <code>root</code> 身份运行程序可能会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">[sudo] password for ustc:</span><br><span class="line">ustc is not in the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure>
<p>除了可以通过 <code>visudo</code> 命令编辑 <code>sudoers</code> 文件外，还可以直接通过将新的用户加入到 <code>sudo</code> 用户组，以能够使用 <code>sudo</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser ustc sudo</span><br></pre></td></tr></table></figure>
<p>再次切换到新的用户即可看到使用 sudo 的提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="line">See &quot;man sudo_root&quot; for details.</span><br></pre></td></tr></table></figure>
</div></p>
<h2 id="文本处理">文本处理</h2>
<h3 id="正则表达式">正则表达式</h3>
<p><a href="https://regex101.com/">在线编辑正则表达式</a> 正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。</p>
<p>特殊字符表：</p>
<table>
<thead>
<tr class="header">
<th>特殊字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[]</code></td>
<td>方括号表达式，表示匹配的字符集合，例如 <code>[0-9]</code>、<code>[abcde]</code></td>
</tr>
<tr class="even">
<td><code>()</code></td>
<td>标记子表达式起止位置</td>
</tr>
<tr class="odd">
<td><code>*</code></td>
<td>匹配前面的子表达式零或多次</td>
</tr>
<tr class="even">
<td><code>+</code></td>
<td>匹配前面的子表达式一或多次</td>
</tr>
<tr class="odd">
<td><code>?</code></td>
<td>匹配前面的子表达式零或一次</td>
</tr>
<tr class="even">
<td><code>\</code></td>
<td>转义字符，除了常用转义外，还有：<code>\b</code> 匹配单词边界；<code>\B</code> 匹配非单词边界等</td>
</tr>
<tr class="odd">
<td><code>.</code></td>
<td>匹配除 <code>\n</code>（换行）外的任意单个字符</td>
</tr>
<tr class="even">
<td><code>&#123;&#125;</code></td>
<td>标记限定符表达式的起止。例如 <code>&#123;n&#125;</code> 表示匹配前一子表达式 n 次；<code>&#123;n,&#125;</code> 匹配至少 n 次；<code>&#123;n,m&#125;</code> 匹配 n 至 m 次</td>
</tr>
<tr class="odd">
<td><code>|</code></td>
<td>表明前后两项二选一</td>
</tr>
<tr class="even">
<td><code>$</code></td>
<td>匹配字符串的结尾</td>
</tr>
<tr class="odd">
<td><code>^</code></td>
<td>匹配字符串的开头，在方括号表达式中表示不接受该方括号表达式中的字符集合</td>
</tr>
<tr class="even">
<td><code>\f</code></td>
<td>匹配一个换页符。等价于 <code>\x0c</code> 和 <code>\cL</code></td>
</tr>
<tr class="odd">
<td><code>\n</code></td>
<td>匹配一个换行符。等价于 <code>\x0a</code> 和 <code>\cJ</code> 比较常用</td>
</tr>
<tr class="even">
<td><code>\r</code></td>
<td>匹配一个回车符。等价于 <code>\x0d</code> 和 <code>\cM</code> 比较常用</td>
</tr>
<tr class="odd">
<td><code>\t</code></td>
<td>匹配一个制表符。等价于 <code>\x09</code>和 <code>\cI</code></td>
</tr>
<tr class="even">
<td><code>\v</code></td>
<td>匹配一个垂直制表符。等价于 <code>\x0b</code> 和 <code>\cK</code></td>
</tr>
<tr class="odd">
<td><code>\s</code></td>
<td>匹配任何空白字符,包括空格、制表符、换页符等等。等价于 <code>[\f\n\r\t\v].</code></td>
</tr>
<tr class="even">
<td><code>\S</code></td>
<td>匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v].</code></td>
</tr>
<tr class="odd">
<td><code>\w</code></td>
<td>匹配字母、数字、下划线。等价于<code>[_[:alnum:]]</code></td>
</tr>
<tr class="even">
<td><code>\d</code></td>
<td>匹配数字。等价于 <code>[0-9]</code></td>
</tr>
</tbody>
</table>
<p>{n,m}表示匹配次数，包括n,m次</p>
<p>若是想要匹配特殊字符本身，需要在之前加上转义字符 <code>\</code>。 <div class="note info no-icon"><p>匹配正整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1-9][0-9]*</span><br></pre></td></tr></table></figure>
<p>匹配仅由 26 个英文字母组成的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[A-Za-z]+$</span><br></pre></td></tr></table></figure>
<p>匹配 Chapter 1-99 或 Section 1-99</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(Chapter|Section) [1-9][0-9]&#123;0,1&#125;$</span><br></pre></td></tr></table></figure>
<p>匹配“ter”结尾的单词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ter\b</span><br></pre></td></tr></table></figure>
<p>匹配rgb代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^#([0-9]&#123;6&#125;$|([0-9]|[A-F])&#123;3&#125;$)</span><br></pre></td></tr></table></figure>
</div></p>
<h4 id="基本扩展正则表达式">基本/扩展正则表达式</h4>
<p>基本正则表达式（Basic Regular Expressions, BRE）和扩展正则表达式（Extended Regular Expressions, ERE）是两种 POSIX 正则表达式风格。</p>
<p>BRE 可能是如今最老的正则风格了，对于部分特殊字符（如 <code>+</code>, <code>?</code>, <code>|</code>, <code>&#123;</code>）需要加上转义符 <code>\</code> 才能表达其特殊含义。</p>
<p>ERE 与如今的现代正则风格较为一致，相比 BRE，上述特殊字符默认发挥特殊作用，加上 <code>\</code> 之后表达普通含义。</p>
<h4 id="懒惰和贪婪">懒惰和贪婪</h4>
<p>使用 <code>*</code> <code>+</code> 的时候默认是贪婪模式，即尽可能匹配更多的子表达式。在 <code>*</code> <code>+</code> 之后加上 <code>?</code> 变为懒惰模式，即尽可能匹配更少的子表达式。</p>
<p>例如：<code>123456456</code></p>
<p>贪婪：<code>1.+6</code> -&gt; <code>123456456</code></p>
<p>懒惰：<code>1.+?6</code> -&gt; <code>123456</code> 后向引用可以将之前匹配到的具体内容再次利用。在正则表达式中，<code>()</code> 以及它们包含的内容为一个分组，每个分组默认拥有一个组号。</p>
<p>组号分配规则：</p>
<ul>
<li>0 代表整个表达式</li>
<li>从左至右，按左括号的出现顺序分配，第一个为 1，第二个为 2，以此类推</li>
<li>扫描两遍，第一次只分配未命名的组，第二次只分配命名的组。即任意命名组的组号都大于未命名的组号</li>
</ul>
<h4 id="后向引用">后向引用</h4>
<div class="note info no-icon"><p>示例</p>
<p><code>\b(\w+)\b\s+\1\b</code> 可以用来匹配用空白字符分割的两个重复的单词（例如 <code>linux linux</code>），其中 <code>\1</code> 是对组号为 1 的组 <code>(\w+)</code> 的引用。</p>
<p><code>\b(?'Word'\w+)\b\s+\k'Word'\b</code> 也可以起到同样的效果，其中 <code>?'Word'</code> 用于命名组，<code>\k'Word'</code> 用于引用组。</p>
</div>
<h4 id="零宽断言">零宽断言</h4>
<p>零宽断言用于查找某些内容进行定位，但内容并不放入匹配结果，就像 <code>\b</code> <code>^</code> <code>$</code> 的定位一样。<code>(?=exp)</code> 用于匹配表达式 <code>exp</code> 前面的位置，<code>(?&lt;=exp)</code> 用于匹配后面的位置。</p>
<h4 id="拓展阅读">拓展阅读</h4>
<p><a href="https://zhuanlan.zhihu.com/p/46294360">乱用正则引发的惨案</a></p>
<h3 id="其他的文本处理工具">其他的文本处理工具</h3>
<h4 id="grep-1">grep</h4>
<p>grep 全称 Global Regular Expression Print，是一个强大的文本搜索工具，可以在一个或多个文件中搜索指定 pattern 并显示相关行。</p>
<p>grep 默认使用 BRE，要使用 ERE 可以使用 <code>grep -E</code> 或 egrep。</p>
<p>命令格式：<code>grep [option] pattern file</code></p>
<p>一些用法：</p>
<ul>
<li><code>-n</code>：显示匹配到内容的行号</li>
<li><code>-v</code>：显示不被匹配到的行</li>
<li><code>-i</code>：忽略字符大小写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /bin | grep -n &quot;^man$&quot;  # 搜索内容仅含 man 的行，并且显示行号</span><br><span class="line">ls /bin | grep -v &quot;[a-z]\|[0-9]&quot;  # 搜索不含小写字母和数字的行</span><br><span class="line">ls /bin | grep -iv &quot;[A-Z]\|[0-9]&quot;  # 搜索不含字母和数字的行</span><br></pre></td></tr></table></figure>
<h4 id="sed-1">sed</h4>
<p>sed 全称 Stream EDitor，即流编辑器，可以方便地对文件的内容进行逐行处理。</p>
<p>sed 默认使用 BRE，要使用 ERE 可以 sed -E。</p>
<p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [OPTIONS] &#x27;command&#x27; file(s)</span><br><span class="line">sed [OPTIONS] -f scriptfile file(s)</span><br></pre></td></tr></table></figure>
<p>此处的 command 和 scriptfile 中的命令均指的是 sed 命令。</p>
<p>常见 sed 命令：</p>
<ul>
<li>s 替换</li>
<li>d 删除</li>
<li>c 选定行改成新文本</li>
<li>a 当前行下插入文本</li>
<li>i 当前行上插入文本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo -e &quot;seD\nIS\ngOod&quot; &gt; sed_demo</span><br><span class="line">$ cat sed_demo</span><br><span class="line">seD</span><br><span class="line">IS</span><br><span class="line">gOod</span><br><span class="line">$ sed &quot;2d&quot; sed_demo  # 删除第二行</span><br><span class="line">seD</span><br><span class="line">gOod</span><br><span class="line">$ sed &quot;s/[a-z]/~/g&quot; sed_demo  # 替换所有小写字母为 ~</span><br><span class="line">~~D</span><br><span class="line">IS</span><br><span class="line">~O~~</span><br><span class="line">$ sed &quot;3cpErfeCt&quot; sed_demo  # 选定第三行，改成 pErfeCt</span><br><span class="line">seD</span><br><span class="line">IS</span><br><span class="line">pErfeCt</span><br></pre></td></tr></table></figure>
<h4 id="awk-1">awk</h4>
<p>awk 是一种用于处理文本的编程语言工具，名字来源于三个作者的首字母。相比 sed，awk 可以在逐行处理的基础上，针对列进行处理。默认的列分隔符号是空格，其他分隔符可以自行指定。</p>
<p>awk 使用 ERE。</p>
<p>命令格式：<code>awk [options] 'pattern &#123;action&#125;' [file]</code></p>
<p>awk 逐行处理文本，对符合的 patthern 执行 action。需要注意的是，awk 使用单引号时可以直接用 <code>$</code>，使用双引号则要用 <code>\$</code>。</p>
<p>一些示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat awk_demo</span><br><span class="line">Beth    4.00    0</span><br><span class="line">Dan     3.75    0</span><br><span class="line">kathy   4.00    10</span><br><span class="line">Mark    5.00    20</span><br><span class="line">Mary    5.50    22</span><br><span class="line">Susie   4.25    18</span><br><span class="line">$ # 选择第三列值大于 0 的行，对每一行输出第一列的值和第二第三列的乘积</span><br><span class="line">$ awk &#x27;$3 &gt;0 &#123; print $1, $2 * $3 &#125;&#x27; awk_demo</span><br><span class="line">kathy 40</span><br><span class="line">Mark 100</span><br><span class="line">Mary 121</span><br><span class="line">Susie 76.5</span><br></pre></td></tr></table></figure>
<p>示例中 <code>$1</code>，<code>$2</code>，<code>$3</code> 分别指代本行的第 1、2、3 列。特别地，$0 指代本行。</p>
<p>awk 语言是「图灵完全」的，这意味着理论上它可以做到和其他语言一样的事情。这里我们不仅可以对每行进行操作，还可以定义变量，将前面处理的状态保存下来，以下是一个求和的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; sum = 0 &#125; &#123; sum += $2 * $3 &#125; END &#123; print sum &#125;&#x27; awk_demo</span><br><span class="line">337.5</span><br></pre></td></tr></table></figure>
<h4 id="trsort">tr,sort</h4>
<p>除此之外，tr可用于进行简单的预处理，sort可以用于进行简单的排序、</p>
<h2 id="shell环境">shell环境</h2>
<p>组命令：</p>
<ul>
<li><p>使用 <code>&#123; 命令1; 命令2; … &#125;</code>，组命令在 shell 内执行，不会产生新的进程，注意花括号和命令之间的空格。</p></li>
<li><p>使用 <code>(命令1; 命令2; …)</code>，组命令会建立独立的 shell 子进程来执行组命令，这里的圆括号周围并不需要空格。</p></li>
</ul>
<p>可以在脚本开头加上 <code>set -u</code> 来实现使用未定义变量报错，否则会默认成空值</p>
<h3 id="位置参数">位置参数</h3>
<ul>
<li>Shell 解释用户的命令时，把命令程序名后面的所有字串作为程序的参数。分别对应 <code>$1</code>、<code>$2</code>、<code>$3</code>、……、<code>$9</code>，程序名本身对应 <code>$0</code>。</li>
<li>可用 <code>shift &lt;n&gt;</code> 命令，丢弃开头的 n 个位置变量，改变 <code>$1</code>、<code>$2</code>、<code>$3</code> 等的对应关系。</li>
<li>可用 <code>set</code> 命令，重置整个位置变量列表，从而给 <code>$1</code>、<code>$2</code>、<code>$3</code> 等赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ set one two three</span><br><span class="line">$ echo $1 $2 $3</span><br><span class="line">one two three</span><br><span class="line">$ shift 2</span><br><span class="line">$ echo $1 $2 $3</span><br><span class="line">three</span><br><span class="line">$ # 此时 $2 和 $3 已不存在</span><br></pre></td></tr></table></figure>
<h3 id="特殊变量">特殊变量</h3>
<table>
<thead>
<tr class="header">
<th>特殊变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>$#</code></td>
<td>命令行上的参数个数，不包括 <code>$0</code></td>
</tr>
<tr class="even">
<td><code>$?</code></td>
<td>最后命令的退出代码，0 表示成功，其它值表示失败</td>
</tr>
<tr class="odd">
<td><code>$$</code></td>
<td>当前进程的 PID</td>
</tr>
<tr class="even">
<td><code>$!</code></td>
<td>最近一个后台运行进程的进程号</td>
</tr>
<tr class="odd">
<td><code>$*</code></td>
<td>命令行所有参数构成的一个字符串</td>
</tr>
<tr class="even">
<td><code>$@</code></td>
<td>用双引号括起的命令行各参数拼接构成的一个字符串</td>
</tr>
<tr class="odd">
<td><code>$_</code></td>
<td>在此之前执行的命令或脚本的最后一个参数</td>
</tr>
<tr class="even">
<td><code>$0</code></td>
<td>命令行上输入的Shell程序名</td>
</tr>
</tbody>
</table>
<h3 id="特殊字符">特殊字符</h3>
<ul>
<li><p>反斜杠，消除单个字符的特殊含义。</p>
<ul>
<li>包含空白字符（空格和制表符）、反斜杠本身、各种引号，以及 <code>$</code>、<code>!</code> 等。</li>
<li>与其他语言不同，shell 中反斜杠不会将普通字符转义为其他含义（例如 <code>\n</code> 不会被视作换行符）。</li>
</ul></li>
<li><p>使用双引号包裹字符串可以消除空白字符切分参数的特殊含义，但是很多其他特殊字符的特殊含义仍然保留。双引号也被称为「弱引用」。</p></li>
<li><p>单引号，能消除所有特殊字符的特殊含义，包括反斜杠，因此单引号字符串中不能使用反斜杠转义单引号本身。单引号也被称为「强引用」。</p></li>
<li><p>反引号（<code>`</code>）括起的字符串，被 shell 解释为命令，执行时用命令输出结果代替整个反引号对界限部分。</p>
<ul>
<li>与反引号相同的语法是 <code>$(command)</code>，它的好处是界限更明确，且可以嵌套。因此编写新脚本时，更建议使用此语法。</li>
</ul></li>
</ul>
<h3 id="语法">语法</h3>
<p>具体语法可参考<a href="https://101.lug.ustc.edu.cn/Ch06/#bash-arithmetic">linux101</a></p>
<h2 id="拓展阅读-1">拓展阅读</h2>
<h3 id="进程与会话">进程与会话</h3>
<p>Fork 是类 UNIX 中创建进程的基本方法：将当前的进程完整复制一份。新进程和旧进程唯一的区别是 <code>fork()</code> 的返回值不同。程序员可以根据其返回值为新旧进程设置不同的逻辑。</p>
<p>除了最开始的 0 号进程外，绝大多数情况下其他进程是由另一个进程通过 fork 产生的。这里产生进程的一方为<strong>父进程</strong>，被产生的是<strong>子进程</strong>。在 Linux 中，父进程可以等待子进程，接收子进程退出信号以及返回值。 父进程如果先于子进程退出，产生孤儿进程，会被0号进程(init)接管 子进程先退出但父进程没有回应，产生僵尸进程，会被系统定时清理</p>
<p><strong>进程组</strong>大体上是执行同一工作的进程形成的一个团体，通常是由于父进程 fork 出子进程后子进程继承父进程的组 ID 而逐渐形成。</p>
<p><strong>会话</strong> (session) 可以说是面向用户的登录出现的概念。当用户从终端登录进入 shell，就会以该 shell 为会话首进程展开本次会话。一个会话中通常包含着多个进程组，分别完成不同的工作。用户退出时，这个会话会结束，但有些进程仍然以该会话标识符 (session ID) 驻留系统中继续运行。</p>
<table>
<thead>
<tr class="header">
<th>进程属性</th>
<th>意义/目的</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PID</td>
<td>Process ID，标识进程的唯一性。</td>
</tr>
<tr class="even">
<td>PPID</td>
<td>Parent PID，标识进程父子关系。</td>
</tr>
<tr class="odd">
<td>PGID</td>
<td>Process Group ID，标识共同完成一个任务的整体。</td>
</tr>
<tr class="even">
<td>TPGID</td>
<td>标识一组会话中处于前台（与用户交流）的进程（组）。</td>
</tr>
<tr class="odd">
<td>SID</td>
<td>Session ID，标识一组会话，传统意义上标识一次登录所做的任务的集合，如果是与具体登录无关的进程，其 SID 被重置。</td>
</tr>
</tbody>
</table>
<h3 id="终端-terminal-与控制台-console">终端 (Terminal) 与控制台 (Console)</h3>
<p>在上世纪六十年代，个人计算机尚未开始发展，用户使用计算机的一种常见方式就是通过终端，与远程的服务器连接交互。当时键盘和显示器连为一体，称为终端（terminal）。而主机自带的一套键盘与屏幕只能给系统管理员使用，称为控制台 (console)，用来输出启动 debug 信息（现在的 Linux 系统如果因故障而不得不进入单用户修复模式，则只有一个终端 <code>/dev/console</code> 开启）。</p>
<p>然而随着时代的发展，这种模式逐渐被家庭电脑的分布式主机取代，我们不需要，也没有多套终端了，只有显示器、键盘、鼠标。但是为了向前兼容性，我们需要假装这是一个（甚至多个）终端，所以一般发行版 <code>/dev</code> 目录下有 7 个终端 <code>tty1 ~ tty7</code>，通过 <code>Ctrl + Alt + F1 ~ F7</code> 切换键盘与显示器与哪个终端相对应。</p>
<p>再后来，随着时代发展，终端需要出现在图形界面上了，然而承载图形界面的也是终端，所以终端里的终端就需要终端模拟器来实现了。由此，出现在图形界面上的终端才叫终端模拟器。</p>
<p>没有图形界面时，shell 一般为控制台 (tty) 的子进程，在图形界面上 shell 建立在虚拟终端 (pty, pseudo tty) 之上。顺带一提，服务器常用的远程连接工具 <code>ssh</code> 的父进程也是一个 pty。</p>
<p>参考阅读: <a href="https://www.linuxdashen.com/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%88%E7%AB%AF%E5%90%97%EF%BC%9F">你真的知道什么是终端吗？</a></p>
<h3 id="文件系统的特殊权限位">文件系统的特殊权限位</h3>
<p>有三个特殊权限位：setuid, setgid 和 sticky。</p>
<ul>
<li><code>setuid</code>: 以文件所属的用户的身份 (UID) 执行此程序。</li>
<li><code>setgid</code>: 对文件来说，以文件所属的用户组的身份 (GID) 执行此程序；对目录来说，在这个目录下创建的文件的用户组都与此目录本身的用户组一致，而不是创建者的用户组。</li>
<li><code>sticky</code> (restricted deletion flag): 目录中的所有文件只能由文件所有者（除 <code>root</code> 以外）删除或者移动。一个典型的例子是临时文件夹 <code>/tmp</code>，在此文件夹中你可以创建、修改、重命名、移动、删除自己的文件，但是动不了别人的文件。</li>
</ul>
<p><code>/usr/bin/passwd</code> 的文件权限设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 root root 67992 Aug 29  2019 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p>可以看到，本来是执行权限位的地方变成了 <code>s</code>。这代表此文件有 <code>setuid</code> 特殊权限位。在你执行 <code>passwd</code> 的时候，它的实际权限和 <code>root</code> 一样，只是它知道，执行它的人是你（而非 <code>root</code>），所以只提供修改你自己的密码的功能。</p>
<p>此外，passwd需要知道实际执行自己的用户是谁，在 Linux 中，有两个系统调用可以获取当前进程归属的 UID：<code>getuid()</code> 和 <code>geteuid()</code>。前者对应的是「实际用户」(Real user)，是实际运行（拥有）这个进程的用户，后者对应的是「有效用户」(Effective user)，对应进程拥有的权限。在运行 <code>passwd</code> 的时候，有效用户是 <code>root</code>，所以可以修改 <code>/etc/shadow</code>；而实际用户是你，所以它不会让你修改别人的密码。</p>
<p>对用户组来说，也有实际用户组 (GID) 和有效用户组 (EGID) 的区别。</p>
<h3 id="登录-shell和非登录-shell">登录 Shell和非登录 Shell</h3>
<p>「登录 Shell」是属于你的当前会话操作中的第一个进程，一般是在你输入用户名和密码之后打开的 Shell。常见的场景有：</p>
<ul>
<li><code>su -</code> 之后的 Shell。</li>
<li>SSH 登录机器后的 Shell</li>
<li>Ctrl + Alt + F[1-7] 之后 TTY 中的 Shell</li>
</ul>
<p>而「非登录 Shell」的常见场景：</p>
<ul>
<li><code>su</code> 打开的是「非登录 Shell」</li>
<li>在桌面环境中打开的终端（模拟器），启动的也是「非登录 Shell」</li>
</ul>
<p>一般地，「登录 Shell」会额外加载 <code>profile</code> 文件（文件名根据你使用的 Shell 的不同而有区别），且它的 <code>argv[0][0] == '-'</code>（相信你已经学过 C 语言了）。可以用以下方法验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $0  # 查看当前 Shell 的 argv[0] 的值</span><br><span class="line">-bash</span><br><span class="line">$ # 是 Login shell</span><br><span class="line">$ sudo su # 进入 root</span><br><span class="line"># echo $0</span><br><span class="line">bash</span><br><span class="line"># # 是 Non-login shell</span><br></pre></td></tr></table></figure>
<h3 id="fork炸弹">fork炸弹</h3>
<p>Fork 炸弹有如下的这种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:()&#123; :|: &amp; &#125;;:</span><br></pre></td></tr></table></figure>
<p>这是一个函数定义以及对其的调用语句，可以格式化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:()</span><br><span class="line">&#123;</span><br><span class="line">    :|: &amp;</span><br><span class="line">&#125;;</span><br><span class="line">:</span><br></pre></td></tr></table></figure>
<p>在 Bash 中，<code>:</code>、<code>.</code>、<code>/</code> 等一些字符也能够被用于函数命名，因此，上面的代码等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func()</span><br><span class="line">&#123;</span><br><span class="line">    func | func &amp;</span><br><span class="line">&#125;;</span><br><span class="line">func</span><br></pre></td></tr></table></figure>
<p>fork 炸弹的核心是函数内容：<code>func | func &amp;</code></p>
<ul>
<li>第一个 func 代表递归执行这个函数。</li>
<li><div class="line-block">代表要将第一个函数的数据结果通过管道传输给后一个函数。</div></li>
<li>&amp; 代表要在后台执行这一条命令，如果其中一个函数被操作系统回收，其调用产生的子函数并不会被回收。</li>
</ul>
<p>于是运行一次这个函数就会创建两个 func 函数的实例，并不断地反复调用。实例的数量会指数爆炸式地增长，最终耗尽系统的资源。</p>
<h4 id="防范方法">防范方法</h4>
<p>一个有效的方式(https://101.lug.ustc.edu.cn/Ch06/supplement/#fn:1)是通过修改系统配置，限制一个用户能够拥有的进程数量多少。<code>ulimit -u 30</code> 可以限制当前用户能够拥有的进程数量为 30。</p>
<h3 id="动静态链接">动/静态链接</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -o hello hello.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd ./hello</span></span><br><span class="line">    linux-vdso.so.1 (0x00007ffc49703000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f36767d3000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f36769ea000)</span><br><span class="line"></span><br><span class="line">//编译得到程序就依赖于 `linux-vdso.so.1`、`libc.so.6` 和 `/lib64/ld-linux-x86-64.so.2` 三个库文件，如果系统中没有这三个库文件，程序就无法执行。</span><br></pre></td></tr></table></figure>
<p>使用到第三方的库需要加上 <code>-l</code> 参数指定在<strong>链接</strong>时链接到的库。 对于复杂的应用来说，下载后可能会因为没有动态链接库而无法运行。 而静态链接则将依赖的库全部打包到程序文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o hello-static hello.c -static  # 编译一个静态链接的应用</span><br><span class="line">$ ldd ./hello-static  # 没有动态链接库的依赖</span><br><span class="line">    not a dynamic executable</span><br></pre></td></tr></table></figure>
<p>此时编译得到的程序文件没有额外的依赖，在其他机器上一般也能顺利运行。代价则是消耗更多的空间，并且可能产生性能损耗</p>
<h3 id="交叉编译">交叉编译</h3>
<p>有时需要开发另一个系统的程序，此时就需要交叉编译来实现，比如使用mingw编译windows程序 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install gcc-mingw-w64  # 安装 mingw 交叉编译器</span><br><span class="line">$ sudo apt install wine  # 安装 wine Windows 兼容层（默认仅安装 64 位架构支持）</span><br><span class="line">$ x86_64-w64-mingw32-gcc -o hello.exe hello.c  # 编译为 64 位的 Windows 程序</span><br><span class="line">$ file hello.exe  # 确认为 Windows 程序</span><br><span class="line">hello.exe: PE32+ executable (console) x86-64, for MS Windows</span><br><span class="line">$ wine hello.exe  # 使用 wine 运行</span><br><span class="line">it looks like wine32 is missing, you should install it.</span><br><span class="line">as root, please execute &quot;apt-get install wine32&quot;</span><br><span class="line">wine: created the configuration directory &#x27;/home/ubuntu/.wine&#x27;</span><br><span class="line">（忽略首次配置的输出）</span><br><span class="line">wine: configuration in L&quot;/home/ubuntu/.wine&quot; has been updated.</span><br><span class="line">Hello, world!</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="docker">docker</h3>
<p>Dockerfile 是构建 Docker 镜像的标准格式，下面会举一些例子。我们会基于这些例子简单介绍 Dockerfile 的语法。</p>
<h4 id="构建简单的交叉编译环境">构建简单的交叉编译环境</h4>
<p>这个例子尝试使用 Debian 仓库中的 RISC-V <a href="https://101.lug.ustc.edu.cn/Ch07/supplement/#cross-compile-example">交叉编译</a>工具链与 QEMU 模拟器构建一个简单的用于交叉编译的环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM debian:buster-slim</span><br><span class="line"></span><br><span class="line">RUN sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    apt update &amp;&amp; apt install -y gcc-riscv64-linux-gnu g++-riscv64-linux-gnu libc6-dev-riscv64-cross \</span><br><span class="line">                                 binutils-riscv64-linux-gnu libstdc++-dev-riscv64-cross \</span><br><span class="line">                                 qemu-system-misc qemu-user-static qemu-user binfmt-support \</span><br><span class="line">                                 fish vim --no-install-recommends</span><br><span class="line">RUN mkdir /workspace/</span><br><span class="line"></span><br><span class="line">WORKDIR /workspace/</span><br><span class="line">ENV QEMU_LD_PREFIX=/usr/riscv64-linux-gnu/</span><br><span class="line"></span><br><span class="line">CMD [&quot;fish&quot;]</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>docker build</code>，我们可以构建出镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker build -t riscv-cross:example .</span><br></pre></td></tr></table></figure>
<p>Docker 在根据 Dockerfile 构建时，会从上到下执行这些指令，每条指令对应镜像的一层。Docker 容器镜像的独特之处就在于它的分层设计：在构建镜像时每层的更改会叠加在上一层上（这意味着，上一层的所有数据仍然会保留，即使在新的一层删除了）；如果某一层已经存在，Docker 会直接使用这一层，节约构建的时间和占用的空间。 因此构建镜像应尽量减少层数避免空间浪费</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>linux</tag>
        <tag>苏州大学</tag>
        <tag>中国科学技术大学</tag>
      </tags>
  </entry>
  <entry>
    <title>基于加州房地产数据集的数据分析项目</title>
    <url>/thinklive/39056/</url>
    <content><![CDATA[<h1 id="实践报告">实践报告</h1>
<h2 id="背景介绍">背景介绍</h2>
<p>本次作业使用一个房价数据集，房价数据集完全由数字信息构成，规模属于中小级别(2w条左右)，有一定的数据处理需求，但由于最主要的参数房价和其他相关列主要是简单的类线性关系，易于作为学习数据科学的入门材料。<br />
此外，通过房屋参数来预测房价在现实中也有一定的实践意义，例如一些房屋出售软件可以建立相关模型来给出估价等。</p>
<h2 id="问题描述">问题描述</h2>
<p>主要目标是预测房价，为此目标，需要清洗不合理的数据，寻找线性相关的列，最后利用一些回归模型来进行训练，并验证结果 最后的输入是数据集内和房价线性相关程度较高的列，输出则是对房价的预测结果。</p>
<h2 id="数据描述">数据描述</h2>
<p>这些数据涉及在加州某个地区的街区以及基于 1990 年人口普查数据的一些汇总统计数据：</p>
<ol type="1">
<li>房屋中位价值：一个街区内家庭的房屋中位价值（以美元计算）</li>
<li>收入中位数：一栋房屋内的家庭收入中位数（以万美元衡量）</li>
<li>中位年龄：街区内房屋的中位年龄； 数字较小的是较新的建筑</li>
<li>房间总数：一个街区内的房间总数</li>
<li>卧室总数：一个街区内的卧室总数</li>
<li>人口：居住在一个街区内的总人数</li>
<li>家庭：一个街区的家庭总数</li>
<li>纬度：衡量房屋向北有多远的指标； 值越高越北 [°]</li>
<li>经度：衡量房屋向西有多远的量度； 数值越高，越西 [°]</li>
<li>距离海岸：到最近海岸点的距离[m]</li>
<li>到洛杉矶的距离：到洛杉矶市中心的距离[m]</li>
<li>到圣地亚哥的距离：到圣地亚哥中心的距离[m]</li>
<li>到圣何塞的距离: 到圣何塞中心的距离 [m]</li>
<li>到旧金山的距离：到旧金山市中心的距离[m]</li>
</ol>
<ol type="1">
<li>Median House Value: Median house value for households within a block (measured in US Dollars)</li>
<li>Median Income: Median income for households within a block of houses (measured in tens of thousands of US Dollars)</li>
<li>Median Age: Median age of a house within a block; a lower number is a newer building [years]</li>
<li>Total Rooms: Total number of rooms within a block</li>
<li>Total Bedrooms: Total number of bedrooms within a block</li>
<li>Population: Total number of people residing within a block</li>
<li>Households: Total number of households, a group of people residing within a home unit, for a block</li>
<li>Latitude: A measure of how far north a house is; a higher value is farther north [°]</li>
<li>Longitude: A measure of how far west a house is; a higher value is farther west [°]</li>
<li>Distance to coast: Distance to the nearest coast point [m]</li>
<li>Distance to Los Angeles: Distance to the centre of Los Angeles [m]</li>
<li>Distance to San Diego: Distance to the centre of San Diego [m]</li>
<li>Distance to San Jose: Distance to the centre of San Jose [m]</li>
<li>Distance to San Francisco: Distance to the centre of San Francisco [m]</li>
</ol>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#引入python库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"><span class="comment">#固定随机结果</span></span><br><span class="line">np.random.seed(<span class="number">44</span>)</span><br><span class="line"><span class="comment">#读取数据集</span></span><br><span class="line">training_data = pd.read_csv(<span class="string">&#x27;California_Houses.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data.columns.values</span><br></pre></td></tr></table></figure>
<pre><code>array([&#39;Median_House_Value&#39;, &#39;Median_Income&#39;, &#39;Median_Age&#39;, &#39;Tot_Rooms&#39;,
       &#39;Tot_Bedrooms&#39;, &#39;Population&#39;, &#39;Households&#39;, &#39;Latitude&#39;,
       &#39;Longitude&#39;, &#39;Distance_to_coast&#39;, &#39;Distance_to_LA&#39;,
       &#39;Distance_to_SanDiego&#39;, &#39;Distance_to_SanJose&#39;,
       &#39;Distance_to_SanFrancisco&#39;], dtype=object)</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data.describe()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Median_House_Value
</th>
<th>
Median_Income
</th>
<th>
Median_Age
</th>
<th>
Tot_Rooms
</th>
<th>
Tot_Bedrooms
</th>
<th>
Population
</th>
<th>
Households
</th>
<th>
Latitude
</th>
<th>
Longitude
</th>
<th>
Distance_to_coast
</th>
<th>
Distance_to_LA
</th>
<th>
Distance_to_SanDiego
</th>
<th>
Distance_to_SanJose
</th>
<th>
Distance_to_SanFrancisco
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
<td>
2.064000e+04
</td>
<td>
2.064000e+04
</td>
<td>
20640.000000
</td>
<td>
20640.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
206855.816909
</td>
<td>
3.870671
</td>
<td>
28.639486
</td>
<td>
2635.763081
</td>
<td>
537.898014
</td>
<td>
1425.476744
</td>
<td>
499.539680
</td>
<td>
35.631861
</td>
<td>
-119.569704
</td>
<td>
40509.264883
</td>
<td>
2.694220e+05
</td>
<td>
3.981649e+05
</td>
<td>
349187.551219
</td>
<td>
386688.422291
</td>
</tr>
<tr>
<th>
std
</th>
<td>
115395.615874
</td>
<td>
1.899822
</td>
<td>
12.585558
</td>
<td>
2181.615252
</td>
<td>
421.247906
</td>
<td>
1132.462122
</td>
<td>
382.329753
</td>
<td>
2.135952
</td>
<td>
2.003532
</td>
<td>
49140.039160
</td>
<td>
2.477324e+05
</td>
<td>
2.894006e+05
</td>
<td>
217149.875026
</td>
<td>
250122.192316
</td>
</tr>
<tr>
<th>
min
</th>
<td>
14999.000000
</td>
<td>
0.499900
</td>
<td>
1.000000
</td>
<td>
2.000000
</td>
<td>
1.000000
</td>
<td>
3.000000
</td>
<td>
1.000000
</td>
<td>
32.540000
</td>
<td>
-124.350000
</td>
<td>
120.676447
</td>
<td>
4.205891e+02
</td>
<td>
4.849180e+02
</td>
<td>
569.448118
</td>
<td>
456.141313
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
119600.000000
</td>
<td>
2.563400
</td>
<td>
18.000000
</td>
<td>
1447.750000
</td>
<td>
295.000000
</td>
<td>
787.000000
</td>
<td>
280.000000
</td>
<td>
33.930000
</td>
<td>
-121.800000
</td>
<td>
9079.756762
</td>
<td>
3.211125e+04
</td>
<td>
1.594264e+05
</td>
<td>
113119.928682
</td>
<td>
117395.477505
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
179700.000000
</td>
<td>
3.534800
</td>
<td>
29.000000
</td>
<td>
2127.000000
</td>
<td>
435.000000
</td>
<td>
1166.000000
</td>
<td>
409.000000
</td>
<td>
34.260000
</td>
<td>
-118.490000
</td>
<td>
20522.019101
</td>
<td>
1.736675e+05
</td>
<td>
2.147398e+05
</td>
<td>
459758.877000
</td>
<td>
526546.661701
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
264725.000000
</td>
<td>
4.743250
</td>
<td>
37.000000
</td>
<td>
3148.000000
</td>
<td>
647.000000
</td>
<td>
1725.000000
</td>
<td>
605.000000
</td>
<td>
37.710000
</td>
<td>
-118.010000
</td>
<td>
49830.414479
</td>
<td>
5.271562e+05
</td>
<td>
7.057954e+05
</td>
<td>
516946.490963
</td>
<td>
584552.007907
</td>
</tr>
<tr>
<th>
max
</th>
<td>
500001.000000
</td>
<td>
15.000100
</td>
<td>
52.000000
</td>
<td>
39320.000000
</td>
<td>
6445.000000
</td>
<td>
35682.000000
</td>
<td>
6082.000000
</td>
<td>
41.950000
</td>
<td>
-114.310000
</td>
<td>
333804.686371
</td>
<td>
1.018260e+06
</td>
<td>
1.196919e+06
</td>
<td>
836762.678210
</td>
<td>
903627.663298
</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数据处理">数据处理</h2>
<h3 id="导入python库">导入python库</h3>
<h3 id="封装函数">封装函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据清洗函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_outliers</span>(<span class="params">data, variable, lower=-np.inf, upper=np.inf</span>):</span><br><span class="line">    df = data.copy()</span><br><span class="line">    df = df[df[variable] &gt; lower]</span><br><span class="line">    df = df[df[variable] &lt; upper]</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line">    </span><br><span class="line"><span class="comment">#划分训练集和验证集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_val_split</span>(<span class="params">data, train_pct=<span class="number">0.8</span></span>):</span><br><span class="line">    data_len = data.shape[<span class="number">0</span>]</span><br><span class="line">    shuffled_indices = np.random.permutation(data_len)</span><br><span class="line">    </span><br><span class="line">    split_index = <span class="built_in">int</span>(<span class="number">0.8</span> * data_len)</span><br><span class="line">    train_indices = shuffled_indices[:split_index]</span><br><span class="line">    val_indices = shuffled_indices[split_index:]</span><br><span class="line">    </span><br><span class="line">    train = data.iloc[train_indices]</span><br><span class="line">    validation = data.iloc[val_indices]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train, validation</span><br><span class="line">    </span><br><span class="line"><span class="comment">#绘制分布图和箱型图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_distribution</span>(<span class="params">data, label</span>):</span><br><span class="line">    fig, axs = plt.subplots(nrows=<span class="number">2</span>)</span><br><span class="line">    sns.histplot(</span><br><span class="line">        data[label], </span><br><span class="line">        ax=axs[<span class="number">0</span>]</span><br><span class="line">    )</span><br><span class="line">    sns.boxplot(</span><br><span class="line">        x=data[label],</span><br><span class="line">        ax=axs[<span class="number">1</span>],</span><br><span class="line">        showfliers=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line">    spacer = np.<span class="built_in">max</span>(data[label]) * <span class="number">0.05</span></span><br><span class="line">    xmin = np.<span class="built_in">min</span>(data[label]) - spacer</span><br><span class="line">    xmax = np.<span class="built_in">max</span>(data[label]) + spacer</span><br><span class="line">    axs[<span class="number">0</span>].set_xlim((xmin, xmax))</span><br><span class="line">    axs[<span class="number">1</span>].set_xlim((xmin, xmax))</span><br><span class="line"></span><br><span class="line">    plt.subplots_adjust(hspace=<span class="number">0</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&quot;Distribution of &quot;</span> + label)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出根据一列聚合的另一列的平均值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_mean_lineplot</span>(<span class="params">dis,val,df=training_data,thisbins=<span class="number">200</span></span>):</span><br><span class="line">    categories = pd.cut(df[dis], bins=thisbins)</span><br><span class="line">    mids = [c.mid <span class="keyword">for</span> c <span class="keyword">in</span> categories]  </span><br><span class="line">    df[<span class="string">&#x27;distance_bin&#x27;</span>] = mids</span><br><span class="line">    mean_price = df.groupby(<span class="string">&#x27;distance_bin&#x27;</span>)[val].mean()</span><br><span class="line">    newdf=pd.DataFrame()</span><br><span class="line">    newdf[<span class="string">&#x27;mean_price&#x27;</span>]=mean_price</span><br><span class="line">    newdf[<span class="string">&#x27;distance_bin&#x27;</span>]=mean_price.index</span><br><span class="line">    sns.lineplot(x=<span class="string">&#x27;distance_bin&#x27;</span>,y=<span class="string">&#x27;mean_price&#x27;</span>,data=newdf)</span><br><span class="line">    plt.title(<span class="string">&quot;mean house price with the same &quot;</span>+dis)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出线性分布图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_lmplot</span>(<span class="params">x_col,name,y_col=<span class="string">&quot;Median_House_Value&quot;</span>,bins=<span class="number">100</span>,ci=<span class="number">1</span></span>):</span><br><span class="line">    sns.lmplot(data = training_data, x = x_col, \</span><br><span class="line">           y = y_col,x_bins=bins,x_ci=ci)</span><br><span class="line">    plt.title(<span class="string">&quot;proportion of &quot;</span>+name+<span class="string">&quot; against house value&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">#绘制二元分布图 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_jonitplot</span>(<span class="params">x_col,name,y_col=<span class="string">&quot;Median_House_Value&quot;</span></span>):</span><br><span class="line">    sns.jointplot(data = training_data, x = x_col, \</span><br><span class="line">              y = y_col, \</span><br><span class="line">              kind = <span class="string">&quot;hex&quot;</span>)</span><br><span class="line">    plt.suptitle(name+<span class="string">&quot; agginst value&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="数据过滤">数据过滤</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#观察数据分布</span></span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Age&#x27;</span>);</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Income&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_11_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_11_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_11_2.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看到收入和售价数据的右侧末端比较不合理，应该过滤</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Median_Income&#x27;</span>,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Median_House_Value&#x27;</span>,<span class="number">0</span>,<span class="number">400000</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Distance_to_coast&#x27;</span>,<span class="number">0</span>,<span class="number">70000</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Households&#x27;</span>,<span class="number">0</span>,<span class="number">1500</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data.describe()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Median_House_Value
</th>
<th>
Median_Income
</th>
<th>
Median_Age
</th>
<th>
Tot_Rooms
</th>
<th>
Tot_Bedrooms
</th>
<th>
Population
</th>
<th>
Households
</th>
<th>
Latitude
</th>
<th>
Longitude
</th>
<th>
Distance_to_coast
</th>
<th>
Distance_to_LA
</th>
<th>
Distance_to_SanDiego
</th>
<th>
Distance_to_SanJose
</th>
<th>
Distance_to_SanFrancisco
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
count
</th>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
<td>
1.465100e+04
</td>
<td>
1.465100e+04
</td>
<td>
14651.000000
</td>
<td>
14651.000000
</td>
</tr>
<tr>
<th>
mean
</th>
<td>
199561.517917
</td>
<td>
3.696580
</td>
<td>
29.953996
</td>
<td>
2356.678657
</td>
<td>
496.034742
</td>
<td>
1367.255341
</td>
<td>
468.929561
</td>
<td>
35.372597
</td>
<td>
-119.555017
</td>
<td>
21259.751408
</td>
<td>
2.490542e+05
</td>
<td>
3.721187e+05
</td>
<td>
359123.874456
</td>
<td>
397236.235539
</td>
</tr>
<tr>
<th>
std
</th>
<td>
79310.711796
</td>
<td>
1.419884
</td>
<td>
12.191439
</td>
<td>
1425.953928
</td>
<td>
287.919292
</td>
<td>
814.994880
</td>
<td>
266.065608
</td>
<td>
2.077014
</td>
<td>
2.063217
</td>
<td>
16562.862059
</td>
<td>
2.475190e+05
</td>
<td>
2.905277e+05
</td>
<td>
226985.441402
</td>
<td>
262135.238533
</td>
</tr>
<tr>
<th>
min
</th>
<td>
14999.000000
</td>
<td>
0.499900
</td>
<td>
1.000000
</td>
<td>
11.000000
</td>
<td>
3.000000
</td>
<td>
3.000000
</td>
<td>
3.000000
</td>
<td>
32.540000
</td>
<td>
-124.350000
</td>
<td>
120.676447
</td>
<td>
4.205891e+02
</td>
<td>
4.849180e+02
</td>
<td>
569.448118
</td>
<td>
456.141313
</td>
</tr>
<tr>
<th>
25%
</th>
<td>
140600.000000
</td>
<td>
2.625000
</td>
<td>
20.000000
</td>
<td>
1410.000000
</td>
<td>
296.000000
</td>
<td>
816.000000
</td>
<td>
286.000000
</td>
<td>
33.880000
</td>
<td>
-121.890000
</td>
<td>
8077.199272
</td>
<td>
2.631262e+04
</td>
<td>
1.550810e+05
</td>
<td>
88700.495102
</td>
<td>
92070.783507
</td>
</tr>
<tr>
<th>
50%
</th>
<td>
187500.000000
</td>
<td>
3.551100
</td>
<td>
31.000000
</td>
<td>
2053.000000
</td>
<td>
431.000000
</td>
<td>
1190.000000
</td>
<td>
412.000000
</td>
<td>
34.140000
</td>
<td>
-118.360000
</td>
<td>
17596.867293
</td>
<td>
1.385490e+05
</td>
<td>
1.872540e+05
</td>
<td>
484362.783196
</td>
<td>
552023.712780
</td>
</tr>
<tr>
<th>
75%
</th>
<td>
252000.000000
</td>
<td>
4.625000
</td>
<td>
38.000000
</td>
<td>
2968.000000
</td>
<td>
631.000000
</td>
<td>
1725.000000
</td>
<td>
595.000000
</td>
<td>
37.690000
</td>
<td>
-117.980000
</td>
<td>
28063.195081
</td>
<td>
5.221622e+05
</td>
<td>
7.009827e+05
</td>
<td>
519935.107297
</td>
<td>
587792.558476
</td>
</tr>
<tr>
<th>
max
</th>
<td>
399400.000000
</td>
<td>
7.988700
</td>
<td>
52.000000
</td>
<td>
12837.000000
</td>
<td>
2219.000000
</td>
<td>
8733.000000
</td>
<td>
1499.000000
</td>
<td>
41.950000
</td>
<td>
-114.550000
</td>
<td>
69995.382339
</td>
<td>
1.018260e+06
</td>
<td>
1.196919e+06
</td>
<td>
836762.678210
</td>
<td>
903627.663298
</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据分析寻找与房屋价格有线性关系的列">数据分析——寻找与房屋价格有线性关系的列</h3>
<h4 id="可视化房屋价格与距离远近的关系">可视化房屋价格与距离远近的关系</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">places=[<span class="string">&#x27;Distance_to_coast&#x27;</span>, <span class="string">&#x27;Distance_to_LA&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Distance_to_SanDiego&#x27;</span>, <span class="string">&#x27;Distance_to_SanJose&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Distance_to_SanFrancisco&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pla <span class="keyword">in</span> places:</span><br><span class="line">    draw_jonitplot(x_col=pla,name=pla)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_18_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_18_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_18_2.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_18_3.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_18_4.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看出其中只有距海岸线距离似乎与房价有关系</p>
<h3 id="用更直观的折线图表示平均房价与海岸线与城市距离关系">用更直观的折线图表示平均房价与海岸线与城市距离关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pla <span class="keyword">in</span> places:</span><br><span class="line">    draw_mean_lineplot(dis=pla,val=<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_21_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_21_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_21_2.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_21_3.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_21_4.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>根据可视化发现，只有海岸线距离与房价有类似线性关系</p>
<h3 id="房屋数和卧室数与房价是否相关">房屋数和卧室数与房价是否相关</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Tot_Rooms&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">50</span>)</span><br><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Tot_Bedrooms&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_24_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_24_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看出单独两列和房价都无明显关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;bedroom_proportion&#x27;</span>] =training_data[<span class="string">&#x27;Tot_Bedrooms&#x27;</span>] / training_data[<span class="string">&#x27;Tot_Rooms&#x27;</span>]</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;bedroom_proportion&#x27;</span>,<span class="number">0</span>,<span class="number">0.25</span>)</span><br><span class="line">draw_lmplot(x_col=<span class="string">&#x27;bedroom_proportion&#x27;</span>,name=<span class="string">&#x27;bedroom&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_26_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>两者比例和房价近似线性有关</p>
<h3 id="和房屋年龄关系">和房屋年龄关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Median_Age&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_29_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看出和年龄没有明显关系</p>
<h3 id="和家庭平均人口数的关系">和家庭平均人口数的关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;people_house_proportion&#x27;</span>] =training_data[<span class="string">&#x27;Population&#x27;</span>] / training_data[<span class="string">&#x27;Households&#x27;</span>]</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;people_house_proportion&#x27;</span>,<span class="number">0</span>,<span class="number">3.5</span>)</span><br><span class="line">draw_lmplot(x_col=<span class="string">&#x27;people_house_proportion&#x27;</span>,name=<span class="string">&#x27;people_house_proportion&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_32_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;people_house_proportion&#x27;</span>].describe()</span><br></pre></td></tr></table></figure>
<pre><code>count    9213.000000
mean        2.722022
std         0.422372
min         1.060606
25%         2.432647
50%         2.740845
75%         3.044444
max         3.499266
Name: people_house_proportion, dtype: float64</code></pre>
<p>可以看出和家庭平均人数有近似线性关系</p>
<h3 id="与中位数收入的关系">与中位数收入的关系</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">draw_lmplot(x_col=<span class="string">&#x27;Median_House_Value&#x27;</span>,name=<span class="string">&#x27;Median_House_Value&#x27;</span>,ci=<span class="number">95</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_36_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<p>可以看出和中位数收入线性有关</p>
<h3 id="验证相关性可视化">验证——相关性可视化</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correlation = training_data.corr()[<span class="string">&#x27;Median_House_Value&#x27;</span>].sort_values(ascending = <span class="literal">False</span>).to_frame()</span><br><span class="line">sns.heatmap(correlation, annot = <span class="literal">True</span>, cmap = <span class="string">&#x27;Blues&#x27;</span>, fmt = <span class="string">&#x27;.2f&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>&lt;Axes: &gt;</code></pre>
<figure>
<img src="/assets/myproj3/output_39_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<h2 id="建立模型">建立模型</h2>
<p>由于数据呈现出较为标准的线性关系，选取了线性回归，决策树，随机森林，k近邻回归等回归模型，这些模型适合处理线性数据关系，并且其原理和训练方法容易理解。 缺点则是都是比较简单的模型，因此准确度不算特别理想，也不适宜处理关系复杂的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用到的辅助函数：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#划分数据为valid和train</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide_datas</span>(<span class="params">train,valid,<span class="built_in">list</span></span>):</span><br><span class="line">    X_train = train[<span class="built_in">list</span>]</span><br><span class="line">    y_train = train[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line">    X_valid = valid[<span class="built_in">list</span>]</span><br><span class="line">    y_valid = valid[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line">    <span class="keyword">return</span> X_train,y_train,X_valid,y_valid</span><br><span class="line"></span><br><span class="line"><span class="comment">#把series转换成dataframe</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">series_to_df</span>(<span class="params">predict</span>):</span><br><span class="line">    predictions_series = pd.Series(predict[:,<span class="number">0</span>])</span><br><span class="line">    predictions_df = predictions_series.to_frame()</span><br><span class="line">    predictions_df=predictions_df.rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;house_value&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> predictions_df</span><br><span class="line">    </span><br><span class="line"><span class="comment">#把n*1的series转换成1*n的series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_series</span>(<span class="params">predict</span>):</span><br><span class="line">    s = pd.Series(predict)</span><br><span class="line">    df = s.to_frame()</span><br><span class="line">    <span class="keyword">return</span> df.values</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_m1, valid_m1 = train_val_split(training_data)</span><br><span class="line">train_m2, valid_m2 = train_val_split(training_data)</span><br><span class="line">features=[<span class="string">&#x27;Median_Income&#x27;</span>,<span class="string">&#x27;Distance_to_coast&#x27;</span>,<span class="string">&#x27;bedroom_proportion&#x27;</span>,<span class="string">&#x27;people_house_proportion&#x27;</span>]</span><br><span class="line"><span class="comment">#模型1</span></span><br><span class="line">X_train_m1,y_train_m1,X_valid_m1,y_valid_m1 = divide_datas(train_m1,valid_m1,[<span class="string">&#x27;Median_Income&#x27;</span>])</span><br><span class="line"><span class="comment">#模型2</span></span><br><span class="line">X_train_m2,y_train_m2,X_valid_m2,y_valid_m2 = divide_datas(train_m2,valid_m2,features)</span><br></pre></td></tr></table></figure>
<h3 id="建立线性模型">建立线性模型</h3>
<p><span class="math display">\[
\hat{y}_i = \theta_0 + \theta_1 x_i
\]</span></p>
<p>建立线性回归模型，并可视化预测值的分布与实际分布比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model <span class="keyword">as</span> lm</span><br><span class="line">linear_model_m1 = lm.LinearRegression()</span><br><span class="line">linear_model_m2 = lm.LinearRegression()</span><br><span class="line"><span class="comment"># Fit the 1st model</span></span><br><span class="line">linear_model_m1.fit(X_train_m1, y_train_m1)</span><br><span class="line"><span class="comment"># Compute the fitted and predicted values for 1st model</span></span><br><span class="line">y_predicted_m1 = linear_model_m1.predict(X_valid_m1)</span><br><span class="line">predictions_df=series_to_df(y_predicted_m1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m2.fit(X_train_m2, y_train_m2)</span><br><span class="line">y_fitted_m2 = linear_model_m2.predict(X_train_m2)</span><br><span class="line">y_predicted_m2 = linear_model_m2.predict(X_valid_m2)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m1.score(X_train_m1, y_train_m1)</span><br></pre></td></tr></table></figure>
<pre><code>0.405456747259772</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m2.score(X_train_m2, y_train_m2)</span><br></pre></td></tr></table></figure>
<pre><code>0.5238399282191235</code></pre>
<p>可以看出使用更多特征列的模型二有更好的性能</p>
<h3 id="主成分分析pca">主成分分析（PCA）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">linear_model_m3 = lm.LinearRegression()</span><br><span class="line">train_m3, valid_m3 = train_val_split(training_data)</span><br><span class="line"><span class="comment">#模型3</span></span><br><span class="line">X_train_m3,y_train_m3,X_valid_m3,y_valid_m3 = divide_datas(train_m3,valid_m3,features)</span><br><span class="line"><span class="comment">#对特征数据进行奇异值分解</span></span><br><span class="line">pca = PCA(n_components=<span class="number">4</span>)</span><br><span class="line">pca.fit(X_train_m3)</span><br><span class="line">principal_components = pca.transform(X_train_m3)</span><br><span class="line"></span><br><span class="line">pca.fit(X_valid_m3)</span><br><span class="line">principal_components_valid = pca.transform(X_valid_m3)</span><br><span class="line"><span class="comment">#用PCA处理后的数据来训练模型</span></span><br><span class="line">linear_model_m3.fit(principal_components, y_train_m3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算模型预测的数据</span></span><br><span class="line">y_fitted_m3 = linear_model_m3.predict(principal_components)</span><br><span class="line">y_predicted_m3 = linear_model_m3.predict(principal_components_valid)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m3.score(principal_components, y_train_m3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>0.5185359815322779</code></pre>
<h3 id="正则化">正则化</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#l1正则化模型</span></span><br><span class="line">lasso_model = lm.Lasso(alpha=<span class="number">3</span>)</span><br><span class="line">lasso_model.fit(X_train_m3, y_train_m3)</span><br><span class="line">y_predicted_lasso = lasso_model.predict(X_valid_m3)</span><br><span class="line">y_predicted_lasso=to_series(y_predicted_lasso)</span><br></pre></td></tr></table></figure>
<html>
<head>
<!-- Load require.js. Delete this if your page already loads require.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>
<script type="application/vnd.jupyter.widget-state+json">
{
    "version_major": 2,
    "version_minor": 0,
    "state": {}
}
</script>
</head>
<body>
</body>
</html>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#l2正则化模型</span></span><br><span class="line">ridge_model = lm.Ridge(alpha=<span class="number">3</span>)</span><br><span class="line">ridge_model.fit(X_train_m3, y_train_m3)</span><br><span class="line">y_predicted_ridge = ridge_model.predict(X_valid_m3)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ridge_model.score(X_train_m3, y_train_m3)</span><br></pre></td></tr></table></figure>
<pre><code>0.5177135759219753</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lasso_model.score(X_train_m3, y_train_m3)</span><br></pre></td></tr></table></figure>
<pre><code>0.5185322538476318</code></pre>
<h3 id="决策树模型">决策树模型</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#分类模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line">decision_tree_model = tree.DecisionTreeClassifier(max_depth=<span class="number">50</span>,min_samples_split=<span class="number">4</span>)</span><br><span class="line">decision_tree_model = decision_tree_model.fit(X_train_m3, y_train_m3)</span><br><span class="line">y_predicted_tree=decision_tree_model.predict(X_valid_m3)</span><br><span class="line">y_predicted_tree=to_series(y_predicted_tree)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#回归模型</span></span><br><span class="line">decision_tree_model_regression = tree.DecisionTreeRegressor(criterion=<span class="string">&#x27;absolute_error&#x27;</span>,min_samples_split=<span class="number">3</span>)</span><br><span class="line">decision_tree_model_regression = decision_tree_model_regression.fit(X_train_m3, y_train_m3)</span><br><span class="line">y_predicted_tree_regression=decision_tree_model_regression.predict(X_valid_m3)</span><br><span class="line">y_predicted_tree_regression=to_series(y_predicted_tree_regression)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">decision_tree_model.get_depth()</span><br></pre></td></tr></table></figure>
<pre><code>50</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#随机森林回归模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">forest_model = RandomForestRegressor(criterion=<span class="string">&#x27;absolute_error&#x27;</span>,max_depth=<span class="number">50</span>,random_state=<span class="number">0</span>,min_samples_leaf=<span class="number">3</span>,n_jobs=<span class="number">4</span>)</span><br><span class="line">forest_model = forest_model.fit(principal_components,y_train_m3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_predicted_forest=forest_model.predict(principal_components_valid)</span><br><span class="line">y_predicted_forest=to_series(y_predicted_forest)</span><br></pre></td></tr></table></figure>
<h3 id="k近邻回归">k近邻回归</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line">KE_model=KNeighborsRegressor(n_neighbors=<span class="number">2</span>,weights=<span class="string">&#x27;distance&#x27;</span>) </span><br><span class="line">KE_model=KE_model.fit(X_train_m3,y_train_m3)</span><br><span class="line">y_predicted_ke=KE_model.predict(X_valid_m3)</span><br></pre></td></tr></table></figure>
<h2 id="模型评估">模型评估</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用到的辅助函数：</span></span><br><span class="line"><span class="comment">#误差分析</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rmse</span>(<span class="params">predicted, actual</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.mean((actual - predicted)**<span class="number">2</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mae</span>(<span class="params">predicted,actual</span>):</span><br><span class="line">    <span class="keyword">return</span> np.mean(np.<span class="built_in">abs</span>(predicted - actual))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">preditcted,actual,num=<span class="number">500</span></span>):</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">abs</span>(preditcted - actual)&lt;=num).mean().mean()</span><br><span class="line"></span><br><span class="line"><span class="comment">#用以上三个误差评估函数评估预测数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_model</span>(<span class="params">predicted,valid,num=<span class="number">500</span></span>):</span><br><span class="line">    rmse_val = rmse(predicted, valid)</span><br><span class="line">    mae_val = mae(predicted,valid)</span><br><span class="line">    accuracy_val = accuracy(predicted,valid,num)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;rmse&#x27;</span>: rmse_val, <span class="string">&#x27;mae&#x27;</span>: mae_val, <span class="string">&#x27;accuracy&#x27;</span> : accuracy_val&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算出最后结果，存储到df</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_result</span>(<span class="params">predicts,df</span>):</span><br><span class="line">    <span class="keyword">for</span> predict <span class="keyword">in</span> predicts:</span><br><span class="line">        df.loc[<span class="built_in">len</span>(df)] = evaluate_model(predict, y_valid_m3,<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出误差散点图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scatter_plot</span>(<span class="params">predict,actual,name</span>):</span><br><span class="line">    residuals = <span class="built_in">abs</span>(predict - actual)</span><br><span class="line">    plt.scatter(predict, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Sale Price&#x27;</span>) </span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Residuals vs. Sale Price for &#x27;</span>+name)</span><br><span class="line">    ax=axs[<span class="number">1</span>]</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出预测结果和验证集的分布图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">two_x_histplot</span>(<span class="params">df1,df2,col1,col2</span>):</span><br><span class="line">    min_value = <span class="built_in">min</span>(df1[col1].<span class="built_in">min</span>(), df2[col2].<span class="built_in">min</span>())</span><br><span class="line">    max_value = <span class="built_in">max</span>(df1[col1].<span class="built_in">max</span>(), df2[col2].<span class="built_in">max</span>())</span><br><span class="line">    bins = np.linspace(min_value, max_value, <span class="number">50</span>)</span><br><span class="line">    sns.histplot(data=df1, x=col1, alpha=<span class="number">0.5</span>,bins=bins,color=<span class="string">&#x27;#66ccff&#x27;</span>)</span><br><span class="line">    sns.histplot(data=df2, x=col2, alpha=<span class="number">0.3</span>,bins=bins,color=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    ax=axs[<span class="number">0</span>]</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最终结果汇总</span></span><br><span class="line">results = pd.DataFrame(columns=[<span class="string">&#x27;rmse&#x27;</span>, <span class="string">&#x27;mae&#x27;</span>, <span class="string">&#x27;accuracy&#x27;</span>]) </span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_m1, y_valid_m1,<span class="number">10000</span>)</span><br><span class="line">results.loc[<span class="built_in">len</span>(results)] = evaluate_model(y_predicted_m2, y_valid_m2,<span class="number">10000</span>)</span><br><span class="line">pres=[y_predicted_m3,y_predicted_lasso,y_predicted_ridge,y_predicted_tree,y_predicted_tree_regression,y_predicted_forest,y_predicted_ke]</span><br><span class="line">results=make_result(pres,results)</span><br><span class="line">results.index=[<span class="string">&#x27;lm_model1&#x27;</span>,<span class="string">&#x27;lm_model2&#x27;</span>,<span class="string">&#x27;lm_pca_model3&#x27;</span>,<span class="string">&#x27;lasso&#x27;</span>,<span class="string">&#x27;ridge&#x27;</span>,<span class="string">&#x27;tree&#x27;</span>,<span class="string">&#x27;tree_regression&#x27;</span>,<span class="string">&#x27;forest_regression&#x27;</span>,<span class="string">&#x27;K_neighbours&#x27;</span>]</span><br><span class="line">results</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rmse
</th>
<th>
mae
</th>
<th>
accuracy
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
lm_model1
</th>
<td>
60922.482902
</td>
<td>
48571.055228
</td>
<td>
0.135648
</td>
</tr>
<tr>
<th>
lm_model2
</th>
<td>
56846.626574
</td>
<td>
43979.354330
</td>
<td>
0.160608
</td>
</tr>
<tr>
<th>
lm_pca_model3
</th>
<td>
55342.558354
</td>
<td>
43704.366177
</td>
<td>
0.154097
</td>
</tr>
<tr>
<th>
lasso
</th>
<td>
55311.818220
</td>
<td>
43551.728305
</td>
<td>
0.150841
</td>
</tr>
<tr>
<th>
ridge
</th>
<td>
55434.380284
</td>
<td>
43656.940158
</td>
<td>
0.150841
</td>
</tr>
<tr>
<th>
tree
</th>
<td>
77547.042415
</td>
<td>
58941.074335
</td>
<td>
0.141617
</td>
</tr>
<tr>
<th>
tree_regression
</th>
<td>
73484.094196
</td>
<td>
56195.496473
</td>
<td>
0.127509
</td>
</tr>
<tr>
<th>
forest_regression
</th>
<td>
52955.981209
</td>
<td>
40886.882257
</td>
<td>
0.170917
</td>
</tr>
<tr>
<th>
K_neighbours
</th>
<td>
74706.010594
</td>
<td>
52427.281809
</td>
<td>
0.204558
</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#误差可视化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pres)):</span><br><span class="line">    names=[<span class="string">&#x27;lm_model1&#x27;</span>,<span class="string">&#x27;lm_model2&#x27;</span>,<span class="string">&#x27;lm_pca_model3&#x27;</span>,<span class="string">&#x27;lasso&#x27;</span>,<span class="string">&#x27;ridge&#x27;</span>,<span class="string">&#x27;tree&#x27;</span>,<span class="string">&#x27;tree_regression&#x27;</span>,<span class="string">&#x27;forest_regression&#x27;</span>,<span class="string">&#x27;K_neighbours&#x27;</span>]</span><br><span class="line">    scatter_plot(pres[i],y_valid_m3,names[i])</span><br><span class="line">    two_x_histplot(series_to_df(pres[i]),y_valid_m3,<span class="string">&quot;house_value&quot;</span>,<span class="string">&quot;Median_House_Value&quot;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="/assets/myproj3/output_71_0.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_1.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_2.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_3.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_4.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_5.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_6.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_7.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_8.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_9.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_10.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_11.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_12.png" alt="" /><figcaption>png</figcaption>
</figure>
<figure>
<img src="/assets/myproj3/output_71_13.png" alt="" /><figcaption>png</figcaption>
</figure>
<h3 id="交叉验证">交叉验证</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_predict</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross_validation</span>(<span class="params">mls,is_series</span>):</span><br><span class="line">    result_df=pd.DataFrame(columns=[<span class="string">&#x27;rmse&#x27;</span>, <span class="string">&#x27;mae&#x27;</span>, <span class="string">&#x27;accuracy&#x27;</span>]) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(models)):</span><br><span class="line">        predicted=cross_val_predict(mls[i], X_train_m3, y_train_m3, cv=<span class="number">10</span>,n_jobs=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (is_series[i]): predicted=to_series(predicted)</span><br><span class="line">        result_df.loc[<span class="built_in">len</span>(result_df)]=evaluate_model(predicted, y_train_m3,<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">return</span> result_df</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_model_m1 = lm.LinearRegression()</span><br><span class="line">models=[linear_model_m3,lasso_model,ridge_model,decision_tree_model,decision_tree_model_regression,forest_model,KE_model]</span><br><span class="line">tf=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">cross_results=cross_validation(models,tf)</span><br><span class="line">cross_results.index=[<span class="string">&#x27;lm_model&#x27;</span>,<span class="string">&#x27;lasso&#x27;</span>,<span class="string">&#x27;ridge&#x27;</span>,<span class="string">&#x27;tree&#x27;</span>,<span class="string">&#x27;tree_regression&#x27;</span>,<span class="string">&#x27;forest_regression&#x27;</span>,<span class="string">&#x27;K_neighbours&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cross_results</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rmse
</th>
<th>
mae
</th>
<th>
accuracy
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
lm_model
</th>
<td>
55984.041030
</td>
<td>
43744.485025
</td>
<td>
0.150611
</td>
</tr>
<tr>
<th>
lasso
</th>
<td>
55984.270526
</td>
<td>
43748.196798
</td>
<td>
0.151018
</td>
</tr>
<tr>
<th>
ridge
</th>
<td>
56032.724551
</td>
<td>
43836.923361
</td>
<td>
0.149661
</td>
</tr>
<tr>
<th>
tree
</th>
<td>
76236.606876
</td>
<td>
58051.316147
</td>
<td>
0.139620
</td>
</tr>
<tr>
<th>
tree_regression
</th>
<td>
75482.497313
</td>
<td>
56896.289009
</td>
<td>
0.147083
</td>
</tr>
<tr>
<th>
forest_regression
</th>
<td>
53620.108361
</td>
<td>
40894.203324
</td>
<td>
0.174763
</td>
</tr>
<tr>
<th>
K_neighbours
</th>
<td>
76776.253905
</td>
<td>
55102.977787
</td>
<td>
0.192130
</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>基于mit6.006的作业解析</title>
    <url>/thinklive/8605/</url>
    <content><![CDATA[<h1 id="hw1">hw1</h1>
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<p>对这种形式的函数可以这样比较</p>
<p><span class="math display">\[f_1=n^{\sqrt{n}}=(2^{lgn})^{\sqrt{n}}\]</span> <span class="math display">\[f_2=n^{10}.2^{n/2}=2^{lg(10n)+n/2}\]</span></p>
<h2 id="复杂度计算">复杂度计算</h2>
<p>对于T(n,n): T (x, y) = Θ(x + y) + T (x/2, y/2). 化成</p>
<p><img src="/assets/mit6.006作业解析/image-20231120213425020.png" /></p>
<p>得到θ(n) <span id="more"></span></p>
<p>T (x, y) = Θ(x) + T (x, y/2). 等于lgy个θ(x) 即，θ(nlgn)</p>
<p>T (x, y) = Θ(x) + S(x, y/2), S(x, y) = Θ(y) + T (x/2, y).</p>
<p>化成T (x, y) = Θ(x) + Θ(y/2) + T (x/2, y/2). 与第一个例子相似，θ(n)</p>
<h2 id="寻峰算法">寻峰算法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm1</span>(<span class="params">problem, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># the recursive subproblem will involve half the number of columns</span></span><br><span class="line">    mid = problem.numCol // <span class="number">2</span></span><br><span class="line">    <span class="comment"># information about the two subproblems</span></span><br><span class="line">    (subStartR, subNumR) = (<span class="number">0</span>, problem.numRow)</span><br><span class="line">    (subStartC1, subNumC1) = (<span class="number">0</span>, mid)</span><br><span class="line">    (subStartC2, subNumC2) = (mid + <span class="number">1</span>, problem.numCol - (mid + <span class="number">1</span>))</span><br><span class="line">    subproblems = []</span><br><span class="line">    subproblems.append((subStartR, subStartC1, subNumR, subNumC1))</span><br><span class="line">    subproblems.append((subStartR, subStartC2, subNumR, subNumC2))</span><br><span class="line">    <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">    divider = crossProduct(<span class="built_in">range</span>(problem.numRow), [mid])</span><br><span class="line">    <span class="comment"># find the maximum in the dividing column</span></span><br><span class="line">    bestLoc = problem.getMaximum(divider, trace)</span><br><span class="line">    <span class="comment"># see if the maximum value we found on the dividing line has a better</span></span><br><span class="line">    <span class="comment"># neighbor (which cannot be on the dividing line, because we know that</span></span><br><span class="line">    <span class="comment"># this location is the best on the dividing line)</span></span><br><span class="line">    neighbor = problem.getBetterNeighbor(bestLoc, trace)</span><br><span class="line">    <span class="comment"># this is a peak, so return it</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == bestLoc:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(bestLoc)</span><br><span class="line">        <span class="keyword">return</span> bestLoc</span><br><span class="line">    <span class="comment"># otherwise, figure out which subproblem contains the neighbor, and</span></span><br><span class="line">    <span class="comment"># recurse in that half</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, neighbor)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm1(sub, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm2</span>(<span class="params">problem, location = (<span class="params"><span class="number">0</span>, <span class="number">0</span></span>), trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    nextLocation = problem.getBetterNeighbor(location, trace)</span><br><span class="line">    <span class="keyword">if</span> nextLocation == location:</span><br><span class="line">        <span class="comment"># there is no better neighbor, so return this peak</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(location)</span><br><span class="line">        <span class="keyword">return</span> location</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># there is a better neighbor, so move to the neighbor and recurse</span></span><br><span class="line">        <span class="keyword">return</span> algorithm2(problem, nextLocation, trace)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm3</span>(<span class="params">problem, bestSeen = <span class="literal">None</span>, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    midRow = problem.numRow // <span class="number">2</span></span><br><span class="line">    midCol = problem.numCol // <span class="number">2</span></span><br><span class="line">    <span class="comment"># first, get the list of all subproblems</span></span><br><span class="line">    subproblems = []</span><br><span class="line">    (subStartR1, subNumR1) = (<span class="number">0</span>, midRow)</span><br><span class="line">    (subStartR2, subNumR2) = (midRow + <span class="number">1</span>, problem.numRow - (midRow + <span class="number">1</span>))</span><br><span class="line">    (subStartC1, subNumC1) = (<span class="number">0</span>, midCol)</span><br><span class="line">    (subStartC2, subNumC2) = (midCol + <span class="number">1</span>, problem.numCol - (midCol + <span class="number">1</span>))</span><br><span class="line">    subproblems.append((subStartR1, subStartC1, subNumR1, subNumC1))</span><br><span class="line">    subproblems.append((subStartR1, subStartC2, subNumR1, subNumC2))</span><br><span class="line">    subproblems.append((subStartR2, subStartC1, subNumR2, subNumC1))</span><br><span class="line">    subproblems.append((subStartR2, subStartC2, subNumR2, subNumC2))</span><br><span class="line">    <span class="comment"># find the best location on the cross (the middle row combined with the</span></span><br><span class="line">    <span class="comment"># middle column)</span></span><br><span class="line">    cross = []</span><br><span class="line">    cross.extend(crossProduct([midRow], <span class="built_in">range</span>(problem.numCol)))</span><br><span class="line">    cross.extend(crossProduct(<span class="built_in">range</span>(problem.numRow), [midCol]))</span><br><span class="line">    crossLoc = problem.getMaximum(cross, trace)</span><br><span class="line">    neighbor = problem.getBetterNeighbor(crossLoc, trace)</span><br><span class="line">    <span class="comment"># update the best we&#x27;ve seen so far based on this new maximum</span></span><br><span class="line">    <span class="keyword">if</span> bestSeen <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> problem.get(neighbor) &gt; problem.get(bestSeen):</span><br><span class="line">        bestSeen = neighbor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setBestSeen(bestSeen)</span><br><span class="line">    <span class="comment"># return if we can&#x27;t see any better neighbors</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == crossLoc:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(crossLoc)</span><br><span class="line">        <span class="keyword">return</span> crossLoc</span><br><span class="line">    <span class="comment"># figure out which subproblem contains the largest number we&#x27;ve seen so</span></span><br><span class="line">    <span class="comment"># far, and recurse</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, bestSeen)</span><br><span class="line">    newBest = sub.getLocationInSelf(problem, bestSeen)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm3(sub, newBest, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm4</span>(<span class="params">problem, bestSeen = <span class="literal">None</span>, rowSplit = <span class="literal">True</span>, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    subproblems = []</span><br><span class="line">    divider = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> rowSplit:</span><br><span class="line">        <span class="comment"># the recursive subproblem will involve half the number of rows</span></span><br><span class="line">        mid = problem.numRow // <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># information about the two subproblems</span></span><br><span class="line">        (subStartR1, subNumR1) = (<span class="number">0</span>, mid)</span><br><span class="line">        (subStartR2, subNumR2) = (mid + <span class="number">1</span>, problem.numRow - (mid + <span class="number">1</span>))</span><br><span class="line">        (subStartC, subNumC) = (<span class="number">0</span>, problem.numCol)</span><br><span class="line">  </span><br><span class="line">        subproblems.append((subStartR1, subStartC, subNumR1, subNumC))</span><br><span class="line">        subproblems.append((subStartR2, subStartC, subNumR2, subNumC))</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">        divider = crossProduct([mid], <span class="built_in">range</span>(problem.numCol))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># the recursive subproblem will involve half the number of columns</span></span><br><span class="line">        mid = problem.numCol // <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># information about the two subproblems</span></span><br><span class="line">        (subStartR, subNumR) = (<span class="number">0</span>, problem.numRow)</span><br><span class="line">        (subStartC1, subNumC1) = (<span class="number">0</span>, mid)</span><br><span class="line">        (subStartC2, subNumC2) = (mid + <span class="number">1</span>, problem.numCol - (mid + <span class="number">1</span>))</span><br><span class="line">  </span><br><span class="line">        subproblems.append((subStartR, subStartC1, subNumR, subNumC1))</span><br><span class="line">        subproblems.append((subStartR, subStartC2, subNumR, subNumC2))</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">        divider = crossProduct(<span class="built_in">range</span>(problem.numRow), [mid])</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># find the maximum in the dividing row or column</span></span><br><span class="line">    bestLoc = problem.getMaximum(divider, trace)</span><br><span class="line">    neighbor = problem.getBetterNeighbor(bestLoc, trace)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># update the best we&#x27;ve seen so far based on this new maximum</span></span><br><span class="line">    <span class="keyword">if</span> bestSeen <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> problem.get(neighbor) &gt; problem.get(bestSeen):</span><br><span class="line">        bestSeen = neighbor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setBestSeen(bestSeen)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># return when we know we&#x27;ve found a peak</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == bestLoc <span class="keyword">and</span> problem.get(bestLoc) &gt;= problem.get(bestSeen):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(bestLoc)</span><br><span class="line">        <span class="keyword">return</span> bestLoc</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># figure out which subproblem contains the largest number we&#x27;ve seen so</span></span><br><span class="line">    <span class="comment"># far, and recurse, alternating between splitting on rows and splitting</span></span><br><span class="line">    <span class="comment"># on columns</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, bestSeen)</span><br><span class="line">    newBest = sub.getLocationInSelf(problem, bestSeen)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm4(sub, newBest, <span class="keyword">not</span> rowSplit, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br></pre></td></tr></table></figure>
<p>算法一二如课程笔记所述，均是正确的，以下是证明</p>
<ul>
<li>algo1</li>
</ul>
<ol type="1">
<li>证明算法不可能返回一个空值，首先算法不可能得到一个负索引的子数组（在只有一列的时候必然会得到结果而不是继续划分），在最小问题的情况下，如果此时子问题有一列，那么必然返回一个峰值，如果有两列，不管目前讨论的列是不是最大值，都会递归成最小为1为列的子问题，不会返回空值</li>
<li>证明返回的位置确实是峰值位置，如果算法1返回一个位置（r1，c1），则该位置必须具有列c1中的最大值，并且必须是某个递归子问题中的峰值。为了推导矛盾，假设（r1，c1）不是原始问题中的峰值。在某个子问题中，位置（r1，c1）与列c2相邻（|c1 - c2| = 1），并且值必须满足不等式val（r1，c1）&lt; val（r1，c2）。<br />
让（r2，c2）是算法1在c2列中找到的最大值的位置。因此，必定有val（r1，c2）≤ val（r2，c2）。因为c2是分割线，且算法选择在包含（r1，c1）的一半上进行递归，所以我们知道val（r2，c2）&lt; val（r2，c1）。因此，我们有以下不等式链：<br />
val（r1，c1）&lt; val（r1，c2）≤ val（r2，c2）&lt; val（r2，c1）<br />
但是，为了使算法1将（r1，c1）作为峰值返回，（r1，c1）处的值必须是其列中的最大值，即val（r1，c1）≥ val（r2，c1）。因此，我们得到了一个矛盾。</li>
</ol>
<ul>
<li>algo3是错误的</li>
</ul>
<p>时间复杂度是θ(n)，情况类似复杂度题目的第一个情况，1+1/2+1/4……</p>
<p><strong>反例</strong></p>
<p>如图所示的反例会选择返回一个在当前子问题中看起来像一个峰值，但是与子问题外部的某个更大值相邻的位置</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>0</th>
<th>9</th>
<th>8</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>对算法四的证明</p>
<ul>
<li>algo4</li>
</ul>
<p>时间复杂度是θ(n),类似算法3</p>
<p>算法四交叉进行行和列的最大值寻找</p>
<ol type="1">
<li>如果峰值问题不为空，则算法将始终返回一个位置。在算法中，根据是在行还是列上分割，递归子问题的维度会相应地减少。所以算法要么在某个时刻停止并返回一个位置，要么最终检查一个行数或列数为非正的子问题。但是，问题的行数或列数变为严格负数的唯一方式是在某个时刻m=0或n=0。因此，如果算法没有返回位置，它必定最终检查一个空的子问题。然而，证明假设该情况不会发生。</li>
<li>如果算法返回一个位置，则该位置将是原始问题中的一个峰值。如果算法返回一个位置(r1, c1)，那么该位置必定是某个递归子问题中的峰值。另外，如果(r2, c2)是算法执行过程中的最佳位置（存储在bestSeen变量中的位置），那么必定满足val(r1, c1) ≥ val(r2, c2)。证明假设(r1, c1)不是原始问题的峰值。那么当位置(r1, c1)通过递归调用链向上传递时，它必定在某个级别停止是不是峰值。因此，必定存在一个包含位置(r1, c1)的子问题，在该级别中，该子问题的某个邻居(r3, c3)的值满足val(r1, c1) &lt; val(r3, c3)。对于(r3, c3)既是递归子问题的邻居又不包含在子问题中，它必定在算法的执行过程中被检查过。因此，必定满足val(r3, c3) ≤ val(r2, c2)。因此，我们得到以下不等式链：val(r1, c1) &lt; val(r3, c3) ≤ val(r2, c2) ≤ val(r1, c1)。这导致了矛盾。</li>
</ol>
<h1 id="hw2">hw2</h1>
<h2 id="科赫雪花">科赫雪花</h2>
<figure>
<embed src="/game/fractal.html" /><figcaption>简单的演示</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SNOWFLAKE(n)</span><br><span class="line"> e1, e2, e3 = edges of an equilateral triangle with side length 1</span><br><span class="line"> SNOWFLAKE-EDGE(e1, n)</span><br><span class="line"> SNOWFLAKE-EDGE(e2, n)</span><br><span class="line"> SNOWFLAKE-EDGE(e3, n)</span><br><span class="line">SNOWFLAKE-EDGE(edge, n)</span><br><span class="line"> if n = = 0</span><br><span class="line">  edge is an edge on the snowflake</span><br><span class="line"> else</span><br><span class="line">  e1, e2, e3 = split edge in 3 equal parts</span><br><span class="line"> SNOWFLAKE-EDGE(e1, n − 1)</span><br><span class="line"> f2, g2 = edges of an equilateral triangle whose 3rd edge is e2, pointing outside the snowflake</span><br><span class="line"> ∆(f2, g2, e2) is a triangle on the snowflake’s surface</span><br><span class="line"> SNOWFLAKE-EDGE(f2, n − 1)</span><br><span class="line"> SNOWFLAKE-EDGE(g2, n − 1)</span><br><span class="line"> SNOWFLAKE-EDGE(e3, n − 1)</span><br></pre></td></tr></table></figure>
<p>从主函数（层数视为-1)开始对每条边进行处理，这一层有三个节点。 而对边处理的函数则遵从这样的流程</p>
<ol type="1">
<li>把边等分成三个部分e1,e2,e3</li>
<li>对e1进行递归</li>
<li>以e2为一条边向外侧生成一个等边三角形，f2,g2是这个三角形的另外两条边</li>
<li>以此对f2,g2,e3进行递归 函数实际上把一条边拓展出了一个三角形 因此第i层的节点数是:<span class="math display">\[3*4^i\]</span> <img src="/assets/mit6.006作业解析/image-20231122203735331.png" /></li>
</ol>
<h3 id="d-硬件加速渲染">3D 硬件加速渲染</h3>
<p>在这种渲染方式中，cpu计算分解出的三角形顶点的集合，发给gpu进行绘制，因此cpu的执行时间只取决于分解出的三角形数量，也就是θ(4^n)</p>
<h3 id="d-硬件加速渲染-1">2D 硬件加速渲染</h3>
<p>在这种渲染方式中，cpu实际上只计算不断分割出的线段集合，在本题中就是计算最外侧的轮廓的顶点的集合，计算结束后发给gpu绘制 时间复杂度依旧是θ(4^n)，但需要注意的是由于计算完了才开始渲染，因此递归树的中间节点不会对渲染产生时间消耗</p>
<h3 id="软件渲染">软件渲染</h3>
<p>在没有硬件加速器的2D渲染（也称为软件渲染）中，CPU 像上一部分一样，为每个路径编译一个线段列表，但它也负责 用于“光栅化”每个线段。 光栅化获取线段端点的坐标 并计算位于线段上的所有像素的坐标。 用这些像素在显示器上绘制线段。光栅化算法在时间上的消耗与线段的长度成正比，线段上的像素数量与线段的长度成正比。 在整个问题中，假设所有线段的长度至少为一个像素，因此 光栅化的成本大于编译线段的成本。 需要注意的是：</p>
<ol type="1">
<li>中间节点依旧对渲染无影响</li>
<li>由于每次对边处理实际上增加了该边1/3的像素点，所以最后一层产生的代价是<span class="math display">\[θ({(1/3)}^n)\]</span></li>
<li>同理，总渲染代价和cpu处理（只处理像素点）的时间复杂度都是<span class="math display">\[θ({(4/3)}^n)\]</span></li>
</ol>
<h3 id="没有硬件加速的-3d-渲染">没有硬件加速的 3D 渲染</h3>
<p>在这种情况下， CPU 编译三角形列表，然后光栅化每个三角形。 我们知道一种算法 栅格化一个三角形，其运行时间与三角形的表面积成正比。三角形内的像素数量与三角形的面积成正比。可以假设边长为 l 的三角形的面积为 θ(l^2)。 顺着递归树进行分析，首层只增加了三个节点，每个新节点对应一个边长是原边长1/3的新三角形，增加了1/3的面积，之后的每一层都有4^i个节点，对应4/9的面积增长，即每层的增长是 <span class="math display">\[\frac{1}{3}.\frac{4}{9}^i\]</span> 可以用等比数列的求和算出答案，但时间复杂度必然是θ(1)</p>
<h2 id="电路模拟">电路模拟</h2>
<p><img src="/assets/mit6.006作业解析/image-20231124185516359.png" /> 如图是对一个异或门的模拟，两个输入端AB产生的信号会在2ns的延迟后在输出端产生一个结果，除此以外没有延迟 按照题意运行<code>python -m cProfile -s time circuit.py &lt; tests/5devadas13.in</code> 得到如下结果（不完全），可以看到消耗最多时间的是lt(lower than)和find_min两个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">625762426  319.980    0.000  319.980    0.000 circuit.py:286(__lt__)</span><br><span class="line">   259964  315.431    0.001  635.431    0.002 circuit.py:381(_find_min)</span><br><span class="line">    64400    1.371    0.000  639.636    0.010 circuit.py:423(step)</span><br><span class="line">828793/634381    0.463    0.000    0.612    0.000 &#123;built-in method builtins.len&#125;</span><br><span class="line">   194381    0.421    0.000  635.865    0.003 circuit.py:361(min)</span><br><span class="line">    32768    0.352    0.000    0.352    0.000 &#123;method &#x27;write&#x27; of &#x27;_io.TextIOWrapper&#x27; objects&#125;</span><br><span class="line">    65554    0.309    0.000    0.723    0.000 circuit.py:163(transition_output)</span><br><span class="line">        1    0.290    0.290  640.116  640.116 circuit.py:456(run)</span><br></pre></td></tr></table></figure>
<p>随后题意要求基于原来的api实现一个优先队列(最小堆)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Array-based priority queue implementation.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initially empty priority queue.&quot;&quot;&quot;</span></span><br><span class="line">        self.queue = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leftchid</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*key+<span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightchild</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*key+<span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> (key-<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">self,key1,key2</span>):</span><br><span class="line">        temp=self.queue[key2]</span><br><span class="line">        self.queue[key2]=self.queue[key1]</span><br><span class="line">        self.queue[key1]=temp</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Number of elements in the queue.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sift_up</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            p=self.parent(key)</span><br><span class="line">            <span class="keyword">if</span> (p&lt;<span class="number">0</span> <span class="keyword">or</span> self.queue[p]&lt;=self.queue[key]):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.swap(p,key)</span><br><span class="line">                key=p</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Inserts an element in the priority queue.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Cannot insert None in the queue&#x27;</span>)</span><br><span class="line">        self.queue.append(key)</span><br><span class="line">        self.sift_up(self.__len__()-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;The smallest element in the queue.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            lft,rht = self.leftchid(key),self.rightchild(key)</span><br><span class="line">            min_key=key</span><br><span class="line">            <span class="keyword">if</span> (lft&lt;self.__len__() <span class="keyword">and</span> self.queue[lft]&lt;self.queue[key]):</span><br><span class="line">                min_key=lft</span><br><span class="line">            <span class="keyword">if</span> (rht&lt;self.__len__() <span class="keyword">and</span> self.queue[rht]&lt;self.queue[min_key]):</span><br><span class="line">                min_key=rht</span><br><span class="line">            <span class="keyword">if</span> (min_key==key): <span class="keyword">break</span></span><br><span class="line">            self.swap(min_key,key)</span><br><span class="line">            key =min_key</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Removes the minimum element in the queue.</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            The value of the removed element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.swap(<span class="number">0</span>,self.__len__()-<span class="number">1</span>)</span><br><span class="line">        min_val=self.queue.pop(self.__len__()-<span class="number">1</span>)</span><br><span class="line">        self.sift_down(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> min_val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_find_min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Computes the index of the minimum element in the queue.</span></span><br><span class="line">        <span class="comment"># This method may crash if called when the queue is empty.</span></span><br><span class="line">        <span class="keyword">if</span> self.__len__==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;cannot find min of empty queue&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>python3可以运行所有测试，但无法运行可视化程序，不过也无所谓了，优化后再次运行一开始的输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">    65583    2.826    0.000    5.321    0.000 circuit.py:389(sift_down)</span><br><span class="line">    65583    1.006    0.000    1.901    0.000 circuit.py:366(sift_up)</span><br><span class="line">  1930321    0.807    0.000    1.109    0.000 circuit.py:362(__len__)</span><br><span class="line">  1349048    0.772    0.000    0.772    0.000 circuit.py:357(swap)</span><br><span class="line">  1432334    0.719    0.000    0.719    0.000 circuit.py:286(__lt__)</span><br><span class="line">    64400    0.698    0.000    9.608    0.000 circuit.py:451(step)</span><br><span class="line">2450781/2256369    0.473    0.000    0.567    0.000 &#123;built-in method builtins.len&#125;</span><br></pre></td></tr></table></figure>
<p>问题解决了,amdtel的offer什么时候发？</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据结构与算法</tag>
        <tag>麻省理工</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利ds100的数据科学笔记pandas部分</title>
    <url>/thinklive/15575/</url>
    <content><![CDATA[<h2 id="notebook">notebook</h2>
<ol type="1">
<li><code>Ctrl</code> + <code>Return</code>（或者 <code>Cmd</code> + <code>Return</code>在 Mac 上）： <em>评估当前单元格</em></li>
<li><code>Shift</code> + <code>Return</code>： <em>评估当前单元格并移至下一个单元格</em></li>
<li><code>ESC</code>： <em>命令模式</em> （在使用以下任何命令之前可能需要按）</li>
<li><code>a</code>: <em>在上面创建一个单元格</em></li>
<li><code>b</code>： <em>在下面创建一个单元格</em></li>
<li><code>dd</code>: <em>删除一个单元格</em></li>
<li><code>z</code>： <em>撤消上一次单元格操作</em></li>
<li><code>m</code>： <em>将单元格转换为 Markdown</em></li>
<li><code>y</code>： <em>将单元格转换为代码</em> <span id="more"></span></li>
</ol>
<h2 id="pandas">pandas</h2>
<h3 id="创建表格dataframe">创建表格DataFrame</h3>
<p>按列创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info = pd.DataFrame(</span><br><span class="line">    data = &#123;&#x27;fruit&#x27;: [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;raspberry&#x27;],</span><br><span class="line">          &#x27;color&#x27;: [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;pink&#x27;],</span><br><span class="line">          &#x27;price&#x27;: [1.0, 0.75, 0.35, 0.05]</span><br><span class="line">          &#125;)</span><br><span class="line">fruit_info</span><br></pre></td></tr></table></figure>
<p>按行创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info2 = pd.DataFrame(</span><br><span class="line">    [(&quot;red&quot;, &quot;apple&quot;, 1.0), (&quot;orange&quot;, &quot;orange&quot;, 0.75), (&quot;yellow&quot;, &quot;banana&quot;, 0.35),</span><br><span class="line">     (&quot;pink&quot;, &quot;raspberry&quot;, 0.05)], </span><br><span class="line">    columns = [&quot;color&quot;, &quot;fruit&quot;, &quot;price&quot;])</span><br></pre></td></tr></table></figure>
<h3 id="选择行和列">选择行和列</h3>
<ul>
<li>loc 两个详细运算符中的第一个是 <code>loc</code>，它需要两个参数。 第一个是一个或多个行 <strong>标签</strong> ，第二个是一个或多个列 <strong>标签</strong> 。</li>
</ul>
<p>所需的行或列可以单独提供、以切片表示法或作为列表提供。 单独提供会返回series 单独切片参数默认返回行</p>
<p><img src="/assets/jupyter%20notbook/image-20230924084033386.png" /> <img src="/assets/jupyter%20notbook/image-20230924084006924.png" /> <img src="/assets/jupyter%20notbook/image-20230924084050655.png" /> ● loc selects items by label. First argument is rows, second argument is columns. ● iloc selects items by number. First argument is rows, second argument is columns. ● [] only takes one argument, which may be: ○ A slice of row numbers. ○ A list of column labels. ○ A single column label. That is,[] is context sensitive.</p>
<ul>
<li>列名一般唯一，可以强制重复</li>
<li>行名可以重复 pandas支持裸操作,但此时无法使用切片</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Here we&#x27;re providing a list of fruits as single argument to []</span><br><span class="line">fruit_info[[&quot;fruit&quot;, &quot;color&quot;, &quot;price&quot;]]</span><br></pre></td></tr></table></figure>
<h3 id="其他行列操作">其他行列操作</h3>
<p>添加行和列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info[&#x27;rank1&#x27;] = [1,2,3,4]</span><br><span class="line">fruit_info.loc[:,&#x27;rank2&#x27;] = [1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>使用 <code>.drop()</code>方法来 <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html">删除</a> 这两个 <code>rank1</code>和 <code>rank2</code>您创建的列。 确保使用 <code>axis</code>参数正确。 注意 <code>drop</code>不会更改表，而是返回一个具有较少列或行的新表，除非您设置可选 <code>inplace</code>范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info</span><br><span class="line">fruit_info_original = fruit_info.drop([&#x27;rank1&#x27;,&#x27;rank2&#x27;],axis=1)</span><br><span class="line">fruit_info_original</span><br></pre></td></tr></table></figure>
<p>重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruit_info_caps=fruit_info_original.rename(columns=&#123;&#x27;fruit&#x27;:&#x27;F&#x27;,&#x27;color&#x27;:&#x27;C&#x27;,&#x27;price&#x27;:&#x27;P&#x27;&#125;)</span><br><span class="line">fruit_info_caps</span><br></pre></td></tr></table></figure>
<h3 id="布尔数组筛选和查询">布尔数组筛选和查询</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = baby_names[(baby_names[&#x27;Year&#x27;]==2000) &amp; (baby_names[&#x27;Count&#x27;]&gt;3000)]</span><br><span class="line">result_using_query = baby_names.query(&#x27;Year==2000 &amp; Count&gt;3000&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="slides实例">slides实例</h3>
<p>提取列数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections[&quot;Candidate&quot;].tail(5).to_frame()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提取目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For row labels, use DataFrame.index:</span><br><span class="line">For column labels, use DataFrame.columns:</span><br></pre></td></tr></table></figure>
<p>支持布尔数组检索 <img src="/assets/jupyter%20notbook/image-20230924090511103.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections[elections[&quot;Party&quot;] == &quot;Independent&quot;]</span><br><span class="line">elections[(elections[&quot;Result&quot;] == &quot;win&quot;) &amp; (elections[&quot;%&quot;] &lt; 47)]</span><br></pre></td></tr></table></figure>
<p>支持用其他数组检索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a_parties = [&quot;Anti-Masonic&quot;, &quot;American&quot;, &quot;Anti-Monopoly&quot;, &quot;American Independent&quot;]</span><br><span class="line">elections[elections[&quot;Party&quot;].isin(a_parties)]</span><br></pre></td></tr></table></figure>
<p>查询类似sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elections.query(&#x27;Result == &quot;win&quot; and Party not in @parties&#x27;)</span><br></pre></td></tr></table></figure>
<p>匿名函数辅助查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What if we wanted to find the longest names in California?</span><br><span class="line">babynames.query(&#x27;Sex == &quot;M&quot; and Year == 2020&#x27;)</span><br><span class="line">.sort_values(&quot;Name&quot;, key = lambda x: x.str.len(),</span><br><span class="line">ascending = False)</span><br></pre></td></tr></table></figure>
<p>创建删除列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">babyname_lengths = babynames[&quot;Name&quot;].str.len()</span><br><span class="line">#add that series to the dataframe as a column</span><br><span class="line">babynames[&quot;name_lengths&quot;] = babyname_lengths</span><br><span class="line">babynames = babynames.sort_values(by = &quot;name_lengths&quot;, ascending=False)</span><br><span class="line">babynames = babynames.drop(&quot;name_lengths&quot;, axis = &#x27;columns&#x27;)//删除列(默认为行)</span><br></pre></td></tr></table></figure>
<p>map方法使用函数统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def dr_ea_count(string):</span><br><span class="line">return string.count(&#x27;dr&#x27;) + string.count(&#x27;ea&#x27;)</span><br><span class="line">babynames[&quot;dr_ea_count&quot;] = babynames[&quot;Name&quot;].map(dr_ea_count)</span><br><span class="line">babynames = babynames.sort_values(by = &quot;dr_ea_count&quot;, ascending=False)</span><br></pre></td></tr></table></figure>
<p>字典创建表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#build dictionary where each entry is the rtp for a given name</span><br><span class="line">#e.g. rtps[&quot;jennifer&quot;] should be 0.0231</span><br><span class="line">rtps = &#123;&#125;</span><br><span class="line">for name in babynames[&quot;Name&quot;].unique():</span><br><span class="line">counts_of_current_name = female_babynames[female_babynames[&quot;Name&quot;] == name][&quot;Count&quot;]</span><br><span class="line">rtps[name] = ratio_to_peak(counts_of_current_name)</span><br><span class="line">#convert to series</span><br><span class="line">rtps = pd.Series(rtps)</span><br></pre></td></tr></table></figure>
<p>使用group建立新表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">female_babynames.groupby(&quot;Name&quot;).agg(ratio_to_peak)</span><br></pre></td></tr></table></figure>
<p><img src="/assets/jupyter%20notbook/image-20230924092636108.png" /> groupby的其他用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given a DataFrameGroupBy object, can use various functions to generate DataFrames (or</span><br><span class="line">Series). agg is only one choice:</span><br><span class="line">● agg: Creates a new DataFrame with one aggregated row per subframe.</span><br><span class="line">● max: Creates a new DataFrame aggregated using the max function.</span><br><span class="line">● size: Creates a new Series with the size of each subframe.</span><br><span class="line">● filter: Creates a copy of the original DataFrame, but keeping only rows from subframes</span><br><span class="line">that obey the provided condition.</span><br></pre></td></tr></table></figure>
<p>合并表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">merged = pd.merge(left = elections, right = male_2020_babynames,</span><br><span class="line">left_on = &quot;First Name&quot;, right_on = &quot;Name&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>数据科学</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利ds100和cs231n的numpy笔记</title>
    <url>/thinklive/59126/</url>
    <content><![CDATA[<p><a href="http://www.numpy.org/">Numpy</a> 是 Python 中科学计算的核心库。 它提供了高性能的多维数组对象以及使用这些对象的工具 数组。</p>
<h2 id="数组">数组</h2>
<p>numpy 数组是一个值网格，所有值都具有相同的类型，并由非负整数组成的元组索引。 它的维度就是数组的秩 ；它的shape就是每个维度的大小组成的元组 <span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array</span><br><span class="line">print(b.shape)                     # Prints &quot;(2, 3)&quot;</span><br><span class="line">print(b[0, 0], b[0, 1], b[1, 0])   # Prints &quot;1 2 4&quot;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://numpy.org/doc/stable/user/basics.creation.html#arrays-creation">官方数组创建教程</a> <a href="http://ds100.org/fa17/assets/notebooks/numpy/Numpy_Review.html">ds100的numpy教程</a> <a href="https://cs231n.github.io/python-numpy-tutorial/#numpy">cs231n的python numpy教程</a></p>
<h3 id="创建数组的方法">创建数组的方法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;np.array([[1.,2.], [3.,4.]])</span><br><span class="line"></span><br><span class="line">array([[ 1.,  2.],</span><br><span class="line">       [ 3.,  4.]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([x for x in range(5)])</span><br><span class="line"></span><br><span class="line">array([0, 1, 2, 3, 4])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([[&quot;A&quot;, &quot;matrix&quot;], [&quot;of&quot;, &quot;words.&quot;]])</span><br><span class="line"></span><br><span class="line">array([[&#x27;A&#x27;, &#x27;matrix&#x27;],</span><br><span class="line">       [&#x27;of&#x27;, &#x27;words.&#x27;]], </span><br><span class="line">      dtype=&#x27;&lt;U6&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.ones([3,2])</span><br><span class="line"></span><br><span class="line">array([[ 1.,  1.],</span><br><span class="line">       [ 1.,  1.],</span><br><span class="line">       [ 1.,  1.]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.random.randn(3,2)</span><br><span class="line"></span><br><span class="line">array([[ 0.3601399 ,  1.31206686],</span><br><span class="line">       [-0.95112397,  0.62475726],</span><br><span class="line">       [-1.24179768,  1.63392069]])</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;c = np.full((2,2), 7)  # Create a constant array</span><br><span class="line">print(c)               # Prints &quot;[[ 7.  7.]</span><br><span class="line">                       #          [ 7.  7.]]&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;d = np.eye(2)         # Create a 2x2 identity matrix</span><br><span class="line">print(d)              # Prints &quot;[[ 1.  0.]</span><br><span class="line">                      #          [ 0.  1.]]&quot;</span><br></pre></td></tr></table></figure>
<h3 id="数组属性">数组属性</h3>
<ul>
<li>dtype</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;np.arange(1,5).dtype</span><br><span class="line"></span><br><span class="line">dtype(&#x27;int64&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([&quot;Hello&quot;, &quot;Worlddddd!&quot;]).dtype</span><br><span class="line"></span><br><span class="line">dtype(&#x27;&lt;U10&#x27;)</span><br><span class="line">/*</span><br><span class="line">What does `&lt;U6` mean?</span><br><span class="line">- `&lt;` Little Endian</span><br><span class="line">- `U` Unicode</span><br><span class="line">- `6` length of longest string</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.array([1,2,3]).astype(float)</span><br><span class="line"></span><br><span class="line">array([ 1.,  2.,  3.])</span><br></pre></td></tr></table></figure>
<p>数组的类型与其包含的数据类型相对应,可以用.astype改变类型</p>
<h3 id="数组编辑">数组编辑</h3>
<h4 id="重组和展开">重组和展开</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;np.arange(1,13).reshape(4,3)</span><br><span class="line"></span><br><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [ 4,  5,  6],</span><br><span class="line">       [ 7,  8,  9],</span><br><span class="line">       [10, 11, 12]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;A.flatten()</span><br><span class="line">array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])</span><br></pre></td></tr></table></figure>
<h4 id="切片索引和整数索引">切片索引和整数索引</h4>
<p>切片时，第一个参数是行，第二个是列，切片形成的是对原来数组的引用，修改子数组也会影响原数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Use slicing to pull out the subarray consisting of the first 2 rows</span><br><span class="line"># and columns 1 and 2; b is the following array of shape (2, 2):</span><br><span class="line"># [[2 3]</span><br><span class="line">#  [6 7]]</span><br><span class="line">b = a[:2, 1:3]</span><br><span class="line"></span><br><span class="line"># A slice of an array is a view into the same data, so modifying it</span><br><span class="line"># will modify the original array.</span><br><span class="line">print(a[0, 1])   # Prints &quot;2&quot;</span><br><span class="line">b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]</span><br><span class="line">print(a[0, 1])   # Prints &quot;77&quot;</span><br></pre></td></tr></table></figure>
<p>可以混合整数索引和切片索引，这样做会产生一个比原始数组的秩更低的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Two ways of accessing the data in the middle row of the array.</span><br><span class="line"># Mixing integer indexing with slices yields an array of lower rank,</span><br><span class="line"># while using only slices yields an array of the same rank as the</span><br><span class="line"># original array:</span><br><span class="line">row_r1 = a[1, :]    # Rank 1 view of the second row of a</span><br><span class="line">row_r2 = a[1:2, :]  # Rank 2 view of the second row of a</span><br><span class="line">print(row_r1, row_r1.shape)  # Prints &quot;[5 6 7 8] (4,)&quot;</span><br><span class="line">print(row_r2, row_r2.shape)  # Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span><br><span class="line"></span><br><span class="line"># We can make the same distinction when accessing columns of an array:</span><br><span class="line">col_r1 = a[:, 1]</span><br><span class="line">col_r2 = a[:, 1:2]</span><br><span class="line">print(col_r1, col_r1.shape)  # Prints &quot;[ 2  6 10] (3,)&quot;</span><br><span class="line">print(col_r2, col_r2.shape)  # Prints &quot;[[ 2]</span><br><span class="line">                             #          [ 6]</span><br><span class="line">                             #          [10]] (3, 1)&quot;</span><br></pre></td></tr></table></figure>
<p>整数数组 索引允许你使用另一个数组的数据构造任意数组 大批。 这是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1,2], [3, 4], [5, 6]])</span><br><span class="line"></span><br><span class="line"># An example of integer array indexing.</span><br><span class="line"># The returned array will have shape (3,) and</span><br><span class="line">print(a[[0, 1, 2], [0, 1, 0]])  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># The above example of integer array indexing is equivalent to this:</span><br><span class="line">print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># When using integer array indexing, you can reuse the same</span><br><span class="line"># element from the source array:</span><br><span class="line">print(a[[0, 0], [1, 1]])  # Prints &quot;[2 2]&quot;</span><br><span class="line"></span><br><span class="line"># Equivalent to the previous integer array indexing example</span><br><span class="line">print(np.array([a[0, 1], a[0, 1]]))  # Prints &quot;[2 2]&quot;</span><br></pre></td></tr></table></figure>
<p>可以用整数数组索引修改数组部分值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create a new array from which we will select elements</span><br><span class="line">a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[ 1,  2,  3],</span><br><span class="line">          #                [ 4,  5,  6],</span><br><span class="line">          #                [ 7,  8,  9],</span><br><span class="line">          #                [10, 11, 12]])&quot;</span><br><span class="line"></span><br><span class="line"># Create an array of indices</span><br><span class="line">b = np.array([0, 2, 0, 1])</span><br><span class="line"></span><br><span class="line"># Select one element from each row of a using the indices in b</span><br><span class="line">print(a[np.arange(4), b])  # Prints &quot;[ 1  6  7 11]&quot;</span><br><span class="line"></span><br><span class="line"># Mutate one element from each row of a using the indices in b</span><br><span class="line">a[np.arange(4), b] += 10</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[11,  2,  3],</span><br><span class="line">          #                [ 4,  5, 16],</span><br><span class="line">          #                [17,  8,  9],</span><br><span class="line">          #                [10, 21, 12]])</span><br></pre></td></tr></table></figure>
<h4 id="数组的数学运算">数组的数学运算</h4>
<p>numpy 提供的数学函数的完整列表 <a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">文档</a> Numpy 提供了更多用于操作数组的函数； 完整的列表 <a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">文档</a></p>
<p>Numpy 提供了许多有用的函数来执行计算 数组； 最有用的之一是 <code>sum</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]])</span><br><span class="line"></span><br><span class="line">print(np.sum(x))  # Compute sum of all elements; prints &quot;10&quot;</span><br><span class="line">print(np.sum(x, axis=0))  # Compute sum of each column; prints &quot;[4 6]&quot;</span><br><span class="line">print(np.sum(x, axis=1))  # Compute sum of each row; prints &quot;[3 7]&quot;</span><br></pre></td></tr></table></figure>
<p>转置矩阵， 只需使用 <code>T</code>数组对象的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2], [3,4]])</span><br><span class="line">print(x)    # Prints &quot;[[1 2]</span><br><span class="line">            #          [3 4]]&quot;</span><br><span class="line">print(x.T)  # Prints &quot;[[1 3]</span><br><span class="line">            #          [2 4]]&quot;</span><br><span class="line"></span><br><span class="line"># Note that taking the transpose of a rank 1 array does nothing:</span><br><span class="line">v = np.array([1,2,3])</span><br><span class="line">print(v)    # Prints &quot;[1 2 3]&quot;</span><br><span class="line">print(v.T)  # Prints &quot;[1 2 3]&quot;</span><br></pre></td></tr></table></figure>
<h3 id="广播">广播</h3>
<p>我们有一个较小的数组和一个 较大的数组，并且我们想多次使用较小的数组来执行某些操作 在更大的阵列上。</p>
<p>例如，假设我们要向每个添加一个常数向量 矩阵的行。 我们可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = np.empty_like(x)   # Create an empty matrix with the same shape as x</span><br><span class="line"></span><br><span class="line"># Add the vector v to each row of the matrix x with an explicit loop</span><br><span class="line">for i in range(4):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"># Now y is the following</span><br><span class="line"># [[ 2  2  4]</span><br><span class="line">#  [ 5  5  7]</span><br><span class="line">#  [ 8  8 10]</span><br><span class="line">#  [11 11 13]]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<p>Numpy 广播允许我们执行此计算，而无需实际执行 创建多个副本 <code>v</code>。 考虑这个版本，使用广播：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = x + v  # Add v to each row of x using broadcasting</span><br><span class="line">print(y)  # Prints &quot;[[ 2  2  4]</span><br><span class="line">          #          [ 5  5  7]</span><br><span class="line">          #          [ 8  8 10]</span><br><span class="line">          #          [11 11 13]]&quot;</span><br></pre></td></tr></table></figure>
<p>线路 <code>y = x + v</code>尽管有效 <code>x</code>有形状 <code>(4, 3)</code>和 <code>v</code>有形状 <code>(3,)</code>由于广播； 这条线的工作原理就像 <code>v</code>实际上有形状 <code>(4, 3)</code>, 其中每一行都是一个副本 <code>v</code>，并且按元素求和。</p>
<p>一起广播两个数组遵循以下规则：</p>
<ol type="1">
<li>如果数组没有相同的秩，则在前面添加较低秩数组的形状 1s 直到两个形状具有相同的长度。</li>
<li>如果两个数组具有相同的维度，则称 <em>兼容</em> 它们在维度上 维度中的大小，或者如果其中一个数组在该维度中的大小为 1。</li>
<li>如果数组在所有维度上都兼容，则可以一起广播。</li>
<li>广播后，每个数组的行为就好像它的形状等于元素方向 两个输入数组的形状的最大值。</li>
<li>在一个数组的大小为 1 而另一个数组的大小大于 1 的任何维度中， 第一个数组的行为就好像它是沿着该维度复制的</li>
</ol>
<p>一些应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Compute outer product of vectors</span><br><span class="line">v = np.array([1,2,3])  # v has shape (3,)</span><br><span class="line">w = np.array([4,5])    # w has shape (2,)</span><br><span class="line"># To compute an outer product, we first reshape v to be a column</span><br><span class="line"># vector of shape (3, 1); we can then broadcast it against w to yield</span><br><span class="line"># an output of shape (3, 2), which is the outer product of v and w:</span><br><span class="line"># [[ 4  5]</span><br><span class="line">#  [ 8 10]</span><br><span class="line">#  [12 15]]</span><br><span class="line">print(np.reshape(v, (3, 1)) * w)</span><br><span class="line"></span><br><span class="line"># Add a vector to each row of a matrix</span><br><span class="line">x = np.array([[1,2,3], [4,5,6]])</span><br><span class="line"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span><br><span class="line"># giving the following matrix:</span><br><span class="line"># [[2 4 6]</span><br><span class="line">#  [5 7 9]]</span><br><span class="line">print(x + v)</span><br><span class="line"></span><br><span class="line"># Add a vector to each column of a matrix</span><br><span class="line"># x has shape (2, 3) and w has shape (2,).</span><br><span class="line"># If we transpose x then it has shape (3, 2) and can be broadcast</span><br><span class="line"># against w to yield a result of shape (3, 2); transposing this result</span><br><span class="line"># yields the final result of shape (2, 3) which is the matrix x with</span><br><span class="line"># the vector w added to each column. Gives the following matrix:</span><br><span class="line"># [[ 5  6  7]</span><br><span class="line">#  [ 9 10 11]]</span><br><span class="line">print((x.T + w).T)</span><br><span class="line"># Another solution is to reshape w to be a column vector of shape (2, 1);</span><br><span class="line"># we can then broadcast it directly against x to produce the same</span><br><span class="line"># output.</span><br><span class="line">print(x + np.reshape(w, (2, 1)))</span><br><span class="line"></span><br><span class="line"># Multiply a matrix by a constant:</span><br><span class="line"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span><br><span class="line"># these can be broadcast together to shape (2, 3), producing the</span><br><span class="line"># following array:</span><br><span class="line"># [[ 2  4  6]</span><br><span class="line">#  [ 8 10 12]]</span><br><span class="line">print(x * 2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>数据科学</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利Sysadmin decal的linux笔记</title>
    <url>/thinklive/28990/</url>
    <content><![CDATA[<h1 id="shell脚本">shell脚本</h1>
<p>Shell 脚本通常以 shebang 行开头：#!path/to/interpreter。</p>
<p><code>#!</code>是一个人类可读的 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)#Magic_number">幻数表示</a> <code>0x23 0x21</code>它可以告诉 shell 将文件其余部分的执行传递给 指定翻译。 如果您的脚本作为可执行文件运行（例如 <code>./awesome_shell_script</code>) 加上 shebang 行，那么 shell 将调用 可执行文件（通常是解释器）位于 <code>path/to/interpreter</code>运行你的 脚本。 如果您的脚本作为参数传递给解释器，例如 <code>bash awesome_shell_script</code>，那么 shebang 没有效果并且 <code>bash</code>会处理 脚本的执行。 <span id="more"></span> <strong>为什么这很重要？</strong> shebang 可以被认为是一个有用的部分 执行脚本的关注 <em>如何</em> 元数据传递了用户 给程序的作者。 <code>awesome_shell_script</code>可能是一个 <code>bash</code>脚本，一个 <code>python</code>脚本，一个 <code>ruby</code>脚本等。这个想法是只有脚本的 对于调用的用户来说，行为而不是其实现细节应该重要。</p>
<p>您可能已经看到过一些变体 <code>#!/bin/sh</code>。 虽然最初参考的是 现代系统上的 Bourne shell <code>sh</code>已经提到了 <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html">Shell Command Language</a> ，这是一个具有多种实现的 POSIX 规范。 <code>sh</code>通常符号链接到这些符合 POSIX 标准的 shell 之一 实现 Shell 命令语言。 以 Debian 为例， <code>sh</code>是 符号链接到 shell <code>dash</code>。 重要的是要注意 <code>bash</code>不 **_** 遵守这个标准，虽然运行 <code>bash</code>作为 <code>bash --posix</code>做到了 更合规。</p>
<h3 id="管道"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#piping"></a>管道</h3>
<p>我们可以使用 <code>|</code>字符将多个命令链接在一行中。 例如： <code>command1 | command2</code> 将传递的输出 <code>command1</code>作为输入 <code>command2</code>。 我们可以根据需要多次重复此操作。</p>
<h3 id="循环使用-for"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#looping-with-for"></a>循环使用 <code>for</code></h3>
<p>Bash 可以使用 for 循环对多个对象重复操作。 语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for VARIABLE in LIST; do</span><br><span class="line"></span><br><span class="line">    CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>缩进不是必需的，但使代码更易于阅读。 这 <code>LIST</code>可以是包含多个文件的目录，也可以是包含多行 init 的文件、文件列表（ <code>file1 file2 file3</code>），甚至是一系列数字（ <code>&#123;start..end&#125;</code>).</p>
<h2 id="有用的命令"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#useful-commands"></a>有用的命令</h2>
<p>一些对于完成实验可能有用的命令。 当然，解决问题的方法有很多，并不需要使用这些命令。</p>
<h3 id="cat"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#cat"></a><code>cat</code></h3>
<p><code>cat</code> <a href="https://linux.die.net/man/1/cat">打印</a> 将文件 <a href="https://linuxhint.com/bash_stdin_stderr_stdout/">到标准输出</a> 。 对于打印一些内容以通过管道输入其他命令非常有用！</p>
<h3 id="cut"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#cut"></a><code>cut</code></h3>
<p><code>cut [options] [filename]</code>提取文件的某些部分（或管道输入） <a href="https://linux.die.net/man/1/cut">参数</a> 根据使用的 。 一些可能有用的：</p>
<p><code>-d</code>允许我们更改分隔符，或更改字符 <code>cut</code>寻找将字符串分成块。 如果省略该选项， <code>tab</code>用来。</p>
<p><code>-f</code>允许我们指定与要返回的字段对应的数字，例如 <code>cut -f1 -d" "</code>将返回句子中的第一个单词。 数字后跟一个 <code>-</code>也返回指定字段之后的所有字段，因此 <code>cut -f1- -d" "</code>将返回整个字符串。</p>
<p><code>--complement</code>告诉 <code>cut</code>返回除 <strong>之外的所有内容。</strong> 指定字段</p>
<h3 id="grep"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#grep"></a><code>grep</code></h3>
<p><code>grep [pattern] [filename]</code> <a href="https://linux.die.net/man/1/grep">过滤</a> 并返回文件（或管道输入）中包含指定模式的行。</p>
<h3 id="sed"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#sed"></a><code>sed</code></h3>
<p><code>sed</code>可以做 <a href="https://linux.die.net/man/1/sed">很多事情</a> ，比如编辑字符串和匹配正则表达式。 我们可以用 <code>sed</code>将一种模式替换为另一种模式，如下所示：</p>
<p><code>sed 's/&lt;PATTERN-TO-REPLACE&gt;/&lt;NEW-PATTERN&gt;/g &lt;INPUT&gt;'</code></p>
<p>sed` 还可以从其他东西获取管道输入，而不是显式输入。</p>
<p>这 <code>g</code>最后告诉 <code>sed</code>替换所有出现的模式； 如果我们只想替换模式的第一次出现，则可以省略它，或者用数字替换以仅替换一定次数的出现。</p>
<h3 id="xargs"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#xargs"></a><code>xargs</code></h3>
<p><code>xargs</code>让我们将命令应用于从管道重定向的输出。 例如， <code>output | xargs command</code>会适用 <code>command</code>到 <code>output</code>。 一些有用的 <a href="https://linux.die.net/man/1/xargs">选项</a> ：</p>
<p><code>-n1</code>告诉 <code>xargs</code>将命令应用到中的每个项目 <code>output</code>如果输出中有多个项目（例如多个字符串的列表），则一次</p>
<p><code>-0</code>告诉 <code>xargs</code>用空字符（表示字符串的结尾）分割输出中的项目，而不是使用空格。 搭配 <code>-n1</code>， 这意味着 <code>xargs</code>会将命令应用于每个字符串，而不是将字符串分解为单个单词并将命令应用于每个单词。</p>
<p>与往常一样，有更多方法可以使用这些命令，因此请使用 Google 或 <a href="https://en.wikipedia.org/wiki/Man_page">手册页</a> 来了解更多信息</p>
<h2 id="语法">语法</h2>
<h3 id="shell-变量和类型">Shell 变量和类型</h3>
<p>与大多数其他编程语言一样， <code>bash</code>促进有状态分配 名称到值作为变量。</p>
<p>变量可以被赋值 <code>bash</code>语法如下： <code>NAME=value</code>。 请注意 赋值运算符之间缺少空格 <code>=</code>及其操作数。 任务 对空格敏感。</p>
<p>您可以通过在前面添加一个来检索变量的值 <code>$</code>以它的名字。 获取值 <code>NAME</code>必须完成 <code>$NAME</code>。 这就是所谓的变量 插值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ NAME = &quot;Tux&quot; # Incorrect</span><br><span class="line">-bash: NAME: command not found </span><br><span class="line">$ NAME=&quot;Tux&quot; # Correct</span><br><span class="line">$ echo NAME # Incorrect. We want the value we assigned to NAME, not the text </span><br><span class="line"># NAME itself.</span><br><span class="line">NAME</span><br><span class="line">$ echo $NAME # Correct</span><br><span class="line">Tux</span><br></pre></td></tr></table></figure>
<p><code>$?</code>保存最近执行的命令的退出代码。 在这个 上下文、退出代码 <code>0</code>一般表示程序已经执行 成功地。 其他 <a href="http://tldp.org/LDP/abs/html/exitcodes.html">退出代码</a> 指的是错误的性质 导致程序失败。</p>
<p>特殊 <em>位置参数</em> 允许将参数传递到脚本中。 <code>$0</code>是脚本的名称， <code>$1</code>是传递给的第一个参数 脚本， <code>$2</code>是传递给脚本的第二个参数， <code>$3</code>是第三个 论证等 <code>$#</code>给出传递给脚本的参数数量。</p>
<p>所以 <code>./awesome_shell_script foo bar</code>可以访问 <code>foo</code>从 <code>$1</code>和 <code>bar</code>从 <code>$2</code>.</p>
<p>Bash 变量是 <em>无类型的</em> 。 它们通常被视为文本（字符串），但是 如果变量包含数字和算术运算，则可以将其视为数字 对其应用操作。 请注意，这与大多数编程不同 语言。 <em>变量</em> 本身没有类型，但 <em>运算符</em> 会处理 在不同的环境下他们的价值观也不同。 换句话说， <code>bash</code>变量是文本，没有任何固有的行为或属性 可以操作的文本，但操作员会解释该文本 根据其内容（数字或无数字？）和上下文 表达。</p>
<h3 id="算术"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#arithmetic"></a>算术</h3>
<p>Bash 支持整数算术 <code>let</code>内置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ x=1+1</span><br><span class="line">$ echo $x # Incorrect. We wanted 2, not the text 1+1.</span><br><span class="line">1+1</span><br><span class="line">$ let x=1+1</span><br><span class="line">$ echo $x # Correct</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>注意 <code>let</code>对空格敏感。 操作数和运算符不得 用空格分隔。</p>
<p><code>bash</code>本身不支持浮点运算，所以我们必须依赖 如果我们想处理十进制数字，请使用外部实用程序。 一个常见的选择 这是 <code>bc</code>。 有趣的事实： <code>bc</code>实际上是它自己的完整语言！</p>
<p>我们经常访问 <code>bc</code>通过 <em>管道</em> （表示为 <code>|</code>），这允许 将一个命令的输出用作另一命令的输入。 我们包括 <code>-l</code> 选项 <code>bc</code>为了启用浮点运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo 1/2 | bc -l</span><br><span class="line">.50000000000000000000</span><br></pre></td></tr></table></figure>
<h3 id="test"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#test"></a><code>test</code></h3>
<p>Bash 脚本经常使用 <code>[</code>（同义词为 <code>test</code>) shell 内置的 表达式的条件评估。 <code>test</code>计算一个表达式并 以任一状态代码退出 <code>0</code>(true) 或状态代码 <code>1</code>（错误的）。</p>
<p><code>test</code>支持常见的字符串和数字运算符，以及许多 额外的二元和一元运算符在大多数情况下没有直接类似物 其他编程语言。 您可以看到这些运算符的列表，以及 其他有用的信息，通过输入 <code>help test</code>在你的壳里。 的输出 如下所示。 注意 <code>help</code>类似于 <code>man</code>，除非它用于 bash 函数而不是其他程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ help test</span><br><span class="line">test: test [expr]</span><br><span class="line">    Exits with a status of 0 (true) or 1 (false) depending on</span><br><span class="line">    the evaluation of EXPR.  Expressions may be unary or binary.  Unary</span><br><span class="line">    expressions are often used to examine the status of a file.  There</span><br><span class="line">    are string operators as well, and numeric comparison operators.</span><br><span class="line"></span><br><span class="line">    File operators:</span><br><span class="line"></span><br><span class="line">        -a FILE        True if file exists.</span><br><span class="line">        -b FILE        True if file is block special.</span><br><span class="line">        -c FILE        True if file is character special.</span><br><span class="line">        -d FILE        True if file is a directory.</span><br><span class="line">        -e FILE        True if file exists.</span><br><span class="line">        -f FILE        True if file exists and is a regular file.</span><br><span class="line">        -g FILE        True if file is set-group-id.</span><br><span class="line">        -h FILE        True if file is a symbolic link.</span><br><span class="line">        -L FILE        True if file is a symbolic link.</span><br><span class="line">        -k FILE        True if file has its `sticky&#x27; bit set.</span><br><span class="line">        -p FILE        True if file is a named pipe.</span><br><span class="line">        -r FILE        True if file is readable by you.</span><br><span class="line">        -s FILE        True if file exists and is not empty.</span><br><span class="line">        -S FILE        True if file is a socket.</span><br><span class="line">        -t FD          True if FD is opened on a terminal.</span><br><span class="line">        -u FILE        True if the file is set-user-id.</span><br><span class="line">        -w FILE        True if the file is writable by you.</span><br><span class="line">        -x FILE        True if the file is executable by you.</span><br><span class="line">        -O FILE        True if the file is effectively owned by you.</span><br><span class="line">        -G FILE        True if the file is effectively owned by your group.</span><br><span class="line">        -N FILE        True if the file has been modified since it was last </span><br><span class="line">read.</span><br><span class="line"></span><br><span class="line">      FILE1 -nt FILE2  True if file1 is newer than file2 (according to</span><br><span class="line">                       modification date).</span><br><span class="line"></span><br><span class="line">      FILE1 -ot FILE2  True if file1 is older than file2.</span><br><span class="line"></span><br><span class="line">      FILE1 -ef FILE2  True if file1 is a hard link to file2.</span><br><span class="line"></span><br><span class="line">    String operators:</span><br><span class="line"></span><br><span class="line">        -z STRING      True if string is empty.</span><br><span class="line"></span><br><span class="line">        -n STRING</span><br><span class="line">        STRING         True if string is not empty.</span><br><span class="line"></span><br><span class="line">        STRING1 = STRING2</span><br><span class="line">                       True if the strings are equal.</span><br><span class="line">        STRING1 != STRING2</span><br><span class="line">                       True if the strings are not equal.</span><br><span class="line">        STRING1 &lt; STRING2</span><br><span class="line">                       True if STRING1 sorts before STRING2 lexicographically.</span><br><span class="line">        STRING1 &gt; STRING2</span><br><span class="line">                       True if STRING1 sorts after STRING2 lexicographically.</span><br><span class="line"></span><br><span class="line">    Other operators:</span><br><span class="line"></span><br><span class="line">        -o OPTION      True if the shell option OPTION is enabled.</span><br><span class="line">        ! EXPR         True if expr is false.</span><br><span class="line">        EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.</span><br><span class="line">        EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.</span><br><span class="line"></span><br><span class="line">        arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,</span><br><span class="line">                       -lt, -le, -gt, or -ge.</span><br><span class="line"></span><br><span class="line">    Arithmetic binary operators return true if ARG1 is equal, not-equal,</span><br><span class="line">    less-than, less-than-or-equal, greater-than, or greater-than-or-equal</span><br><span class="line">    than ARG2.</span><br></pre></td></tr></table></figure>
<p>我们可以测试整数相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ [ 0 -eq 0 ]; echo $? # exit code 0 means true</span><br><span class="line">0</span><br><span class="line">$ [ 0 -eq 1 ]; echo $? # exit code 1 means false</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>字符串相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ [ zero = zero ]; echo $? # exit code 0 means true</span><br><span class="line">0</span><br><span class="line">$ [ zero = one ]; echo $? # exit code 1 means false</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>以及您可以自由进行的许多其他字符串和数字运算 探索。</p>
<h3 id="控制结构"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#flow-control"></a>控制结构</h3>
<p><code>bash</code>包括大多数编程语言典型的控制结构 – <code>if-then-elif-else</code>, <code>while</code> <code>for-in</code>等等。您可以阅读更多有关 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_07.html">条件语句</a> 和 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_09.html">迭代</a> 中的 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html">Bash 指南 初学者</a> Linux 文档项目 (LDP) 的 。 我们鼓励您 请阅读这些部分，因为本指南仅提供了一些内容的简短摘要 重要特征。</p>
<h3 id="if-then-elif-else"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#if-then-elif-else"></a>if-then-elif-else</h3>
<p>if 语句的一般形式 <code>bash</code>是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if TEST-COMMANDS; then</span><br><span class="line"></span><br><span class="line">  CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">elif MORE-TEST-COMMANDS; then</span><br><span class="line"></span><br><span class="line">  MORE-CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">else </span><br><span class="line"></span><br><span class="line">  ALTERNATE-CONSEQUENT-COMMANDS;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>缩进是一种很好的做法，但不是必需的。</p>
<p>例如，如果我们写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">if [ $1 -eq $2 ]; then</span><br><span class="line">  echo args are equal</span><br><span class="line">else</span><br><span class="line">  echo args are not equal</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>我们看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./awesome_shell_script 0 0</span><br><span class="line">args are equal</span><br><span class="line">$ ./awesome_shell_script 0 1</span><br><span class="line">args are not equal</span><br></pre></td></tr></table></figure>
<h3 id="尽管"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#while"></a>尽管</h3>
<p>while 循环的一般形式 <code>bash</code>是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while TEST-COMMANDS; do</span><br><span class="line"></span><br><span class="line">  CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>如果 <code>TEST-COMMANDS</code>退出并带有状态码 <code>0</code>, <code>CONSEQUENT-COMMANDS</code>将要 执行。 这些步骤将重复，直到 <code>TEST-COMMANDS</code>退出时带有一些非零值 地位。</p>
<p>例如，如果我们写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">n=$1</span><br><span class="line">while [ $n -gt 0 ]; do</span><br><span class="line">  echo $n</span><br><span class="line">  let n=$n-1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>我们看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./awesome_shell_script 5</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#functions"></a>函数</h3>
<p><code>bash</code> supports functions, albeit in a crippled form relative to many other languages. Some notable differences include:</p>
<ul>
<li>函数不 <em>返回</em> 任何内容，它们只是产生输出流（例如 <code>echo</code>到标准输出）</li>
<li><code>bash</code>严格来说是按值调用。 也就是说，只有原子值（字符串）可以 被传递到函数中。</li>
<li>变量没有词法作用域。 <code>bash</code>使用一个非常简单的本地系统 范围接近动态范围。</li>
<li><code>bash</code>没有一流的函数（即没有将函数传递给 其他函数）、匿名函数或闭包。</li>
</ul>
<p>功能于 <code>bash</code>定义为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name_of_function() &#123;</span><br><span class="line"></span><br><span class="line">  FUNCTION_BODY</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name_of_function $arg1 $arg2 ... $argN</span><br></pre></td></tr></table></figure>
<p>请注意函数签名中缺少参数。 参数在 <code>bash</code> 函数的处理方式与全局位置参数类似，其中 <code>$1</code> 含有 <code>$arg1</code>, <code>$2</code>含有 <code>$arg2</code>， ETC。</p>
<p>例如，如果我们写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  echo hello $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo $1</span><br></pre></td></tr></table></figure>
<p>我们看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./awesome_shell_script world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="实例">实例</h2>
<p><code>斐波那契</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of fibonacci</span><br><span class="line"></span><br><span class="line">if [ $# -eq 0 ]; then</span><br><span class="line">    echo &quot;fibonacci needs an argument&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">fib() &#123;</span><br><span class="line">    N=&quot;$1&quot;</span><br><span class="line">    if [ -z &quot;$&#123;N##*[!0-9]*&#125;&quot; ]; then</span><br><span class="line">        echo &quot;fibonacci only makes sense for nonnegative integers&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ &quot;$N&quot; -eq 0 ]; then</span><br><span class="line">        echo 0</span><br><span class="line">    elif [ &quot;$N&quot; -eq 1 ]; then</span><br><span class="line">        echo 1</span><br><span class="line">    else</span><br><span class="line">        echo $(($(fib $((N-2))) + $(fib $((N-1)))))</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib &quot;$1&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -p “send: ” FOO</span><br><span class="line"># enter “hi”</span><br><span class="line">echo “sent: $FOO”</span><br><span class="line">sent: hi</span><br><span class="line"></span><br><span class="line">FOO=$(expr 1 + 1)</span><br><span class="line">echo “$FOO”</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">-eq ==</span><br><span class="line">-ne !=</span><br><span class="line">-gt &gt;</span><br><span class="line">-ge &gt;=</span><br><span class="line">-lt &lt;</span><br><span class="line">-le &lt;=</span><br><span class="line"></span><br><span class="line">test zero = zero; echo $?</span><br><span class="line">0 # 0 means true</span><br><span class="line">test zero = one; echo $?</span><br><span class="line">1 # 1 means false</span><br><span class="line"></span><br><span class="line">if [ “$1” -eq 69 ];</span><br><span class="line">then</span><br><span class="line">echo “nice”</span><br><span class="line">elif [ “$1” -eq 42 ];</span><br><span class="line">then</span><br><span class="line">echo “the answer!”</span><br><span class="line">else</span><br><span class="line">echo “wat r numbers”</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">read -p &quot;are you 21?&quot; ANSWER</span><br><span class="line">case &quot;$ANSWER&quot; in</span><br><span class="line">“yes”)</span><br><span class="line">echo &quot;i give u cookie&quot;;;</span><br><span class="line">“no”)</span><br><span class="line">echo &quot;thats illegal&quot;;;</span><br><span class="line">“are you?”)</span><br><span class="line">echo “lets not”;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;please answer&quot;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">NAMES=&quot;a b c d&quot;</span><br><span class="line">for NAME in $NAMES</span><br><span class="line">do</span><br><span class="line">echo &quot;Hello $NAME&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">echo &quot;Hello $NAME&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>Bash 支持整数算术 <code>let</code>内置的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ x=1+1</span><br><span class="line">$ echo $x # Incorrect. We wanted 2, not the text 1+1.</span><br><span class="line">1+1</span><br><span class="line">$ let x=1+1</span><br><span class="line">$ echo $x # Correct</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>注意 <code>let</code>对空格敏感。 操作数和运算符不得 用空格分隔。 <code>test</code>计算一个表达式并 以任一状态代码退出 <code>0</code>(true) 或状态代码 <code>1</code>（错误的）</p>
<p><code>bash</code>支持函数，尽管相对于许多其他函数而言，其形式有缺陷 语言。 一些显着的差异包括：</p>
<ul>
<li>函数不 <em>返回</em> 任何内容，它们只是产生输出流（例如 <code>echo</code>到标准输出）</li>
<li><code>bash</code>严格来说是按值调用。 也就是说，只有原子值（字符串）可以 被传递到函数中。</li>
<li>变量没有词法作用域。 <code>bash</code>使用一个非常简单的本地系统 范围接近动态范围。</li>
<li><code>bash</code>没有一流的函数（即没有将函数传递给 其他函数）、匿名函数或闭包</li>
</ul>
<p>请注意函数签名中缺少参数。 参数在 <code>bash</code> 函数的处理方式与全局位置参数类似，其中 <code>$1</code> 含有 <code>$arg1</code>, <code>$2</code>含有 <code>$arg2</code>， ETC。</p>
<p>例如，如果我们写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  echo hello $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo $1</span><br></pre></td></tr></table></figure>
<p>我们看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./awesome_shell_script world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h1 id="shell命令">shell命令</h1>
<h2 id="ssh安全外壳">SSH（安全外壳）</h2>
<p>SSH 允许您通过互联网登录远程计算机。 这相当于在远程计算机上打开 shell。</p>
<p>用法是 <code>ssh [remote username]@[remote host]</code>.</p>
<h3 id="问题"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#question"></a>问题</h3>
<ol type="1">
<li>登录到 <code>tsunami.ocf.berkeley.edu</code>使用您的 OCF 用户名和密码。 有一个文件在 <code>~staff/public_html/decal</code>。 打开它。 文件中到底隐藏着什么秘密？</li>
</ol>
<h2 id="管道和重定向"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#pipes-and-redirection"></a>管道和重定向</h2>
<p>将命令链接在一起对于自动化 shell 操作至关重要。 这是一个快速备忘单：</p>
<p><code>&gt;</code>：将 <a href="https://linux.die.net/man/3/stdout">标准</a> 输出重定向到文件（将覆盖该文件）。</p>
<p><code>&gt;&gt;</code>：将标准输出附加到文件（与 <code>&gt;</code>除非不覆盖）。</p>
<p><code>&lt;</code>：从文件中读取输入。</p>
<p><code>|</code>：将一个程序的输出发送到下一个程序的输入。</p>
<p>下面是一个示例：假设您正在参加一门课程，需要您提交一个包含您的 SID 的文本文件。 您的第一反应可能是打开一个文本编辑器（例如 <code>vim</code>）并简单地输入它，但是有一种更快的方法来创建文件！ 这里是：</p>
<p><code>echo '123456789' &gt; sid.txt</code></p>
<h2 id="tmux">tmux</h2>
<h3 id="为什么是-tmux">为什么是 tmux？</h3>
<ul>
<li>当通过 ssh 连接到一台计算机时，您可以打开多个窗口。</li>
<li>您可以在编辑程序的同时对其进行编译和运行。</li>
<li>您可以注销并通过 ssh 重新登录，而无需重新打开所有文件。</li>
</ul>
<h3 id="入门"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#getting-started"></a>入门</h3>
<ul>
<li>开始会话 <code>tmux</code>.</li>
<li>从会话中分离 <code>Ctrl-b d</code>（释放后按 d <code>Ctrl-b</code>)</li>
<li>分成 2 个窗格 <code>Ctrl-b %</code>（垂直）或 <code>Ctrl-b "</code>（水平的）</li>
<li>交换当前窗格 <code>Ctrl-b o</code></li>
<li>在线查找有关 tmux 的更多信息。 您可能会发现 <a href="https://gist.github.com/MohamedAlaa/2961058">此备忘单</a> 很有帮助！</li>
</ul>
<h1 id="包管理">包管理</h1>
<h2 id="debian简介-apt和-dpkg">Debian：简介 <code>apt</code>和 <code>dpkg</code></h2>
<p>在本课程中，我们将重点关注 Debian 的使用。 正如本周讲座中提到的，Debian 使用 apt/dpkg 作为其包管理器。 其他发行版使用不同的包管理器。</p>
<h3 id="apt"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#apt"></a><code>apt</code></h3>
<p>Debian 的前端包管理器是 <code>apt</code>。 大多数时候，当您需要与包管理器打交道时， <code>apt</code>通常是要走的路。 在做任何事情之前 <code>apt</code>，更新包列表通常是一个好习惯，以便包管理器可以找到并获取各种包的最新版本。 为此，您可以运行：</p>
<p><code>apt update</code></p>
<p>要查找要安装的包：</p>
<p><code>apt search [package|description]</code></p>
<p>要安装包：</p>
<p><code>apt install [package]</code></p>
<p>要删除包：</p>
<p><code>apt remove [package]</code></p>
<p>使用安装的软件包一段时间后，您可能会注意到它们不会自动更新，这一功能可能存在于为其他操作系统编写的程序中。 要更新已安装的软件包，请运行：</p>
<p><code>apt upgrade</code>或有时 <code>apt dist-upgrade</code></p>
<p>使用起来比较普遍 <code>apt upgrade</code>更新你的包，但有时你需要使用 <code>apt dist-upgrade</code>。 阅读有关两者之间差异的更多信息 <a href="https://askubuntu.com/questions/194651/why-use-apt-get-upgrade-instead-of-apt-get-dist-upgrade">您可以在此处</a> 。</p>
<p>在某些情况下，您希望完全确定要安装的软件包的版本。 要列出可以安装的潜在版本，您可以运行：</p>
<p><code>apt policy [package]</code></p>
<p>这根据其引脚优先级列出了要安装的候选版本以及与系统兼容的其他版本。 要安装特定目标版本的 aa 版本，您可以运行：</p>
<p><code>apt -t [targetrelease] install [package]</code></p>
<p>还有其他命令可以删除不需要的依赖项并清除包，但这就是 <code>man</code>页面是为了。 请注意，您将必须使用 <code>sudo</code>对于上述命令，因为您实际上是在修改系统本身。</p>
<h3 id="dpkg"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#dpkg"></a><code>dpkg</code></h3>
<p>后端包管理器是 <code>dpkg</code>。 传统上， <code>dpkg</code>用于安装本地软件包。 使用 <code>dpkg</code>，您还可以检查软件包并修复损坏的安装。 要安装本地软件包，请运行：</p>
<p><code>dpkg -i [packagefilename]</code></p>
<p>删除系统包：</p>
<p><code>dpkg --remove [package]</code></p>
<p>要检查包以获取有关该包的更多信息：</p>
<p><code>dpkg -I [packagefilename]</code></p>
<p>要修复/配置所有已解压但未完成的安装：</p>
<p><code>dpkg --configure -a</code></p>
<h2 id="入门-1"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#getting-started"></a>入门</h2>
<h3 id="创建一个简单的包">创建一个简单的包</h3>
<p>现在，我们将使用您将在接下来的步骤中创建的 hellopenguin 可执行文件创建一个简单的包。 首先，移至您在入门部分克隆的存储库中的 a2 文件夹：</p>
<p><code>cd decal-labs/a2</code></p>
<p>现在我们将创建一个文件夹来进行此练习：</p>
<p><code>mkdir ex1</code></p>
<p>现在进入该文件夹：</p>
<p><code>cd ex1</code></p>
<h3 id="编写和编译程序"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#writing-and-compiling-the-program"></a>编写和编译程序</h3>
<p>现在，我们将用 C 语言制作一个非常简单的应用程序，打印“Hello Penguin！” 名为地狱企鹅。 调用：</p>
<p><code>touch hellopenguin.c</code></p>
<p>这将创建一个名为的空文件 <code>hellopenguin.c</code>。 现在，使用您选择的首选文本编辑器，例如 <code>vim</code>, <code>emacs</code>， 或者 <code>nano</code>，将以下代码插入 <code>hellopenguin.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   printf(&quot;Hello Penguin!\n&quot;);</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在将编译您刚刚编写的源文件：</p>
<p><code>gcc hellopenguin.c -o hellopenguin</code></p>
<p>其作用是获取源文件 <code>hellopenguin.c</code>并将其编译为名为的可执行文件 <code>hellopenguin</code>与 <code>-o</code>输出标志。</p>
<h3 id="打包可执行文件"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#packaging-the-executable"></a>打包可执行文件</h3>
<p>现在，我们将创建可执行文件所在的文件夹结构。在 Debian 中，用户级包通常驻留在该文件夹中 <code>/usr/bin/</code>:</p>
<p><code>mkdir -p packpenguin/usr/bin</code></p>
<p>现在移动你编译的 <code>hellopenguin</code>可执行到 <code>packpenguin/usr/bin/</code>文件夹。</p>
<p><code>mv hellopenguin packpenguin/usr/bin/</code></p>
<p>现在我们将创建一个名为 <code>hellopenguin</code>。 移动到父目录 <code>packpenguin</code>文件夹并调用以下命令：</p>
<p><code>fpm -s dir -t deb -n hellopenguin -v 1.0~ocf1 -C packpenguin</code></p>
<p>这指定您要使用目录 <code>-s</code>标志，并输出 <code>.deb</code>包使用 <code>-t</code>旗帜。 它接受一个名为的目录 <code>packpenguin</code>， 使用 <code>-C</code>标志，并输出 <code>.deb</code>文件名为 <code>hellopenguin</code>， 使用 <code>-n</code>，版本号为 <code>1.0~ocf1</code>， 使用 <code>-v</code>旗帜。</p>
<p>现在通过调用 apt 并安装它来测试它：</p>
<p><code>sudo dpkg -i ./hellopenguin_1.0~ocf1_amd64.deb</code></p>
<p>现在你应该能够运行 <code>hellopenguin</code>通过执行以下操作：</p>
<p><code>hellopenguin</code></p>
<h1 id="计算机网络">计算机网络</h1>
<h2 id="概述">概述</h2>
<p>不可否认，互联网是一个重新定义了我们世界的重要系统。 开发网络和允许设备通信的能力对于现代计算机系统至关重要。 本实验将研究计算机网络的基础知识，然后从系统管理员的角度检查网络。</p>
<p>我们将使用网页浏览作为类比来了解网络的基础知识。 当我上网浏览猫的图片时到底会发生什么？</p>
<p>但首先让我们简要了解一下网络的细节。</p>
<hr />
<h2 id="硬件地址mac"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#mac"></a>硬件地址mac</h2>
<p>媒体访问控制 (MAC) 地址是唯一分配给网络接口的标识符。 <img src="https://upload.wikimedia.org/wikipedia/commons/9/94/MAC-48_Address.svg" title="MAC地址格式" alt="所有文字" /></p>
<p>由于 MAC 地址是唯一的，因此通常称为物理地址。 八位位组通常以十六进制书写并用冒号分隔。 MAC 地址示例是 <code>00:14:22:01:23:45</code>。 请注意，前 3 个八位位组指的是组织唯一标识符 (OUI)，它可以帮助识别制造商。 有趣的事实—— <code>00:14:22</code>以上是 Dell 的 OUI。</p>
<h2 id="ip"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#ip"></a>ip</h2>
<p>IP 地址是识别根据互联网协议连接到网络的设备的方法。 互联网协议有两个版本：IPv4 和 IPv6，它们的地址大小不同。 IPv6 地址示例是 <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>它比 IPv4 地址长得多，例如 <code>127.0.0.1</code>。 由于时间关系，我们只讨论 IPv4，但 IPv6 确实正在取得进展，值得一试！</p>
<p>IPv4 地址为 32 位，即 4 个字节，每个字节由点 (.) 分隔。 IPv4 地址示例是 <code>127.0.0.1</code>。 巧合的是，这个地址被称为环回地址，它映射到您自己机器上的环回接口。 这允许网络应用程序在同一台计算机（在本例中是您的计算机）上运行时相互通信。 但为什么 <code>127.0.0.1</code>并不是 <code>127.0.0.0</code>或者 <code>127.0.0.2</code>?</p>
<p>答案是 <code>127.0.0.1</code>是简单的约定，但从技术上讲，网络块中的任何地址 <code>127.0.0.0/8</code>是一个有效的环回地址。 但网络块到底是什么？</p>
<p>在 IPv4 中，我们可以将地址块划分为子网。 这是以 CIDR 格式编写的。 我们以上面的子网为例 <code>127.0.0.0/8</code>。 斜杠后面的数字 ( <code>/</code>)，在本例中为 8，是子网掩码。 这表示网络地址中有多少位，其余位标识网络内的主机。 在这种情况下，网络地址是 <code>127.0.0.0</code>面具是 <code>255.0.0.0</code>。 所以 <code>127.0.0.1</code>将是第一个主机 <code>127.0.0.0/8</code>网络等等。</p>
<p>该图提供了 CIDR 寻址的可视化细分 <img src="https://i.imgur.com/dEgcX0R.png" title="CIDR 寻址示例由 CS168 提供" alt="所有文字" /></p>
<h2 id="arp"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#arp"></a>ARP</h2>
<p>地址解析协议 (ARP) 是用于将 IP 地址解析为 MAC 地址的协议。 为了理解ARP，我们首先讨论发送帧的两种方式，单播和广播。 在第 2 层上下文中，单播帧意味着将该帧发送到一个 MAC 地址。 另一方面，通过将帧发送到广播地址来广播帧意味着该帧应该发送到网络上的每个设备，从而有效地“淹没”本地网络。</p>
<p>例如，让我们想象一个发送者 A，他有 MAC <code>00:DE:AD:BE:EF:00</code>，广播一条消息，本质上是询问“谁拥有 IP 地址 <code>42.42.42.42</code>请在 00:DE:AD:BE:EF:00 告诉 A”。</p>
<p>如果一台机器B，有MAC <code>12:34:56:78:9a:bc</code>有IP地址 <code>42.42.42.42</code>他们向发件人发送单播回复，其中包含以下信息“ <code>12:34:56:78:9a:bc</code>有 <code>42.42.42.42</code>”。 发送方将此信息存储在 arp 表中，因此每当它收到发往机器 B 的数据包时，即目标 IP 地址为 <code>42.42.42.42</code>它将数据包发送到从 B 收到的 MAC。</p>
<p>为了路由 IP 数据包，设备具有所谓的路由表。 路由条目存储在路由表中，它们本质上是告诉设备应如何基于 IP 转发数据包的规则。 路由条目指定子网以及与该条目对应的接口。 设备选择具有最特定于给定数据包的子网的条目，并将其转发出该条目上的接口。</p>
<p>路由表通常也有一个默认网关。 在没有更具体的匹配条目的情况下，这将用作数据包的默认捕获所有内容。</p>
<p>以此路由表为例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default via 10.0.2.2 dev eth0</span><br><span class="line">10.0.2.0/24 dev eth0  proto kernel  scope link  src 10.0.2.15</span><br><span class="line">10.0.2.128/25 dev eth0  proto kernel  scope link  src 10.0.2.15</span><br><span class="line">192.168.162.0/24 dev eth1  proto kernel  scope link  src 192.168.162.162</span><br></pre></td></tr></table></figure>
<p>一个数据包的目的地是 <code>8.8.8.8</code>将从默认网关 eth0 转发出去。 一个数据包的目的地是 <code>10.0.2.1</code>将根据第二个条目从 eth0 转发。 一个数据包的目的地是 <code>10.0.2.254</code>将根据第三个条目从 eth0 转发。 一个数据包的目的地是 <code>192.168.162.254</code>将根据第四个条目从 eth1 转发。</p>
<h2 id="域名"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#dns"></a>域名</h2>
<p>我们已经讨论了 IP 地址以及它们如何通过 IP 与主机进行通信，但是虽然 IP 地址是机器友好的（计算机喜欢数字），但它们并不完全是人类友好的。 记住电话号码已经够难了，记住 32 位 IP 地址也不会更容易。</p>
<p>但我们更容易记住 &lt;www.google.com、www.facebook.com&gt; 或 Coolmath-games.com 等名称。 因此，在这种冲突中，域名系统 (DNS) 诞生了，它是机器友好的 IP 地址和人类友好的域名之间的折衷方案。</p>
<p>DNS 是一个将 google.com 等域名映射到 <code>172.217.6.78</code>。 当您查询 google.com 时，您的计算机会将 google.com 的 DNS 查询发送到 DNS 服务器。 假设配置正确并且 google.com 有一个有效的对应地址，您将收到来自权威服务器的响应，其实质上是“google.com 有 IP 地址” <code>x.x.x.x</code>”.</p>
<p>现在让我们稍微消除一下这个黑魔法……</p>
<h2 id="dns-记录"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#dns-records"></a>DNS 记录</h2>
<p>DNS 服务器以资源记录 (RR) 的形式存储数据。 资源记录本质上是（名称、值、类型、TTL）的元组。 虽然 DNS 记录的类型多种多样，但我们最关心的是</p>
<ol type="1">
<li><p><strong>一条记录</strong> 名称 = 主机名 值 = IP 地址</p>
<p>该记录非常简单，包含给定主机名的 IP 地址，本质上是我们最终想要得到的信息。</p></li>
<li><p><strong>国民服役记录</strong> 名称=域名 值 = 域的 DNS 服务器名称</p>
<p>该记录指向另一个可以为该域提供权威答案的 DNS 服务器。 将此视为将您重定向到另一个名称服务器。</p></li>
<li><p><strong>CNAME 记录</strong> 名称 = 别名 值=规范名称</p>
<p>这些记录指向给定别名的规范名称，例如 docs.google.com 将是一个仅指向 document.google.com 的别名 尝试 &lt;www.facebook.com&gt;</p></li>
<li><p><strong>MX记录</strong> 邮件服务使用的记录。</p></li>
</ol>
<h2 id="tcp-和-udp"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#tcp-and-udp"></a>TCP 和 UDP</h2>
<p>现在我们将讨论传输层的协议。 这一层最著名的两个协议是传输控制协议（TCP）和用户数据报协议（UDP）。</p>
<p>TCP 是一种面向有状态流的协议，可确保可靠的传输。 可靠的传输本质上保证信息完整且有序地到达目的地。</p>
<p>TCP 是面向连接的协议，这意味着它在发送任何数据之前必须首先建立连接。 此连接交换信息，这是 TCP 用于在其他功能中提供可靠传输的机制。 TCP 连接以 TCP 握手开始。</p>
<p>TCP 握手包括在发送方和接收方之间交换的数据包的 TCP 标头中设置某些标志。 发送方首先发送 SYN（设置了 SYN 标志的数据包）来启动 TCP 连接。 服务器通过发回 SYN-ACK（一个同时设置了 SYN 和 ACK 标志的数据包）来确认此连接请求。 客户端通过向服务器发送一个最终 ACK 来确认这一点，然后建立连接。</p>
<p>TCP 然后开始传输数据，如果数据成功到达连接的另一端，则会发出 ACK。 因此，如果数据丢失、重新排序或损坏，TCP 能够识别这一点并发送重传任何丢失数据的请求。</p>
<p>TCP 也有一个关闭连接的过程。 我们在这里只考虑优雅终止，突然终止有不同的过程，我们不会讨论。 如果您有兴趣，CS168 <a href="https://drive.google.com/file/d/0B4GG2Ks7ZJf5RlpRby1Qbk8zcTg/view">这里</a> 有一些很棒的材料。 假设机器 A 想关闭与机器 B 的连接。</p>
<p>A 首先发送 FIN。 B 必须通过发送 FIN 和 ACK 进行响应。 如果 B 仅发送 ACK，则连接将持续存在，并且可以发送其他数据，直到发送 FIN。 另一方面，如果 B 准备好关闭连接并且不需要发送额外的数据，则 B 也可以只发送一个同时设置了 FIN 和 ACK 标志的数据包，即 FIN+ACK。发送最后一个 ACK​​ 来表示连接终止。</p>
<p>UDP是无状态无连接协议。 UDP 专注于以数据报的形式发送消息。 无连接 UDP 也不会产生 TCP 握手和终止的开销。 UDP 也不保证可靠传输，因此消息可能会损坏、无序到达或根本不到达。 因此，UDP 有时被称为不可靠数据报协议。</p>
<p>虽然 UDP 不保证可靠传输，但它不会像 TCP 那样遭受建立和关闭连接的开销。 因此，UDP 非常适合我们只想快速发送数据包并且丢失一些数据包也不会造成灾难性后果的使用情况。</p>
<p>此外，与 TCP 相比，发送的每个 UDP 数据报都需要单独接收。 而对于 TCP，您传递的数据流被透明地分成一定数量的发送，并且数据流在另一端透明地重建为一个整体。</p>
<h2 id="端口"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#ports-optional"></a>端口</h2>
<p>广义上讲，端口定义了服务端点——端口标记了流量的入口和出口点。 IP 地址连接主机，而端口则连接在此类主机上运行的进程。 一次只能将一个进程绑定到一个端口。 端口由 16 位数字表示，范围从 0 到 65535。从 0 到 1023 的端口是众所周知的端口，即系统端口。 使用这些端口通常有更严格的要求。 1024 到 49151 是注册端口。 官方 <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">列表</a> IANA 维护着知名和注册范围的 。 从 49152 到 65535 的其余端口是临时端口，可以根据每个请求动态分配给通信会话。</p>
<h1 id="systemd-unit">systemd unit</h1>
<p><a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">unit的介绍和写法</a> Linux 发行版越来越多地采用 <code>systemd</code>初始化系统。 这套功能强大的软件可以管理服务器的许多方面，从服务到安装的设备和系统状态。</p>
<p>在 <code>systemd</code>， A <code>unit</code>指系统知道如何操作和管理的任何资源。 这是主要对象 <code>systemd</code>工具知道如何处理。 这些资源是使用称为单元文件的配置文件定义的。</p>
<p>单位是对象 <code>systemd</code>知道如何管理。 这些基本上是系统资源的标准化表示，可以由守护程序套件管理并由提供的实用程序操作。</p>
<p>单元可以说类似于其他 init 系统中的服务或作业。 然而，单元具有更广泛的定义，因为它们可用于抽象服务、网络资源、设备、文件系统挂载和隔离资源池。 系统的单元文件副本一般保存在 <code>/lib/systemd/system</code>目录。 当软件在系统上安装单元文件时，这是它们默认放置的位置。</p>
<p>存储在此处的单元文件可以在会话期间按需启动和停止。 这将是通用的普通单元文件，通常由上游项目的维护人员编写，应该适用于部署的任何系统 <code>systemd</code>在其标准实施中。 您不应编辑此目录中的文件。 相反，如果有必要，您应该使用另一个单元文件位置来覆盖该文件，该位置将取代该位置中的文件。 正确的方法是创建一个以单元文件命名的目录 <code>.d</code>附加在最后。 所以对于一个叫做 <code>example.service</code>，一个名为 <code>example.service.d</code>可以被创建。 在此目录中，有一个以以下结尾的文件 <code>.conf</code>可用于覆盖或扩展系统单元文件的属性。</p>
<p>大多数单元文件中的第一部分是 <code>[Unit]</code>部分。 这通常用于定义单元的元数据并配置单元与其他单元的关系。</p>
<p>尽管部分顺序并不重要 <code>systemd</code>解析文件时，此部分通常放置在顶部，因为它提供了单元的概述。 您可以在以下位置找到一些常见指令 <code>[Unit]</code>部分是：</p>
<ul>
<li><strong><code>Description=</code></strong>：该指令可用于描述单元的名称和基本功能。 它由各种返回 <code>systemd</code>工具，因此最好将其设置为简短、具体且信息丰富的内容。</li>
<li><strong><code>Documentation=</code></strong>：该指令提供了文档 URI 列表的位置。 这些可以是内部可用的 <code>man</code>页面或网络可访问的 URL。 这 <code>systemctl status</code>命令将公开此信息，以便于轻松发现。</li>
<li><strong><code>Requires=</code></strong>：该指令列出了该单元本质上依赖的所有单元。 如果当前单位已激活，则此处列出的单位也必须成功激活，否则该单位将失败。 默认情况下，这些单元与当前单元并行启动。</li>
<li><strong><code>Wants=</code></strong>：该指令类似于 <code>Requires=</code>，但不太严格。 <code>Systemd</code>当此单元被激活时，将尝试启动此处列出的任何单元。 如果未找到这些单元或无法启动，当前单元将继续运行。 这是配置大多数依赖关系的推荐方法。 同样，这意味着并行激活，除非被其他指令修改。</li>
<li><strong><code>BindsTo=</code></strong>：该指令类似于 <code>Requires=</code>，但也会导致当前单元在关联单元终止时停止。</li>
<li><strong><code>Before=</code></strong>：如果同时激活了该指令中列出的单元，则只有当前单元被标记为已启动后，它们才会启动。 这并不意味着依赖关系，并且如果需要的话必须与上述指令之一结合使用。</li>
<li><strong><code>After=</code></strong>：该指令中列出的单元将在启动当前单元之前启动。 这并不意味着依赖关系，如果需要，必须通过上述指令建立依赖关系。</li>
<li><strong><code>Conflicts=</code></strong>：这可用于列出不能与当前单元同时运行的单元。 启动具有这种关系的单元将导致其他单元停止。</li>
<li><strong><code>Condition...=</code></strong>: 有许多指令以 <code>Condition</code>这允许管理员在启动设备之前测试某些条件。 这可用于提供仅在适当的系统上运行的通用单元文件。 如果不满足条件，则会正常跳过该单元。</li>
<li><strong><code>Assert...=</code></strong>：类似于以 <code>Condition</code>，这些指令检查运行环境的不同方面，以决定是否应激活该单元。 然而，与 <code>Condition</code>指令，负结果会导致该指令失败。</li>
</ul>
<h1 id="安全管理">安全管理</h1>
<h2 id="加密与解密">加密与解密</h2>
<h3 id="基础知识">基础知识</h3>
<p>加密采用明文和密钥，返回密文。 解密需要密文和密钥，仅当解密密钥有效时才恢复并返回原始明文。 加密和解密的密钥是由随机位组成的长字符串，这使得攻击者在计算上无法猜测密钥并解密密文。</p>
<p><img src="https://docs.oracle.com/cd/E19424-01/820-4811/images/scrypt.gif" alt="一切" /> 安全性是指在面对攻击时保持系统按预期运行 这可以采取多种形式：</p>
<ol type="1">
<li>保密性</li>
<li>完整性/真实性</li>
<li>可用性</li>
</ol>
<p>模块：</p>
<ol type="1">
<li>认证</li>
<li>加密：防止攻击者读取您的文件，直到它们得到 联邦调查局和他们的密码学家参与其中</li>
<li>哈希：将大数据转化为小数据</li>
<li>签名和证书：确保您就是您所说的人 假设我想使用你的公钥来验证你的身份。 我 可以用它加密一些东西，并要求你解密它并且 显示正确的值。 如果您可以解密该值，那么您必须拥有密钥的私有部分并且可以进行身份​​验证。 假设你想证明你发送的消息实际上是由您发送。 您可以使用您的私钥来“签署”消息通过对其进行加密，您的公钥可用于解密签名以验证您（由您发布的公开信息识别）键）实际上确实发送了消息，因为只有您而不是其他人对手将拥有相应的私钥。 <code>根证书</code>：操作系统包含许多根证书 这是网络信任的基础。 证书是在通向根的链中签名； 如果链有效，则最后的 cert 被认为是可信的。</li>
</ol>
<p>网络攻击： 攻击网络系统的方法有很多： 窃听、中间人、拒绝服务、应用程序 缓冲区/堆溢出、SQL 注入等漏洞 目录遍历、CSRF、SSRF、XSS、蠕虫、rootkit、垃圾邮件、加密挖矿、勒索软件、网络钓鱼等等……</p>
<h3 id="对称密码学"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#symmetric-cryptography"></a>对称密码学</h3>
<p>在对称密码学中，用于加密和解密的密钥是相同的。</p>
<p>尝试一下：</p>
<ol type="1">
<li><code>gpg --symmetric [FILE]</code>在任何文件上输出 <code>[FILE].gpg</code>文件是输入文件的加密版本。 加密文件时需要输入密码。</li>
<li><code>gpg --decrypt [FILE].gpg</code>在原始文件的加密版本上，您需要输入原始密码。</li>
</ol>
<p>在此 GPG 实现中，文件的加密和解密都需要知道单个密码，在本例中该密码充当对称密钥。</p>
<h3 id="非对称密码学"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#asymmetric-cryptography"></a>非对称密码学</h3>
<p>在非对称加密中，两个单独的密钥分别用于加密和解密。 这两个密钥是一对公私密钥。 公钥是公开的并用于加密数据。 而私钥由所有者保密并用于解密数据。 使用公钥加密文件意味着只有拥有相应私钥的人才能解密生成的加密文件。</p>
<h4 id="gpg-钥匙圈抽象"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#gpg-keyring-abstraction"></a>GPG 钥匙圈抽象</h4>
<p>GPG 使用“密钥环”作为集中位置来保存用户的所有密钥。 如果您想使用并保留它，则需要向密钥环添加/导入密钥。 同样，如果您希望与其他人共享密钥，您可以导出您的密钥（这会生成您的密钥的副本）并让他们将其导入到他们的密钥环中。</p>
<p>尝试一下：</p>
<ol type="1">
<li><code>gpg --full-generate-key</code>生成 GPG 公私密钥对。 它会要求输入密码。 <em>如果您的机器需要一段时间才能生成密钥，则可能是由于缺乏长随机密钥所需的熵（随机性）。 <code>sudo apt-get install haveged</code>将安装一个生成熵的守护进程。</em></li>
<li><code>gpg --recipient [RECIPIENT] --encrypt [FILE]</code>这将加密 <code>[FILE]</code>和 <code>[RECIPIENT]</code>的公钥（目前，尝试使用您自己的公钥加密文件）。</li>
<li><code>gpg --decrypt [FILE].gpg</code>将搜索您的密钥环并使用适当的私钥解密文件（当然，如果您拥有正确的私钥）。 <em>您无需指定使用哪个密钥来解密文件，因为 GPG 加密的文件和密钥包含元数据，允许 GPG 从密钥环中选择正确的密钥来解密文件。</em></li>
</ol>
<h3 id="签名"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#signatures"></a>签名</h3>
<p>公钥加密、私钥解密的非对称方案也可以反过来实现数字签名，其作用相当于物理签名。 在这个相反的方案中，私钥用于对文件进行签名，从而在该文件上生成签名。 并使用相应的公钥来验证签名。 因此，只有拥有私钥的人才能生成签名，但拥有相应公钥的任何人都可以验证该签名。 <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Illustration_of_digital_signature.svg/1920px-Illustration_of_digital_signature.svg.png" /></p>
<p>UNIX 权限模型有 3 个组成部分：授予文件的 (1) 所有者用户、(2) 所有者组和 (3) 其他人/其他所有人的权限。 权限本身有 3 个子组件：(1) 读取、(2) 写入和 (3) 执行，强制执行读取、写入或执行文件的能力。</p>
<p><img src="https://www.comentum.com/images/permissions.jpg" /></p>
<h3 id="gpg">gpg</h3>
<ol type="1">
<li>解密b8/file1.txt.gpg:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --decrypt b8/file1.txt.gpg </span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>输入密码ocfdecal后,解密内容为: mYp@sw0rd2. 导入密钥的命令是:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --import &#123;key_file&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>将密钥导出到文件的命令:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --export --armor &#123;key_id&#125; &gt; &#123;output_file&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>查看钥匙圈所有钥匙的命令:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --list-keys</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>使用私钥b8/lab8privkey解密b8/file2.txt.gpg:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --import ./lab8privkey</span><br><span class="line">gpg --decrypt  ./file2.txt.gpg</span><br></pre></td></tr></table></figure>
<h3 id="hash">hash</h3>
<ol type="1">
<li><code>sha1sum [FILE]</code>获取 SHA1 哈希值 <code>[FILE]</code>.</li>
<li><code>md5sum [FILE]</code>获取 MD5 哈希值 <code>[FILE]</code>.</li>
</ol>
<h2 id="安全系统">安全系统</h2>
<h3 id="威胁模型">威胁模型</h3>
<p>设计安全系统时要记住的最重要的事情是 了解您的威胁模型。 没有系统能够保证安全或能够 能够抵挡所有的攻击，甚至在极端的情况下也是不可能的。 对手。 但是，您可以（并且应该）针对威胁采取预防措施 你很可能会面临。 平衡授权用户访问的需求 在将未经授权的用户拒之门外的情况下，很容易出错。 幸运的是，聪明人已经将安全原则提炼为 中得到了很好的 <a href="http://www.icir.org/vern/cs161-sp17/notes/Principles.1.19.pdf">第一个讲义</a> 一些公理，在CS 161 的 介绍 （归功于大卫·瓦格纳教授）。 建议阅读讲义。</p>
<p><strong>构建威胁模型时，请记住以下问题：</strong></p>
<ol type="1">
<li>你在保护什么？</li>
<li>谁是你的对手？</li>
<li>您需要保护它的可能性有多大？</li>
<li>如果不加以保护，会产生什么后果？</li>
<li>您应该投入多少资源来保护它？</li>
</ol>
<h3 id="加密解密">加密解密</h3>
<p><strong>对称密钥加密几乎对所有事物都有用，尤其是属于以下类别的事物：</strong></p>
<ul>
<li>加密传输中的数据（例如 HTTPS）</li>
<li>加密静态数据（例如手机上存储的数据）</li>
</ul>
<p>作为示例，我们来探讨一下 iPhone 如何使用加密来保证数据安全：</p>
<ol type="1">
<li>iPhone 的内部存储使用一组 AES 密钥进行加密，这些密钥存储在手机内部芯片上，并在工厂生成。</li>
<li>这些密钥又使用您的 PIN 进行加密。 您的 PIN 码允许手机解锁密钥，从而解密文件系统的其余部分。</li>
</ol>
<p>与对称密钥加密不同，公钥加密中有 2 个密钥 ，密码系统由<strong>公钥</strong> 和 <strong>私钥</strong>组成 。 顾名思义， 公钥是公开共享的，这是其他人可以使用的方式 加密适合您的数据。 您使用您的私钥来解密此内容 数据。 只要没有人拥有你的私钥，任何人都可以使用你的公钥 加密数据并确保只有您可以解密它。 这是一个强大的 对称密钥范式的扩展，除了加密之外，它还允许 签名和不可否认性 公钥密码学与 <strong><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA 算法</a></strong> 同义， 是最早经过验证的双密钥方案之一。 <strong>RSA 公钥加密工作原理的简要概述</strong>：</p>
<ol type="1">
<li>RSA算法，通过一些高等数学（涉及素数和模数） 算术），返回 3 个数字：一个公共指数（又名密钥），一个私有指数， 和一个模数。 两个密钥的工作方式使得用一个密钥加密的数据只能 可以用另一个密钥解密。</li>
<li>为了加密数据，需要使用指数和模数之一对数据执行模幂运算。</li>
<li>为了解密数据，对加密数据进行模幂运算 与合作伙伴密钥和模数。 常用时，使用较大的指数 作为私钥，用于解密数据和创建签名， 较小的指数作为公钥，用于加密数据 并验证签名。 比如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>
<p>该命令将生成两个文件， <code>~/.ssh/id_rsa</code>和 <code>~/.ssh/id_rsa.pub</code>。 正如命令所示，此命令生成 4096 位 RSA 密钥对。 你 应该能够猜测哪个文件代表公钥以及哪个文件必须 因此是私钥。 为了影响安全 SSH 登录，请使用 RSA密钥，用户必须首先将他们想要使用的公钥传输到 提前向服务器表明自己的身份。 然后，一旦会话结束 服务器和客户端之间建立的，服务器会加密一个随机数 号码与用户的公钥并发送给用户。 用户将 然后使用他们的私钥解密该值并返回该值的哈希值 到服务器，然后服务器可以自己散列该值以确定用户是否 能够成功解密随机数，从而表明拥有 匹配的密钥并作为身份验证的证据。</p>
<h3 id="签名和证书">签名和证书</h3>
<p>一开始，您 将发布 Natoshi 的公钥，此后，对于您发布的每个帖子，您 将使用您（Natoshi）的私钥对消息内容进行加密，并且 将其与您的原始消息一起发布。 那么，想验证的人 Natoshi（即公钥对应的私钥的所有者 属于 Natoshi）实际上确实发布了一条特定的消息，可以简单地 使用 Natoshi 的公钥解密加密签名并比较 内容与原始消息相反。</p>
<p>Natoshi 王位的觊觎者将是 无法签署他们的虚假声明，以便可以与他们核实 Natoshi 公开了公钥，因为他们没有 Natoshi 的私钥， 您可以放心，没有人会过度影响您的项目 当你躲避 IRS 和 DEA 时，除非他们碰巧有 仓库里装满了 ASIC 和大量廉价电力。</p>
<p><strong>然而，在这个方案中，如何防止对手发布虚假信息 公钥并声称是您？</strong> （他们可以对此进行有效签名 假公钥）不知何故，你需要“引导”信任：有人需要 验证您的身份并公开确认您的公钥实际上 对应于你。</p>
<p>我们通过 <strong>证书</strong> 来做到这一点：签署的声明 声称特定的公钥实际上属于它所声称的人 属于。</p>
<p>谁签署此证书？ 一个 <strong>证书颁发机构</strong> ，我们的某人 信任负责验证身份和发布签名。</p>
<p>但是我们如何知道要信任哪些 CA，以及我们如何才能信任声称 真正值得信赖的是？ 他们可能还需要证书。 它 听起来好像一路下来都是海龟； 然而，链条确实结束了 某处：所谓的信任根，根 CA。 这些 CA 的 证书是由浏览器和操作系统预安装的，因此 本质上受信任，无需任何进一步的证书。 如果根 CA 签署您的证书，我们假设他们已经完成了必要的尽职调查 愿意冒着声誉风险签署您的证书，并且基本上 相信他们的话。 这种模型被称为“ <strong>信任网络”</strong> ，是网络如何 今天的安全工作正常进行。</p>
<p>不幸的是，它并不像我们希望的那样可靠： 有些 CA 很卑鄙，只要有足够的钱就会签署任何东西，从而导致有效的 为 microsoft.com 和 github.com 等域颁发的证书 显然不是 Microsoft 或 GitHub 的实体。 <a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/#fn:badwosign">1</a> 此外， 任何拥有足够边境控制的实体都可以强制安装自己的 根证书（例如哈萨克斯坦政府 <a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/#fn:badkazakh">2</a> ) 并截取 通过为任何域颁发自己的伪造证书来窃取任何流量。</p>
<p>您可能没有意识到，但 <strong>您使用并依赖证书和签名 每天。</strong> 每当您在网站地址栏附近看到绿色锁时， 访问，您正在通过 TLS 或 HTTPS 连接访问该网站，并且数据 您和网站之间的传输是加密的。 当你的浏览器 连接到网站的服务器，它会按顺序请求服务器的公钥 设置加密连接和服务器证书以便 验证其作为授权为您拥有的域提供服务的服务器的身份 要求。 然后，您的浏览器通过验证公钥来验证公钥 证书上的签名。 如果有人试图执行 对您进行中间人攻击，此证书验证步骤将失败， 因为受信任的 CA 不太可能颁发签名的证书 将您的域名转让给您以外的实体（除非您不幸 居住在哈萨克斯坦）。 您将收到一条非常侵入性的通知 这个事实，忽略证书验证是一个坏主意 失败通知。</p>
<p><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/">怎么为自己的网站设置https加密传输数据</a> 现在您有了一个网站，您决定，作为一个优秀的互联网公民，您 希望保护您的访客免受政府的窥探，通过 设置 HTTPS。 您已经知道您将需要一个公钥和一个 为此，由受信任的根 CA 签署的证书。 你怎么去 关于得到一个？ 在互联网上搜索，你发现了一个很棒的项目，名为 <a href="https://letsencrypt.org">Let's Encrypt</a> 提供免费、签名的服务 证书。</p>
<h3 id="文件安全">文件安全</h3>
<p><img src="https://www.comentum.com/images/permissions.jpg" /> 作为 <code>root</code>用户。 当程序启动时，它会继承其用户 ID 和组 ID 父进程，并保留它们，除非手动删除权限。 如果你 以 root 用户身份启动程序，因为，例如，它需要更深入的 系统访问，程序中的漏洞意味着攻击者可以 以 root 用户身份与您的计算机进行交互。 这是一个常见问题 错误配置的网络服务器，其中服务器以根目录运行 遍历漏洞可能允许攻击者读取秘密凭证 存储在服务器的文件系统上。</p>
<p>这个故事的寓意与最小特权原则紧密相连：无论在哪里 可能的话，只给予尽可能少的许可或特权。 如果 程序不需要 root 凭据，请勿以特权用户身份运行它。 如果 文件包含敏感内容，请勿使其可读。</p>
<p>如何更改权限？ 有两个主要命令可以执行此操作： <code>chmod</code>和 <code>chown</code>. <code>chmod</code>更改文件模式，即权限，以及 其语法示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -la ~/</span><br><span class="line">drwxr-xr-x 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod 644 test</span><br><span class="line">$ ls -la</span><br><span class="line">drw-r--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod u+x test</span><br><span class="line">drwxr--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod 000 test</span><br><span class="line">d--------- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod +r test</span><br><span class="line">dr--r--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br></pre></td></tr></table></figure>
<p><code>chmod</code>接受八进制表示法的文件权限，即 下列的：</p>
<table>
<thead>
<tr class="header">
<th>#</th>
<th>读写</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7</td>
<td>读写</td>
</tr>
<tr class="even">
<td>6</td>
<td>RW-</td>
</tr>
<tr class="odd">
<td>5</td>
<td>接收</td>
</tr>
<tr class="even">
<td>4</td>
<td>r–</td>
</tr>
<tr class="odd">
<td>3</td>
<td>-wx</td>
</tr>
<tr class="even">
<td>2</td>
<td>-在-</td>
</tr>
<tr class="odd">
<td>1</td>
<td>-X</td>
</tr>
<tr class="even">
<td>0</td>
<td>—</td>
</tr>
</tbody>
</table>
<h1 id="pueept">pueept</h1>
<p>● 流行的配置管理软件 ● 用于配置单个机器 ● 声明性哲学，必要时带有一些命令式组件 ● 最初基于 Ruby 构建，现在拥有自己的配置语言 流程： ● 客户端向服务器请求更新 ○ “我想配置为 Minecraft 服务器” ● 服务器向客户端询问事实列表 ○ “好的，请将您的主机名和 RAM 发送给我” ● 客户用事实回应 ○ “我的主机名是僵尸.ocf.berkeley.edu，我有 4GB RAM” ● 服务器响应配置 ○ “确保 Minecraft 服务器正在运行，主机名为僵尸.ocf.berkeley.edu，4GB RAM， 这个配置文件 ● 客户端进行必要的更改以确保其当前配置与 服务器给出的配置 ○ “minecraft服务器当前正在运行，但配置文件已更新，我将获取 更新后的版本 Puppet是一个配置管理工具,通过Puppet可以实现对大量服务器/主机的集中化、自动化的配置管理。Puppet的工作原理是:</p>
<ol type="1">
<li>在Puppet Master服务器上面编写Puppet Manifests(配置文件)。这些文件使用Puppet语言定义了服务器的最终状态。</li>
<li>Puppet Agent安装在被管理的主机上面,它会定期从Puppet Master拉取配置。</li>
<li>Puppet Agent对本地服务器状态进行检查,然后根据Manifests对服务器进行配置,确保服务器状态与预期状态一致。</li>
<li>如果配置发生变化,Puppet会自动应用这些变化,无需手动操作。</li>
<li>Puppet Agent会定期运行,如果配置失效会再次修正。所以Puppet脚本就是编写Puppet Manifests的文件,它定义了需要配置什么,怎么配置。常见的配置包括:- 安装软件</li>
</ol>
<ul>
<li>管理服务<br />
</li>
<li>配置文件内容<br />
</li>
<li>用户和权限<br />
</li>
<li>安全设置<br />
</li>
<li>定时任务 等等通过Puppet脚本可以实现服务器配置的版本控制、自动化部署,大幅减少管理时间成本。它适用于需要管理大量Linux/Unix主机的场景。</li>
</ul>
<h1 id="git">git</h1>
<p>创建一个分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b dice</span><br></pre></td></tr></table></figure>
<p>这使得一个新的本地分支称为 <code>dice</code>基于我们所在的分支机构 目前在（ <code>master</code>）并将您切换到 <code>dice</code>分支。 这个命令是 基本上简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch dice       # Create new branch called &#x27;dice&#x27;</span><br><span class="line">git checkout dice     # Switch to branch called &#x27;dice&#x27;</span><br></pre></td></tr></table></figure>
<p>您可以通过键入来查看您创建的分支 <code>git branch</code>。 你应该看到 此时有两个分支，一个称为 <code>master</code>和一个叫 <code>dice</code>。 一个 星号位于您当前签出的分支旁边。 <code>git log</code>查看历史提交。 每个提交都有一些信息，例如提交的作者、 创建提交的时间戳和提交消息。</p>
<ul>
<li><p>每个提交条目的第一行都有一个长的十六进制字符串。 这是 commit <em>hash</em> ：将其视为可用于引用的唯一 ID 具体提交。</p></li>
<li><p>有些提交在提交哈希旁边的括号中包含分支信息， 表明它们是最近的提交或 <code>HEAD</code>那个分支的。 你的 最近的提交应该有类似的内容 <code>(HEAD -&gt; dice)</code>。 第四个 提交应该有 <code>(origin/master, origin/HEAD)</code>因为我们的分支机构 关闭 <code>master</code>并在其之上添加了三个新的提交。 请注意，如果 有人向本地或远程添加新提交 <code>master</code>， 分支 信息可能会更改或过时。</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit adc45cd5110b59f76cefc2b862d0e4d550ccb183 (HEAD -&gt; dice)</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:32:35 2023 +0800</span><br><span class="line"></span><br><span class="line">    Restrict input range for dice iterations and sides</span><br><span class="line"></span><br><span class="line">commit a79a770157449a9d2fb1595a0b83ecc99070eabf</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:31:56 2023 +0800</span><br><span class="line"></span><br><span class="line">    Add dice rolling logic and output dice sum and sequence</span><br><span class="line"></span><br><span class="line">commit 924d0b1ebf050a043da434114187a290280ec660</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:30:45 2023 +0800</span><br><span class="line"></span><br><span class="line">    Add -s flag for number of sides on a die</span><br><span class="line"></span><br><span class="line">commit 3acb62af3eff4a1dbbe875e81ec1485d9d10c44b (origin/master, origin/HEAD, master)</span><br><span class="line">Merge: 4e2aac7 2aefa6c</span><br><span class="line">Author: Ishaan Dham &lt;56564174+Ishaandham19@users.noreply.github.com&gt;</span><br><span class="line">Date:   Tue Mar 21 21:39:51 2023 -0700</span><br><span class="line"></span><br><span class="line">    Merge pull request #34 from 0xcf/demo</span><br><span class="line"></span><br><span class="line">    Demo</span><br><span class="line"></span><br><span class="line">commit 2aefa6c51449ffcd39d945e3d74ce2b5e50acf7f (origin/demo)</span><br><span class="line">Author: Ishaan Dham &lt;ishaandham01@gmail.com&gt;</span><br></pre></td></tr></table></figure>
<p>除了查看提交历史记录之外，您可能还想查看实际的更改 在代码中。 您可以使用 <code>git diff &lt;old commit&gt; &lt;new commit&gt;</code>查看 两次提交之间的差异。</p>
<p>除了查看提交历史记录之外，您可能还想查看实际的更改 在代码中。 您可以使用 <code>git diff &lt;old commit&gt; &lt;new commit&gt;</code>查看 两次提交之间的差异。 有几种不同的方式可以引用 一次提交。 之前提到的一个是复制提交的哈希值（请注意 您的提交哈希值将与下面的示例不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff 3368313c0afb6e306133d604ca72b0287124e8f2 762053064506810dee895219e5b2c2747a202829</span><br></pre></td></tr></table></figure>
<p>您还可以复制提交哈希开头的一小块，而不是 整个哈希。 由于哈希的工作方式，您不太可能 有两个具有完全相同的起始序列的提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff 3368313 7620530</span><br></pre></td></tr></table></figure>
<p>如果你想尝试 <code>diff</code>两个提交非常接近 日志，一种更简单的方法是通过距提交的距离来引用提交 <code>HEAD</code> （最近）使用以下格式提交 <code>HEAD~&lt;number&gt;</code>。 由于我们添加了三个 提交新的提交 <code>dice</code>，我们可以查看之间的差异 <code>dice</code>和 <code>master</code>使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff HEAD~3 HEAD</span><br></pre></td></tr></table></figure>
<p>有多种方法可以处理合并冲突，但我们将采用的方法 在这个实验室中向您展示正在使用 <code>git rebase</code>。 我们的 <code>dice</code>分支是“基于” 这 <code>master</code>在某个时间点有分支，但是 <code>master</code>分行有 向前离开 <code>dice</code>基于过时的 <code>master</code>。 因此，我们想要 “重新基地” <code>dice</code>就目前的状态而言 <code>master</code>。 当你的 <code>dice</code>分支， 跑步 <code>git rebase master</code>。 Git 将回滚您所做的提交 <code>dice</code>， 复制 任何新的提交 <code>master</code>，并尝试在顶部重放您的提交。 有时 <code>rebase</code>无需您的干预即可运行完成，但是如果 存在合并冲突，您需要解决它。</p>
<p>Git 会告诉你如果遇到合并冲突该怎么办 在变基期间。 在这种情况下，打开 <code>rand.py</code>并找到冲突区域 应具有以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Lines of code from the base branch (in this case master)</span><br><span class="line">=======</span><br><span class="line">Lines of code from the branch you&#x27;re rebasing (in this case dice)</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Commit message of the commit that conflicts with the base branch</span><br></pre></td></tr></table></figure>
<p>要解决冲突，只需保留您想要的行（您的行来自 <code>dice</code>） 和 删除冲突区域中的其他行（</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD`, `=======`, `&gt;&gt;&gt;&gt;&gt;&gt;&gt; dice`</span><br></pre></td></tr></table></figure>
<p>，以及来自 master 的不需要的代码），然后保存并退出 文件。 Git 会将您保存的内容作为文件的确切形式 看起来像在变基结束时，所以你所做的本质上是修复 文件，以便代码正常运行。 这意味着如果您有多个 合并冲突，您决定混合保留基础分支中的一些行 还有一些来自您的功能分支，您需要确保代码确实有效 正确。</p>
<p>现在您已经解决了合并冲突，请按照变基说明进行操作 暂存您的固定文件（ <code>git add rand.py</code>），然后运行 <code>git rebase --continue</code>。 如果 Git 发现其他文件有更多合并冲突，您将遵循相同的操作 程序如上。 然而，我们只有一个有冲突的文件，所以我们的变基是 完成的！ 跑步 <code>git log</code>查看我们 rebase 的结果。 你现在应该看到了 你想象中的队友 <code>"dice rolling WIP"</code>提交您分支的历史记录， 你的提交高于他们的提交。</p>
<h1 id="docker">docker</h1>
<p><a href="https://docs.docker.com/v17.09/engine/installation/linux/docker-ce/ubuntu/">安装 Docker</a> wsl2不支持systemctl命令，而是支持systemed命令 所以需要执行如下命令启动docker</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">service docker <span class="keyword">start</span></span><br></pre></td></tr></table></figure>
<p><code>虚拟机</code> 你的电脑里有一台电脑！ ● 通过软件模拟抽象物理硬件 ● 虚拟机管理程序运行多个虚拟机 ● 隔离应用：更好的安全性、稳定性 ● 一些开销：需要不同的客户操作系统和模拟 每个应用程序的虚拟硬件数量 ● 需要一些时间来启动</p>
<p><code>容器</code> ● 通常与虚拟机进行比较，但更像是捆绑的进程 环境 ● 提供类似的隔离 ○ 然而，比虚拟机要少得多！ 出于这个原因，我们仍然经常在虚拟机内运行容器（但是 每个虚拟机可以运行 &gt;1 个容器） ● 启动速度比虚拟机快得多 ● 目标是通过共享代码提供轻量级隔离环境 ● 轻松打包应用程序以实现一致的部署 ● 常见的容器：Docker、rkt、LXC ● 很确定这是加州大学伯克利分校唯一使用的课程</p>
<table>
<thead>
<tr class="header">
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>docker search</td>
<td>Search Docker Hub for pre-built images</td>
</tr>
<tr class="even">
<td>docker pull</td>
<td>Pull an image or a repository from a registry</td>
</tr>
<tr class="odd">
<td>docker images</td>
<td>List images</td>
</tr>
<tr class="even">
<td>docker build</td>
<td>Build an image from a Dockerfile</td>
</tr>
<tr class="odd">
<td>docker run</td>
<td>Run a command in a new container</td>
</tr>
<tr class="even">
<td>docker ps</td>
<td>List containers</td>
</tr>
<tr class="odd">
<td>docker start/stop/restart</td>
<td>Start/stop/restart a container</td>
</tr>
<tr class="even">
<td>docker exec</td>
<td>Run a command in a running container</td>
</tr>
<tr class="odd">
<td>docker inspect</td>
<td>Return low-level information on Docker objects</td>
</tr>
<tr class="even">
<td>docker rm</td>
<td>Remove one or more containers</td>
</tr>
<tr class="odd">
<td>docker rmi</td>
<td>Remove one or more images</td>
</tr>
</tbody>
</table>
<p><code>docker</code> ● 需要构建镜像 ● 通常使用 Dockerfile 来指定 如何构建快照 ● 快照是分层构建的 ○ 像洋葱一样 ○ 允许基于相同的快照层构建速度更快 ● 保持每一层最少化资源</p>
<p>自动化配置管理工具 ● 声明式：说出你想要什么，而不是如何做 ○ 应用程序弄清楚如何 ● 可以定义要安装的应用程序、要包含的文件等 ● 可以在不同“类别”的机器上安装不同的东西 （桌面与服务器） ● 常用工具：Puppet、Ansible、Chef</p>
<h2 id="docker的使用">docker的使用</h2>
<p><code>docker run hello-world</code></p>
<p>您应该看到一些友好的输出，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete </span><br><span class="line">Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此消息表明您的安装似乎运行正常。 为了生成此消息，Docker 采取了以下步骤：</p>
<ol type="1">
<li>Docker 客户端联系了 Docker 守护进程。</li>
<li>Docker 守护进程从 Docker Hub 中提取“hello-world”镜像。</li>
<li>Docker 守护进程从该映像创建了一个新容器，该容器运行生成您当前正在读取的输出的可执行文件。</li>
<li>Docker 守护进程将该输出传输到 Docker 客户端，然后将其发送到您的终端。 在容器中默认以<code>root</code>用户身份登录。</li>
</ol>
<p>以交互方式运行容器。 如果您需要在裸系统上尝试和安装东西而不弄乱当前系统，那么这非常有用。 尝试运行以下命令：</p>
<p><code>docker run -it ubuntu:latest</code></p>
<p>这 <code>-i</code>flag 告诉 docker 保留 <code>STDIN</code>打开你的容器，然后 <code>-t</code>分配一个 <a href="https://en.wikipedia.org/wiki/Pseudoterminal">伪 TTY</a> flag为您 。 基本上，您需要两者才能在新启动的容器中拥有一个 shell。 尝试安装一些软件包 <code>apt</code>或者只是玩玩。 它看起来应该像一个裸露的 Linux 系统。</p>
<p>使用 CTRL+D 退出容器。 自然的问题是，Docker 镜像是如何构建的？ Dockerfile <strong>。</strong> 就像镜像的源代码 相反，Dockerfile允许您通过指定手动键入创建镜像的所有命令来定义镜像。 然后 Docker 可以从指定Dockerfile 构建镜像。 这些 Dockerfile 可以放入版本控制中，并将镜像上传到在线存储库。</p>
<p>Docker可以通过读取来自<code>Dockerfile</code>的指令来自动构建镜像 。 <code>Dockerfile</code>是一个文本文档，其中包含所有命令 用户可以在命令行上调用来构建镜像。 eg.下面是一个 <strong>Dockerfile</strong> ，通过将 Python 3 和软件包安装到基础 Fedora Linux 映像上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Specify Fedora Linux as base image</span><br><span class="line">FROM fedora:latest</span><br><span class="line"></span><br><span class="line"># Install Python with yum (Fedora&#x27;s Package Manager)</span><br><span class="line"># Install required Python packages</span><br><span class="line">RUN yum update -y &amp;&amp; yum install -y python3 python3-pip &amp;&amp; \</span><br><span class="line">    python3 -m pip install pyfiglet termcolor</span><br><span class="line"> </span><br><span class="line"># Add the missile.py file to the final image</span><br><span class="line">ADD missile.py /</span><br><span class="line"></span><br><span class="line"># Specify the command to be run on container creation</span><br><span class="line">CMD [&quot;/usr/bin/python3&quot;, &quot;missile.py&quot;]</span><br></pre></td></tr></table></figure>
<p><code>docker build -t missile:latest .</code></p>
<p>这告诉 Docker 在当前目录中查找 <code>Dockerfile</code>，并用该文件构建一个镜像。 这 <code>-t</code>flag 告诉 Docker 使用名称标记此构建 <code>missile:latest</code>。</p>
<p>查看系统上正在运行的容器。 使用以下命令：</p>
<p><code>docker ps</code></p>
<p>由于您（可能）没有运行任何容器，因此您可能不会看到任何有趣的东西。 但是，如果您传入 <code>-a</code>标志，您还可以看到已停止的容器：</p>
<p>要获取有关容器的更多信息，您可以使用 <code>docker logs</code>命令 获取容器的日志（无论它仍在运行还是已退出）：</p>
<p><code>docker logs &lt;container_id_or_name&gt;</code></p>
<p>在某些时候，您可能想要清理已退出且不打算再使用的容器：</p>
<p><code>docker rm &lt;container_id_or_name&gt;</code></p>
<p>将移除容器。</p>
<p>查看已经下载的镜像: <code>docker images</code> 图像可能会占用计算机上相当多的空间，因此您可能需要清理不打算使用的图像 使用。 如果您收到有关计算机上没有足够磁盘空间的错误，这一点尤其重要：</p>
<p><code>docker rmi &lt;image_id&gt;</code></p>
<p>镜像文件以及容器的各种文件系统都存储在 <code>/var/lib/docker</code></p>
<h3 id="分离容器">分离容器</h3>
<p>容器可以以后台服务的形式运行，这适用于一些后台服务的场合，Docker 支持这种方式 以 <code>-d</code>标志，见 <a href="https://docs.docker.com/engine/reference/run/#detached--d">分离 方式启动容器 模式</a></p>
<p>Docker 为容器创建一个单独的虚拟网络，因此您需要将主机端口转发到您的 容器的端口（这称为 <a href="https://en.wikipedia.org/wiki/Port_forwarding">端口转发</a> 或端口映射）。 容器正在侦听端口 80，因此让我们尝试将主机的端口 5050 转发到容器的端口 ：</p>
<p><code>docker run -d -p=5050:80 httpd</code></p>
<p><code>-p</code> 接受冒号分隔的一对 <code>HOST_PORT:CONTAINER_PORT</code></p>
<p>您实际上可以“附加”到正在运行的容器并在其中运行更多命令，类似于 <code>docker run</code>作品。 使用 这 <code>docker exec</code>命令：</p>
<p><code>docker exec &lt;container_id_or_name&gt; &lt;command&gt;</code></p>
<p>要停止此容器，请使用 <code>docker stop &lt;container_id_or_name&gt;</code>.</p>
<p>您可以使用以下命令重新启动容器 <code>docker restart &lt;container_id_or_name&gt;</code>.</p>
<h3 id="关于-docker-compose">关于 docker-compose</h3>
<p><code>docker-compose</code>允许您定义需要多个容器才能运行的应用程序。 例如，在网络上 应用程序，您可能希望实际的 Web 应用程序在单个容器内运行，并且数据库在其中运行 一个不同的容器。</p>
<p>通常，您根据 <strong>服务</strong> 来定义应用程序。 同样，以 Web 应用程序为例，有 两个不同的服务：应用程序本身和支持它的数据库。 <code>docker-compose</code>让您定义不同的服务 在 <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> 文件中并相应地运行服务。</p>
<p>其中一件好事是 <code>docker-compose</code>是它会自动为您的容器设置一个网络，其中：</p>
<ul>
<li>服务的每个容器都位于网络上，并且可以从网络上的其他容器访问</li>
<li>每个容器都可以通过其容器名称在网络上发现</li>
</ul>
<p>使用 <a href="https://docs.docker.com/compose/install/">Docker 官方网站上的说明安装 Docker Compose</a></p>
<h1 id="一些小脚本">一些小脚本</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">PHONEBOOK_ENTRIES=&quot;phonelist.txt&quot;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">if [ &quot;$#&quot; -lt 1 ]; then</span><br><span class="line"></span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;new&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    echo $2 $3 &gt;&gt; phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;list&quot; ]; then</span><br><span class="line"></span><br><span class="line">    if [ ! -e $PHONEBOOK_ENTRIES ] || [ ! -s $PHONEBOOK_ENTRIES ]; then</span><br><span class="line"></span><br><span class="line">        echo &quot;phonebook is empty&quot;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">        # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">        cat phonelist.txt</span><br><span class="line"></span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;lookup&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    grep $2 phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;remove&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    sed -i &quot;s/$2//g&quot; phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;clear&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    rm phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">     # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">     echo nothing</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">host=$1</span><br><span class="line"></span><br><span class="line">ping -c 1 $host &gt;&gt; log.txt</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;OK&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">    echo &quot;can&#x27;t access&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1/bin/bash</span><br><span class="line"></span><br><span class="line">ip addr show | grep &quot;link/ether&quot; | head -n 1 | cut -d&#x27; &#x27; -f 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>linux</tag>
        <tag>系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>迪瑞克拉世界观轶事集</title>
    <url>/thinklive/14434/</url>
    <content><![CDATA[<h2 id="泰特斯">泰特斯</h2>
<p>正如童话故事常见的开头一样，泰特斯是个贫穷而有志气的青年，有一天当他在王国的大街上闲逛时，他遇到了公主的轿子，年轻的泰特斯对美丽淑慧的公主一见钟情，他下定决心一定要当上王国的驸马爷。 <span id="more"></span> 当时开国皇帝恩西斯去世没有多久，年轻的皇帝卡奥斯也是为年轻气盛的青年，泰特斯认为这是成为皇帝亲信的好机会。</p>
<p>当时无权无势的人想要上位有两种办法，一是参军博得战功，二是进入帝国大学谋求文官职位，泰特斯身体虚弱，而且厌恶战争，但却有个不错的头脑，于是在他刻苦攻读下终于进入了帝国的最高学府学习数学，十年后，泰特斯已经是位小有名气的数学家了。</p>
<p>新帝卡奥斯是个奇怪的皇帝，他不甚喜欢锦衣玉食,也不爱美人或者诗琴书赋，唯独对数学很感兴趣，帝国的数学家往往是些老古董，唯有泰特斯名声卓著，血气方刚，二人一见如故，泰特斯如愿以偿成为皇帝的亲信。</p>
<p>卡奥斯将各项赋税与各种工程的设计实施交给了泰特斯，结果无不让他满意，为了表示对泰特斯的欣赏，皇帝决定将自己的妹妹嫁给他。</p>
<p>当公主府的使臣带着婚书拜访泰特斯时，他礼貌而不失坚决地回绝了，此时在他看来任何不懂数学之美的人都是庸俗的，除了数学女神的青睐，他对任何女人不屑一顾。</p>
<p>当然，这件事传到了皇帝的耳朵里，同时传导的还有群臣的议论，皇帝敏感地察觉到在大部分人眼中泰特斯才是帝国最聪明的人，心怀不满的皇帝半强迫地让公主嫁给了泰特斯。当然，皇帝并不无情，否则如果他将所有比他强的数学家都杀了，那么帝国早就没几个大数学家了——要知道他的水平只是二流的</p>
<p>为了自己与泰特斯的安危，贤惠的公主规劝丈夫，聪明的泰特斯恍然大悟，从此以后他收敛锋芒，沉迷于公主府奢华的生活，最终，他与公主幸福地生活到了最后。</p>
<p>泰特斯关于数学研究的遗著于共和历11年首次出现在公众面前，最后屡经辗转进入了共和国首都博物馆的展馆</p>
<h2 id="黎明">黎明</h2>
<p>外交官是位三十出头的年轻人（就他的职位而言），一个月前，他被尊贵的皇帝陛下召见，并被赋予和葛雷氏族谈判的任务。他精于谈判之道，自从帝国决定用经济而不是武力的手段来征服那些遮布隆（帝国语，未开化的人）他变成了谈判桌上最可怕的对手，有人说他的鹰眼能轻易看穿对手的心理底线，有人说他的眼线分布各地，实际上，在外交官的心中，他的才能无关轻重，仅仅是帝国的威亚所致罢了，在早先的黑暗岁月中，遮布隆大多被帝国的屠杀，谎言与掠夺打败。</p>
<p>葛雷族有着一支装备精良的武装，他们背靠大陆大方最大的矿系，然而在帝国面前，这一切毫无意义，诚然，他们完全可以炸毁矿道，但那并不能躲避他们沦为帝国仆从的命运。</p>
<p>当我走进葛雷族的营地时，几乎所有人都对我怒目而视，其中大多是野性，却也带着几份文明，族长是位很硬朗的老人。</p>
<p>“知道吗，按我们的习俗，只要学到知识，就是师徒，你毕业于帝国大学，而我读过帝国大学出版的书，所以我们应该是师兄弟”</p>
<p>我对这老人不合时宜的幽默搞得一点摸不清头脑，“过来，我想让你看个东西”老人领着我向营地的深处走去，在巨大的仓库群前停了下来。</p>
<p>当他打开大门的时候我就知道了——金子，宝石，帝国经济体系中不可或缺的存在，自此帝国历234年定下贵金属和帝国货币的兑换关系后，它们就成了帝国最坚实的支柱。</p>
<p>“这是祖先为我们留下的，留着我们营地的大约只有十分之一””</p>
<p>“你们没有告诉我们这里的矿脉有黄金和宝石？”</p>
<p>“我现在不是告诉你们了吗？”</p>
<p>“……”</p>
<p>“你们帝国的经济命脉就是流通在市场上的黄金吧，如果这种规模的黄金瞬间涌入你们的市场，会发生什么？”</p>
<p>“……”</p>
<p>“好了，开始谈判吧”</p>
<p>历时3天的谈判后，帝国开出了有史以来最宽松的条件，葛雷族的所有自治权予以保留，唯一的条件是，必须与帝国展开全方面的贸易</p>
<h2 id="度量">度量</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只是两个小人物的故事</span><br></pre></td></tr></table></figure>
<p>一般来说，这年头很难遇到算命的，至于在酒吧里看到算命的就更少见了，用算命来骗酒喝已经是不知多少年前的老故事了，然而，在此时此刻，却有两个中年男人在酒吧里对饮。</p>
<p>“你是刚来这座城市吗？”</p>
<p>“恰恰相反，我在这待了很多年了”</p>
<p>发问者并没有追问</p>
<p>“你活过3000帝国币吗？”</p>
<p>莫名其妙的问题，乡巴佬的叫法，发问者心想，一时间他不知对方是什么意思</p>
<p>“我的父亲在活到566布朗时咽了气，他本指望着活到700布朗的，呵呵，然后我就到这里来了”</p>
<p>和一个不知从哪个穷乡僻壤来的家伙聊天或许能让自己以后酒场吹牛添一些料，中年人想，于是他决定听下去。</p>
<p>“来到这里后，一时间我很不适应，你们似乎总喜欢用在时间和空间上均匀分布的事物当做度量的标准，真是奇怪”</p>
<p>提问者忍不住做出了回答“你是说你们甚至没有时空的概念？”</p>
<p>“用你们的话说，我们的时间是经济学，空间则是社会学。当然，你们的语言和概念是无法完全解释的，300克朗昭示着步入成年，数不过来的人意味着一个国家，扎在一定的一堆人意味着一个省，这只是比喻。”</p>
<p>他自嘲般地说“我来的时候觉得在那地方我始终是客子，来到这里后又感觉并非家乡”</p>
<p>窗外一只先前飞走的蝴蝶盘旋一圈后又回到了树梢。</p>
<p>“知道吗？你会活过394杯酒。”他没头没脑地说了一句。</p>
<p>另一位中年人沉默着，他每周的同一时间都会来这里点一杯酒。</p>
<p>“而我，会活过自己度量过的第1944位客户”</p>
<p>“你指望我为你的疯话付钱吗？”</p>
<p>”我不适应你们的语言，我也不适应你们的思维……每一秒，每一厘米对你们而言都是无法更改的，你为什么觉得作为我故乡度量——金钱是能更改的呢？对你来说这是一天，对我而言这是6帝国币，二者都是神圣不可更改的。”</p>
<p>中年人有些可悲地看着他“你需要去补补数学和物理的课”</p>
<p>“我只想知道自己该用什么来度量”他显得有些颓废。</p>
<p>“结账，他那杯也算我的”占卜师指着中年男人桌上的酒，向服务员喊道。</p>
<p>占卜师离开酒吧的背影显得并不年轻，“我是他的第几个客户？”中年男人想到。</p>
<p>中年人从此再也没有喝过酒，一年后，一种以果汁为主成分的硬饮料在帝国风靡一时，中年人在一次应酬中举起了一杯苹果汁，当他察觉到一丝酒味后已经晚了，作为一个厌恶半途而废的男人，他选择一饮而尽，随后咽了气。</p>
]]></content>
      <categories>
        <category>迪瑞克拉</category>
      </categories>
      <tags>
        <tag>迪瑞克拉</tag>
      </tags>
  </entry>
  <entry>
    <title>基于伯克利cs61a的python笔记</title>
    <url>/thinklive/28549/</url>
    <content><![CDATA[<h2 id="python语言特性">python语言特性</h2>
<h3 id="函数">函数</h3>
<p>名称也可以与函数绑定。例如，名称 <code>max</code> 就和我们之前使用的 <code>max</code> 函数进行了绑定。与数字不同，函数很难以文本呈现，因此当询问一个函数时，Python 会打印一个标识来描述： <span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; max</span><br><span class="line">&lt;built-in function max&gt;</span><br></pre></td></tr></table></figure></p>
<p>赋值语句可以为现有函数赋予新名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f = max</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;built-in function max&gt;</span><br><span class="line">&gt;&gt;&gt; f(2, 3, 4)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>以下指南改编自 <a href="http://www.python.org/dev/peps/pep-0008">Python 代码风格指南</a>, 它可以作为所有（非叛逆的）Python 程序员的指南。这些共享的约定使开发者社区的成员之间的沟通能够顺利进行。作为遵循这些约定的副作用，你会发现你的代码在内部变得更加一致。</p>
<ol type="1">
<li>函数名是小写的，单词之间用下划线分隔。鼓励使用描述性名称。</li>
<li>函数名称通常反映解释器应用于参数的操作（例如， <code>print, add, square</code> ）或结果（例如， <code>max, abs, sum</code> ）。</li>
<li>参数名称是小写的，单词之间用下划线分隔。首选单个词的名称。</li>
<li>参数名称应该反映参数在函数中的作用，而不仅仅是允许的参数类型。</li>
<li>当作用明确时，单字参数名称可以接受，但应避免使用 l（小写的 L）和 O（大写的 o）或 I（大写的 i）以避免与数字混淆。</li>
</ol>
<h3 id="函数设计原则">函数设计原则</h3>
<ul>
<li>每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。</li>
<li>不要重复自己（Don't repeat yourself）是软件工程的核心原则。这个所谓的 DRY 原则指出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。如果你发现自己正在复制粘贴一段代码，那么你可能已经找到了进行函数抽象的机会。</li>
<li>定义通用的函数。比如作为 <code>pow</code> 函数的一个特例的平方函数就不在 Python 库中，因为 <code>pow</code> 函数可以将数字计算为任意次方。 当你使用函数名称作为参数调用 <code>help</code> 时，你会看到它的文档字符串（键入 q 以退出 Python help）。 Python 中的注释可以附加到 <code>#</code> 号后的行尾。例如，上面代码中的注释 <code>玻尔兹曼常数</code> 描述了 <code>k</code> 变量的含义。这些注释不会出现在 Python 的 <code>help</code> 中，而且会被解释器忽略，它们只为人类而存在。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help(pressure)</span><br></pre></td></tr></table></figure>
<h2 id="数据结构">数据结构</h2>
<h3 id="链表">链表</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Link:</span><br><span class="line">        &quot;&quot;&quot;A linked list with a first element and the rest.&quot;&quot;&quot;</span><br><span class="line">        empty = ()</span><br><span class="line">        def __init__(self, first, rest=empty):</span><br><span class="line">            assert rest is Link.empty or isinstance(rest, Link)</span><br><span class="line">            self.first = first</span><br><span class="line">            self.rest = rest</span><br><span class="line">        def __getitem__(self, i):</span><br><span class="line">            if i == 0:</span><br><span class="line">                return self.first</span><br><span class="line">            else:</span><br><span class="line">                return self.rest[i-1]</span><br><span class="line">        def __len__(self):</span><br><span class="line">            return 1 + len(self.rest)</span><br></pre></td></tr></table></figure>
<h3 id="抽象障碍">抽象障碍</h3>
<p>每当程序的一部分可以使用更高级别的函数而不是使用较低级别的函数时，就会违反抽象障碍。例如，计算有理数平方的函数最好用 <code>mul_rational</code> 实现，它不对有理数的实现做任何假设。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_rational(x):</span><br><span class="line">        return mul_rational(x, x)</span><br></pre></td></tr></table></figure>
<h3 id="序列">序列</h3>
<p>范围通常出现在 for 语句 header 中的表达式，以指定 <code>&lt;suite&gt;</code> 应执行的次数。如果 <code>&lt;name&gt;</code> 没有被用在 <code>&lt;suite&gt;</code>，一个惯用的使用方式是，使用下划线表示 <code>&lt;name&gt;</code>。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for _ in range(3):</span><br><span class="line">        print(&#x27;Go Bears!&#x27;)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure>
<p>对解释器而言，下划线只是环境中的另一个名称，但对程序员具有约定俗成的含义，表示该名称不会出现在任何未来的表达式中。 列表推导式的一般形式是：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;</span><br></pre></td></tr></table></figure>
<p>为了运算列表推导式，Python 首先评估 <code>&lt;sequence expression&gt;</code>，它必须返回一个 iterable 值。然后，每个元素依次绑定到 <code>&lt;name&gt;</code>，再运算 <code>&lt;filter expression&gt;</code>；如果产生一个真值，运算 <code>&lt;map expression&gt;</code>。最后 <code>&lt;map expression&gt;</code> 的值被收集到一个列表中</p>
<p><code>reduce</code> 可用于将序列的所有元素相乘。使用 <code>mul</code> 作为 <code>reduce_fn</code>， 1 作为 <code>initial</code> 值， <code>reduce</code> 可用于将各数字相乘。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(mul, [2, 4, 8], 1)</span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p><strong>多行文字 (Multiline Literals)</strong>。字符串不限于一行。跨越多行的字符串文字可以用三重引号括起。我们已经在文档字符串中广泛使用了这种三重引号。</p>
<h3 id="迭代器">迭代器</h3>
<p>迭代器的用处源自以下事实： 迭代器的一系列数据可能不会在内存中显式表示。 迭代器提供了一种考虑一系列值中的每一个的机制 轮，但所有这些元素不需要同时存储。 相反，当迭代器请求下一个元素时，该元素可能会 按需计算，而不是从现有内存中检索 来源。</p>
<p>范围能够惰性地计算序列的元素，因为 表示的序列是统一的，并且任何元素都很容易从 范围的开始和结束边界。 迭代器允许延迟生成 更广泛的底层序列数据集类别，因为它们不需要 提供对底层系列的任意元素的访问。 反而， 迭代器只需要按顺序计算该系列的下一个元素， 每次请求另一个元素时。 虽然不像访问那样灵活 序列的任意元素（称为 <em>随机访问</em> ）、 <em>顺序访问</em> 顺序数据通常足以满足数据处理应用程序的需要。 函数 map 是惰性的：调用它并不执行计算 需要计算其结果的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def double_and_print(x):</span><br><span class="line">        print(&#x27;***&#x27;, x, &#x27;=&gt;&#x27;, 2*x, &#x27;***&#x27;)</span><br><span class="line">        return 2*x</span><br><span class="line">&gt;&gt;&gt; s = range(3, 7)</span><br><span class="line">&gt;&gt;&gt; doubled = map(double_and_print, s)  # double_and_print not yet called</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called once</span><br><span class="line">*** 3 =&gt; 6 ***</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called again</span><br><span class="line">*** 4 =&gt; 8 ***</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; list(doubled)                       # double_and_print called twice more</span><br><span class="line">*** 5 =&gt; 10 ***</span><br><span class="line">*** 6 =&gt; 12 ***</span><br><span class="line">[10, 12]</span><br></pre></td></tr></table></figure>
<h2 id="迭代器-1">迭代器</h2>
<p>可迭代的 Letters 实例 b_to_k 和 LetterIter 迭代器 实例 first_iterator 和 second_iterator的 不同之处在于 字母 实例不会改变，而迭代器实例会改变 每次调用 next （或等效地，每次调用 <strong>next</strong> ）。 迭代器通过顺序数据跟踪进度，而可迭代器 代表数据本身。</p>
<p>Python 中的许多内置函数都采用可迭代参数并返回迭代器。 函数 map 例如， 接受一个函数和一个可迭代对象。 它返回 将函数参数应用于每个元素的结果的迭代器 在可迭代的参数中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;  caps   =   map  (  lambda   x  :   x  .  upper  (),   b_to_k ) </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;B&#x27; </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;C&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="生成器">生成器</h2>
<p>生成器函数是生成值而不是返回值的函数 普通函数返回一次； 一个生成器函数可以产生多次 生成器是通过调用生成器函数自动创建的迭代器 当调用生成器函数时，它返回一个迭代其产量的生成器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def plus_minus(x):</span><br><span class="line">... yield x</span><br><span class="line">... yield -x</span><br><span class="line">&gt;&gt;&gt; t = plus_minus(3)</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">-3</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">&lt;generator object plus_minus ...&gt;</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数">高阶函数</h2>
<h3 id="嵌套定义">嵌套定义</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def sqrt(a):</span><br><span class="line">        def sqrt_update(x):</span><br><span class="line">            return average(x, a/x)</span><br><span class="line">        def sqrt_close(x):</span><br><span class="line">            return approx_eq(x * x, a)</span><br><span class="line">        return improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure>
<p>与局部赋值一样，局部 <code>def</code> 语句只影响当前局部帧。这些函数仅在求解 <code>sqrt</code> 时在作用域内。与求解过程一致，这些局部 <code>def</code> 语句在调用 <code>sqrt</code> 之前都不会被求解。</p>
<p>词法作用域（Lexical scope）：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， <code>sqrt_update</code> 引用名称 <code>a</code>，它是其封闭函数 <code>sqrt</code> 的形式参数。这种在嵌套定义之间共享名称的规则称为词法作用域。最重要的是，内部函数可以访问定义它们的环境中的名称（而不是它们被调用的位置）。</p>
<p>我们需要对我们的环境模型实现两个扩展来启用词法作用域。</p>
<ol type="1">
<li>每个用户定义的函数都有一个父环境：定义它的环境。</li>
<li>调用用户定义的函数时，其局部帧会继承其父环境。 Python 中词法作用域的两个关键优势。</li>
</ol>
<ul>
<li>局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。</li>
<li>局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。</li>
</ul>
<h3 id="lambda">lambda</h3>
<p>不像 定义 语句、lambda 表达式可以用作运算符或 调用表达式的操作数。 这是因为它们只是一行 计算结果为函数的表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; what = lambda x : x + 5</span><br><span class="line">&gt;&gt;&gt; what</span><br><span class="line">&lt;function &lt;lambda&gt; at 0xf3f490&gt;</span><br><span class="line">&gt;&gt;&gt; (lambda y: y + 5)(4)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="类">类</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">     def __init__(self, account_holder):</span><br><span class="line">            self.balance = 0</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<p>内置函数 <code>getattr</code> 还按名称返回对象的属性。它是点表示法的函数等效物。使用 <code>getattr</code> ，我们可以使用字符串查找属性，就像我们对调度字典所做的那样。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(spock_account, &#x27;balance&#x27;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>我们还可以测试应该对象是否具有 <code>hassattr</code> 的名命属性。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(spock_account, &#x27;deposit&#x27;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>我们可以通过对点表达式的返回值调用 <code>type</code> 来查看交互式解释器的差异。作为类的属性，方法只是一个函数，但作为实例的属性，它是一个绑定方法：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; type(Account.deposit)</span><br><span class="line">&lt;class &#x27;Function&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(spock_account.deposit)</span><br><span class="line">&lt;class &#x27;method&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>这两个结果的区别仅在于第一个是参数为 <code>self</code> 和 <code>amount</code> 的标准双参数函数。第二种是单参数方法，调用方法时，名称 <code>self</code> 将自动绑定到名为 <code>spock_account</code> 的对象，而参数 <code>amount</code> 将绑定到传递给方法的参数。这两个值（无论是函数值还是绑定方法值）都与相同的 <code>deposit</code> 函数体相关联。 在某些情况下，有一些实例变量和方法与对象的维护和一致性相关，我们不希望对象的用户看到或使用。它们不是类定义的抽象的一部分，而是实现的一部分。Python 的约定规定，如果属性名称以下划线开头，则只能在类本身的方法中访问它，而不是用户访问。</p>
<p>计算点表达式：</p>
<ol type="1">
<li>点表达式左侧的 <code>&lt;expression&gt;</code> ，生成点表达式的对象。</li>
<li><code>&lt;name&gt;</code> 与该对象的实例属性匹配；如果存在具有该名称的属性，则返回属性值。</li>
<li>如果实例属性中没有 <code>&lt;name&gt;</code> ，则在类中查找 <code>&lt;name&gt;</code>，生成类属性。</li>
<li>除非它是函数，否则返回属性值。如果是函数，则返回该名称绑定的方法。</li>
</ol>
<h2 id="约束传递-propagating-constraints">约束传递 (Propagating Constraints)</h2>
<p>可变数据允许我们模拟具有变化的系统，也允许我们构建新的抽象类型。在这个扩展示例中，我们结合了非局部赋值、列表和字典来构建一个支持多方向计算的基于约束系统。将程序表示为约束是一种声明式编程，在这种编程中，程序员声明要解决的问题的结构，而不是抽象出问题解决方案的具体计算方式的细节。</p>
<p>计算机程序传统上被组织为单向计算，它对预先指定的参数执行操作以产生所需的输出。另一方面，我们通常希望根据数量之间的关系对系统进行建模。例如，我们之前考虑过理想气体定律，它通过玻尔兹曼常数 (k) 将理想气体的压力 (p)、体积 (v)、数量 (n) 和温度 (t) 联系起来：</p>
<p><code>p * v = n * k * t</code></p>
<p>这样的方程不是单向的。给定任何四个量，我们可以使用这个方程来计算第五个。然而，将方程式翻译成传统的计算机语言会迫使我们选择一个量来根据其他四个量进行计算。因此，计算压力的函数不能用于计算温度，即使这两个量的计算来自同一个方程。</p>
<p>在本节中，我们概述了线性关系的一般模型的设计。我们定义了在数量之间保持的原始约束，例如强制数学关系 a + b = c 的 adder(a, b, c) 约束。</p>
<p>我们还定义了一种组合方式，以便可以组合原始约束来表达更复杂的关系。这样，我们的程序就类似于一种编程语言。我们通过构建一个网络来组合约束，在该网络中约束由连接器 (connector) 连接。连接器是一个对象，它“持有”一个值并且可以参与一个或多个约束。</p>
<p>例如，我们知道华氏温度和摄氏温度之间的关系是：</p>
<p><code>9 * c = 5 * (f - 32)</code></p>
<p>该等式是 c 和 f 之间的复杂约束。这样的约束可以被认为是一个由原始加法器 (adder) 、乘法器 (multiplier) 和常量 (constant) 约束组成的网络。</p>
<figure>
<img src="https://composingprograms.netlify.app/sicp/celsius_fahrenheit_constraint.png" alt="" /><figcaption>celsius_fahrenheit_constraint</figcaption>
</figure>
<p>在此图中，我们在左侧看到一个乘数框，其中包含三个端子，标记为 a 、b 和 c。这些将乘数连接到网络的其余部分，如下所示：终端连接到连接器 celsius，该连接器将保持摄氏温度。b 端子连接到连接器 w，该连接器链接到常量 9。乘数盒约束为 a 和 b 乘积的 c 端链接到另一个乘法盒的 c 端，其 b 连接到常量 5，其 a 连接到和约束中的项之一。</p>
<p>这种网络的计算过程如下：当一个连接器被赋予一个值时（由用户或由它链接到的约束框），它会唤醒所有相关的约束（除了刚刚唤醒它的约束） 以告诉他们它有值。每个被唤醒的约束框之后轮流询问其连接器，以查看是否有足够的信息来确定连接器的值。如果有，该框设置该连接器，然后唤醒所有关联的约束，依此类推。例如，在摄氏度和华氏度之间的转换中， w、 x 和 y 立即被常量框分别设置为 9、 5 和 32。连接器唤醒乘法器和加法器，它们确定没有足够的信息继续进行。如果用户（或网络的其他部分）将摄氏连接器设置为一个值（比如 25），最左边的乘法器将被唤醒，它将 u 设置为 25 * 9 = 225。然后你唤醒第二个乘法器，将 v 设置为 45，v 唤醒加法器，将 fahrenheit 连接器设置为 77。</p>
<p><strong>使用约束系统 (Using the Constraint System)</strong>。要使用约束系统执行上述温度计算，我们首先通过调用连接器构造函数创建两个命名连接器，摄氏度 celsius 和华氏度 fahrenheit。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius = connector(&#x27;Celsius&#x27;)</span><br><span class="line">&gt;&gt;&gt; fahrenheit = connector(&#x27;Fahrenheit&#x27;)</span><br></pre></td></tr></table></figure>
<p>然后，我们将这些连接器链接到一个反映上图的网络中。函数转换器 (converter) 组装网络中的各种连接器和约束。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def converter(c, f):</span><br><span class="line">        &quot;&quot;&quot;用约束条件连接 c 到 f ，将摄氏度转换为华氏度.&quot;&quot;&quot;</span><br><span class="line">        u, v, w, x, y = [connector() for _ in range(5)]</span><br><span class="line">        multiplier(c, w, u)</span><br><span class="line">        multiplier(v, x, u)</span><br><span class="line">        adder(v, y, f)</span><br><span class="line">        constant(w, 9)</span><br><span class="line">        constant(x, 5)</span><br><span class="line">        constant(y, 32)</span><br></pre></td></tr></table></figure>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; converter(celsius, fahrenheit)</span><br></pre></td></tr></table></figure>
<p>我们将使用消息传递系统来协调约束和连接器。约束是不包含局部状态本身的字典。它们对消息的响应是非纯函数，会更改它们约束的连接器。</p>
<p>连接器是保存当前值并响应操纵该值的消息的字典。约束不会直接更改连接器的值，而是通过发送消息来更改，以便连接器可以通知其他约束以响应更改。这样，一个连接器既代表了一个数字，同时也封装了连接器的行为。</p>
<p>我们可以发送给连接器的一条消息是设置它的值。在这里，我们（ “ user ” ）将 celsius 的值设置为 25。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;set_val&#x27;](&#x27;user&#x27;, 25)</span><br><span class="line">Celsius = 25</span><br><span class="line">Fahrenheit = 77.0</span><br></pre></td></tr></table></figure>
<p>不仅 celsius 的值变为 25，而且它的值通过网络传播，因此 fahrenheit 的值也发生变化。打印这些更改是因为我们在构造它们时命名了这两个连接器。</p>
<p>现在我们可以尝试将 fahrenheit 度设置为一个新值，比如 212。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Contradiction detected: 77.0 vs 212</span><br></pre></td></tr></table></figure>
<p>连接器抱怨说它感觉到了一个矛盾：它的值为 77.0，而有人试图将它设置为 212。如果我们真的想用新值应用到网络，我们可以告诉 celsius 忘记它的旧值：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;forget&#x27;](&#x27;user&#x27;)</span><br><span class="line">Celsius is forgotten</span><br><span class="line">Fahrenheit is forgotten</span><br></pre></td></tr></table></figure>
<p>连接器 celsius 发现最初设置其值的用户现在收回该值，因此 celsius 同意失去其值，并将这一事实通知网络的其余部分。这个信息最终传播到 fahrenheit，它现在发现它没有理由继续相信它自己的值是 77。因此，它也放弃了它的值。</p>
<p>现在 fahrenheit 没有值，我们可以将其设置为 212：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Fahrenheit = 212</span><br><span class="line">Celsius = 100.0</span><br></pre></td></tr></table></figure>
<p>这个新值在通过网络传播时会迫使 celsius 的值变为 100。我们使用了完全相同的网络来计算给定 celsius 的 fahrenheit 和给定 fahrenheit 的 celsius。这种计算的非方向性是基于约束的系统的显着特征。</p>
<p><strong>实施约束系统 (Implementing the Constraint System)</strong>。正如我们所见，连接器是将消息名称映射到函数和数据值的字典。我们将实施响应以下消息的连接器：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; connector [&#x27;set_val&#x27;](source, value)  &quot;&quot;&quot;表示 source 在请求连接器将当前值设为 value&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;has_val&#x27;]()  &quot;&quot;&quot;返回连接器是否已经具有值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;val&#x27;]  &quot;&quot;&quot;是连接器的当前值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;forget&#x27;](source)  &quot;&quot;&quot;告诉连接器 source 请求遗忘它的值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;connect&#x27;](source)  &quot;&quot;&quot;告诉连接器参与新的约束，即 source&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>约束也是字典，它通过两条消息从连接器接收信息：</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; constraint[\&#x27;new_val&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器具有新的值。&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; constraint[\&#x27;forget&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器遗忘了值。&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>当约束收到这些消息时，它们会将消息传播到其他连接器。</p>
<p>adder 函数在三个连接器上构造一个加法器约束，其中前两个必须与第三个相加：a + b = c。为了支持多向约束传播，加法器还必须指定它从 c 中减去 a 得到 b，同样地从 c 中减去 b 得到 a。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import add, sub</span><br><span class="line">&gt;&gt;&gt; def adder(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a+b=c&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, add, sub, sub)</span><br></pre></td></tr></table></figure>
<p>我们想实现一个通用的三元（三向）约束，它使用来自 adder 的三个连接器和三个函数来创建一个接受 new_val 和 forget 消息的约束。对消息的响应是局部函数，它们被放置在称为约束的字典中。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_ternary_constraint(a, b, c, ab, ca, cb):</span><br><span class="line">        &quot;&quot;&quot;约束ab(a,b)=c，ca(c,a)=b，cb(c,b)=a。&quot;&quot;&quot;</span><br><span class="line">        def new_value():</span><br><span class="line">            av, bv, cv = [connector[&#x27;has_val&#x27;]() for connector in (a, b, c)]</span><br><span class="line">            if av and bv:</span><br><span class="line">                c[&#x27;set_val&#x27;](constraint, ab(a[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">            elif av and cv:</span><br><span class="line">                b[&#x27;set_val&#x27;](constraint, ca(c[&#x27;val&#x27;], a[&#x27;val&#x27;]))</span><br><span class="line">            elif bv and cv:</span><br><span class="line">                a[&#x27;set_val&#x27;](constraint, cb(c[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">        def forget_value():</span><br><span class="line">            for connector in (a, b, c):</span><br><span class="line">                connector[&#x27;forget&#x27;](constraint)</span><br><span class="line">        constraint = &#123;&#x27;new_val&#x27;: new_value, &#x27;forget&#x27;: forget_value&#125;</span><br><span class="line">        for connector in (a, b, c):</span><br><span class="line">            connector[&#x27;connect&#x27;](constraint)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>
<p>称为约束的字典是一个调度字典，也是约束对象本身。它响应约束接收到的两条消息，但也作为调用其连接器的 source 参数传递。</p>
<p>每当约束被告知其连接器之一具有值时，就会调用约束的局部函数 new_value。该函数首先检查 a 和 b 是否都有值。如果是，它告诉 c 将其值设置为函数 ab 的返回值，在加法器的情况下为 add。约束将自身（约束）作为连接器的 source 参数传递，该连接器是加法器对象。如果 a 和 b 不同时都有值，则约束检查 a 和 c，依此类推。</p>
<p>如果约束被告知它的一个连接器遗忘了它的值，它会请求它的所有连接器遗忘它们的值。（实际上只有那些由此约束设置的值会丢失。）</p>
<p>乘法器与加法器非常相似。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import mul, truediv</span><br><span class="line">&gt;&gt;&gt; def multiplier(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a*b=c.&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, mul, truediv, truediv)</span><br></pre></td></tr></table></figure>
<p>常量也是一种约束，但它永远不会发送任何消息，因为它只涉及它在构造时设置的单个连接器。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def constant(connector, value):</span><br><span class="line">        &quot;&quot;&quot;常量赋值.&quot;&quot;&quot;</span><br><span class="line">        constraint = &#123;&#125;</span><br><span class="line">        connector[&#x27;set_val&#x27;](constraint, value)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure>
<p>这三个约束足以实现我们的温度转换网络。</p>
<p><strong>连接器表示 (Representing connectors)</strong>。连接器表示为包含值的字典，也有具备局部状态的响应函数。连接器必须跟踪为其提供当前值的信息提供者，以及它参与的约束列表。</p>
<p>构造函数连接器具有用于设置和遗忘值的局部函数，这些值是对来自约束的消息的响应。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def connector(name=None):</span><br><span class="line">        &quot;&quot;&quot;限制条件之间的连接器.&quot;&quot;&quot;</span><br><span class="line">        informant = None</span><br><span class="line">        constraints = []</span><br><span class="line">        def set_value(source, value):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            val = connector[&#x27;val&#x27;]</span><br><span class="line">            if val is None:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = source, value</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;=&#x27;, value)</span><br><span class="line">                inform_all_except(source, &#x27;new_val&#x27;, constraints)</span><br><span class="line">            else:</span><br><span class="line">                if val != value:</span><br><span class="line">                    print(&#x27;Contradiction detected:&#x27;, val, &#x27;vs&#x27;, value)</span><br><span class="line">        def forget_value(source):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            if informant == source:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = None, None</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;is forgotten&#x27;)</span><br><span class="line">                inform_all_except(source, &#x27;forget&#x27;, constraints)</span><br><span class="line">        connector = &#123;&#x27;val&#x27;: None,</span><br><span class="line">                     &#x27;set_val&#x27;: set_value,</span><br><span class="line">                     &#x27;forget&#x27;: forget_value,</span><br><span class="line">                     &#x27;has_val&#x27;: lambda: connector[&#x27;val&#x27;] is not None,</span><br><span class="line">                     &#x27;connect&#x27;: lambda source: constraints.append(source)&#125;</span><br><span class="line">        return connector</span><br></pre></td></tr></table></figure>
<p>连接器也是约束用于与连接器通信的五个消息的调度字典。四个响应是函数，最后的响应是值本身。</p>
<p>当有设置连接器值的请求时调用局部函数 set_value。如果连接器当前没有值，它将设置它的值并记住请求设置值的源约束作为信息提供者。然后连接器将通知它的所有参与约束，除了请求设置值的约束。这是使用以下迭代函数完成的。</p>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def inform_all_except(source, message, constraints):</span><br><span class="line">        &quot;&quot;&quot;告知信息除了source外的所有约束条件，。&quot;&quot;&quot;</span><br><span class="line">        for c in constraints:</span><br><span class="line">            if c != source:</span><br><span class="line">                c[message]()</span><br></pre></td></tr></table></figure>
<p>如果要求连接器遗忘其值，它会调用局部函数 forget-value，该函数首先检查以确保请求来自与最初设置值相同的约束。如果是这样，连接器会通知其关联的约束有关值的丢失。</p>
<p>对消息 has_val 的响应表明连接器是否有值。 对消息连接的响应将源约束添加到约束列表中。</p>
<p>我们设计的约束程序引入了许多将在面向对象编程中再次出现的思想。约束和连接器都是通过消息操作的抽象。当连接器的值发生变化时，它会通过一条消息进行更改，该消息不仅会更改值，还会验证它（检查源）并传播其效果（通知其他约束）。事实上，我们将在本章后面使用具有字符串值键和函数值的字典的类似架构来实现面向对象的系统</p>
<h2 id="debug">debug</h2>
<p>请注意，回溯中的行似乎是配对在一起的。 该对中的第一行具有以下格式： 文件“<文件名>”，第 <编号> 行，<函数></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;&lt;file name&gt;&quot;, line &lt;number&gt;, in &lt;function&gt;</span><br></pre></td></tr></table></figure>
<p>该行为您提供以下信息： 文件名：包含问题的文件的名称。 Number：文件中引起问题的行号，或包含下一个函数调用的行号 函数：可以在其中找到该行的函数的名称。 回溯消息中的最后一行是错误语句。 错误语句具有以下格式： <错误类型>：<错误消息> 这一行为您提供了两条信息： 错误类型：引起的错误类型（例如SyntaxError，TypeError）。 这些通常具有足够的描述性，可以帮助您缩小错误原因的搜索范围。 错误消息：更详细地描述导致错误的原因。 不同的错误类型会产生不同的错误消息。</p>
<h2 id="running-doctests">Running doctests</h2>
<p>Python has a great way to quickly write tests for your code. These are called doctests, and look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    &quot;&quot;&quot;A random function.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; foo(4)</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; foo(5)</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>The lines in the docstring that look like interpreter outputs are the <strong>doctests</strong>. To run them, go to your terminal and type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m doctest file.py</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m doctest file.py -v</span><br><span class="line">除了告诉你哪些文档测试失败之外，它还会 告诉您哪些文档测试通过了。</span><br></pre></td></tr></table></figure>
<p>许多程序员喜欢研究他们的代码的一种方法是使用交互式 REPL。 也就是说，您可以在其中直接运行函数并检查其输出的终端。 通常，要完成此操作，您可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -i file.py</span><br></pre></td></tr></table></figure>
<h3 id="使用-assert声明">使用 <code>assert</code>声明</h3>
<p>Python 有一个特性称为 <code>assert</code>语句，它可以让您测试条件是否为真，并打印错误 否则在一行中消息。 如果您知道某些条件在某些点需要为真，这会很有用 在你的程序中。 例如，如果您正在编写一个接受整数并将其加倍的函数，那么它可能会很有用 确保您的输入实际上是一个整数。 然后你可以编写以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def double(x):</span><br><span class="line">    assert isinstance(x, int), &quot;The input to double(x) must be an integer&quot;</span><br><span class="line">    return 2 * x</span><br></pre></td></tr></table></figure>
<p>请注意，我们并没有真正调试 <code>double</code>在这里，我们正在做的是确保任何拨打电话的人 <code>double</code>正在以正确的论点这样做。 例如，如果我们有一个函数 <code>g</code>接受一个字符串和一个数字 并将字符串的长度添加到数字的两倍，其实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def g(x, y):</span><br><span class="line">    return double(x) + y # should be double(y) + len(x)</span><br></pre></td></tr></table></figure>
<h3 id="syntaxerror"><code>SyntaxError</code></h3>
<ul>
<li><p><strong>原因</strong> ：代码语法错误</p></li>
<li><p><strong>示例</strong> ：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    def incorrect(f)</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>解决办法</strong> ： <code>^</code>符号指向包含的代码 无效的语法。 错误消息没有告诉你 <em>什么</em> 是 错了，但它确实告诉你 <em>在哪里</em> 。</p></li>
<li><p><strong>注意</strong> ：Python 将检查 <code>SyntaxErrors</code>执行之前 任何代码。 这与其他错误不同，其他错误仅 在运行时引发。</p></li>
</ul>
<h3 id="indentationerror"><code>IndentationError</code></h3>
<ul>
<li><p><strong>原因</strong> ：缩进不当</p></li>
<li><p><strong>示例</strong> ：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    print(&#x27;improper indentation&#x27;)</span><br><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>解决方案</strong> ：显示缩进不正确的行。 只需重新缩进即可。</p></li>
<li><p><strong>注意</strong> ：如果制表符和空格不一致，Python 将提出其中之一。 确保使用空格！ （只是少了点 在 Python 中使用空格和所有 cs61a 内容通常令人头痛 使用空格）。</p></li>
</ul>
<h3 id="typeerror"><code>TypeError</code></h3>
<ul>
<li><p><strong>原因一</strong> ：</p>
<ul>
<li><p>原始运算符的操作数类型无效。 你是 可能尝试加/减/乘/除不兼容 类型。</p></li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError: unsupported operand type(s) for +: &#x27;function&#x27; and &#x27;int&#x27;</span><br></pre></td></tr></table></figure></code></pre></li>
</ul></li>
<li><p><strong>原因2</strong> ：</p>
<ul>
<li><p>在函数调用中使用非函数对象。</p></li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; square = 3</span><br><span class="line">&gt;&gt;&gt; square(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &#x27;int&#x27; object is not callable</span><br></pre></td></tr></table></figure></code></pre></li>
</ul></li>
<li><p><strong>原因3</strong> ：</p>
<ul>
<li><p>向函数传递错误数量的参数。</p></li>
<li><p><strong>示例</strong> ：</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: add expected 2 arguments, got 1</span><br></pre></td></tr></table></figure></code></pre></li>
</ul></li>
</ul>
<h3 id="nameerror"><code>NameError</code></h3>
<ul>
<li><p><strong>原因</strong> ：变量没有分配给任何东西或者没有分配 存在。 这包括函数名称。</p></li>
<li><p><strong>示例</strong> ：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  y = x + 3</span><br><span class="line">NameError: global name &#x27;x&#x27; is not defined</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>解决方案</strong> ：确保您正在初始化变量（即 在使用之前为变量分配一个值）。</p></li>
<li><p><strong>注意</strong> ：错误消息显示“全局名称”的原因是 因为Python将从a开始搜索变量 函数的本地框架。 如果在那里找不到该变量， Python将继续搜索父框架，直到到达 全球框架。 如果仍然找不到变量，Python 引发错误。</p></li>
</ul>
<h3 id="indexerror"><code>IndexError</code></h3>
<ul>
<li><p><strong>原因</strong> ：尝试索引序列（例如元组、列表、 string）的数字超过了序列的大小。</p></li>
<li><p><strong>示例</strong> ：</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  x[100]</span><br><span class="line">IndexError: tuple index out of range</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>解决方案</strong> ：确保索引在范围内 顺序。 如果您使用变量作为索引（例如 <code>seq[x]</code>, 确保变量被分配给正确的索引。</p></li>
</ul>
<h2 id="object">object</h2>
<p>因为两个列表可能内容相同，但实际上是不同的列表，所以我们需要一种方法来测试两个对象是否是同一个。Python 包括两个比较运算符，称为 is 和 is not，它们测试两个表达式实际上是否计算为相同的对象。如果两个对象的当前值相等，则它们是相同的，并且对一个对象的任何更改都将始终反映在另一个对象中。身份是比相等更强大的条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suits is [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; suits == [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>字典也确实有一些限制：</p>
<ul>
<li>字典的键不能是或包含可变值。</li>
<li>对于给定的键，最多只能有一个对应的值。 非局部语句 (nonlocal statement)。当我们调用 make_withdraw 时，我们将 balance 绑定到初始金额。然后我们定义并返回一个局部函数 withdraw，它会在调用时更新并返回 balance 的值。</li>
</ul>
<p>python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_withdraw(balance):</span><br><span class="line">        &quot;&quot;&quot;返回一个每次调用都会减少余额的 withdraw 函数&quot;&quot;&quot;</span><br><span class="line">        def withdraw(amount):</span><br><span class="line">            nonlocal balance                 # 声明 balance 是非局部的</span><br><span class="line">            if amount &gt; balance:</span><br><span class="line">                return &#x27;Insufficient funds&#x27;</span><br><span class="line">            balance = balance - amount       # 重新绑定</span><br><span class="line">            return balance</span><br><span class="line">        return withdraw</span><br></pre></td></tr></table></figure>
<p>非局部语句声明：每当我们更改 balance 的绑定时，绑定关系都会在已经绑定 balance 的第一帧中更改。回想一下，如果没有非局部语句，赋值语句将始终在当前环境的第一帧中绑定。非局部语句指示名称不会出现在第一个（局部）帧或最后一个（全局）帧，而是其他地方。</p>
<h2 id="错题集">错题集</h2>
<h3 id="递增子序列">递增子序列</h3>
<figure class="highlight plaintext"><figcaption><span>inc_subseqs(s):</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Assuming that S is a list, return a nested list of all subsequences</span><br><span class="line"></span><br><span class="line">    of S (a list of lists) for which the elements of the subsequence</span><br><span class="line"></span><br><span class="line">    are strictly nondecreasing. The subsequences can appear in any order.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs = inc_subseqs([1, 3, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1, 2], [1, 3], [2], [3]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; inc_subseqs([])</span><br><span class="line"></span><br><span class="line">    [[]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs2 = inc_subseqs([1, 1, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs2)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1], [1, 1], [1, 1, 2], [1, 2], [1, 2], [2]]</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def subseq_helper(s, prev):</span><br><span class="line"></span><br><span class="line">        if not s:</span><br><span class="line"></span><br><span class="line">            return [[]]</span><br><span class="line"></span><br><span class="line">        elif s[0] &lt; prev:</span><br><span class="line"></span><br><span class="line">            return subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            a = subseq_helper(s[1::],s[0])</span><br><span class="line"></span><br><span class="line">            b = subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">            return insert_into_all(s[0], a) + b</span><br><span class="line"></span><br><span class="line">    return subseq_helper(s,0)</span><br><span class="line"></span><br><span class="line">seqs = inc_subseqs([1, 3, 2])</span><br></pre></td></tr></table></figure>
<h3 id="反转奇数深度树的标签">反转奇数深度树的标签</h3>
<figure class="highlight plaintext"><figcaption><span>t.is_leaf():</span></figcaption><table><tr><td class="code"><pre><span class="line">        return </span><br><span class="line">    label_list = []</span><br><span class="line">    for b in t.branches:</span><br><span class="line">        label_list.append(b.label)</span><br><span class="line">    for b, new_label in zip(t.branches, reversed(label_list)):</span><br><span class="line">        b.label = new_label</span><br><span class="line">        for bb in b.branches:</span><br><span class="line">            reverse_other(bb)</span><br><span class="line"></span><br><span class="line">我的解法：</span><br><span class="line">def helper(t,depth):</span><br><span class="line"></span><br><span class="line">        if depth%2==0:</span><br><span class="line"></span><br><span class="line">            if t.is_leaf():</span><br><span class="line"></span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            else:</span><br><span class="line"></span><br><span class="line">                for branch in t.branches:</span><br><span class="line"></span><br><span class="line">                    helper(branch,depth+1)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            labels=[]</span><br><span class="line"></span><br><span class="line">            brans=t.branches</span><br><span class="line"></span><br><span class="line">            for branch in brans:</span><br><span class="line"></span><br><span class="line">                labels.insert(0,branch.label)</span><br><span class="line"></span><br><span class="line">            for new_label,new_branch in zip(labels,brans):</span><br><span class="line"></span><br><span class="line">                new_branch.label=new_label</span><br><span class="line"></span><br><span class="line">            for bran in brans:</span><br><span class="line"></span><br><span class="line">                helper(bran,depth+1)</span><br><span class="line"></span><br><span class="line">    helper(t,1)</span><br></pre></td></tr></table></figure>
<h3 id="生成器的生成器">生成器的生成器</h3>
<figure class="highlight plaintext"><figcaption><span>make_generators_generator(g):</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Generates all the &quot;sub&quot;-generators of the generator returned by</span><br><span class="line"></span><br><span class="line">    the generator function g.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_m_ints_to(n, m):</span><br><span class="line"></span><br><span class="line">    ...     i = 0</span><br><span class="line"></span><br><span class="line">    ...     while (i &lt;= n):</span><br><span class="line"></span><br><span class="line">    ...         yield i</span><br><span class="line"></span><br><span class="line">    ...         i += m</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_3_ints_to_10():</span><br><span class="line"></span><br><span class="line">    ...     for item in every_m_ints_to(10, 3):</span><br><span class="line"></span><br><span class="line">    ...         yield item</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; for gen in make_generators_generator(every_3_ints_to_10):</span><br><span class="line"></span><br><span class="line">    ...     print(&quot;Next Generator:&quot;)</span><br><span class="line"></span><br><span class="line">    ...     for item in gen:</span><br><span class="line"></span><br><span class="line">    ...         print(item)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    9</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">    def gen_helper(lst):</span><br><span class="line"></span><br><span class="line">        yield from lst</span><br><span class="line"></span><br><span class="line">    yield_sofar = []</span><br><span class="line"></span><br><span class="line">    gg = g()</span><br><span class="line"></span><br><span class="line">    for x in gg:</span><br><span class="line"></span><br><span class="line">        yield_sofar.append(x)</span><br><span class="line"></span><br><span class="line">        yield gen_helper(yield_sofar.copy())</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h3 id="生成器生成树的搜索路径">生成器生成树的搜索路径</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if t.label == value:</span><br><span class="line">        yield [value]</span><br><span class="line">    for b in t.branches:</span><br><span class="line">        for path in path_yielder(b, value):</span><br><span class="line">            yield [t.label] + path</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>伯克利</tag>
        <tag>课程笔记</tag>
        <tag>python</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基于c++ primer plus的读书笔记</title>
    <url>/thinklive/15197/</url>
    <content><![CDATA[<h1 id="c语言部分">c语言部分</h1>
<h2 id="基本函数构成">基本函数构成</h2>
<p>将数组传递为函数参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fcname(int arg[],int n)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="基本输入输出">基本输入输出</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- cin及其衍生函数返回一个iostream函数的引用，即支持</span><br><span class="line">cin,get().get()</span><br><span class="line">iostream的其他成员</span><br><span class="line">- cout.put()显示字符</span><br><span class="line">- cout.write()显示字符串</span><br><span class="line">- cout&lt;&lt;flush刷新缓冲区</span><br><span class="line">- cout&lt;&lt;endl刷新缓冲区并提供换行符</span><br><span class="line">- dec,hex,oct控制输出数制</span><br><span class="line">hex(cout)控制cout为16进制</span><br><span class="line">- int width()返回字段宽度当前设置</span><br><span class="line"> int width(int i)设置字段宽度，返回以前字段宽度 </span><br><span class="line"> 只影响下一次输出</span><br><span class="line"> - fill()设置填充用字符</span><br><span class="line"> - precision()设置精度，即保留几位小数</span><br><span class="line"> - setf()设置各种输出格式</span><br><span class="line"> - 流状态stream_state(eof,fail,bad)</span><br><span class="line"> - cin.get(ch)读取下一个字符，跳过换行符和空白</span><br><span class="line"> - cin.get()读取空白和换行符</span><br><span class="line"> - cin.get()get的基础上读取到换行符并丢弃</span><br><span class="line"> - cin.read()读取内容，但不会在末尾加空字符</span><br><span class="line"> - cin.peek()读取输入流下一个字符但不抽取</span><br><span class="line"> - cin.putback(ch)把一个字符放到输入流最前</span><br></pre></td></tr></table></figure>
<h3 id="文件输入输出">文件输入输出</h3>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写入文件</span><br><span class="line">ofstream fout;//ofstream继承ostream</span><br><span class="line">fout.open(&quot;hello.txt&quot;);</span><br><span class="line">fout &lt;&lt; &quot;i&#x27;m adding sth&quot;</span><br><span class="line">|| ofstream fout(&quot;hello.txt&quot;);</span><br><span class="line">读取文件也类似</span><br><span class="line">fin &gt;&gt; ch||string</span><br><span class="line">关闭流</span><br><span class="line">fout.close()</span><br><span class="line">fin.close()</span><br><span class="line">检测文件是否打开</span><br><span class="line">if (!fin.is_open())</span><br><span class="line">设置文件输入输出格式</span><br><span class="line">ios_base::</span><br></pre></td></tr></table></figure></p>
<h2 id="基本逻辑运算符">基本逻辑运算符</h2>
<p>break打断循环 continue，跳到更新表达式前开始执行 非const引用的函数不接受const参数</p>
<h2 id="基本数据类型">基本数据类型</h2>
<p>结构数组</p>
<figure class="highlight plaintext"><figcaption><span>stname;</span></figcaption><table><tr><td class="code"><pre><span class="line">stname stobj\[int x] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">union(类似结构，但相同数据类型只存一种)</span><br><span class="line">每个指针需要一个*用于初始化</span><br><span class="line">int * intlist=new int [10]</span><br><span class="line">delete-new</span><br><span class="line">delete []-new []</span><br><span class="line">typedef typename aliasname</span><br></pre></td></tr></table></figure>
<h2 id="名称空间">名称空间</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef HNAME_H</span><br><span class="line">#define HNAME_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>如果在遇到另一个定义HNAME_H的头文件时，将他忽略</p>
<p>作用域： 1默认情况下，函数中声明的变量作用域位于代码块内，如果函数内外都声明一个同名变量，运行至内部代码块使用内部，离开代码块使用外部 2静态变量存在于整个程序运行周期，脱离作用域后只是无法使用并不消失 代码块外声明且不带static关键字：链接性外部，可以在其他程序使用 代码块外声明，且使用static：链接性内部，可以在整个程序使用 代码块内声明，且使用static：作用域于代码块内，但始终存在//由于静态变量只可以定义一次，所以即使离开代码块后变量依旧存在，且值不变，直到下一次修改 3运算符::放置于变量前时，使用同名变量（如果有）的全局版本 4namespace{</p>
<p>} 无法放置于代码块内，因此默认为全局名称，可以囊括声明和定义，可以随时添加 定义于类声明的函数自动成为内联函数</p>
<h1 id="c特性">c++特性</h1>
<h2 id="class">class</h2>
<p>1声明构造函数时，尽量使用explicit(显性转换)前缀，防止隐性转换带来的问题 mutable(摆动的)前缀声明变量，表示这些变量可能在const成员函数内被更改 用const_cast&lt;&gt;和static_cast&lt;&gt;与this指针可以实现const成员函数向非const的转变，反之则是错误的</p>
<p>2class初始化成员时，按构造函数声明变量的顺序，因此初始化成员时最好也以此顺序初始化 如果不希望class有copy和赋值(=)操作，则应该在private里定义copy和=运算符</p>
<p>3基类引用可以指向派生类对象，无需进行强制类型转换</p>
<p>4定义于类声明的函数自动成为内联函数</p>
<p>5类的函数对所有对象共用，但数据则各自私有</p>
<p>6要创造类对象数组，该类必须有默认构造函数</p>
<p>7只有一个构造函数参数的构造函数可以用于类的自动转换 classname t; t=20; 如果想禁止这种转换，可以声明explicit给构造函数</p>
<p>8类声明中可定义对于某种基本类型的转换函数 operator int();//可声明为显式转换，尽量避免过多的转换造成二义性</p>
<p>9如果定义类成员参数为static，则它在程序中只有一个地址，可以被所有类成员共享 但通过static实现共享成员时，需要重新定义复制和赋值函数来避免问题</p>
<h3 id="动态类的注意事项">动态类的注意事项</h3>
<p>*构造函数中如果用new初始化指针成员，则应该在析构函数中使用delete new对应delete,new[]对应delete[] 对多个构造函数，应用和析构函数兼容的new来初始化成员 重构复制和赋值运算符来实现深复制</p>
<p>10对于使用new创建的类，使用delete时其析构函数才会被调用 如果在使用new时，将对象地址赋予一个指针时，如果删除指针，则对应的对象会调用自己的析构函数 对与使用定位new创建的类对象，需要显式调用析构函数 object-&gt;~classname(); 且应该以创建顺序的相反顺序调用，因为后创建的对象可能依赖于前者</p>
<h3 id="类继承">类继承</h3>
<h4 id="公有继承">公有继承</h4>
<p>class sonclassname: public fatherclassname 派生类继承了基类的公有接口和数据 但只能用基类public和protected函数访问基类私有数据 派生类可添加函数和数据成员 派生类需要自己的构造函数，并由于权限问题，其构造函数必须包括基类构造函数，并且同样可以使用成员初始化列表 <code>指针</code> 基类指针和引用可以在不显式转化的情况下指向派生类对象反过来却不行 <code>虚函数</code></p>
<ul>
<li>对于基类和派生类的同名函数： 如果函数通过引用或指针调用，将确定使用哪种方法 ￥如果没有使用关键字virual，将根据引用类型或指针类型选择方法。 如果使用了关键字virtual，将根据引用或指针指向对象的类型选择方法</li>
<li>构造函数不能为虚函数</li>
<li>析构函数应当为虚函数</li>
<li>友元函数并非类成员，但可以使用虚函数</li>
<li>**重新定义继承方式（虚实）并非重载，会覆盖掉原先的虚函数定义，如果必须重新定义，则需要重新定义使用基类虚函数</li>
</ul>
<p><code>纯虚函数</code> virual typename func() const=0; 含有虚函数的类不能创建实例，只能用作基类</p>
<p><code>访问控制（protected）</code> 派生类成员函数可以访问protected成员，不能访问private成员</p>
<h4 id="私有继承">私有继承</h4>
<p>使用私有继承，基类的公有成员和保护成员都成为派生类的私有成员，只可以在派生类的成员函数中使用，可以实现has_a关系 私有继承访问基类方法时需要调动基类的命名空间 <code>访问基类对象</code> 如果要直接访问基类对象，则需要调用强制类型转化将派生类转化为基类</p>
<h4 id="保护继承">保护继承</h4>
<p>保护继承时，基类的公有和保护成员都成为派生类的保护成员，基类接口在派生类中可用</p>
<p>通过using指令可以让私有函数被当前作用域可用</p>
<h2 id="命令行参数">命令行参数</h2>
<p>int main(int argc,char* argv[]) argc为参数个数 argv为参数组成的字符串</p>
<h2 id="字符输入">字符输入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; ***(读取输入中的结束字符为结束标志，会将换行符留在输入流)</span><br><span class="line">getline(stringname,length)通过换行符确定输入结束点</span><br><span class="line">cin.get()读取到换行符之前，不带参数则读取下一个字符(用于清除换行符)</span><br><span class="line">cin.clear()清空输入流</span><br><span class="line">&lt;string&gt;</span><br><span class="line">重载符号+实现拼接</span><br><span class="line">str.size()</span><br><span class="line">输入字符串使用getline(cin,str)</span><br><span class="line">结构数组</span><br><span class="line">struct stname;</span><br><span class="line">stname stobj[int x] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">字符函数库&lt;cctype&gt;</span><br><span class="line">isspace(ch)测试是否空白</span><br><span class="line">isalpha(ch)是否字符</span><br><span class="line">isdigit()是否数字</span><br><span class="line">ispunct()是否标点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; ***(读取输入中的结束字符为结束标志，会将换行符留在输入流)</span><br><span class="line">getline(stringname,length)通过换行符确定输入结束点</span><br><span class="line">cin.get()读取到换行符之前，不带参数则读取下一个字符(用于清除换行符)</span><br><span class="line">cin.clear()清空输入流</span><br></pre></td></tr></table></figure>
<p>&lt;string&gt; 重载符号+实现拼接 str.size() 输入字符串使用getline(cin,str) 结构数组 struct stname; stname stobj[int x] = { {} {} } 字符函数库&lt;cctype&gt; isspace(ch)测试是否空白 isalpha(ch)是否字符 isdigit()是否数字 ispunct()是否标点</p>
<h2 id="指针">指针</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，c++没有溢出检测机制，</span><br><span class="line">char name[]=&quot;hello&quot;;</span><br><span class="line">char c =name[10]导致未定义行为</span><br><span class="line">2，用一个常量指针指向常量需要两次const</span><br><span class="line">const char* const name=&quot;hhh&quot;</span><br><span class="line">如果需要一个class专属常量，则使用</span><br><span class="line">static const ***</span><br><span class="line">实现文件中，const int classname:: ***</span><br><span class="line">对于宏：</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline functionname</span><br><span class="line">3,const 出现在*左侧表示被指物为常量，右侧表示指针为常量指针</span><br><span class="line">4,函数名就是函数的地址</span><br><span class="line">double pam(int);</span><br><span class="line">double(*pt)(int);</span><br><span class="line">pt即为函数指针</span><br><span class="line">如果需要一个函数以相同相同返回值和参数的函数为一个参数，则可以考虑函数指针</span><br><span class="line">5，内联函数不能递归</span><br><span class="line">6,引用容器时，如果迭代器不引用，仍然传递临时副本o</span><br><span class="line">7,函数传递指针时按值传递，当向函数传递指针时，指针是按值传递的！这意味着你可以改变被指向的数组内容，因为在调用函数时，这些元素不会被复制！这意味着你可以改变被指向的数组的内容，因为这些元素在函数被调用时并没有被复制。另一方面，如果你改变了所指向的数组，这种改变在函数之外不会持续，因为你只改变了指针的拷贝，而不是原来的指针本身。</span><br></pre></td></tr></table></figure>
<h3 id="智能指针">智能指针</h3>
<p>auto_ptr&lt;string&gt; 和&lt;unique_ptr&gt;指针采用所有权模型，对特定对象只有一个智能指针可以拥有它，只有拥有它的指针可以删除它 shared_ptr&lt;string&gt;追踪引用对象的智能指针数量，最后一个指针过期时才会调用delete 使用new分配内存才能使用auto_ptr,unique_ptr</p>
<h2 id="异常">异常</h2>
<h3 id="try_catch">try_catch</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"> func();</span><br><span class="line">&#125;</span><br><span class="line">catch(errortype e1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line">&#123;</span><br><span class="line"> do sth;</span><br><span class="line"> throw(error_type e1);8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>栈解退</code> 假设try块没有直接调用引发异常的函数，而是调用对引发异常的函数进行调用的函数，则程序从引发异常的函数跳到包含try块和处理程序的函数（追踪到一个地址位于try块的返回地址） <code>其他异常特性</code></p>
<ul>
<li>throw-catch类似函数参数和返回，但函数返回语句将控制器交给调用函数的函数，但throw语句将控制权向上返回到第一个这样的函数，包含能捕获相应异常的try-catch组合</li>
<li>throw语句总是生成副本，但catch参数使用基类引用能捕获所有派生类的异常对象</li>
</ul>
<h4 id="exception类">exception类</h4>
<p>exception类可作为其他异常类的基类，用what的虚函数（返回一个字符串）重载来指示错误类型 <code>失败时返回空指针的语法</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * pi= new (std::nothrow) int;</span><br></pre></td></tr></table></figure>
<h3 id="未捕获异常">未捕获异常</h3>
<p>未捕获的异常会使程序调用函数terminate(),默认情况下，terminate()调用abort()函数，可以指定terminate()调用的函数来修改其行为</p>
<h2 id="一些新特性">一些新特性</h2>
<h3 id="关键字">关键字</h3>
<p>关键字nullptr表示空指针</p>
<h3 id="rtti运行阶段类型识别">RTTI(运行阶段类型识别)</h3>
<h4 id="dynamiccast">dynamic——cast</h4>
<p>danamic_cast&lt;type *&gt; (pt) 如果可以安全将pt转化为type*指针，返回对象地址，否则返回空指针 如果对引用使用，错误时返回bad_cast异常</p>
<h4 id="typeid和type_info">typeid和type_info</h4>
<p>typeid返回对type_info对象的引用，type_ifo是定义在typeinfo的类，重载==和!=预算符，例如 typeid(obj1)==typeid(obj2)</p>
<h3 id="类型转换运算符">类型转换运算符</h3>
<ul>
<li>dynamic_cast</li>
<li>const_cast</li>
<li>static_cast</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用于执行各种类型的数值转换static_cast &lt;typename&gt; (expression)</span><br><span class="line">//转换是允许隐式转换时才能通过（派生类和基类可以互相转换）</span><br></pre></td></tr></table></figure>
<ul>
<li>reinterpret_cast /执行危险的转换</li>
</ul>
<p>移动语义 通过指针转移右值的地址给新对象 或通过std::move()将左值转化为右值</p>
<p>someclass()=default default关键字显式声明编译器创建默认构造函数，复制构造函数 delete用于禁止类中的函数</p>
<p>关键字override可用于覆盖虚函数定义</p>
<h3 id="匿名函数">匿名函数</h3>
<p>返回类型编译器自动确定，可直接作为函数指针使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[] (double x) &#123;return x%3==0;&#125; </span><br></pre></td></tr></table></figure>
<p>可以返回类型后置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[] (double x)-&gt; double&#123;int y = x;return y-x;&#125;</span><br></pre></td></tr></table></figure>
<p>可以给匿名函数命名</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于斯坦福cs106l的c++编程规范笔记</title>
    <url>/thinklive/48468/</url>
    <content><![CDATA[<h2 id="c特性">c++特性</h2>
<ul>
<li>更好的C C++支持<code>命令式编程</code>，一种编程风格，其中程序按顺序执行的命令序列。从这个意义上讲，C++ 可以看作是对C 编程语言，使日常命令式编程更加直观和更容易使用。课程阅读器的这一部分介绍了一些 C++ 最常用的库,包括标准模板库，并展示了如何使用这些库来构建命令程式。 此外，它探索了最初出现在 C++ 语言中的新原语。C 编程语言，即指针、C 字符串和预处理器。 <span id="more"></span></li>
<li>数据抽象</li>
</ul>
<p>C++与其兄弟C的最大区别在于_数据抽象_,程序执行的方式可以与程序执行的方式分开 程序员谈论那个程序。</p>
<ul>
<li>面向对象编程</li>
</ul>
<p>. 面向对象编程是一种完全不同的方式考虑程序设计，可以极大地简化复杂的软件系统。 钥匙 面向对象背后的概念很简单，但要真正体会到面向对象的力量 编程，您将需要一次又一次地看到它的运行情况。 这部分课程 读者探索了面向对象编程中的主要概念以及如何在 C++ 中实现它继承和多态。</p>
<ul>
<li>泛型编程</li>
</ul>
<p>泛型编程是一种编程风格，旨在构建可以解决一系列远远超出最初设想的问题的软件<br />
履行。 虽然泛型编程的完整处理远远超出了介绍性的范围C++ 编程课，泛型编程的许多思想都可以访问并且可以从根本上改变了您对 C++ 编程的看法。</p>
<h2 id="const">const</h2>
<p>Can’t declare non-const reference to const variable Can’t declare non-const reference to const vari</p>
<p><img src="/images/obsidian/20230215213916.png" title="image" alt="图片" /> <img src="/images/obsidian/20230215214023.png" title="image" alt="图片" /></p>
<h2 id="模板">模板</h2>
<p><img src="/images/obsidian/20230215215043.png" title="image" alt="图片" /> 函数指针：将函数作为对象传递</p>
<h2 id="stl">stl</h2>
<p>sequence:线性，有顺序 associative:不一定线性，有索引机制(map)</p>
<p>vector:有顺序的相同类型的数据集合，大小可控制 ---子属性：<em>size:元素数量 ---capacity</em>:单个元素大小 <img src="/images/obsidian/20230214194657.png" title="image" alt="图片" /> vector最常用，deque用于首部插入场合，list用于多种列表</p>
<p>associative(关联数组):有顺序的需要有比较方法，无序的需要哈希函数（更快） iterators（迭代器）：用于访问容器中的所有数据 --常用函数，begin(),end(),iter++,*(pointer),== !=,=（赋值,复制）, <img src="/images/obsidian/20230214200501.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214200805.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214201819.png" title="image" alt="图片" /></p>
<h2 id="输入输出流">输入输出流</h2>
<p>First call to std::cin &gt;&gt; creates a command line<br />
prompt that allows the user to type until they hit enter</p>
<ul>
<li>Each &gt;&gt; ONLY reads until the next whitespace<br />
</li>
<li>Whitespace = tab, space, newline<br />
</li>
<li>Everything after the first whitespace gets saved and<br />
used the next time std::cin &gt;&gt; is called<br />
</li>
<li>The place its saved is called a buffer <img src="/images/obsidian/20230213213832.png" title="image" alt="图片" /> <img src="/images/obsidian/20230213214430.png" title="image" alt="图片" /> <img src="/images/obsidian/20230213214751.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214102508.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214104421.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214162731.png" title="image" alt="图片" /> <img src="/images/obsidian/20230214162820.png" title="image" alt="图片" /></li>
</ul>
<h2 id="hashmap的c实现">hashmap的c++实现</h2>
<h3 id="相关函数">相关函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数HashMap():</span><br><span class="line">接受参数count(值的个数),hash function(有默认值)</span><br><span class="line"></span><br><span class="line">参数(typename fitst,typename last,bucket_count,H)</span><br><span class="line">//用一个容器首尾指针初始化hashmap</span><br><span class="line">eg.</span><br><span class="line">hashmap&lt;k,m&gt; map&#123;vec.begin(),vec.end()&#125;</span><br><span class="line"></span><br><span class="line">参数(init_list init,bucket_count,H)</span><br><span class="line">//用容器直接初始化hashmap</span><br><span class="line">eg.</span><br><span class="line">HashMap&lt;char, int&gt; map&#123;&#123;&#x27;a&#x27;, 3&#125;, &#123;&#x27;b&#x27;, 5&#125;, &#123;&#x27;c&#x27;, 7&#125;&#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">key-键</span><br><span class="line">mapped-被加密的值(int)</span><br><span class="line">H-哈希函数</span><br><span class="line">bucket_count(存储的键值对数组容量)</span><br><span class="line">load_factor(内联函数，返回size/bucket_count，即实际储存值的键值对)</span><br><span class="line">contains(参数const K&amp; key判断是否存在改键，返回bool值)</span><br><span class="line">at(参数k，返回mapped的引用)</span><br><span class="line">clear(清空键值对)</span><br><span class="line">insert(参数为键值对引用，返回一对pair&lt;iterator,bool&gt;,iter指向改键值对，无论是否已存在，bool表示是否成功添加，如为false则已存在该键值对)</span><br><span class="line">erase(key为参数，返回bool值)</span><br><span class="line">earse(iter为参数，返回该指针下一个位置)</span><br><span class="line">rehash(size_t为参数，重新哈希为给出的新的指针数组大小)</span><br><span class="line">begin(根据hashmap是否为const给出iter或const iter)</span><br><span class="line">end(返回伪指针)</span><br><span class="line">debug(打印所有哈希键值对以及哈希表所有参数，注意，必须基于重载&lt;&lt;运算符的基础)</span><br><span class="line"></span><br><span class="line">符号重载：</span><br><span class="line">M&amp; [](const key&amp; ,返回insert(key)的返回pair的first成员的second成员，即mapped值)</span><br><span class="line">//用于给key对应的value(mapped)赋值</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">node(struct，包含next指针和value)</span><br><span class="line">nodepair(前后node的pair)</span><br><span class="line">findnode(参数key，返回指针对&lt;prev,curr&gt;)</span><br><span class="line">first_not_empty_bucket()</span><br><span class="line">make_iterator(参数node*curr)</span><br><span class="line">_bucket_array(vector&lt;node*&gt;,其中一个node*为ptr,则ptr-&gt;value为&lt;key ,mapped&gt;)</span><br><span class="line"></span><br><span class="line">//指针构造</span><br><span class="line"></span><br><span class="line">_bucket_array：由指针组成的数组,每个成员都是一个指针</span><br><span class="line">储存的值为next指针和一个pair&lt;key,mapped&gt;</span><br><span class="line">operator-&gt; is a bit of an odd-ball. When you write p-&gt;m, it is interpreted as (p.operator-&gt;())-&gt;m.</span><br><span class="line"></span><br><span class="line">- This means operator-&gt; should return a pointer to the object that has the field m.</span><br></pre></td></tr></table></figure>
<h3 id="涉及的c特性">涉及的c++特性</h3>
<p>匿名函数 基本lambda语法 基本形式如下： 【capture】（parameters）-&gt;return-type {body}</p>
<p>typename function() return {x,y,z} 即用{}的参数初始化原函数返回的类型</p>
<p>ptrdiff_t:用于储存两个指针的差</p>
<p>conditional_t&lt;func,x,y&gt;如果func为true则x，为false则y</p>
<p>forward_iterator_tag：单方向迭代器（可读写） ++iter，iter+=1随后返回对自身的引用 iter++，先返回一个对自身的复制，随后iter+=1</p>
<p>std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p>
<p>ate：从文件尾部开始 strsub(start,length) 移动语义(c++11新特性) clss(classname &amp;&amp;) 利用右值引用的部分数据直接初始化新的类，并在初始化之后将右值删除，可以通过std::move()强制转化左值为右值。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>c++</tag>
        <tag>斯坦福</tag>
      </tags>
  </entry>
  <entry>
    <title>基于北大前沿计算实践课和missing semester的linux等编程工具笔记</title>
    <url>/thinklive/11069/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p><a href="https://en.wikipedia.org/wiki/Linux">Linux</a>是一群<strong>开源</strong>的、基于<strong>Linux内核</strong>的<strong>类Unix操作系统</strong>集合。</p>
<ul>
<li>操作系统(operating system)：管理计算机硬件和软件资源的程序，为用户程序提供硬件抽象和接口。</li>
<li>操作系统内核(operating system kernel)：操作系统最核心的部分，管理系统的进程、内存、设备驱动程序、文件和网络系统，一直在内存中，不包括图形界面、Shell等功能</li>
<li>Shell：内核的封装，为用户提供更高级的抽象，比如<code>echo</code>、<code>ls</code>、<code>cd</code>等命令，以及进程间通信功能（管道） <span id="more"></span></li>
<li>Unix内核：最早形成规模，被广泛使用的操作系统，由肯•汤普森(Ken Thompson)和丹尼斯•里奇(Dennis Ritchie)发明，使用C编写，现在常用的基于UNIX内核的操作系统有<a href="https://www.oracle.com/solaris/solaris11/">Solaris</a>、<a href="https://www.freebsd.org/">FreeBSD</a></li>
<li>Linux内核：由李纳斯•托瓦兹(Linus Torvalds)在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版UNIX操作系统Minix太难用了，于是决定自己开发一个操作系统。第1版本于1991年9月发布，当时仅有10000行代码。李纳斯•托瓦兹没有保留Linux源代码的版权，公开了代码，并邀请他人一起完善Linux。据估计，现在只有2%的Linux核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有Linux内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权(Benevolent dictator for life, BDFL)。</li>
</ul>
<h2 id="shell的配置">shell的配置</h2>
<p>很多程序的配置都是通过纯文本格式的被称作_点文件_的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>并不会显示它们）。</p>
<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a> 有非常好的资源</p>
<p>对于 <code>bash</code>来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH="$PATH:/path/to/program/bin"</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p>
<p>还有一些其他的工具也可以通过_点文件_进行配置：</p>
<ul>
<li><code>bash</code> - <code>~/.bashrc</code>, <code>~/.bash_profile</code></li>
<li><code>git</code> - <code>~/.gitconfig</code></li>
<li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li>
<li><code>ssh</code> - <code>~/.ssh/config</code></li>
<li><code>tmux</code> - <code>~/.tmux.conf</code></li>
</ul>
<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p>
<ul>
<li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li>
<li><strong>可以执行</strong>: 您的工具在任何地方都以相同的配置工作</li>
<li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li>
<li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li>
<li>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</li>
</ul>
<p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"></span><br><span class="line"># 使用和 shell 相关的配置时先检查当前 shell 类型</span><br><span class="line">if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"></span><br><span class="line"># 您也可以针对特定的设备进行配置</span><br><span class="line">if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then &#123;do_something&#125;; fi</span><br></pre></td></tr></table></figure>
<p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure>
<p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Test if ~/.aliases exists and source it</span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="包管理">包管理</h2>
<p>在Ubuntu下，我们也可以在网站上下载软件包，后缀为<code>.deb</code>，然后调用<code>dpkg</code>进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure>
<p><code>.deb</code>文件后缀是<a href="https://www.debian.org/">Debian</a>系统的 软件包格式，Ubuntu基于Debian开发因此使用相同的软件包格式，里面包含了程序的二进制文件、配置文件、man/info帮助页面等信息。用户 不同的任务依赖大量的软件支撑，不同的软件往往有着复杂的依赖关系，一个软件往往也有很多版本，为了管理这么多的软件，Ubuntu提供了统一的软件管理 机制，也就是<code>dpkg</code>和<code>ap![[download.gif]]t</code>。 <code>dpkg</code>的用法如上所示，<code>dpkg -l</code>可以列出所有的以安装软件，<code>dpkg -r</code>卸载软件，更多命令可以使用<code>dpkg --help</code>或者<code>man dpkg</code>。dpkg安装完成之后，默认文件存放位置如下：</p>
<ul>
<li>二进制文件：<code>/usr/bin</code></li>
<li>库文件：<code>/usr/lib</code></li>
<li>配置文件：<code>/etc</code></li>
<li>使用手册和帮助文档：<code>/usr/share/doc</code></li>
<li>man帮助页面：<code>/usr/share/man</code></li>
</ul>
<p>然而dpkg并不是万能的，当某个软件的依赖项没有安装时dpkg就会报错，需要用户手动安装依赖项。apt很好地解决了这一问题。首先开发者会将 编译后的二进制文件和软件信息存放在Ubuntu的源服务器上，当需要安装软件时，apt会自动从服务器上获取软件依赖信息，然后从服务器上下载依赖并安 装，然后再安装需要的软件。服务器的信息记录在本地的<code>/etc/apt/sources.list</code>中：</p>
<h2 id="shell脚本">shell脚本</h2>
<h3 id="赋值">赋值</h3>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，在shell脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash中的字符串通过<code>'</code> 和 <code>"</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>"</code>定义的字符串会将变量值进行替换</p>
<h3 id="参数">参数</h3>
<ul>
<li><code>$0</code> - 脚本名</li>
<li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li>
<li><code>$@</code> - 所有参数</li>
<li><code>$#</code> - 参数个数</li>
<li><code>$?</code> - 前一个命令的返回值</li>
<li><code>$$</code> - 当前脚本的进程识别码</li>
<li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li>
<li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li>
</ul>
<h3 id="返回值">返回值</h3>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别</p>
<h2 id="查找">查找</h2>
<h3 id="查找文件">查找文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找所有名称为src的文件夹</span><br><span class="line">find . -name src -type d</span><br><span class="line"># 查找所有文件夹路径中包含test的python文件</span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"># 查找前一天修改的所有文件</span><br><span class="line">find . -mtime -1</span><br><span class="line"># 查找所有大小在500k至10M的tar.gz文件</span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除全部扩展名为.tmp 的文件</span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"># 查找全部的 PNG 文件并将其转换为 JPG</span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure>
<p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name '*PATTERN*'</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码">查找代码</h3>
<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。 它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：****</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找所有使用了 requests 库的文件</span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"># 查找所有的foo字符串，并打印其之后的5行</span><br><span class="line">rg foo -A 5</span><br><span class="line"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure>
<h2 id="使用建议">使用建议</h2>
<h3 id="建立别名">建立别名</h3>
<p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias alias_name=&quot;command_to_alias arg1 arg2&quot;</span><br></pre></td></tr></table></figure>
<p>注意， <code>=</code>两边是没有空格的，因为 <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p>
<p>别名有许多很方便的特性:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建常用命令的缩写</span><br><span class="line">alias ll=&quot;ls -lh&quot;</span><br><span class="line"></span><br><span class="line"># 能够少输入很多</span><br><span class="line">alias gs=&quot;git status&quot;</span><br><span class="line">alias gc=&quot;git commit&quot;</span><br><span class="line">alias v=&quot;vim&quot;</span><br><span class="line"></span><br><span class="line"># 手误打错命令也没关系</span><br><span class="line">alias sl=ls</span><br><span class="line"></span><br><span class="line"># 重新定义一些命令行的默认行为</span><br><span class="line">alias mv=&quot;mv -i&quot;           # -i prompts before overwrite</span><br><span class="line">alias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed</span><br><span class="line">alias df=&quot;df -h&quot;           # -h prints human readable format</span><br><span class="line"></span><br><span class="line"># 别名可以组合使用</span><br><span class="line">alias la=&quot;ls -A&quot;</span><br><span class="line">alias lla=&quot;la -l&quot;</span><br><span class="line"></span><br><span class="line"># 在忽略某个别名</span><br><span class="line">\ls</span><br><span class="line"># 或者禁用别名</span><br><span class="line">unalias la</span><br><span class="line"></span><br><span class="line"># 获取别名的定义</span><br><span class="line">alias ll</span><br><span class="line"># 会打印 ll=&#x27;ls -lh&#x27;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是<code>.bashrc</code> 或 <code>.zshrc</code>，</p>
<h3 id="tips">tips</h3>
<p>右击边框开启设置菜单 <code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p>
<p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。 <a href="https://github.com/clvv/fasd"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a> 对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>
<h2 id="命令行环境">命令行环境</h2>
<h3 id="默认环境变量">默认环境变量</h3>
<p>因为Shell中定义的环境变量之后影响子进程，为了避免我们每次都需要在使用前定义环境变量，我们可以将这一设置写进<code>~/.bashrc</code>里，这个配置文件会在每次启动bash时执行。<code>~/.bashrc</code>中已经包含了很多配置，我们要做的就是在最后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HELLO=hello</span><br></pre></td></tr></table></figure>
<p>然后执行<code>source ~/.bashrc</code>，这样就可以在每次打开Shell的时候定义这一环境变量。利用这个机制，假如我们想把自定义的命令加入<code>PATH</code>中时就可以在<code>~/.bashrc</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/path/to/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>这样命令就会添加到Shell的搜索路径中。需要注意的一点是，如果使用的是zsh，需要修改的就不是<code>~/.bashrc</code>，而是<code>~/.zshrc</code></p>
<h3 id="端口转发">端口转发</h3>
<p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>
<p>此时就需要进行 <em>端口转发</em>。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇<a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p>
<p><strong>本地端口转发</strong> <img src="https://i.stack.imgur.com/a28N8.png" title="本地端口转发" alt="Local Port Forwarding" /></p>
<p><strong>远程端口转发</strong> <img src="https://i.stack.imgur.com/4iK3b.png" title="远程端口转发" alt="Remote Port Forwarding" /></p>
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>
<h3 id="信号机制">信号机制</h3>
<p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种_软件中断_。</p>
<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个<code>SIGINT</code> 信号到进程。</p>
<p>下面这个 Python 程序向您展示了捕获信号<code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用<code>SIGQUIT</code> 信号，通过输入<code>Ctrl-\</code>可以发送该信号。 尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。 信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code>是 Terminal Stop 的缩写（即<code>terminal</code>版本的SIGSTOP）。</p>
<p>我们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入<code>Ctrl-Z</code> ，然后紧接着再输入<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用<code>disown</code> 。除此之外，您可以使用终端多路复用器来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"></span><br><span class="line">$ nohup sleep 2000 &amp;</span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ bg %1</span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -STOP %1</span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %1</span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %2</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill %2</span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>
<h3 id="tmux多路终端复用">tmux多路终端复用</h3>
<p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>
<p>像 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a> 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p>
<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>
<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p>
<p>现在最流行的终端多路器是 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>
<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p>
<ul>
<li><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口
<ul>
<li><code>tmux</code> 开始一个新的会话</li>
<li><code>tmux new -s NAME</code> 以指定名称开始一个新的会话</li>
<li><code>tmux ls</code> 列出当前所有会话</li>
<li>在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离</li>
<li><code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li>
</ul></li>
<li><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分
<ul>
<li><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code>关闭</li>
<li><code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的</li>
<li><code>&lt;C-b&gt; p</code> 切换到前一个窗口</li>
<li><code>&lt;C-b&gt; n</code> 切换到下一个窗口</li>
<li><code>&lt;C-b&gt; ,</code> 重命名当前窗口</li>
<li><code>&lt;C-b&gt; w</code> 列出当前所有窗口</li>
</ul></li>
<li><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell
<ul>
<li><code>&lt;C-b&gt; "</code> 水平分割</li>
<li><code>&lt;C-b&gt; %</code> 垂直分割</li>
<li><code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，<方向> 指的是键盘上的方向键</li>
<li><code>&lt;C-b&gt; z</code> 切换当前面板的缩放</li>
<li><code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分</li>
<li><code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li>
</ul></li>
</ul>
<h3 id="ssh">ssh</h3>
<p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></table></figure>
<p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如<code>bar.mit.edu</code>），也可以使用 IP 指定（例如<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p>
<h4 id="执行命令">执行命令</h4>
<p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。 <code>ssh foobar@server ls</code> 可以直接在用foobar的命令下执行 <code>ls</code> 命令。 想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p>
<h4 id="ssh-密钥">SSH 密钥</h4>
<p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p>
<h4 id="密钥生成">密钥生成</h4>
<p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>
<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h4 id="基于密钥的认证机制">基于密钥的认证机制</h4>
<p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>
<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了<a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p>
<h3 id="g-基于密钥的认证机制">G# 基于密钥的认证机制</h3>
<p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat .ssh/id_ed25519 | ssh foobar@remote &#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br></pre></td></tr></table></figure>
<p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></table></figure>
<h2 id="文本匹配">文本匹配</h2>
<ul>
<li>当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li>
<li>花括号<code>&#123;&#125;</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</li>
<li>[[Pasted image 20230128155221.png]]</li>
</ul>
<h3 id="正则表达式">正则表达式</h3>
<p>正则表达式通常以（尽管并不总是） <code>/</code>开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<ul>
<li><code>.</code> 除换行符之外的”任意单个字符”</li>
<li><code>*</code> 匹配前面字符零次或多次</li>
<li><code>+</code> 匹配前面字符一次或多次</li>
<li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li>
<li><code>(RX1|RX2)</code> 任何能够匹配<code>RX1</code> 或 <code>RX2</code>的结果</li>
<li><code>^</code> 行首</li>
<li><code>$</code> 行尾</li>
</ul>
<h3 id="awk">awk</h3>
<p>擅长文本处理的编程语言 <code>&#123;print $2&#125;</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。 在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过<code>-F</code>来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名 让我们统计一下所有以<code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| awk &#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27; | wc -l</span><br></pre></td></tr></table></figure>
<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>指定了一个匹配模式串（也就是<code>&#123;...&#125;</code>前面的那部分内容）。该匹配要求文本的第一部分需要等于1（这部分刚好是<code>uniq -c</code>得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN &#123; rows = 0 &#125;</span><br><span class="line">$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; rows += $1 &#125;</span><br><span class="line">END &#123; print rows &#125;</span><br></pre></td></tr></table></figure>
<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。</p>
<h2 id="守护进程">守护进程</h2>
<p>即便守护进程（daemon）这个词看上去有些陌生，你应该已经大约明白它的概念。大部分计算机都有一系列在后台保持运行，不需要用户手动运行或者交互的进程。这些进程就是守护进程。以守护进程运行的程序名一般以 <code>d</code> 结尾，比如 SSH 服务端 <code>sshd</code>，用来监听传入的 SSH 连接请求并对用户进行鉴权。</p>
<p>Linux 中的 <code>systemd</code>（the system daemon）是最常用的配置和运行守护进程的方法。运行 <code>systemctl status</code> 命令可以看到正在运行的所有守护进程。这里面有很多可能你没有见过，但是掌管了系统的核心部分的进程：管理网络、DNS解析、显示系统的图形界面等等。用户使用 <code>systemctl</code> 命令和 <code>systemd</code> 交互来<code>enable</code>（启用）、<code>disable</code>（禁用）、<code>start</code>（启动）、<code>stop</code>（停止）、<code>restart</code>（重启）、或者<code>status</code>（检查）配置好的守护进程及系统服务。</p>
<p><code>systemd</code> 提供了一个很方便的界面用于配置和启用新的守护进程或系统服务。下面的配置文件使用了守护进程来运行一个简单的 Python 程序。文件的内容非常直接所以我们不对它详细阐述。<code>systemd</code> 配置文件的详细指南可参见 <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">freedesktop.org</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/systemd/system/myapp.service</span><br><span class="line">[Unit]</span><br><span class="line"># 配置文件描述</span><br><span class="line">Description=My Custom App</span><br><span class="line"># 在网络服务启动后启动该进程</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"># 运行该进程的用户</span><br><span class="line">User=foo</span><br><span class="line"># 运行该进程的用户组</span><br><span class="line">Group=foo</span><br><span class="line"># 运行该进程的根目录</span><br><span class="line">WorkingDirectory=/home/foo/projects/mydaemon</span><br><span class="line"># 开始该进程的命令</span><br><span class="line">ExecStart=/usr/bin/local/python3.7 app.py</span><br><span class="line"># 在出现错误时重启该进程</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"># 相当于Windows的开机启动。即使GUI没有启动，该进程也会加载并运行</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"># 如果该进程仅需要在GUI活动时运行，这里应写作：</span><br><span class="line"># WantedBy=graphical.target</span><br><span class="line"># graphical.target在multi-user.target的基础上运行和GUI相关的服务</span><br></pre></td></tr></table></figure>
<h2 id="备份">备份</h2>
<p>任何没有备份的数据都可能在一个瞬间永远消失。复制数据很简单，但是可靠地备份数据很难。下面列举了一些关于备份的基础知识，以及一些常见做法容易掉进的陷阱。</p>
<p>首先，复制存储在同一个磁盘上的数据不是备份，因为这个磁盘是一个单点故障（single point of failure）。这个磁盘一旦出现问题，所有的数据都可能丢失。放在家里的外置磁盘因为火灾、抢劫等原因可能会和源数据一起丢失，所以是一个弱备份。推荐的做法是将数据备份到不同的地点存储。</p>
<p>同步方案也不是备份。即使方便如 Dropbox 或者 Google Drive，当数据在本地被抹除或者损坏，同步方案可能会把这些“更改”同步到云端。同理，像 RAID 这样的磁盘镜像方案也不是备份。它不能防止文件被意外删除、损坏、或者被勒索软件加密。</p>
<p>有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。对备份的数据实施版本控制保证了用户可以从任何记录过的历史版本中恢复数据。在备份中检测并删除重复数据，使其仅备份增量变化可以减少存储开销。在安全性方面，作为用户，你应该考虑别人需要有什么信息或者工具才可以访问或者完全删除你的数据及备份。最后一点，不要盲目信任备份方案。用户应该经常检查备份是否可以用来恢复数据。</p>
<p>备份不限制于备份在本地计算机上的文件。云端应用的重大发展使得我们很多的数据只存储在云端。当我们无法登录这些应用，在云端存储的网络邮件，社交网络上的照片，流媒体音乐播放列表，以及在线文档等等都会随之丢失。用户应该有这些数据的离线备份，而且已经有项目可以帮助下载并存储它们。</p>
<h2 id="常见命令行标志参数及模式">常见命令行标志参数及模式</h2>
<p>命令行工具的用法千差万别，阅读 <code>man</code> 页面可以帮助你理解每种工具的用法。即便如此，下面我们将介绍一下命令行工具一些常见的共同功能。</p>
<ul>
<li><p>大部分工具支持 <code>--help</code> 或者类似的标志参数（flag）来显示它们的简略用法。</p></li>
<li><p>会造成不可撤回操作的工具一般会提供“空运行”（dry run）标志参数，这样用户可以确认工具真实运行时会进行的操作。这些工具通常也会有“交互式”（interactive）标志参数，在执行每个不可撤回的操作前提示用户确认。</p></li>
<li><p><code>--version</code> 或者 <code>-V</code> 标志参数可以让工具显示它的版本信息（对于提交软件问题报告非常重要）。</p></li>
<li><p>基本所有的工具支持使用 <code>--verbose</code> 或者 <code>-v</code> 标志参数来输出详细的运行信息。多次使用这个标志参数，比如 <code>-vvv</code>，可以让工具输出更详细的信息（经常用于调试）。同样，很多工具支持 <code>--quiet</code> 标志参数来抑制除错误提示之外的其他输出。</p></li>
<li><p>大多数工具中，使用 <code>-</code> 代替输入或者输出文件名意味着工具将从标准输入（standard input）获取所需内容，或者向标准输出（standard output）输出结果。</p></li>
<li><p>会造成破坏性结果的工具一般默认进行非递归的操作，但是支持使用“递归”（recursive）标志函数（通常是 <code>-r</code>）。</p></li>
<li><p>有的时候你可能需要向工具传入一个 <em>看上去</em> 像标志参数的普通参数，比如：</p>
<ul>
<li><p>使用 <code>rm</code> 删除一个叫 <code>-r</code> 的文件；</p></li>
<li><p>在通过一个程序运行另一个程序的时候（<code>ssh machine foo</code>），向内层的程序（<code>foo</code>）传递一个标志参数。</p>
<p>这时候你可以使用特殊参数 <code>--</code> 让某个程序 <em>停止处理</em> <code>--</code> 后面出现的标志参数以及选项（以 <code>-</code> 开头的内容）：</p></li>
<li><p><code>rm -- -r</code> 会让 <code>rm</code> 将 <code>-r</code> 当作文件名；</p></li>
<li><p><code>ssh machine --for-ssh -- foo --for-foo</code> 的 <code>--</code> 会让 <code>ssh</code> 知道 <code>--for-foo</code> 不是 <code>ssh</code> 的标志参数。</p></li>
</ul></li>
</ul>
<h2 id="代码调试">代码调试</h2>
<h3 id="事件分析">事件分析</h3>
<p>在我们使用<code>strace</code>调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p>
<p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）。下面是关于常见命令的简介：</p>
<ul>
<li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li>
<li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li>
<li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在<code>perf.data</code>中；</li>
<li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li>
</ul>
<h3 id="资源监控">资源监控</h3>
<p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。</p>
<ul>
<li><strong>通用监控</strong> - 最流行的工具要数 <a href="https://htop.dev/"><code>htop</code></a>,了，它是 <a href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a>的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、 <code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。 还可以留意一下 <a href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等；</li>
<li><strong>I/O 操作</strong> - <a href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li>
<li><strong>磁盘使用</strong> - <a href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a>是一个交互性更好的 <code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；</li>
<li><strong>内存使用</strong> - <a href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</li>
<li><strong>打开文件</strong> - <a href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a> 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</li>
<li><strong>网络连接和配置</strong> - <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 <a href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</li>
<li><strong>网络使用</strong> - <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对网络占用进行监控的交互式命令行工具。</li>
</ul>
<p>如果您希望测试一下这些工具，您可以使用 <a href="https://linux.die.net/man/1/stress"><code>stress</code></a> 命令来为系统人为地增加负载。</p>
<h2 id="qa">QA</h2>
<h3 id="source-script.sh-和-.script.sh-有什么区别"><code>source script.sh</code> 和 <code>./script.sh</code> 有什么区别?</h3>
<p>这两种情况 <code>script.sh</code> 都会在bash会话中被读取和执行，不同点在于哪个会话执行这个命令。 对于 <code>source</code> 命令来说，命令是在当前的bash会话中执行的，因此当 <code>source</code> 执行完毕，对当前环境的任何更改（例如更改目录或是定义函数）都会留存在当前会话中。 单独运行 <code>./script.sh</code> 时，当前的bash会话将启动新的bash会话（实例），并在新实例中运行命令 <code>script.sh</code>。 因此，如果 <code>script.sh</code> 更改目录，新的bash会话（实例）会更改目录，但是一旦退出并将控制权返回给父bash会话，父会话仍然留在先前的位置（不会有目录的更改）。 同样，如果 <code>script.sh</code> 定义了要在终端中访问的函数，需要用 <code>source</code> 命令在当前bash会话中定义这个函数。否则，如果你运行 <code>./script.sh</code>，只有新的bash会话（进程）才能执行定义的函数，而当前的shell不能。</p>
<h3 id="各种软件包和工具存储在哪里引用过程是怎样的-bin-或-lib-是什么">各种软件包和工具存储在哪里？引用过程是怎样的? <code>/bin</code> 或 <code>/lib</code> 是什么？</h3>
<p>根据你在命令行中运行的程序，这些包和工具会全部在 <code>PATH</code> 环境变量所列出的目录中查找到， 你可以使用 <code>which</code> 命令(或是 <code>type</code> 命令)来检查你的shell在哪里发现了特定的程序。 一般来说，特定种类的文件存储有一定的规范，<a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">文件系统，层次结构标准（Filesystem, Hierarchy Standard）</a>可以查到我们讨论内容的详细列表。</p>
<ul>
<li><code>/bin</code> - 基本命令二进制文件</li>
<li><code>/sbin</code> - 基本的系统二进制文件，通常是root运行的</li>
<li><code>/dev</code> - 设备文件，通常是硬件设备接口文件</li>
<li><code>/etc</code> - 主机特定的系统配置文件</li>
<li><code>/home</code> - 系统用户的主目录</li>
<li><code>/lib</code> - 系统软件通用库</li>
<li><code>/opt</code> - 可选的应用软件</li>
<li><code>/sys</code> - 包含系统的信息和配置(<a href="https://missing-semester-cn.github.io/2020/course-shell/">第一堂课</a>介绍的)</li>
<li><code>/tmp</code> - 临时文件( <code>/var/tmp</code> ) 通常重启时删除</li>
<li><code>/usr/</code> - 只读的用户数据
<ul>
<li><code>/usr/bin</code> - 非必须的命令二进制文件</li>
<li><code>/usr/sbin</code> - 非必须的系统二进制文件，通常是由root运行的</li>
<li><code>/usr/local/bin</code> - 用户编译程序的二进制文件</li>
</ul></li>
<li><code>/var</code> -变量文件 像日志或缓存</li>
<li><br />
</li>
</ul>
<h3 id="我应该用-apt-get-install-还是-pip-install-去下载软件包呢">我应该用 <code>apt-get install</code> 还是 <code>pip install</code> 去下载软件包呢?</h3>
<p>这个问题没有普遍的答案。这与使用系统程序包管理器还是特定语言的程序包管理器来安装软件这一更笼统的问题相关。需要考虑的几件事：</p>
<ul>
<li><p>常见的软件包都可以通过这两种方法获得，但是小众的软件包或较新的软件包可能不在系统程序包管理器中。在这种情况下，使用特定语言的程序包管理器是更好的选择。</p></li>
<li><p>同样，特定语言的程序包管理器相比系统程序包管理器有更多的最新版本的程序包。</p></li>
<li><p>当使用系统软件包管理器时，将在系统范围内安装库。如果出于开发目的需要不同版本的库，则系统软件包管理器可能不能满足你的需要。对于这种情况，大多数编程语言都提供了隔离或虚拟环境，因此你可以用特定语言的程序包管理器安装不同版本的库而不会发生冲突。对于 Python，可以使用 virtualenv，对于 Ruby，使用 RVM 。</p></li>
<li><p>根据操作系统和硬件架构，其中一些软件包可能会附带二进制文件或者软件包需要被编译。例如，在树莓派（Raspberry Pi）之类的ARM架构计算机中，在软件附带二进制文件和软件包需要被编译的情况下，使用系统包管理器比特定语言包管理器更好。这在很大程度上取决于你的特定设置。 你应该仅使用一种解决方案，而不同时使用两种方法，因为这可能会导致难以解决的冲突。我们的建议是尽可能使用特定语言的程序包管理器，并使用隔离的环境（例如 Python 的 virtualenv）以避免影响全局环境</p></li>
<li><h3 id="docker和虚拟机有什么区别">Docker和虚拟机有什么区别?</h3></li>
</ul>
<p>Docker 基于容器这个更为概括的概念。关于容器和虚拟机之间最大的不同是，虚拟机会执行整个的 OS 栈，包括内核（即使这个内核和主机内核相同）。与虚拟机不同，容器避免运行其他内核实例，而是与主机分享内核。在Linux环境中，有LXC机制来实现，并且这能使一系列分离的主机像是在使用自己的硬件启动程序，而实际上是共享主机的硬件和内核。因此容器的开销小于完整的虚拟机。</p>
<p>另一方面，容器的隔离性较弱而且只有在主机运行相同的内核时才能正常工作。例如，如果你在macOS 上运行 Docker，Docker 需要启动 Linux虚拟机去获取初始的 Linux内核，这样的开销仍然很大。最后，Docker 是容器的特定实现，它是为软件部署而定制的。基于这些，它有一些奇怪之处：例如，默认情况下，Docker 容器在重启之间不会有以任何形式的存储。</p>
<h3 id="还有更多的-vim-小窍门吗">还有更多的 Vim 小窍门吗？</h3>
<p>更多的窍门：</p>
<ul>
<li>插件 - 花时间去探索插件。有很多不错的插件修复了vim的缺陷或者增加了能够与现有vim工作流结合的新功能。关于这部分内容，资源是<a href="https://vimawesome.com/">VimAwesome</a> 和其他程序员的dotfiles。</li>
<li>标记 - 在vim里你可以使用 <code>m&lt;X&gt;</code> 为字母 <code>X</code> 做标记，之后你可以通过 <code>'&lt;X&gt;</code> 回到标记位置。这可以让你快速定位到文件内或文件间的特定位置。</li>
<li>导航 - <code>Ctrl+O</code> 和 <code>Ctrl+I</code> 命令可以使你在最近访问位置前后移动。</li>
<li>撤销树 - vim 有不错的更改跟踪机制，不同于其他的编辑器，vim存储变更树，因此即使你撤销后做了一些修改，你仍然可以通过撤销树的导航回到初始状态。一些插件比如 <a href="https://github.com/sjl/gundo.vim">gundo.vim</a> 和 <a href="https://github.com/mbbill/undotree">undotree</a> 通过图形化来展示撤销树。</li>
<li>时间撤销 - <code>:earlier</code> 和 <code>:later</code> 命令使得你可以用时间而非某一时刻的更改来定位文件。</li>
<li><a href="https://vim.fandom.com/wiki/Using_undo_branches#Persistent_undo">持续撤销</a> - 是一个默认未被开启的vim的内置功能，它在vim启动之间保存撤销历史，需要配置在 <code>.vimrc</code> 目录下的<code>undofile</code> 和 <code>undodir</code>，vim会保存每个文件的修改历史。</li>
<li>热键（Leader Key） - 热键是一个用于用户自定义配置命令的特殊按键。这种模式通常是按下后释放这个按键（通常是空格键）并与其他的按键组合去实现一个特殊的命令。插件也会用这些按键增加它们的功能，例如，插件UndoTree使用 <code>&lt;Leader&gt; U</code> 去打开撤销树。</li>
<li>高级文本对象 - 文本对象比如搜索也可以用vim命令构成。例如，<code>d/&lt;pattern&gt;</code> 会删除下一处匹配 pattern 的字符串，<code>cgn</code> 可以用于更改上次搜索的关键字。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>麻省理工</tag>
        <tag>北京大学</tag>
        <tag>linux</tag>
        <tag>编程工具</tag>
      </tags>
  </entry>
</search>
