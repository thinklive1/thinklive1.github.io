<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinklive1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#66CCFF","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="&#96;冯·诺依曼计算机特点 – 计算机由五大部件组成 • 输入数据和程序的“输入设备” • 记忆程序和数据的“存储器” • 完成数据加工处理的“运算器” • 控制程序执行的“控制器” • 输出处理结果的“输出设备”">
<meta property="og:type" content="article">
<meta property="og:title" content="基于苏大ppt的计算机硬件笔记">
<meta property="og:url" content="https://thinklive1.github.io/thinklive/33908/index.html">
<meta property="og:site_name" content="thinklive">
<meta property="og:description" content="&#96;冯·诺依曼计算机特点 – 计算机由五大部件组成 • 输入数据和程序的“输入设备” • 记忆程序和数据的“存储器” • 完成数据加工处理的“运算器” • 控制程序执行的“控制器” • 输出处理结果的“输出设备”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230531113546.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230531113559.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230531113735.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230531114156.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230603134629.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230610145852.png">
<meta property="article:published_time" content="2024-01-20T11:53:48.573Z">
<meta property="article:modified_time" content="2023-11-27T12:47:59.707Z">
<meta property="article:author" content="thinklive">
<meta property="article:tag" content="课程笔记">
<meta property="article:tag" content="苏州大学">
<meta property="article:tag" content="计算机组成">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thinklive1.github.io/images/obsidian/20230531113546.png">


<link rel="canonical" href="https://thinklive1.github.io/thinklive/33908/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://thinklive1.github.io/thinklive/33908/","path":"thinklive/33908/","title":"基于苏大ppt的计算机硬件笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>基于苏大ppt的计算机硬件笔记 | thinklive</title>
  







 <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
<script type="text/javascript" async src="/js/fairyDustCursor.js"></script>
<script type="text/javascript" async src="/js/tab-title.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="thinklive" type="application/atom+xml">
</head>
<script src="/js/tab-title.js"></script>
<script type="text/javascript" async src="/js/text.js"></script>

<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>



  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">thinklive</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">dirichlet library</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索 | search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页-|-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页 | home</a></li><li class="menu-item menu-item-标签-|-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags</a></li><li class="menu-item menu-item-分类-|-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories</a></li><li class="menu-item menu-item-归档-|-archive"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archive</a></li><li class="menu-item menu-item-相册-|-photo"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册 | photo</a></li><li class="menu-item menu-item-留言-|-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言 | guestbook</a></li><li class="menu-item menu-item-感谢-|-thank"><a href="/thanks/" rel="section"><i class="fa custom thanks fa-fw"></i>感谢 | thank</a></li><li class="menu-item menu-item-游戏-|-game"><a href="/game/bad1.html" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏 | game</a></li><li class="menu-item menu-item-神龛-|-shrine"><a href="/cyberblog/" rel="section"><i class="fa fa-microchip fa-fw"></i>神龛 | shrine</a></li><li class="menu-item menu-item-资源地图-|-resourcemap"><a href="/webstack/" rel="section"><i class="fa fa-list fa-fw"></i>资源地图 | resourcemap</a></li><li class="menu-item menu-item-思维导图-|-mindmap"><a href="/mindmap/index.html" rel="section"><i class="fa fa-map fa-fw"></i>思维导图 | mindmap</a></li><li class="menu-item menu-item-网站地图-|-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>网站地图 | sitemap</a></li><li class="menu-item menu-item-蒸汽-|-steam"><a href="/steamgames/index.html" rel="section"><i class="fa fa custum steam fa-fw"></i>蒸汽 | steam</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">


<!--网易云音乐插件-->
<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->
<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--网易云playlist外链地址-->   
<meting-js
    server="netease"
    type="playlist" 
    id="2762741085"
    mini="false"
    fixed="false"
    list-folded="true"
    autoplay="false"
    volume="0.2"
    theme="#4c4c4c"
    order="random"
    loop="all"
    preload="auto"
    lrc-type="2"
    mutex="true">
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#cisc%E5%92%8Crisc%E6%98%AFcpu%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">CISC和RISC是CPU的两种基本架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#risc%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">RISC特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">程序执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">寻址方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">8086&#x2F;8088微处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%98%9F%E5%88%97%E7%BC%93%E5%86%B2%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">指令队列缓冲器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="nav-number">2.2.</span> <span class="nav-text">寻址空间计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">编程结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">主存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E5%A4%84%E4%BA%8E%E4%B8%AD%E5%BF%83%E5%9C%B0%E4%BD%8D%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.1.</span> <span class="nav-text">主存储器处于中心地位的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%8C%87%E6%A0%87"><span class="nav-number">3.2.</span> <span class="nav-text">存储器的分类和指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">读写存储器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%BB%87"><span class="nav-number">4.</span> <span class="nav-text">8086&#x2F;8088存储器组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">指令格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-1"><span class="nav-number">6.1.</span> <span class="nav-text">寻址方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-number">7.</span> <span class="nav-text">通用数据传送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">8.</span> <span class="nav-text">目标地址传送类指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">9.</span> <span class="nav-text">算术运算类指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">10.</span> <span class="nav-text">逻辑运算类指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="nav-number">11.</span> <span class="nav-text">移位指令和循环移位指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-number">12.</span> <span class="nav-text">串操作指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">13.</span> <span class="nav-text">程序控制类指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-number">15.</span> <span class="nav-text">伪指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E7%BB%84%E6%88%90"><span class="nav-number">16.</span> <span class="nav-text">存储器的分类与组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B"><span class="nav-number">16.1.</span> <span class="nav-text">读写过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">16.2.</span> <span class="nav-text">只读存储器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95"><span class="nav-number">16.3.</span> <span class="nav-text">拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">16.4.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">16.5.</span> <span class="nav-text">外部存储器（辅助存储器</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="thinklive"
      src="/images/thive.png">
  <p class="site-author-name" itemprop="name">thinklive</p>
  <div class="site-description" itemprop="description">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinklive1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinklive1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/t469631989@gmail.com" title="E-Mail → t469631989@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/38099250?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;38099250?spm_id_from&#x3D;333.1007.0.0" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/thinklive" title="steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;thinklive" rel="noopener me" target="_blank"><i class="fa custom steam fa-fw"></i>steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div><div style="Text-align:center;width:100%"><div style="margin:0 auto"><canvas id="canvas" style="width:60%" height="100" width="700">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){function t(t,e){for(var a=0;a<l[e].length;a++)for(var n=0;n<l[e][a].length;n++)1==l[e][a][n]&&(h.beginPath(),h.arc(14*(g+2)*t+2*n*(g+1)+(g+1),2*a*(g+1)+(g+1),g,0,2*Math.PI),h.closePath(),h.fill())}function e(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a=[];a.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var r=c.length-1;r>=0;r--)a[r]!==c[r]&&t.push(r+"_"+(Number(c[r])+1)%10);for(var r=0;r<t.length;r++)n.apply(this,t[r].split("_"));c=a.concat()}function a(){for(var t=0;t<d.length;t++)d[t].stepY+=d[t].disY,d[t].x+=d[t].stepX,d[t].y+=d[t].stepY,(d[t].x>i+g||d[t].y>f+g)&&(d.splice(t,1),t--)}function n(t,e){for(var a=[1,2,3],n=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],r=0;r<l[e].length;r++)for(var o=0;o<l[e][r].length;o++)if(1==l[e][r][o]){var h={x:14*(g+2)*t+2*o*(g+1)+(g+1),y:2*r*(g+1)+(g+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*a[Math.floor(Math.random()*a.length)],color:n[Math.floor(Math.random()*n.length)],disY:1};d.push(h)}}function r(){o.height=100;for(var e=0;e<c.length;e++)t(e,c[e]);for(var e=0;e<d.length;e++)h.beginPath(),h.arc(d[e].x,d[e].y,g,0,2*Math.PI),h.fillStyle=d[e].color,h.closePath(),h.fill()}var l=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],o=document.getElementById("canvas");if(o.getContext){var h=o.getContext("2d"),f=100,i=700;o.height=f,o.width=i,h.fillStyle="#f00",h.fillRect(10,10,50,50);var c=[],d=[],g=o.height/20-1;!function(){var t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date);c.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6])}(),clearInterval(v);var v=setInterval(function(){e(),a(),r()},50)}}()</script></div>
<img src="/images/thinklive_cyber.png"; z-index: 0; style="max-width: 100%; width: auto; height: auto;background-color: #fff;">

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thinklive1.github.io/thinklive/33908/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/thive.png">
      <meta itemprop="name" content="thinklive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="thinklive">
      <meta itemprop="description" content="起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="基于苏大ppt的计算机硬件笔记 | thinklive">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于苏大ppt的计算机硬件笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-20 19:53:48" itemprop="dateCreated datePublished" datetime="2024-01-20T19:53:48+08:00">2024-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-27 20:47:59" itemprop="dateModified" datetime="2023-11-27T20:47:59+08:00">2023-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课程笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>44 分钟</span>
    </span>
</div>

        
        </div>
      </header>
   

    
    
    
    <div class="post-body" itemprop="articleBody"><p>`冯·诺依曼计算机特点<br />
– 计算机由五大部件组成<br />
• 输入数据和程序的“输入设备”<br />
• 记忆程序和数据的“存储器”<br />
• 完成数据加工处理的“运算器”<br />
• 控制程序执行的“控制器”<br />
• 输出处理结果的“输出设备”</p>
<span id="more"></span>
<p>– 指令和数据以同等地位存于存储器，可按地址寻访<br />
– 指令和数据用二进制表示<br />
– 指令由操作码和地址码组成<br />
– 以运算器为中心 基础逻辑电路：与门，非门，或门，异或门，与非门，或非门，同或门 半加器<br />
– 𝑆𝑖当前位， 𝐶𝑖进位符 全加器 （包括之前的进位cn-1） – 𝐹𝑛当前位， 𝐶𝑛进位符 𝐶𝑛 = 𝑋𝑛 ⋅ 𝑌𝑛 + 𝑋𝑛⨁𝑌𝑛 ⋅ 𝐶𝑛−1 <img src="/images/obsidian/20230531113546.png" title="image" alt="图片" /> <img src="/images/obsidian/20230531113559.png" title="image" alt="图片" /> <img src="/images/obsidian/20230531113735.png" title="image" alt="图片" /> CPU与外设之间的数据交换必须通过接口来完成，通常接口有<br />
以下一些功能：<br />
– 设置数据的寄存、缓冲逻辑，以适应CPU与外设之间的速度差异；<br />
– 进行信息格式的转换，例如串行和并行的转换；<br />
– 协调CPU和外设两者在信息的类型和电平的差异，如电平转换驱动器、<br />
数/模或模/数转换器等；<br />
– 协调时序差异；<br />
– 地址译码和设备选择功能；<br />
– 设置中断和DMA（直接存储器存取）控制逻辑，以保证在中断和DMA<br />
允许的情况下产生中断和DMA请求信号，并在接受到中断和DMA应答<br />
之后完成中断处理和DMA传输。 `为何要用二进制表示（冯.诺依曼核心）<br />
– 无法制造多个稳定状态的物理器件<br />
– 编码、计数、运算规则简单<br />
– 和逻辑的真、假对应，通过逻辑门电路可实现算数运算 BCD码<br />
– 机器中用4位二进制对每个十进制数位进行编码方法<br />
– 4位二进制有16种组合，选取其中的十个。<br />
– 常用的方法有：8421码、余3码、格雷码</p>
<p>为什么要用BCD码<br />
– 高精确度的计算<br />
– 耗费更多的存储空间 <code>数的定点与浮点表示   – 十进制的公式表示：𝑁 = 10𝐸 ∗ 𝑆   – 二进制数的公式表示：𝑁 = 2𝐸 ∗ 𝑆   • 定点数：阶码𝐸位置固定，存储时统一忽略阶码   – 定点整数: 𝐸 = 0， 𝑆为纯整数，小数点固定在数值部分的右边   – 定点小数: 𝐸 = 0， 𝑆为纯小数，小数点固定在数值部分的左边</code>浮点数详解<br />
– 浮点数的表示范围<br />
• 阶码E的范围：−128 ≤ 𝑒 &lt; 127<br />
• 最大正数：0.111 ... 1 × 2011...1 = (1 − 2^−23) × 2^127<br />
• 最小正数：0.100 ... 0 × 2100...0 = 1<br />
2 × 2−128 = 2−129<br />
– 浮点数的表示精度<br />
• 总位数不变<br />
– 阶码越大：数值表示范围越大<br />
– 尾数越少：精度变低 <img src="/images/obsidian/20230531114156.png" title="image" alt="图片" /> 机器数的表示形式：原码、反码、补码<br />
– 原码：符号+真值<br />
• +41 原 = 0 0101001， −41 原 = 1 0101001<br />
• +0 原 = 0 0000000， −0 原 = 1 0000000<br />
– 反码：正数不变，负数时符号不变，其他各位取反<br />
• +41 反 = 0 0101001， −41 反 = 1 1010110<br />
• +0 反 = 0 0000000， −0 反 = 1 1111111<br />
– 补码：正数不变，负数为反码+1（计算机表示带符号数的方法）<br />
• +41 补 = 0 0101001， −41 补 = 1 1010111<br />
• +0 补 = 0 0000000， −0 补 = 0 0000000<br />
• +127 补 = 0 1111111， −127 补 = 1 0000001<br />
• −128 补 = 1 0000000 `溢出<br />
– 运算结果超出机器数所能表示的范围时，称为溢出<br />
– 定点数溢出的判断方法<br />
• 两个同符号的数相加，得到的和的符号与相加数的符号不一致。<br />
– 采用双符号位：正数的符号位为00，负数的符号位为11。符号位参加运算。如果<br />
两个符号位不相同，则溢出。（浪费资源）<br />
• 任意两数相加，如果数值最高位的进位不等于符号位的进位，则溢出。<br />
– 浮点数溢出的判断方法<br />
• 看阶码是否溢出！</p>
<p>BCD码：用四位二进制数表达一个十进制数，方便运算和显示 浮点数：尾数S和阶码E 符号+阶码+符号+尾数 反码：正数不变，负数除了符号位取反 补码：正数不变，负数除了符号位加一 +0：00000000 -128:10000000 [x+y]补=[x]补+[y]补 [x-y]补=[x]补+[-y]补</p>
<p>有效地址EA=基址（BX/BP）+变址值(SI/DI)+位移量DISP +段基址=物理地址</p>
<h2 id="cisc和risc是cpu的两种基本架构">CISC和RISC是CPU的两种基本架构</h2>
<p>– CISC：寻址方式多，方便编程<br />
– RISC：寻址方式少，指令短、规整</p>
<h3 id="risc特点">RISC特点</h3>
<p>– 指令系统<br />
• RISC指令长度相同；寻址方式少；指令执行时间相当<br />
– RISC CPU内部寄存器多<br />
– 存储器操作<br />
• 只有取数/存数指令访问存储器，大部分指令都在寄存器之间进行<br />
– 代码量增多，实现特殊功能时程序复杂<br />
– 较少的单元电路，面积小，功耗低<br />
– 结构简单，设计周期短</p>
<h3 id="程序执行过程">程序执行过程</h3>
<p>– PC发起地址查询<br />
– 内存依据地址返回指令/数据<br />
– CPU进行指令解析<br />
– PC增量或PC赋值<br />
• 指令结构<br />
– 操作码+地址码（操作数所在地）</p>
<h3 id="寻址方式">寻址方式</h3>
<ul>
<li>立即数寻址（办理人随身携带）<br />
– 操作数由指令的地址码部分直接给出来<br />
• 操作码+操作数<br />
</li>
<li>寄存器直接寻址（办理人已寄存）<br />
– 指令地址码部分给出某一通用寄存器地址<br />
– 从寄存器存取数据比主存快得多<br />
– 由于寄存器的数量较少，其地址码字段短</li>
<li>直接寻址（办理人在队伍里）<br />
– 指令中地址码字段给出操作数的地址<br />
• PC赋值——取操作数</li>
<li>间接寻址（办理人在哪问家长）<br />
– 指令中给出的地址是存放操作数地址的地址<br />
– 寄存器间接寻址（家长已寄存）<br />
– 存储器间接寻址（家长在队伍里）</li>
<li>偏移寻址（相对寻址）<br />
– 从我往后数A个<br />
– EA：有效地址 – 相对寻址： EA=A+(PC) 相对于当前指令处位移量为A的单元<br />
– 基址寻址： EA=A+(B) 相对于基址(B)处位移量为A的单元<br />
– 变址寻址： EA=A+(I) 相对于首址A处位移量为(I)的单元</li>
</ul>
<h2 id="微处理器">8086/8088微处理器</h2>
<h3 id="指令队列缓冲器">指令队列缓冲器</h3>
<p>– 取指令时，每当指令队列缓冲区满一条指令，EU立即开始执行<br />
– 当指令队列中有2个空字节（8088一个）BIU自动去取指<br />
– EU从指令队列中去取指，然后执行指令，当该指令需要内存或<br />
I/O访问，EU请求BIU进入总线周期完成访问：<br />
• BIU空闲状态：立即响应<br />
• 正在取指：取指完后响应<br />
– 指令队列已满，EU没有对BIU有请求，BIU进入空闲状态<br />
– 执行转移、调用、返回指令：指令队列中的内容（原顺序指令）<br />
被清除，BIU去取EU所指示的新的程序段指令</p>
<h3 id="寻址空间计算">寻址空间计算</h3>
<p>– 8位机寻址：8根地址线<br />
• 地址范围：0~255<br />
• 最大内存空间：28 = 256Byte<br />
– 16位机：216 = 64KB<br />
– 32位机：232 = 4GB<br />
– 64位机：264 = 16EB</p>
<h3 id="编程结构">编程结构</h3>
<p><img src="/images/obsidian/20230603134629.png" title="image" alt="图片" /> – 4个通用寄存器(16位)<br />
• AX、BX、CX、DX（可8位单独使用）<br />
– 4个专用寄存器(16位)<br />
• BP（Base Pointer）基数指针<br />
• SP（Stack Pointer）堆栈指针<br />
• SI（Source Index）源变址<br />
• DI（Destination Index）目的变址<br />
– 4个段寄存器（16位）<br />
• CS（Code Segment）代码段寄存器<br />
• DS（Data Segment）数据段寄存器<br />
• SS（Stack Segment）堆栈段寄存器<br />
• ES（Extra Segment）扩展段寄存器 – CS用来存放程序当前使用的代码段的段地址，CPU执行的指令<br />
将从代码段取得<br />
• CS:IP构成传统意义的PC<br />
– SS用来存放堆栈段的段地址，堆栈操作的数据就在堆栈段中<br />
• 通常SS:SP和SS:BP构成堆栈段的访问<br />
– DS用来存放数据段的段地址，一般地说，程序所用的数据就存<br />
放在数据段中<br />
• 通常DS:XX（通用寄存器）构成对数据段的访问；<br />
– ES用来存放附加段的段地址，也用来存放数据，但典型用法是<br />
存放处理后的数据</p>
<h2 id="主存储器">主存储器</h2>
<h3 id="主存储器处于中心地位的原因">主存储器处于中心地位的原因</h3>
<p>• 当前计算机正在执行的程序和数据均存放在存储器中，<br />
CPU直接从存储器取指令或数据；<br />
• 输入输出设备增多，数据传输速度加快，因此采用了<br />
DMA(直接存储器存取)技术和输入/输出通道技术，<br />
在存储器与输入/输出系统之间直接传送数据；<br />
• 共享存储器的多处理机的出现，利用存储器存放共享<br />
数据，并实现处理机之间的通信。</p>
<h3 id="存储器的分类和指标">存储器的分类和指标</h3>
<p>随机存储器（random access memory，RAM）<br />
• 又称读写存储器，指通过指令可以随机地、个别地对<br />
各个存储单元进行访问（读写）的存储器<br />
• 访问所需时间基本固定，与存储单元地址无关<br />
• 停电会造成信号丢失<br />
非易失性存储器<br />
• 停电仍能保持其内容 <code>容量 • 计算机可寻址的最小单位是一个存储字，一个存储字   所包括的二进制位数称为字长   • 一个字节（Byte）为8个二进制位（bit），一个字可   以由若干字节组成，一个字的字长通常是8的倍数。   • 主存储器的容量：以字或字节为单位来表示主存储器   存储单元的总数   • 单位：B、KB、MB、GB、 TB、PB、EB、ZB...   • 指令中地址码的位数决定了主存储器的可直接寻址的   最大空间   • 32位微型机提供32位物理地址，支持对4G字节的物理主存   空间的访问</code>存储器存取时间(Memory Access Time)<br />
• 又称存储器访问时间<br />
• 启动一次存储器操作到完成该操作所经历的时间。<br />
`存储周期(Memory Cycle Time)<br />
• 连续启动两次独立的存储器操作(例如连续两次读操<br />
作)所需间隔的最小时间 • 主存储器和CPU是由总线连接的。CPU通过使<br />
用AR（地址寄存器）和DR（数据寄存器）个<br />
主存储器进行数据传送。若AR为K位字长，<br />
DR为n位字长，则允许主存包含2^k个可寻址<br />
字节或字。<br />
• 在一个周期内，CPU和主存储器之间进行n位<br />
数据传送。 读操作：存储器→CPU<br />
• CPU把信息字的地址送到<br />
AR,经地址总线送往主存<br />
储器<br />
• CPU通过控制总线发读<br />
(Read)命令<br />
• CPU等待主存储器的<br />
Ready回答信号，Ready<br />
为 1，表示信息已读出经<br />
数据总线,送入DR。<br />
AR：地址寄存器<br />
DR：数码寄存器<br />
主存储器的基本操作</p>
<p>• 写操作：CPU→存储器<br />
• CPU把信息字的地址送<br />
到AR，经地址总线送往<br />
主存储器,并将信息字送<br />
往DR<br />
• CPU通过控制总线发写<br />
(Write)命令<br />
• CPU等待主存储器的<br />
Ready回答信号，Ready<br />
为 1，表示信息已从DR<br />
经数据总线写入主存储<br />
器</p>
<h3 id="读写存储器">读写存储器</h3>
<p>按存储元件在运行中能否长时间保存信息分为静<br />
态存储器SRAM和动态存储器DRAM两种<br />
• 静态存储器：利用双稳态触发器来保存信息，只<br />
要不断电，信息就不会丢失<br />
• 动态存储器：利用MOS电容存储电荷来保存信<br />
息，使用时需不断给电容充电才能使信息保持<br />
• 静态存储器的集成度低，功耗较大；动态存储器<br />
的集成度高，功耗小，主要用于大容量存储器 • DRAM每片容量大，引脚少; 价格低; 功耗低; 但<br />
速度低，须再生。 DRAM一般用作计算机的主<br />
存储器。<br />
• SRAM速度快，价格较高，一般用作容量不大的<br />
高速存储器。 DRAM和SRAM是可任意读写的随机存储器，当发生掉电时，存储的<br />
内容容易立即消失，属于易失性存储器。<br />
非易失性存储器，即使掉电，内容也不会消失：<br />
只读存储器(ROM)<br />
• 掩膜式ROM，由芯片制造商在制造时写入内容，以后只能读不能写<br />
可编程序的只读存储器(PROM)<br />
• 用户根据自己需要确定ROM的内容；<br />
• 有熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元<br />
的熔丝(写入)。<br />
可擦除可编程序的只读存储器(EPROM)<br />
• 产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线<br />
照射后,浮置栅上的电子将逸散,即整体擦除。<br />
可用电擦除的可编程序的只读存储器(E2PROM)<br />
• 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写<br />
入周期要几毫秒,寿命为10万次。<br />
闪速存储器(Flash Memory)<br />
• 用电擦除,但只能整体擦除或分区擦除。</p>
<h2 id="存储器组织">8086/8088存储器组织</h2>
<p>存储器分段<br />
– 为什么分段<br />
• 地址寄存器均为16位： 216 = 64KB<br />
– 分段方便操作系统进行存储管理<br />
– 如何分段<br />
• 8086地址空间为20位=1MB，地址为5位16进制数：00000H~FFFFFH<br />
– 从偏移地址考虑，理论上最多16个不重叠的地址段<br />
– 从段地址考虑，最多可以定义216个不同段<br />
– 段重叠<br />
• 段区分配通常由操作系统完成<br />
– CS、DS、SS、ES存储与程序相关的段基址<br />
– IP、SP、BP、SI、DI存储与程序相关的偏移地址 逻辑地址和物理地址<br />
– 逻辑地址<br />
• 程序和指令表示的一种地址<br />
• 包括两部分：段地址和偏移地址<br />
– 物理地址<br />
• 段地址*\16+偏移地址=物理地址<br />
– 寻址操作根据操作系统默认规则完成 堆栈（段）<br />
– 机制<br />
• 栈顶为唯一出入口<br />
– 地址较小的一端<br />
• 后进先出原则<br />
– 作用<br />
• 数据暂存<br />
• 保留轨迹 段加偏移”寻址机制允许重定位<br />
– 重定位是指一个完整的程序块或数据块可以在存储器所允许的空<br />
间内任意浮动，并定位到一个新的可寻址的区域<br />
– 允许程序和数据不需要做任何修改</p>
<h2 id="小结">小结</h2>
<p>• 微处理器的设计有CISC与RISC两种基本架构。深入理解16位微处理器8086的内部结构<br />
及其工作原理，是掌握微机工作原理的基础和关键。Intel系列高档微处理器内部的复杂<br />
结构及其工作原理，都是在8086CPU的结构基础上逐步分解结构和细化流水线操作而发<br />
展起来的。透彻地掌握8086CPU的基础，将有利于理解高档微处理器的技术发展。<br />
• 8086/8088 CPU的内部结构由总线接口单元BIU和执行单元EU两部分组成。其内部有3<br />
组共14个寄存器，必须了解它们各自的功能，并能掌握它们的使用方法。<br />
• 总线周期是理解CPU按时序工作的重要概念。8086/8088 CPU一个最基本的总线周期由<br />
4个时钟周期组成，简称为4个状态，即T1、T2、T3与T4这4个状态。<br />
• 微处理器的引脚及其功能是其重要的外部特性。由于8086／8088 CPU只有40条引脚，<br />
学习和掌握它们的功能相对于高档微处理器说来就比较简单。</p>
<p>CF - 进位标志(Carry Flag),表示上一条指令的运算是否产生进位。如果产生进位,CF为1,否则为0。OF - 溢出标志(Overflow Flag),表示上一条指令的结果是否越界。如果结果超出目的操作数可以表示的范围,OF为1,否则为0。 SF - 符号标志(Sign Flag),表示上一条指令运算结果的符号。如果结果为负数,SF为1,如果为正数,SF为0。 ZF - 零标志(Zero Flag),表示上一条指令的运算结果是否为0。如果结果为0,ZF为1,否则为0。</p>
<h2 id="指令格式">指令格式</h2>
<p>计算机是通过指令来处理各种数据，为指出数据的来源、<br />
操作结果的去向及执行何操作，一条指令必须包含以下信<br />
息：<br />
– (1) 操作码——位数及位置。<br />
– (2) 操作数的地址——操作数的个数<br />
– (3) 操作结果的存储地址。<br />
– (4) 下一条指令的地址 <code>指令长度   – 可以等于机器字长，也可以大于或小于机器字长。   • 尽可能短   • 等于字节的整数倍。   – 若所有指令的长度都是相等的，称为定长指令字结构   • RISC指令大多采用定长指令结构   – 若各种指令的长度随指令功能而异，</code>操作码<br />
– 操作码的位数取决于计算机指令系统的规模<br />
– 定长编码和变长编码 变长编码：分散地放在指令字的不同字段中，如INTEL 8086/Pentium<br />
– 优点：能表示更多的指令<br />
– 缺点：增加了译码难度，控制器复杂 <code>指令涉及的数据类型   – 地址：无符号数，一般是加减操作（含移位）   • 8、16或32位   – 数值数据   • 定点数（整数）：补码表示   – 16位、32位、64位   • 浮点数（实数）：IEEE754标准   – 位、位串、字符与字符串   • 用来表示文本、声音和图像等   • 字节、字(16位)、双字(32位)、四字(64位)   – 现代32位计算机通常以32位为一个字：字节、半字(16位)、字(32位)、双字(64位)   – 逻辑数据   • 按位操作（0-假/非0-真）</code>数据寻址方式<br />
– 有效地址EA（Effective Address）=基址值（BX或BP）+变址<br />
值（SI或DI）+位移量DISP<br />
• +段基址=物理地址<br />
– 根据命令判断字段长短<br />
• 通常由寄存器长度决定</p>
<h3 id="寻址方式-1">寻址方式</h3>
<ul>
<li>立即寻址</li>
<li>寄存器寻址</li>
<li>直接数据寻址</li>
<li>寄存器间接寻址（间接寻址目标为存储器，故不能确定目标位置长度）</li>
<li>基址加变址寻址</li>
<li>寄存器相对寻址</li>
<li>相对基址加变址寻址(带DISP的基址加变址寻址) 程序存储器寻址方式<br />
– 实现程序转移<br />
• 条件转移<br />
– 段内短转移（-128~+127）<br />
• JMP<br />
– 段内/段间，直接/间接寻址<br />
• CALL<br />
– 段内/段间，直接/间接寻址<br />
• 中断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">其他寻址方式  </span><br><span class="line">– 串操作指令寻址方式  </span><br><span class="line">• 操作类别：清0、复制、比较等  </span><br><span class="line">• 源数据地址：DS:SI  </span><br><span class="line">• 目标数据地址：ES:DI  </span><br><span class="line">– I/O端口寻址方式  </span><br><span class="line">• 直接端口寻址  </span><br><span class="line">– IN AL, n OUT n, AL  </span><br><span class="line">– 端口号：0～255  </span><br><span class="line">• 间接端口寻址  </span><br><span class="line">– IN AL, DX OUT DX, AL  </span><br><span class="line">– 端口号：0～65535</span><br></pre></td></tr></table></figure>
<h2 id="通用数据传送">通用数据传送</h2>
<p>//CS - Code Segment,代码段寄存器。它保存代码段的起始地址,用于查找程序的指令。IP - Instruction Pointer,指令指针寄存器。它保存下条指令的地址,用于告诉CPU去哪里找到下一条要执行的指令。 1、基本传送指令 MOV（Move）：传送<br />
– 一般形式：MOV dest, src<br />
• dest  src，将源操作数src复制到目的操作数dest，src不变 2、堆栈操作<br />
– PUSH src<br />
– POP dest<br />
– LIFO后进先出<br />
– 堆栈操作按字进行<br />
– 不能POP CS 3、XCHG（Exchange）：交换<br />
– 一般形式：<br />
• XCHG oprd1, oprd2 ;交换oprd1与oprd2的内容<br />
– 语法格式：<br />
• XCHG reg/mem, reg/mem 4.字节翻译指令XLAT（代码转换或查表指令）<br />
– BX 基址：代码转换表首地址（表大小：0~255）<br />
– AL 偏移（码值） MOV BX,0030H<br />
MOV AL,5<br />
XLAT</p>
<h2 id="目标地址传送类指令">目标地址传送类指令</h2>
<p><code>LEA（Load Effective Address）装入有效地址   – 语法格式：LEA reg16, mem ;reg16 = mem的有效地址   – 通常用于建立串操作   – 对标志位的影响：无。   – 【例】设BX = 5678H   • LEA SI, 2\[BX]   ;执行后，SI = 567AH 将计算结果放入BX寄存器,而不会访问那个地址的值</code>LDS reg16, mem<br />
– 定位串操作源地址<br />
– LDS SI, [DI+100AH]<br />
– 低16位存入reg16，高16位存入DS<br />
<code>LES reg16, mem   – 定位串操作目标地址   – 同上，高16位存入ES</code>LAHF、SAHF（保存和设置标志位）<br />
– 与AH寄存器交互<br />
– SF：符号标志：运算结果符号位<br />
– ZF：零标志：运算结果是否为0<br />
– AF：辅助进位标志：低四位是否向高四位进位<br />
– PF：奇偶标志：是否有偶数个1<br />
– CF：进位标志：是否进位/借位</p>
<h2 id="算术运算类指令">算术运算类指令</h2>
<p>加法<br />
– 一般形式：<br />
• ADD dest, src ; dest  dest + src<br />
• ADC dest, src ; dest  dest + src + CF<br />
• INC oprd ;oprd  oprd + 1<br />
– 语法格式：<br />
• ADD reg/mem, reg/mem/imm<br />
• ADC reg/mem, reg/mem/imm<br />
• INC reg/mem<br />
– 对标志位的影响：<br />
• ADD、ADC：按一般规则影响CF、OF、SF和ZF<br />
• INC：不影响CF，其它同ADD<br />
• ADD与ADC的2个操作数必须类型匹配，且不能同时是内存操作数 减法<br />
– 一般形式：<br />
• SUB dest, src ; dest  dest - src<br />
• SBB dest, src ; dest  dest - src - CF<br />
• CMP oprd1, oprd2 ; oprd1 - oprd2<br />
– 与SUB的区别在于，不将减法结果存入dest，只影响标志位<br />
• DEC oprd ; oprd  oprd - 1<br />
• NEG oprd ; oprd  0 – oprd = oprd + 1<br />
– 语法格式：<br />
• SUB reg/mem, reg/mem/imm<br />
• SBB reg/mem, reg/mem/imm<br />
• CMP reg/mem, reg/mem/imm<br />
• DEC reg/mem<br />
• NEG reg/mem SUB、SBB、CMP：影响CF、OF、SF、ZF、AF和PF<br />
• DEC：不影响CF，其它同SUB<br />
• SUB与SBB的2个操作数必须类型匹配，且不能同时是内存操作数 乘法<br />
<code>– MUL（Unsigned Multiplication）：无符号乘法   – 一般形式：   • MUL src   – 语法格式：   • MUL reg8/mem8 ; AX = AL × src   • MUL reg16/mem16 ; DX:AX = AX × src   • 对标志位的影响：若8位×8位、16位×16位的结果分别能由8、16位容   纳（即结果的高一半为0），则CF = OF = 0，否则，CF = OF = 1；其   余标志无定义。   • 由于2个n位数的乘积可能需要2n位，因此，若操作数是8位，则结果为   16位；同样，16位操作数相乘结果为32位（80386中32位数相乘结果   为64位）。</code>IMUL（Integer Multiplication）：带符号乘法<br />
– 一般形式：<br />
• IMUL src<br />
– 语法格式：<br />
• IMUL reg8/mem8 ; AX = AL × src<br />
• IMUL reg16/mem16 ; DX:AX = AX × src<br />
• 对标志位的影响：若结果的高一半为低一半的符号扩展，则CF = OF =<br />
0，否则，CF = OF = 1；其余标志无定义<br />
– 【例】对于同一个二进制数，采用 MUL与IMUL执行的结果可能<br />
不同。设AL = 0FFH，BL = 1，分别执行下列指令，会得出不同<br />
结果。<br />
• MUL BL ; AX = 00ffh（255D）<br />
• IMUL BL ; AX = 0ffffh（-1D） 除法<br />
– 一般形式：<br />
• DIV src ; 无符号数除法<br />
• IDIV src ; 带符号数除法<br />
– 语法格式：<br />
• DIV reg/mem<br />
• IDIV reg/mem<br />
– 功能描述：<br />
• src是8位：AX÷src，结果商在AL、余数在AH<br />
• src是16位：DX:AX÷src，结果商在AX、余数在DX<br />
– 对标志位的影响：无定义<br />
– 若是8位÷8位或16位÷16位怎么解决？</p>
<p>符号扩展<br />
– 对标志位的影响：无<br />
– CBW、CWD（Convert Byte/Word to Word/Double word）<br />
– 语法格式：<br />
• CBW ; AL符号扩展为AX<br />
– (若AL为正数,则零扩展,若AL为负数,则扩展部分全1)<br />
• CWD ; AX符号扩展为32位数DX:AX<br />
– 【例】设AL = 0FEH，给出依次执行下列指令后的结果。<br />
• CBW ; ax = fffeh<br />
• CWD ; dx = ffffh, ax不变，即dx:ax = -2<br />
• 十进制调整指令（不要求）<br />
– BCD码的加减乘除</p>
<h2 id="逻辑运算类指令">逻辑运算类指令</h2>
<p>AND reg/mem, reg/mem/imm<br />
– OR reg/mem, reg/mem/imm<br />
– XOR reg/mem, reg/mem/imm<br />
– NOT reg/mem<br />
– TEST reg/mem, reg/mem/imm；执行AND操作但不存储<br />
结果<br />
• 对标志位的影响：<br />
– NOT：无。<br />
– 其它指令：CF = OF = 0，按一般规则影响SF和ZF `使某位变反，其余位保持不变：对应位异或1，其余位为0<br />
• 例： XOR AL, 60H ; 使第5、6两位为原来码的反码<br />
• 特例： XOR AL, 0FFH = NOT AL</p>
<h2 id="移位指令和循环移位指令">移位指令和循环移位指令</h2>
<p>一般形式：<br />
– SHL dest, count ; dest逻辑左移，count为移位次数<br />
– SAL dest, count ; dest算术左移<br />
– SHR dest, count ; dest逻辑右移<br />
– SAR dest, count ; dest算术右移<br />
– ROL, ROR循环左/右移；RCL, RCR带进位标志循环左/右移 对标志位的影响：<br />
– 移位次数为1时，若移位后符号位发生了变化，则OF = 1，否则<br />
OF = 0；若移位次数 &gt; 1，则OF无定义<br />
– 按一般规则影响ZF与SF。然而，若移位次数为0，则不影响标志<br />
位；CF为最后移入位<br />
• 参数规范：当count = 1时，可以立即数输入，否则需先<br />
存入CL中；count取值范围0~255<br />
• 【例】设AX的值为一个2字节非压缩BCD码，将其转换为<br />
1字节压缩BCD码存入AL。<br />
MOV CL, 4<br />
SHL AH, CL ; ah低4位移到高4位<br />
AND AL , 0FH ; al高4位清0<br />
OR AL , AH</p>
<h2 id="串操作指令">串操作指令</h2>
<p>目标和源都是存储器 (字、字节)<br />
– DS:SI 提供源，ES:DI提供目的，CX提供长度<br />
• 种类<br />
– MOVS（Move）传送<br />
– CMPS（Compare）比较<br />
– SCAS（Scan）搜索<br />
– LODS（Load）读<br />
– STOS（Store）写<br />
• 方向（DF标志位）<br />
• 重复前缀<br />
– REP（Repeat）<br />
– REPE/REPZ<br />
– REPNE/REPNZ</p>
<h2 id="程序控制类指令">程序控制类指令</h2>
<p>无条件转移JMP（Jump）<br />
• 一般形式：<br />
– JMP target ; 转移到target指定的目标地址处<br />
– 根据转移的距离，JMP指令可分为下列两类：<br />
• 段内转移：在同一代码段内进行，又称近（Near）转移，只要修改IP的<br />
值即可实现<br />
• 段间转移：可在不同代码段之间进行，又称远（Far）转移，需要同时<br />
修改CS和IP的值<br />
– 根据目标地址的指定方式，JMP指令又可分为直接转移和间接转<br />
移<br />
• 直接转移：是指转移的目标地址直接出现在指令中，在程序执行前就已<br />
确定<br />
• 间接转移：指转移的目标地址是寄存器或内存操作数的值，只有执行到<br />
该条指令时才能确定 – 直接转移<br />
• JMP [NEAR PTR] label ; 段内转移<br />
– 目标地址 = IP + label（2字节） ; ±32KB<br />
例：JMP ADDR1 ; ADDR1代表一个段内目标地址<br />
ADDR1与当前IP位移量1235H, CS=1500H, IP=2400H<br />
目的地址：18638H JMP SHORT label<br />
– 目标地址 = IP + label（1字节） ; -128~127<br />
• JMP FAR PTR label ; 段间转移<br />
– 间接转移<br />
• JMP reg16/WORD PTR mem<br />
; IP = reg16/mem16 段内间接转移<br />
例：JMP FAR PTR ADDR2 ; ADDR2代表一个段间目标地址<br />
ADDR2所在CS=6500H，IP=020CH<br />
目的地址：6520CH<br />
例：JMP BX ；BX→IP，CS不变<br />
JMP WORD PTR [DI] ；[DS:DI] →IP，CS不变 JMP DWORD PTR mem<br />
– ; CS = [mem+2]，IP = [mem]<br />
例：当前CS=1000H, IP=026AH<br />
DS=2000H, BX=1400H, ADDR3=020AH<br />
JMP DWORD PTR [BX+ADDR3]<br />
CS=4000H, IP=320EH • CALL过程名<br />
– CALL NEAR PROC 段内直接寻址（修改IP, CS不变）<br />
– CALL BX 段内间接转移（BX → IP）<br />
– CALL FAR PROC 段间直接调用<br />
• IP、CS都改变，例如：CALL 2000H:5600H<br />
• 返回地址入栈包括CS和IP<br />
– CALL DWORD PTR [reg16] 段间间接调用<br />
• 低字 → IP，高字 → CS<br />
– CALL与JMP区别<br />
• CALL调用时会将修改前IP（或IP与CS）入栈，且完成后会返回当前位置<br />
• RET<br />
– 要和CALL调用类型对应：RET（段内）与RETF（段间）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例】求AX累加器和BX累加器中两个无符号数之差的绝  </span><br><span class="line">对值，结果放在2800H单元中  </span><br><span class="line">CMP AX, BX  </span><br><span class="line">JB AA  </span><br><span class="line">SUB AX, BX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], AX  </span><br><span class="line">JMP STOP ;该句缺少怎样？  </span><br><span class="line">AA: SUB BX, AX  </span><br><span class="line">MOV DI, 2800H  </span><br><span class="line">MOV [DI], BX  </span><br><span class="line">STOP： HLT</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【例】从外设71H中取一个数M,判断其值是否在10和20之  </span><br><span class="line">间，如果M≥20，则送0FFH给外设73H;如果M&lt;10,则送  </span><br><span class="line">00H给外设73H;如果10≤M&lt;20,则送88H给外设73H  </span><br><span class="line">IN AL, 71H  </span><br><span class="line">CMP AL, 10  </span><br><span class="line">JNC LP1  </span><br><span class="line">MOV AL, 00H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP1: CMP AL, 20  </span><br><span class="line">JNC LP2  </span><br><span class="line">MOV AL, 88H  </span><br><span class="line">JMP LP3  </span><br><span class="line">LP2: MOV AL, 0FFH  </span><br><span class="line">LP3: OUT 73H, AL  </span><br><span class="line">HLT</span><br></pre></td></tr></table></figure>
<p>循环控制（短地址区间）<br />
– LOOP 目标地址<br />
• CX-1,如CX≠0,转移到目标地址（负值）<br />
– LOOPE/LOOPZ 目标地址<br />
• CX-1,如ZF=1且CX≠0循环（LOOPNE/LOOPNZ时ZF=0）</p>
<figure class="highlight plaintext"><figcaption><span>【例】求2个数组之和，每个数组长度为N。如遇到2个组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数元素都为0，则停止求和  </span><br><span class="line">MOV SI, -1  </span><br><span class="line">MOV CX, N  </span><br><span class="line">NEXT: INC SI  </span><br><span class="line">MOV AL, [ADDR1 + SI]  </span><br><span class="line">ADD AL, [SI + ADDR2]  </span><br><span class="line">MOV [SI + ADDR3], AL  </span><br><span class="line">LOOPNZ NEXT</span><br></pre></td></tr></table></figure>
<p>中断指令<br />
– INT 中断类型<br />
• 0-255<br />
• 中断向量表<br />
– 每种中断占4个字节<br />
» 前两个为偏移地址，后两个为段地址<br />
– 和CALL的区别<br />
• 相同点：断点入栈<br />
• 不同点<br />
– 清除中断标志IF<br />
– 清除单步标志TF<br />
– 标志寄存器入栈<br />
• 【例】 INT 20H<br />
– IRET<br />
– INTO 溢出中断（中断号04H）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">延时一秒</span><br><span class="line">START: MOV CX, 1000  </span><br><span class="line">DELAY1S: CALL DELAY1MS  </span><br><span class="line">LOOP DELAY1S  </span><br><span class="line">HLT  </span><br><span class="line">DELAY1MS: PUSH CX  </span><br><span class="line">MOV CX, 374  </span><br><span class="line">LP1: PUSHF  </span><br><span class="line">POPF  </span><br><span class="line">LOOP LP1  </span><br><span class="line">POP CX  </span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<h2 id="类型">类型</h2>
<p><code>汇编流程   – 汇编源程序：用助记符指令、变量名和标号编写的程序。   • 文件名：\*\*\*.ASM   – 目标程序：机器能识别的二进制代码程序。   • 文件名：\*\*\*.OBJ   – 执行程序：为PC系统所接受的应用程序。   • 文件名：\*\*\*.EXE   • 工具程序   –</code> 汇编程序：把汇编源程序翻译成机器能识别的机器指令程序的工<br />
<code>具程序。   • 文件名：MASM.EXE   – 连接程序：把目标文件与库文件以及其他目标文件连接在一起。   • 文件名：LINK.EXE</code>汇编语言语句类型<br />
– 指令性语句——真指令<br />
• 实际的CPU指令<br />
• 汇编程序将其翻译成机器目标代码<br />
• 由四部分组成：<br />
[标号:] 指令助记符 [操作数] [; 注释]<br />
– 指示性语句——伪指令[伪操作指令]<br />
• 方便编制程序<br />
• 不产生代码<br />
[名字] 伪操作命令 [操作数表] [; 注释]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SSEG SEGMENT PARA STACK ; 堆栈段定义  </span><br><span class="line">DW 256 DUP (?)  </span><br><span class="line">SSEG ENDS  </span><br><span class="line">DSEG SEGMENT ; 数据段定义  </span><br><span class="line">MESS DB &#x27;HELLO&#x27;, 0DH, 0AH, &#x27;$&#x27;  </span><br><span class="line">DSEG ENDS  </span><br><span class="line">CSEG SEGMENT ; 代码段(指令区)  </span><br><span class="line">ASSUME CS:CSEG, DS:DSEG ; 规定段的性质  </span><br><span class="line">START: MOV AX, DSEG ; 设置数据段基值  </span><br><span class="line">MOV DS, AX  </span><br><span class="line">MOV DX, OFFSET MESS ; 显示字符串信息  </span><br><span class="line">MOV AH, 09  </span><br><span class="line">INT 21H  </span><br><span class="line">MOV AH,4CH ; 结束本程序运行，返回DOS  </span><br><span class="line">INT 21H  </span><br><span class="line">CSEG ENDS  </span><br><span class="line">END START  </span><br><span class="line">汇编语言有若干个段  </span><br><span class="line">段名、开始、结束  </span><br><span class="line">唯一的END结束  </span><br><span class="line">定义起始执行地址</span><br></pre></td></tr></table></figure>
<p>表达式和运算符<br />
– 由汇编程序计算<br />
• 值<br />
• 地址<br />
– 算术运算符（7种）<br />
• +、-、*、/<br />
• MOD<br />
• SHL、SHR 逻辑运算符（4种）<br />
• AND、OR、XOR、NOT<br />
• 和指令助记符的区别<br />
• MOV AL, 0ADH AND 0EAH → MOV AL, 0A8H<br />
– 关系运算符（6种）<br />
• EQ、NE、LT、GT、LE、GE<br />
• 关系成立时返回0FFFFH，不成立时返回0<br />
– 数值返回运算符<br />
• SEG<br />
• OFFSET<br />
• TYPE • SIZE<br />
• LENGTH 属性运算符<br />
• PTR 修改操作数类型<br />
• THIS</p>
<h2 id="伪指令">伪指令</h2>
<p>数据定义伪指令（变量定义）<br />
– 数据定义伪指令用来为数据分配内存空间(规定变量的类型），<br />
并设置相应内存单元的初始值。<br />
– 形式：<br />
变量名 变量定义符 操作数, 操作数, ..., 操作数<br />
• 其中，变量名是一个符号地址，表示其后操作数的首地址，变量名为可<br />
选项，给出变量名只是为了按名存取其对应的内存单元。 变量定义符主要包括下列几种<br />
– DB（Define Byte）：定义字节，后面的每个操作数占1个字节。<br />
– DW（Define Word）：定义字，后面的每个操作数占1个字。<br />
– DD（Define Dword）：定义双字，后面的每个操作数占2个字。<br />
– 操作数可以是<br />
• 常数 例：DATA DB 10, 4, 10H<br />
• 表达式 例：DATA DW 2*3, 8/4<br />
• 字符串 例：DATA DB 'ABCD'<br />
– ？表示只保留内存空间，未定义初始值。<br />
• 例：DATA DD ？, 1, ？<br />
• 重复次数 DUP （操作数，．．．，操作数）<br />
– 例：DATA DB 3 DUP（？，9）</p>
<h2 id="存储器的分类与组成">存储器的分类与组成</h2>
<p><code>存储器分类   – 程序的执行是从主存中自动的取指令到控制器进行解释执行，需   要的数据也放在主存中根据指令需要存取。   – 按存储介质分类   • 半导体存储器：双极型，静态MOS型，动态MOS型   • 磁表面存储器：磁盘（Disk）、磁带 （Tape）   • 光存储器：CD、CD-ROM、DVD   – 按断电后信息的可保存性分类   • 非易失性存储器   – 信息可一直保留，不需电源维持（如 ：ROM、磁表面存储器、光存储器等）   • 易失性存储器   – 电源关闭时信息自动丢失。（如：RAM、Cache等） – 按存储器功能分类   • 读写存储器（Read/Write Memory)：可读可写   • 只读存储器（Read Only Memory)：只能读不能写   – 按工作方式/存取方式分类   • 随机存取存储器Random Access Memory (RAM)   – 每个单元读写时间一样，且与各单元所在位置无关，如：内存。   • 顺序存取存储器Sequential Access Memory (SAM)   – 数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置   有关，例如：磁带。   • 直接存取存储器Direct Access Memory (DAM)   – 直接定位到要读写的数据块，在读写某个数据块时按顺序进行。例如：磁盘。   • 相联存储器Associate Memory/Content Addressed Memory (CAM）   – 按内容存储与检索，根据内容访问存储位置并进行读写。例如：快表。 – 按容量/速度   • 寄存器   • 高速缓存   • 主存   • 外存储器</code>参数 – 存取速度：<br />
• 存取时间𝑇𝑎：指的是CPU从启动一次存储器操作到完成所需要的时间。<br />
• 存取周期𝑇𝑚：是指连续启动两次独立的存储器操作所需最小时间间隔。<br />
• 带宽（数据传输速度）</p>
<h3 id="读写过程">读写过程</h3>
<p>– 读<br />
• CPU先把读单元地址送到AR，经过地址总线送往主存，同时CPU通过控<br />
制总线发一个读请求，然后CPU等待从主存储器发来的信号，通知CPU<br />
读操作已经完成。<br />
• 存储器通过ready线回答，如果ready信号为1，说明存储字的内容已经<br />
读出，并放在数据总线上，送往DR。<br />
– 写<br />
• CPU先将写单元地址经AR送往地址总线，并把写内容字送DR，同时通<br />
过控制总线发出写命令，然后CPU等待写操作完成信号。<br />
• 主存把收到的信息字写入CPU指定的地址后通过ready线发出完成信号。</p>
<h3 id="只读存储器">只读存储器</h3>
<p>分类<br />
– ROM<br />
• 芯片的内容在制造时已经输入，只能读，不能修改。<br />
• 存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。存储<br />
元件：二极管或晶体管。<br />
– PROM（Programmable ROM, PROM）<br />
• 用户可根据自己的需要来确定ROM里的内容，常见的是熔丝式PROM<br />
是以熔丝的接通来表示1、断开表示0。常用于工业控制机。<br />
– EPROM（Erasable PROM, EPROM）<br />
• 紫外线擦除，只能对芯片进行整体擦除，而不能对芯片中个别需要改写<br />
的存储单元单独擦除。编程次数不受限制。 E2PROM（Electrically EPROM）<br />
• 电擦除，可以用字擦除方式擦除，也可以用数据块擦除方式擦除。以字<br />
擦除方式操作时，能够只擦除被选中的那个存储单元的内容；在数据块<br />
擦除方式操作时，可擦除数据块内所有单元的内容。编程次数受限制。<br />
– 闪速存储器（Flash Memory）<br />
• 一种快擦写型存储器，它的主要特点是：既可在不加电的情况下长期保<br />
存信息，又能进行快速擦除（整体擦除或分区擦除）与重写，兼备了E2<br />
PROM和RAM的优点。<br />
• 闪存的读取速度与DRAM相近，是磁盘的100倍左右；写数据（快擦－<br />
编程）则与硬盘相近。</p>
<h3 id="拓展">拓展</h3>
<ul>
<li>字扩展（位数不变、扩充容量）</li>
<li>位扩展（字数不变，位数扩展）</li>
<li>字位同时扩展（字和位同时扩展）</li>
</ul>
<h3 id="内存">内存</h3>
<p>解决内存访问速度慢的措施有三个：<br />
• 提高主存芯片本身的速度<br />
• 采用多模块存储器技术<br />
• 在主存和CPU之间加入Cache</p>
<h3 id="外部存储器辅助存储器">外部存储器（辅助存储器</h3>
<p>磁表面存储器<br />
– 两类：数字磁记录和模拟磁记录。<br />
– 原理：磁性材料沉积在基体上形成记录介质，通过磁头与记录介<br />
质的相对运动来读写信息。<br />
– 优点：<br />
①容量大，位价低<br />
②记录介质可重复使用<br />
③信息可长期保存甚至可脱机保存<br />
④非破坏性读出<br />
– 缺点：<br />
①速度慢<br />
②对工作环境要求高 光存储器<br />
– 记录原理：用激光在具有感光特性的介质上非接触地记录高密度<br />
信息，以介质材料的光学性质的变化来表示0或1。<br />
– 优点：容量大、可替换（便携带）<br />
– 缺点：速度慢。</p>
<p>寻址时间<br />
– 寻址时间包括两部分：磁头寻找目标磁道所需的寻道时间和找到<br />
磁道后磁头等待所需要读写的区段旋转到磁头下方的等待时间。<br />
– 平均寻址时间=平均寻道时间+平均等待时间<br />
– 平均等待时间与磁盘转速有关，用磁盘旋转一周所需时间的一半<br />
来表示。 数据传输率<br />
– 外部：磁表面存储器的缓存在单位时间内与主机之间传送数据的<br />
位数或字节数。<br />
• 单位bps。<br />
• 取决于总线的类型和标准<br />
– ATA、SCSI、SATA、SAS<br />
– 内部：磁头与硬盘内存之间的数据传输率。<br />
• 传输率=记录密度D x 运动速度V<br />
• 误码率<br />
– 衡量磁表面存储器的出错概率，等于出错信息的位数和读出的总<br />
信息位数比。 磁盘cache<br />
– 基本情况：硬盘内存速度差 (ms-ns)<br />
• 可采用增加磁盘主轴转速<br />
• 提高I/O总线速度<br />
• 改进读写算法<br />
• 采用磁盘cache等方法<br />
– 缓存的大小与速度是直接关系到硬盘的传输速度的重要因素。<br />
– 主流硬盘的缓存8M以上（有些甚至1G）。<br />
– 类型一般是DRAM或SDRAM。<br />
– 采用预读策略（局部性规则）：对顺序数据特别有效<br />
• 视频数据<br />
• 图像文件 磁盘阵列存储器（RAID）<br />
• 廉价冗余磁盘阵列（RAID）是用多台磁盘储存器组成的大<br />
容量外存储子系统。（Redundant Arrays of<br />
Inexpensive Disk）由美国加州大学伯克利分校提出。<br />
• 目的<br />
– 组合小的廉价磁盘来代替大的昂贵的磁盘，降低大批量数据存储<br />
的费用；<br />
– 希望采用冗余信息的方式，使得磁盘失效时不会使对数据的访问<br />
受损失；<br />
– 能适当的提升数据传输速度。<br />
– 保证数据的可靠性和高可用性 RAID的实现<br />
– 专门的控制芯片来完成<br />
– 用软件的方法来实现， RAID 0级（无冗余和无校验的数据分块）<br />
– 将连续的数据块分别存放在不同的磁盘上。具有最高的I/O性能<br />
和磁盘空间利用率，无数据冗余，无容错能力，不能应用于数据<br />
安全性要求高的场合。<br />
• RAID 1级（镜像磁盘阵列）<br />
– 由磁盘对组成，每一个工作盘都有对应的镜像盘，上面保存着与<br />
工作盘完全相同的数据，安全性高，但磁盘空间的利用率只有<br />
50% RAID 2级（具有纠错海明码的磁盘阵列）<br />
– 采用海明码纠错技术和位交叉技术，用户需增加足够的校验盘来<br />
提供单纠错和双验错功能。当阵列内有G个数据盘时，则所需的<br />
校验盘数C要满足公式： 2𝐶 ≥ 𝐺 + 𝐶 + 1，如果有4个数据盘，<br />
则需要3个校验盘。对数据的访问涉及到磁盘阵列中的每一个盘，<br />
对大数据量传送有较高性能，但不利于小数据量的传送。RAID<br />
2很少使用。 位交叉存取<br />
– 将一个数据段中的各位分别存储在不同的磁盘上，以同步方式进<br />
行读写，最小访问数据单位是每个磁盘的最小读写单位（例如扇<br />
区）X磁盘数。<br />
– 适合传送批量数据<br />
• 块交叉存取<br />
– 以数据块为单位，将连续的数据块分别存放在不同的磁盘上，最<br />
小访问数据单位是每个磁盘的最小读写单位（例如扇区）<br />
– 适合传送少量数据 RAID 5级（无专用校验盘的奇偶校验磁盘阵列）<br />
– 无专用的校验盘，将校验信息分布到组内所有盘上，对大、小数<br />
据量的读写都有很好的性能，因而是一种较好的方案。<br />
• RAID 10级（RAID 0级+RAID 1级）<br />
– 由分块和镜像组成，是所有RAID中性能最好的磁盘阵列，但每<br />
次写入时要写两个互为镜像的盘， CPU占用率高，磁盘的利用<br />
率低 磁盘存储器与光盘存储器的比较<br />
– 两种存储器的记录原理、组成部分等方面都是相同的。在计算机<br />
中它们各有自己的特点与功能。<br />
– 硬盘驱动器<br />
• 容量大、数据传输率高、等待时间短。<br />
– 光盘驱动器<br />
• 存储密度高、容量大、价格低。但是光盘与主机的速度不匹配所以不能<br />
作为中间存储器，即不能替代硬盘 <img src="/images/obsidian/20230610145852.png" title="image" alt="图片" /> 为什么这种层次化结构是有效的？<br />
– 时间局部性（Temporal Locality）<br />
• 含义：刚被访问过的单元很可能不久又被访问<br />
• 做法：让最近被访问过的信息保留在靠近CPU的存储器中<br />
– 空间局部性 （Spatial Locality）<br />
• 含义：刚被访问过的单元的邻近单元很可能不久被访问<br />
• 做法：将刚被访问过的单元的邻近单元调到靠近CPU的存储器中<br />
– 大量典型程序的运行情况分析结果表明：程序具有访问局部性特<br />
征<br />
• 指令：指令按序存放，地址连续，循环程序段或子程序段重复执行<br />
• 数据：连续存放，数组元素重复、按序访问</p>
<p>• 键盘<br />
– 键盘是一组排列成阵列形式的按键开关，按下一个键就产生一个<br />
相应的字符，然后转换成ASCII或其他码送往主机<br />
– 键盘输入信号处理可分为三个步骤：<br />
• (1) 按下一个键；<br />
• (2) 查出按下的是哪一个键；<br />
• (3) 将该键翻译成能被计算机接收的代码<br />
• 键盘的种类<br />
– 机械式键盘<br />
• 触点的导通或断开<br />
• 每个键由底座、轴帽、轴帽固定卡、弹簧、金属支脚、触点金属片 导电橡胶式键盘<br />
• 通过导电的橡胶实现触点的连接<br />
– 电容式键盘<br />
• 当人体（手指）接触金属感应片的时候，由于人体相当于一个接大地的<br />
电容，因此会在感应片和大地之间形成一个电容 薄膜式键盘<br />
• 无机械磨损<br />
• 低价格<br />
• 低噪音<br />
• 低成本<br />
• 市场占有相当份额 • 鼠标<br />
– 一种坐标定位部件，只能用来输入相对坐标。 • CMOS传感器将每一幅图像都发送给数字信号处理器（DSP）进行分析。<br />
• DSP检测各图像中的图案，并分析图像中图案的位置如何变动。<br />
• 根据一系列图像中图案位置的变化，DSP确定鼠标的移动距离并将相应<br />
坐标发送给计算机。<br />
• 计算机根据从鼠标接收到的坐标信息，移动屏幕上的光标。<br />
– 与轨迹球鼠标相比，光电鼠标具有下列优势：<br />
• 没有可移动的零部件，这意味着磨损更少、故障率更低。<br />
• 灰尘无法进入鼠标内部并干扰跟踪传感器。<br />
• 增加的跟踪分辨率意味着响应更顺畅。<br />
• 不需要鼠标垫等专用表面。 触摸屏<br />
– 电阻式：利用压力感应进行控制电阻<br />
– 电容式：利用人体的电流感应进行工作<br />
– 红外式：在显示器上加上光点距架框，在屏幕表面形成一个红外<br />
线网<br />
– 表面声波触摸屏：玻璃屏的左上角和右下角各固定了竖直和水平<br />
方向的超声波发射换能器，右上角则固定了两个相应的超声波接<br />
收换能器。玻璃屏的四个周边则刻有45°角由疏到密间隔非常精<br />
密的反射条纹 条形码（Bar Code）<br />
– 由一组宽度和反射率不同的平行相邻条和空按预先规定的编码规<br />
则组合起来，用来表示一组数据的符号 主要类型<br />
• 堆叠式/行排式<br />
– 建立在一维条码基础之上，按需要堆积成二行或多行<br />
– 继承了一维条码的一些特点<br />
– 需要对行进行判定，其译码算法与软件也不完全相同于一维条码<br />
• 矩阵式二维码<br />
– 它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码<br />
– 用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制<br />
的“0”，点的排列组合确定了矩阵式二维条码所代表的意义 显示器显色原理<br />
– 像素点：颜色显示的最小单元<br />
• 一个像素点包含三原色<br />
• 通过调整三原色的显示强弱来控制颜色 CRT<br />
– 可用于字符、图形和图像显示器。<br />
– CRT是一个真空器件，由电子枪、偏转装置和荧光屏组成。<br />
– 玻璃屏内壁涂有荧光粉，它将电子束的动能转换成光能，显示出<br />
光点。不同的荧光粉在电子束的轰击下发出不同的颜色。<br />
– 对电子束的要求<br />
• （1）电子束要有足够的强度和速度。<br />
• （2）电子束要足够细。<br />
• （3）电子束的运动方向要高度可控 有机发光二极管（OLED）<br />
– 自发光的二极管，无需背光<br />
• 等离子显示器（PDP）<br />
– 利用惰性气体在一定电压下产生气体放电现象而实现的发光技术。<br />
• 显示技术的重要技术指标<br />
– 分辨率<br />
• 字符显示方式<br />
– 一屏可显示的最多字符数称为分辨率，例如80列×25行，表示每屏最多可显示25<br />
行，每行可有80个字符。<br />
• 在图形显示方式<br />
– 一屏可显示的像点数称为分辨率，例如800×600，表示一屏可包含600条水平扫<br />
描线，每线可分为800点。<br />
• 分辨率越高，显示的信息越多 颜色数（位深）：每个像素点可显示的颜色数（灰度级）<br />
• 每种原色由8位表示灰度，三原色共计224种颜色<br />
• 实际传输过程中采用32位表示一种颜色，而高端显示器每种原色用10位<br />
表示，总共可表示230，约10.7亿色 按打字原理分：击打式打印机（点阵针式打印机）和非击<br />
打式打印机（喷墨打印机、激光打印机）。<br />
• 按工作方式分：串行打印机和行式打印机。串行打印机一<br />
次只能打一个字，行式打印机一次可以打印一行<br />
• 常见打印机类型<br />
– 点阵针式打印机<br />
– 激光打印机<br />
– 喷墨打印机<br />
– 热转印和热敏打字机<br />
• 发展趋势<br />
– 击打式和非击打式并存<br />
– 击打式的多样化、特殊化：银行、铁路、超市、酒店</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 课程笔记</a>
              <a href="/tags/%E8%8B%8F%E5%B7%9E%E5%A4%A7%E5%AD%A6/" rel="tag"><i class="fa fa-tag"></i> 苏州大学</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="tag"><i class="fa fa-tag"></i> 计算机组成</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/thinklive/59610/" rel="prev" title="基于中科大linux101和苏大ppt的linux笔记">
                  <i class="fa fa-angle-left"></i> 基于中科大linux101和苏大ppt的linux笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/thinklive/2910/" rel="next" title="基于恐龙书和苏大ppt的操作系统笔记">
                  基于恐龙书和苏大ppt的操作系统笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">thinklive</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">339k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">20:32</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 技术支持
  </div><script defer src="/lib/three.js"></script><script defer src="/lib/lines.js"></script><script defer src="/lib/waves.js"></script>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.3" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  <script src="/js/third-party/addtoany.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://thinklive1.github.io/thinklive/33908/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<!-- calendar widget -->
{% if theme.CloudCalendar.enable %}
    <script src="{{ theme.CloudCalendar.calendarCdn }}"></script>
    <script src="{{ theme.CloudCalendar.langCdn }}"></script>
    <script>
    $(function() {
        $('#CloudCalendar').aCalendar('{{ theme.CloudCalendar.language }}',
            $.extend(
                '', {
                    single:{{ theme.CloudCalendar.single }},
                    root:'{{ theme.CloudCalendar.root }}'
                }
            )
        );
    });
    </script>
{% endif %}
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"thinklive1/blog_comments","issue_term":"pathname","theme":"photon-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script>
<script>
    const snowflakes = ["❄", "❄", "❆", "❅", "✥","❄", "❄", "❆", "❅", "✥","✻"];
    // 创建雪花
    function createSnowflake() {
        const snowflake = document.createElement("span");
        snowflake.classList.add("snowflake");
        const randomIndex = Math.floor(Math.random() * snowflakes.length);
        snowflake.textContent = snowflakes[randomIndex];
        
        // 起始位置
        /* 80%概率 生成在页面两侧 30% 的位置
        const probability = Math.random();
        let startPosition = Math.random() * 100;

        if (probability < 0.8) {
            startPosition = Math.random() < 0.5 ? Math.random() * 30 : (Math.random() * 30) + 70;
        }
        snowflake.style.left = `${startPosition}vw`;
        */
        snowflake.style.left = `${Math.random() * 100}vw`;
        snowflake.style.top = `-30px`;
        // 雪花大小与透明度
        const size = Math.random() * 18 + 10;
        snowflake.style.fontSize = `${size}px`;
        const opacity = Math.random() * 0.6 + (size > 18 ? 0.4 : 0);
        snowflake.style.setProperty("--opacity", opacity);
        // 动画持续时间
        const fallDuration = Math.random() * 10 + 10;
        // 旋转持续时间
        const rotateDuration = Math.random() * 3 + 1;

        snowflake.style.animationDuration = `${fallDuration}s, ${fallDuration}s`; // 向 CSS 添加淡出动画的持续时间
        // 横向幅度
        const translateX = (Math.random() * 500 - 200);
        snowflake.style.setProperty("--translateX", `${translateX}px`);
        // 纵向幅度
        snowflake.style.setProperty("--translateY", `${window.innerHeight}px`);

        document.body.appendChild(snowflake);
        // 移除雪花
        setTimeout(() => {
            snowflake.remove();
        }, fallDuration * 1000);
    }
    
    function snowfallAnimation() {
        // 载入时若边栏是隐藏状态则不加载雪花
        const sidebarnav = document.querySelector('.sidebar');
        const sidebarnavdisplay = window.getComputedStyle(sidebarnav).getPropertyValue('display'); 
        if (sidebarnavdisplay !== 'none') {
            createSnowflake();
        }
        setTimeout(snowfallAnimation, 150); // 生成速度，毫秒
    }
    snowfallAnimation();
</script>

   <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  <video autoplay loop muted playsinline style="position:fixed;top:50%;opacity: 0.8;left:50%;min-width:100%;min-height:100%;transform:translateX(-50%)translateY(-50%);z-index:-2;">
  <source src="/images/red.mp4" type="video/mp4">
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
