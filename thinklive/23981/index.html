<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinklive1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#66CCFF","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="专业课 网络 USP是一个智能化的网络数据库统一检索平台。它通过一个统一界面帮助用户在多个网络数据库搜索平台中实现信息检索操作，是对外网络中的多种检索工具的智能化整合 NAT即网络地址转换（Network Address Translation），是一种将IP数据包中的IP地址转换为另一个IP地址的技术  静态NAT  功能：实现内部IP与公网IP的一对一固定映射，常用于需要公网访问的服务器（如W">
<meta property="og:type" content="article">
<meta property="og:title" content="复试冲刺20天">
<meta property="og:url" content="https://thinklive1.github.io/thinklive/23981/index.html">
<meta property="og:site_name" content="thinklive">
<meta property="og:description" content="专业课 网络 USP是一个智能化的网络数据库统一检索平台。它通过一个统一界面帮助用户在多个网络数据库搜索平台中实现信息检索操作，是对外网络中的多种检索工具的智能化整合 NAT即网络地址转换（Network Address Translation），是一种将IP数据包中的IP地址转换为另一个IP地址的技术  静态NAT  功能：实现内部IP与公网IP的一对一固定映射，常用于需要公网访问的服务器（如W">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem.assets/edit_distance_state_transfer.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg">
<meta property="article:published_time" content="2025-02-28T13:12:21.000Z">
<meta property="article:modified_time" content="2025-09-09T07:53:29.848Z">
<meta property="article:author" content="thinklive">
<meta property="article:tag" content="研distance">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem.assets/edit_distance_state_transfer.png">


<link rel="canonical" href="https://thinklive1.github.io/thinklive/23981/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://thinklive1.github.io/thinklive/23981/","path":"thinklive/23981/","title":"复试冲刺20天"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>复试冲刺20天 | thinklive</title>
  







<script type="text/javascript" async src="/js/fairyDustCursor.js"></script>
<script type="text/javascript" async src="/js/tab-title.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script>
const options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: false, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}

const darkmode = new Darkmode(options);
</script>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="thinklive" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>
<script src="/js/tab-title.js"></script>
<script type="text/javascript" async src="/js/text.js"></script>

<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>


  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">thinklive</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">dirichlet library</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索 | search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页-|-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页 | home</a></li><li class="menu-item menu-item-标签-|-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags</a></li><li class="menu-item menu-item-分类-|-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories</a></li><li class="menu-item menu-item-归档-|-archive"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archive</a></li><li class="menu-item menu-item-相册-|-photo"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册 | photo</a></li><li class="menu-item menu-item-留言-|-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言 | guestbook</a></li><li class="menu-item menu-item-感谢-|-thank"><a href="/thanks/" rel="section"><i class="fa custom thanks fa-fw"></i>感谢 | thank</a></li><li class="menu-item menu-item-游戏-|-game"><a href="/game/bad1.html" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏 | game</a></li><li class="menu-item menu-item-神龛-|-shrine"><a href="/cyberblog/" rel="section"><i class="fa fa-microchip fa-fw"></i>神龛 | shrine</a></li><li class="menu-item menu-item-资源地图-|-resourcemap"><a href="/webstack/" rel="section"><i class="fa fa-list fa-fw"></i>资源地图 | resourcemap</a></li><li class="menu-item menu-item-思维导图-|-mindmap"><a href="/mindmap/index.html" rel="section"><i class="fa fa-map fa-fw"></i>思维导图 | mindmap</a></li><li class="menu-item menu-item-网站地图-|-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>网站地图 | sitemap</a></li><li class="menu-item menu-item-蒸汽-|-steam"><a href="/steamgames/index.html" rel="section"><i class="fa fa custum steam fa-fw"></i>蒸汽 | steam</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">


<!--网易云音乐插件-->
<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->
<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--网易云playlist外链地址-->   
<meting-js
    server="netease"
    type="playlist" 
    id="2762741085"
    mini="false"
    fixed="false"
    list-folded="true"
    autoplay="false"
    volume="0.2"
    theme="#4c4c4c"
    order="random"
    loop="all"
    preload="auto"
    lrc-type="2"
    mutex="true">
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%93%E4%B8%9A%E8%AF%BE"><span class="nav-number">1.</span> <span class="nav-text">专业课</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">1.1.</span> <span class="nav-text">网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ds"><span class="nav-number">1.2.</span> <span class="nav-text">DS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E5%B7%A5"><span class="nav-number">1.3.</span> <span class="nav-text">软工</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.4.</span> <span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#os"><span class="nav-number">1.5.</span> <span class="nav-text">OS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ai"><span class="nav-number">1.6.</span> <span class="nav-text">ai</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%91%E7%A0%94"><span class="nav-number">2.</span> <span class="nav-text">科研</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#knowledge"><span class="nav-number">2.1.</span> <span class="nav-text">knowledge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A2%AF%E5%BA%A6"><span class="nav-number">2.1.1.</span> <span class="nav-text">梯度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#r-%E6%A0%91"><span class="nav-number">2.1.2.</span> <span class="nav-text">R 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hmm"><span class="nav-number">2.1.3.</span> <span class="nav-text">HMM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E8%AF%95%E5%8F%82%E8%80%83"><span class="nav-number">3.1.</span> <span class="nav-text">机试参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">3.1.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-number">3.1.2.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">3.1.3.</span> <span class="nav-text">set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unordered_set"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">unordered_set</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-number">3.1.4.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">3.1.5.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">3.1.6.</span> <span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unordered_map"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">unordered_map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">3.1.7.</span> <span class="nav-text">string</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.7.1.</span> <span class="nav-text">1.string构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E5%9F%BA%E6%9C%AC%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.7.2.</span> <span class="nav-text">2.string基本赋值操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E5%AD%98%E5%8F%96%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.7.3.</span> <span class="nav-text">3.string存取字符操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.7.4.</span> <span class="nav-text">4.string拼接操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number">3.1.7.5.</span> <span class="nav-text">5.string查找和替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string-%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.7.6.</span> <span class="nav-text">6.string 比较操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E5%AD%90%E4%B8%B2"><span class="nav-number">3.1.7.7.</span> <span class="nav-text">7.string子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.7.8.</span> <span class="nav-text">8.string插入和删除操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">3.1.8.</span> <span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.8.1.</span> <span class="nav-text">1.deque构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque%E5%AD%98%E5%8F%96%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.8.2.</span> <span class="nav-text">2.deque存取、插入和删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.8.3.</span> <span class="nav-text">3.deque赋值操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.8.4.</span> <span class="nav-text">4.deque大小操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority_queue"><span class="nav-number">3.1.9.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#algorithm"><span class="nav-number">3.1.10.</span> <span class="nav-text">algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#functional"><span class="nav-number">3.1.11.</span> <span class="nav-text">functional</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">算法范式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">3.2.1.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E9%9B%86%E5%92%8C"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">子集和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#n%E7%9A%87%E5%90%8E"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">N皇后</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">3.2.2.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">0-1背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">完全背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.2.1.</span> <span class="nav-text">找零问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%982"><span class="nav-number">3.2.2.2.2.</span> <span class="nav-text">找零问题2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">编辑距离问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83"><span class="nav-number">3.2.3.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">分数背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">最大容量问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">最大切分乘积问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cpp%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">3.3.</span> <span class="nav-text">cpp基本输入输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9B%E6%89%A3%E7%83%AD%E9%A2%98-100-%E9%81%93%E9%A2%98%E8%A7%A3"><span class="nav-number">3.4.</span> <span class="nav-text">力扣热题 100 道题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-number">3.4.1.</span> <span class="nav-text">哈希</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">3.4.2.</span> <span class="nav-text">双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">3.4.3.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E4%B8%B2"><span class="nav-number">3.4.4.</span> <span class="nav-text">子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.4.5.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5"><span class="nav-number">3.4.6.</span> <span class="nav-text">矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.4.7.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.4.8.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-number">3.4.9.</span> <span class="nav-text">图论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">3.4.10.</span> <span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">3.4.11.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.4.12.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">3.4.13.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83-1"><span class="nav-number">3.4.14.</span> <span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">3.4.15.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.4.15.1.</span> <span class="nav-text">斐波那契类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5-1"><span class="nav-number">3.4.15.2.</span> <span class="nav-text">矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.4.15.3.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">3.4.15.4.</span> <span class="nav-text">最长递增子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">3.4.15.5.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8"><span class="nav-number">3.4.15.6.</span> <span class="nav-text">买卖股票</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A0%91"><span class="nav-number">3.4.15.7.</span> <span class="nav-text">动态规划树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-1"><span class="nav-number">3.4.15.8.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.15.9.</span> <span class="nav-text">一维问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7"><span class="nav-number">3.4.16.</span> <span class="nav-text">技巧</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="thinklive"
      src="/images/thive.png">
  <p class="site-author-name" itemprop="name">thinklive</p>
  <div class="site-description" itemprop="description">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinklive1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinklive1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/t469631989@gmail.com" title="E-Mail → t469631989@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/38099250?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;38099250?spm_id_from&#x3D;333.1007.0.0" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/thinkliving" title="steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;thinkliving" rel="noopener me" target="_blank"><i class="fa custom steam fa-fw"></i>steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

<div style="Text-align:center;width:100%"><div style="margin:0 auto"><canvas id="canvas" style="width:60%" height="100" width="700">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){function t(t,e){for(var a=0;a<l[e].length;a++)for(var n=0;n<l[e][a].length;n++)1==l[e][a][n]&&(h.beginPath(),h.arc(14*(g+2)*t+2*n*(g+1)+(g+1),2*a*(g+1)+(g+1),g,0,2*Math.PI),h.closePath(),h.fill())}function e(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a=[];a.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var r=c.length-1;r>=0;r--)a[r]!==c[r]&&t.push(r+"_"+(Number(c[r])+1)%10);for(var r=0;r<t.length;r++)n.apply(this,t[r].split("_"));c=a.concat()}function a(){for(var t=0;t<d.length;t++)d[t].stepY+=d[t].disY,d[t].x+=d[t].stepX,d[t].y+=d[t].stepY,(d[t].x>i+g||d[t].y>f+g)&&(d.splice(t,1),t--)}function n(t,e){for(var a=[1,2,3],n=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],r=0;r<l[e].length;r++)for(var o=0;o<l[e][r].length;o++)if(1==l[e][r][o]){var h={x:14*(g+2)*t+2*o*(g+1)+(g+1),y:2*r*(g+1)+(g+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*a[Math.floor(Math.random()*a.length)],color:n[Math.floor(Math.random()*n.length)],disY:1};d.push(h)}}function r(){o.height=100;for(var e=0;e<c.length;e++)t(e,c[e]);for(var e=0;e<d.length;e++)h.beginPath(),h.arc(d[e].x,d[e].y,g,0,2*Math.PI),h.fillStyle=d[e].color,h.closePath(),h.fill()}var l=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],o=document.getElementById("canvas");if(o.getContext){var h=o.getContext("2d"),f=100,i=700;o.height=f,o.width=i,h.fillStyle="#f00",h.fillRect(10,10,50,50);var c=[],d=[],g=o.height/20-1;!function(){var t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date);c.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6])}(),clearInterval(v);var v=setInterval(function(){e(),a(),r()},50)}}()</script></div>
<img class= 'logo' src="/images/thinklive_cyber.png"; z-index: '0'; style="max-width: 100%; width: auto; height: auto;background-color: --content-bg-color;">

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thinklive1.github.io/thinklive/23981/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/thive.png">
      <meta itemprop="name" content="thinklive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="thinklive">
      <meta itemprop="description" content="起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="复试冲刺20天 | thinklive">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          复试冲刺20天
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-28 21:12:21" itemprop="dateCreated datePublished" datetime="2025-02-28T21:12:21+08:00">2025-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-09 15:53:29" itemprop="dateModified" datetime="2025-09-09T15:53:29+08:00">2025-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">考研笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/%E7%A0%94distance/" itemprop="url" rel="index"><span itemprop="name">研distance</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>61k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3:41</span>
    </span>
</div>

        
        </div>
      </header>
   

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="专业课">专业课</h1>
<h2 id="网络">网络</h2>
<p>USP是一个智能化的网络数据库统一检索平台。它通过一个统一界面帮助用户在多个网络数据库搜索平台中实现信息检索操作，是对外网络中的多种检索工具的智能化整合<br />
NAT即网络地址转换（Network Address Translation），是一种将IP数据包中的IP地址转换为另一个IP地址的技术</p>
<ol type="1">
<li>静态NAT
<ul>
<li>功能：实现内部IP与公网IP的一对一固定映射，常用于需要公网访问的服务器（如Web服务器），确保外部可通过固定公网IP访问内部设备</li>
</ul></li>
<li>动态NAT
<ul>
<li>功能：从定义的公网IP地址池中动态分配IP，内部设备随机获取公网IP，用完后释放，适用用户数不固定的场景</li>
</ul></li>
<li>端口地址转换(PAT/NAPT(Network Address Port Translation，网络地址端口转换))
<ul>
<li>功能：多个内部IP共享一个公网IP，通过端口号区分不同连接，极大节省IP地址，是家庭、企业最常用的NAT方式</li>
</ul></li>
</ol>
<span id="more"></span>
<h2 id="ds">DS</h2>
<p>广义表的长度是指广义表第一层元素的个数，不包括递归子表内部的元素个数</p>
<ol type="1">
<li>普通表：如(ab,c)，长度为3</li>
<li>嵌套表：如(a,(b),d)，长度为3</li>
</ol>
<p>广义表的深度是指广义表的最大嵌套层数</p>
<ol type="1">
<li>空表：深度为1</li>
<li>普通表：如(a,b,c)，深度为1</li>
<li>嵌套表：如(a,(b,c),d)，深度为2，因为(b,) 是第一层中的子表，深度为1，整体深度为2</li>
</ol>
<h2 id="软工">软工</h2>
<p>问题定义-&gt;可行性分析-&gt;需求分析-&gt;设计-&gt;开发阶段-&gt;测试-&gt;运行与维护<br />
主要的软件开发方法:</p>
<ol type="1">
<li>结构化方法：面向数据流，自顶向下逐层分解，进行结构化分析、结构化设计、结构化程序设计。适用数据处理领域，不适用大且复杂、需求一直变化的场景</li>
<li>jackson方法：面向数据结构，通过问题的输入输出数据结构来分析，推出相应程序结构。适用小规模</li>
</ol>
<p>软件测试与开发模型:</p>
<ol type="1">
<li>软件测试的目的：验证软件是否符合需求，发现缺陷，确保质量,验证功能，避免风险</li>
<li>软件测试的类型：单元测试（模块级）、集成测试（模块间交互）、系统测试（整体功能）、验收测试（分为Alpha测试和Beta测试）</li>
<li>软件测试的方法：白盒测试（代码逻辑）、黑盒测试（功能验证）、自动化测试（工具辅助）</li>
<li>模型：
<ol type="1">
<li>瀑布模型：线性流程（需求-设计-开发-测试-部署），适合需求明确的项目</li>
<li>演化模型：初始的原型逐步演化成最终软件产品的过程，演化模型适用于对软件需求缺之准确认识的情况。典型的演化模型有：增量模型、原型型、旋模型</li>
<li>增量模型：从一组给定的需求开始，一次构造一段增量，逐步完善待开发的系统。增量模型强调每一个增量都发布一个可运行的产品，可较快产生能操作的系统</li>
<li>敏捷模型：迭代开发，快速交付，适应需求变化（如Scrum、看板）</li>
<li>螺旋模型：是瀑布模型和演化模型的结合，增加了风险分析，客户参与开发，适合大型复杂项目</li>
<li>原型模型：先构建原型供用户反馈，收集用户的反馈意见，再优化开发</li>
<li>喷泉模型：支持面向对象开发的过程模型。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的。迭代是指软件的某个部分常常被重复工作多次，相关功能在每次迭代中随之加入渐进的软件成分。无间隙指在各项活动之间无明显边界，如分析和设计活动之间没有明显的界限</li>
</ol></li>
</ol>
<p>软件维护主要分为以下四种类型:</p>
<ol type="1">
<li><strong>修正性维护（Corrective Maintenance）</strong>:
<ul>
<li>概念:针对发现的软件错误或缺陷进行修复和更正的维护活动</li>
<li>目的:消除软件中存在的错误,提高软件的可靠性和正确性</li>
</ul></li>
<li><strong>适应性维护（Adaptive Maintenance）</strong>:
<ul>
<li>概念:对软件进行修改和调整,使其能够适应硬件环境、操作系统或其他外部条件的变化</li>
<li>目的:确保软件能够持续运行并满足用户的需求</li>
</ul></li>
<li><strong>完善性维护（Perfective Maintenance）</strong>:
<ul>
<li>概念:在不改变软件原有功能的情况下,对软件进行优化和改进,以提高其性能和可用性</li>
<li>目的:提升软件的质量,增强用户体验</li>
</ul></li>
<li><strong>预防性维护（Preventive Maintenance）</strong>:
<ul>
<li>概念:对软件进行系统性的分析和检查,以检测和预防潜在的问题</li>
<li>目的:降低软件故障发生的概率,延长软件的使用寿命</li>
</ul></li>
</ol>
<p>白盒测试，也称为结构化测试、基于代码的测试，是一种测试用例设计方法，它从程序的控制结构导出测试用例。用白盒测试产生的测试用例能够</p>
<ol type="1">
<li>保证一个模块中的所有独立路径至少被使用一次</li>
<li>对所有逻辑值均需测试true和false</li>
<li>在上下边界及可操作范围内运行所有循环</li>
<li>检查内部数据结构以确保其有效性</li>
</ol>
<p>黑盒测试也称功能测试，通过测试来检测每个功能是否都能正常使用。在完全不考虑程序内部结构和内部特性的情况下，对程序接口进行测试，以用户的角度，从输入数据与输出数据的对应关系出发进行测试</p>
<p>提高软件质量:</p>
<ol type="1">
<li>复审：是在软件生命周期每个阶段结束之前都采用一定的标准对该段产生的软件进行检测</li>
<li>复查：是检查已有的材料，以断定在软件生命周期某个阶段的工作是否能够开始或继续</li>
<li>管理复审：是向管理人员提供有关项目的总体状况、成本和进度等方面的情况，以便管理</li>
</ol>
<p>软件形式化：在严格数学基础上的软件开发方法，基于数学的方法来描述软件属性的技术<br />
三要素: 方法，工具，过程</p>
<h2 id="数据库">数据库</h2>
<p>候选码：可以唯一标识一个元组的最少的属性集合<br />
主键：一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性,主键是候选键的子集<br />
超键（Super Key） 是一个或多个属性的集合，这个集合可以唯一标识关系表中的每一行记录,候选键是一个最小的超键</p>
<p>存储过程是一组为了完成特定功能的语句集合，经编译后存储在数据库中。它可接收输入参数、输出参数，也可包含逻辑控制语句和数据操作语句等。用户通过调用存储过程来执行这些预定义的操作，可实现代码复用，提高数据库操作的效率和安全性，减少网络传输量<br />
触发器是一种特殊的存储过程，它在特定的数据库事件（如INSERT、UPDATE、DELETE操作）发生时自动执行。触发器可用于实现数据的完整性约束、数据审计、日志记录等功能，能在数据发生变化时自动进行一些额外的操作或检查，确保数据库中的数据符合特定的业务规则和要求</p>
<p>数据库中的死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种互相等待的现象</p>
<p>外接是指两个表在进行操作时，不仅返回符合连接和查询条件的元组，还返回不符合条件的一些元组；<br />
左外连接是指返回左表中仅符合连接条件不符合查询条件的元组：<br />
右外连接是指返回右表中仅符合连接条件不符合查询条件的元组：<br />
全外连接是左外连接和右外连接去掉重复项的元组集并集</p>
<p>索引是存储在数据库中的一个物理结构，是实际存在的，相当于一本书的目录，常用B+树实现<br />
键是一个逻辑概念，不是数据库中的物理部分</p>
<p>视图是从一个或几个基本表中导出的表，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据。基本表中的数据发生变化时，从视图中查询出来的数据也就随之发生变化<br />
作用：</p>
<ul>
<li>能够简化用户的操作</li>
<li>使用户能以多种角度看待同一数据</li>
<li>在一定程度上提供了数据的逻辑独立性</li>
<li>能够对秘密数据提供安全保护</li>
</ul>
<p>游标：将查询出来的结果集作为一个单元来进行处理，适用于逐行处理数据</p>
<p>安全性技术：用户标识和鉴别、多层存取控制、审计、视图、数据加密<br />
存取控制是指确保只授权给有资格的用户访问数据库的权限，且令所有未被授权的人员无法接近数据<br />
两个部分：定义用户权限和合法权限检查；两种方法：</p>
<ol type="1">
<li><strong>自主存取控制（DAC）</strong>：用户对不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限<br />
</li>
<li><strong>强制存取控制（MAC）</strong>：每一个数据库对象被标以一定的密级，每一个用户也被授予一定级别的许可证，只有具有合法许可证的用户才可以进行存取</li>
</ol>
<p><strong>断言</strong>是指更具有一般性的约束，断言创建后，任何涉及到断言中的关系的操作会引发数据库对断言的检查，任何使断言为假的操作都会被拒绝执行</p>
<p>悲观锁:总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现<br />
乐观锁:总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型， 这样可以提高吞吐量 ，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(compare and swap)实现的<br />
ABA 问题:如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题</p>
<p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存</p>
<p><strong>DBA(Database Administrator)</strong></p>
<p>三级模式结构是描述数据库系统中数据抽象层次的概念模型,它包括:</p>
<ul>
<li>外模式（External Model）
<ul>
<li>也称为用户视图或应用程序视图</li>
<li>描述数据库中针对特定用户或应用程序的数据视图</li>
<li>用户只能看到和操作外模式所定义的数据子集</li>
</ul></li>
<li>概念模式（Conceptual Model）
<ul>
<li>也称为逻辑模型或数据库模型</li>
<li>描述数据库中全部数据的逻辑结构和特性</li>
<li>这是数据库的整体数据模型,独立于任何硬件或软件实现</li>
</ul></li>
<li>内模式（Internal Model）
<ul>
<li>也称为存储模型或物理模型</li>
<li>描述数据在计算机内部如何存储和组织的细节</li>
<li>包括数据存储结构、存储介质、存取路径等物理存储细节</li>
</ul></li>
</ul>
<p>三级模式结构提供了以下优点:</p>
<ol type="1">
<li>数据独立性:
<ul>
<li>外模式独立于概念模式,概念模式独立于内模式</li>
<li>可以在不影响上层的情况下修改底层模式</li>
</ul></li>
<li>灵活性和可扩展性:
<ul>
<li>用户可根据需求定制外模式</li>
<li>数据库可根据应用需求进行修改和扩展</li>
</ul></li>
<li>安全性和隐私性:
<ul>
<li>通过外模式控制用户对数据的访问权限</li>
<li>内模式的物理存储细节对用户是隐藏的</li>
</ul></li>
</ol>
<p>完整性约束:</p>
<ul>
<li>实体完整性：关系模式中的主码不能为空值</li>
<li>参照完整性：关系模式中的外码只能是空值或者另一关系模式的主码</li>
<li>用户定义完整性：关系模式中针对某一属性的约束</li>
</ul>
<p>SQL（Structured Query Language）是一种专门用于管理和操作关系型数据库的标准化查询语言。它主要包括以下几个方面:</p>
<ol type="1">
<li>数据定义语言（DDL）:
<ul>
<li>用于创建、修改和删除数据库对象,如数据库、表、视图等</li>
<li>常用命令包括 CREATE、ALTER、DROP 等</li>
</ul></li>
<li>数据操作语言（DML）:
<ul>
<li>用于对数据库中的数据进行增删改查等操作</li>
<li>常用命令包括 SELECT、INSERT、UPDATE、DELETE 等</li>
</ul></li>
<li>数据控制语言（DCL）:
<ul>
<li>用于管理数据库的访问权限和安全策略</li>
<li>常用命令包括 GRANT、REVOKE 等</li>
</ul></li>
<li>事务控制语言（TCL）:
<ul>
<li>用于管理数据库事务,确保数据的完整性和一致性</li>
<li>常用命令包括 COMMIT、ROLLBACK 等</li>
</ul></li>
</ol>
<p>自然连接是等值连接的一种特殊情况：<br />
等值连接要求连接的是值相等的分量，两个关系中可以没有相同的属性；进行自然连接的两个关系中必须有相同的属性<br />
等值连接不要求去掉重复属性列；自然连接时需要除掉重复的属性列<br />
左/右外连接是在两表进行自然连接，只把左/右表要舍弃的保留在结果集中<br />
全外连接是在两表进行自然连接，只把左表和右表要舍弃的都保留在结果集中，相对应的列上填null</p>
<p>ACID特性包括：</p>
<ul>
<li>隔离性：一个事务的执行不能被其他事务所于扰</li>
<li>原子性：事务是一个不可分割的单位，要么全做，要么全不做</li>
<li>一致性：事务执行的结果必须使数据库从一个一致性状态变到另一个一致性状态</li>
<li>永久性：一旦事务被提交，它对数据库的改变就是永久的</li>
</ul>
<p>日志文件、后备副本可用于数据库恢复</p>
<p>排他锁（写锁）：当数据被加上写锁，其他事务不能对该数据进行读和写<br />
共享锁（S读锁）：当数据被加上读锁，允许其他事务对该数据进行读，不允许写</p>
<p>封锁协议:</p>
<ol type="1">
<li>一级封锁协议：事务在修改数据之前加写锁，真到事务结束才释放。该协议可以防止丢失修改<br />
</li>
<li>二级封锁协议：在一级封锁协议的基础上，加上了事务在读取数据之前对其加读锁，读完后即可释放读锁。该协议避免了读脏数据<br />
</li>
<li>三级封锁协议：在一级封锁协议的基础上，加上了事务在读取数据之前必须加上读锁，直到事务结束才释放。该协议解决了不可重复读问题</li>
</ol>
<p>范式(normal form):</p>
<p>第一范式要求数据库表中的每一列都是不可分割的原子值，即表中的每个字段都只能存储单一值，不能包含集合、数组或多值字段<br />
第二范式要求数据库表满足第一范式，并且表中的每个非主属性（不属于候选键的属性）必须完全依赖于主键，不能存在<strong>部分依赖</strong>(非主属性依赖于主键的一部分，而不是整个主键)<br />
第三范式要求数据库表满足第二范式，并且表中的每个非主属性必须直接依赖于主键，不能存在<strong>传递依赖</strong>(非主属性依赖于另一个非主属性，而另一个非主属性依赖于主键)<br />
BC范式要求数据库表满足第二范式，并且所有属性（包括主属性）都必须依赖于候选键，任何属性都不能依赖于非候选键，即表中每个非平凡函数依赖(X-&gt;Y，但Y不是X的子集) X → Y 中，X 必须是超键</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>函数依赖</td>
<td>一个属性的值唯一确定另一个属性的值</td>
</tr>
<tr class="even">
<td>部分依赖</td>
<td>非主属性依赖于主键的一部分</td>
</tr>
<tr class="odd">
<td>全依赖</td>
<td>非主属性依赖于主键的全部字段</td>
</tr>
<tr class="even">
<td>传递依赖</td>
<td>非主属性通过另一个非主属性间接依赖于主键</td>
</tr>
<tr class="odd">
<td>多值依赖</td>
<td>一个属性的值确定多个属性的值，但这些属性彼此独立</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>由1NF到2NF，消除了非主属性对主属性的部分函数依赖</li>
<li>由2NF到3NF，消除了非主属性对主属性的传递函数依赖</li>
<li>由3NF到BCNF，消除了主属性对码的部分函数依赖和传递函数依赖</li>
</ol>
<p>常见的启发式优化规则包括:</p>
<ol type="1">
<li>选择性规则:
<ul>
<li>优先选择选择性高的索引或条件,即缩小数据范围的索引或条件</li>
<li>这样可以尽早对数据进行过滤,减少后续处理的数据量</li>
</ul></li>
<li>顺序规则:
<ul>
<li>优先执行成本较低的操作,如索引扫描等</li>
<li>将成本较高的操作,如全表扫描、排序等放在最后执行</li>
</ul></li>
<li>嵌套规则:
<ul>
<li>优先处理内层的子查询或表达式</li>
<li>将外层的操作放在最后执行</li>
</ul></li>
<li>分区规则:
<ul>
<li>优先利用分区表的分区信息进行数据过滤</li>
<li>尽可能缩小扫描的分区范围</li>
</ul></li>
<li>物化视图规则:
<ul>
<li>优先利用已经物化的视图进行查询</li>
<li>可以避免重复计算</li>
</ul></li>
</ol>
<p>同步问题:</p>
<ul>
<li>当前读：像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</li>
<li>快照读：像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</li>
</ul>
<p>MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现<br />
导致 MySQL 索引失效的常见场景：</p>
<ol type="1">
<li>联合索引不满足最左匹配原则</li>
<li>模糊查询最前面的为不确定匹配字符</li>
<li>索引列参与了运算</li>
<li>索引列使用了函数</li>
<li>索引列存在类型转换</li>
<li>索引列使用 is not null 查询</li>
</ol>
<h2 id="os">OS</h2>
<p>操作系统的特征：并发性、共享性、异步性、虚拟性:</p>
<ol type="1">
<li>并发和共享互为存在的条件</li>
<li>虚拟以并发和资源共享为前提：为使并发进程能更方便、更有效地共享资源,操作系统常采用多种虚技未来在逻辑上增加CPU和设备的数量以及存储器的容量，从而解决众多并发进程对有限的系统资源的争用问题</li>
<li>异步性是并发和共享的必然结果</li>
</ol>
<h2 id="ai">ai</h2>
<p>云计算(Cloud Computing)是一种基于互联网的计算模式,它通过网络提供按需获取和使用计算资源的服务。云计算主要包括以下特点:</p>
<ol type="1">
<li>资源共享:
<ul>
<li>云计算将硬件、软件等IT资源集中管理和运营,用户可以按需使用</li>
<li>资源按需分配,提高了资源利用率</li>
</ul></li>
<li>按需服务:
<ul>
<li>用户可以根据实际需求灵活调配和使用云计算资源</li>
<li>按需付费,用多少付多少</li>
</ul></li>
<li>高可用性:
<ul>
<li>云计算平台具有高可靠性和容错性,能确保服务的可用性</li>
<li>能够应对硬件故障、网络中断等情况</li>
</ul></li>
<li>规模弹性:
<ul>
<li>云计算能根据用户需求自动扩展或收缩资源</li>
<li>用户可根据业务需求随时调整资源使用量</li>
</ul></li>
<li>虚拟化:
<ul>
<li>云计算基于虚拟化技术,可将物理硬件抽象为可编程的虚拟资源</li>
<li>提高了资源利用率和管理效率</li>
</ul></li>
</ol>
<p>主要服务模式包括:</p>
<ul>
<li>IaaS(基础设施即服务)</li>
<li>PaaS(平台即服务)</li>
<li>SaaS(软件即服务)</li>
</ul>
<p>区块链(Blockchain)是一种基于分布式账本技术的数字记录系统,具有以下主要特点:</p>
<ol type="1">
<li>分布式账本
<ul>
<li>区块链是一种去中心化的分布式账本,没有单一的中心控制节点</li>
<li>账本信息存储在全网各节点的数据库中,形成分布式的数据存储</li>
</ul></li>
<li>链式数据结构
<ul>
<li>账本信息以时间顺序组织成一个个数据块(区块),并以加密方式链接在一起</li>
<li>每个新区块都包含前一个区块的信息,形成一个不可篡改的链式结构</li>
</ul></li>
<li>加密安全性
<ul>
<li>区块链使用密码学技术(如哈希、数字签名)确保数据的安全性和完整性</li>
<li>一旦记录进入区块链,就难以被删除或篡改</li>
</ul></li>
<li>点对点传输
<ul>
<li>区块链网络采用点对点的通信模式,交易信息在网络中直接传播</li>
<li>不需要中心化的第三方中介机构参与</li>
</ul></li>
<li>共识机制
<ul>
<li>区块链节点通过共识算法(如工作量证明、权益证明等)达成对交易记录的共识</li>
<li>确保整个网络的数据一致性和可靠性</li>
</ul></li>
</ol>
<p>区块链的主要应用包括:</p>
<ul>
<li>加密货币(比特币、以太坊等)</li>
<li>供应链管理</li>
<li>数字资产交易</li>
<li>身份认证</li>
<li>智能合约</li>
</ul>
<p>ai专业名词:</p>
<ul>
<li>损失函数：用于衡量模型预测结果与真实标签之间的差异，如均方误差、交叉熵等，训练的目标是最小化损失函数</li>
<li>优化算法：用于更新模型参数以最小化损失函数的方法，如随机梯度下降及其变种Adagrad、 Adadelta、Adam等</li>
<li>准确率：分类任务中，预测正确的样本数占总样本数的比例</li>
<li>召回率：在分类任务中，真实为正例的样本中被正确预测为正例的比例</li>
<li>F1值：综合考虑准确率和召回率的评估指标，是二者的调和平均数</li>
<li>超参数：在模型训练前需要手动设置的参数，如学习率、迭代次数、神经网络的层数、隐藏层节点数等，它们影响模型的训练过程和最终性能，通常需要通过调参来确定最优值</li>
</ul>
<p>分类(Classification)和聚类(Clustering)区别:</p>
<ol type="1">
<li>监督学习 vs 无监督学习:
<ul>
<li>分类是一种监督学习任务,需要有预先标记的训练数据</li>
<li>聚类是一种无监督学习任务,不需要预先标记的训练数据</li>
</ul></li>
<li>目标不同:
<ul>
<li>分类的目标是将新的数据样本分类到预定义的类别中</li>
<li>聚类的目标是发现数据中自然存在的分组(簇)</li>
</ul></li>
<li>输出形式不同:
<ul>
<li>分类输出的是预定义的类别标签</li>
<li>聚类输出的是数据被划分到的不同簇</li>
</ul></li>
<li>应用场景不同:
<ul>
<li>分类常用于预测任务,如垃圾邮件识别、信用评级等</li>
<li>聚类常用于探索性数据分析,如客户细分、异常检测等</li>
</ul></li>
</ol>
<p>评估:</p>
<ul>
<li>分类任务：准确率（Accuracy）、精确率</li>
<li>(Precision）、召回率（Recall）、F1Score。回归任务：均方误差（MSE）、平均绝对误差(MAE)</li>
<li>泛化能力验证：交叉验证（Cross+ Validation)</li>
</ul>
<p>过拟合（Overfitting）<br />
表现：模型在训练集表现好，测试集差<br />
解决：增加数据量、正则化、减少模型复杂度、早停法（EarlyStopping）<br />
欠拟合（Underfitting）<br />
表现：模型在训练集和测试集均表现差<br />
解决：增加模型复杂度、添加更多特征、减少正则化</p>
<h1 id="科研">科研</h1>
<h2 id="knowledge">knowledge</h2>
<h3 id="梯度">梯度</h3>
<p>梯度的定义和性质如下:<br />
定义: 设 f(x1, x2, ..., xn) 是一个多变量函数, 梯度是一个 n 维列向量:∇f = [∂f/∂x1, ∂f/∂x2, ..., ∂f/∂xn]^T<br />
其中 ∂f/∂xi 表示 f 对 xi 的偏导数<br />
几何意义:</p>
<ul>
<li>梯度指向函数值增长最快的方向</li>
<li>梯度的方向就是函数值增长最快的方向, 梯度的模长就是函数值增长最快的速率</li>
</ul>
<p>性质:</p>
<ul>
<li>梯度为 0 的点是函数的临界点, 可能是极大值、极小值或鞍点</li>
<li>沿着梯度方向移动, 函数值会单调增加</li>
<li>梯度下降法利用这一性质, 通过不断沿负梯度方向移动来求解优化问题的最小值</li>
</ul>
<p>应用:</p>
<ul>
<li>在机器学习中, 梯度被用于训练各种模型, 如线性回归、神经网络等</li>
<li>在优化算法中, 如 Interior-Point 算法中的牛顿法, 梯度被用于计算搜索方向</li>
<li>在数值分析中, 梯度被用于求解偏微分方程</li>
</ul>
<h3 id="r-树">R 树</h3>
<p>一棵 R 树满足如下的性质</p>
<ol type="1">
<li>除非它是根结点之外，所有叶子结点包含有 m 至 M 个记录索引（条目）作为根结点的叶子结点所具有的记录个数可以少于 m通常，m=M/2</li>
<li>对于所有在叶子中存储的记录（条目），I 是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）</li>
<li>每一个非叶子结点拥有 m 至 M 个孩子结点，除非它是根结点</li>
<li>对于在非叶子结点上的每一个条目，i 是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质 2）</li>
<li>所有叶子结点都位于同一层，因此 R 树为平衡树</li>
</ol>
<p>结点：</p>
<ul>
<li>叶子结点所保存的数据形式为：(I, tuple-identifier)
<ul>
<li>其中，tuple-identifier 表示的是一个存放于数据库中的 tuple，也就是一条记录，它是 n 维的I 是一个 n 维空间的矩形，并可以恰好框住这个叶子结点中所有记录代表的 n 维空间中的点</li>
</ul></li>
<li>R 树的非叶子结点存放的数据结构为：(I, child-pointer)
<ul>
<li>其中，child-pointer 是指向孩子结点的指针，I 是覆盖所有孩子结点对应矩形的矩形</li>
</ul></li>
</ul>
<h3 id="hmm">HMM</h3>
<p>HMM 是 Hidden Markov Model 的缩写, 即隐马尔可夫模型它是一种重要的概率图模型, 广泛应用于语音识别、自然语言处理、生物信息学等领域</p>
<p>隐马尔可夫模型的主要特点如下:</p>
<ul>
<li>状态空间: HMM 包含一组隐藏的状态, 这些状态不能直接观测到, 而是通过观测数据来推断</li>
<li>状态转移: 模型在隐藏状态之间进行马尔可夫转移, 即每个状态只依赖于前一个状态</li>
<li>观测概率: 每个隐藏状态都与一个观测数据相关联, 并有一个观测概率分布</li>
</ul>
<p>Top-k Hidden Markov Model (Top-k HMM) 算法是一种用于高效计算 HMM 中 Top-k 概率最高的状态路径的算法它的主要思想如下:</p>
<ul>
<li>初始化: 将 HMM 的初始状态概率分布、转移概率矩阵和观测概率矩阵作为输入 设置需要计算的 Top-k 个状态路径的数量 k</li>
<li>动态规划过程: 使用动态规划的方法, 递推计算每个时刻 t 的 Top-k 状态路径 在每个时刻 t, 保留 Top-k 概率最高的状态路径</li>
<li>回溯过程: 从最后一个时刻 T 开始, 根据保留的 Top-k 状态路径, 逐步回溯得到 Top-k 概率最高的完整状态路径</li>
<li>输出结果: 输出计算得到的 Top-k 概率最高的状态路径</li>
</ul>
<h1 id="编程">编程</h1>
<h2 id="机试参考">机试参考</h2>
<p>devcpp开启调试功能:</p>
<ol type="1">
<li>点击“工具”菜单--编译选项--“代码生成/优化”--连接器--“产生调试信息”为YES,单击“确定”实现调试过程中，选择指定变量，即可显示相应变量的值，并且随着程序的变化而变化</li>
<li>点击”工具“菜单--环境选项--”浏览DEBUG变量“--选择”查看鼠标指向的变量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="vector">vector</h3>
<p><code>vector</code>包含着一系列连续存储的元素,其行为和数组类似。访问Vector中的任意元素或从末尾添加元素都可以在<code>常量级时间复杂度</code>内完成，而查找特定值的元素所处的位置或是在Vector中插入元素则是<code>线性时间复杂度</code></p>
<p>构造函数:</p>
<ul>
<li><code>vector();</code> 无参数 - 构造一个空的vector</li>
<li><code>vector(size_type num);</code> 数量(num) - 构造一个大小为num，值为Type默认值的Vector</li>
<li><code>vector(size_type num, const TYPE &amp;val);</code> 数量(num)和值(val) - 构造一个初始放入num个值为val的元素的Vector</li>
<li><code>vector(const vector &amp;from);</code> vector(from) - 构造一个与vector from 相同的vector</li>
<li><code>vector(input_iterator start, input_iterator end);</code> 迭代器(start)和迭代器(end) - 构造一个初始值为<code>[start,end)</code>区间元素的Vector(注:半开区间).</li>
<li><code>vector(initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());</code>C++11新提供的方法，类似如下方式：
<ul>
<li><code>std::vector&lt;int&gt;a&#123;1, 2, 3, 4, 5&#125;;</code></li>
<li><code>std::vector&lt;int&gt;a = &#123;1, 2, 3, 4, 5&#125;;</code></li>
</ul></li>
</ul>
<p>常用API：</p>
<ul>
<li>Operators : 对vector进行赋值或比较
<ul>
<li><code>v1 == v2</code></li>
<li><code>v1 != v2</code></li>
<li><code>v1 &lt;= v2</code></li>
<li><code>v1 &gt;= v2</code></li>
<li><code>v1 &lt; v2</code></li>
<li><code>v1 &gt; v2</code></li>
<li><code>v[]</code></li>
</ul></li>
<li><code>assign()</code>对Vector中的元素赋值</li>
<li><code>at()</code> : 返回指定位置的元素</li>
<li><code>back()</code> : 返回最末一个元素</li>
<li><code>begin()</code> : 返回第一个元素的迭代器</li>
<li><code>capacity()</code> : 返回vector所能容纳的元素数量(在不重新分配内存的情况下)</li>
<li><code>clear()</code> : 清空所有元素</li>
<li><code>empty()</code> : 判断Vector是否为空（返回true时为空）</li>
<li><code>end()</code> : 返回最末元素的迭代器(译注:实指向最末元素的下一个位置)</li>
<li><code>erase()</code> : 删除指定元素</li>
<li><code>front()</code> : 返回第一个元素</li>
<li><code>get_allocator()</code> : 返回vector的内存分配器</li>
<li><code>insert()</code> : 插入元素到Vector中</li>
<li><code>max_size()</code> : 返回Vector所能容纳元素的最大数量（上限）</li>
<li><code>pop_back()</code> : 移除最后一个元素</li>
<li><code>push_back()</code> : 在Vector最后添加一个元素</li>
<li><code>rbegin()</code> : 返回Vector尾部的逆迭代器</li>
<li><code>rend()</code> : 返回Vector起始的逆迭代器</li>
<li><code>reserve()</code> : 设置Vector最小的元素容纳数量</li>
<li><code>resize()</code> : 改变Vector元素数量的大小</li>
<li><code>size()</code> : 返回Vector元素数量的大小</li>
<li><code>swap()</code> : 交换两个Vector</li>
</ul>
<h3 id="stack">stack</h3>
<p>C++ stack（堆栈）实现了一个<strong>先进后出</strong>（FILO）的数据结构</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stkT;</code> : 采用模板类实现，stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code> : 拷贝构造函数</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>size()</code>: 返回栈中的元素数</li>
<li><code>top()</code>: 返回栈顶的元素</li>
<li><code>pop()</code>: 从栈中取出并删除元素</li>
<li><code>push(x)</code>: 向栈中添加元素x</li>
<li><code>empty()</code>: 在栈为空时返回true</li>
</ul>
<h3 id="set">set</h3>
<p>集合中以一种特定的顺序保存唯一的元素<br />
构造函数:</p>
<ul>
<li><code>set();</code> 无参数 - 构造一个空的set</li>
<li><code>set(InputIterator first, InputIterator last)</code> : 迭代器的方式构造set</li>
<li><code>set(const set &amp;from);</code> : copyd的方式构造一个与set from 相同的set</li>
<li><code>set(input_iterator start, input_iterator end);</code> 迭代器(start)和迭代器(end)</li>
<li>构造一个初始值为<code>[start,end)</code>区间元素的Vector(注:半开区间)</li>
<li><code>set (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());</code>C++11新提供的方法，类似如下方式：
<ul>
<li><code>std::set&lt;int&gt;a&#123;1, 2, 3, 4, 5&#125;;</code></li>
</ul></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>begin()</code> : 返回指向第一个元素的迭代器</li>
<li><code>clear()</code> : 清除所有元素</li>
<li><code>count()</code> : 返回某个值元素的个数</li>
<li><code>empty()</code> : 如果集合为空，返回true</li>
<li><code>end()</code> : 返回指向最后一个元素的迭代器</li>
<li><code>equal_range()</code> : 返回集合中与给定值相等的上下限的两个迭代器</li>
<li><code>erase()</code> : 删除集合中的元素</li>
<li><code>find()</code> : 返回一个指向被查找到元素的迭代器</li>
<li><code>get_allocator()</code> : 返回集合的分配器</li>
<li><code>insert()</code> : 在集合中插入元素</li>
<li><code>lower_bound()</code> : 返回指向大于（或等于）某值的第一个元素的迭代器</li>
<li><code>key_comp()</code> : 返回一个用于元素间值比较的函数</li>
<li><code>max_size()</code> : 返回集合能容纳的元素的最大限值</li>
<li><code>rbegin()</code> : 返回指向集合中最后一个元素的反向迭代器</li>
<li><code>rend()</code> : 返回指向集合中第一个元素的反向迭代器</li>
<li><code>size()</code> : 集合中元素的数目</li>
<li><code>swap()</code> : 交换两个集合变量</li>
<li><code>upper_bound()</code> : 返回大于某个值元素的迭代器</li>
<li><code>value_comp()</code> : 返回一个用于比较元素间的值的函数</li>
</ul>
<h4 id="unordered_set">unordered_set</h4>
<table>
<thead>
<tr class="header">
<th><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#begin"><code>begin</code></a></th>
<th>指定受控序列的开头</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#bucket"><code>bucket</code></a></td>
<td>获取键值的存储桶编号</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#bucket_count"><code>bucket_count</code></a></td>
<td>获取存储桶数</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#bucket_size"><code>bucket_size</code></a></td>
<td>获取存储桶的大小</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#cbegin"><code>cbegin</code></a></td>
<td>指定受控序列的开头</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#cend"><code>cend</code></a></td>
<td>指定受控序列的末尾</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#clear"><code>clear</code></a></td>
<td>删除所有元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#contains"><code>contains</code></a></td>
<td>检查 <code>unordered_set</code> 中是否包含具有指定键的元素。</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#count"><code>count</code></a></td>
<td>查找与指定键匹配的元素数，非multi的情况下非0即1。</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#emplace"><code>emplace</code></a></td>
<td>添加就地构造的元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#emplace_hint"><code>emplace_hint</code></a></td>
<td>添加就地构造的元素，附带提示</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#empty"><code>empty</code></a></td>
<td>测试元素是否存在</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#end"><code>end</code></a></td>
<td>指定受控序列的末尾</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#equal_range"><code>equal_range</code></a></td>
<td>查找与指定键匹配的范围</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#erase"><code>erase</code></a></td>
<td>移除指定位置处的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#find"><code>find</code></a></td>
<td>查找与指定键匹配的元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#get_allocator"><code>get_allocator</code></a></td>
<td>获取存储的分配器对象</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#hash"><code>hash_function</code></a></td>
<td>获取存储的哈希函数对象</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#insert"><code>insert</code></a></td>
<td>添加元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#key_eq"><code>key_eq</code></a></td>
<td>获取存储的比较函数对象</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#load_factor"><code>load_factor</code></a></td>
<td>对每个存储桶的平均元素数进行计数</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#max_bucket_count"><code>max_bucket_count</code></a></td>
<td>获取最大的存储桶数</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#max_load_factor"><code>max_load_factor</code></a></td>
<td>获取或设置每个存储桶的最多元素数</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#max_size"><code>max_size</code></a></td>
<td>获取受控序列的最大大小</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#rehash"><code>rehash</code></a></td>
<td>重新生成哈希表</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#size"><code>size</code></a></td>
<td>对元素数进行计数</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#swap"><code>swap</code></a></td>
<td>交换两个容器的内容</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-set-class?view=msvc-170#unordered_set"><code>unordered_set</code></a></td>
<td>构造容器对象</td>
</tr>
</tbody>
</table>
<h3 id="queue">queue</h3>
<p>C++队列是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构</p>
<p>构造函数：</p>
<ul>
<li><code>explicit queue (const container_type&amp; ctnr);</code></li>
<li><code>explicit queue (container_type&amp;&amp; ctnr = container_type());</code></li>
<li><code>template &lt;class Alloc&gt; explicit queue (const Alloc&amp; alloc);</code></li>
<li><code>template &lt;class Alloc&gt; queue (const container_type&amp; ctnr, const Alloc&amp; alloc);</code></li>
<li><code>template &lt;class Alloc&gt; queue (container_type&amp;&amp; ctnr, const Alloc&amp; alloc);</code></li>
<li><code>template &lt;class Alloc&gt; queue (const queue&amp; x, const Alloc&amp; alloc);</code></li>
<li><code>template &lt;class Alloc&gt; queue (queue&amp;&amp; x, const Alloc&amp; alloc);</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>back()</code> : 返回最后一个元素</li>
<li><code>empty()</code> : 如果队列空则返回真</li>
<li><code>front()</code> : 返回第一个元素</li>
<li><code>pop()</code> : 删除第一个元素</li>
<li><code>push()</code> : 在末尾加入一个元素</li>
<li><code>size()</code> : 返回队列中元素的个数</li>
</ul>
<h3 id="list">list</h3>
<p>Lists将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢.</p>
<p>构造函数：</p>
<ul>
<li><code>list (const allocator_type&amp; alloc = allocator_type());</code></li>
<li><code>list (size_type n, const value_type&amp; val = value_type(), const allocator_type&amp; alloc = allocator_type());</code></li>
<li><code>template &lt;class InputIterator&gt; list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());</code></li>
<li><code>list (const list&amp; x);</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>assign()</code> : 给list赋值</li>
<li><code>back()</code> : 返回最后一个元素</li>
<li><code>begin()</code> : 返回指向第一个元素的迭代器</li>
<li><code>clear()</code> : 删除所有元素</li>
<li><code>empty()</code> : 如果list是空的则返回true</li>
<li><code>end()</code> : 返回末尾的迭代器</li>
<li><code>erase()</code> : 删除一个元素</li>
<li><code>front()</code> : 返回第一个元素</li>
<li><code>get_allocator()</code> : 返回list的配置器</li>
<li><code>insert()</code> : 插入一个元素到list中</li>
<li><code>max_size()</code> : 返回list能容纳的最大元素数量</li>
<li><code>merge()</code> : 合并两个list</li>
<li><code>pop_back()</code> : 删除最后一个元素</li>
<li><code>pop_front()</code> : 删除第一个元素</li>
<li><code>push_back()</code> : 在list的末尾添加一个元素</li>
<li><code>push_front()</code> : 在list的头部添加一个元素</li>
<li><code>rbegin()</code> : 返回指向第一个元素的逆向迭代器</li>
<li><code>remove()</code> : 从list删除元素</li>
<li><code>remove_if()</code> : 按指定条件删除元素</li>
<li><code>rend()</code> : 指向list末尾的逆向迭代器</li>
<li><code>resize()</code> : 改变list的大小</li>
<li><code>reverse()</code> : 把list的元素倒转</li>
<li><code>size()</code> : 返回list中的元素个数</li>
<li><code>sort()</code> : 给list排序</li>
<li><code>splice()</code> : 合并两个list</li>
<li><code>swap()</code> : 交换两个list</li>
<li><code>unique()</code> : 删除list中重复的元素</li>
</ul>
<h3 id="map">map</h3>
<p>C++ Maps是一种关联式容器，包含“关键字/值”对</p>
<p>构造函数：</p>
<ul>
<li><code>map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());</code></li>
<li><code>template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last,const key_compare&amp; comp = key_compare(),const allocator_type&amp; = allocator_type());</code></li>
<li><code>map (const map&amp; x);</code></li>
<li><code>map (const map&amp; x, const allocator_type&amp; alloc);</code></li>
<li><code>map (map&amp;&amp; x);</code></li>
<li><code>map (map&amp;&amp; x, const allocator_type&amp; alloc);</code></li>
<li><code>map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>begin()</code> : 返回指向map头部的迭代器</li>
<li><code>clear()</code> : 删除所有元素</li>
<li><code>count()</code> : 返回指定元素出现的次数</li>
<li><code>empty()</code> : 如果map为空则返回true</li>
<li><code>end()</code> : 返回指向map末尾的迭代器</li>
<li><code>equal_range()</code> : 返回特殊条目的迭代器对</li>
<li><code>erase()</code> : 删除一个元素</li>
<li><code>find()</code> : 查找一个元素</li>
<li><code>get_allocator()</code> : 返回map的配置器</li>
<li><code>insert()</code> : 插入元素</li>
<li><code>key_comp()</code> : 返回比较元素key的函数</li>
<li><code>lower_bound()</code> : 返回键值&gt;=给定元素的第一个位置</li>
<li><code>max_size()</code> : 返回可以容纳的最大元素个数</li>
<li><code>rbegin()</code> : 返回一个指向map尾部的逆向迭代器</li>
<li><code>rend()</code> : 返回一个指向map头部的逆向迭代器</li>
<li><code>size()</code> : 返回map中元素的个数</li>
<li><code>swap()</code> : 交换两个map</li>
<li><code>upper_bound()</code> : 返回键值&gt;给定元素的第一个位置</li>
<li><code>value_comp()</code> : 返回比较元素value的函数</li>
</ul>
<h4 id="unordered_map">unordered_map</h4>
<table>
<thead>
<tr class="header">
<th>类型定义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#allocator_type"><code>allocator_type</code></a></td>
<td>用于管理存储的分配器的类型</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#const_iterator"><code>const_iterator</code></a></td>
<td>受控序列的常量迭代器的类型</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#const_local_iterator"><code>const_local_iterator</code></a></td>
<td>受控序列的常量存储桶迭代器的类型</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#const_pointer"><code>const_pointer</code></a></td>
<td>元素的常量指针的类型</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#const_reference"><code>const_reference</code></a></td>
<td>元素的常量引用的类型</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#difference_type"><code>difference_type</code></a></td>
<td>两个元素间的带符号距离的类型</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#hasher"><code>hasher</code></a></td>
<td>哈希函数的类型</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#iterator"><code>iterator</code></a></td>
<td>受控序列的迭代器的类型</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#key_equal"><code>key_equal</code></a></td>
<td>比较函数的类型</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#key_type"><code>key_type</code></a></td>
<td>排序键的类型</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#local_iterator"><code>local_iterator</code></a></td>
<td>受控序列的存储桶迭代器的类型</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#mapped_type"><code>mapped_type</code></a></td>
<td>与每个键关联的映射值的类型</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#pointer"><code>pointer</code></a></td>
<td>指向元素的指针的类型</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#reference"><code>reference</code></a></td>
<td>元素的引用的类型</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#size_type"><code>size_type</code></a></td>
<td>两个元素间的无符号距离的类型</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#value_type"><code>value_type</code></a></td>
<td>元素的类型</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>成员函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#at"><code>at</code></a></td>
<td>查找具有指定键的元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#begin"><code>begin</code></a></td>
<td>指定受控序列的开头</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#bucket"><code>bucket</code></a></td>
<td>获取键值的存储桶编号</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#bucket_count"><code>bucket_count</code></a></td>
<td>获取存储桶数</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#bucket_size"><code>bucket_size</code></a></td>
<td>获取存储桶的大小</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#cbegin"><code>cbegin</code></a></td>
<td>指定受控序列的开头</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#cend"><code>cend</code></a></td>
<td>指定受控序列的末尾</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#clear"><code>clear</code></a></td>
<td>删除所有元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#count"><code>count</code></a></td>
<td>查找与指定键匹配的元素数</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#contains"><code>contains</code></a></td>
<td>检查 <code>unordered_map</code> 中是否包含具有指定键的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#emplace"><code>emplace</code></a></td>
<td>添加就地构造的元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#emplace_hint"><code>emplace_hint</code></a></td>
<td>添加就地构造的元素，附带提示</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#empty"><code>empty</code></a></td>
<td>测试元素是否存在</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#end"><code>end</code></a></td>
<td>指定受控序列的末尾</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#equal_range"><code>equal_range</code></a></td>
<td>查找与指定键匹配的范围</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#erase"><code>erase</code></a></td>
<td>移除指定位置处的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#find"><code>find</code></a></td>
<td>查找与指定键匹配的元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#get_allocator"><code>get_allocator</code></a></td>
<td>获取存储的分配器对象</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#hash"><code>hash_function</code></a></td>
<td>获取存储的哈希函数对象</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#insert"><code>insert</code></a></td>
<td>添加元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#key_eq"><code>key_eq</code></a></td>
<td>获取存储的比较函数对象</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#load_factor"><code>load_factor</code></a></td>
<td>对每个存储桶的平均元素数进行计数</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#max_bucket_count"><code>max_bucket_count</code></a></td>
<td>获取最大的存储桶数</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#max_load_factor"><code>max_load_factor</code></a></td>
<td>获取或设置每个存储桶的最多元素数</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#max_size"><code>max_size</code></a></td>
<td>获取受控序列的最大大小</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#rehash"><code>rehash</code></a></td>
<td>重新生成哈希表</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#size"><code>size</code></a></td>
<td>对元素数进行计数</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#swap"><code>swap</code></a></td>
<td>交换两个容器的内容</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#unordered_map"><code>unordered_map</code></a></td>
<td>构造容器对象</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#op_at"><code>unordered_map::operator[]</code></a></td>
<td>查找或插入具有指定键的元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unordered-map-class?view=msvc-170#op_eq"><code>unordered_map::operator=</code></a></td>
<td>复制哈希表</td>
</tr>
</tbody>
</table>
<h3 id="string">string</h3>
<p>c++字符串数组需要指定长度，如<code>vec.push_back(string(1,char c))</code> ，将字符串转化为字面数字需要用<code>stoi</code>(来自string库)函数 栈3</p>
<h4 id="string构造函数">1.string构造函数</h4>
<ul>
<li><code>string();</code>//创建一个空的字符串</li>
<li><code>string(const string&amp; str);</code>//使用一个string对象初始化另一个string对象</li>
<li><code>string(const char* s);</code>//使用字符串s初始化</li>
<li><code>string(int n,char c);</code>//使用n个字符c初始化</li>
</ul>
<h4 id="string基本赋值操作">2.string基本赋值操作</h4>
<ul>
<li><code>string&amp; operator=(const char* s);</code>//char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>//把字符串s赋值给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>//字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char* s);</code>//把字符串s赋值给当前的字符串</li>
<li><code>string&amp; assign(const char* s,int n);</code>//把字符串s的前n个字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>//把字符串s赋值给当前的字符串</li>
<li><code>string&amp; assign(int n,char c);</code>//用n个字符c赋值给当前字符串</li>
<li><code>string&amp; assign(const string &amp;s,int start,int n);</code>//将s从start开始n个字符赋值给字符串</li>
</ul>
<h4 id="string存取字符操作">3.string存取字符操作</h4>
<ul>
<li><code>char&amp; operator[](int n);</code>//通过<code>[]</code>方式取字符</li>
<li><code>char&amp; at(int n);</code>//通过at方法获取字符</li>
</ul>
<h4 id="string拼接操作">4.string拼接操作</h4>
<ul>
<li><code>string&amp; operator+=(const string&amp; str);</code>//重载+=运算符</li>
<li><code>string&amp; operator+=(const char* str);</code>//重载+=运算符</li>
<li><code>string&amp; operator+=(const char c);</code>//重载+=运算符</li>
<li><code>string&amp; append(const char *s);</code>//把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s,int n);</code>//把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>//同operator+=（）</li>
<li><code>string&amp; append(const string &amp;s,int pos,int n);</code>//把字符串s中从pos开始的n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(int n,char c);</code>//在当前字符串结尾添加n个字符c</li>
</ul>
<h4 id="string查找和替换">5.string查找和替换</h4>
<ul>
<li><code>int find(const string&amp; str,int pos = 0)const;</code>//查找str第一次出现的位置，从pos开始查找</li>
<li><code>int find(const char* s,int pos = 0)const;</code>//查找s第一次出现位置，从pos开始查找</li>
<li><code>int find(const char *s,int pos,int n)const;</code>//从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c,int pos = 0)const;</code>//查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos)const;</code>//查找str最后一次出现位置，从pos开始查找</li>
<li><code>int rfind(const char* s,int pos = npos)const;</code>//查找s最后一次出现位置，从pos开始查找</li>
<li><code>int rfind(const char* s,int pos,int n )const;</code>//从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c,int pos = 0)const;</code>//查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos,int n,const string&amp; str);</code>//替换从pos开始的n个字符为字符串str</li>
<li><code>string&amp; replace(int pos,int n,const char* s);</code>//替换从pos开始的n个字符为字符串s</li>
</ul>
<h4 id="string-比较操作">6.string 比较操作</h4>
<ul>
<li><code>int compare(const string &amp;s)const;</code>//与字符串s比较</li>
<li><code>int compare(const char*s)const;</code>//与字符串s比较</li>
<li>compare函数在&gt;时返回1，&lt;时返回-1，相等时返回0，比较区分大小写，逐个字符比较</li>
</ul>
<h4 id="string子串">7.string子串</h4>
<ul>
<li><code>string substr(int pos = 0,int n = npos)const;</code>//返回由pos开始的n个字符组成的字符串</li>
</ul>
<h4 id="string插入和删除操作">8.string插入和删除操作</h4>
<ul>
<li><code>string&amp; insert(int pos,const char* s);</code>//插入字符串</li>
<li><code>string&amp; insert(int pos,const string &amp;str);</code>//插入字符串</li>
<li><code>string&amp; insert(int pos,int n,char c);</code>//在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos,int n = npos);</code>//删除从pos开始的n个字符</li>
</ul>
<h3 id="deque">deque</h3>
<p>deque是Double-Ended Queues(双向队列)的缩写</p>
<p>双向队列和向量很相似，但是它允许在容器头部快速插入和删除（就像在尾部一样）</p>
<h4 id="deque构造函数">1.deque构造函数</h4>
<ul>
<li><code>deque&lt;T&gt; queT;</code>//queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>deque&lt;T&gt; queT(size);</code>//构造大小为size的deque，其中值为T类型的默认值</li>
<li><code>deque&lt;T&gt; queT(size, val);</code>//构造大小为size的deque，其中值为val</li>
<li><code>deque(const deque &amp;que);</code>//拷贝构造函数</li>
<li><code>deque(input_iterator start, input_iterator end);</code>//迭代器构造函数</li>
</ul>
<h4 id="deque存取插入和删除操作">2.deque存取、插入和删除操作</h4>
<ul>
<li><code>back();</code>//返回最后一个元素</li>
<li><code>front();</code>//返回第一个元素</li>
<li><code>insert();</code>//</li>
<li><code>pop_back();</code>//删除尾部的元素</li>
<li><code>pop_front();</code>//删除头部的元素</li>
<li><code>push_back();</code>//在尾部加入一个元素</li>
<li><code>push_front();</code>//在头部加入一个元素</li>
<li><code>at();</code>//访问指定位置元素</li>
</ul>
<h4 id="deque赋值操作">3.deque赋值操作</h4>
<ul>
<li><code>operator[] (size_type n);</code>//重载[]操作符</li>
</ul>
<h4 id="deque大小操作">4.deque大小操作</h4>
<ul>
<li><code>empty()</code>;//判断队列是否为空</li>
<li><code>size()</code>;//返回队列的大小</li>
</ul>
<h3 id="priority_queue">priority_queue</h3>
<p>优先队列类似队列， 但是在这个数据结构中的元素按照一定的规则排列有序</p>
<p>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有<strong>最高优先级先出</strong> （first in, largest out）的行为特征</p>
<p>首先要包含头文件<code>#include&lt;queue&gt;</code>, 他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队</p>
<p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它<strong>本质是一个堆实现的</strong></p>
<p>构造函数： <code>priority_queue&lt;Type, Container, Functional&gt;</code></p>
<ul>
<li>Type 就是数据类型，</li>
<li>Container 就是容器类型（Container必须是具备<strong>随机存取</strong>能力的容器，支持如下方法：<code>empty()</code>, <code>size()</code>, <code>front()</code>, <code>push_back()</code>,<code>pop_back()</code>。比如vector,deque等等，但不能用list。STL里面默认用的是vector）。可选</li>
<li>Functional 就是比较的方式。可选</li>
</ul>
<p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆(Functional是less)</p>
<p>api和队列基本操作相同:</p>
<ul>
<li><code>top</code> 访问队头元素</li>
<li><code>empty</code> 队列是否为空</li>
<li><code>size</code> 返回队列内元素个数</li>
<li><code>push</code> 插入元素到队尾 (并排序)</li>
<li><code>emplace</code> 原地构造一个元素并插入队列</li>
<li><code>pop</code> 弹出队头元素</li>
<li><code>swap</code> 交换内容</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">cpp vector</a></p>
<h3 id="algorithm">algorithm</h3>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#adjacent_find"><code>adjacent_find</code></a></th>
<th>搜索相等或满足指定条件的两个相邻元素</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#all_of"><code>all_of</code></a></td>
<td>当给定范围中的每个元素均满足条件时返回 <strong><code>true</code></strong></td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#any_of"><code>any_of</code></a></td>
<td>当指定元素范围中至少有一个元素满足条件时返回 <strong><code>true</code></strong></td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#binary_search"><code>binary_search</code></a></td>
<td>测试已排序的范围中是否有等于指定值的元素，或在二元谓词指定的意义上与指定值等效的元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#clamp"><code>clamp</code></a></td>
<td></td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#copy"><code>copy</code></a></td>
<td>将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向前方向的新位置</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#copy_backward"><code>copy_backward</code></a></td>
<td>将一个源范围中的元素值分配到目标范围，循环访问元素的源序列并将它们分配在一个向后方向的新位置</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#copy_if"><code>copy_if</code></a></td>
<td>复制给定范围中对于指定条件为 <strong><code>true</code></strong> 的所有元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#copy_n"><code>copy_n</code></a></td>
<td>复制指定数量的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#count"><code>count</code></a></td>
<td>返回范围中其值与指定值匹配的元素的数量</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#count_if"><code>count_if</code></a></td>
<td>返回范围中其值与指定条件匹配的元素的数量</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#equal"><code>equal</code></a></td>
<td>逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#equal_range"><code>equal_range</code></a></td>
<td>在排序的范围中查找符合以下条件的位置对：第一个位置小于或等效于指定元素的位置，第二个位置大于此元素位置，等效意义或用于在序列中建立位置的排序可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#fill"><code>fill</code></a></td>
<td>将相同的新值分配给指定范围中的每个元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#fill_n"><code>fill_n</code></a></td>
<td>将新值分配给以特定元素开始的范围中的指定数量的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find"><code>find</code></a></td>
<td>在范围中找到具有指定值的元素的第一个匹配项位置</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find_end"><code>find_end</code></a></td>
<td>在范围中查找与指定序列相同的最后一个序列，或在二元谓词指定的意义上等效的最后一个序列</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find_first_of"><code>find_first_of</code></a></td>
<td>在目标范围中搜索若干值中任意值的第一个匹配项，或搜索在二元谓词指定的意义上等效于指定元素集的若干元素中任意元素的第一个匹配项</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find_if"><code>find_if</code></a></td>
<td>在范围中找到满足指定条件的元素的第一个匹配项位置</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#find_if_not"><code>find_if_not</code></a></td>
<td>返回指示的范围中不满足条件的第一个元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#for_each"><code>for_each</code></a></td>
<td>将指定的函数对象按向前顺序应用于范围中的每个元素并返回此函数对象</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#for_each_n"><code>for_each_n</code></a></td>
<td></td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#generate"><code>generate</code></a></td>
<td>将函数对象生成的值分配给范围中的每个元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#generate_n"><code>generate_n</code></a></td>
<td>将函数对象生成的值分配给范围中指定数量的元素，并返回到超出最后一个分配值的下一位置</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#includes"><code>includes</code></a></td>
<td>测试一个排序的范围是否包含另一排序范围中的所有元素，其中元素之间的排序或等效条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#inplace_merge"><code>inplace_merge</code></a></td>
<td>将两个连续的排序范围中的元素合并为一个排序范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_heap"><code>is_heap</code></a></td>
<td>如果指定范围中的元素形成堆，则返回 <strong><code>true</code></strong></td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_heap_until"><code>is_heap_until</code></a></td>
<td>如果指定范围形成直到最后一个元素的堆，则返回 <strong><code>true</code></strong></td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_partitioned"><code>is_partitioned</code></a></td>
<td>如果给定范围中对某个条件测试为 <strong><code>true</code></strong> 的所有元素在测试为 <strong><code>true</code></strong> 的所有元素之前，则返回 <strong><code>false</code></strong></td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_permutation"><code>is_permutation</code></a></td>
<td>确定给定范围的元素是否形成有效排列</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_sorted"><code>is_sorted</code></a></td>
<td>如果指定范围中的元素按顺序排序，则返回 <strong><code>true</code></strong></td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#is_sorted_until"><code>is_sorted_until</code></a></td>
<td>如果指定范围中的元素按顺序排序，则返回 <strong><code>true</code></strong></td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#iter_swap"><code>iter_swap</code></a></td>
<td>交换由一对指定迭代器引用的两个值</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#lexicographical_compare"><code>lexicographical_compare</code></a></td>
<td>逐个元素比较两个序列以确定其中的较小序列</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#lower_bound"><code>lower_bound</code></a></td>
<td>在排序的范围中查找其值大于或等效于指定值的第一个元素的位置，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#make_heap"><code>make_heap</code></a></td>
<td>将指定范围中的元素转换到第一个元素是最大元素的堆中，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#max"><code>max</code></a></td>
<td>比较两个对象并返回较大对象，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#max_element"><code>max_element</code></a></td>
<td>在指定范围中查找最大元素的第一个匹配项，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#merge"><code>merge</code></a></td>
<td>将两个排序的源范围中的所有元素合并为一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#min"><code>min</code></a></td>
<td>比较两个对象并返回较小对象，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#min_element"><code>min_element</code></a></td>
<td>在指定范围中查找最小元素的第一个匹配项，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#minmax"><code>minmax</code></a></td>
<td>比较两个输入参数，并按最小到最大的顺序将它们作为参数对返回</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#minmax_element"><code>minmax_element</code></a></td>
<td>在一次调用中执行由 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#min_element"><code>min_element</code></a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#max_element"><code>max_element</code></a> 执行的操作</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#mismatch"><code>mismatch</code></a></td>
<td>逐个元素比较两个范围是否相等或是否在二元谓词指定的意义上等效，并找到出现不同的第一个位置</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#alg_move"><code>&lt;alg&gt; move</code></a></td>
<td>移动与指定范围关联的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#move_backward"><code>move_backward</code></a></td>
<td>将一个迭代器的元素移动到另一迭代器移动从指定范围的最后一个元素开始，并在此范围的第一个元素结束</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#next_permutation"><code>next_permutation</code></a></td>
<td>重新排序范围中的元素，以便使用按字典顺序的下一个更大排列（如果有）替换原有排序，其中“下一个”的意义可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#none_of"><code>none_of</code></a></td>
<td>当给定范围中没有元素满足条件时返回 <strong><code>true</code></strong></td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#nth_element"><code>nth_element</code></a></td>
<td>对范围内的元素分区，正确找到范围中序列的第 <em>n</em> 个元素，以使序列中位于此元素之前的所有元素小于或等于此元素，位于此元素之后的所有元素大于或等于此元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partial_sort"><code>partial_sort</code></a></td>
<td>将范围中指定数量的较小元素按非降序顺序排列，或根据二元谓词指定的排序条件排列</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partial_sort_copy"><code>partial_sort_copy</code></a></td>
<td>将源范围中的元素复制到目标范围，其中源元素按降序或二元谓词指定的其他顺序排序</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partition"><code>partition</code></a></td>
<td>将范围中的元素分为两个不相交的集，满足一元谓词的元素在不满足一元谓词的元素之前</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partition_copy"><code>partition_copy</code></a></td>
<td>将条件为 <strong><code>true</code></strong> 的元素复制到一个目标，将条件为 <strong><code>false</code></strong> 的元素复制到另一目标元素必须来自于指定范围</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#partition_point"><code>partition_point</code></a></td>
<td>返回给定范围中不满足条件的第一个元素元素经过排序，满足条件的元素在不满足条件的元素之前</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#pop_heap"><code>pop_heap</code></a></td>
<td>移除从堆顶到范围中倒数第二个位置之间的最大元素，然后将剩余元素形成新堆</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#prev_permutation"><code>prev_permutation</code></a></td>
<td>重新排序范围中的元素，以便使用按字典顺序的下一个更大排列（如果有）替换原有排序，其中“下一个”的意义可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#push_heap"><code>push_heap</code></a></td>
<td>将范围末尾的元素添加到包括范围中前面元素的现有堆中</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#random_shuffle"><code>random_shuffle</code></a></td>
<td>将范围中 <em>N</em> 个元素的序列重新排序为随机 <em>N</em>! 种序列中的 可能排列之一</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#remove"><code>remove</code></a></td>
<td>从给定范围中消除指定值，而不影响剩余元素的顺序，并返回不包含指定值的新范围的末尾</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#remove_copy"><code>remove_copy</code></a></td>
<td>将源范围中的元素复制到目标范围（不复制具有指定值的元素），而不影响剩余元素的顺序，并返回新目标范围的末尾</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#remove_copy_if"><code>remove_copy_if</code></a></td>
<td>将源范围中的元素复制到目标范围（不复制满足谓词的元素），而不影响剩余元素的顺序，并返回新目标范围的末尾</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#remove_if"><code>remove_if</code></a></td>
<td>从给定范围中消除满足谓词的元素，而不影响剩余元素的顺序，并返回不包含指定值的新范围的末尾</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#replace"><code>replace</code></a></td>
<td>检查范围中的每个元素，并替换与指定值匹配的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#replace_copy"><code>replace_copy</code></a></td>
<td>检查源范围中的每个元素，并替换与指定值匹配的元素，同时将结果复制到新的目标范围</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#replace_copy_if"><code>replace_copy_if</code></a></td>
<td>检查源范围中的每个元素，并替换满足指定谓词的元素，同时将结果复制到新的目标范围</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#replace_if"><code>replace_if</code></a></td>
<td>检查范围中的每个元素，并替换满足指定谓词的元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#reverse"><code>reverse</code></a></td>
<td>反转范围中元素的顺序</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#reverse_copy"><code>reverse_copy</code></a></td>
<td>反转源范围中元素的顺序，同时将这些元素复制到目标范围</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#rotate"><code>rotate</code></a></td>
<td>交换两个相邻范围中的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#rotate_copy"><code>rotate_copy</code></a></td>
<td>交换源范围中两个相邻范围内的元素，并将结果复制到目标范围</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#sample"><code>sample</code></a></td>
<td></td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#search"><code>search</code></a></td>
<td>在目标范围中搜索其元素与给定序列中的元素相等或在二元谓词指定的意义上等效于给定序列中的元素的序列的第一个匹配项</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#search_n"><code>search_n</code></a></td>
<td>在范围中搜索具有特定值或按二元谓词的指定与此值相关的指定数量的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#set_difference"><code>set_difference</code></a></td>
<td>将属于一个排序的源范围、但不属于另一排序的源范围的所有元素相并到一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#set_intersection"><code>set_intersection</code></a></td>
<td>将属于两个排序的源范围的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#set_symmetric_difference"><code>set_symmetric_difference</code></a></td>
<td>将属于一个而不是两个排序的源范围的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#set_union"><code>set_union</code></a></td>
<td>将至少属于两个排序的源范围之一的所有元素相并为一个排序的目标范围，其中排序条件可通过二元谓词指定</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#sort"><code>sort</code></a></td>
<td>将指定范围中的元素按非降序顺序排列，或根据二元谓词指定的排序条件排列</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#shuffle"><code>shuffle</code></a></td>
<td>使用随机数生成器重新排列给定范围中的元素</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#sort_heap"><code>sort_heap</code></a></td>
<td>将堆转换为排序的范围</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#stable_partition"><code>stable_partition</code></a></td>
<td>将范围中的元素分为两个不相交的集，满足一元谓词的元素在不满足一元谓词的元素之前，并保留等效元素的相对顺序</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#stable_sort"><code>stable_sort</code></a></td>
<td>将指定范围中的元素按非降序顺序排列，或根据二元谓词指定的排序条件排列，并保留等效元素的相对顺序</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#swap"><code>swap</code></a></td>
<td>在两种类型的对象之间交换元素值，将第一个对象的内容分配给第二个对象，将第二个对象的内容分配给第一个对象</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#swap_ranges"><code>swap_ranges</code></a></td>
<td>将一个范围中的元素与另一大小相等的范围中的元素交换</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#transform"><code>transform</code></a></td>
<td>将指定的函数对象应用于源范围中的每个元素或两个源范围中的元素对，并将函数对象的返回值复制到目标范围</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#unique"><code>unique</code></a></td>
<td>移除指定范围中彼此相邻的重复元素</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#unique_copy"><code>unique_copy</code></a></td>
<td>将源范围中的元素复制到目标范围，彼此相邻的重复元素除外</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm-functions?view=msvc-170#upper_bound"><code>upper_bound</code></a></td>
<td>在排序的范围中查找其值大于指定值的第一个元素的位置，其中排序条件可通过二元谓词指定</td>
</tr>
</tbody>
</table>
<h3 id="functional">functional</h3>
<p>提供一系列有用的函数对象，包括常用的二元谓词(由于是模板函数，使用需要提供类型)</p>
<table>
<thead>
<tr class="header">
<th><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/binary-function-struct?view=msvc-170">binary_function</a></th>
<th>空基类，定义可能由提供二元函数对象的派生类继承的类型<br> （在 C++11 中已弃用，在 C++17 中已移除）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/divides-struct?view=msvc-170">divides</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行除法算术运算</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/equal-to-struct?view=msvc-170">equal_to</a></td>
<td>此二元谓词测试指定类型的一个值是否等于该类型的另一个值</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/greater-struct?view=msvc-170">greater</a></td>
<td>此二元谓词测试指定类型的一个值是否大于该类型的另一个值</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/greater-equal-struct?view=msvc-170">greater_equal</a></td>
<td>此二元谓词测试指定类型的一个值是否大于或等于该类型的另一个值</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/less-struct?view=msvc-170">less</a></td>
<td>此二元谓词测试指定类型的一个值是否小于该类型的另一个值</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/less-equal-struct?view=msvc-170">less_equal</a></td>
<td>此二元谓词测试指定类型的一个值是否小于或等于该类型的另一个值</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/logical-and-struct?view=msvc-170">logical_and</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行合取逻辑运算，并测试结果是 ture 还是 false</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/logical-not-struct?view=msvc-170">logical_not</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行求反逻辑运算，并测试结果是 ture 还是 false</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/logical-or-struct?view=msvc-170">logical_or</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行析取逻辑运算，并测试结果是 ture 还是 false</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/minus-struct?view=msvc-170">minus</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行减法算术运算</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/modulus-struct?view=msvc-170">取模</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行取模算术运算</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/multiplies-struct?view=msvc-170">multiplies</a></td>
<td>此类提供预定义的函数对象，后者对指定值类型的元素执行乘法算术运算</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/negate-struct?view=msvc-170">negate</a></td>
<td>此类提供预定义的函数对象，后者返回元素值的负值</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/not-equal-to-struct?view=msvc-170">not_equal_to</a></td>
<td>此二元谓词测试指定类型的一个值是否不等于该类型的另一个值</td>
</tr>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/plus-struct?view=msvc-170">plus</a></td>
<td>此类提供预定义的函数对象，后对指定值类型的元素执行加法算术运算</td>
</tr>
<tr class="even">
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/unary-function-struct?view=msvc-170">unary_function</a></td>
<td>空基类，定义可能由提供一元函数对象的派生类继承的类型<br> （在 C++11 中已弃用，在 C++17 中已移除）</td>
</tr>
</tbody>
</table>
<h2 id="算法范式">算法范式</h2>
<p>来自<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_backtracking">hello-algo</a></p>
<h3 id="回溯">回溯</h3>
<p>之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择<br />
例如在二叉树查找值为7的节点:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 前序遍历：例题二 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 尝试</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == <span class="number">7</span>) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上是最标准的回溯，通俗易懂地说就是穷举，对比较复杂的问题很容易就能超过多项式复杂度，到达阶乘这种程度<br />
因此需要考虑对其的优化，例如<strong>剪枝</strong><br />
此外当然也可以用例如a star之类的启发式选择算法，俗称经验公式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(State *state, vector&lt;Choice *&gt; &amp;choices, vector&lt;State *&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为解</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSolution</span>(state)) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        <span class="built_in">recordSolution</span>(state, res);</span><br><span class="line">        <span class="comment">// 不再继续搜索</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (Choice choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：判断选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(state, choice)) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            <span class="built_in">makeChoice</span>(state, choice);</span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            <span class="built_in">undoChoice</span>(state, choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>常见例题:</p>
<p><strong>搜索问题</strong>：这类问题的目标是找到满足特定条件的解决方案</p>
<ul>
<li>全排列问题：给定一个集合，求出其所有可能的排列组合</li>
<li>子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集</li>
<li>汉诺塔问题：给定三根柱子和一系列大小不同的圆盘，要求将所有圆盘从一根柱子移动到另一根柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上</li>
</ul>
<p><strong>约束满足问题</strong>：这类问题的目标是找到满足所有约束条件的解</p>
<ul>
<li>N皇后：在 n × n 的棋盘上放置N个皇后，使得它们互不攻击</li>
<li>数独：在 n × n 的网格中填入数字 0 ~ 9 ，使得每行、每列和每个 3 × 3 子网格中的数字不重复</li>
<li>图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同</li>
</ul>
<p><strong>组合优化问题</strong>：这类问题的目标是在一个组合空间中找到满足某些条件的最优解</p>
<ul>
<li>0-1 背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大</li>
<li>旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径</li>
<li>最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连</li>
</ul>
<h4 id="全排列">全排列</h4>
<div class="note default"><p>全排列问题是回溯算法的一个典型应用。它的定义是在给定一个集合（如一个数组或字符串）的情况下，找出其中元素的所有能的排列</p>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：全排列 I */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;choices, vector&lt;<span class="type">bool</span>&gt; &amp;selected, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.<span class="built_in">size</span>() == choices.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> choice = choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.<span class="built_in">push_back</span>(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 I */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permutationsI</span>(vector&lt;<span class="type">int</span>&gt; nums) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">selected</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">backtrack</span>(state, nums, selected, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑有相同元素的情况:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：全排列 II */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;choices, vector&lt;<span class="type">bool</span>&gt; &amp;selected, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.<span class="built_in">size</span>() == choices.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; duplicated;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> choice = choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素 且 不允许重复选择相等元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i] &amp;&amp; duplicated.<span class="built_in">find</span>(choice) == duplicated.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            duplicated.<span class="built_in">emplace</span>(choice); <span class="comment">// 记录选择过的元素值</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.<span class="built_in">push_back</span>(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 II */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permutationsII</span>(vector&lt;<span class="type">int</span>&gt; nums) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">selected</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">backtrack</span>(state, nums, selected, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="子集和">子集和</h4>
<div class="note default"><p>给定一个正整数数组nums和一个目标正整数target，请找出所有可能的组合，使得组合中的元素和等于target。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合</p>
<p>要求:</p>
<ul>
<li>输入集合中的元素可以被无限次重复选取</li>
<li>子集不区分元素顺序</li>
</ul>
</div>
<p>默认已排序，如果题目不提供排序数组，可以手动排……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;choices, <span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.<span class="built_in">push_back</span>(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        <span class="built_in">backtrack</span>(state, target - choices[i], choices, i, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetSumI</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;              <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;                  <span class="comment">// 遍历起始点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;        <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    <span class="built_in">backtrack</span>(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果提供的choices有重复元素，即相同元素只能按顺序被选择，记录一个start表示本次选择开始位置，相同元素如果遍历到索引大于start时说明这一轮只能先选前面那个，后面这个重复元素必须被跳过；如果是不同元素或者这轮第一个该元素则正常进行:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：子集和 II */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;choices, <span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="comment">// 剪枝三：从 start 开始遍历，避免重复选择同一元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; choices[i] == choices[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.<span class="built_in">push_back</span>(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        <span class="built_in">backtrack</span>(state, target - choices[i], choices, i + <span class="number">1</span>, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 II */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetSumII</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;              <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;                  <span class="comment">// 遍历起始点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;        <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    <span class="built_in">backtrack</span>(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="n皇后">N皇后</h4>
<div class="note default"><p>根据国际象棋的规则，皇后可以攻击与同处一行、一列或一条斜线上的棋子。给定n个皇后和n×n棋盘，寻找摆放位置</p>
</div>
<p>先考虑怎么表示这个约束条件</p>
<ol type="1">
<li>行约束可以通过逐行选择放入位置解决</li>
<li>列约束可以使用一个列选择数组</li>
<li>注意到主对角线上所有格子的<strong>行索引减列索引</strong>为恒定值,可以用数组 diags1 记录每条主对角线上是否有皇后</li>
<li>同理，次对角线上的所有格子的<strong>行索引加列索引</strong>是恒定值。我们同样也可以借助数组 diags2 来处理次对角线约束</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：n 皇后 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, vector&lt;vector&lt;string&gt;&gt; &amp;state, vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; &amp;res, vector&lt;<span class="type">bool</span>&gt; &amp;cols,</span></span></span><br><span class="line"><span class="params"><span class="function">               vector&lt;<span class="type">bool</span>&gt; &amp;diags1, vector&lt;<span class="type">bool</span>&gt; &amp;diags2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当放置完所有行时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 计算该格子对应的主对角线和次对角线</span></span><br><span class="line">        <span class="type">int</span> diag1 = row - col + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> diag2 = row + col;</span><br><span class="line">        <span class="comment">// 剪枝：不允许该格子所在列、主对角线、次对角线上存在皇后</span></span><br><span class="line">        <span class="keyword">if</span> (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：将皇后放置在该格子</span></span><br><span class="line">            state[row][col] = <span class="string">&quot;Q&quot;</span>;</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 放置下一行</span></span><br><span class="line">            <span class="built_in">backtrack</span>(row + <span class="number">1</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line">            <span class="comment">// 回退：将该格子恢复为空位</span></span><br><span class="line">            state[row][col] = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 n 皇后 */</span></span><br><span class="line">vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; <span class="built_in">nQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 初始化 n*n 大小的棋盘，其中 &#x27;Q&#x27; 代表皇后，&#x27;#&#x27; 代表空位</span></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">state</span>(n, <span class="built_in">vector</span>&lt;string&gt;(n, <span class="string">&quot;#&quot;</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cols</span><span class="params">(n, <span class="literal">false</span>)</span></span>;<span class="comment">// 记录列是否有皇后</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diags1</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录主对角线上是否有皇后</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diags2</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录次对角线上是否有皇后</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态规划">动态规划</h3>
<p>dp与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题，我们可以将前一个子问题转移到下一个状态视为一个决策，然后用回溯，这是一种穷举<br />
但动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性</p>
<ol type="1">
<li><strong>最优子结构</strong>:原问题的最优解是从子问题的最优解构建得来的，如带代价的楼梯问题中：<code>dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]</code><br />
</li>
<li><strong>无后效(马尔科夫)性</strong>：给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关
<ol type="1">
<li>并不是有无后效性就适合dp解决，计算和存储状态必然有开销，当开销过大时用dp会超时</li>
<li>通过增加状态的范围，可以使状态转移更复杂的问题也满足无后效性，但往往开销较大</li>
</ol></li>
</ol>
<p>例如，爬楼梯问题改成:<code>每步可以上1阶或者2阶，但不能连续两轮跳1阶</code>，就需要记录上一轮跳了1还是2阶<br />
状态<code>dp[i,j]</code>表示处在第i阶并且上一轮跳了j阶:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 带约束爬楼梯：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsConstraintDP</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>; dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>; dp[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i - <span class="number">2</span>][<span class="number">1</span>] + dp[i - <span class="number">2</span>][<span class="number">2</span>];<span class="comment">//也可以是dp[i] = dp[i-2] + dp[i-3]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">1</span>] + dp[n][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解题思路:</p>
<ol type="1">
<li>假定我们在一个状态，思考这个状态可以怎么表示，用例如一个n维向量记忆，由于是dp问题，我们假定每个状态都是截止目前最优的</li>
<li>找出状态转移的方式，例如爬楼梯问题只依赖于n-1和n-2的情况</li>
<li>选取一个特定的顺序开始遍历解决问题，需要确保
<ol type="1">
<li>填满初始化状态</li>
<li>确保之后每个状态依赖的子问题已经被算出了</li>
<li>选取合适终止条件</li>
</ol></li>
</ol>
<p>理论上讲，为了空间最优，每层计算只需要依赖子问题数量的空间复杂度，对一维dp来说:一般是O(1)，但一般来说存储马尔科夫链上的所有状态复杂度相对也可以接受(一般是O(N))</p>
<h4 id="背包问题">0-1背包问题</h4>
<div class="note default"><p>给定n个物品，第i个物品的重量为<code>wgt[i-1]</code>、价值为<code>val[i-1]</code>，和一个容量为cap的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值</p>
</div>
<p>很容易想到，我们应该把重量排序，然后依次决策，因此需要一个i状态表示当前物品编号，以及一个目前限制容量c，<code>dp[i,c]</code>则表示遍历到i为止限制容量是c时的最大价值<br />
选到i时，如果不选i，那和i-1一样，如果选i，此时容量减少，价值增加，且因为不能重复选择，也退回到i-1<br />
dp状态转移: $d p[i,c]=(d p[i-1,c],d p[i-1,c-w g t[i-1]]+v a l[i-1]) $<br />
而依赖关系呢？<code>dp[i,c]</code>依赖<code>dp[i - 1][c], dp[i - 1][c - wgt[i - 1]]</code>，也就是i只依赖i-1好知道，c依赖范围是取决于wgt的，因此i应该放外侧，每一行c都知道了才能到下一个i</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 0-1 背包：记忆化搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDFSMem</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mem, <span class="type">int</span> i, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 若已有记录，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i][c] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i][c];</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能选择不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) <span class="keyword">return</span> <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> no = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> yes = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 记录并返回两种方案中价值更大的那一个</span></span><br><span class="line">    mem[i][c] = <span class="built_in">max</span>(no, yes);</span><br><span class="line">    <span class="keyword">return</span> mem[i][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0-1 背包：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) dp[i][c] = dp[i - <span class="number">1</span>][c];<span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i - <span class="number">1</span>][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);<span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_dynamic_programming/knapsack_problem/#4">空间优化</a></p>
<h4 id="完全背包问题">完全背包问题</h4>
<div class="note default"><p>给定n个物品，第i个物品的重量为<code>wgt[i-1]</code>、价值为<code>val[i-1]</code>，和一个容量为cap的背包。每个物品可以重复选取，问在限定背包容量下能放入物品的最大价值。示例如图14-22所示</p>
</div>
<p>类似0-1背包，选到i时，如果不选i，那和i-1一样，但如果选i，此时容量减少，价值增加，<strong>且因为可以重复选择</strong>，不用退回到i-1,还是i<br />
状态转移: <span class="math inline">\(d p[i,c]=\operatorname*{max}(d p[i-1,c],d p[i,c-w g t[i-1]]+v a l[i-1])\)</span><br />
而依赖关系呢？<code>dp[i,c]</code>依赖<code>dp[i - 1][c], dp[i][c - wgt[i - 1]]</code>，依赖方向依旧是左和上，但这次都是轴向，像之前一样的遍历顺序也是可以的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 完全背包：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unboundedKnapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) dp[i][c] = dp[i - <span class="number">1</span>][c];<span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);<span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_dynamic_programming/knapsack_problem/#4">空间优化</a></p>
<h5 id="找零问题">找零问题</h5>
<div class="note default"><p>给定n种硬币,第i种硬币的面值为<code>coins[i-1]</code>，目标金额为amt,每种硬币可以重复选取,问能够凑出目标金额的最少硬币数量。如果无法凑出自标金额，则返回-1</p>
</div>
<p><strong>零钱兑换可以看作完全背包问题的一种特殊情况</strong>，两者具有以下联系与不同点</p>
<ul>
<li>两道题可以相互转换，“物品”对应“硬币”、“物品重量”对应“硬币面值”、“背包容量”对应“目标金额”</li>
<li>优化目标相反，完全背包问题是要最大化物品价值，零钱兑换问题是要最小化硬币数量</li>
<li>完全背包问题是求“不超过”背包容量下的解，零钱兑换是求“恰好”凑到目标金额的解</li>
</ul>
<p>状态i,a对应的子问题为:前i种硬币能够凑出金额a的最少硬币数量,记为 <code>dp[i,a]</code><br />
如果不能找i硬币，那么和i-1一样，否则要和<code>dp[i][a-coins[i-1]]</code>取一个较小值<br />
事实上，类似完全背包，找零只有左和上方的依赖，这就意味着要实现最佳找a元，本质上只依赖于所有a-coin的最优解的最小值，也就是固定一个a，遍历i一遍就可以找到a的对应最优解，可以优化为一维<code>dp[a] = min(dp[a], dp[a - coins[i - 1]] + 1);//遍历每个可找的i</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 零钱兑换：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> MAX = amt + <span class="number">1</span>;<span class="comment">//处理无解情况</span></span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amt + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移：首行首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) dp[<span class="number">0</span>][a] = MAX;</span><br><span class="line">    <span class="comment">// 状态转移：其余行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) dp[i][a] = dp[i - <span class="number">1</span>][a];<span class="comment">//若超过目标金额，则不选硬币 i</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][a] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][a], dp[i][a - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);<span class="comment">//不选和选硬币 i 这两种方案的较小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt] != MAX ? dp[n][amt] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="找零问题2">找零问题2</h5>
<div class="note default"><p>给定n种硬币,第i种硬币的面值为<code>coins[i-1]</code>，目标金额为amt,每种硬币可以重复选取,问出目标金额的硬币组合数量</p>
</div>
<p>状态转移: <span class="math inline">\(d p[i,a]=d p[i-1,a]+d p[i,a-c o i n s[i-1]]\)</span><br />
即对每个i <span class="math inline">\(d p[a]=d p[a]+d p[a-c o i n s[i-1]]\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 零钱兑换 II：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeIIDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amt + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) dp[a] = dp[a]; <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">            <span class="keyword">else</span> dp[a] = dp[a] + dp[a - coins[i - <span class="number">1</span>]]; <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="编辑距离问题">编辑距离问题</h4>
<div class="note default"><p>输入两个字符串s和t，返回将s转换为t所需的最少编辑步数<br />
你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符</p>
</div>
<p>字符串s和t的长度分别为 n和m，我们先考虑两字符串尾部的字符<code>s[n-1],t[m-1]</code></p>
<ul>
<li>若相同，我们可以跳过它们,考虑n-2和m-2情况</li>
<li>若不同，需要对s进行一次编辑（插入、删除、替换），使得两字符串尾部的字符相同，从而可以跳过它们</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem.assets/edit_distance_state_transfer.png" /></p>
<p>状态转移如图所示，公式为 <span class="math inline">\(d p[i,j]=\operatorname*{min}(d p[i,j-1],d p[i-1,j],d p[i-1,j-1])+1\)</span><br />
<code>dp[i][j]</code>依赖左方、上方、左上方的解，依旧可以两层遍历<br />
tip:插入短字符串和删除长字符串在该问题里其实是等价的，可以省去一次计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 编辑距离：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistanceDP</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移：首行首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="comment">// 状态转移：其余行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 若两字符相等，则直接跳过此两字符</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>; <span class="comment">// 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_dynamic_programming/edit_distance_problem/#3">空间优化</a>略麻烦……</p>
<h3 id="贪心">贪心</h3>
<p>贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解<br />
只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解，这种条件相对苛刻，证明起来也很麻烦，因此没有完全把握最好不要用贪心<br />
典型的贪心算法问题：</p>
<ul>
<li><strong>硬币找零问题</strong>：在某些硬币组合下，贪心算法总是可以得到最优解</li>
<li><strong>区间调度问题</strong>：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解</li>
<li><strong>分数背包问题</strong>：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解</li>
<li><strong>股票买卖问题</strong>：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润</li>
<li><strong>霍夫曼编码</strong>：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小</li>
<li><strong>Dijkstra 算法</strong>：解决给定源顶点到其余各顶点的最短路径问题的贪心算法</li>
</ul>
<h4 id="分数背包问题">分数背包问题</h4>
<div class="note default"><p>给定n个物品，第i个物品的重量为<code>wgt[i-1]</code>、价值为<code>val[i-1]</code>，和一个容量为cap的背包。每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下背包中物品的最大价值</p>
</div>
<p>很容易用反证法证明，每次选择价格重量比最高的物品是最优策略，因为如果选择非最高的，那么换成最高的必然更优</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 物品 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> w; <span class="comment">// 物品重量</span></span><br><span class="line">    <span class="type">int</span> v; <span class="comment">// 物品价值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Item</span>(<span class="type">int</span> w, <span class="type">int</span> v) : <span class="built_in">w</span>(w), <span class="built_in">v</span>(v) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分数背包：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fractionalKnapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建物品列表，包含两个属性：重量、价值</span></span><br><span class="line">    vector&lt;Item&gt; items;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wgt.<span class="built_in">size</span>(); i++) items.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(wgt[i], val[i]));</span><br><span class="line">    <span class="comment">// 按照单位价值 item.v / item.w 从高到低进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), [](Item &amp;a, Item &amp;b) &#123; <span class="built_in">return</span> (<span class="type">double</span>)a.v / a.w &gt; (<span class="type">double</span>)b.v / b.w; &#125;);</span><br><span class="line">    <span class="comment">// 循环贪心选择</span></span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.w &lt;= cap) &#123;</span><br><span class="line">            <span class="comment">// 若剩余容量充足，则将当前物品整个装进背包</span></span><br><span class="line">            res += item.v;</span><br><span class="line">            cap -= item.w;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若剩余容量不足，则将当前物品的一部分装进背包</span></span><br><span class="line">            res += (<span class="type">double</span>)item.v / item.w * cap;</span><br><span class="line">            <span class="comment">// 已无剩余容量，因此跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最大容量问题">最大容量问题</h4>
<div class="note default"><p>输入一个数组ht，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器<br />
谷器的容量等于高度和宽度的乘积（面积），其中高度由较短的隔板决定，宽度是两入隔板的数组索引之差，请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量</p>
</div>
<p>从最大的宽度开始收缩，只有往短板方向收缩可能有更优情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 最大容量：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCapacity</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ht)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 i, j，使其分列数组两端</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = ht.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始最大容量为 0</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环贪心选择，直至两板相遇</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 更新最大容量</span></span><br><span class="line">        <span class="type">int</span> cap = <span class="built_in">min</span>(ht[i], ht[j]) * (j - i);</span><br><span class="line">        res = <span class="built_in">max</span>(res, cap);</span><br><span class="line">        <span class="comment">// 向内移动短板</span></span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; ht[j]) i++;</span><br><span class="line">        <span class="keyword">else</span> j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最大切分乘积问题">最大切分乘积问题</h4>
<div class="note default"><p>给定一个正整数n，将其切分为至少两个正整数的和，所有整数的乘积最大是多少</p>
</div>
<ul>
<li>当n&gt;= 4时,切分出一个2后乘积会变大(2(n-2) ≥n)，这说明大于等于4的整数都应该被切分<br />
</li>
<li>如果有3个2，乘积不如两个3，因此在切分方案中，最多只应存在两个2从而获得更大的乘积</li>
</ul>
<p>综上所述，可推理出以下贪心策略:</p>
<ol type="1">
<li>输入整数n，从其不断地切分出因子3，直至余数为0、1、2</li>
<li>当余数为0时,代表n是3的倍数，因此不做任何处理</li>
<li>3.当余数为2时，不继续划分，保留</li>
<li>当余数为 1时,由于2 × 2 &gt; 1 × 3,因此应将最后一个3替换为2</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 最大切分乘积：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProductCutting</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 n &lt;= 3 时，必须切分出一个 1</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 贪心地切分出 3 ，a 为 3 的个数，b 为余数</span></span><br><span class="line">    <span class="type">int</span> a = n / <span class="number">3</span>; <span class="type">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">2</span> * <span class="number">2</span>;<span class="comment">//当余数为 1 时，将一对 1 * 3 转化为 2 * 2</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">2</span>) <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a) * <span class="number">2</span>;<span class="comment">//当余数为 2 时，不做处理</span></span><br><span class="line">    <span class="comment">// 当余数为 0 时，不做处理</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="cpp基本输入输出">cpp基本输入输出</h2>
<div class="note info"><p>和考研无关但知道也不错:</p>
<ul>
<li>C 中的输入输出函数，如 scanf() 和 printf() 等，是非类型安全的：
<ul>
<li>它们依赖于格式化字符串来指示输入/输出数据的类型</li>
<li>如果格式化字符串不正确，就会导致不可预测的结果，如缓冲区溢出和未定义的行为</li>
</ul></li>
<li>C++ 中的输入输出函数，如 std::cin 和 std::cout 等，是类型安全的：
<ul>
<li>它们使用类型安全的 C++ 流语义，其中数据类型是静态确定的，而不是动态确定的</li>
<li>这意味着数据类型在编译时就已经确定，而不是在运行时根据格式化字符串动态确定</li>
<li>这种静态类型检查可以在编译时检测到类型不匹配的错误，从而使 C++ 的输入输出更加类型安全</li>
</ul></li>
<li>因此，scanf() 的参数需要使用格式化字符串来指定输入数据的类型，而 cin 和 std::cin 可以自动识别输入数据的类型</li>
</ul>
<p>cin 和 cout 是 C++ 的输入输出流，可以使用它们来实现控制台的输入输出操作 同步流（synchronized stream）的概念：</p>
<ul>
<li>同步流意味着在程序流中输出数据时，程序必须等到数据完全输出到设备上，然后才能继续执行后面的代码</li>
<li>同样，当程序尝试从输入设备读取数据时，程序会等待用户输入完整的数据，然后才能继续执行后面的代码</li>
<li>不止c++,c的scanf() 和 printf() 也实现了同步流，但其缓冲区的实现更为底层，效率更高</li>
<li>总得来说，c++输入输出依旧为了同步等高级功能牺牲了一定性能，但这些开销可以被我们手动关闭；关闭后每次读取输入时，输出缓存区不会被刷新</li>
</ul>
</div>
<ul>
<li>getchar()函数从标准输入（stdin）中读取一个字符，返回该字符的 ASCII 码值
<ul>
<li>通常用于读取单个字符或者字符数组，可以实现简单的输入操作</li>
<li>使用时需要注意的是，由于输入的字符是直接通过键盘输入的，因此需要按下回车键才能将输入的字符送入缓冲区，此时getchar()才能够读取到输入的内容</li>
</ul></li>
<li>getline()函数从输入流中读取一行文本(可以指定分隔符)，并将其存储到一个字符串对象中，可以读取包含空格在内的一整行输入
<ul>
<li>使用时需要注意的是，如果使用默认的分隔符 <code>\n</code>，getline() 会将换行符读取到缓冲区，如果下一次使用 getline() 读取输入，就会导致缓冲区中的换行符被读取，而不是期望的输入。此时可以通过调用cin.ignore()来清除缓冲区中的字符，或者指定其他分隔符</li>
<li>c++输入输出,当cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&gt;&gt;会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待但是如果读取成功，字符后面的分隔符是残留在缓冲区的</li>
</ul></li>
<li>stringstream 是 C++ 标准库提供的一种数据流对象，用于在内存中对字符串进行输入输出操作
<ul>
<li>它可以像 cin 和 cout 一样进行输入输出，并且具有和输入输出流相似的接口和方法，例如 &lt;&lt; 和 &gt;&gt; 操作符</li>
<li>它提供了将一个字符串转换成一个数据类型的方法，方便程序员进行数据处理</li>
<li>在 C++ 中，stringstream 也是类型安全的</li>
</ul></li>
</ul>
<p>getline() 其参数实际上有三个，第三个参数为分隔符参数，即 getline() 会以该参数分割处理数据，默认缺省该参数的情况下，getline() 会以<code>\n</code>为分隔符，即默认我们使用的是<code>getline(cin, s, '\n')</code>;<br />
例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, s);  <span class="comment">//读入 string 类型 s</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;First: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//输出 s</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s);  <span class="comment">//在此读入</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//再次输出 s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于默认换行符分割，此次输出符合预期</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, s, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">//读入 string 类型 s，并以 &#x27;,&#x27; 为分隔符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;First: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//输出 s</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">//在此读入</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//再次输出 s，并以 &#x27;,&#x27; 为分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于分隔符换成&#x27;,&#x27;，输入流残留的&#x27;\n&#x27;会被下次输入时读取，产生以下输出</span></span><br><span class="line">First: <span class="number">114</span></span><br><span class="line">Second:</span><br><span class="line"><span class="number">514</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//建议对策:</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">//读入 string 类型 s</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;First: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//输出 s</span></span><br><span class="line"><span class="comment">// 使用 cin.ignore() 忽略掉输入缓冲区中的换行符</span></span><br><span class="line"><span class="comment">// 也可以使用 cin.get() 读取缓冲区中的换行符</span></span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"><span class="comment">// cin.get();</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s, <span class="string">&#x27;,&#x27;</span>);  <span class="comment">//在此读入</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second: &quot;</span> &lt;&lt; s &lt;&lt; endl;  <span class="comment">//再次输出 s</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>stringstream 和 cin、cout 等输入输出流都有类似的接口和方法，可以进行输入输出操作，但它们的作用域不同。cin、cout 等输入输出流通常用于标准输入输出流，而 stringstream 通常用于字符串的处理 通常我们可以使用 stringstream 对字符串进行分割、转换、拼接等操作，然后再使用 cin 或 cout 输出到标准输入输出流中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream s;</span><br><span class="line">    string name = <span class="string">&quot;yjsp&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">24</span>;</span><br><span class="line">    <span class="type">double</span> height = <span class="number">170.5</span>;</span><br><span class="line">    string status = <span class="string">&quot;is dust&quot;</span>;</span><br><span class="line">    s &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Height: &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;, Status: &quot;</span> &lt;&lt; status;</span><br><span class="line">    string str = s.<span class="built_in">str</span>();<span class="comment">//将所有插入的数据转换为一个字符串</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(ss &gt;&gt; str)&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;<span class="comment">//不断通过空格的划分赋值给str</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例题:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 计算a+b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a_plus_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;please input two numbers : &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) cout &lt;&lt; <span class="string">&quot;a+b is &quot;</span> &lt;&lt; a + b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s!= <span class="number">0</span>) &#123;</span><br><span class="line">            --s;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            sum+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s!= <span class="number">0</span>) &#123;</span><br><span class="line">            --s;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            sum+=a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string l;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,l))&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(l)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>,num;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;num) sum+=num;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串并排序输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_from_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string l;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, l)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(l)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, num;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; num) sum += num;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_strings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;<span class="comment">//初始化语法</span></span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; s) vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>();i != vec.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strings_withdot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        vector&lt;string&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, s, <span class="string">&#x27;,&#x27;</span>)) vec.<span class="built_in">push_back</span>(s);<span class="comment">//getline属于string头文件，可以指定分隔符 </span></span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>;i++) cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        --a;</span><br><span class="line">        string t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>();i!=vec.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;<span class="comment">//初始化语法</span></span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; s) vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = vec.<span class="built_in">begin</span>();i!=vec.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        vector&lt;string&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss ,s ,<span class="string">&#x27;,&#x27;</span>)) vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>()<span class="number">-1</span>;i++) cout &lt;&lt; vec[i]&lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; *(--vec.<span class="built_in">end</span>()) &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="力扣热题-100-道题解">力扣热题 100 道题解</h2>
<h3 id="哈希">哈希</h3>
<p>题号:1 两数之和<br />
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标<br />
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素<br />
对数组的每个元素：</p>
<ol type="1">
<li>查找哈希表是否有其元素值对应的<code>&lt;k,v&gt;</code>,如果有，该<code>&lt;k,v&gt;</code>的 v 值就是其匹配的数组索引号</li>
<li>将 target 与该元素值的差作为 k，其索引作为 v 写入哈希表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;<span class="comment">// 暴力解法，O(N^2)</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp, result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = nums.<span class="built_in">begin</span>(); i != nums.<span class="built_in">end</span>();i++) temp.<span class="built_in">push_back</span>(target - *i);</span><br><span class="line">    <span class="type">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = nums.<span class="built_in">begin</span>(); i != nums.<span class="built_in">end</span>();i++) &#123;</span><br><span class="line">        <span class="type">int</span> index2 = index1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = temp.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>;t &lt; index2;t++) it++;</span><br><span class="line">        <span class="keyword">while</span> (it != temp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*i == *it) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(index1);</span><br><span class="line">                result.<span class="built_in">push_back</span>(index2);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        index1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(nums[i]) != hash.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123; i,hash[nums[i]] &#125;;</span><br><span class="line">        hash[target - nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:2 字母异位词分组<br />
给你一个字符串数组，请你将 <code>字母异位词(字母相同排列不同的单词)</code> 组合在一起可以按任意顺序返回结果列表<br />
由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键, 值则是字符串数组，最后将这些数组返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; um;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : strs) &#123;</span><br><span class="line">        string t = s;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        um[t].<span class="built_in">emplace_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : um) res.<span class="built_in">push_back</span>(i.second);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:3 最长连续序列<br />
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度<br />
请你设计并实现时间复杂度为 O(n) 的算法解决此问题<br />
不需要在原数组连续，因此可以用一个哈希集合去重，然后我们开始找连续序列，对遍历中遇到的任意值 x，如果它在一个连续序列中，那么必有从序列最大或者最小值开始找起的连续序列是存在<code>x</code>的序列中最长的这个性质，因此对遍历中的 x，先找到其所在序列末端，再一边删一遍记录长度<br />
时间复杂度：O(n)<br />
空间复杂度：O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line">    <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) us.<span class="built_in">emplace</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!us.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> i = *us.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (us.<span class="built_in">count</span>(i + <span class="number">1</span>)) ++i;</span><br><span class="line">        <span class="keyword">while</span> (us.<span class="built_in">count</span>(i)) &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            us.<span class="built_in">erase</span>(i);</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针">双指针</h3>
<p>题号:1 移动零<br />
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序<br />
请注意 ，必须在不复制数组的情况下原地对数组进行操作<br />
设置慢指针用于遍历 0，快指针用于遍历慢指针后第一个非 0 元素</p>
<ol type="1">
<li>初始快慢指针均为 0</li>
<li>while 指针不越界，循环:
<ol type="1">
<li>如果慢指针处元素为 0:
<ol type="1">
<li>快指针移动到第一个非 0 元素或者越界函数终止</li>
<li>交换快慢指针的元素</li>
</ol></li>
<li>快慢指针均+1</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n &amp;&amp; slow&lt;n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (fast &lt;n &amp;&amp; nums[fast] == <span class="number">0</span>) ++fast;</span><br><span class="line">            <span class="keyword">if</span> (fast &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            nums[fast] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++slow;++fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以优先让快指针动:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:2 盛最多水的容器<br />
给定一个长度为 n 的整数数组 height 有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水 返回容器可以储存的最大水量 很明显最大水量是x轴差值乘以最短边，要更大就需要增加x轴距离或者加长最短边<br />
从x轴最远两端开始，如果改变相对长边，那么水量必然减少，移动相对短边则水量有可能增加，因此只要不断这样遍历记录最大水量就好了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>, max_ar = (j - i) * <span class="built_in">min</span>(height[i], height[j]);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[j]) ++i;</span><br><span class="line">        <span class="keyword">else</span> --j;</span><br><span class="line">        max_ar = <span class="built_in">max</span>(max_ar, (j - i) * <span class="built_in">min</span>(height[i], height[j]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_ar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:3 三数之和<br />
给你一个整数数组 nums ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 i != j、i != k 且 j != k ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 请你返回所有和为 0 且不重复的三元组</p>
<ol type="1">
<li>先排序，然后开始遍历(遍历时跳过重复值)</li>
<li>再给定一个值，很容易就能判断有没有第三个值k满足条件</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> t = nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">while</span> (k &gt; j &amp;&amp; t + nums[k] &gt; <span class="number">0</span>) --k;</span><br><span class="line">            <span class="keyword">if</span> (j == k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) res.<span class="built_in">push_back</span>(&#123; nums[i], nums[j], nums[k] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方解双指针:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 枚举 a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">        <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">        <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> target = -nums[first];</span><br><span class="line">        <span class="comment">// 枚举 b</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) --third;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">            <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (second == third) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[second] + nums[third] == target) res.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度：O( <span class="math inline">\(N^2\)</span> )，其中 N 是数组 nums 的长度<br />
空间复杂度：O(logN)我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)</p>
<p>题号:4 接雨水(hard)<br />
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) leftMax[i] = <span class="built_in">max</span>(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) rightMax[i] = <span class="built_in">max</span>(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res += <span class="built_in">min</span>(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口">滑动窗口</h3>
<p>题号:1 无重复字符的最长子串<br />
给定一个字符串s,请你找出其中不含有重复字符的最长的长度<br />
用i,j表示子串，对特定的i，用一个哈希集合可以得出当前最长不重复子串长度<br />
随后固定j，i向前滑动一个位置，集合移除其对应的字符，循环直到j滑到字符串尾</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hash;</span><br><span class="line">    <span class="type">size_t</span> max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">    hash.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; !hash.<span class="built_in">count</span>(s[j])) &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, hash.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span> (j == s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hash.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:2 找到字符串中所有字母异位词<br />
给定两个字符串s和p，找到s中所有p的异位词(对原词的重排列，用到所有原字符刚好一次)的子串，返回这些子串的起始索引不考虑答案输出的顺序</p>
<ol type="1">
<li>用一个26字符长的数组存储字符，如果我们把s和p窗口内相同的字符抵消掉，数组非0元素数即为他们差异数</li>
<li>此题窗口范围为plen,先计算第一个窗口情况，如果差异为0直接退出</li>
<li>开始右移，对每次右移:
<ol type="1">
<li>减去左侧字符，加上右侧字符，并判断差异变化</li>
<li>如果差异为0，退出，否则继续循环</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (sLen &lt; pLen) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pLen; ++i) &#123;<span class="comment">//计算第一个窗口的字符情况</span></span><br><span class="line">        ++count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        --count[p[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> differ = <span class="number">0</span>;<span class="comment">//子串和p不同的字母数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) <span class="keyword">if</span> (count[j] != <span class="number">0</span>) ++differ;<span class="comment">//不为0的元素说明有差异</span></span><br><span class="line">    <span class="keyword">if</span> (differ == <span class="number">0</span>) res.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sLen - pLen; ++i) &#123;</span><br><span class="line">        --count[s[i] - <span class="string">&#x27;a&#x27;</span>];<span class="comment">//i右移移除对应count，正式的+1由for循环完成,接下来处理differ变化</span></span><br><span class="line">        <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) --differ;  <span class="comment">// 如果i处是多余字符，即count的对应值为1，i右移后differ会减少</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>)  ++differ; <span class="comment">// 如果i处正好相抵，i右移后differ会增加</span></span><br><span class="line">        </span><br><span class="line">        ++count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)  --differ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count[s[i + pLen] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)  ++differ; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (differ == <span class="number">0</span>) res.<span class="built_in">emplace_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子串">子串</h3>
<p>题号:1 和为 K 的子数组<br />
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数<br />
子数组是数组中元素的连续非空序列</p>
<ol type="1">
<li>创建一个哈希表，其k存储子数组和，其v存储对应这个和的子数组的数量</li>
<li>遍历原数组逐步向哈希表添加<code>1~k</code>的前缀和
<ol type="1">
<li>如果我们找到一个sum(i,j)满足题意，那么可得sum(0,j)-sum(0,i)==sum(i,j)==k</li>
<li>也就是说，sum(0,j)-k==sum(0,i),在哈希表里找到n个prefix-k,就有n个满足题意的子数组</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums) &#123;</span><br><span class="line">        pre += x;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(pre - k)) &#123;</span><br><span class="line">            count += mp[pre - k];</span><br><span class="line">        &#125;</span><br><span class="line">        mp[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组">数组</h3>
<p>题号:1 最大子数组和<br />
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和</p>
<ol type="1">
<li>类似上一题，子数组的和可以用两端前缀和差表示，这次我们只需要最大值，因此只需要保留一个量，即当前元素之前的最小差，用目前为止的前缀和减去它就行了</li>
<li>事实上可以进一步化简，如果存储到前一个元素为止的最优解sum(i-1),最优解就是<code>sum(i)和nums[i]</code>二选一</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max_sum = nums[<span class="number">0</span>], pre_sum = max_sum, min_sum = <span class="built_in">min</span>(<span class="number">0</span>, nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        min_sum = <span class="built_in">min</span>(min_sum, pre_sum);</span><br><span class="line">        pre_sum += nums[i];</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, pre_sum - min_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray_sol2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>, maxres = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;x: nums) &#123;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre + x, x);</span><br><span class="line">        maxres = <span class="built_in">max</span>(maxres, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxres;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 合并区间<br />
以数组 intervals 表示若干个区间的集合，其中单个区间为<code>intervals[i] = [starti, endi]</code>请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</p>
<p>可以合并的区间在排序后必然是连续的，排序后逐个遍历合并即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = &#123; intervals[<span class="number">0</span>] &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; intervals.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="type">int</span> tail = res.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= res[tail][<span class="number">1</span>]) &#123;</span><br><span class="line">            res[tail][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], res[tail][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 轮转数组<br />
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数</p>
<p>先分两部分转，最后整体转</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; (end - start + <span class="number">1</span>) / <span class="number">2</span>;i++) <span class="built_in">swap</span>(nums[start + i], nums[end - i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    k %= nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - k - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(nums, nums.<span class="built_in">size</span>() - k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 除自身以外数组的乘积<br />
给你一个整数数组 nums，返回 数组 result ，其中 <code>result[i]</code> 等于 nums 中除 <code>nums[i]</code> 之外其余各元素的乘积<br />
题目数据保证数组nums之中任意元素的全部前缀元素和后缀的乘积都在32位整数范围内<br />
请不要使用除法，且在O(n)时间复杂度内完成此题</p>
<ol type="1">
<li>对任意一个元素,要求的积就是它的前后缀积之积，因此先求前缀积数组(由于是积，第一个元素为1)</li>
<li>从后往前可以一步步算后缀积和前缀积数组对应元素相乘，减少计算量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; size;i++) res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> right_product = nums[size - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = size - <span class="number">2</span>;j &gt;= <span class="number">0</span>;--j) &#123;</span><br><span class="line">        res[j] *= right_product;</span><br><span class="line">        right_product *= nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="矩阵">矩阵</h3>
<p>题号:1 矩阵置零<br />
给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 请使用 原地 算法</p>
<p>标记行列，然后清零<br />
有空间上更优的解法，但逻辑很麻烦，感觉记也记不住……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">col</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">                row[i] = col[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 螺旋矩阵<br />
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素</p>
<p>每四个方向是一圈，而对每个方向来说，其起始点和遍历数量只与圈数有关，因此可以不断循环直到结果数组满足要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> dire = <span class="number">0</span>, cycle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() &gt;= m * n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">switch</span> (dire) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = cycle;j &lt; n - cycle;++j) res.<span class="built_in">emplace_back</span>(matrix[cycle][j]);</span><br><span class="line">        dire = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cycle + <span class="number">1</span>;i &lt; m - cycle;++i) res.<span class="built_in">emplace_back</span>(matrix[i][n - <span class="number">1</span> - cycle]);</span><br><span class="line">        dire = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - cycle - <span class="number">2</span>;j &gt;= cycle;--j) res.<span class="built_in">emplace_back</span>(matrix[m - <span class="number">1</span> - cycle][j]);</span><br><span class="line">        dire = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">2</span> - cycle;i &gt;= <span class="number">1</span> + cycle;--i) res.<span class="built_in">emplace_back</span>(matrix[i][cycle]);</span><br><span class="line">        dire = <span class="number">0</span>;</span><br><span class="line">        ++cycle;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题号:3 旋转图像<br />
给定一个 n × n 的二维矩阵 matrix 表示一个图像请你将图像顺时针旋转 90 度<br />
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵请不要 使用另一个矩阵来旋转图像</p>
<p>画个图就能看出，矩阵第k行被翻转到结果矩阵的n-1-k列,k从0开始 即关键等式: <code>matrix[row][col]=matrixnew​[col][n−row−1]</code><br />
可以递推坐标映射公式,更方便的做法是先行翻转得到<code>matrixnew​[n−row−1][col]</code>然后对角线翻转得到<code>matrixnew​[col][n−row−1]</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate2</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) <span class="built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 搜索二维矩阵 II<br />
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列</li>
<li>每列的元素从上到下升序排列</li>
</ul>
<p>鉴于矩阵各行行内的有序性，可以直接在各行内二分查找</p>
<p>对任意元素，如果存在的话，其右侧和下方元素比它更大，左侧和上方元素比它小,因此:</p>
<ol type="1">
<li>从右上角或者左下角开始，不断舍弃矩阵不正确的部分</li>
<li>若当前元素大于target,其左上方元素必然比它小，舍弃，即向右或者向下</li>
<li>相反情况下，其右下方元素必然比它大，舍弃，即向左或者向上</li>
<li>大小情况下各自只能在上下，左右方向里选不同的一对情况舍入，否则会提前跑出范围</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row: matrix) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(row.<span class="built_in">begin</span>(), row.<span class="built_in">end</span>(), target);</span><br><span class="line">            <span class="keyword">if</span> (it != row.<span class="built_in">end</span>() &amp;&amp; *it == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix2</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &gt; target) --x;</span><br><span class="line">            <span class="keyword">else</span> ++y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix3</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> x = m<span class="number">-1</span>, y =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;=<span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[x][y] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &gt; target) --x;</span><br><span class="line">        <span class="keyword">else</span> ++y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="链表">链表</h3>
<p>题号:1 相交链表<br />
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点如果两个链表不存在相交节点，返回 null</p>
<p>这题有很多思路，例如用哈希表检测碰撞，求出两者长度然后让遍历长链表到和短链表有相同剩余长度的位置，再一起同步检测<br />
下面是使用双指针的做法:</p>
<p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null<br />
当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点具体做法如下</p>
<ul>
<li>每步操作需要同时更新指针 pA 和 pB</li>
<li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点</li>
<li>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点</li>
<li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null</li>
</ul>
<p>相当于同时遍历A+B和B+A,假设没有公共点，会在遍历完两链表相加的长度后终止，否则会在各自遍历完一次各自的链表后交换后的那次遍历中间相遇(除非两链表长度一致)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">NULL</span> || headB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* pA = headA;</span><br><span class="line">    ListNode* pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="literal">NULL</span> ? headB : pA-&gt;next;</span><br><span class="line">        pB = pB == <span class="literal">NULL</span> ? headA : pB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>题号:2 反转链表<br />
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表</p>
<p>迭代法很基础，递归法需要先压栈到最后一个节点，然后每轮修改后一个节点的指向到前一个节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* p = head, * q = head-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (q) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q-&gt;next;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以链表1-&gt;2-&gt;3-&gt;4-&gt;5举例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            直到当前节点的下一个节点为空时返回当前节点</span></span><br><span class="line"><span class="comment">            由于5没有下一个节点了，所以此处返回节点5</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归传入下一个节点，目的是为了到达最后一个节点</span></span><br><span class="line">    ListNode newHead = <span class="built_in">reverseList</span>(head.next);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">        第一轮出栈，head为5，head.next为空，返回5</span></span><br><span class="line"><span class="comment">        第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，</span></span><br><span class="line"><span class="comment">                    把当前节点的子节点的子节点指向当前节点</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5</span></span><br><span class="line"><span class="comment">                    返回节点5</span></span><br><span class="line"><span class="comment">        第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                    返回节点5</span></span><br><span class="line"><span class="comment">        第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null</span></span><br><span class="line"><span class="comment">                    此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                    返回节点5</span></span><br><span class="line"><span class="comment">        第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，</span></span><br><span class="line"><span class="comment">                    此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null</span></span><br><span class="line"><span class="comment">                    此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                    返回节点5</span></span><br><span class="line"><span class="comment">        出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 回文链表<br />
给你一个单链表的头节点 head ，请你判断该链表是否为 回文链表 如果是，返回 true ；否则，返回 false</p>
<p>容易想到先转化数组再比对<br />
不顾及优雅的话，可以用一个外部变量正向迭代，辅以递归反向迭代(我个人喜欢创造函数局部值然后辅助函数传引用)<br />
也可以用快慢指针，慢指针走到中点，然后从中点开始反转链表(n/2复杂度)，再逐个比较</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ListNode* frontPointer;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* currentNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        frontPointer = frontPointer-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome_recur</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    frontPointer = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断该链表是否为回文链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!fast) <span class="keyword">break</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = <span class="built_in">reverseList</span>(slow);</span><br><span class="line">    <span class="keyword">while</span> (head &amp;&amp; slow) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val != slow-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 环形链表 给你一个链表的头节点 head ，判断链表中是否有环<br />
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）注意：pos 不作为参数进行传递 仅仅是为了标识链表的实际情况<br />
如果链表中存在环 ，则返回 true 否则，返回 false</p>
<p>经典的快慢指针例题，不赘述<br />
此外，这种找环的通解也可以用哈希做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!fast) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle_hash</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; seen;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seen.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        seen.<span class="built_in">insert</span>(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 环形链表 II<br />
给定一个链表的头节点 head ，返回链表开始入环的第一个节点 如果链表无环，则返回 null<br />
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）如果 pos 是 -1，则在该链表中没有环注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况<br />
不允许修改链表</p>
<p>经典解法哈希和上一题类似</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" /> 还是用上一题的快慢指针,设链表中环外部分的长度为 aslow 指针进入环后，又走了 b 的距离与 fast 相遇,到环前最后一个结点剩下距离为c此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc<br />
即a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br />
当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置最终，它们会在入环点相遇</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, * fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            ListNode* ptr = head;</span><br><span class="line">            <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:6 合并两个有序链表<br />
将两个升序链表合并为一个新的 升序 链表并返回新链表是通过拼接给定的两个链表的所有节点组成的</p>
<p>基础链表题之一，迭代和递归都很好理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode&#123;&#125;;</span><br><span class="line">    ListNode* tail = head, * t;</span><br><span class="line">    <span class="keyword">while</span> (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        t = list1-&gt;val &lt; list2-&gt;val ? list1 : list2;</span><br><span class="line">        <span class="keyword">if</span> (t == list1) list1 = list1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> list2 = list2-&gt;next;</span><br><span class="line">        tail-&gt;next = t;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail-&gt;next = (!list1) ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == null) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == null) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = <span class="built_in">mergeTwoLists</span>(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = <span class="built_in">mergeTwoLists</span>(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:7 两数相加<br />
给你两个 非空 的链表，表示两个非负的整数它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字<br />
请你将两个数相加，并以相同形式返回一个表示和的链表<br />
你可以假设除了数字 0 之外，这两个数都不会以 0 开头</p>
<p>模拟位加法，记得保留进位信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *head = <span class="literal">nullptr</span>, *tail = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">        <span class="type">int</span> n1 = l1 ? l1-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n2 = l2 ? l2-&gt;val: <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = n1 + n2 + carry;</span><br><span class="line">        <span class="keyword">if</span> (!head) head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:8 删除链表的倒数第N个节点<br />
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点</p>
<p>双指针的又一次奇技淫巧,让快指针先跑n步，然后快慢指针一起遍历到结束<br />
小心几个边界情况:</p>
<ol type="1">
<li>要删去倒数第n个节点，准确地说我们需要这个节点的前一个节点，因此可以让它空过一次或者从一个无实值头结点开始，也可以像我这样直接做一个Pre指针出来</li>
<li>如果要删头结点，也就是没有Pre的情况，需要特别判断</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, * slow = head, * pre =slow;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) fast = fast-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre == slow) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    pre-&gt;next = slow-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:9 两两交换链表中的节点<br />
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）<br />
<img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" /></p>
<p>递归:找不出一对相邻节点时终止返回,返回值实际上作为每一对的下个节点，也就是原来的左节点指向后继节点，随后把原来的右节点指向左节点，就完成了每层的任务<br />
迭代:类似递归一对一对地进行，但需要加一个头结点存储结果和保留先驱节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs_recur</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null || head.next == null) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = head.next;</span><br><span class="line">    head.next = <span class="built_in">swapPairs_recur</span>(newHead.next);</span><br><span class="line">    newHead.next = head;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead =<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    ListNode* temp = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;<span class="comment">//之后两个节点都存在时才可以交换</span></span><br><span class="line">        ListNode* node1 = temp-&gt;next;</span><br><span class="line">        ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">        temp-&gt;next = node2;</span><br><span class="line">        node1-&gt;next = node2-&gt;next;</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        temp = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* res = dummyHead-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:10 随机链表的复制 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点<br />
构造这个链表的 深拷贝 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态复制链表中的指针都不应指向原链表中的节点<br />
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y<br />
返回复制链表的头节点</p>
<p>本题主要难点在于，如何指向一个随机(可能还没有被复制)的结点:</p>
<ol type="1">
<li>最简单的做法莫过于用哈希表存储原节点到复制结点的映射，然后再一一把随机指针迭代创建，这样相当于需要遍历两次，复杂度的数量级还是n，但数值较高</li>
<li>类似的思路也可以用递归做，每轮如果查哈希表失败，就创建新节点，然后对next和random指针也递归，最后返回被复制的节点给上层使用<br />
</li>
<li>为了把空间复杂度降到常数级，可以将该链表中每一个节点拆分为两个相连的节点，例如对于链表 A→B→C，我们可以将其拆分为 A→A′→B→B′→C→C′对于任意一个原节点 S，其拷贝节点 S′ 即为其后继节点但对尾节点需要进行特别处理</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; cachedNode;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Node* t = head;</span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">        Node* headNew = <span class="keyword">new</span> <span class="built_in">Node</span>(t-&gt;val);</span><br><span class="line">        cachedNode[t] = headNew;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : cachedNode) &#123;</span><br><span class="line">        Node* n0 = n.first;</span><br><span class="line">        Node* n1 = n.second;</span><br><span class="line">        n1-&gt;next = n0-&gt;next == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : cachedNode[n0-&gt;next];</span><br><span class="line">        n1-&gt;random = n0-&gt;random == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : cachedNode[n0-&gt;random];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;Node*, Node*&gt; cachedNode;</span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList_recur</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!cachedNode.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">        Node* headNew = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        cachedNode[head] = headNew;</span><br><span class="line">        headNew-&gt;next = <span class="built_in">copyRandomList_recur</span>(head-&gt;next);</span><br><span class="line">        headNew-&gt;random = <span class="built_in">copyRandomList_recur</span>(head-&gt;random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedNode[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList_best</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">        Node* nodeNew = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        nodeNew-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = nodeNew;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next-&gt;next) &#123;</span><br><span class="line">        Node* nodeNew = node-&gt;next;</span><br><span class="line">        nodeNew-&gt;random = (node-&gt;random != <span class="literal">nullptr</span>) ? node-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* headNew = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (Node* node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">        Node* nodeNew = node-&gt;next;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        nodeNew-&gt;next = (nodeNew-&gt;next != <span class="literal">nullptr</span>) ? nodeNew-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:11 排序链表<br />
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表</p>
<p>说起排序链表，最自然的想法必然是插入排序，但这样时间复杂度较高<br />
再比如可以用哈希表,k为链表结点值，v是链表指针，根据k排序完再组起来，这样空间复杂度很高<br />
最完美的办法就只有归并了，而且为了空间能O(1),还得自底向上</p>
<p>大致的思路:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    ListNode* node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> subLength = <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ListNode* prev = dummyHead, *curr = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* head1 = curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr-&gt;next != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* head2 = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            curr = head2;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">nullptr</span> &amp;&amp; curr-&gt;next != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                next = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* merged = <span class="built_in">merge</span>(head1, head2);</span><br><span class="line">            prev-&gt;next = merged;</span><br><span class="line">            <span class="keyword">while</span> (prev-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">    <span class="keyword">while</span> (temp1 != <span class="literal">nullptr</span> &amp;&amp; temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">            temp1 = temp1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">            temp2 = temp2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp-&gt;next = temp1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp-&gt;next = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:12 LRU缓存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="type">int</span> _key, <span class="type">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> _capacity): <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二叉树">二叉树</h3>
<p>题号:1 二叉树的中序遍历<br />
给定一个二叉树的根节点 root ，返回 它的 中序 遍历</p>
<p>递归实现非常基础，迭代法需要用到栈:</p>
<ol type="1">
<li>一路往左子树走入栈</li>
<li>无路可走后，出栈一个节点输出</li>
<li>往出栈节点的右子树走</li>
</ol>
<p>类似的，遍历可以只用出入栈操作实现<br />
先序(中左右):初始入栈根节点，每次出栈输出一个节点，然后以右左子节点顺序入栈<br />
后序(左右中):一路往左子树走，每次出栈时我们需要一个flag标志保存最后一个输出节点(标记右子树有没有走过)，如果没有右孩子或者flag==右孩子直接输出，否则右节点先入栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (root || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            st.<span class="built_in">emplace</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            root = st.<span class="built_in">top</span>();st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 二叉树最大深度<br />
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 翻转二叉树<br />
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">invert_helper</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">    <span class="built_in">invert_helper</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">invert_helper</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">invert_helper</span>(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 对称二叉树<br />
判断二叉树是否对称<br />
你可能会自然想到递归，但问题是我们需要沿着对称轴递归判断，也就是需要两个参数<br />
迭代实现就是两个栈同步在两个子树上出入栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; st1, st2;</span><br><span class="line">    TreeNode* p1 = root;</span><br><span class="line">    TreeNode* p2 = p1;</span><br><span class="line">    st1.<span class="built_in">emplace</span>(p1);</span><br><span class="line">    st2.<span class="built_in">emplace</span>(p2);</span><br><span class="line">    <span class="keyword">while</span> (!st1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        p1 = st1.<span class="built_in">top</span>();st1.<span class="built_in">pop</span>();</span><br><span class="line">        p2 = st2.<span class="built_in">top</span>();st2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> ((p1 &amp;&amp; !p2) || (p2 &amp;&amp; !p1)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p1) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st1.<span class="built_in">push</span>(p1-&gt;left);</span><br><span class="line">            st1.<span class="built_in">push</span>(p1-&gt;right);</span><br><span class="line">            st2.<span class="built_in">push</span>(p2-&gt;right);</span><br><span class="line">            st2.<span class="built_in">push</span>(p2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 二叉树的直径<br />
给你一棵二叉树的根节点，返回该树的直径<br />
二叉树的直径是指树中任意两个节点之间最长路径的长度这条路径可能经过也可能不经过根节点 root<br />
两节点之间路径的长度由它们之间边数表示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxd =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Left = <span class="built_in">depth</span>(node-&gt;left);</span><br><span class="line">    <span class="type">int</span> Right = <span class="built_in">depth</span>(node-&gt;right);</span><br><span class="line">    maxd=<span class="built_in">max</span>(Left+Right,maxd);<span class="comment">//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(Left,Right)+<span class="number">1</span>;<span class="comment">//返回节点深度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">depth</span>(root);</span><br><span class="line">    <span class="keyword">return</span> maxd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:6 二叉树层序遍历</p>
<p>迭代做很简单，逐层入队列就行<br />
递归需要带深度信息，例如父节点的索引号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector &lt;vector &lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    queue &lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">        ret.<span class="built_in">push_back</span>(vector &lt;<span class="type">int</span>&gt; ());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ret.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:7 将有序数组转化为平衡二叉搜索树<br />
平衡条件可以直观地想到每次二分法建树<br />
要注意的是，此题的树形不唯一，这里直接用c++的除法(向下取整)找根节点<br />
每次递归传入一个数组范围，若范围只有一个元素，直接返回新节点，否则建立根节点，递归左右子节点再返回根节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST_helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> head, <span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head &gt; tail) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[head]);</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    <span class="type">int</span> mid = (tail + head) / <span class="number">2</span>;</span><br><span class="line">    node-&gt;val = nums[mid];</span><br><span class="line">    node-&gt;left = <span class="built_in">sortedArrayToBST_helper</span>(nums, head, mid - <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">sortedArrayToBST_helper</span>(nums, mid + <span class="number">1</span>, tail);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> mid = nums.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">    root-&gt;left = <span class="built_in">sortedArrayToBST_helper</span>(nums, <span class="number">0</span>, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">sortedArrayToBST_helper</span>(nums, mid + <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:8 验证二叉搜索树<br />
此题中左右子节点有严格大小关系<br />
本题难点在于，想从上而下校验需要知道子节点的最大最小值才能判断，因此需要逆转思路，不是从上至下校验，而是从上至下限制范围，每次往下递归，都增加一个最大或者最小值限制，只要有不满足的子节点就判false<br />
此外对BST中序遍历必然是一个升序序列，可以以此判断 此外，此题阴的是数值范围是long long，用int过不了用例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isValidBST_helper</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> min_val, <span class="type">long</span> <span class="type">long</span> max_val, <span class="type">bool</span>&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!res || !root) <span class="keyword">return</span>;<span class="comment">//检验失败或root为空则退出</span></span><br><span class="line">    <span class="keyword">if</span> (min_val &gt;= root-&gt;val || root-&gt;val &gt;= max_val) &#123; res = <span class="number">0</span>;  <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">isValidBST_helper</span>(root-&gt;left, min_val, root-&gt;val, res);</span><br><span class="line">    <span class="built_in">isValidBST_helper</span>(root-&gt;right, root-&gt;val, max_val, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* roots)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">isValidBST_helper</span>(roots, LONG_MIN, LONG_MAX, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST_iter</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> inorder = (<span class="type">long</span> <span class="type">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= inorder) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder = root -&gt; val;</span><br><span class="line">        root = root -&gt; right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:9 二叉搜索树中第 K 小的元素<br />
给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）</p>
<p>迭代法可以模拟中序遍历来不断根据大小顺序生成元素，这样只有h+k的复杂度，但这个h是一路往左的子树，最坏情况有n长 考虑要多次进行这样操作的情况，例如可以新建一个结点类，带一个序号值，或者只用一个哈希表存储各个节点的左侧结点数<br />
只要查一次的话可以省略哈希表，不断根据左侧结点数选择要往哪走，这样做最坏情况会O(N)，即左子树有n-1个结点，而我们要找最小元素，之后就会一个个地往左走，总共2n左右次操作,性能和迭代差不多</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        --k;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">node_num_of_tree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">node_num_of_tree</span>(root-&gt;left) + <span class="built_in">node_num_of_tree</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthSmallest_helper</span><span class="params">(TreeNode* root, <span class="type">const</span> <span class="type">int</span>&amp; k, <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//n表示root这个节点的大小顺序</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == k) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; k) <span class="keyword">return</span> <span class="built_in">kthSmallest_helper</span>(root-&gt;right, k, <span class="built_in">node_num_of_tree</span>(root-&gt;right-&gt;left) + n + <span class="number">1</span>);<span class="comment">//由于题目必然有解，此时root必存在右孩子</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kthSmallest_helper</span>(root-&gt;left, k, n - <span class="built_in">node_num_of_tree</span>(root-&gt;left-&gt;right) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">kthSmallest_helper</span>(root, k, <span class="number">1</span> + <span class="built_in">node_num_of_tree</span>(root-&gt;left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:10 二叉树的右视图<br />
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值<br />
实际上就是需要遍历每一层的最右侧节点:</p>
<ol type="1">
<li>深度遍历，优先从右侧走，也就是左节点先入栈，但同时需要维护深度信息，用一个深度栈维护</li>
<li>广度遍历，由于走到每层的最后就是我们要找的节点，所以不需要深度信息，这里我使用的两栈交替法解决判断每层结束，这样空间复杂度会稍高，但逻辑很好理解</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView_dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rightmostValueAtDepth;</span><br><span class="line">    <span class="type">int</span> max_depth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; depthStack;</span><br><span class="line">    nodeStack.<span class="built_in">push</span>(root);</span><br><span class="line">    depthStack.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = nodeStack.<span class="built_in">top</span>();nodeStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> depth = depthStack.<span class="built_in">top</span>();depthStack.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 维护二叉树的最大深度</span></span><br><span class="line">            max_depth = <span class="built_in">max</span>(max_depth, depth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不存在对应深度的节点我们才插入</span></span><br><span class="line">            <span class="keyword">if</span> (!rightmostValueAtDepth.<span class="built_in">count</span>(depth)) rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line"></span><br><span class="line">            nodeStack.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">            nodeStack.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">            depthStack.<span class="built_in">push</span>(depth + <span class="number">1</span>);</span><br><span class="line">            depthStack.<span class="built_in">push</span>(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rightView;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> depth = <span class="number">0</span>; depth &lt;= max_depth; ++depth) rightView.<span class="built_in">push_back</span>(rightmostValueAtDepth[depth]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rightView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView_bfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    queue&lt;TreeNode*&gt; qe1, qe2;</span><br><span class="line">    qe1.<span class="built_in">emplace</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = &#123; root-&gt;val &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!qe1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = qe1.<span class="built_in">front</span>();qe1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) qe2.<span class="built_in">emplace</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) qe2.<span class="built_in">emplace</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qe2.<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(qe2.<span class="built_in">back</span>()-&gt;val);</span><br><span class="line">        <span class="built_in">swap</span>(qe1, qe2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:11 二叉树展开为链表<br />
给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同</li>
</ul>
<p>先序遍历也就是中左右顺序，也就是需要不断把左子树插进父节点和右节点之间，可以理解为不断把左子树的最右节点(根据先序遍历顺序，该节点必是右子树的前驱)插入右子树前 或者 不断把左子树插到父节点与右节点之间(左子树根节点必然是父节点的直接后驱)<br />
我们可以用使用以上操作的(迭代)先序遍历实现算法，我们知道先序遍历的栈实现就是不断以右左顺序压栈，而栈顶元素必然是最后一个访问元素prev的最左孩子(直接后驱)，因此可以在遍历过程中不断把prev节点的左子树清空，右子树改成栈顶节点</p>
<p>要省下栈空间，可以不断寻找前驱节点，由于我们只需要不断处理左子树:</p>
<ol type="1">
<li>根节点开始向右走直到遇到左子树l，寻找前驱节点pre，即左子树的最右节点</li>
<li>"断开"右子树r，把前驱节点连到被断开部分的开头</li>
<li>把l连到父节点p的右子树上，并将父节点的左子树设为空此时连接关系是<code>p-&gt;l-&gt;pre-&gt;r</code>但l和r里可能还有左子树</li>
<li>对p处理结束后，转到1继续循环直到遇到叶节点</li>
</ol>
<p>本题的关键就是理解链接的顺序，即不断从根节点开始链接最左的孩子，直到所有节点没有左孩子<br />
例如最后一种的递归做法，维护一个last表示链表尾,对有左子树的当前链表，递归将左子树与根节点链接，对只有右子树的当前链表，将目前链表尾接到右子树上再递归<br />
也就是说不断找前驱和不断找后驱都是可以的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> stk = <span class="built_in">stack</span>&lt;TreeNode*&gt;(&#123;root&#125;);</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* curr = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = curr-&gt;left, * right = curr-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">nullptr</span>) stk.<span class="built_in">push</span>(right);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">nullptr</span>) stk.<span class="built_in">push</span>(left);</span><br><span class="line">        prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten_best</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode* curr = root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode* next = curr-&gt;left;</span><br><span class="line">            TreeNode* predecessor = next;</span><br><span class="line">            <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span>) predecessor = predecessor-&gt;right;</span><br><span class="line">            predecessor-&gt;right = curr-&gt;right;<span class="comment">//对一个节点来说，其右孩子先序遍历的前驱是左孩子最右的子节点</span></span><br><span class="line">            curr-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            curr-&gt;right = next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">flatten_recur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">subflatten</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">subflatten</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    TreeNode right = root.right;</span><br><span class="line">    TreeNode last = root; <span class="comment">//左右为空时返回root</span></span><br><span class="line">    root.left=null;</span><br><span class="line">    <span class="keyword">if</span>(left!=null) &#123;</span><br><span class="line">        root.right = left;</span><br><span class="line">        last = <span class="built_in">subflatten</span>(left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right!=null)&#123;</span><br><span class="line">        last.right = right;</span><br><span class="line">        last = <span class="built_in">subflatten</span>(right);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> last;<span class="comment">//返回链表的最后一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:12 从前序与中序遍历序列构造二叉树<br />
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点<br />
这题属于原理容易理解但实现复杂的类型,个人认为掌握递归法就够了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree_helper</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right, <span class="type">const</span> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder_left &gt; preorder_right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">    <span class="type">int</span> preorder_root = preorder_left;</span><br><span class="line">    <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">    <span class="type">int</span> inorder_root = index.<span class="built_in">at</span>(preorder[preorder_root]);</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">    <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">    <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">    <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">    root-&gt;left = <span class="built_in">BuildTree_helper</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>, index);</span><br><span class="line">    <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">    <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">    root-&gt;right = <span class="built_in">BuildTree_helper</span>(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right, index);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 构造哈希映射，用于快速定位根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        index[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BuildTree_helper</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree_iter</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preorder.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="type">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; preorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> preorderVal = preorder[i];</span><br><span class="line">        TreeNode* node = stk.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val != inorder[inorderIndex]) &#123;</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorderVal);</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>()-&gt;val == inorder[inorderIndex]) &#123;</span><br><span class="line">                node = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                ++inorderIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorderVal);</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:13 路径总和 III<br />
给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目<br />
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）</p>
<p>虽然是二叉树，但本题完全可以看做动态规划问题来做(只需要求路径数量)，通过在遍历时缓存前缀和大小及数量，就可以以线性复杂度解决此题<br />
还有一个问题是对任意结点，它能查到的前缀和必然是它的父级节点所有的，也就在这条dst路径上，因此在遍历完子节点后必须删除计数值<br />
以及，此题又非常幽默地用了long long输入范围，也不知道图什么</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum_helper</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> curr, <span class="type">int</span> targetSum, unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;&amp; prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    curr += root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (prefix.<span class="built_in">count</span>(curr - targetSum)) ret = prefix[curr - targetSum];</span><br><span class="line">    prefix[curr]++;</span><br><span class="line">    ret += <span class="built_in">pathSum_helper</span>(root-&gt;left, curr, targetSum, prefix);</span><br><span class="line">    ret += <span class="built_in">pathSum_helper</span>(root-&gt;right, curr, targetSum, prefix);</span><br><span class="line">    prefix[curr]--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; prefix;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pathSum_helper</span>(root, <span class="number">0</span>, targetSum, prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:14 最近公共祖先<br />
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先</p>
<ol type="1">
<li>递归:由于递归会先递归到叶节点然后自底向上匹配，所以匹配成功的必然是最近公共祖先，而这个祖先有两种情况
<ol type="1">
<li>左右侧各有这两个节点中的一个</li>
<li>祖先本身是一个节点，还有一个是其子节点</li>
<li>根据两个条件可以建立相应递归函数，注意lson,rson判定和祖先判定是两种逻辑</li>
</ol></li>
<li>建立子节点到父节点的哈希表，标记一个节点的所有父节点匹配另一个节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TreeNode* res;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> lson = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">    <span class="type">bool</span> rson = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">        res = root;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor_recur</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root, p, q);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lowestCommonAncestor_helper</span><span class="params">(TreeNode* root, unordered_map&lt;<span class="type">int</span>, TreeNode*&gt;&amp; fa)</span> </span>&#123;<span class="comment">//构建子节点到父节点的链接</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">        <span class="built_in">lowestCommonAncestor_helper</span>(root-&gt;left, fa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">        <span class="built_in">lowestCommonAncestor_helper</span>(root-&gt;right, fa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, TreeNode*&gt; fa;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line">    fa[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">lowestCommonAncestor_helper</span>(root, fa);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;<span class="comment">//一路标记p的父节点</span></span><br><span class="line">        vis[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">        p = fa[p-&gt;val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[q-&gt;val]) <span class="keyword">return</span> q;</span><br><span class="line">        q = fa[q-&gt;val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:15 BST的AVL化<br />
给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种<br />
如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过1，我们就称这棵二叉搜索树是平衡的</p>
<p>此题可以转化为中序序列建树问题，当然为什么能转化需要证明，见<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balance-a-binary-search-tree/solutions/241897/jiang-er-cha-sou-suo-shu-bian-ping-heng-by-leetcod/">题解</a><br />
考场上不需要证明，直接写就行了，毕竟这个结论很符合直觉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; inorderSeq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getInorder</span><span class="params">(TreeNode* o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;left) <span class="built_in">getInorder</span>(o-&gt;left);</span><br><span class="line">    inorderSeq.<span class="built_in">push_back</span>(o-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;right) <span class="built_in">getInorder</span>(o-&gt;right); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    TreeNode* o = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(inorderSeq[mid]);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid - <span class="number">1</span>) o-&gt;left = <span class="built_in">build</span>(l, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= r) o-&gt;right = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getInorder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">build</span>(<span class="number">0</span>, inorderSeq.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="图论">图论</h3>
<p>题号:1 岛屿数量<br />
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量<br />
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成<br />
此外，你可以假设该网格的四条边均被水包围</p>
<p>此题可以用bfs做，但有些麻烦的细节，写的时候要小心四个方向的索引别写错，每次找到新岛屿再建队列等小问题<br />
可以使用如下题的方向向量数组优化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_outside</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">const</span> <span class="type">int</span>&amp; m, <span class="type">const</span> <span class="type">int</span>&amp; n, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>();<span class="comment">//行数</span></span><br><span class="line">    <span class="type">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; qe;</span><br><span class="line">                qe.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> p = qe.<span class="built_in">front</span>();qe.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> ti = p.first, tj = p.second;</span><br><span class="line">                    <span class="keyword">if</span> (grid[ti][tj] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;<span class="comment">//遇到水终止操作</span></span><br><span class="line">                    grid[ti][tj] = <span class="string">&#x27;2&#x27;</span>; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_outside</span>(ti - <span class="number">1</span>, tj, m, n, grid) &amp;&amp; grid[ti - <span class="number">1</span>][tj] == <span class="string">&#x27;1&#x27;</span>) &#123; qe.<span class="built_in">emplace</span>(ti - <span class="number">1</span>, tj); grid[ti - <span class="number">1</span>][tj] = <span class="string">&#x27;2&#x27;</span>; &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_outside</span>(ti + <span class="number">1</span>, tj, m, n, grid) &amp;&amp; grid[ti + <span class="number">1</span>][tj] == <span class="string">&#x27;1&#x27;</span>) &#123; qe.<span class="built_in">emplace</span>(ti + <span class="number">1</span>, tj); grid[ti + <span class="number">1</span>][tj] = <span class="string">&#x27;2&#x27;</span>; &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_outside</span>(ti, tj - <span class="number">1</span>, m, n, grid) &amp;&amp; grid[ti][tj - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; qe.<span class="built_in">emplace</span>(ti, tj - <span class="number">1</span>); grid[ti][tj - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>; &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_outside</span>(ti, tj + <span class="number">1</span>, m, n, grid) &amp;&amp; grid[ti][tj + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; qe.<span class="built_in">emplace</span>(ti, tj + <span class="number">1</span>); grid[ti][tj + <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 腐烂的橘子<br />
在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 0 代表空单元格</li>
<li>值 1 代表新鲜橘子</li>
<li>值 2 代表腐烂的橘子</li>
</ul>
<p>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂<br />
返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1</p>
<p>本题的特点在于，可能有多个腐蚀源头，因此需要以多个源头开始进行广度遍历</p>
<ol type="1">
<li>找到所有腐烂橘子位置，并用一个队列存储</li>
<li>遍历1.中的队列，对每个腐烂橘子，污染其邻居，如果有新鲜橘子也将其入队</li>
<li>2.遍历一轮后，时间加一，如果有新橘子腐烂继续循环</li>
<li>最后需要判别有没有新鲜橘子剩下来，最简单的做法是再遍历一次，但在之前过程中一直对新鲜橘子计数也可以做到</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//是否有新鲜橘子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)<span class="comment">//找到第一轮腐烂橘子</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123; i,j &#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>() &amp;&amp; flag)<span class="comment">//如果没有腐烂橘子并且有新鲜橘子，则新鲜橘子不可能腐烂</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">size</span>();<span class="comment">//遍历同一时间感染的橘子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; t;k++) &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;p = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> x = p.first + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> y = p.second + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="number">1</span>)<span class="comment">//找到新感染的橘子</span></span><br><span class="line">                &#123;</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; x,y &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">empty</span>())<span class="comment">//如果当前轮有新感染的橘子，时间加一</span></span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)<span class="comment">//检查是否有未感染的新鲜橘子</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 课程表<br />
你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1<br />
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 ai 则 必须 先学习课程 bi<br />
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1<br />
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false</p>
<p>此题表示图的方法比较非主流，只给了无序的边集合，想要发掘图的拓扑关系，应该将边以起始顶点来聚类，形成一个嵌套数组，也就是408里的邻接表<br />
然后可以分为dfs,bfs两种思路:</p>
<ol type="1">
<li>深度遍历:深度遍历的思路是后面遍历到的边的入点不能是之前访问过的点，这样就会形成一个环而无法拓扑排序
<ol type="1">
<li>一个易错点是，由于图未必联通，可能有多个子图，因此需要区分不同的有连接关系的拓扑序列，也就是结点分为3种状态
<ol type="1">
<li>完全未访问</li>
<li>已访问，但仍在一个深度遍历的过程中，这些节点在同一个联通图内</li>
<li>访问且深度遍历完，是有联通关系的拓扑序列的一部分，但和其他序列无关</li>
</ol></li>
<li>用栈理解更直观，如果只在相邻节点都已经搜索完成时入栈一个节点，那么如果可以全部入栈一个图，就可以拓扑排序</li>
</ol></li>
<li>广度遍历:即所谓的kahn算法:
<ol type="1">
<li>可以拓扑排序的图，一定同时有入度和出度为0的节点，也就是序列的首尾，我们可以不断移除入度为0的节点，令其相邻节点的入度减1</li>
<li>循环终止后我们发现所有边都被移除，就存在拓扑序列，否则不存在</li>
<li>觉得眼熟？408的死锁检测也用了类似算法</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_course</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; courses, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> node, <span class="type">bool</span>&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!res) <span class="keyword">return</span>;</span><br><span class="line">    courses[node] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> es = edges[node];<span class="comment">//该节点连向的其他节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : es) &#123;</span><br><span class="line">        <span class="keyword">if</span> (courses[e] == <span class="number">1</span>) &#123; res = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (courses[e] == <span class="number">0</span>) <span class="built_in">dfs_course</span>(courses, edges, e, res);</span><br><span class="line">    &#125;</span><br><span class="line">    courses[node] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">courses</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;<span class="comment">//课程状态数组，0表示未遍历过</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edges</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">bool</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : prerequisites) edges[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; numCourses &amp;&amp; res;++i) <span class="keyword">if</span> (courses[i] == <span class="number">0</span>) <span class="built_in">dfs_course</span>(courses, edges, i, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish_bfs</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">    indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> visited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ++visited;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            --indeg[v];</span><br><span class="line">            <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 前缀树</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code></li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code></li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p>前缀树可以视为树状存储的字符串，根节点为空字符串，根节点到每个节点的路径则是一个特定前缀，而对这个前缀，最多可以有26(此题固定位小写字母)个子节点形成下一个单词前缀。此外，如果想表示字符串终止，需要一个特定的flag，也就是每个有end标记的节点会特定一个字符串，可以看做一种编码体系<br />
看着手搓数据结构比较吓人，其实很简单，实现上就是一个26叉树，其插入就是顺着单词一路创建(如果原先没有的话)，最后标一个end;查找前缀也很容易理解，查找单词就是查找一个有end标记的前缀</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[ch] ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>,<span class="literal">nullptr</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[ch]) node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="回溯-1">回溯</h3>
<p>回溯法：一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试<br />
这样听上去暴力的算法感觉很简单，但其实对有性能要求的场合，优化起来会很麻烦<br />
总得来说，回溯的思路是:</p>
<ol type="1">
<li>每层传入给下一层目前为止的选择集，同样也收到上一层的选择集，对每层来说:</li>
<li>如果没有选择或者满足终止条件，退出</li>
<li>遍历所有选择
<ol type="1">
<li>添加一个选择到选择集传给下一层</li>
<li>移除该选择集</li>
</ol></li>
</ol>
<p>需要注意的是，虽然递归后需要回溯，但如果传入下层的选择是一个副本而不是引用，就不需要回溯操作，遍历后到达作用域终点当前的选择信息也会被自动释放<br />
一般来说优化性能有两个方向:</p>
<ol type="1">
<li>预处理输入，例如如果可以简单判断无解的情况就不要回溯</li>
<li>记忆化，记忆已经做过的选择或者其他信息避免重复计算</li>
</ol>
<p>题号:1 全排列<br />
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案</p>
<p>例如对此题来说，简单的思路是通过一个状态数组维护已排列和未排列部分，然后不断递归穷举，这样很直观，但空间开销极大<br />
如果要省略这个状态数组，可以不断在穷举未排序部分时交换即将放入排序部分的元素和未排序部分边界的元素，这样就可以把拓展边界操作统一为右移一位边界，避免状态数组的开销</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">permute_helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; output, <span class="type">int</span> first, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有数都填完了</span></span><br><span class="line">    <span class="keyword">if</span> (first == len) &#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(output);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; len; ++i) &#123;<span class="comment">//[0,first]部分为已填过的数</span></span><br><span class="line">        <span class="comment">// 动态维护数组</span></span><br><span class="line">        <span class="built_in">swap</span>(output[i], output[first]);</span><br><span class="line">        <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">        <span class="built_in">permute_helper</span>(res, output, first + <span class="number">1</span>, len);</span><br><span class="line">        <span class="comment">// 撤销操作</span></span><br><span class="line">        <span class="built_in">swap</span>(output[i], output[first]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="built_in">permute_helper</span>(res, nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 子集<br />
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集<br />
解集不能包含重复的子集。你可以按 任意顺序 返回解集</p>
<p>子集和排列问题不同的是，无需考虑顺序，只需要考虑各个元素的有无，如果用递归做，每层只有两种可能,即放入和不放入一个元素，也就是其决策树画出来是颗满二叉树，每个叶节点对应一个子集<br />
眼熟？没错，这也是一种编码，我们完全可以用n位二进制数编码所有子集，k位对应第k个元素的有无</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;<span class="comment">//n位二进制掩码表示子集</span></span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                t.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">    <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">    t.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 电话号码的字母排列<br />
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回</p>
<p>相当于指定层数的回溯，每一层查表得到三个字母，依次送入下一层回溯，事实上，决策树是三叉树，最后结果数量也是 <span class="math inline">\(3^n\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">letterCombinations_helper</span><span class="params">(vector&lt;string&gt;&amp; combinations, <span class="type">const</span> unordered_map&lt;<span class="type">char</span>, string&gt;&amp; phoneMap, <span class="type">const</span> string&amp; digits, <span class="type">int</span> index, string&amp; combination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == digits.<span class="built_in">length</span>()) combinations.<span class="built_in">push_back</span>(combination);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> digit = digits[index];</span><br><span class="line">        <span class="type">const</span> string&amp; letters = phoneMap.<span class="built_in">at</span>(digit);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>&amp; letter : letters) &#123;</span><br><span class="line">            combination.<span class="built_in">push_back</span>(letter);</span><br><span class="line">            <span class="built_in">letterCombinations_helper</span>(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">            combination.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;<span class="comment">//电话数字能表示的字母组合</span></span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;string&gt; combinations;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, string&gt; phoneMap&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    string combination;</span><br><span class="line">    <span class="built_in">letterCombinations_helper</span>(combinations, phoneMap, digits, <span class="number">0</span>, combination);</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 组合总和<br />
给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合<br />
<code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的 对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个</p>
<p>同样是标准回溯题，此题有一个大小关系约束，可以先对candidates排序，这样对相加结果大于target之后的元素就可以跳过了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combinationSum_helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; candidates, <span class="type">const</span> <span class="type">int</span>&amp; target, <span class="type">int</span> pre_sum, vector&lt;<span class="type">int</span>&gt; pre_select, <span class="type">int</span> index)</span> </span>&#123;<span class="comment">//每次进入的初始状态是pre_sum是所有pre_select的元素和，所以先判断是否满足条件可以结束</span></span><br><span class="line">    <span class="keyword">if</span> (pre_sum == target) &#123;<span class="comment">//大于的情况不会调用递归，所以只可能小于等于</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(pre_select);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index;i &lt; candidates.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">            <span class="type">int</span> sum = pre_sum + candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pre_select.<span class="built_in">emplace_back</span>(candidates[i]);</span><br><span class="line">                <span class="built_in">combinationSum_helper</span>(res, candidates, target, sum, pre_select, i);</span><br><span class="line">                pre_select.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> size = candidates.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">combinationSum_helper</span>(res, candidates, target, <span class="number">0</span>, &#123;&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 括号生成<br />
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合(这是卡特兰数问题的一个例子)</p>
<p>此题依旧没脱出回溯的模板，但规则上与之前不同的是强调成对性，<strong>也就是左括号数永远需要大于等于右括号数</strong><br />
对其的优化可以是用左右括号计数来约束每次回溯的选择，左括号数小于对数才可以放左括号，右括号数小于左括号数才可以放右括号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; res, string&amp; cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == n * <span class="number">2</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="built_in">backtrack</span>(res, cur, open + <span class="number">1</span>, close, n);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="built_in">backtrack</span>(res, cur, open, close + <span class="number">1</span>, n);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string current;</span><br><span class="line">    <span class="built_in">backtrack</span>(result, current, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:6 单词搜索<br />
给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code><br />
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p>
<p>字符串匹配麻烦之处在于从任何索引开始都可能匹配上，但不管怎么说，如果能匹配，那么必然有一个开始点，因此意见可以穷举整个矩阵来解决<br />
虽然无法避免穷举矩阵的开销，但可以在遍历过程中设置一个visited数组，避免单次匹配过程中重复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exist_helper</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> string&amp; word, <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; dire, <span class="type">int</span> index, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; coord, <span class="type">bool</span>&amp; res, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//index对应当前匹配的word字符串索引,coord则是当前所在矩阵位置</span></span><br><span class="line">    <span class="keyword">if</span> (res || word[index] != board[coord.first][coord.second]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == word.<span class="built_in">length</span>() - <span class="number">1</span>) res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        visited[coord.first][coord.second] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dire) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> x = coord.first + dir.first; <span class="type">int</span> y = coord.second + dir.second;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= board.<span class="built_in">size</span>() || y &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || visited[x][y])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">exist_helper</span>(board, word, dire, index + <span class="number">1</span>, &#123; x,y &#125;, res, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[coord.first][coord.second] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; directions = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">exist_helper</span>(board, word, directions, <span class="number">0</span>, &#123; i,j &#125;, res, visited);</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:7 分割回文串<br />
给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串 ，使每个子串都是回文 。返回 <code>s</code> 所有可能的分割方案<br />
很麻烦的一题，分割有顺序性，因此必须从左到右遍历，这点可以用双指针实现，即<code>i&lt;=j</code><br />
计算回文开销很大，因此必须预处理或者记忆化<br />
我们用一个n长方阵存储双指针，0表示未访问，1表示是回文，2表示不是回文:</p>
<ol type="1">
<li>预处理，对任何i&gt;=j,这个指针对视为回文(递归中要用)</li>
<li>每次查找回文时，先递归<code>&lt;i+1,j-1&gt;</code>这一对，<code>&lt;i,j&gt;</code>是不是回文取决于,i,j处字符是否相等且<code>&lt;i+1,j-1&gt;</code>是否是回文</li>
<li>记忆化:计算前先查表i,j，如果非0说明已经计算过</li>
</ol>
<p>回溯过程:</p>
<ol type="1">
<li>i从0到n遍历
<ol type="1">
<li>j从i到n遍历
<ol type="1">
<li>如果此时i,j是回文，分割并回溯</li>
<li>否则什么都不做</li>
</ol></li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack_string</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> i, vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt; selection, vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt;&amp; sym_word)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(selection);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">find_symmetry</span>(s, sym_word, i, j);</span><br><span class="line">        <span class="keyword">if</span> (sym_word[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            selection.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">backtrack_string</span>(s, j + <span class="number">1</span>, res, selection, sym_word);</span><br><span class="line">            selection.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_symmetry</span><span class="params">(<span class="type">const</span> string&amp; s, vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt;&amp; sym_word, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sym_word[i][j] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) sym_word[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">find_symmetry</span>(s, sym_word, i + <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        sym_word[i][j] = (s[i] == s[j] &amp;&amp; sym_word[i + <span class="number">1</span>][j - <span class="number">1</span>]==<span class="number">1</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt; <span class="built_in">sym_word</span>(n, <span class="built_in">vector</span>&lt;<span class="type">uint8_t</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n;++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = j;i &lt; n;++i) sym_word[i][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; selection;</span><br><span class="line">    <span class="built_in">backtrack_string</span>(s, <span class="number">0</span>, res, selection, sym_word);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二分查找">二分查找</h3>
<p>题号:1 搜索插入位置<br />
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置<br />
请使用时间复杂度为 O(log n) 的算法</p>
<p>经典，没什么好说的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (head + tail) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 搜索二维矩阵<br />
给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列</li>
<li>每行的第一个整数大于前一行的最后一个整数</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code></p>
<p>做两次二分搜索，一次找行,即行首小于等于target,下一行首严格大于target;再一次找行内<br />
也可以把矩阵映射成一维数组，即逐行相接，然后二分搜索</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">midsearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (head + tail) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先找一个行首小于等于目标，下一行首大于目标的行</span></span><br><span class="line">    <span class="type">int</span> up = <span class="number">0</span>, row = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, down = row, mid = down / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (up &lt;= down) &#123;</span><br><span class="line">        mid = (up + down) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid == row || (matrix[mid][<span class="number">0</span>] &lt;= target &amp;&amp; matrix[mid + <span class="number">1</span>][<span class="number">0</span>] &gt; target)) <span class="keyword">return</span> <span class="built_in">midsearch</span>(matrix[mid], target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &gt; target) down = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> up = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">midsearch</span>(matrix[mid], target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 在排序数组中查找元素的第一个和最后一个位置<br />
给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置<br />
如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code><br />
你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p>此题难点在怎么找数组首尾，当然随便找一个然后首尾顺着找也是个简单粗暴的方法，但极端情况可能有O(N)复杂度不达标<br />
因此还是需要二分找到范围首尾，这里可以用一个flag改变二分行为，但没必要这么麻烦，左右各自做一个函数更方便，也没什么开销<br />
需要注意的是由于等于的情况也会继续二分，最后有可能在不等于target的情况下结束，你可能想加一不就行了，但同样也有可能在等于情况下结束，例子就先略过了，当然也很好解决，加一个int存储最后一次匹配target的值就行了<br />
最后如何判断找没找到呢?看两个索引是否是target的值就行了，此外，先判索引是否有效也是基操，在此题里，索引越界也表示没找到target</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch_lft</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = <span class="number">0</span>, rht = nums.<span class="built_in">size</span>() - <span class="number">1</span>, res;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt;= rht) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (lft + rht) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            rht = mid - <span class="number">1</span>;</span><br><span class="line">            res = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> lft = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch_rht</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = <span class="number">0</span>, rht = nums.<span class="built_in">size</span>() - <span class="number">1</span>, res;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt;= rht) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (lft + rht) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            lft = mid + <span class="number">1</span>;</span><br><span class="line">            res = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> rht = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="type">int</span> lft = <span class="built_in">binarySearch_lft</span>(nums, target);</span><br><span class="line">    <span class="type">int</span> rht = <span class="built_in">binarySearch_rht</span>(nums, target);</span><br><span class="line">    <span class="keyword">if</span> (lft &lt; <span class="number">0</span> || rht &gt;= nums.<span class="built_in">size</span>() || nums[lft] != target || nums[rht] != target) lft = rht = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123; lft,rht &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 搜索旋转排序数组<br />
整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong><br />
在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code><br />
给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code><br />
你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p>此题麻烦在边界问题很难处理，我们先设想任意一个旋转数组，可分为两个部分，x和y长度的两个有序子数组，任意选一个点，要么正好就是两个子数组交接处，要么在一个子数组中间，知道这个性质后有两种思路:</p>
<ol type="1">
<li>先找分界点，也就是数组的最大/最小值
<ol type="1">
<li>由于条件是数组已经旋转过，那么0索引必然是一个子数组开头，并且不是最小值，利用这点，不断找比0处元素更小的部分</li>
<li>找到后对某个区间二分</li>
</ol></li>
<li>不管分界点，对每个中点必然至少有一侧有序，可以常数复杂度观察是否在有序区间内，然后跳转
<ol type="1">
<li>边界条件是mid在边界上如何判断，因此有序需要加一个左右边界相等的条件</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sorted</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lft, <span class="type">int</span> rht)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lft ==rht || nums[lft] &lt; nums[rht];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search_rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = <span class="number">0</span>, rht = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt;= rht) &#123;</span><br><span class="line">        mid = (lft + rht) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_sorted</span>(nums, lft, mid)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[lft] &amp;&amp; target &lt;= nums[mid]) rht = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> lft = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[rht]) lft = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> rht = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 寻找旋转排序数组中的最小值<br />
已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code><br />
给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong><br />
你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p>
<p>思路上一题说过，注意两个边界情况:</p>
<ol type="1">
<li>如果数组旋转0，也就是没旋转，就不会触发对最小值的更改，需要将其默认值设为0索引元素</li>
<li>对mid等于0索引的情况也应该右移(条件是严格升序，此时能等于0索引，说明lft=0,rht=1,只有这两个元素有可能更小，0是默认返回值，因此搜一下1)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = <span class="number">0</span>, rht = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid, rotate_start = nums[<span class="number">0</span>], min;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt;= rht) &#123;</span><br><span class="line">        mid = (lft + rht) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (rotate_start &lt;= nums[mid]) lft = ++mid;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            min = nums[mid];</span><br><span class="line">            rht = --mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="栈">栈</h3>
<p>题号:1 有效的括号<br />
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效<br />
有效字符串需满足：</p>
<ol type="1">
<li>左括号必须用相同类型的右括号闭合</li>
<li>左括号必须以正确的顺序闭合</li>
<li>每个右括号都有一个对应的相同类型的左括号</li>
</ol>
<p>经典题，为了方便拓展可以用哈希表匹配括号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; se = &#123; <span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;[&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (se.<span class="built_in">find</span>(s[<span class="number">0</span>]) == se.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; ma = &#123; &#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,&#123;<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>&#125;,&#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (se.<span class="built_in">find</span>(c) != se.<span class="built_in">end</span>()) st.<span class="built_in">push</span>(c);<span class="comment">//左括号直接入栈</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//c是右括号</span></span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || ma[c] != st.<span class="built_in">top</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 最小栈<br />
设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象</li>
<li><code>void push(int val)</code> 将元素val推入堆栈</li>
<li><code>void pop()</code> 删除堆栈顶部的元素</li>
<li><code>int top()</code> 获取堆栈顶部的元素</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素</li>
</ul>
<p>用一个辅助栈同步基础栈的出入栈操作，但每次存取的是基础栈当前状态的最小元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; x_stack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; min_stack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_stack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">push</span>(x);</span><br><span class="line">        min_stack.<span class="built_in">push</span>(<span class="built_in">min</span>(min_stack.<span class="built_in">top</span>(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">pop</span>();</span><br><span class="line">        min_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 字符串解码<br />
给定一个经过编码的字符串，返回它解码后的字符串<br />
编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数<br />
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入</p>
<p>此题细节上非常麻烦，但框架很清晰，遍历字符串的过程中不断压栈，遇到<code>]</code>就取出来将k次字符串放入栈末尾，最后需要把栈内的所有字符串加起来<br />
细节上，为了优化存取，对连续字符应该放到一个string存储，数字如果是多位的也需要放入一个多位string存储，此外c++字符串数组需要指定长度，如<code>vec.push_back(string(1,char c))</code> ，将字符串转化为字面数字需要用<code>stoi</code>(来自string库)函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(s[i]); ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(<span class="built_in">string</span>(<span class="number">1</span>, s[i]));</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(s[i]); ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//右括号</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                string ss = vec.<span class="built_in">back</span>(); vec.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">if</span> (ss == <span class="string">&quot;[&quot;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> times = <span class="built_in">stoi</span>(vec.<span class="built_in">back</span>());vec.<span class="built_in">pop_back</span>();</span><br><span class="line">                    string t;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; times;++i) t += temp;</span><br><span class="line">                    vec.<span class="built_in">emplace_back</span>(t);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> temp.<span class="built_in">insert</span>(<span class="number">0</span>, ss);</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; vec.<span class="built_in">size</span>();++i)vec[<span class="number">0</span>] += vec[i];</span><br><span class="line">    <span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 每日温度<br />
定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替</p>
<ol type="1">
<li>设置一个辅助数组，用于存储对应温度的最小索引，初始均为无穷大
<ol type="1">
<li>反向遍历温度数组，对每个i，若有的话找到比其高的最低温度，并不断更新辅助数组里对应温度的索引</li>
</ol></li>
<li><strong>单调栈</strong>:正向遍历温度列表，对于温度列表中的每个元素 <code>temperatures[i]</code>:
<ol type="1">
<li>如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 <code>temperatures[prevIndex]</code>和当前温度<code>temperatures[i]</code></li>
<li>如果<code>temperatures[i]</code>更高，则将<code>prevIndex 移除</code>，并将<code>prevIndex</code>对应的等待天数赋为<code>i - prevIndex</code>，否则i入栈</li>
<li>重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将<code>i</code>进栈</li>
</ol></li>
</ol>
<p>单调栈的性质是:栈底到栈顶序列是单调的，此题中是严格递减关系。为什么可以用单调栈？因为此题有索引递增顺序，符合栈的序列性，又要大小要求，符合单调性<br />
每次匹配到一个较大元素，都是符合题意的首个更高温，因此可以出栈，每次匹配到一个较小元素，都说明这个元素和之前的元素都需要等一个更高温</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">temper</span><span class="params">(<span class="number">71</span>, <span class="number">0x7fffffff</span>)</span></span>;<span class="comment">//对i索引，表示30+i度温度出现的最小索引号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i) &#123;</span><br><span class="line">        <span class="type">unsigned</span> warmer = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = temperatures[i] + <span class="number">1</span>; t &lt;= <span class="number">100</span>; ++t) warmer = <span class="built_in">min</span>(warmer, temper[t - <span class="number">30</span>]);</span><br><span class="line">        <span class="keyword">if</span> (warmer != <span class="number">0x7fffffff</span>) res[i] = warmer - i;</span><br><span class="line">        temper[temperatures[i] - <span class="number">30</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures_stack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            <span class="type">int</span> previousIndex = s.<span class="built_in">top</span>();</span><br><span class="line">            res[previousIndex] = i - previousIndex;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="堆">堆</h3>
<p>题号:1 数组中的第K个最大元素<br />
给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素<br />
请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素<br />
你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题<br />
基础堆排序，用快排也行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickselect</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    <span class="type">int</span> partition = nums[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; partition);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; partition);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j)<span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, l, j, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest_qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickselect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> parent, <span class="type">const</span> <span class="type">int</span>&amp; heapsize)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lft = (parent &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, rht = (parent &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> max_one = (lft &lt; heapsize &amp;&amp; heap[lft] &gt; heap[parent]) ? lft : parent;</span><br><span class="line">    max_one = (rht &lt; heapsize &amp;&amp; heap[rht] &gt; heap[max_one]) ? rht : max_one;</span><br><span class="line">    <span class="keyword">if</span> (max_one != parent) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[parent], heap[max_one]);</span><br><span class="line">        <span class="built_in">maxheap</span>(heap, max_one, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_maxheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">const</span> <span class="type">int</span>&amp; heapsize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = heapsize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">maxheap</span>(heap, i, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> heapsize = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">build_maxheap</span>(nums, heapsize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        --heapsize;</span><br><span class="line">        <span class="built_in">maxheap</span>(nums, <span class="number">0</span>, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 前 K 个高频元素<br />
给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案</p>
<p>可以用一个哈希表存储<code>&lt;值，次数&gt;</code>对，然后维护一个k长度的最小堆，注意这里最小堆(优先队列的写法),首个参数是存储对象，第二个参数vector是存储形式，第三个参数是比较函数的函数类型<br />
同样也可以用快排处理哈希表键值对组成的数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; occurrences;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : nums) &#123;</span><br><span class="line">        occurrences[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(&amp;cmp)&gt; <span class="built_in">q</span>(cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [num, count] : occurrences) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">top</span>().second &lt; count) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">emplace</span>(num, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ret.<span class="built_in">emplace_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; v, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; ret, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> picked = <span class="built_in">rand</span>() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">    <span class="built_in">swap</span>(v[picked], v[start]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pivot = v[start].second;</span><br><span class="line">    <span class="type">int</span> index = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用双指针把不小于基准值的元素放到左边，</span></span><br><span class="line">        <span class="comment">// 小于基准值的元素放到右边</span></span><br><span class="line">        <span class="keyword">if</span> (v[i].second &gt;= pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(v[index + <span class="number">1</span>], v[i]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(v[start], v[index]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= index - start) &#123;</span><br><span class="line">        <span class="comment">// 前 k 大的值在左侧的子数组里</span></span><br><span class="line">        <span class="built_in">qsort</span>(v, start, index - <span class="number">1</span>, ret, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 前 k 大的值等于左侧的子数组全部元素</span></span><br><span class="line">        <span class="comment">// 加上右侧子数组中前 k - (index - start + 1) 大的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= index; i++) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(v[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; index - start + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">qsort</span>(v, index + <span class="number">1</span>, end, ret, k - (index - start + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取每个数字出现次数</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; occurrences;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: nums) &#123;</span><br><span class="line">        occurrences[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; values;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv: occurrences) &#123;</span><br><span class="line">        values.<span class="built_in">push_back</span>(kv);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    <span class="built_in">qsort</span>(values, <span class="number">0</span>, values.<span class="built_in">size</span>() - <span class="number">1</span>, ret, k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="贪心-1">贪心</h3>
<p>题号:1 跳跃游戏<br />
给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度<br />
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false</p>
<p>如果是dp做就用dp表示可达性然后遍历，但这题跳跃长度可选，因此与其维护dp数组，不如维护可以可以跳到的边界，一旦边界到达最右侧，就返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= rightmost) &#123;</span><br><span class="line">            rightmost = <span class="built_in">max</span>(rightmost, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 跳跃游戏II<br />
给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code><br />
每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code></li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code></p>
<p>设所处位置为i，可跳k步，对i来说每次的最优解是跳到一个j(i<sub>i+k范围)处，<code>j+nums[j]</code>是范围里i</sub>i+k的最大值<br />
也就是说，我们每次不仅维护一个最大范围，还要根据这个范围寻找一个下次最优解，每次跳到下次最优解时更新step</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxPos &gt;= i) &#123;</span><br><span class="line">            maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                ++step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更容易理解的版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>, i = <span class="number">0</span>, max_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        maxPos = i + nums[i];</span><br><span class="line">        <span class="keyword">if</span> (maxPos &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> ++step;<span class="comment">//此时相当于可以跳到终点，需要先加一再返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt;= maxPos;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + nums[j] &gt; max_index+nums[max_index]) max_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        i = max_index;maxPos = max_index + nums[max_index];</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 划分字母区间<br />
给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 <code>"ababcc"</code> 能够被分为 <code>["abab", "cc"]</code>，但类似 <code>["aba", "bcc"]</code> 或 <code>["ab", "ab", "cc"]</code> 的划分是非法的<br />
注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code><br />
返回一个表示每个字符串片段的长度的列表</p>
<p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。每次根据这个位置取片段，取如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的<br />
例如，s第一个字符是a，我们必须把截止最后一个a的长度填进去，然后遍历这个子串，看里面有没有其他需要填进去的字母，例如满足a的条件需要长度3，第二个字符是b，b最后出现在s第四个字符，就需要长度再加一</p>
<ol type="1">
<li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start=end=0</li>
<li>对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 endc​，则当前片段的结束下标一定不会小于 endc​，因此令 end=max(end,endc​)</li>
<li>当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 <code>[start,end]</code>，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start=end+1，继续寻找下一个片段</li>
<li>重复上述过程，直到遍历完字符串</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> last[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) last[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; partition;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        end = <span class="built_in">max</span>(end, last[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            partition.<span class="built_in">push_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态规划-1">动态规划</h3>
<h4 id="斐波那契类型">斐波那契类型</h4>
<p>题号:1 爬楼梯<br />
假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶<br />
每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>假设已经爬到了x级(x&lt;=n)，上一个状态可能是x-1或x-2，因此可得f(n)=f(n-1)+f(n-2)，也就是斐波那契数列<br />
这么一来只需要不断保留x-1和x-2项计算就行了，设置一个数组{结果，旧值，更旧值}，每次旧和更旧值相加存到结果值，下一轮的旧值是现在的结果，更旧值是现在的旧值,因此一一赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memory = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (steps &lt; n) &#123;</span><br><span class="line">        memory[<span class="number">0</span>] = memory[<span class="number">1</span>] + memory[<span class="number">2</span>];</span><br><span class="line">        memory[<span class="number">2</span>] = memory[<span class="number">1</span>];</span><br><span class="line">        memory[<span class="number">1</span>] = memory[<span class="number">0</span>];</span><br><span class="line">        steps++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 第 N 个泰波那契数<br />
泰波那契序列(三个数之和版的斐波那契数)<br />
给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span> ,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        mem[<span class="number">0</span>] = mem[<span class="number">1</span>] + mem[<span class="number">2</span>] + mem[<span class="number">3</span>];</span><br><span class="line">        mem[<span class="number">3</span>] = mem[<span class="number">2</span>];</span><br><span class="line">        mem[<span class="number">2</span>] = mem[<span class="number">1</span>];</span><br><span class="line">        mem[<span class="number">1</span>] = mem[<span class="number">0</span>];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 使用最小花费爬楼梯<br />
给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶<br />
你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯<br />
请你计算并返回达到楼梯顶部的最低花费</p>
<p>楼梯，或者说斐波那契问题的关键就是，第k项只依赖于k-1和k-2项，爬到k阶的最小花费取决于k-1,k-2的最小花费+对应cost;而之前的楼梯问题相当于代价相等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = cost.<span class="built_in">size</span>(),i = <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="built_in">min</span>(mem[<span class="number">1</span>] + cost[i - <span class="number">1</span>], mem[<span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        mem[<span class="number">2</span>] = mem[<span class="number">1</span>];</span><br><span class="line">        mem[<span class="number">1</span>] = mem[<span class="number">0</span>];++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 打家劫舍<br />
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警<br />
给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额</p>
<p>假设我们已经偷到k家，如果之前偷了k-2,可以偷这家，否则和偷k-1家情况一致，也就是k家情况的最佳收益取决于<code>money(k-2)+num[k]</code>与<code>money(k-1)</code>的最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem = &#123; <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]),nums[<span class="number">0</span>],<span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]) &#125;;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        mem[<span class="number">0</span>] = <span class="built_in">max</span>(mem[<span class="number">1</span>] + nums[i], mem[<span class="number">2</span>]);</span><br><span class="line">        mem[<span class="number">1</span>] = mem[<span class="number">2</span>];</span><br><span class="line">        mem[<span class="number">2</span>] = mem[<span class="number">0</span>];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 删除并获得点数<br />
给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作<br />
每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素<br />
开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数</p>
<p>乍一看无从下手，因为我们可以任意选择索引处的数x，但选择后x-1和x+1都清零了，现在必然选择所有x是最优的，因此每次我们选的是一个数而不是索引<br />
对一个选择集，我们会发现其可以表示成一系列相差大于1的数如<code>1,3,5,8</code>，对其排序可得到一个升序序列，没错，可以视为打家劫舍的一个变种，但逻辑更复杂一点<br />
先从简单的情形讨论，如果数组是个连续整数序列，那就纯粹是打家劫舍问题，对大小顺序里k的数，可以抢k-1或者抢k与k-2<br />
但如果有2以上的间隔呢，如<code>1,3,4,6,8</code>,此时我们发现抢1对之后的选择没有任何影响，准确地说，抢到k时，如果k-1这个数不存在，即k-1情况等价于上一个存在的树对应情况，，例如我们抢到3时，发现2不存在，那么3的最优解就是抢了3加上之前的最好情况 这么分析后，假设我们有一个实际存在值的数组，那么策略是:</p>
<ol type="1">
<li>遍历到某个数k,设j是k的上一个数
<ol type="1">
<li>如果k-1==j，按打家劫舍做，<code>k = max(k-1 ,money(k) +(k-2))</code></li>
<li>如果k-1不存在，<code>k=j+money(k)</code></li>
</ol></li>
</ol>
<p>实现细节有不少麻烦之处，这里用空间换易读性，存储不重复值的升序数组和对应哈希表的出现次数，方便之后调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteAndEarn</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), i = <span class="number">2</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; keys = &#123; nums[<span class="number">0</span>] &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!um.<span class="built_in">count</span>(i)) um[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ++um[i];</span><br><span class="line">        <span class="keyword">if</span> (i != keys.<span class="built_in">back</span>()) keys.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (keys.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> keys[<span class="number">0</span>] * um[keys[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp;<span class="comment">//偷到第二家</span></span><br><span class="line">    temp = ((keys[<span class="number">1</span>] - <span class="number">1</span>) != keys[<span class="number">0</span>]) ? keys[<span class="number">0</span>] * um[keys[<span class="number">0</span>]] + keys[<span class="number">1</span>] * um[keys[<span class="number">1</span>]] : <span class="built_in">max</span>(keys[<span class="number">1</span>] * um[keys[<span class="number">1</span>]], keys[<span class="number">0</span>] * um[keys[<span class="number">0</span>]]);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem = &#123; temp,temp,keys[<span class="number">0</span>] * um[keys[<span class="number">0</span>]] &#125;;<span class="comment">//&#123;结果，偷到第二家，偷到第一家&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; keys.<span class="built_in">size</span>()) &#123;<span class="comment">//进入时已经偷了2家或1家</span></span><br><span class="line">        <span class="keyword">if</span> ((keys[i] - <span class="number">1</span>) != keys[i - <span class="number">1</span>]) mem[<span class="number">0</span>] = mem[<span class="number">1</span>] + keys[i] * um[keys[i]];</span><br><span class="line">        <span class="keyword">else</span> mem[<span class="number">0</span>] = <span class="built_in">max</span>(mem[<span class="number">1</span>], mem[<span class="number">2</span>] + keys[i] * um[keys[i]]);</span><br><span class="line">        mem[<span class="number">2</span>] = mem[<span class="number">1</span>];</span><br><span class="line">        mem[<span class="number">1</span>] = mem[<span class="number">0</span>];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mem[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="矩阵-1">矩阵</h4>
<p>怀疑不太可能考，先略过这部分</p>
<p>题号:1 不同路径<br />
一个机器人位于一个 <code>m x n</code> 网格的左上角 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角 问总共有多少条不同的路径？</p>
<p><code>f(i,j)=f(i−1,j)+f(i,j−1)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 最小路径和<br />
给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小<br />
<strong>说明：</strong>每次只能向下或者向右移动一步</p>
<p><code>dp[i][j]</code>表示从左上角出发到 (i,j) 位置的最小路径和,从左上到右下更新dp即可</p>
<ol type="1">
<li>当 i&gt;0 且 j=0 时，<code>dp[i][0]=dp[i−1][0]+grid[i][0]</code></li>
<li>当 i=0 且 j&gt;0 时，<code>dp[0][j]=dp[0][j−1]+grid[0][j]</code></li>
<li>当 i&gt;0 且 j&gt;0 时，<code>dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">size</span>() == <span class="number">0</span> || grid[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">auto</span> dp = vector &lt; vector &lt;<span class="type">int</span>&gt; &gt; (m, vector &lt;<span class="type">int</span>&gt; (n));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="字符串">字符串</h4>
<p>可分为编辑问题和比较问题，编辑问题由于可能需要一个无任何编辑的初始情况，更适合用长度作为表示问题的方式，0表示空字符串，m表示m长度的字符串(但依旧从0索引，即尾字符索引是m-1)</p>
<p>题号:1 最长回文子串<br />
给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p>
<p>从大往小遍历，并存储最大索引和长度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_symmetry_helper</span><span class="params">(<span class="type">const</span> string&amp; s, vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt;&amp; sym_word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>&amp; m, <span class="type">int</span>&amp; st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j || sym_word[i][j] == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sym_word[i][j] == <span class="number">1</span>) &#123; m = <span class="built_in">max</span>(j - i + <span class="number">1</span>, m);<span class="keyword">if</span> (m == j - i + <span class="number">1</span>) st = i; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - i == <span class="number">1</span>) sym_word[i][j] = s[i] == s[j];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">find_symmetry_helper</span>(s, sym_word, i + <span class="number">1</span>, j - <span class="number">1</span>, m, st);</span><br><span class="line">            sym_word[i][j] = (s[i] == s[j] &amp;&amp; sym_word[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sym_word[i][j] == <span class="number">1</span>) &#123; m = <span class="built_in">max</span>(j - i + <span class="number">1</span>, m);<span class="keyword">if</span> (m == j - i + <span class="number">1</span>) st = i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), max_len = <span class="number">1</span>, max_start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">uint8_t</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">uint8_t</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>;j &gt; i;--j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; max_len) <span class="built_in">find_symmetry_helper</span>(s, dp, i, j, max_len, max_start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(max_start, max_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 单词拆分<br />
给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code><br />
<strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用</p>
<p>对0-i索引的字符串，如果能被表示，则对每个词word,其词长wl:<br />
如果0-(i-wl)的字符串能被表示，且(i-wl) - i的字符串等于word，那么它可以被表示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>()+<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] = <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> word_len = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (dp[i-word_len] &amp;&amp; word_len &lt;= i &amp;&amp; s.<span class="built_in">substr</span>(i-word_len, word_len) == word ) dp[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 最长回文子序列<br />
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度<br />
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列</p>
<p><code>dp[i][j]</code>表示字符串 s 的下标范围<code>[i,j]</code>内的最长回文子序列的长度</p>
<ol type="1">
<li>如果 <code>s[i]=s[j]</code>，则 <code>dp[i][j]=dp[i+1][j−1]+2</code></li>
<li>如果 <code>s[i]!=s[j]</code>，则 <code>s[i]</code> 和 <code>s[j]</code> 不可能同时作为同一个回文子序列的首尾，因此 <code>dp[i][j]=max(dp[i+1][j],dp[i][j−1])</code></li>
</ol>
<p>由这个递推公式得出，需要从内向外遍历，而起始点和i,j扩张方向则可以随意 d 下方使用i向左，j向右的方式，当然相反也行，只需要保证外层调用时内层已经准备好<br />
由于每次固定一个i，j从i+1开始往右走，因此，每次都是调用已经计算过的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c1 = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = s[j];</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 编辑距离<br />
给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em><br />
你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>注意到，别问怎么注意的，问题中缩短较长字符串等价于加长较短字符串，因此我们统一为两种操作:删除和替换 当我们获得<code>D[i][j-1]，D[i-1][j] 和 D[i-1][j-1]</code>的值之后就可以计算出<code>D[i][j]</code>。<code>D[i][j]</code>为 A 的前 i 个字符和 B 的前 j 个字符编辑距离的子问题<br />
即对于 B 的第 j 个字符，我们在 A 的末尾添加了一个相同的字符，那么<code>D[i][j]</code>最小可以为 <code>D[i][j-1] + 1</code>； <code>D[i-1][j]</code>为 A 的前 i - 1 个字符和 B 的前 j 个字符编辑距离的子问题<br />
即对于 A 的第 i 个字符，我们在 B 的末尾添加了一个相同的字符，那么<code>D[i][j]</code>最小可以为<code>D[i-1][j] + 1</code>；<code>D[i-1][j-1]</code> 为 A 前 i - 1 个字符和 B 的前 j - 1 个字符编辑距离的子问题<br />
即对于 B 的第 j 个字符，我们修改 A 的第 i 个字符使它们相同，那么<code>D[i][j]</code>最小可以为<code>D[i-1][j-1] + 1</code><br />
特别地，如果 A 的第 i 个字符和 B 的第 j 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，<code>D[i][j]</code>最小可以为<code>D[i-1][j-1]</code>。 那么我们可以写出如下的状态转移方程：</p>
<ol type="1">
<li>若 A 和 B 的最后一个字母相同： <code>D[i][j]​=min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1])=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]−1)​</code></li>
<li>若 A 和 B 的最后一个字母不同： <code>D[i][j]=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1])</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> left = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> down = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> left_down = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) left_down += <span class="number">1</span>;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(left, <span class="built_in">min</span>(down, left_down));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 两个字符串的最小ASCII删除和<br />
给定两个字符串<code>s1</code> 和 <code>s2</code>，返回 使两个字符串相等所需删除字符的 <strong>ASCII</strong> 值的最小和</p>
<p>策略:需要删掉删除和最小的字符串，考虑什么情况是没必要删的，如果s1是s2的一个子序列，那么s2里s1的字符就不需要删，也就是说这个问题其实是寻找子序列配合一个删除和约束<br />
如何寻找子序列呢？我们知道就是先比末尾字符，然后根据情况dp，此题加了一个删除和约束，那就往最小化删除和的方向dp<br />
当然反过来想，也可以找字符和最大的公共子序列，然后用两个字符串的总字符和减去它的两倍</p>
<p><code>dp[i][j]</code>表示s1直到i的子串和s2直到j的子串最小删除和</p>
<ol type="1">
<li>初始条件如果另一方不存在，就等于存在一方字符值</li>
<li>固定一个i增加j
<ol type="1">
<li>如果对应两个字符相等，不用删除就等价于(i-1,j-1)子问题</li>
<li>否则删掉一个删除和最小的，等价于对应删掉字符的值加删掉后对应子问题的删除和</li>
</ol></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumDeleteSum</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = s1.<span class="built_in">size</span>(); <span class="type">int</span> n = s2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//上行结束后，所有有一方长度为0的子问题都解决了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">char</span> c1 = s1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = s2[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + s1[i - <span class="number">1</span>], dp[i][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最长递增子序列">最长递增子序列</h4>
<p>题号:1 最长递增子序列<br />
递增子序列有以下性质:</p>
<ol type="1">
<li>递增，比序列尾部元素大就可以扩张子序列</li>
<li>不知道具体有什么元素，或者说其尾部索引</li>
</ol>
<p>因此可以<code>dp[i]</code>表示到i为止的最长子序列尾部，这样一来每次对j索引更新时就需要遍历查找之前的最长子序列，具体地说找尾部元素比j小的子序列中最长的一个<br />
优化:考虑让每次可以新加的数尽可能小，这样至少不会是更差的选择:维护一个数组<code>d[i]</code>，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，<code>d[1]=nums[0]</code>，d数组有递增性质</p>
<p>设当前已求出的最长上升子序列的长度为 len（初始时为 1），从前往后遍历数组 nums，在遍历到<code>nums[i]</code>时：</p>
<ol type="1">
<li>如果<code>nums[i]&gt;d[len]</code> ，则直接加入到 d 数组末尾，并更新<code>len=len+1</code></li>
<li>否则，在 d 数组中二分查找，找到第一个比<code>nums[i]</code>小的数<code>d[k]</code>，并更新<code>d[k+1]=nums[i]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(),max_num;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span> (nums[j] &lt; nums[i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: dp) max_num=<span class="built_in">max</span>(i,max_num);</span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS_bin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>, n = (<span class="type">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    d[len] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; d[len]) d[++len] = nums[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 最长递增子序列的个数<br />
给定一个未排序的整数数组 <code>nums</code>， <em>返回最长递增子序列的个数</em><br />
<strong>注意</strong> 这个数列必须是 <strong>严格</strong> 递增的</p>
<p>暴力法就是上题基础上加个计数，非暴力法，嗯，不提了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>(), maxLen = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span>, <span class="title">cnt</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>; cnt[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    cnt[i] = cnt[j]; <span class="comment">// 重置计数</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) cnt[i] += cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = dp[i];</span><br><span class="line">            res = cnt[i]; <span class="comment">// 重置计数</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == maxLen) res += cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 最长数对链<br />
给你一个由 <code>n</code> 个数对组成的数对数组 <code>pairs</code> ，其中 <code>pairs[i] = [lefti, righti]</code> 且 <code>lefti &lt; righti</code><br />
现在，我们定义一种 <strong>跟随</strong> 关系，当且仅当 <code>b &lt; c</code> 时，数对 <code>p2 = [c, d]</code> 才可以跟在 <code>p1 = [a, b]</code> 后面。我们用这种形式来构造 <strong>数对链</strong><br />
找出并返回能够形成的 <strong>最长数对链的长度</strong><br />
你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造</p>
<p>类似上题和上上题，定义<code>dp[i]</code>为以<code>pairs[i]</code>为结尾的最长数对链的长度。计算<code>dp[i]</code>时，遍历所有小于i的索引j，<code>dp[i]</code>赋值为索引处的pair可以添加数对的dp最大值+1。这种动态规划的思路要求计算<code>dp[i]</code>时，所有潜在的<code>dp[j]</code>已经计算完成，可以先将pairs进行排序来满足这一要求。初始化时，dp需要全部赋值为1</p>
<p>二分:用一个数组arr来记录当前最优情况，<code>arr[i]</code>就表示长度为 i+1 的数对链的末尾可以取得的最小值，遇到一个新数对时，先用二分查找得到这个数对可以放置的位置，再更新arr<br />
贪心:要挑选最长数对链的第一个数对时，最优的选择是挑选右边界最小的，这样能给挑选后续的数对留下更多的空间。挑完第一个数对后，要挑第二个数对时，也是按照相同的思路，是在剩下的数对中，左边界满足题意的条件下，挑选右边界最小的。按照这样的思路，可以先将输入按照右边界排序，然后不停地判断左边界是否能满足大于前一个数对的右边界即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestChain</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = pairs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestChain_binary</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : pairs) &#123;</span><br><span class="line">        <span class="type">int</span> x = p[<span class="number">0</span>], y = p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span> || x &gt; arr.<span class="built_in">back</span>()) arr.<span class="built_in">emplace_back</span>(y);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), x) - arr.<span class="built_in">begin</span>();</span><br><span class="line">            arr[idx] = <span class="built_in">min</span>(arr[idx], y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestChain_greed</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> curr = INT_MIN, res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : pairs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr &lt; p[<span class="number">0</span>]) &#123;</span><br><span class="line">            curr = p[<span class="number">1</span>];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 最长定差子序列<br />
给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出并返回 <code>arr</code> 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code><br />
<strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列</p>
<p><code>dp[i]</code>表示以<code>arr[i]</code>为结尾的最长的等差子序列的长度，那么对任意v,其驱动元素如果存在必然是v-diff,如果存在v-difference元素，遍历到v时必然有个非0的<code>d[v-diff]</code>存在，其加一后就是<code>dp[v]</code>，由于哈希表默认值是0，因此不存在也不影响<br />
结果就是dp数组最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestSubsequence</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> difference)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v: arr) &#123;</span><br><span class="line">        dp[v] = dp[v - difference] + <span class="number">1</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 最长等差数列<br />
给你一个整数数组 <code>nums</code>，返回 <code>nums</code> 中最长等差子序列的<strong>长度</strong><br />
回想一下，<code>nums</code> 的子序列是一个列表 <code>nums[i1], nums[i2], ..., nums[ik]</code> ，且 <code>0 &lt;= i1 &lt; i2 &lt; ... &lt; ik &lt;= nums.length - 1</code>。并且如果 <code>seq[i+1] - seq[i]</code>( <code>0 &lt;= i &lt; seq.length - 1</code>) 的值都相同，那么序列 <code>seq</code> 是等差的</p>
<p>容易理解的方法:<br />
<code>dp[i][d]</code>表示以<code>nums[i]</code>结尾且公差为d的数列长度，即<code>dp[i]</code>存储一个以i元素结尾可以存在的不同d等差数列的哈希表<br />
对于<code>nums[i]</code>，可以枚举它的前一项<code>nums[j]</code>，0&lt;= j &lt; i，有了前一项<code>nums[j]</code>，其实公差就确定了<code>d=nums[i]-nums[j]</code></p>
<ol type="1">
<li>如果<code>nums[j]</code>可以是某个公差为d的数列的最后一项，<code>nums[i]</code>就可以接在后面形成更长的等差数列，状态转移方程为<code>dp[i][d]=dp[j][d]+1</code></li>
<li>否则它两就形成公差为d的等差数列前两项，状态转移方程为<code>dp[i][d]=2</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestArithSeqLength_best</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [minit, maxit] = <span class="built_in">minmax_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> diff = *maxit - *minit;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = -diff; d &lt;= diff; ++d) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(*maxit + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">int</span> prev = num - d; prev &gt;= *minit &amp;&amp; prev &lt;= *maxit &amp;&amp; f[prev] != <span class="number">-1</span>) &#123;</span><br><span class="line">                f[num] = <span class="built_in">max</span>(f[num], f[prev] + <span class="number">1</span>);</span><br><span class="line">                res = <span class="built_in">max</span>(res, f[num]);</span><br><span class="line">            &#125;</span><br><span class="line">            f[num] = <span class="built_in">max</span>(f[num], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestArithSeqLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">-500</span>; i &lt;= <span class="number">500</span>; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;<span class="comment">//头元素可以视为任意差的数列开头</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;<span class="comment">//对i之前的元素j</span></span><br><span class="line">            <span class="type">int</span> d = nums[i] - nums[j];<span class="comment">//i与j的差</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j].<span class="built_in">count</span>(d)) dp[i][d] = dp[j][d] + <span class="number">1</span>;<span class="comment">//如果j可以加在i的后面形成等差数列，其数列长度加一</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][d] = <span class="number">2</span>;<span class="comment">//否则生成一个新数列</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i][d]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="最长公共子序列">最长公共子序列</h4>
<p>题号:1 最长公共子序列<br />
给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code><br />
一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列</p>
<p>过于经典，不多说了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence_better</span><span class="params">(string text1, string text2)</span> </span>&#123;<span class="comment">//dp[j]等于text2中以text2[j]为末尾元素的子序列和text1的[0,i-1]子串的最长公共子序列的长度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(text2.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; text2.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="type">int</span> newlen = <span class="built_in">max</span>(maxlen, dp[j]);</span><br><span class="line">            <span class="keyword">if</span> (text1[i] == text2[j]) dp[j] = maxlen + <span class="number">1</span>;</span><br><span class="line">            maxlen = newlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">cbegin</span>(), dp.<span class="built_in">cend</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 不相交的线<br />
在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数<br />
现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线<br />
以这种方法绘制线条，并返回可以绘制的最大连线数</p>
<p>对每根线来说，两个索引都需要严格大于各自边的前方任意索引，并且对应元素要相等，这就是什么呢？每次，就是公共子序列，so……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num1 = nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> num2 = nums2[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="买卖股票">买卖股票</h4>
<p>题号:1 买卖股票的最佳时机<br />
给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格<br />
你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润<br />
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code></p>
<p>因为最多只能卖一股，到第i天，我们的最优解是买入目前为止的最低价，到目前为止的最高价全卖出，因此遍历中记录迄今为止的最低价格，每次考虑此次卖出的利润是否比之前更好<br />
如果用dp就是<code>dp[i]= max(dp[i-1], prices[i]-minprices[i-1])</code>，但我们</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minprice = <span class="number">0x7fffffff</span>, maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> price: prices) &#123;</span><br><span class="line">        maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">        minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 买卖股票的最佳时机 II<br />
给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格<br />
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售<br />
返回 <em>你能获得的 <strong>最大</strong> 利润</em></p>
<p>定义状态<code>dp[i][0]</code>表示第 i 天交易完后手里没有股票的最大利润，<code>dp[i][1]</code> 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）<br />
可得:</p>
<ol type="1">
<li><code>dp[i][0]=max&#123;dp[i−1][0],dp[i−1][1]+prices[i]&#125;</code></li>
<li><code>dp[i][1]=max&#123;dp[i−1][1],dp[i−1][0]−prices[i]&#125;</code></li>
</ol>
<p>由于这个状态转移符合马尔科夫假设，因此只需要存储前一天状态<code>dp[i−1][0]</code>和<code>dp[i−1][1]</code></p>
<p>贪心:我们只考虑利润，利润是什么？是一个子区间的右左差，由于每天可以随意买入卖出，因此i天买入，j天卖出的区间差等价于{i,i+1}……{j-1,j}的区间差之和，也就是说只要有赚头，我们当天买，第二天卖，加起来也是最优解<br />
这样一来就简单了，我们沿着所有长度为2的区间滚过去，有利润就买入卖出，加起来就是最大利润，实际上这就是获取最大利润买入卖出次数最大的一种方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int newDp0 = max(dp0, dp1 + prices[i]);</span></span><br><span class="line"><span class="comment">        int newDp1 = max(dp1, dp0 - prices[i]);</span></span><br><span class="line"><span class="comment">        dp0 = newDp0;</span></span><br><span class="line"><span class="comment">        dp1 = newDp1;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit_greed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;   </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) res += <span class="built_in">max</span>(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="动态规划树">动态规划树</h4>
<p>题号:1 不同的二叉搜索树<br />
给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数</p>
<p>定义:</p>
<ul>
<li>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数</li>
<li>F(i,n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)</li>
</ul>
<p>则:$ G(n)=_{i=1}^{n}F(i,n) $<br />
选定一个根节点后，其左右子树的结构相互独立互不影响，因此根为 i 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积<br />
则<br />
(其实这也是个卡特兰数问题)</p>
<p>具体来说，由于我们找的是个数，只要满足搜索树要求(中序遍历是升序数组)，值毫无影响，因此对任意i问题，可以随意划分根节点并转换成左右子树各自数量相乘，不同根节点的左右子树乘积就是目标值，例如我们找根为k(<code>k&lt;i</code>)时左右积，左边是0-k,右边是k-i,值不影响形状数量，左边数量就是i'=k时的子问题，右边数量就是i'=i-k时的子问题</p>
<p>$ F(i,n)=G(i-1)G(n-i) $<br />
$ G(n)=_{i=1}^{n}G(i-1)G(n-i) $</p>
<p>优化:鉴于一些乘积会重复取用，或许可以用一个乘积数组的空间换时间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">G</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    G[<span class="number">0</span>] = <span class="number">1</span>; G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 不同的二叉搜索树 II<br />
给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案</p>
<p>与上一题不同的是需要返回生成的树，也就是要把数组G换成树组，且需要考虑不同的值，因此对相同形状的不同取值也要重新生成数，没有存储子问题的必要了，每次要调用就先生成<br />
如果想用空间表达这个问题，那么<code>G[st][ed]表示st-ed自然数序列能生成的不同bst集合</code>，其可以通过不断选取st-ed之间的一个值i作为根节点其左子树集合是<code>G[st][i-1]</code>,右子树集合是<code>G[i+1][end]</code>，两者与i这个根节点的所有组合则是所求<br />
优化:取值范围相同的二叉树集合也可以被复用,或许可以用两个索引值的哈希表存储这些树的集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">    <span class="comment">// 枚举可行根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">        vector&lt;TreeNode*&gt; leftTrees = <span class="built_in">generateTrees</span>(start, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">        vector&lt;TreeNode*&gt; rightTrees = <span class="built_in">generateTrees</span>(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTrees) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTrees) &#123;</span><br><span class="line">                TreeNode* currTree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                currTree-&gt;left = left;</span><br><span class="line">                currTree-&gt;right = right;</span><br><span class="line">                allTrees.<span class="built_in">emplace_back</span>(currTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allTrees;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 打家劫舍 III<br />
地区只有一个入口，我们称之为 <code>root</code><br />
除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警<br />
给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em></p>
<p>用 f(o) 表示选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和<br />
g(o) 表示不选择 o 节点的情况下，o 节点的子树上被选择的节点的最大权值和<br />
l 和 r 代表 o 的左右孩子</p>
<p>抢了o就不能抢它的孩子，收益是不抢两个孩子的情况和;不抢o对左右孩子选取一个最好情况相加<br />
优化:对于每个节点，我们只关心它的孩子节点们抢了和没抢的分别状况。设计一个结构，表示某个节点的 f 和 g 值，在每次递归返回的时候，都把这个点对应的 f 和 g 返回给上一级调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">unordered_map &lt;TreeNode*, <span class="type">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">    f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right];</span><br><span class="line">    g[node] = <span class="built_in">max</span>(f[node-&gt;left], g[node-&gt;left]) + <span class="built_in">max</span>(f[node-&gt;right], g[node-&gt;right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob1</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[root], g[root]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubtreeStatus</span> &#123;</span><br><span class="line">    <span class="type">int</span> selected;</span><br><span class="line">    <span class="type">int</span> notSelected;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SubtreeStatus <span class="title">dfs2</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        <span class="type">int</span> selected = node-&gt;val + l.notSelected + r.notSelected;</span><br><span class="line">        <span class="type">int</span> notSelected = <span class="built_in">max</span>(l.selected, l.notSelected) + <span class="built_in">max</span>(r.selected, r.notSelected);</span><br><span class="line">        <span class="keyword">return</span> &#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob2</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rootStatus = <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rootStatus.selected, rootStatus.notSelected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="背包问题-1">背包问题</h4>
<p>题号:1 完全平方数<br />
给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em><br />
<strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是</p>
<p><code>f[i]</code>表示最少需要多少个数的平方来表示整数i，有两种可能:</p>
<ol type="1">
<li>i本身是完全平方数，返回1</li>
<li>存在一个完全平方数k,存在非0的<code>f[i-k]</code></li>
</ol>
<p>如果第一种可能，就是k=i的特例,<code>f[i]=f[0]+1=1</code>，因此不需要额外判断<br />
遍历i不断找最小的<code>f[i-k]</code>就行了，由于i-k+k=i,因此找到后+1就是i的最优解<br />
极端情况下，由于1也是完全平方数,i超过一个可以表示数的部分总可以用1补上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_num = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) min_num = <span class="built_in">min</span>(min_num, f[i - j * j]);</span><br><span class="line">        f[i] = min_num + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 零钱兑换 II<br />
给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额<br />
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code><br />
假设每一种面额的硬币有无限个<br />
题目数据保证结果符合 32 位带符号整数</p>
<p><code>dp[i]</code>表示金额之和等于i的硬币组合数，目标是求<code>dp[amount]</code>，对每个i，如果存在一个硬币coin,<code>dp[i-coin]</code>不为0，那么就可以得到对应<code>dp[i-coin]</code>的组合数<br />
为了避免重复计算同一个组合，我们用一个外层循环固定每次用的面值，例如面值有1,2,5，那么我们先用1解决所有找零问题，固定到2时我们已经知道只用1的找零方案数了，然后我们考虑增加一些用2找零的子情况，也就是用到两个1的方案都可以加个2的情况，固定到5时也类似<br />
由于每次添加一个之前没有考虑的面值，因此不会重复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span>, <span class="title">valid</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; valid[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; coin : coins) <span class="keyword">for</span> (<span class="type">int</span> i = coin; i &lt;= amount; i++) valid[i] |= valid[i - coin];<span class="comment">//如果存在一种方式使得 valid[i] 为 1，就将其标记为可行</span></span><br><span class="line">    <span class="keyword">if</span> (!valid[amount]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; coin : coins) <span class="keyword">for</span> (<span class="type">int</span> i = coin; i &lt;= amount; i++) dp[i] += dp[i - coin];  </span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 组合总和 Ⅳ<br />
给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数<br />
题目数据保证答案符合 32 位整数范围<br />
请注意，<strong>顺序不同的序列被视作不同的组合</strong></p>
<p>本题与上题不同的是，要计算排列数而不是组合数，我们需要严格从头到尾构造，对任意i，如果可以加num得到一个和为i的排列，就加进去<br />
以及，这题闲的没事干又放一个超大用例，dp数组一定得用size_t(unsigned long long),无语</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">size_t</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums) </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num) dp[i] += dp[i - num];</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="一维问题">一维问题</h4>
<p>题号:1 乘积最大子数组<br />
给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续<br />
（该子数组中至少包含一个数字），并返回该子数组所对应的乘积<br />
测试用例的答案是一个 <strong>32位</strong> 整数</p>
<p>维护一个 fmin​(i)，它表示以第 i 个元素结尾的乘积最小子数组的乘积，由于乘法要考虑正负性，我们需要考虑之前的最小负数和最大正数，由于还可能是0，因此有可能不乘是最优解</p>
 $\begin{array}{l}{{f_{\mathrm{max}}(i)=\operatorname*{{max}_{i=1}^n}\{f_{\mathrm{max}}(i-1)\times a_{i},\,f_{\mathrm{min}}(i-1)\times a_{i},\,a_{i}\}}}\\ {{{}}}\\ {{f_{\mathrm{min}}(i)=\operatorname*{min}_{i=1}^n\{f_{\mathrm{max}}(i-1)\times a_{i},\,f_{\mathrm{min}}(i-1)\times a_{i},\,a_{i}\}}}\end{array}$  
<p>也就是说，其实只要维护一个最小值和一个最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> maxF = nums[<span class="number">0</span>], minF = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">long</span> mx = maxF, mn = minF;</span><br><span class="line">        maxF = <span class="built_in">max</span>(mx * nums[i], <span class="built_in">max</span>((<span class="type">long</span>)nums[i], mn * nums[i]));</span><br><span class="line">        minF = <span class="built_in">min</span>(mn * nums[i], <span class="built_in">min</span>((<span class="type">long</span>)nums[i], mx * nums[i]));</span><br><span class="line">        <span class="keyword">if</span>(minF&lt;INT_MIN) minF=nums[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(maxF, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:2 分割等和子集<br />
给你一个只包含正整数的非空数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等</p>
<p><code>dp[i][j]</code>表示从数组的<code>[0,i]</code>下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false</p>
<ul>
<li><code>dp[i][0]=true</code></li>
<li><code>dp[0][nums[0]]=true</code></li>
</ul>
<p>过程中规则:</p>
<ul>
<li>如果<code>j≥nums[i]</code>，则对于当前的数字<code>nums[i]</code>，可以选取也可以不选取，两种情况只要有一个为 true，就有<code>dp[i][j]=true</code>
<ul>
<li>如果不选取<code>nums[i]</code>，则 <code>dp[i][j]=dp[i−1][j]</code></li>
<li>如果选取<code>nums[i]</code>，则 <code>dp[i][j]=dp[i−1][j−nums[i]]</code></li>
</ul></li>
<li>如果<code>j&lt;nums[i]</code>，则在选取的数字的和等于j的情况下无法选取当前的数字<code>nums[i]</code>，因此有<code>dp[i][j]=dp[i−1][j]</code></li>
</ul>
<p>在计算 dp 的过程中，每一行的 dp 值都只与上一行的 dp 值有关，因此只需要一个一维数组即可将空间复杂度降到 O(target)。此时的转移方程为：<span class="math inline">\(dp[j]=dp[j]\mid dp[j-n u m s[i]]\)</span><br />
第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 <code>dp[j]</code> 值的时候，<code>dp[j−nums[i]]</code>已经是被更新过的状态，不再是上一行的 dp 值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxNum &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= num) dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition_better</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        maxNum = <span class="built_in">max</span>(maxNum, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxNum &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= num; --j) dp[j] |= dp[j - num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 解决智力问题<br />
给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>questions</code> ，其中 <code>questions[i] = [pointsi, brainpoweri]</code><br />
这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong> （也就是从问题<code>0</code>开始依次解决），针对每个问题选择 <strong>解决</strong> 或者 <strong>跳过</strong> 操作。解决问题 <code>i</code> 将让你 <strong>获得</strong> <code>pointsi</code> 的分数，但是你将 <strong>无法</strong> 解决接下来的 <code>brainpoweri</code> 个问题（即只能跳过接下来的 <code>brainpoweri</code>个问题）。如果你跳过问题 <code>i</code> ，你可以对下一个问题决定使用哪种操作</p>
<ul>
<li>比方说，给你 <code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>：
<ul>
<li>如果问题 <code>0</code> 被解决了， 那么你可以获得 <code>3</code> 分，但你不能解决问题 <code>1</code> 和 <code>2</code></li>
<li>如果你跳过问题 <code>0</code> ，且解决问题 <code>1</code> ，你将获得 <code>4</code> 分但是不能解决问题 <code>2</code> 和 <code>3</code></li>
</ul></li>
</ul>
<p>请你返回这场考试里你能获得的 <strong>最高</strong> 分数</p>
<p>从无后效性的角度考虑动态规划「状态」的定义。对于每一道题目，解决与否会影响到后面一定数量题目的结果，但不会影响到前面题目的解决。因此我们可以考虑从反方向定义「状态」，即考虑解决每道题本身及以后的题目可以获得的最高分数<br />
用<code>dp[i]</code>来表示解决<strong>第 i 道题目及以后的题目</strong>可以获得的最高分数。同时，我们从后往前遍历题目，并更新 dp 数组</p>
<ol type="1">
<li>不解决第 i 道题目，此时 <code>dp[i]=dp[i+1]</code></li>
<li>解决第 i 道题目，我们只能解决下标大于<code>i+brainpower[i]</code>的题目，而此时根据 dp 数组的定义，解决这些题目的最高分数为 <code>dp[i+brainpower[i]+1]</code>（当 i≥n 的情况下，我们认为 <code>dp[i]=0</code>）。因此，我们有：</li>
</ol>
<p><span class="math inline">\(d p[i]=\operatorname*{max}(d p[i+1],p o i n t{s[i]}+d p[\operatorname*{min}(n,i+b r a i n p o w e r[i]+1)]).\)</span></p>
<p>预留<code>dp[n]=0</code>用来表示没有做任何题目的分数，则:<span class="math inline">\(dp[i]=\operatorname*{max}(dp[i+1],p o i n t s[i]+dp[\operatorname*{min}(n,i+b r a i n p o w e r[i]+1)]).\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mostPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; questions)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = questions.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;   <span class="comment">// 解决每道题及以后题目的最高分数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) dp[i] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>], questions[i][<span class="number">0</span>] + dp[<span class="built_in">min</span>(n, i + questions[i][<span class="number">1</span>] + <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 零钱兑换<br />
给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额<br />
计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code><br />
你可以认为每种硬币的数量是无限的</p>
<p>令F(S)为组成金额 S 所需的最少硬币数量，如果存在一个硬盘面额c,f(s-c)存在，则f(s)=f(s-c)+1<br />
那么通过递归不断从小到大遍历寻找就行了，此外还需要一个数组用于记忆化<br />
迭代法的情况下，从1开始，每个s都是对所有硬币面额c找一个最优s-c的情况再加一</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; count;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> rem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rem &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//说明找完了</span></span><br><span class="line">    <span class="keyword">if</span> (count[rem - <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> Min = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin:coins) &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">dp</span>(coins, rem - coin);<span class="comment">//如果是-1则找不了，0及以上说明有解</span></span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">0</span> &amp;&amp; res &lt; Min) Min = res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count[rem - <span class="number">1</span>] = Min == INT_MAX ? <span class="number">-1</span> : Min;</span><br><span class="line">    <span class="keyword">return</span> count[rem - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    count.<span class="built_in">resize</span>(amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(coins, amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange_dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin: coins) </span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i) dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 统计构造好字符串的方案数<br />
给你整数 <code>zero</code> ，<code>one</code> ，<code>low</code> 和 <code>high</code> ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>
<ul>
<li>将 <code>'0'</code> 在字符串末尾添加 <code>zero</code> 次</li>
<li>将 <code>'1'</code> 在字符串末尾添加 <code>one</code> 次</li>
</ul>
<p>以上操作可以执行任意次<br />
如果通过以上过程得到一个 <strong>长度</strong> 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <strong>好</strong> 字符串<br />
请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>10 + 7</code> <strong>取余</strong> 后返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(high + <span class="number">1</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>&amp; res = memo[i]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>)  <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> res = (<span class="built_in">dfs</span>(dfs, i - zero) + <span class="built_in">dfs</span>(dfs, i - one)) % MOD;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; i++) res = (res + <span class="built_in">dfs</span>(dfs, i)) % MOD;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:6 解码方法<br />
一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：<code>"1" -&gt; 'A' "2" -&gt; 'B' ... "25" -&gt; 'Y' "26" -&gt; 'Z'</code><br />
然而，在 <strong>解码</strong> 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（<code>"2"</code> 和 <code>"5"</code> 与 <code>"25"</code>）<br />
例如，<code>"11106"</code> 可以映射为：</p>
<ul>
<li><code>"AAJF"</code> ，将消息分组为 <code>(1, 1, 10, 6)</code></li>
<li><code>"KJF"</code> ，将消息分组为 <code>(11, 10, 6)</code></li>
<li>消息不能分组为 <code>(1, 11, 06)</code> ，因为 <code>"06"</code> 不是一个合法编码（只有 "6" 是合法的）</li>
</ul>
<p>注意，可能存在无法解码的字符串<br />
给你一个只含数字的 <strong>非空 </strong>字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。如果没有合法的方式解码整个字符串，返回 <code>0</code><br />
题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数</p>
<ol type="1">
<li>当前字符为 <code>0</code>，和它前一个的组合编码不合法，则整个编码不可被解码，返回 <code>0</code> 即可，比如遇到了 <code>00</code>，<code>60</code>等</li>
<li>当前字符为 <code>0</code>，和它前一个的组合编码合法，则<strong>只能</strong>将当前字符 <code>0</code> 和它的前一个字符“绑定”为“一个字符”，比如遇到了 <code>10</code>，<code>20</code>等（实际上只能是这两种情况）</li>
<li>当前字符不为 <code>0</code>，和它前一个的组合编码不合法，则<strong>只能</strong>将当前字符看做一个单独的编码，比如遇到了 <code>01</code>，<code>94</code>等</li>
<li>当前字符不为 <code>0</code>，和它前一个的组合编码合法，则可以将当前字符看做是一个单独的编码，也可以和它的前一个字符绑定，比如遇到了 <code>11</code>，<code>24</code>等，只有这种情况下有两种分叉</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, x = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        x = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> || x &gt; <span class="number">26</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">26</span> || x &lt; <span class="number">10</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:7 最低票价<br />
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 <code>days</code> 的数组给出。每一项是一个从 <code>1</code> 到 <code>365</code> 的整数<br />
火车票有 <strong>三种不同的销售方式</strong> ：</p>
<ul>
<li>一张 <strong>为期一天</strong> 的通行证售价为 <code>costs[0]</code> 美元</li>
<li>一张 <strong>为期七天</strong> 的通行证售价为 <code>costs[1]</code> 美元</li>
<li>一张 <strong>为期三十天</strong> 的通行证售价为 <code>costs[2]</code> 美元</li>
</ul>
<p>通行证允许数天无限制的旅行。例如，如果我们在第 <code>2</code> 天获得一张 <strong>为期 7 天</strong> 的通行证，那么我们可以连着旅行 7 天：第 <code>2</code> 天、第 <code>3</code> 天、第 <code>4</code> 天、第 <code>5</code> 天、第 <code>6</code> 天、第 <code>7</code> 天和第 <code>8</code> 天<br />
返回你想要完成在给定的列表 <code>days</code> 中列出的每一天的旅行所需要的最低消费</p>
<p><code>dp[i]</code>表示第i天旅游的情况下，<code>[1,i]</code>这段日子的最小花费。在这个定义下，答案就应该是<code>dp[days.back()]</code><br />
首先没开始的时候肯定不花钱，<code>dp[0]=0</code>。令j=0指向数组days的首元素，如果第i天不旅游，状态转移方程即为<code>dp[i]=dp[i−1]</code><br />
如果<code>i=days[j]</code>，那为了保证第i天旅游，有三种选择策略。状态转移方程为<code>dp[i]=min(dp[max(0,i−1)]+costs[0],dp[max(0,i−7)]+costs[1],dp[max(0,i−30)]+costs[2])</code>，分别表示选择1、7、30天有效期的策略，选择最小的转移，转移完记得让j右移 事实上，当j≥n（n为days的长度）时就可以停止DP过程了，因为最后一个需要旅行的日子已经安排完了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mincostTickets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; days, vector&lt;<span class="type">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">366</span>,<span class="number">0x3f</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= <span class="number">365</span> &amp;&amp; j &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(i == days[j]) &#123;</span><br><span class="line">            dp[i] = dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">1</span>)] + costs[<span class="number">0</span>];</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>]);</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[days.<span class="built_in">back</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="技巧">技巧</h3>
<p>题号:1 只出现一次的数字<br />
给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素<br />
如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法:</p>
<ul>
<li>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字</li>
<li>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字</li>
<li>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字</li>
</ul>
<p>但是常数空间线性时间的解法呢？注意到(别问怎么注意到的),任意偶数个相同的数异或运算都是0，而0和任意奇数个相同的数异或运算都是那个奇数的数，因此所有数异或就能得到答案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i: nums) temp ^=i;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note info"><p>cpp位运算:</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;</td>
<td>与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr class="even">
<td>|</td>
<td>或</td>
<td>两个位都为0时，结果才为0</td>
</tr>
<tr class="odd">
<td>^</td>
<td>异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr class="even">
<td>~</td>
<td>取反</td>
<td>0变1，1变0</td>
</tr>
<tr class="odd">
<td>&lt;&lt;</td>
<td>左移</td>
<td>各二进位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td>右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td>
</tr>
</tbody>
</table>
</div>
<p>题号:2 多数元素<br />
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素<br />
你可以假设数组是非空的，并且给定的数组总是存在多数元素</p>
<ol type="1">
<li>最简单的做法是哈希表，不赘述<br />
</li>
<li>其次是排序，比较排序无法线性复杂度，但如果堆排可以常数空间</li>
<li>如果将 <code>nums</code> 分成两部分，那么 <code>a</code> 必定是至少一部分的众数,可以使用分治法，向上合并时，如果两侧众数不同需要遍历算出正确的众数</li>
<li>Boyer-Moore 算法:
<ol type="1">
<li>维护一个候选众数<code>candidate</code>和它出现的次数<code>count</code>初始时<code>candidate</code>可以为任意值，<code>count</code>为<code>0</code>；</li>
<li>遍历数组<code>nums</code>中的所有元素，对于每个元素<code>x</code>，在判断<code>x</code>之前，如果<code>count</code>的值为<code>0</code>，我们先将<code>x</code>的值赋予<code>candidate</code>，判断<code>x</code>：
<ol type="1">
<li>如果<code>x</code>与<code>candidate</code>相等，那么计数器<code>count</code>的值增加<code>1</code></li>
<li>如果<code>x</code>与<code>candidate</code>不等，那么计数器<code>count</code>的值减少<code>1</code></li>
</ol></li>
<li>在遍历完成后，<code>candidate</code>即为整个数组的众数</li>
</ol></li>
</ol>
<p>看起来很抽象？可以这么想，对真正的众数来说，其他数加在一起和众数相消，最后剩下的也只有众数；并且对任意对数的相消之后，这个性质都成立.为什么呢？设众数为x，非众数统称为y1-yk,不同的两个数能相消，假设y系数团结起来全部和众数想消，众数也会赢，如果y系数发生内斗相消，众数反而赢得更多，因此只要不断相消，众数就会赢到最后<br />
在这个算法中，candidate就是下次相消操作的被挑战者，极端情况下candidate从始至终是众数，其count也会严格大于0，而对其他candidate，再怎么相消也赢不过众数<br />
形象地说，可以称为相杀算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_in_range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = lo; i &lt;= hi; ++i)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target) ++count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majority_element_rec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> nums[lo];</span><br><span class="line">    <span class="type">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> left_majority = <span class="built_in">majority_element_rec</span>(nums, lo, mid);</span><br><span class="line">    <span class="type">int</span> right_majority = <span class="built_in">majority_element_rec</span>(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>) <span class="keyword">return</span> left_majority;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">count_in_range</span>(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>) <span class="keyword">return</span> right_majority;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement_div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">majority_element_rec</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement_vote</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == candidate) ++count;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:3 颜色分类<br />
给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列<br />
我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色<br />
必须在不使用库内置的 sort 函数的情况下解决这个问题</p>
<p>本题是经典的「荷兰国旗问题」，由计算机科学家 <a href="https://leetcode.cn/link/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E8%89%BE%E5%85%B9%E6%A0%BC%C2%B7%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB">Edsger W. Dijkstra</a> 首先提出<br />
很容易想到可以像快排一样用一个枢纽(此题里存索引就可以)划分两个部分不断交换，但既然有三个颜色，那就需要两个分界点<br />
这样一来有个问题，假设0-i是0部分，(i+1)-j是1部分，长度都不为0，那么0部分想拓展就需要挤占1部分，此时交换i+1(j部分开头)和当前索引v后，需要再把v和j+1交换<br />
下方代码使用准确界限，即p0,p1指向0，1区最后一个元素，初始为-1,极端情况下全一数组，p1也会始终和i同步更新,p1+1&lt;=i，因此不会越界</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> p0 = <span class="number">-1</span>, p1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) <span class="built_in">swap</span>(nums[i], nums[++p1]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[<span class="number">1</span> + p0]);</span><br><span class="line">            <span class="keyword">if</span> (p0 &lt; p1) <span class="built_in">swap</span>(nums[i], nums[p1 + <span class="number">1</span>]);</span><br><span class="line">            ++p1;++p0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:4 下一个排列<br />
整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code></li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code></li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code></li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列<br />
必须<strong>原地</strong>修改，只允许使用额外常数空间</p>
<p>下一个排列的性质:</p>
<ol type="1">
<li>需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列</li>
<li>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小</li>
</ol>
<p>具体地，我们这样描述该算法，对于长度为 n 的排列 a：</p>
<ol type="1">
<li>首先从后向前查找第一个顺序对 <code>(i,i+1)</code>，满足 <code>a[i]&lt;a[i+1]</code>(完全逆序就是最大序列了)。此时 <code>[i+1,n)</code> 必然是下降序列(从后往前找顺序对，说明找到的结果后没有这样的顺序对)</li>
<li>如果找到了顺序对，那么在区间<code>[i+1,n)</code>中从后向前查找第一个元素 j 满足<code>a[i]&lt;a[j]</code>,即找一个比<code>a[i]</code>大的数中的最小数</li>
<li>交换 <code>a[i]</code> 与 <code>a[j]</code>，此时可以证明区间<code>[i+1,n)</code>必为降序。我们可以直接使用双指针反转区间<code>[i+1,n)</code>使其变为升序，而无需对该区间进行排序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;<span class="comment">//保证i+1不越界</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) i--;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) j--;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题号:5 寻找重复数<br />
给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数<br />
假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong><br />
你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间</p>
<p>此题的其他官解都很……难以理解，只看第三种做法<br />
我们对<code>nums</code>数组建图，每个位置<code>i</code>视为一条 <code>i→nums[i]</code> 的边。由于存在且仅存在一个重复的数字<code>target</code>，因此<code>target</code>这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的<code>target</code>就是这个环的入口，那么整个问题就等价于环形链表<br />
我们已经证明过如果慢指针从起点出发，快指针从相遇位置出发，快慢指针会在环的入口相遇，所以复刻就行了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slow =nums[<span class="number">0</span>] , fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A0%94distance/" rel="tag"><i class="fa fa-tag"></i> 研distance</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 数据结构与算法</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/thinklive/57068/" rel="prev" title="恐怖人偶剧场古兰吉涅尔">
                  <i class="fa fa-angle-left"></i> 恐怖人偶剧场古兰吉涅尔
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/thinklive/3231/" rel="next" title="基于赫尔辛基大学《深入浅出现代Web编程》的web笔记">
                  基于赫尔辛基大学《深入浅出现代Web编程》的web笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">thinklive</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">588k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">35:38</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 技术支持
  </div><script defer src="/lib/three.js"></script><script defer src="/lib/lines.js"></script><script defer src="/lib/waves.js"></script>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>


  <script src=""></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>


<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  <script src="/js/third-party/addtoany.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://thinklive1.github.io/thinklive/23981/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"thinklive1/blog_comments","issue_term":"pathname","theme":"photon-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script>
<script>
    const snowflakes = ["❄", "❄", "❆", "❅", "✥","❄", "❄", "❆", "❅", "✥","✻"];
    // 创建雪花
    function createSnowflake() {
        const snowflake = document.createElement("span");
        snowflake.classList.add("snowflake");
        const randomIndex = Math.floor(Math.random() * snowflakes.length);
        snowflake.textContent = snowflakes[randomIndex];
        
        // 起始位置
        /* 80%概率 生成在页面两侧 30% 的位置
        const probability = Math.random();
        let startPosition = Math.random() * 100;

        if (probability < 0.8) {
            startPosition = Math.random() < 0.5 ? Math.random() * 30 : (Math.random() * 30) + 70;
        }
        snowflake.style.left = `${startPosition}vw`;
        */
        snowflake.style.left = `${Math.random() * 100}vw`;
        snowflake.style.top = `-30px`;
        // 雪花大小与透明度
        const size = Math.random() * 18 + 10;
        snowflake.style.fontSize = `${size}px`;
        const opacity = Math.random() * 0.6 + (size > 18 ? 0.4 : 0);
        snowflake.style.setProperty("--opacity", opacity);
        // 动画持续时间
        const fallDuration = Math.random() * 10 + 10;
        // 旋转持续时间
        const rotateDuration = Math.random() * 3 + 1;

        snowflake.style.animationDuration = `${fallDuration}s, ${fallDuration}s`; // 向 CSS 添加淡出动画的持续时间
        // 横向幅度
        const translateX = (Math.random() * 500 - 200);
        snowflake.style.setProperty("--translateX", `${translateX}px`);
        // 纵向幅度
        snowflake.style.setProperty("--translateY", `${window.innerHeight}px`);

        document.body.appendChild(snowflake);
        // 移除雪花
        setTimeout(() => {
            snowflake.remove();
        }, fallDuration * 1000);
    }
    
    function snowfallAnimation() {
        // 载入时若边栏是隐藏状态则不加载雪花
        const sidebarnav = document.querySelector('.sidebar');
        const sidebarnavdisplay = window.getComputedStyle(sidebarnav).getPropertyValue('display'); 
        if (sidebarnavdisplay !== 'none') {
            createSnowflake();
        }
        setTimeout(snowfallAnimation, 150); // 生成速度，毫秒
    }
    snowfallAnimation();
function toggleMode() {
    console.log("change color!");
    const root1 = document.documentElement;

    // 检查当前 color-scheme
    const isLightMode = getComputedStyle(root1).getPropertyValue('--content-bg-color').trim() === '#fff';

    if (isLightMode) {
        // 切换到暗模式
        root1.style.setProperty('--content-bg-color', '#000');
        root1.style.setProperty('--text-color', '#fff');
        root1.style.setProperty('--highlight-background', '#444');
        root1.style.setProperty('--highlight-foreground', '#bbb');
        root1.style.setProperty('--btn-default-bg', '#777');
        root1.style.setProperty('--menu-item-bg-color', '#777');
        root1.style.setProperty('--note-warning-bg-color', '#777');
        root1.style.setProperty('--note-bg-color', '#555');
        root1.style.setProperty('--note-info-bg-color', '#777');
        root1.style.setProperty('--table-row-odd-bg-color', '#777');
        root1.style.transition = 'all 0.5s ease';

    }

    else {
        root1.style.setProperty('--content-bg-color', '#fff');
        root1.style.setProperty('--text-color', '#555');
        root1.style.setProperty('--highlight-background', '#eaeef3');
        root1.style.setProperty('--highlight-foreground', '#00193a');
        root1.style.setProperty('--btn-default-bg', '#fff');
        root1.style.setProperty('--menu-item-bg-color', '#f5f5f5');
        root1.style.setProperty('--note-warning-bg-color', '#fdf8ea');
        root1.style.setProperty('--note-bg-color', '#f9f9f9');
        root1.style.setProperty('--note-info-bg-color', '#eef7fa');
        root1.style.setProperty('--table-row-odd-bg-color', '#f9f9f9');
        root1.style.transition = 'all 0.5s ease';
    }
}

function DarkTrigger() {
    console.log('dark!!')
    let isDarkMode = getComputedStyle(document.documentElement).getPropertyValue('--content-bg-color').trim() === '#000';
    console.log(isDarkMode)
    if (isDarkMode) {
        // 切换到暗模式
        const warningNotes = document.querySelectorAll('.post-body .note.warning');
        // 修改背景颜色
        warningNotes.forEach(note => {
        note.style.background = '#666';
        });

        const infoNotes = document.querySelectorAll('.post-body .note.info');
        // 修改背景颜色
        infoNotes.forEach(note => {
        note.style.background = '#666';
        });
    }
}


</script>

 <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<button style="background: #868686;
  width: 3rem;
  height: 3rem;
  position: fixed;
  border-radius: 50%;
  border: none;
  right: unset;
  bottom: 2rem;
  left: 2rem;
  cursor: pointer;
  transition: all 0.5s ease;
  display: flex;
  justify-content: center;
  align-items: center;" class="darkmode-toggle" role="checkbox" onclick="toggleMode()">🌓</button>

  <video autoplay loop muted playsinline style="position:fixed;top:50%;opacity: 0.8;left:50%;min-width:100%;min-height:100%;transform:translateX(-50%)translateY(-50%);z-index:-2;">
  <source src="/images/red.mp4" type="video/mp4">
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
