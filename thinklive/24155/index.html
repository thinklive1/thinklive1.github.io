<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinklive1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#66CCFF","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="概念 数据  数据：信息的载体，在计算机中是符号的集合 数据元素：数据的基本单位，一个整体，由一些不可分割的数据项组成，例如一个学生档案 数据对象：有相同性质的数据元素集合，是数据的子集 数据类型：数据值的类型，和对这个类型特定操作的集合 数据结构：相互之间存在特殊关系的数据元素的集合，这种特殊关系就是所谓的结构。  数据结构包括三个方面  逻辑结构(数据的逻辑关系，和怎么存储在计算机中无关) 存">
<meta property="og:type" content="article">
<meta property="og:title" content="研distance——数据结构部分">
<meta property="og:url" content="https://thinklive1.github.io/thinklive/24155/index.html">
<meta property="og:site_name" content="thinklive">
<meta property="og:description" content="概念 数据  数据：信息的载体，在计算机中是符号的集合 数据元素：数据的基本单位，一个整体，由一些不可分割的数据项组成，例如一个学生档案 数据对象：有相同性质的数据元素集合，是数据的子集 数据类型：数据值的类型，和对这个类型特定操作的集合 数据结构：相互之间存在特殊关系的数据元素的集合，这种特殊关系就是所谓的结构。  数据结构包括三个方面  逻辑结构(数据的逻辑关系，和怎么存储在计算机中无关) 存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231129144215.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231130102600.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/%7B0273A086-DB7E-4fb9-80BB-72F790BBE170%7D.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240330224100.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240330223751.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240330224418.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240330224753.png">
<meta property="og:image" content="https://thinklive1.github.io/resources/tree.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240406214612.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240406220758.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240409132729.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240409133039.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240409133312.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240410171546.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240411170810.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240411171623.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240411171432.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240411172832.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240411172839.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240411173500.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240411173625.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240508204456.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240510115617.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240511113354.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_rotate_with_grandchild.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_rotate_with_grandchild.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_right_rotate.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_left_rotate.png">
<meta property="og:image" content="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241111165247.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241111171032.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241111171040.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241111171051.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241112103548.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241112103600.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241112103610.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241112103620.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020241112103632.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050104.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050105.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050106.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050108.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050110.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050111.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050113.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240511224819.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240522232019.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240522233010.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240522234037.png">
<meta property="article:published_time" content="2023-11-29T13:12:22.000Z">
<meta property="article:modified_time" content="2025-09-09T07:53:29.844Z">
<meta property="article:author" content="thinklive">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231129144215.png">


<link rel="canonical" href="https://thinklive1.github.io/thinklive/24155/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://thinklive1.github.io/thinklive/24155/","path":"thinklive/24155/","title":"研distance——数据结构部分"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>研distance——数据结构部分 | thinklive</title>
  







<script type="text/javascript" async src="/js/fairyDustCursor.js"></script>
<script type="text/javascript" async src="/js/tab-title.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script src="/js/tab-title.js"></script>

<!--pjax：防止跳转页面音乐暂停-->
<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script>
const options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: false, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}

const darkmode = new Darkmode(options);
</script>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="thinklive" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>


  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">thinklive</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">dirichlet library</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索 | search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页-|-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页 | home</a></li><li class="menu-item menu-item-标签-|-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags</a></li><li class="menu-item menu-item-分类-|-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories</a></li><li class="menu-item menu-item-归档-|-archive"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archive</a></li><li class="menu-item menu-item-相册-|-photo"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册 | photo</a></li><li class="menu-item menu-item-留言-|-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言 | guestbook</a></li><li class="menu-item menu-item-感谢-|-thank"><a href="/thanks/" rel="section"><i class="fa custom thanks fa-fw"></i>感谢 | thank</a></li><li class="menu-item menu-item-游戏-|-game"><a href="/game/bad1.html" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏 | game</a></li><li class="menu-item menu-item-神龛-|-shrine"><a href="/cyberblog/" rel="section"><i class="fa fa-microchip fa-fw"></i>神龛 | shrine</a></li><li class="menu-item menu-item-资源地图-|-resourcemap"><a href="/webstack/" rel="section"><i class="fa fa-list fa-fw"></i>资源地图 | resourcemap</a></li><li class="menu-item menu-item-思维导图-|-mindmap"><a href="/mindmap/index.html" rel="section"><i class="fa fa-map fa-fw"></i>思维导图 | mindmap</a></li><li class="menu-item menu-item-网站地图-|-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>网站地图 | sitemap</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">


<!--网易云音乐插件-->
<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->
<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--网易云playlist外链地址-->   
<meting-js
    server="netease"
    type="playlist" 
    id="2762741085"
    mini="false"
    fixed="false"
    list-folded="true"
    autoplay="false"
    volume="0.2"
    theme="#4c4c4c"
    order="random"
    loop="all"
    preload="auto"
    mutex="true">
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.</span> <span class="nav-text">数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">顺序表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.2.</span> <span class="nav-text">链式表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.1.</span> <span class="nav-text">基本操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E9%98%9F%E5%88%97%E7%9F%A9%E9%98%B5"><span class="nav-number">3.</span> <span class="nav-text">栈&amp;&amp;队列&amp;&amp;矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">3.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5"><span class="nav-number">3.3.</span> <span class="nav-text">数组与矩阵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.1.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.1.1.</span> <span class="nav-text">线索二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97"><span class="nav-number">4.2.</span> <span class="nav-text">森林</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">树的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">4.3.1.</span> <span class="nav-text">并查集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8"><span class="nav-number">5.1.</span> <span class="nav-text">存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="nav-number">5.1.1.</span> <span class="nav-text">邻接矩阵法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="nav-number">5.1.2.</span> <span class="nav-text">邻接表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-number">5.1.3.</span> <span class="nav-text">十字链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-number">5.1.4.</span> <span class="nav-text">邻接多重表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1"><span class="nav-number">5.1.5.</span> <span class="nav-text">基本操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">5.2.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">5.3.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">5.3.1.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">5.3.2.</span> <span class="nav-text">带权图的最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">5.3.3.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">5.3.4.</span> <span class="nav-text">关键路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">6.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">基本分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">6.1.1.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">6.1.2.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-number">6.1.3.</span> <span class="nav-text">分块查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">6.2.</span> <span class="nav-text">使用树的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bst"><span class="nav-number">6.2.1.</span> <span class="nav-text">BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91avlbalanced-binary-tre"><span class="nav-number">6.2.2.</span> <span class="nav-text">平衡二叉树AVL(Balanced Binary Tre)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">旋转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">常见操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">6.2.3.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b%E6%A0%91"><span class="nav-number">6.2.4.</span> <span class="nav-text">B树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C-1"><span class="nav-number">6.2.4.1.</span> <span class="nav-text">常见操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b%E6%A0%91-1"><span class="nav-number">6.2.4.2.</span> <span class="nav-text">B+树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8Dkmp%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">字符串匹配KMP算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-number">6.4.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="nav-number">6.4.1.</span> <span class="nav-text">冲突处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">7.1.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5"><span class="nav-number">7.1.1.</span> <span class="nav-text">折半插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94shell%E6%8E%92%E5%BA%8F"><span class="nav-number">7.1.2.</span> <span class="nav-text">希尔(shell)排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-number">7.2.</span> <span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">7.2.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">7.2.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">7.3.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">7.3.1.</span> <span class="nav-text">简单选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">7.3.2.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">7.4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">7.5.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E5%B0%8F%E7%BB%93"><span class="nav-number">7.6.</span> <span class="nav-text">内部排序小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">7.7.</span> <span class="nav-text">外部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">7.7.1.</span> <span class="nav-text">置换-选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="nav-number">7.7.2.</span> <span class="nav-text">最佳归并树</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="thinklive"
      src="/images/thive.png">
  <p class="site-author-name" itemprop="name">thinklive</p>
  <div class="site-description" itemprop="description">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinklive1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinklive1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/t469631989@gmail.com" title="E-Mail → t469631989@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/38099250?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;38099250?spm_id_from&#x3D;333.1007.0.0" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/thinkliving" title="steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;thinkliving" rel="noopener me" target="_blank"><i class="fa custom steam fa-fw"></i>steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

<div style="Text-align:center;width:100%"><div style="margin:0 auto"><canvas id="canvas" style="width:60%" height="100" width="700">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){function t(t,e){for(var a=0;a<l[e].length;a++)for(var n=0;n<l[e][a].length;n++)1==l[e][a][n]&&(h.beginPath(),h.arc(14*(g+2)*t+2*n*(g+1)+(g+1),2*a*(g+1)+(g+1),g,0,2*Math.PI),h.closePath(),h.fill())}function e(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a=[];a.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var r=c.length-1;r>=0;r--)a[r]!==c[r]&&t.push(r+"_"+(Number(c[r])+1)%10);for(var r=0;r<t.length;r++)n.apply(this,t[r].split("_"));c=a.concat()}function a(){for(var t=0;t<d.length;t++)d[t].stepY+=d[t].disY,d[t].x+=d[t].stepX,d[t].y+=d[t].stepY,(d[t].x>i+g||d[t].y>f+g)&&(d.splice(t,1),t--)}function n(t,e){for(var a=[1,2,3],n=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],r=0;r<l[e].length;r++)for(var o=0;o<l[e][r].length;o++)if(1==l[e][r][o]){var h={x:14*(g+2)*t+2*o*(g+1)+(g+1),y:2*r*(g+1)+(g+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*a[Math.floor(Math.random()*a.length)],color:n[Math.floor(Math.random()*n.length)],disY:1};d.push(h)}}function r(){o.height=100;for(var e=0;e<c.length;e++)t(e,c[e]);for(var e=0;e<d.length;e++)h.beginPath(),h.arc(d[e].x,d[e].y,g,0,2*Math.PI),h.fillStyle=d[e].color,h.closePath(),h.fill()}var l=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],o=document.getElementById("canvas");if(o.getContext){var h=o.getContext("2d"),f=100,i=700;o.height=f,o.width=i,h.fillStyle="#f00",h.fillRect(10,10,50,50);var c=[],d=[],g=o.height/20-1;!function(){var t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date);c.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6])}(),clearInterval(v);var v=setInterval(function(){e(),a(),r()},50)}}()</script></div>
<img class= 'logo' src="/images/thinklive_cyber.png"; z-index: '0'; style="max-width: 100%; width: auto; height: auto;background-color: --content-bg-color;">

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thinklive1.github.io/thinklive/24155/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/thive.png">
      <meta itemprop="name" content="thinklive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="thinklive">
      <meta itemprop="description" content="起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="研distance——数据结构部分 | thinklive">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          研distance——数据结构部分
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-29 21:12:22" itemprop="dateCreated datePublished" datetime="2023-11-29T21:12:22+08:00">2023-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-09 15:53:29" itemprop="dateModified" datetime="2025-09-09T15:53:29+08:00">2025-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">考研笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/%E7%A0%94distance/" itemprop="url" rel="index"><span itemprop="name">研distance</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>30k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:47</span>
    </span>
</div>

        
        </div>
      </header>
   

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="概念">概念</h1>
<h2 id="数据">数据</h2>
<ul>
<li><code>数据</code>：信息的载体，在计算机中是符号的集合</li>
<li><code>数据元素</code>：数据的基本单位，一个整体，由一些不可分割的数据项组成，例如一个学生档案</li>
<li><code>数据对象</code>：有相同性质的数据元素集合，是数据的子集</li>
<li><code>数据类型</code>：数据值的类型，和对这个类型特定操作的集合</li>
<li><code>数据结构</code>：相互之间存在特殊关系的数据元素的集合，这种特殊关系就是所谓的结构。</li>
</ul>
<p>数据结构包括三个方面</p>
<ul>
<li><code>逻辑结构</code>(数据的逻辑关系，和怎么存储在计算机中无关)</li>
<li><code>存储结构</code>(数据在计算机中的表示)
<ul>
<li><code>顺序存储</code>：元素存储在相邻的地址间，不需要额外索引，可以随机读写，但容易产生外部碎片</li>
<li><code>链式存储</code>：每个元素不仅存储值，还存储指向下一个元素的指针，不会产生碎片，但占用空间较大</li>
<li><code>索引存储</code>：建立一个外部索引表，利用索引表对数据进行读写，需要额外空间并管理表格</li>
<li><code>散列存储</code>：对每个元素用一个哈希函数计算其存储的地址，需要恰当的哈希函数</li>
</ul></li>
<li><code>数据的运算</code></li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231129144215.png" /></p>
<p><code>ADT</code>(抽象数据类型)构成一个完整的数据结构定义</p>
<span id="more"></span>
<h2 id="算法">算法</h2>
<p>算法是对指定输入的一系列指令 特性：</p>
<ul>
<li><code>有穷性</code>，执行时间和指令次数有穷</li>
<li><code>确定性</code>，指令有确定的含义，相同输入输出一定相同</li>
<li><code>可行性</code>，指令都是以及明确实现有定义的</li>
<li><code>输入</code>：有零个或者多个输入</li>
<li><code>输出</code>：有一个或以上的输出</li>
</ul>
<p>需要实现的目标：正确，可读，健壮(对于非法数据，也输出可控)，效率</p>
<p><code>复杂度</code>：略</p>
<h1 id="线性表">线性表</h1>
<p><code>定义</code>：有相同数据类型的n个数据元素的有限序列,元素直接存在前后关系，且只能线性前后排列,其中的元素都是数据元素，类型相同<br />
<code>类别</code>：逻辑结构，而非顺序表链表等存储结构<br />
<code>基本操作</code>：</p>
<ul>
<li>初始化</li>
<li>按值查找</li>
<li>按位查找</li>
<li>删除元素</li>
<li>输出(如输出到ostream)</li>
<li>求表长</li>
<li>销毁</li>
<li>判空</li>
</ul>
<hr />
<h2 id="顺序表">顺序表</h2>
<p><code>定义</code>:线性表的顺序存储是顺序表，用连续的地址存储表内元素，让逻辑顺序和物理顺序相同<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231130102600.png" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50     <span class="comment">//定义线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType* data[Maxsize]; <span class="comment">//顺序表的元素</span></span><br><span class="line">	<span class="type">int</span> length;      <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;        <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">L.data=<span class="keyword">new</span> ElemType[InitSize]; <span class="comment">//动态分配</span></span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>插入操作</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(sqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) &#123;<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= Maxsize) &#123;</span><br><span class="line">    <span class="comment">//当前存储空间已满,不能插入  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--) &#123;</span><br><span class="line">    <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L.data[i<span class="number">-1</span>] = e; <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++; <span class="comment">//线性表长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均时间分析：</p>
<p><span class="math inline">\(\sum_{i=1}^{n+1}p_{i}(n-i+1)=\sum_{i=1}^{n+1}{\frac{1}{n+1}}(n-i+1)={\frac{1}{n+1}}\sum_{i=1}^{n+1}(n-i+1)={\frac{1}{n+1}}{\frac{n(n+1)}{2}}={\frac{n}{2}}\)</span></p>
<ol start="2" type="1">
<li>删除操作<br />
平均时间分析：</li>
</ol>
<p><span class="math inline">\(\sum_{i=1}^{n}p_{i}(n-i)=\sum_{i=1}^{n}{\frac{1}{n}}(n-i)={\frac{1}{n}}\sum_{i=1}^{n}(n-i)={\frac{1}{n}}{\frac{n(n-1)}{2}}={\frac{n-1}{2}}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,Elemtype &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;L.length; j++) &#123;</span><br><span class="line">    <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>] = L.data[j];  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>按值查找</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e) <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//下标为i的元素值等于e,返回其位序i+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出循环,说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均情况：假设pi是(pi=1/n)是查找的元素在第i(1&lt;=i&lt;=L.length)个位置上的概率</p>
<p><span class="math inline">\(\sum_{i=1}^{n}p_{i}\times i=\sum_{i=1}^{n}{\frac{1}{n}}\times i={\frac{1}{n}}{\frac{n(n+1)}{2}}={\frac{n+1}{2}}\)</span></p>
<div class="note warning"><ul>
<li>线性表的顺序存储结构是一种随机存取的存储结构,此处的顺序存取指的是只能线性遍历的数据结构，而顺序表可以随机存取</li>
<li>本书中的时间复杂度默认指渐进时间复杂度，即n默认趋近正无穷，而不是常数</li>
</ul>
<p>时间O(n),空间O(1)的删除表内一个值的算法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(SqList&amp; L, ElemType x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>;<span class="comment">//k记录值等于x的元素个数</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt; L.length) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L.data[i] == x) &#123;</span><br><span class="line">      k++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      L.data[i-k] = L.data[i];<span class="comment">//当前元素前移k个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.length = L.length - k;<span class="comment">//顺序表长度递减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<p>练习代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxsize = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sqList</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">20</span>]; <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="type">int</span> length;      <span class="comment">//顺序表的当前长度</span></span><br><span class="line">    <span class="built_in">sqList</span>(<span class="type">int</span> max):<span class="built_in">Maxsize</span>(max),<span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="comment">//L.data=new ElemType[InitSize]; //动态分配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(sqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) &#123;<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= Maxsize) &#123;</span><br><span class="line">        <span class="comment">//当前存储空间已满,不能插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j&gt;i; j--) &#123;</span><br><span class="line">        <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e; <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++; <span class="comment">//线性表长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(sqList L, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//下标为i的元素值等于e,返回其位序i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出循环,说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(sqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length) &#123;<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;L.length; j++) &#123;</span><br><span class="line">        <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletemin</span><span class="params">(sqList L)</span> </span>&#123;<span class="comment">//从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位置由最后一个元素填上</span></span><br><span class="line">    <span class="type">int</span> min =L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> min_index =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i&lt; L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min&gt;L.data[i]) &#123;</span><br><span class="line">            min = L.data[i];</span><br><span class="line">            min_index=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;min is &quot;</span> &lt;&lt; min &lt;&lt;endl;</span><br><span class="line">    L.data[min_index] = L.data[L.length<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printql</span><span class="params">(sqList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        cout &lt;&lt; L.data[i]&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseql</span><span class="params">(sqList&amp; L)</span> </span>&#123;<span class="comment">//逆转线性表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp =L.data[i];</span><br><span class="line">        L.data[i] = L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">        L.data[L.length<span class="number">-1</span>-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after rev&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printql</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletex</span><span class="params">(sqList L, <span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;<span class="comment">//删除所有值为x的元素</span></span><br><span class="line">    <span class="type">int</span> xtimes=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x==L.data[i]) &#123;</span><br><span class="line">            xtimes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> values_except_x = L.length-xtimes;</span><br><span class="line">    <span class="type">int</span> new_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i]!=x)&#123;</span><br><span class="line">            L.data[new_index] = L.data[i];</span><br><span class="line">            new_index++;</span><br><span class="line">            values_except_x--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (values_except_x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = L.length-xtimes;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;after del&quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printql</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_orderedql_by_range</span><span class="params">(sqList L,<span class="type">int</span> i ,<span class="type">int</span> j)</span> </span>&#123;<span class="comment">//删除一定范围的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;=j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> lft =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lft &lt; L.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[lft] &gt;= i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lft++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lft&gt;=L.length<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> rht = lft+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (rht &lt; L.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[rht] &gt; j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rht++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = rht;index&lt;L.length;index++) &#123;</span><br><span class="line">        L.data[lft++] = L.data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=lft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete_ql_by_range</span><span class="params">(sqList L,<span class="type">int</span> s,<span class="type">int</span> t)</span> </span>&#123;<span class="comment">//删除一定范围的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value_in_range;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s&lt;=L.data[i] &amp;&amp; L.data[i]&lt;=t)&#123;</span><br><span class="line">            value_in_range++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L.data[i-value_in_range]=L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length-=value_in_range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_unique</span><span class="params">(sqList L)</span> </span>&#123;<span class="comment">//删除相同值的元素</span></span><br><span class="line">    <span class="type">int</span> before = L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> same_values=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>;i&lt;L.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i]==before) &#123;</span><br><span class="line">            same_values++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            L.data[i-same_values] = L.data[i];</span><br><span class="line">            before = L.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length-=same_values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sqList <span class="title">mergesq</span><span class="params">(sqList L1, sqList L2)</span> </span>&#123;<span class="comment">//融合两个有序表</span></span><br><span class="line">    sqList result = *<span class="keyword">new</span> <span class="built_in">sqList</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1.length &amp;&amp; j &lt; L2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L1.data[i] &lt; L2.data[j]) result.data[k++] = L1.data[i++];</span><br><span class="line">        <span class="keyword">else</span> result.data[k++] = L2.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; L1.length) result.data[k++] = L1.data[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; L2.length) result.data[k++] = L2.data[j++];</span><br><span class="line">    result.length=L1.length+L2.length;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(sqList&amp; L,<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = L.data[i];</span><br><span class="line">    L.data[i]=L.data[j];</span><br><span class="line">    L.data[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(sqList&amp; L,<span class="type">int</span> lft,<span class="type">int</span> rht)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;(rht-lft)/<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(L,i+lft,rht-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sqList <span class="title">exchange</span><span class="params">(sqList L,<span class="type">int</span> m,<span class="type">int</span> n)</span> </span>&#123;<span class="comment">//位置互换</span></span><br><span class="line">    <span class="built_in">reverse</span>(L,<span class="number">0</span>,L.length);</span><br><span class="line">    <span class="built_in">reverse</span>(L,<span class="number">0</span>,n);</span><br><span class="line">    <span class="built_in">reverse</span>(L,n,L.length);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">middle_find_x</span><span class="params">(<span class="type">const</span> sqList&amp; L,<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//二分查找x</span></span><br><span class="line">    <span class="type">int</span> index =L.length/<span class="number">2</span>;<span class="type">int</span> lft=<span class="number">0</span>;<span class="type">int</span> rht=L.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lft&lt;=rht) &#123;</span><br><span class="line">        index=(rht+lft)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (L.data[index]==x) <span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L.data[index] &lt; x) lft = index+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> rht=index<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lft;<span class="comment">//lft必然指向首个大于等于x的元素，rht则指向首个小于等于x的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_x</span><span class="params">(sqList L,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="built_in">middle_find_x</span>(L,x);</span><br><span class="line">    <span class="keyword">if</span> (i==L.length<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L.data[i]==x) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(L,i,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        L.data[L.length]=x;</span><br><span class="line">        L.length++;</span><br><span class="line">        <span class="built_in">swap</span>(L,i++,L.length<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;L.length;i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(L,i,L.length<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left_move</span><span class="params">(sqList L,<span class="type">int</span> p)</span> </span>&#123;<span class="comment">//左移p位</span></span><br><span class="line">    <span class="built_in">reverse</span>(L,<span class="number">0</span>,p);</span><br><span class="line">    <span class="built_in">reverse</span>(L,p,L.length);</span><br><span class="line">    <span class="built_in">reverse</span>(L,<span class="number">0</span>,L.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_middle_2</span><span class="params">(sqList L1,sqList L2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="type">int</span> lft=<span class="number">0</span>;<span class="type">int</span> rht=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;(L1.length+L2.length+<span class="number">1</span>)/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L1.data[lft]&lt;=L2.data[rht]) &#123;</span><br><span class="line">            middle =L1.data[lft];</span><br><span class="line">            lft++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            middle=L2.data[rht];</span><br><span class="line">            rht++;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_middle_best</span><span class="params">(sqList L1,sqList L2)</span> </span>&#123;<span class="comment">//寻找两个等长有序表的公共中位数</span></span><br><span class="line">    <span class="type">int</span> m1=L1.data[(L1.length+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> m2=L2.data[(L2.length+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> lft1,lft2,rht1,rht2;</span><br><span class="line">    lft1=lft2=<span class="number">0</span>;</span><br><span class="line">    rht1=rht2=L1.length;</span><br><span class="line">    <span class="keyword">while</span> (rht1-lft1&gt;<span class="number">1</span> || rht2-lft2&gt;<span class="number">1</span>) &#123;<span class="comment">//如果L1中位数小于L2，就舍弃L1较小边，L2较大边</span></span><br><span class="line">        <span class="keyword">if</span> (m1==m2) <span class="keyword">return</span> m1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m1&lt;m2) &#123;</span><br><span class="line">            lft1=(lft1+rht1)/<span class="number">2</span>;</span><br><span class="line">            rht2=(rht2+lft2)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rht1=(lft1+rht1)/<span class="number">2</span>;</span><br><span class="line">            lft2=(rht2+lft2)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m1=L1.data[(lft1+rht1)/<span class="number">2</span>];</span><br><span class="line">        m2=L2.data[(lft2+rht2)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L1.length%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">min</span>(m1,m2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(m1,m2);</span><br><span class="line">    <span class="comment">//两个等长序列，最后总长度必然是偶数位，m1,m2一个是中点位，一个是中点位+1,奇数情况下要取较大的，偶数取较小的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_key_of_sqL</span><span class="params">(sqList L)</span> </span>&#123;<span class="comment">//查找主元(出现次数大于长度的一半)</span></span><br><span class="line">    <span class="type">int</span> l=L.length;</span><br><span class="line">    <span class="type">int</span> vals[l];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        vals[i] =<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) &#123;</span><br><span class="line">        vals[L.data[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vals[i]&gt;l/<span class="number">2</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_key_of_sqL_best</span><span class="params">(sqList L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到</span></span><br><span class="line"><span class="comment">    c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num,则计数加1,否则计</span></span><br><span class="line"><span class="comment">        数减1;当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1,开始新一</span></span><br><span class="line"><span class="comment">        轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。*/</span></span><br><span class="line">    <span class="type">int</span> i, c, count = <span class="number">1</span>;<span class="comment">//c用来保存候选主元素，count用来计数</span></span><br><span class="line">    c=L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> n=L.length;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == c) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                c = L.data[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)  <span class="keyword">for</span>(i =count = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//判断c中元素是否是真正的主元素</span></span><br><span class="line">            <span class="keyword">if</span>(L.data[i] == c) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min_Z</span><span class="params">(sqList L)</span> </span>&#123;<span class="comment">//查找最小的未出现正整数，可能的返回值只有[1,n+1]，超出这个范围不用考虑</span></span><br><span class="line">    <span class="type">int</span> n=L.length;</span><br><span class="line">    <span class="type">int</span> vals[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++) vals[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> (L.data[i]&gt;<span class="number">0</span> &amp;&amp; L.data[i]&lt;=n) vals[L.data[i]<span class="number">-1</span>]++;<span class="comment">//由于数组从0开始索引，需要进行转化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> (vals[i]==<span class="number">0</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xls_min</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;<span class="comment">//a是否是三个数中的最小值</span></span><br><span class="line">    <span class="keyword">if</span>(a&lt;=b&amp;&amp;a&lt;=c) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinofTrip</span> <span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> B [], <span class="type">int</span> m, <span class="type">int</span> C [], <span class="type">int</span> p)</span> </span>&#123;<span class="comment">//查找距离最小的三元组</span></span><br><span class="line">    <span class="comment">//D_min用于记录三元组的最小距离，初值赋为INT_MAX</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>,D_min=INT8_MAX,D;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n &amp;&amp; j&lt;m &amp;&amp; k&lt;p &amp;&amp; D_min&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        D=<span class="built_in">abs</span>(A[i]-B[j] )+<span class="built_in">abs</span>(B[j]-C[k] )+<span class="built_in">abs</span>(C[k]-A[i]); <span class="comment">//计算 D</span></span><br><span class="line">        <span class="keyword">if</span> (D&lt;D_min) D_min=D; <span class="comment">//更新 D</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">xls_min</span> (A[i],B[j],C[k])) i++; <span class="comment">//更新 a</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">xls_min</span>(B[j],C[k],A[i])) j++;</span><br><span class="line">        <span class="keyword">else</span> k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> D_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sqList* L_ptr = <span class="keyword">new</span> <span class="built_in">sqList</span>(<span class="number">50</span>);</span><br><span class="line">    sqList L =*L_ptr;</span><br><span class="line">    sqList L2 = *<span class="keyword">new</span> <span class="built_in">sqList</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">//int temp[8]=&#123;23,13,2,42,12,23,13,23&#125;;</span></span><br><span class="line">    <span class="type">int</span> temp[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">42</span>,<span class="number">67</span>&#125;;</span><br><span class="line">    <span class="type">int</span> temp2[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">22</span>&#125;;</span><br><span class="line">    <span class="type">int</span> temp3[<span class="number">6</span>] = &#123;<span class="number">-21</span>,<span class="number">-3</span>,<span class="number">14</span>,<span class="number">33</span>,<span class="number">35</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>(temp);i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(L,i+<span class="number">1</span>,temp[i]);</span><br><span class="line">        cout &lt;&lt; L.data[i]&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">size</span>(temp2);i++) &#123;</span><br><span class="line">        <span class="built_in">ListInsert</span>(L2,i+<span class="number">1</span>,temp2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//findMinofTrip(temp,8,temp2,5,temp3,6);</span></span><br><span class="line">    <span class="comment">//find_min_Z(L);</span></span><br><span class="line">    <span class="comment">//find_key_of_sqL_best(L2);</span></span><br><span class="line">    <span class="comment">//find_middle(L,L2);</span></span><br><span class="line">    <span class="comment">//left_move(L,2);</span></span><br><span class="line">    <span class="comment">//find_x(L,44);</span></span><br><span class="line">    <span class="comment">//exchange(L,8,3);</span></span><br><span class="line">    <span class="comment">//mergesq(L,L2);</span></span><br><span class="line">    <span class="comment">//make_unique(L);</span></span><br><span class="line">    <span class="comment">//delete_ql_by_range(L,6,43);</span></span><br><span class="line">    <span class="comment">//delete_orderedql_by_range(L,6,45);</span></span><br><span class="line">    <span class="comment">//deletex(L,23);</span></span><br><span class="line">    <span class="comment">//deletemin(L);</span></span><br><span class="line">    <span class="comment">//reverseql(L);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="链式表示">链式表示</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNodef</span> &#123; <span class="comment">//定义单链表结点类型</span></span><br><span class="line">	ElemType data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> *next; <span class="comment">//指针域</span></span><br><span class="line">&#125; ILNode,*LinkList;</span><br><span class="line"><span class="comment">//node是一个节点，Linklist是它的指针(即数组)</span></span><br></pre></td></tr></table></figure>
<p>一般会用一个<code>头结点</code>指向单链表，<code>头结点</code>的数据没有意义，空链表时指针是一个空指针<br />
<code>头指针</code>指向单链表的第一个节点，对有头指针的链表就是指向<code>头结点</code><br />
<code>头结点</code>的优点：</p>
<ol type="1">
<li>所有数据节点都可以用相同的办法处理</li>
<li>由于有<code>头节点</code>，<code>头指针</code>不会是一个空指针，空表和非空表也可以统一处理</li>
</ol>
<h3 id="基本操作">基本操作</h3>
<p>c++实现的一些基本操作： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;                              <span class="comment">// 定义单链表结点类型</span></span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;              <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>* next = <span class="literal">NULL</span>; <span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleLNode</span> &#123;                                     <span class="comment">// 定义双链表结点类型</span></span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;                     <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DoubleLNode</span>* prior = <span class="literal">NULL</span>; <span class="comment">// 指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DoubleLNode</span>* next = <span class="literal">NULL</span>;  <span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LNode* LinkList;</span><br><span class="line"><span class="keyword">typedef</span> DoubleLNode* DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历且打印链表,略过头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_linklist</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; i++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; L-&gt;data &lt;&lt; endl;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历且打印循环单链表,略过头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_loop_linklist</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList head = L;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != head) &#123;</span><br><span class="line">        cout &lt;&lt; i++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; L-&gt;data &lt;&lt; endl;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历且打印循环双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_linklist</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">    DLinkList head = L;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != head) &#123;</span><br><span class="line">        cout &lt;&lt; i++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; L-&gt;data &lt;&lt; endl;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组以尾插法生成链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">build_nodelist</span><span class="params">(LinkList&amp; L, <span class="type">int</span> lst[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    LNode* r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        LNode* s = <span class="keyword">new</span> LNode; <span class="comment">// 创建新结点</span></span><br><span class="line">        s-&gt;data = lst[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组以尾插法生成循环单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">build_loop_list</span><span class="params">(LinkList&amp; L, <span class="type">int</span> lst[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    LNode* r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        LNode* s = <span class="keyword">new</span> LNode; <span class="comment">// 创建新结点</span></span><br><span class="line">        s-&gt;data = lst[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组以尾插法生成循环双链表</span></span><br><span class="line"><span class="function">DLinkList <span class="title">build_loop_double_list</span><span class="params">(DLinkList&amp; L, <span class="type">int</span> lst[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    DoubleLNode* r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        DoubleLNode* s = <span class="keyword">new</span> DoubleLNode; <span class="comment">// 创建新结点</span></span><br><span class="line">        s-&gt;data = lst[i];</span><br><span class="line">        s-&gt;prior = r;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = r;</span><br><span class="line">    r-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法生成链表，即遍历顺序和输入顺序相反</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    LNode* s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入结点的值:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;                  <span class="comment">// 输入9999表示结束</span></span><br><span class="line">        s = <span class="keyword">new</span> LNode; <span class="comment">// 创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s; <span class="comment">// 将新结点插入表中,L为头指针</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入结点的值:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; x; <span class="comment">// 输入结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法生成链表，即遍历顺序和输入顺序一致</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    LNode* r = L;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入结点的值:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        LNode* s = <span class="keyword">new</span> LNode;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s; <span class="comment">// r指向新的表尾结点</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入结点的值:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; x; <span class="comment">// 输入结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找节点，不存在返回NULL</span></span><br><span class="line"><span class="function">LNode* <span class="title">LocateElem_byval</span><span class="params">(LinkList L, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) <span class="comment">// 从第1个结点开始查找data域为e的结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按序号定位结点，如果越界返回NULL</span></span><br><span class="line"><span class="function">LNode* <span class="title">LocateElem_byno</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入删除略,删除时要用delete回收内存！！！</span></span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">merge_list</span><span class="params">(LinkList head, LinkList tail)</span> </span>&#123;</span><br><span class="line">    LinkList temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) temp = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = tail-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>循环单链表表尾结点*r的next域指向L,故表中没有指针域为NULL的结点，判空条件是当前节点是否等于头指针<br />
有时对循环单链表不设头指针而仅设尾指针,若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，而若设的是尾指针r,r-&gt;next即为头指针，对在表头或表尾插入元素都只需要O(1)的时间复杂度<br />
循环双链表中，头结点的prior指针还要指向表尾结点,为空时，头结点的前后指针都指向自己</p>
<p>静态链表借助数组来描述线性表的链式存储结构,其指针是结点的相对地址(数组下标)，又称游标，需要预先分配一块连续的内存空间 <img src="/assets/resources/%7B0273A086-DB7E-4fb9-80BB-72F790BBE170%7D.png" /> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br></pre></td></tr></table></figure></p>
<p><strong>顺序表和链表的比较</strong>：</p>
<ol type="1">
<li>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素</li>
<li>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻</li>
<li>顺序存储需要连续空间，一旦溢出，动态分配成本较大，而链表更灵活，可以一直O(1)时间添加元素</li>
<li>链表存储密度更小，必然小于1，且实现更复杂</li>
</ol>
<p>练习代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;node_list.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.递归删除不带头结点链表值为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_by_val</span><span class="params">(LinkList&amp; L, <span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == x) &#123;</span><br><span class="line">        LinkList l = L;</span><br><span class="line">        L = L-&gt;next;  <span class="comment">// 这里L为调用该函数的外层L-&gt;next，故这里实现了L-&gt;next=L-next-&gt;next</span></span><br><span class="line">        <span class="keyword">delete</span> l;</span><br><span class="line">        <span class="built_in">del_by_val</span>(L, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">del_by_val</span>(L-&gt;next, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在带头结点的单链表L中，删除所有值为x的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_by_val_withhead</span><span class="params">(LinkList p, <span class="type">int</span> x)</span> </span>&#123;  <span class="comment">// p是先驱节点，最初是头结点</span></span><br><span class="line">    LinkList q = p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;  <span class="comment">// 循环检查后继结点的值是否是x</span></span><br><span class="line">        <span class="keyword">if</span> (q-&gt;data == x) &#123;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            LinkList temp = q;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.带头结点的单链表从尾到头反向输出每个结点的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_linklist_rev</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print_linklist_rev</span>(L-&gt;next);</span><br><span class="line">    cout &lt;&lt; L-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">remove_head</span><span class="params">(LinkList head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.在带头结点的单链表L中删除一个最小值结点(假设唯一)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_min_withhead</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkList prev = L;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    LinkList min_node, min_prev;</span><br><span class="line">    <span class="type">int</span> min_val = INT16_MAX;</span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;data &lt; min_val) min_node = L, min_prev = prev, min_val = L-&gt;data;</span><br><span class="line">        prev = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    min_prev-&gt;next = min_node-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> min_node;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除的节点值为:&quot;</span> &lt;&lt; min_val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.将带头结点的单链表就地逆置</span></span><br><span class="line"><span class="function">LinkList <span class="title">rev_insite_withhead</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList head = L, temp; <span class="comment">//暂存头结点</span></span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    LinkList p = L-&gt;next;  <span class="comment">//L和p分别是先驱后继节点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = p-&gt;next; <span class="comment">//暂存p之后的链表</span></span><br><span class="line">        p-&gt;next = L;  <span class="comment">//反转L和p</span></span><br><span class="line">        L = p;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*另一种解法</span></span><br><span class="line"><span class="comment">    LNode* p, * r;</span></span><br><span class="line"><span class="comment">    p = L-&gt;next;</span></span><br><span class="line"><span class="comment">    L-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">    while (p != NULL) &#123;</span></span><br><span class="line"><span class="comment">        r = p-&gt;next;</span></span><br><span class="line"><span class="comment">        p-&gt;next = L-&gt;next;</span></span><br><span class="line"><span class="comment">        L-&gt;next = p;//将P结点插入到头结点之后</span></span><br><span class="line"><span class="comment">        p = r;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return L;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*6.插入排序带头结点的单链表L</span></span><br><span class="line"><span class="comment">    1. 排序部分初始为头结点及其后续一个节点,未排序部分是head-&gt;next-&gt;next为首的链表</span></span><br><span class="line"><span class="comment">    2. 取一个未排序节点，遍历找到插入位置</span></span><br><span class="line"><span class="comment">    3. 插入节点，将leaft指向之前暂存的未排序部分首个结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList leaft = L-&gt;next;<span class="comment">//leaft是未排序部分的首个节点</span></span><br><span class="line">    LinkList remains = leaft-&gt;next;</span><br><span class="line">    leaft-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    leaft = remains;</span><br><span class="line">    <span class="keyword">while</span> (leaft != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        remains = leaft-&gt;next;</span><br><span class="line">        LinkList prev = L;</span><br><span class="line">        <span class="keyword">while</span> (prev-&gt;next != <span class="literal">NULL</span> &amp;&amp; leaft-&gt;data &gt; prev-&gt;next-&gt;data) prev = prev-&gt;next;</span><br><span class="line">        <span class="comment">//注意要先判断next是否为空，否则会访问空指针出现异常！！！</span></span><br><span class="line">        leaft-&gt;next = prev-&gt;next;</span><br><span class="line">        prev-&gt;next = leaft;</span><br><span class="line">        leaft = remains;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 删除无序带头结点单链表介于[x,y]内的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_val_inrange</span><span class="params">(LinkList L, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    LinkList p = L, q = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;data &lt; y &amp;&amp; q-&gt;data &gt;x) &#123;</span><br><span class="line">            LinkList temp = q;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*8.找出两个链表的公共结点</span></span><br><span class="line"><span class="comment">若有公共结点，则从其开始，两链表完全一致，因此必出现在距离尾部距离一致的地方</span></span><br><span class="line"><span class="comment">因此可以将较长的链表截断到较短链表长度，随后遍历寻找公共结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_of_list</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="function">LinkList <span class="title">find_public_node</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">len_of_list</span>(L1-&gt;next);</span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">len_of_list</span>(L2-&gt;next);</span><br><span class="line">    LinkList longer, shorter;</span><br><span class="line">    longer = (len1 &gt; len2) ? L1-&gt;next : L2-&gt;next;</span><br><span class="line">    shorter = (len1 &gt; len2) ? L2-&gt;next : L1-&gt;next;</span><br><span class="line">    longer = (len1 == len2) ? longer : <span class="built_in">LocateElem_byno</span>(longer, <span class="built_in">abs</span>(len1 - len2));</span><br><span class="line">    <span class="keyword">while</span> (longer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (longer == shorter) <span class="keyword">return</span> longer;</span><br><span class="line">        longer = longer-&gt;next;</span><br><span class="line">        shorter = shorter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_of_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.按递增次序输出单链表中各结点的数据元素，并释放结点,就地算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_and_del_sorted_list</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkList iter = L-&gt;next-&gt;next, min = L-&gt;next, prev = min, prev_min = L;</span><br><span class="line">    <span class="keyword">while</span> (iter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min-&gt;data &gt; iter-&gt;data) min = iter, prev_min = prev;</span><br><span class="line">        prev = iter;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev_min-&gt;next = min-&gt;next;</span><br><span class="line">    cout &lt;&lt; min-&gt;data &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> min;</span><br><span class="line">    <span class="built_in">print_and_del_sorted_list</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.将一个带头结点的单链表按奇偶分解成两个链表</span></span><br><span class="line"><span class="function">pair&lt;LinkList, LinkList&gt; <span class="title">tear_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> signal = <span class="number">1</span>;</span><br><span class="line">    LinkList L1head = <span class="keyword">new</span> LNode, L2head = L;</span><br><span class="line">    LinkList q = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkList temp = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (signal == <span class="number">1</span>) &#123;</span><br><span class="line">            signal = <span class="number">0</span>;</span><br><span class="line">            q-&gt;next = L1head-&gt;next;</span><br><span class="line">            L1head-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            signal = <span class="number">1</span>;</span><br><span class="line">            q-&gt;next = L2head-&gt;next;</span><br><span class="line">            L2head-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        q = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(L1head, L2head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//11.C= &#123;a1, b1,...,an,bn&#125;线性表，采用带头结点的单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A = (a1 a2,,,an&#125;, B= bn,,,b2,b1&#125;</span></span><br><span class="line"><span class="comment">//即一个头插法，一个尾插法</span></span><br><span class="line"><span class="function">pair&lt;LinkList, LinkList&gt; <span class="title">tear_list_rev</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList L1head = <span class="keyword">new</span> LNode, L1tail = L1head, L2head = L;</span><br><span class="line">    LinkList node = L-&gt;next;</span><br><span class="line">    L2head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkList temp = node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (signal == <span class="number">0</span>) &#123;</span><br><span class="line">            signal = <span class="number">1</span>;</span><br><span class="line">            L1tail-&gt;next = node;</span><br><span class="line">            L1tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            signal = <span class="number">0</span>;</span><br><span class="line">            node-&gt;next = L2head-&gt;next;</span><br><span class="line">            L2head-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        node = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    L1tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(L1head, L2head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12.递增有序的线性表去除重复元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_samepart_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList prev = L-&gt;next, q = prev-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = prev-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (prev-&gt;data == q-&gt;data) &#123;</span><br><span class="line">            prev-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*13.两个按元素值递增次序排列的单链表,归并为一个按元素值递增次序排列的单链表，不创造新节点</span></span><br><span class="line"><span class="comment">如果是递减版本，则需要使用头插法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">LinkList <span class="title">merge_and_sort</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LinkList l1node = L1-&gt;next, l2node = L2-&gt;next, l1tail = L1;</span><br><span class="line">    L1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1node != <span class="literal">NULL</span> &amp;&amp; l2node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LinkList temp;</span><br><span class="line">        <span class="keyword">if</span> (l1node-&gt;data &lt; l2node-&gt;data) &#123;</span><br><span class="line">            l1tail-&gt;next = l1node;</span><br><span class="line">            l1tail = l1node;</span><br><span class="line">            l1node = l1node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l1tail-&gt;next = l2node;</span><br><span class="line">            l1tail = l2node;</span><br><span class="line">            l2node = l2node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l1tail-&gt;next = (l1node == <span class="literal">NULL</span>) ? l2node : l1node;</span><br><span class="line">    <span class="keyword">delete</span> L2;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14.两个递增有序单链表，用其公共元素产生一个新链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">build_list_from_public</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LinkList prev1 = L1, prev2 = L2;</span><br><span class="line">    LinkList L3 = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="keyword">while</span> (prev1-&gt;next != <span class="literal">NULL</span> &amp;&amp; prev2-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev1-&gt;next-&gt;data == prev2-&gt;next-&gt;data) &#123;</span><br><span class="line">            LinkList new_node = <span class="keyword">new</span> LNode;</span><br><span class="line">            new_node-&gt;data = prev1-&gt;next-&gt;data;</span><br><span class="line">            new_node-&gt;next = L3-&gt;next;</span><br><span class="line">            L3-&gt;next = new_node;</span><br><span class="line">            prev1 = prev1-&gt;next;</span><br><span class="line">            prev2 = prev2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prev1-&gt;next-&gt;data &lt; prev2-&gt;next-&gt;data) prev1 = prev1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> prev2 = prev2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//15.两个链表分别表示两个集合，其元素递增排列，将其交集存放于A链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">list_intersection</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LinkList prev1 = L1, prev2 = L2, l1tail = L1;</span><br><span class="line">    <span class="keyword">while</span> (prev1-&gt;next != <span class="literal">NULL</span> &amp;&amp; prev2-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev1-&gt;next-&gt;data == prev2-&gt;next-&gt;data) &#123;</span><br><span class="line">            l1tail-&gt;next = prev1-&gt;next;</span><br><span class="line">            l1tail = prev1-&gt;next;</span><br><span class="line">            prev1 = prev1-&gt;next;</span><br><span class="line">            prev2 = prev2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prev1-&gt;next-&gt;data &lt; prev2-&gt;next-&gt;data) prev1 = prev1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> prev2 = prev2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    l1tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*16.两个链表分别是一个整数序列，判断B是否是A的子序列</span></span><br><span class="line"><span class="comment">1. 不断比较两个先驱指针的next</span></span><br><span class="line"><span class="comment">2. 若相等，同时后移</span></span><br><span class="line"><span class="comment">3. 若不等，有两种可能，</span></span><br><span class="line"><span class="comment">    1. 如果该节点是一个子序列的开始，则比较其后续节点与son的后续节点</span></span><br><span class="line"><span class="comment">    2. 否则，比较其后续结点和son的开始节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_sonlist</span><span class="params">(LinkList parent, LinkList son)</span> </span>&#123;</span><br><span class="line">    LinkList sonhead = son;</span><br><span class="line">    <span class="keyword">while</span> (parent-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (son-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;next-&gt;data == son-&gt;next-&gt;data) &#123;</span><br><span class="line">            parent = parent-&gt;next;</span><br><span class="line">            son = son-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;next-&gt;data == sonhead-&gt;next-&gt;data) &#123;</span><br><span class="line">            parent = parent-&gt;next;</span><br><span class="line">            son = sonhead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent = parent-&gt;next;</span><br><span class="line">            son = sonhead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//17. 判断带头结点的循环双链表是否对称</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_symmetry</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">    DLinkList lft = L-&gt;next, rht = L-&gt;prior;</span><br><span class="line">    <span class="keyword">while</span> (lft != rht &amp;&amp; lft != rht-&gt;next) &#123;<span class="comment">//边界有两种情况，偶数时，lft会跑到rht右边，奇数时，两者碰到一起</span></span><br><span class="line">        <span class="keyword">if</span> (lft-&gt;data == rht-&gt;data) &#123;</span><br><span class="line">            lft = lft-&gt;next;</span><br><span class="line">            rht = rht-&gt;prior;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//18.两个循环单链表,将链表h2链接到链表hl之后，要求链接后的链表仍保持循环链表形式</span></span><br><span class="line"><span class="function">LinkList <span class="title">merge_loop_list</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LinkList l1tail = L1, l2tail = L2;</span><br><span class="line">    <span class="keyword">while</span> (l1tail-&gt;next != L1) l1tail = l1tail-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (l2tail-&gt;next != L2) l2tail = l2tail-&gt;next;</span><br><span class="line">    l1tail-&gt;next = L2-&gt;next;</span><br><span class="line">    l2tail-&gt;next = L1;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//19.反复找出循环单链表中结点值最小的结点并输出，然后将该结点从中删除，直到单链表空为止，再删除表头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_and_del_minnode_loop</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList node = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node == L) <span class="keyword">return</span>;</span><br><span class="line">    LinkList min_node_prev = L, work_node = node;</span><br><span class="line">    <span class="keyword">while</span> (work_node-&gt;next != L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (work_node-&gt;next-&gt;data &lt; min_node_prev-&gt;next-&gt;data) min_node_prev = work_node;</span><br><span class="line">        work_node = work_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;del min_node:&quot;</span> &lt;&lt; min_node_prev-&gt;next-&gt;data &lt;&lt; endl;</span><br><span class="line">    LinkList temp = min_node_prev-&gt;next;</span><br><span class="line">    min_node_prev-&gt;next = min_node_prev-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    <span class="built_in">find_and_del_minnode_loop</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//20.判断单链表是否有环</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_has_cycle</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList slow = L, fast = L;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LNode* <span class="title">FindLoopStart</span><span class="params">(LNode* head)</span> </span>&#123;</span><br><span class="line">    LNode* fast = head, * slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next; <span class="comment">//每次走一步</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next; <span class="comment">//每次走两步</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>; <span class="comment">//相遇</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//没有环，返回NULL</span></span><br><span class="line">    LNode* pl = head, * p2 = slow;</span><br><span class="line">    <span class="keyword">while</span> (pl != p2) &#123;</span><br><span class="line">        <span class="comment">//分别指向开始点、相遇点</span></span><br><span class="line">        pl = pl-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pl; <span class="comment">//返回入口点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真题1.查找带头结点的链表中倒数第k个位置上的结点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_k_rev_node</span><span class="params">(LinkList L, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    LinkList prev = L, after = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (after == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        after = after-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (after != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        after = after-&gt;next;</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the node is:&quot;</span> &lt;&lt; prev-&gt;data &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真题2.strl和str2分别指向两个单词所在单链表的头结点，找出由strl和str2所指向两个链表共同后缀的起始位置</span></span><br><span class="line"><span class="function">LinkList <span class="title">find_public_charnode</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1-&gt;next == <span class="literal">NULL</span> || L2-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">len_of_list</span>(L1-&gt;next), len2 = <span class="built_in">len_of_list</span>(L2-&gt;next);</span><br><span class="line">    LinkList longer = (len1 &gt; len2) ? L1-&gt;next : L2-&gt;next;</span><br><span class="line">    LinkList shorter = (len1 &gt; len2) ? L2-&gt;next : L1-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">abs</span>(len1 - len2);i++) longer = longer-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (longer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (longer == shorter) <span class="keyword">return</span> longer;</span><br><span class="line">        longer = longer-&gt;next;</span><br><span class="line">        shorter = shorter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真题3.用单链表保存m个整数,其绝对值均小于n,对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点</span></span><br><span class="line"><span class="function">LinkList <span class="title">remove_sameabs</span><span class="params">(LinkList&amp; L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> bucket[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) bucket[i] = <span class="number">0</span>;</span><br><span class="line">    LinkList prev = L;</span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[<span class="built_in">abs</span>(prev-&gt;next-&gt;data)] == <span class="literal">true</span>) &#123;</span><br><span class="line">            LinkList temp = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket[<span class="built_in">abs</span>(prev-&gt;next-&gt;data)] = <span class="literal">true</span>;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print_linklist</span>(L);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真题4.线性表L =(a1,a2,,an)采用带头结点的单链表保存,就地将其排序为(a1,an,a2,an-1,,,)</span></span><br><span class="line"><span class="function">LinkList <span class="title">resort_list</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LinkList p = L, q = L, r;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span> &amp;&amp; q-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//寻找中点</span></span><br><span class="line">        q = q-&gt;next-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;next;<span class="comment">//令q为后半段第一个节点</span></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//断开前半段</span></span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;<span class="comment">//逆置后半段</span></span><br><span class="line">        r = q-&gt;next;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList prev;</span><br><span class="line">    prev = L-&gt;next;<span class="comment">//前半段第一个节点</span></span><br><span class="line">    q = p-&gt;next;<span class="comment">//后半段第一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;<span class="comment">//也可以是prev!=p</span></span><br><span class="line">        r = q-&gt;next;<span class="comment">//暂存的r是后半段链表下一个要处理的节点</span></span><br><span class="line">        q-&gt;next = prev-&gt;next;</span><br><span class="line">        prev-&gt;next = q;<span class="comment">//将n-i+1号节点插入到i号节点后</span></span><br><span class="line">        prev = q-&gt;next;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//最后形成的链表到p为止</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp[<span class="number">8</span>] = &#123; <span class="number">2</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">33</span>,<span class="number">54</span>, <span class="number">72</span>, <span class="number">83</span>, <span class="number">99</span> &#125;;</span><br><span class="line">    <span class="type">int</span> temp2[<span class="number">3</span>] = &#123; <span class="number">3</span>,<span class="number">17</span>, <span class="number">23</span> &#125;;</span><br><span class="line">    LinkList nodes = <span class="keyword">new</span> LNode;</span><br><span class="line">    LinkList nodes2 = <span class="keyword">new</span> LNode;</span><br><span class="line">    <span class="built_in">build_nodelist</span>(nodes, temp,</span><br><span class="line">        <span class="built_in">sizeof</span>(temp) / <span class="built_in">sizeof</span>(temp[<span class="number">0</span>]));  <span class="comment">// 生成带头结点的测试链表</span></span><br><span class="line">    <span class="built_in">build_nodelist</span>(nodes2, temp2,</span><br><span class="line">        <span class="built_in">sizeof</span>(temp2) / <span class="built_in">sizeof</span>(temp2[<span class="number">0</span>]));  <span class="comment">// 生成带头结点的测试链表 </span></span><br><span class="line">    <span class="comment">/*     DLinkList doublelist = new DoubleLNode;</span></span><br><span class="line"><span class="comment">        build_loop_double_list(doublelist, temp, sizeof(temp) / sizeof(temp[0])); */</span></span><br><span class="line">        <span class="comment">//nodes2 = merge_list(nodes2, nodes);</span></span><br><span class="line">        <span class="comment">// del_by_val(nodes-&gt;next,22);//传入头结点的next就可以视为无头结点链表</span></span><br><span class="line">        <span class="comment">// del_by_val_withhead(nodes,22);</span></span><br><span class="line">        <span class="comment">// print_linklist_rev(remove_head(nodes));</span></span><br><span class="line">        <span class="comment">// del_min_withhead(nodes);</span></span><br><span class="line">        <span class="comment">//nodes = rev_insite_withhead(nodes);</span></span><br><span class="line">        <span class="comment">//insertsort_list(nodes);</span></span><br><span class="line">        <span class="comment">//del_val_inrange(nodes,10,30);</span></span><br><span class="line">        <span class="comment">//find_public_node(nodes,nodes2);</span></span><br><span class="line">        <span class="comment">//print_and_del_sorted_list(nodes2);</span></span><br><span class="line">    <span class="comment">/*     auto listpair = tear_list(nodes);</span></span><br><span class="line"><span class="comment">        print_linklist(listpair.first);</span></span><br><span class="line"><span class="comment">        print_linklist(listpair.second); */</span></span><br><span class="line">        <span class="comment">/*     auto nodespair = tear_list_rev(nodes);</span></span><br><span class="line"><span class="comment">            print_linklist(nodespair.first);</span></span><br><span class="line"><span class="comment">            print_linklist(nodespair.second); */</span></span><br><span class="line">            <span class="comment">//remove_samepart_list(nodes);</span></span><br><span class="line">        <span class="comment">//nodes = merge_and_sort(nodes2, nodes);</span></span><br><span class="line">        <span class="comment">//print_linklist(build_list_from_public(nodes,nodes2));</span></span><br><span class="line">        <span class="comment">//print_linklist(list_intersection(nodes,nodes2));</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;A is B&#x27;s parent?&quot; &lt;&lt; if_sonlist(nodes, nodes2) &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;symmetry? &quot; &lt;&lt; if_symmetry(doublelist) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//print_loop_linklist(merge_loop_list(build_loop_list(nodes, temp, sizeof(temp) / sizeof(temp[0])), build_loop_list(nodes2, temp2, sizeof(temp2) / sizeof(temp2[0]))));</span></span><br><span class="line"><span class="comment">//find_and_del_minnode_loop(build_loop_list(nodes, temp, sizeof(temp) / sizeof(temp[0])));</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;has a cycle?&quot; &lt;&lt; if_has_cycle(nodes) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//find_k_rev_node(nodes, 8);</span></span><br><span class="line">    <span class="comment">//find_public_charnode(nodes, nodes2);</span></span><br><span class="line">    <span class="comment">//remove_sameabs(nodes, 200);</span></span><br><span class="line">    <span class="built_in">print_linklist</span>(<span class="built_in">resort_list</span>(nodes));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print_linklist(doublelist);</span></span><br><span class="line">    <span class="comment">//print_linklist(nodes);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<hr />
<h1 id="栈队列矩阵">栈&amp;&amp;队列&amp;&amp;矩阵</h1>
<h2 id="栈">栈</h2>
<p>c++表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize]; <span class="comment">//存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top; <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Linknode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Linknode</span>* next; <span class="comment">//指针域</span></span><br><span class="line">&#125;* LiStack; <span class="comment">//栈类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MaxSize) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top--]; <span class="comment">//先出栈，指针再减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意进出栈对应修改data和top的顺序相反</strong><br />
链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。<br />
实现中规定链栈没有头结点，Lhead指向栈顶元素</p>
<p>两个顺序栈可共享一个连续数组框架，增长方向相对，一个栈底是0，一个是MaxSize-1,只当top1-top0==1时栈满</p>
<p>将中缀表达式转换为后缀表达式的算法思想如下：<br />
从左向右开始扫描中缀表达式；<br />
遇到数字时，加入后缀表达式；<br />
遇到运算符时：<br />
a. 若为<code>(</code>,入栈；<br />
b. 若为<code>)</code>，则依次把栈中的运算符加入后缀表达式，直到出现<code>(</code>，从栈中删除<code>(</code>；<br />
c. 若为除括号外的其他运算符，当其优先级高于除<code>(</code>外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或遇到了一个左括号为止。<br />
当扫描的中缀表达式结束时，栈中的所有运算符依次出栈加入后缀表达式。</p>
<h2 id="队列">队列</h2>
<p>先进先出的数据结构，但其顺序实现会产生难以判满的问题，即rear==MaxSize时，可能前有空槽</p>
<p><strong>循环队列</strong>：</p>
<ul>
<li>初始时：<code>Q.front=Q.rear=0</code></li>
<li>队首指针进1: <code>Q.front= (Q.front+1)%MaxSize</code></li>
<li>队尾指针进1: <code>Q.rear=(Q.rear+1)%MaxSize</code></li>
<li>队列长度:<code>(Q.rear+MaxSize-Q.front)%MaxSize</code></li>
</ul>
<p>可以约定以队头指针在队尾指针的下一位置作为队满的标志,即减少一个存储单元，此时：</p>
<ul>
<li>队满条件：<code>(Q.rear+1)%MaxSize==Q.front</code></li>
<li>队空条件：<code>Q.front==Q.rear</code></li>
</ul>
<p>或者增设<code>size</code>成员，<code>tag</code>成员,tag等于0时，若因删除导致<code>Q.front==Q.rear</code>,则为队空；tag等于1时，若因插入导致<code>Q.front==Q.rear</code>,则为队满<br />
增设一个tag的整型变量，进队时置tag为1,出队时置tag为0,以tag判断满空</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>; <span class="comment">//初始化队首、队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//队空条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue&amp; Q, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//队满报错</span></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize; <span class="comment">//队尾指针加 1 取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue&amp; Q, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//队空则报错</span></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front == (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针加 1 取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>链式队列</strong>：<br />
需要队头和队尾指针,front指向第一个节点，rear指向最后一个节点<br />
队空条件：<code>front==rear==NULL</code><br />
也可以设置一个头结点，统一插入和删除操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span>* next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    LinkNode* front, * rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = <span class="keyword">new</span> LinkNode; <span class="comment">//建立头结点</span></span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    LinkNode* s = <span class="keyword">new</span> LinkNode;</span><br><span class="line">    s-&gt;data = x; s-&gt;next = <span class="literal">NULL</span>; <span class="comment">//创建新结点，插入到链尾</span></span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    LinkNode* p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">        Q.rear = Q.front; <span class="comment">//若原队列中只有一个结点，删除后变空</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双端队列</strong>：<br />
允许两端都可以进行入队和出队操作的队列</p>
<ul>
<li>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入</li>
<li>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除</li>
</ul>
<p>栈被应用于:递归，前后缀运算符，括号匹配<br />
而队列应用于:按广度遍历，操作系统的任务调度</p>
<h2 id="数组与矩阵">数组与矩阵</h2>
<p>一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表，数组是定长的，在逻辑上有自己的维数和长度(但c与c++不检查是否越界)<br />
一维数组:<span class="math inline">\({\mathsf{L O C}}(a_{i})={\mathsf{L O C}}(a_{0})+i\times L\ \ (0\leq i&lt;n)\)</span><br />
二维数组(h1,h2分别是行列的最大值) 按行存储时：<br />
<span class="math display">\[{\mathrm{LOC}}(a_{i,j})={\mathrm{LOC}}(a_{0,0})+\left[i\times(h_{2}+1)+j\right]\times L\]</span><br />
按列存储时：<br />
<span class="math display">\[\mathrm{LOC}(a_{i,j})=\mathrm{LOC}(a_{0,0})+\bigl[j\times(h_{1}+1)+i\bigr]\times L\]</span></p>
<p>二维数组一般从0开始索引，矩阵一般从1开始<br />
矩阵可以用一些方法压缩</p>
<ol type="1">
<li>对称矩阵 ,元素下标之间的对应关系:<span class="math inline">\(k=\frac{i(i-1)}{2}+j-1,\qquad i\geqslant j(i&lt;j时两者互换)\)</span></li>
<li>下三角矩阵(上三角区元素都是常量)</li>
</ol>
<p><span class="math display">\[k=
\begin{cases}
\frac{i(i-1)}{2}+j-1,\qquad i\geq j \\
\frac{n(n+1)}{2},\qquad\qquad\qquad i&lt;j \\
\end{cases}\]</span></p>
<p><img src="/assets/resources/Pasted%20image%2020240330224100.png" /></p>
<p>按列存储且数组从1开始索引时： <span class="math inline">\(k=(j-1)(2n-j+2)/2+i-j+1\)</span></p>
<ol start="3" type="1">
<li>上三角矩阵，与下三角相反 <span class="math display">\[k=
\begin{cases}
\frac{(i-1)(2n-i+2)}{2}+(j-i)\qquad i\le{j}\\
\frac{n(n+1)}{2},\qquad\qquad\qquad\qquad i&gt;j \\
\end{cases}\]</span></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240330223751.png" /></p>
<p>按列存储且数组从1开始索引时： <span class="math inline">\(k=j(j-1)/2+i\)</span></p>
<ol type="1">
<li>三对角矩阵，对任意<span class="math inline">\(|i-1|&gt; 1\)</span>有<span class="math inline">\(a_{i,j}=0\)</span></li>
</ol>
<p><span class="math inline">\(i = \left\lfloor(k+1)/3+1\right\rfloor \qquad j = k-2i+3\)</span></p>
<p><img src="/assets/resources/Pasted%20image%2020240330224418.png" /></p>
<ol start="5" type="1">
<li>稀疏矩阵:非零元素远少于零元素的矩阵,用三元组(i,j,value)储存</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240330224753.png" /></p>
<p>也可以用十字链表(行单链表和列单链表)存储</p>
<hr />
<h1 id="树">树</h1>
<ul>
<li>树是递归定义的</li>
<li>一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度</li>
<li>度大于0的结点称为分支结点(又称非终端结点)；度为0 (没有子女结点)的结点称为叶结点(又称终端结点)</li>
<li>结点的层次从树根开始定义，根结点为第1层，它的子结点为第2层，以此类推。双亲在同一层的结点互为堂兄弟</li>
<li>结点的深度是从根结点开始自顶向下逐层累加的。</li>
<li>结点的高度是从叶结点开始自底向上逐层累加的。</li>
<li>树的高度(或深度)是树中结点的最大层数</li>
<li>路径长度是路径上所经过的边的个数</li>
<li>森林是树的集合</li>
</ul>
<p>基本性质：</p>
<ul>
<li>树中的结点数等于所有结点的度数之和加1(根节点)<code>n0+n1+...+nk = n1+2*n2+...+k*nk+1</code></li>
<li>度m的数第i层至多有 <span class="math inline">\(m^{i-1} 且 i\ge1\)</span></li>
<li>高度h的m叉树最多有 <span class="math inline">\((m^{h}-1)/(m-1)\)</span>个结点</li>
<li>n个结点的m叉树最小高度为 <span class="math inline">\(\lceil\log_{m}(n(m-1)+1)\rceil\)</span></li>
</ul>
<h2 id="二叉树">二叉树</h2>
<p>每个结点至多只有两棵子树的树，子树分左右，即使只有一个节点<br />
<img src="/resources/tree.png" /></p>
<p>基本性质：</p>
<ul>
<li>ni表示度i的节点数，则 <code>n0 = n2 + 1</code></li>
<li>非空二叉树第k层最多有 <span class="math inline">\(2^{k-1}\)</span> 个结点</li>
<li>高度h的二叉树至多有<span class="math inline">\(2^h-1个结点\)</span></li>
<li>对完全二叉树编号：
<ul>
<li>当i&gt;1时，结点i的双亲的编号为 <span class="math inline">\(\lfloor i/2 \rfloor\)</span> ，即当i为偶数时，其双亲的编号为i/2,它是双亲的左孩子；当i为奇数时，其双亲的编号为(i-1)/2,它是双亲的右孩子</li>
<li>当 <span class="math inline">\(2i \le n\)</span> 时，结点i的左孩子编号为2i,否则无左孩子</li>
<li>当 <span class="math inline">\(2i+1 \le n\)</span> 时，结点i的右孩子编号为2i+1,否则无右孩子</li>
<li>结点i所在层次(深度)为 <span class="math inline">\(\lfloor\log_{2}i\rfloor+1\)</span></li>
</ul></li>
<li>具有n个(n&gt;0)结点的完全二叉树的高度为 <span class="math inline">\(\lceil\log_{2}(n+1)\rceil\ 或 \lfloor\log_{2}n\rfloor+1\)</span></li>
</ul>
<p><span class="math display">\[2^{h^{-1}}-1\lt n\leqslant2^{h}-1\]</span></p>
<p><strong>存储结构</strong>：</p>
<ol type="1">
<li>顺序存储，一般从1开始索引，a[i]结点的左右子节点分别是a[2i],a[2i+1],父节点(如果存在)是a<a href="向下取整">i/2</a></li>
<li>链式存储,n个结点产生2n个链域，其中n-1个结点占据一个链域(除了根节点)，因此含有n个结点的二叉链表中，含有n + 1个空链域</li>
</ol>
<p>中序加任何一种其他顺序可以确定一颗二叉树，而只知道先后序列不行</p>
<p>基本操作的cpp实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取索引为 i 节点的左子节点的索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取索引为 i 节点的右子节点的索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取索引为 i 节点的父节点的索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; node-&gt;data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    queue&lt;TreeNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();              <span class="comment">// 队列出队</span></span><br><span class="line">        <span class="built_in">visit</span>(node);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">visit</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非递归实现</span></span><br><span class="line"><span class="comment">思路是通过堆栈不断将优先级高的节点入栈</span></span><br><span class="line"><span class="comment">入栈到尽头时出栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历的非递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder2</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            S.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">visit</span>(p);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历的非递归算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder2</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p);</span><br><span class="line">            S.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = S.<span class="built_in">top</span>(); S.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历的非递归算法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">难点在于，首先要把所有左孩子入栈</span></span><br><span class="line"><span class="comment">直到第一个没有左孩子的结点入栈，但此时不能访问</span></span><br><span class="line"><span class="comment">必须确保先把该节点的右孩子(如果存在，且没有访问过)也访问了，再访问该节点</span></span><br><span class="line"><span class="comment">那么，visit有几种情况呢？</span></span><br><span class="line"><span class="comment">1. 叶节点，此时可以放心访问</span></span><br><span class="line"><span class="comment">2. 有右孩子，但右孩子访问过，此时也可以访问</span></span><br><span class="line"><span class="comment">只要确保只在这两种情况下visit，就是安全的后序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder2</span><span class="params">(LinkTree T)</span> </span>&#123;</span><br><span class="line">    LinkTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (T || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(T);</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        &#125;<span class="comment">//一路遍历到没有左孩子，此时可能有右孩子</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            T = st.<span class="built_in">top</span>();<span class="comment">//读节点但不弹出</span></span><br><span class="line">            <span class="keyword">if</span> (T-&gt;right &amp;&amp; T-&gt;right != pre) T = T-&gt;right;<span class="comment">//如果有右孩子，且没有访问过，右孩子入栈</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                T = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">visit</span>(T);</span><br><span class="line">                pre = T;</span><br><span class="line">                T = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从数组构建链式树，如果值是INT_MIN则视为nullptr</span></span><br><span class="line"><span class="function">LinkTree <span class="title">build_tree_from_array</span><span class="params">(LinkTree T, <span class="type">int</span> values[], <span class="type">int</span> size, <span class="type">int</span> start = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    T-&gt;data = values[start];</span><br><span class="line">    T-&gt;left = (<span class="built_in">left</span>(start) &lt; size) ? <span class="built_in">build_tree_from_array</span>(<span class="keyword">new</span> TreeNode, values, size, <span class="built_in">left</span>((start))) : <span class="literal">nullptr</span>;</span><br><span class="line">    T-&gt;right = (<span class="built_in">right</span>(start) &lt; size) ? <span class="built_in">build_tree_from_array</span>(<span class="keyword">new</span> TreeNode, values, size, <span class="built_in">right</span>((start))) : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将值是int_min的节点设为空，并回收内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree_helper</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == INT16_MIN) &#123;</span><br><span class="line">        LinkTree temp = T;</span><br><span class="line">        T = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_tree_helper</span>(T-&gt;left);</span><br><span class="line">    <span class="built_in">build_tree_helper</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换给定节点的左右子树</span></span><br><span class="line"><span class="function">LinkTree&amp; <span class="title">exchange_lr</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    LinkTree temp = T-&gt;left;</span><br><span class="line">    T-&gt;left = T-&gt;right;</span><br><span class="line">    T-&gt;right = temp;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线索二叉树">线索二叉树</h3>
<p>n个结点的链式数有n+1个空链接，利用这些指针来存储前驱和后继节点<br />
规定若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点,并用两个tag标记前后驱节点是否启用<br />
tag==0时，表示节点是孩子节点，否则是前后节点<br />
线索二叉树的先驱后继是相对于一种遍历顺序的，例如先序线索时如图： <img src="/assets/resources/Pasted%20image%2020240406214612.png" /> 先序线索二叉树无法确定前驱节点，后序线索二叉树无法确定后继节点<br />
<img src="/assets/resources/Pasted%20image%2020240406220758.png" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">//数据元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>* lchild, * rchild; <span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="type">bool</span> ltag, rtag; <span class="comment">//左、右线索标志</span></span><br><span class="line">    <span class="built_in">ThreadNode</span>() &#123; lchild = rchild = <span class="literal">NULL</span>; ltag = rtag = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> ThreadTree = ThreadNode*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode* node)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; node-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用中序遍历线索化二叉树</span></span><br><span class="line"><span class="comment">//先序线索化中当ltag==0时才能对左子树先序列线索化,否则可能形成环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;lchild, pre); <span class="comment">//递归，线索化左子树</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p; <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p; <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;rchild, pre); <span class="comment">//递归，线索化右子树</span></span><br><span class="line">    &#125;<span class="comment">//if(p!=NULL)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用中序遍历建立线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatelnThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">//中序遍历的最后一个结点右孩子指针必为空,不需要判空</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求中序线索二叉树中中序序列下的第一个结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">Firstnode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild; <span class="comment">//最左下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求中序线索二叉树中结点p在中序序列下的后继</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">Nextnode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Firstnode</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1 直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不含头结点的中序线索二叉树的中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode* T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadNode* p = <span class="built_in">Firstnode</span>(T);p != <span class="literal">NULL</span>; p = <span class="built_in">Nextnode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;<span class="comment">//左子树</span></span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;        <span class="comment">//建立前</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;               <span class="comment">//标记当</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">PreThread</span>(p-&gt;lchild, pre);</span><br><span class="line">        <span class="built_in">PreThread</span>(p-&gt;rchild, pre);</span><br><span class="line">    &#125;<span class="comment">//if(p!=NULL)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;<span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T, pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(p-&gt;lchild, pre);</span><br><span class="line">        <span class="built_in">PostThread</span>(p-&gt;rchild, pre);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">    &#125;<span class="comment">//if(p!=NULL)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;<span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T, pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note warning"><ul>
<li>后向遍历可以输出子节点到祖先结点的路径</li>
</ul>
</div>
<h2 id="森林">森林</h2>
<p>可以表示任何树的方法：</p>
<ol type="1">
<li><p>双亲表示法：采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置,求结点的孩子时则需要遍历整个结构 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的双亲节点表示法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PTree</span> &#123;</span><br><span class="line">    PTNode nodes[MaxSize];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>孩子表示法，将每个结点的孩子结点都用单链表链接起来，每个结点都有自己的孩子链表(可以为空)，寻找双亲的操作需要遍历</p></li>
<li><p>孩子兄弟表示法,以二叉链表作为树的存储结构,即二叉树的左指针是孩子链表，右指针是兄弟链表，从当前结点查找其双亲结点比较麻烦，<strong>也是树和二叉树相互转化的方法</strong></p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CSNode</span> &#123;</span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span>* firstchild, * nextsibling; <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> CSTree = CSNode*;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/resources/Pasted%20image%2020240409132729.png" /> 任意一棵和树对应的二叉树的右子树必空 <img src="/assets/resources/Pasted%20image%2020240409133039.png" /> <img src="/assets/resources/Pasted%20image%2020240409133312.png" /></p>
<p>森林和二叉树的转化类似树和二叉树，每一棵树转化成二叉树，视为第一个树的兄弟，被连接至根节点的右侧</p>
<ul>
<li>树的遍历分为先根和后根，因为转化成二叉树时根节点只有左子树，所以不需要区分左右</li>
<li>森林的遍历则有先序和中序
<ul>
<li>先序指先访问第一棵树的根节点，然后递归访问其子节点与其他树</li>
<li>中序指先递归访问第一棵树的子节点，然后访问其根节点，最后递归访问其他树</li>
</ul></li>
</ul>
<p>森林的中序也可以理解成后序，因为对每棵树来说，根节点被最后访问</p>
<div class="note warning"><ul>
<li>转换为二叉树时，树的每个分支结点的所有子结点中的最右子结点无右孩子，根结点转换后也没有右孩子，因此，对应二叉树中无右孩子的结点个数=分支结点数+1</li>
</ul>
</div>
<h2 id="树的应用">树的应用</h2>
<p>从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的带权路径长度<br />
含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树,也称最优二叉树<br />
将一段文本的字符频率作为权值的哈夫曼树，则可以用来进行哈夫曼编码，实现文本的压缩传输，这也是cs106b的期末作业，代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作业其实都用的斯坦福自己的数据结构库，相比stl操作更简单</span></span><br><span class="line"><span class="comment">//todo:哪天用stl写一遍</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EncodingTreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    EncodingTreeNode* zero;</span><br><span class="line">    EncodingTreeNode* one;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cal_weightOfInternal</span><span class="params">(<span class="type">const</span> EncodingTreeNode* node , <span class="type">const</span> Map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; &amp;weight)</span></span></span><br><span class="line"><span class="function"><span class="comment">//计算中间节点的权值，weight存放的是文本字符的初始权值(频率)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;one==<span class="literal">nullptr</span>&amp;&amp;node-&gt;zero==<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> weight[node-&gt;ch];</span><br><span class="line">    &#125;</span><br><span class="line">    sum += <span class="built_in">Cal_weightOfInternal</span>(node-&gt;one,weight);</span><br><span class="line">    sum += <span class="built_in">Cal_weightOfInternal</span>(node-&gt;zero,weight);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EncodingTreeNode* <span class="title">huffmanTreeFor</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; weight;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s :str)</span><br><span class="line">    &#123;</span><br><span class="line">        weight[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(weight.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;<span class="built_in">error</span>(<span class="string">&quot;Should have at least two different character!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;EncodingTreeNode*&gt; PQ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s : weight)</span><br><span class="line">    &#123;</span><br><span class="line">        EncodingTreeNode* TN = <span class="keyword">new</span>  EncodingTreeNode;</span><br><span class="line">        TN-&gt;ch = s; TN-&gt;one = TN-&gt;zero = <span class="literal">nullptr</span>;</span><br><span class="line">        PQ.<span class="built_in">enqueue</span>(TN,weight[s]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(PQ.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> zero = PQ.<span class="built_in">peek</span>();PQ.<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="keyword">auto</span> one = PQ.<span class="built_in">peek</span>();PQ.<span class="built_in">dequeue</span>();</span><br><span class="line">        EncodingTreeNode* internal = <span class="keyword">new</span> EncodingTreeNode;</span><br><span class="line">        internal-&gt;zero = zero;internal-&gt;one = one;internal-&gt;ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">int</span> weightOfInternal = <span class="built_in">Cal_weightOfInternal</span>(internal,weight);</span><br><span class="line">        PQ.<span class="built_in">enqueue</span>(internal,weightOfInternal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> treeroot = PQ.<span class="built_in">peek</span>();</span><br><span class="line">    <span class="keyword">return</span> treeroot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EncodingTreeNode* <span class="title">huffmanTreeFor</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* generate the frequency chart */</span></span><br><span class="line">    PriorityQueue&lt;EncodingTreeNode*&gt; frequency;</span><br><span class="line">    Map&lt;<span class="type">char</span>, <span class="type">double</span>&gt; frequencyMap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> key : str) &#123;</span><br><span class="line">        frequencyMap[key] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (frequencyMap.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;There must be at least two different letters! &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; keys;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> key : frequencyMap) &#123;</span><br><span class="line">        EncodingTreeNode* node = <span class="keyword">new</span> EncodingTreeNode;</span><br><span class="line">        node-&gt;ch = key;</span><br><span class="line">        node-&gt;one = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;zero = <span class="literal">nullptr</span>;</span><br><span class="line">        frequency.<span class="built_in">enqueue</span>(node, frequencyMap[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (frequency.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">double</span> firstweight = frequency.<span class="built_in">peekPriority</span>();</span><br><span class="line">        EncodingTreeNode* firstchoice = frequency.<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="type">double</span> secondweight = frequency.<span class="built_in">peekPriority</span>();</span><br><span class="line">        EncodingTreeNode* secondchoice = frequency.<span class="built_in">dequeue</span>();</span><br><span class="line">        EncodingTreeNode* newNode = <span class="keyword">new</span> EncodingTreeNode;</span><br><span class="line">        newNode-&gt;zero = firstchoice;</span><br><span class="line">        newNode-&gt;one = secondchoice;</span><br><span class="line">        frequency.<span class="built_in">enqueue</span>(newNode, firstweight + secondweight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frequency.<span class="built_in">dequeue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeaf</span><span class="params">(EncodingTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;one == <span class="literal">nullptr</span> &amp;&amp; tree-&gt;zero == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRightPath</span><span class="params">(<span class="type">const</span> <span class="type">char</span> letter, EncodingTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLeaf</span>(tree) &amp;&amp; tree-&gt;ch == letter) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isRightPath</span>(letter, tree-&gt;one) || <span class="built_in">isRightPath</span>(letter, tree-&gt;zero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">decodeText</span><span class="params">(Queue&lt;Bit&gt;&amp; bits, EncodingTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    string origin = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!bits.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        EncodingTreeNode* curNode = tree;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isLeaf</span>(curNode)) &#123;</span><br><span class="line">            Bit label = bits.<span class="built_in">dequeue</span>();</span><br><span class="line">            <span class="comment">/* choose one branch*/</span></span><br><span class="line">            <span class="keyword">if</span> (label == <span class="number">1</span>) &#123;</span><br><span class="line">                curNode = curNode-&gt;one;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (label == <span class="number">0</span>) &#123;</span><br><span class="line">                curNode = curNode-&gt;zero;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* read only on leaves */</span></span><br><span class="line">        origin += curNode-&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue&lt;Bit&gt; <span class="title">encodeText</span><span class="params">(<span class="type">const</span> string&amp; str, EncodingTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Bit&gt; code;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> value : str) &#123;</span><br><span class="line">        EncodingTreeNode* curNode = tree;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isLeaf</span>(curNode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isRightPath</span>(value, curNode-&gt;zero)) &#123;</span><br><span class="line">                code.<span class="built_in">enqueue</span>(<span class="number">0</span>);</span><br><span class="line">                curNode = curNode-&gt;zero;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isRightPath</span>(value, curNode-&gt;one)) &#123;</span><br><span class="line">                code.<span class="built_in">enqueue</span>(<span class="number">1</span>);</span><br><span class="line">                curNode = curNode-&gt;one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集">并查集</h3>
<p>简单地说并查集就是用数组树来表示的集合，其基本操作如下 <img src="/assets/resources/Pasted%20image%2020240410171546.png" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> UFSets[MaxSize]; <span class="comment">//集合元素数组(双亲指针数组)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> S[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) <span class="comment">//每个自成单元素集合</span></span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> </span>&#123;<span class="comment">//返回元素x的根(对应索引必然小于0)</span></span><br><span class="line">    <span class="keyword">while</span> (S[x] &gt;= <span class="number">0</span>) <span class="comment">//循环寻找x的根</span></span><br><span class="line">        x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//根的 S[]小于 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> </span>&#123;<span class="comment">//求两个不相交集合的并集</span></span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2) <span class="keyword">return</span>; <span class="comment">//要求 Root1 与 Root2 是不同的集合</span></span><br><span class="line">    S[Root2] = Root1; <span class="comment">//将根 Root2 连接到另一根 Root1 下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><ul>
<li>可用于实现克鲁斯卡尔算法(判断是否加入一条边之前，先查找这条边关联的两个顶点是否属于同一个集合)<br />
</li>
<li>可用于判断无向图的连通性,即整个图遍历后，连通分量一一对应集合</li>
<li>可用二叉树检查编码是否满足前缀不重复特性，即只有编码树的叶节点能对应被编码的一个字符</li>
</ul>
</div>
<p>练习题汇总： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.找到顺序存储二叉树的公共父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_public_parent</span><span class="params">(Arraytree T, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || j &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) i = <span class="built_in">parent</span>(i);</span><br><span class="line">        <span class="keyword">else</span> j = <span class="built_in">parent</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == j &amp;&amp; i &gt; <span class="number">0</span>) <span class="keyword">return</span> T.data[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.二叉树的自下而上、从右到左的层次遍历算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev_levelOrder</span><span class="params">(LinkTree T)</span> </span>&#123;<span class="comment">//相当于层次遍历的相反顺序，即用栈来存储队列遍历产生的结果</span></span><br><span class="line">    stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    queue&lt;LinkTree&gt; qe;</span><br><span class="line">    qe.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = qe.<span class="built_in">front</span>();</span><br><span class="line">        qe.<span class="built_in">pop</span>();</span><br><span class="line">        stack.<span class="built_in">push</span>(node);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            qe.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            qe.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(stack.<span class="built_in">top</span>());</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.递归求二叉树高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(LinkTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(T-&gt;left), <span class="built_in">height</span>(T-&gt;right)) + <span class="number">1</span>;<span class="comment">//优雅的两行实现，但不是尾递归？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.非递归算法求二叉树的高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height2</span><span class="params">(LinkTree T)</span> </span>&#123;<span class="comment">//层序遍历中存储每层最右侧指针，每次出队元素和最右侧指针相同时，高度++</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">    TreeNode* last = T;</span><br><span class="line">    queue&lt;LinkTree&gt; qe;</span><br><span class="line">    qe.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        LinkTree node = qe.<span class="built_in">front</span>();</span><br><span class="line">        qe.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) qe.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) qe.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node == last) &#123;</span><br><span class="line">            height++;</span><br><span class="line">            last = qe.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.先序遍历序列和中序遍历序列分别存于两个一维数组,构建二叉树</span></span><br><span class="line"><span class="function">LinkTree <span class="title">build_tree_from_pre_and_in</span><span class="params">(<span class="type">int</span> pre[], <span class="type">int</span> in[], <span class="type">int</span> pre1, <span class="type">int</span> pre2, <span class="type">int</span> in1, <span class="type">int</span> in2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pre1,pre2分别是先序的第一和最后一个节点下标</span></span><br><span class="line">    LinkTree root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    root-&gt;data = pre[pre1];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = in1;in[i] != root-&gt;data;i++);<span class="comment">//找到根节点来划分左右子树</span></span><br><span class="line">    <span class="type">int</span> left_len = i - in1;</span><br><span class="line">    <span class="type">int</span> right_len = in2 - i;</span><br><span class="line">    <span class="keyword">if</span> (left_len != <span class="number">0</span>) root-&gt;left = <span class="built_in">build_tree_from_pre_and_in</span>(pre, in, pre1 + <span class="number">1</span>, pre1 + left_len, in1, in1 + left_len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (right_len != <span class="number">0</span>) root-&gt;right = <span class="built_in">build_tree_from_pre_and_in</span>(pre, in, pre2 - right_len + <span class="number">1</span>, pre2, in2 - right_len + <span class="number">1</span>, in2);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.判别给定二叉树是否是完全二叉树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_complete</span><span class="params">(LinkTree T)</span> </span>&#123;</span><br><span class="line">    queue&lt;LinkTree&gt; qe;</span><br><span class="line">    qe.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        LinkTree node = qe.<span class="built_in">front</span>();</span><br><span class="line">        qe.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            qe.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            qe.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (qe.<span class="built_in">front</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                qe.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.求给定二叉树的所有双分支结点个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num_of_twinnode</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;<span class="comment">//优雅的递归</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;left &amp;&amp; T-&gt;right) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">num_of_twinnode</span>(T-&gt;left) + <span class="built_in">num_of_twinnode</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">num_of_twinnode</span>(T-&gt;left) + <span class="built_in">num_of_twinnode</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.交换所有结点的左右子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_lr</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">swap_lr</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">swap_lr</span>(T-&gt;right);</span><br><span class="line">        LinkTree L = T-&gt;left;</span><br><span class="line">        T-&gt;left = T-&gt;right;</span><br><span class="line">        T-&gt;right = L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.求先序遍历序列中第k个节点的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">preOrder_kth_node</span><span class="params">(LinkTree T, <span class="type">int</span>&amp; i, <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> INT32_MIN;<span class="comment">//输入不合理，直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (k == i) <span class="keyword">return</span> T-&gt;data;<span class="comment">//由于每次递归i只+1,因此达到k时必然立刻返回</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;left) val = <span class="built_in">preOrder_kth_node</span>(T-&gt;left, ++i, k);<span class="comment">//存储对左子树遍历后的值</span></span><br><span class="line">    <span class="keyword">if</span> (i == k) <span class="keyword">return</span> val;<span class="comment">//如果遍历完左子树，且i==k,那么返回值必然是ith节点的data</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;right) <span class="keyword">return</span> <span class="built_in">preOrder_kth_node</span>(T-&gt;right, ++i, k);<span class="comment">//如果右孩子不空，才可以++i</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> INT16_MIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.对于树中每个元素值为x的结点，删除以x为根的子树，并释放相应的空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_val_x_node_helper</span><span class="params">(LinkTree&amp; T, <span class="type">int</span>&amp; x, LinkTree&amp; pre, <span class="type">bool</span> is_lft)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">del_val_x_node_helper</span>(T-&gt;left, x, T, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">del_val_x_node_helper</span>(T-&gt;right, x, T, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) &#123;</span><br><span class="line">        <span class="built_in">del_node</span>(T);<span class="comment">//递归删除T的所有子节点</span></span><br><span class="line">        <span class="keyword">if</span> (is_lft) pre-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> pre-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_val_x_node</span><span class="params">(LinkTree&amp; T, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) <span class="built_in">del_node</span>(T);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">del_val_x_node_helper</span>(T-&gt;left, x, T, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">del_val_x_node_helper</span>(T-&gt;right, x, T, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.打印值为x的结点的所有祖先，假设值为x的结点不多于一个</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">print_ancestor_helper</span><span class="params">(LinkTree&amp; T, <span class="type">int</span>&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_ancestor_of_xval</span><span class="params">(LinkTree&amp; T, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_ancestor_helper</span>(T, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">print_ancestor_helper</span><span class="params">(LinkTree&amp; T, <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归返回true表示该节点的子节点中有x节点，因此可以打印，否则不能打印</span></span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> val1 = <span class="built_in">print_ancestor_helper</span>(T-&gt;left, x);</span><br><span class="line">    <span class="keyword">if</span> (val1 == <span class="number">1</span>) cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="type">bool</span> val2 = <span class="built_in">print_ancestor_helper</span>(T-&gt;right, x);</span><br><span class="line">    <span class="keyword">if</span> (val2 == <span class="number">1</span>) cout &lt;&lt; T-&gt;data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> val1 || val2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现用到栈，访问到值为x的结点时，栈中所有元素均为该结点的祖先，依次出栈打印</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//11.p和q分别为指向该二叉树中任意两个结点的指针,寻找其最近公共祖先</span></span><br><span class="line"><span class="comment">//祖先有两种可能：1.该节点左右子树各自存在pq 2.节点本身是p或q且其左子树或右子树有另一个孩子节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ancestor_helper</span><span class="params">(LinkTree tree, LinkTree&amp; p, LinkTree&amp; q, LinkTree&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> is_lft_son = <span class="built_in">ancestor_helper</span>(tree-&gt;left, p, q, res);</span><br><span class="line">    <span class="type">bool</span> is_rht_son = <span class="built_in">ancestor_helper</span>(tree-&gt;right, p, q, res);</span><br><span class="line">    <span class="keyword">if</span> ((is_lft_son &amp;&amp; is_rht_son) || ((tree-&gt;data == p-&gt;data || tree-&gt;data == q-&gt;data) &amp;&amp; (is_lft_son || is_rht_son))) &#123;</span><br><span class="line">        res = tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_lft_son || is_rht_son || (tree-&gt;data == p-&gt;data || tree-&gt;data == q-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkTree <span class="title">find_ancestor_root</span><span class="params">(LinkTree root, LinkTree p, LinkTree q)</span> </span>&#123;</span><br><span class="line">    LinkTree res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">ancestor_helper</span>(root, p, q, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12.求非空二叉树的宽度(结点数最多的一层的结点个数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width_of_tree</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_layer = <span class="number">1</span>;</span><br><span class="line">    queue&lt;LinkTree&gt; qe;</span><br><span class="line">    queue&lt;LinkTree&gt; next_qe;</span><br><span class="line">    qe.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!qe.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            LinkTree t = qe.<span class="built_in">front</span>();</span><br><span class="line">            qe.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) next_qe.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) next_qe.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next_qe.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">        max_layer = <span class="built_in">max</span>(<span class="built_in">int</span>(next_qe.<span class="built_in">size</span>()), max_layer);</span><br><span class="line">        qe = next_qe;</span><br><span class="line">        <span class="keyword">while</span> (!next_qe.<span class="built_in">empty</span>()) next_qe.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//13.一棵满二叉树(所有结点值均不同),已知其先序序列为pre,求其后序序列post。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_post_from_pre</span><span class="params">(<span class="type">int</span> pre[], <span class="type">int</span> l1, <span class="type">int</span> h1, <span class="type">int</span> post[], <span class="type">int</span> l2, <span class="type">int</span> h2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> half;</span><br><span class="line">    <span class="keyword">if</span> (h1 &gt;= l1) &#123;</span><br><span class="line">        post[h2] = pre[<span class="number">11</span>];</span><br><span class="line">        half = (h1 - l1) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">find_post_from_pre</span>(pre, <span class="number">11</span> + <span class="number">1</span>, <span class="number">11</span> + half, post, <span class="number">12</span>, <span class="number">12</span> + half - <span class="number">1</span>); <span class="comment">//转换左子树</span></span><br><span class="line">        <span class="built_in">find_post_from_pre</span>(pre, <span class="number">11</span> + half + <span class="number">1</span>, h1, post, <span class="number">12</span> + half, h2 - <span class="number">1</span>); <span class="comment">//转换右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14.将二叉树的叶结点按从左到右的顺序连成一个带头结点单链表，表头指针为head，叶结点的右指针域来存放单链表指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_to_link_helper</span><span class="params">(LinkTree t, LinkTree&amp; tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right) &#123;</span><br><span class="line">        tail-&gt;right = t;</span><br><span class="line">        tail = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">tree_to_link_helper</span>(t-&gt;left, tail);</span><br><span class="line">        <span class="built_in">tree_to_link_helper</span>(t-&gt;right, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkTree <span class="title">tree_to_link</span><span class="params">(LinkTree&amp; T)</span> </span>&#123;</span><br><span class="line">    LinkTree head = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    LinkTree tail = head;</span><br><span class="line">    head-&gt;data = INT16_MIN;</span><br><span class="line">    head-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    head-&gt;right = tail;</span><br><span class="line">    <span class="built_in">tree_to_link_helper</span>(T, tail);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*15.判断二叉树是否相似，相似的定义：</span></span><br><span class="line"><span class="comment">T1和T2都是空的二叉树或都只有一个根结点；</span></span><br><span class="line"><span class="comment">或者T1的左子树和T2的左子树相似，且T1的右子树和T2的右子树相似</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_tree_similar</span><span class="params">(LinkTree&amp; T1, LinkTree&amp; T2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T1 &amp;&amp; !T2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!T1 || !T2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> if_tree_similar(T1-&gt;left, T2-&gt;left) &amp;&amp; if_tree_similar(T1-&gt;right, T2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//真题1.求出二叉树中所有叶结点的带权路径长度之和,需要权值乘层高</span></span><br><span class="line"><span class="comment">//视data为weight</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum_weight_helper</span><span class="params">(LinkTree t, <span class="type">int</span>&amp; sum, <span class="type">int</span> path_weight, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right) &#123;</span><br><span class="line">        sum += path_weight + t-&gt;data * depth;</span><br><span class="line">    &#125;</span><br><span class="line">    path_weight += t-&gt;data * depth;</span><br><span class="line">    <span class="built_in">sum_weight_helper</span>(t-&gt;left, sum, path_weight, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sum_weight_helper</span>(t-&gt;right, sum, path_weight, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_weight</span><span class="params">(LinkTree&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sum_weight_helper</span>(t, w, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16.在中序线索二叉树里查找指定结点在后序的前驱结点</span></span><br><span class="line"><span class="function">ThreadTree <span class="title">find_pre_node</span><span class="params">(ThreadTree&amp; t, ThreadTree&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在中序线索二叉树t中，求指定结点p在后序下的前驱结点q</span></span><br><span class="line">    ThreadTree q;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) <span class="comment">//若p有右子女，则右子女是其后序前驱</span></span><br><span class="line">        q = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>) <span class="comment">//若p只有左子女，则左子女是其后序前驱</span></span><br><span class="line">        q = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">        q = <span class="literal">NULL</span>; <span class="comment">//p是中序序列第一结点，无后序前驱</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//顺左线索向上找p的祖先，若存在，再找祖先的左子女</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;ltag == <span class="number">1</span> &amp;&amp; p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            q = p-&gt;lchild; <span class="comment">//p结点的祖先的左子女是其后序前驱</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q = <span class="literal">NULL</span>; <span class="comment">//仅有单支树(p是叶子)，己到根结点，p无后序前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<hr />
<h1 id="图">图</h1>
<p>图G由顶点集V和边集E组成，即G=(V,E)<br />
其中，E的组成是(u,v)<br />
可分为有向和无向图</p>
<ul>
<li>有向图的边用&lt;1,2&gt;表示</li>
<li>无向图的边用(1,2)表示</li>
<li>不存在重复边，没有连接自己的边的图是简单图</li>
<li>某两个顶点之间的边数大于1条，又允许顶点通过一条边和自身关联，则称图G为多重图</li>
<li>对无向图，任意两个结点都有边连接的无向图称为完全图，即n(n-1)/2条边，有向完全图的边数则是完全图边数的翻倍</li>
<li>V和E的子集构成的图(必须能构成图)，是原图的子图，若两者的V相等，则称为生成子图</li>
<li>极大连通子图是无向图的连通分量、极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。</li>
<li>无向图中，任意两个节点连通(存在路径)的图是连通图,无向图中的极大连通子图称为连通分量</li>
<li>在有向图中，如果有一对顶点V和W,从V到W和从W到V间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量</li>
<li>连通图的生成树是包含图中全部顶点的一个极小连通子图(n-1条边),减少一条边则不连通，增加一条边则形成环</li>
<li>无向图中顶点v的度是指依附于顶点v的边的条数，即TD(v)，无向图的全部顶点的度的和等于边数的2倍</li>
<li>有向图的全部顶点的入度之和与出度之和相等，并且等于边数</li>
<li>边有权的图称为带权图(网)</li>
<li>稀疏和稠密是相对概念，一般VlogV是分界点</li>
<li>若一个图有n个顶点，并且有大于n-1条边，则此图一定有环</li>
<li>顶点不重复出现的路径称为简单路径,除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路</li>
<li>两个结点间最短路径的长度是两者的距离，不连通时为无穷</li>
<li>一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树</li>
</ul>
<h2 id="存储">存储</h2>
<h3 id="邻接矩阵法">邻接矩阵法</h3>
<p>一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息<br />
<code>A[i][j]</code>可以表示边是否存在(1/0)，也可以表示权值(此时0/无穷表示不存在)<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> VertexType = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> EdgeType = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix_Graph</span> &#123;</span><br><span class="line">    VertexType Vex[MaxVertexNum];</span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <img src="/assets/resources/Pasted%20image%2020240411170810.png" /></p>
<ul>
<li>对无向图来说，可以用上三角矩阵储存边，其第i行或列的边数量就是顶点i的度<br />
</li>
<li>对有向图来说，第i行非零元素的个数正好是顶点i的出度，第i列则是其入度</li>
<li>易于检测节点间关系，但边需要遍历</li>
<li>适合稠密图</li>
</ul>
<h3 id="邻接表法">邻接表法</h3>
<p>每个顶点V建立一个单链表，第i个单链表中的结点表示依附顶点Vi的边(对于有向图则是以顶点Vi为尾的弧)，这个单链表就称为顶点Vi的边表(对于有向图则称为出边表)<br />
同时需要顶点表存储顶点，与边表区分 <img src="/assets/resources/Pasted%20image%2020240411171623.png" /> <img src="/assets/resources/Pasted%20image%2020240411171432.png" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix_Graph</span> &#123;</span><br><span class="line">    VNodeType Vex[MaxVertexNum];</span><br><span class="line">    EdgeType Edge[MaxVNodeNum][MaxVertexNum]; <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VNode</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123; <span class="comment">//边表结点</span></span><br><span class="line">    VNode* adjvex; <span class="comment">//该弧所指向的顶点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span>* next; <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info; //网的边权值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VNode</span> &#123; <span class="comment">//顶点表结点</span></span><br><span class="line">    VNodeType no; <span class="comment">//顶点编号</span></span><br><span class="line">    ArcNode* first; <span class="comment">//指向第一条依附该项点的弧的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ALGraph</span> &#123;</span><br><span class="line">    VNode vertices[MaxVNodeNum]; <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> GraphAdjList = ALGraph;</span><br><span class="line"><span class="keyword">using</span> Vertex = VNode;</span><br><span class="line"></span><br><span class="line"><span class="function">ALGraph <span class="title">build_graph</span><span class="params">(<span class="type">int</span> V[], pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; edges[], <span class="type">int</span> V_size, <span class="type">int</span> e_size)</span> </span>&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    G.vexnum = V_size;G.arcnum = e_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++) &#123;</span><br><span class="line">        VNode v;</span><br><span class="line">        v.no = i;</span><br><span class="line">        v.first = <span class="literal">nullptr</span>;</span><br><span class="line">        G.vertices[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.arcnum;i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> e = edges[i];</span><br><span class="line">        ArcNode* arc = <span class="keyword">new</span> ArcNode;</span><br><span class="line">        arc-&gt;adjvex = &amp;G.vertices[e.second];</span><br><span class="line">        arc-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> temp = G.vertices[e.first].first;</span><br><span class="line">        G.vertices[e.first].first = arc;</span><br><span class="line">        G.vertices[e.first].first-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_graph</span><span class="params">(ALGraph G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = G.vertices[i].first;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p-&gt;adjvex-&gt;no &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无向图的存储空间O(V+2E),有向图是O(V+E)</li>
<li>适合稀疏图</li>
<li>容易找到一个顶点的所有邻居，但难以判断给定两节点关系</li>
<li>求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表(逆邻接表相反)</li>
<li>链接次序任意，因此不唯一</li>
</ul>
<h3 id="十字链表">十字链表</h3>
<p><strong>有向图的存储结构</strong><br />
在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点,顶点结点之间是顺序存储的<br />
弧结点中：</p>
<ul>
<li>tailvex和headvex两个域分别指示弧尾和弧头这两个顶点的编号</li>
<li>hlink域指向弧头相同的下一个弧结点</li>
<li>tlink域指向弧尾相同的下一个弧结点</li>
<li>info域存放该弧的相关信息<br />
</li>
<li>弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上</li>
</ul>
<p>顶点结点中：</p>
<ul>
<li>data域存放该顶点的数据信息，如顶点名称</li>
<li>firstin域指向以该顶点为弧头的第一个弧结点</li>
<li>firstout域指向以该顶点为弧尾的第一个弧结点</li>
</ul>
<p>容易求得顶点的出度和入度。图的十字链表表示是不唯一的，但一个十字链表表示确定一个图<br />
<img src="/assets/resources/Pasted%20image%2020240411172832.png" /> <img src="/assets/resources/Pasted%20image%2020240411172839.png" /></p>
<h3 id="邻接多重表">邻接多重表</h3>
<p><strong>无向图的存储结构</strong><br />
所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点,因此每个边结点同时链接在两个链表中</p>
<p><img src="/assets/resources/Pasted%20image%2020240411173500.png" /> <img src="/assets/resources/Pasted%20image%2020240411173625.png" /></p>
<h3 id="基本操作-1">基本操作</h3>
<ul>
<li>Adjacent (G, x, y):判断图G是否存在边(x,y)</li>
<li>Neighbors (G, x):列出图G中与结点x邻接的边</li>
<li>InsertVertex (G, x):在图 G 中插入顶点 x</li>
<li>DeleteVertex (G, x):从图 G 中删除顶点 x</li>
<li>AddEdge (G, x, y)：若无向边(x,y)或有向边<code>&lt;x,y&gt;</code>不存在，则向图G中添加该边</li>
<li>RemoveEdge (G, x, y):若无向边(x,y)或有向边<code>&lt;x,y&gt;</code>存在，则从图G中删除该边</li>
<li>FirstNeighbor (G, x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x,则返回-1</li>
<li>NextNeighbor (G, x, y):假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</li>
<li>Get_edge_value (G, x, y)：获取图G中边(x,y)或对应的权值</li>
<li>Set_edge_value (G, x, y, v):设置图G中边(x,y)对应的权值为v</li>
</ul>
<div class="note warning"><ul>
<li>有向图的邻接表存储结构中，<strong>顶点V在边表中出现的次数是顶点v的入度</strong>(题中的边表不包括顶点表,任何顶点u对应的边表中存放的都是以u为起点的边所对应的另一个顶点V)</li>
<li>邻接矩阵<span class="math inline">\(A^m\)</span>的i行j列节点的值，是i节点到j节点长度为m的路径数</li>
</ul>
</div>
<h2 id="遍历">遍历</h2>
<p>BFS/DFS中邻接表的时间复杂度是O(V+E),邻接矩阵的时间复杂度是O(<span class="math inline">\(V^2\)</span>)</p>
<ul>
<li>广度遍历是分层查找，需要使用队列
<ul>
<li>邻接矩阵查找每个结点的邻边需要O(V)邻接表为O(E)</li>
<li>使用BFS可以求解非带权图的单源最短路径问题</li>
<li>广度遍历的过程中可以得到一棵遍历树，称为广度优先生成树，其是否唯一取决于邻接表和矩阵存储表示是否唯一</li>
</ul></li>
<li>深度遍历需要使用栈或者递归
<ul>
<li>基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的</li>
<li>空间复杂度为O(V)</li>
<li>对连通图调用DFS才能产生深度优先生成树，否则会得到森林，这样的生成不唯一</li>
<li>DFS可以得到一个拓扑排序序列</li>
<li>可用于检测环，如果遍历时遇到已经访问的结点，则有环</li>
</ul></li>
</ul>
<p>很容易看出非连通图的遍历可能需要进行多次，一般通过循环实现<br />
hello-algo的比较规范的实现：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 广度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line"><span class="function">vector&lt;Vertex*&gt; <span class="title">graphBFS</span><span class="params">(GraphAdjList&amp; graph, Vertex* startVet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;Vertex*&gt; res;</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    set&lt;Vertex*&gt; visited = &#123; startVet &#125;;</span><br><span class="line">    <span class="comment">// 队列用于实现 BFS</span></span><br><span class="line">    queue&lt;VNode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(startVet);</span><br><span class="line">    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Vertex* vet = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();          <span class="comment">// 队首顶点出队</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(vet); <span class="comment">// 记录访问顶点</span></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">auto</span> adjVet = vet-&gt;first;</span><br><span class="line">        <span class="keyword">while</span> (adjVet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(adjVet-&gt;adjvex)) &#123;</span><br><span class="line">                adjVet = adjVet-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;            <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push</span>(adjVet-&gt;adjvex);        <span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">            visited.<span class="built_in">emplace</span>(adjVet-&gt;adjvex); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">            adjVet = adjVet-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历辅助函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ALGraph&amp; graph, set&lt;VNode*&gt;&amp; visited, vector&lt;VNode*&gt;&amp; res, VNode* vet)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(vet);   <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.<span class="built_in">emplace</span>(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">auto</span> adjVet = vet-&gt;first;</span><br><span class="line">    vector&lt;VNode*&gt; temp = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (adjVet) &#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(adjVet-&gt;adjvex);</span><br><span class="line">        adjVet = adjVet-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> V : temp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">count</span>(V))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, visited, res, V); <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line"><span class="function">vector&lt;VNode*&gt; <span class="title">graphDFS</span><span class="params">(ALGraph&amp; graph, VNode* startVet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;VNode*&gt; res;</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    set&lt;VNode*&gt; visited;</span><br><span class="line">    <span class="built_in">dfs</span>(graph, visited, res, startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="应用">应用</h2>
<h3 id="最小生成树">最小生成树</h3>
<p>生成树是指一个图连接所有节点的，且边数为n-1的子图<br />
边的权值之和最小的生成树即为图的最小生成树，树形不唯一，但权值的和唯一(即所有权值不相等时树形也唯一)<br />
有多种算法，普遍思路是从最小边开始贪心</p>
<ol type="1">
<li>prim算法，由于用c++写出过于复杂，以下仅文字描述
<ol type="1">
<li>加入一个随机未访问节点</li>
<li>选取起始顶点已访问，指向顶点未访问的边中权值最小的，加入树</li>
<li>重复2.直到访问所有节点</li>
<li>时间复杂度O( <span class="math inline">\(V^2\)</span> ),适合密集图</li>
</ol></li>
<li>Kruskal算法
<ol type="1">
<li>初始化一个边集为空</li>
<li>从图取出权值最小的边，若两点不都被访问过，加入边集</li>
<li>重复2.直到边集有n-1条边</li>
<li>如果用最小堆实现，则复杂度O( <span class="math inline">\(E\log_{2}E\)</span> )，适合稀疏图</li>
</ol></li>
</ol>
<h3 id="带权图的最短路径">带权图的最短路径</h3>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html">演示地址</a></p>
<ol type="1">
<li>迪杰斯特拉算法(猎魔人那个)，属于一种贪心算法
<ol type="1">
<li>初始化dist和path数组,前者记录v0到vi的最短路径长，初始化为两者边长或无穷(出发点一般是0)；后者记录源点到顶点vi之间的最短路径的前驱结点</li>
<li>选出当前已知且未访问过的最短路径终点Vj,标记访问</li>
<li>进行所谓的放松操作，就是查看j的可达节点k，经过j的路径是否比dist数组中的<code>dist[k]</code>小，如果小就更新dist</li>
<li>重复2.3.一共n-1次，即访问所有节点</li>
<li>时间复杂度O(<span class="math inline">\(V^2\)</span>)</li>
<li>在加入的过程中，由于每次选最小边，总保持从源点v到已访问顶点集s中各顶点的最短路径长度不大于从源点v到未访问顶点集中任何顶点的最短路径长度，即s中顶点已经求到其最短路径，而负权值会打破这个条件</li>
</ol></li>
<li>Floyd算法
<ol type="1">
<li>设置矩阵序列A0~Ak,其中 <span class="math inline">\(A^{(k)}[i][j]\)</span> 表示元素i到j,考虑序号小于k的中间节点的最短路径长度，即迭代到n-1时得出整个图的最短路径(节点序号从0索引)，k=-1时表示i-&gt;j直接路径或正无穷</li>
<li>即每次迭代时k+1, <span class="math inline">\(A^{(k)}[i][j]=\mathrm{Min}\{A^{(k-1)}[i][j],\ A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},\quad k=0,1,\cdots,n-1\)</span> ，这样每次迭代就多考虑一个中间节点</li>
<li>时间复杂度为O( <span class="math inline">\(V^3\)</span>),但常数系数较小，输入中等规模时很有效，允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路；同样适用于带权无向图</li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240508204456.png" /></p>
<h3 id="拓扑排序">拓扑排序</h3>
<p>有向无环图DAG可以用于简化存储空间(dag表示的表达式不可能出现重复的操作数顶点) <img src="/assets/resources/Pasted%20image%2020240510115617.png" /></p>
<p>AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边<code>&lt;Vi,Vj&gt;</code>表示活动Vi必须先于活动Vj，则将这种有向图称为顶点表示活动的网络，记为AOV网.活动Vi是活动Vj的直接前驱，活动Vj是活动Vi的直接后继，这种前驱和后继关系具有传递性，且任何活动不能以它自己作为自己的前驱或后继</p>
<p>一个由DAG图中全部节点构成的无重复序列，且若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径，那么这个序列就是一个拓扑排序<br />
深度遍历会直接产生一个拓扑排序，此外的常见思路：</p>
<ol type="1">
<li>从AOV网中选择一个没有前驱的顶点并输出</li>
<li>从网中删除该顶点和所有以它为起点的有向边</li>
<li>重复1.和2.直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环</li>
</ol>
<p>cpp实现：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G, <span class="type">int</span> indegree[])</span> </span>&#123;</span><br><span class="line">    vector&lt;VNode*&gt; res;</span><br><span class="line">    stack&lt;VNode*&gt; s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            s.<span class="built_in">push</span>(&amp;G.vertices[i]);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        VNode* i = s.<span class="built_in">top</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ++count;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ArcNode* p = i-&gt;first;<span class="comment">//将所有i指向的顶点的入度减1,并且将入度减为0的顶点压入栈S</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            --indegree[p-&gt;adjvex-&gt;no];</span><br><span class="line">            <span class="keyword">if</span> (indegree[p-&gt;adjvex-&gt;no] == <span class="number">0</span>) s.<span class="built_in">push</span>(p-&gt;adjvex);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于输出每个顶点的同时还要删除以它为起点的边，故采用邻接表存储时拓扑排序的时间复杂度为O(V+E),采用邻接矩阵存储时拓扑排序的时间复杂度为O(<span class="math inline">\(V^2\)</span>)</p>
<p>逆拓扑排序：</p>
<ol type="1">
<li>从AOV网中选择一个没有后继(出度为0)的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为终点的有向边。</li>
<li>重复1.和2.直到当前的AOV网为空</li>
</ol>
<ul>
<li>每个顶点有唯一的前驱后继关系时，拓扑排序的结果是唯一的</li>
<li>由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立</li>
</ul>
<h3 id="关键路径">关键路径</h3>
<p>带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销(如完成活动所需的时间)，称之为用边表示活动的网络，简称AOE网</p>
<ol type="1">
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li>
<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生</li>
<li>AOE网中仅有一个入度为0的顶点，称为开始顶点(源点)，它表示整个工程的开始；网中也仅存在一个出度为0的顶点，称为结束顶点(汇点)，它表示整个工程的结束</li>
</ol>
<p>从源点到汇点的所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为关键活动，关键路径代表完成整个工程的最短时间<br />
一些关键名词：</p>
<ol type="1">
<li><p>事件vk的最早发生时间ve(k)<br />
<span class="math inline">\(\nu e(k)=\mathrm{Max}\left\{\nu\mathrm{e}(j)+\mathrm{Weight}(\nu_{j},\,\nu_{k})\right\}\)</span><br />
vk是vj的任意后缀节点<br />
按从前往后的顺序进行，可以在拓扑排序的基础上计算</p></li>
<li><p>事件vk的最迟发生时间vl(k)<br />
在不推迟整个工程完成的前提下，即保证它的后继事件vj在其最迟发生时间vl(j)能够发生时，该事件最迟必须发生的时间<br />
<span class="math inline">\(\nu l(k)=\mathrm{Min}\left\{\nu l(j)-\mathrm{Weight}(\nu_{k},\,\nu_{j})\right\}\)</span><br />
设一个栈以记录拓扑序列，拓扑排序结束后从栈顶至栈底便为逆拓扑有序序列,可以逆拓扑序列进行vl的计算</p></li>
<li><p>活动ai的最早开始时间e(i),即该活动弧的起点所表示的事件的最早发生时间,若边<code>&lt;vk,vj&gt;</code>表示活动ai,则有e(i) = ve(k)</p></li>
<li><p>活动ai的最迟开始时间l(i),即该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。若边<code>&lt;vk,vj&gt;</code>表示活动ai,则有 <span class="math inline">\(l(i)=v l(j)-\operatorname{Weight}(\nu_{k},\,\nu_{j})\)</span></p></li>
<li><p>一个活动ai的最迟开始时间l(i)和其最早开始时间e(i)的差d(i)=l(i)-e(i)<br />
指该活动完成的时间余量,为0的活动需要立即完成，称为关键活动</p></li>
</ol>
<ol type="1">
<li>从源点出发，令ve(源点)= 0,按拓扑有序求其余顶点的最早发生时间ve()</li>
<li>从汇点出发，令vl(汇点)= ve(汇点)，按逆拓扑有序求其余顶点的最迟发生时间vl()</li>
<li>根据各顶点的ve()值求所有弧的最早开始时间e()</li>
<li>根据各顶点的vl()值求所有弧的最迟开始时间l()</li>
<li>求AOE网中所有活动的差额d(),找出所有d() = 0的活动构成关键路径</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240511113354.png" /> 关键路径上的所有活动都是关键活动,网中的关键路径并不唯一,加快那些包括在所有关键路径上的关键活动才一定能达到缩短工期的目的</p>
<div class="note warning"><ul>
<li>若一个有向图的顶点不能排成一个拓扑序列,则含有顶点数大于1的强连通分量</li>
<li>对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元全为零的充分必要条件是，该有向图可以进行拓扑排序</li>
</ul>
</div>
<hr />
<h1 id="查找">查找</h1>
<ul>
<li>在数据集合中寻找满足某种条件的数据元素的过程称为查找</li>
<li>用于查找的数据集合称为查找表,根据是否可以增加删除元素分为静态和动态</li>
<li>数据元素中唯一标识该元素的某个数据项的值是关键字</li>
<li>一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，定义为：<span class="math inline">\(\mathrm{ASL}=\sum_{i=1}^{n}P_{i}C_{i}\)</span></li>
<li>用于指示查找边界的特殊数据元素称为哨兵，例如数组末尾放置一个正无穷表示结束</li>
</ul>
<p>给定n个元素的线性表，定位第i个元素时,需进行<code>n-i + 1</code>次比较，设n是查找表的长度;Pi是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即Pi=1/n; Ci是找到第i个数据元素所需进行的比较次数,平均长度为:<br />
<span class="math inline">\(\mathrm{ASL}_{\mathrm{成功}}=\sum_{i=1}^{n}P_{i}(n-i+1)\)</span></p>
<p>每个元素查找概率相等时：<br />
<span class="math inline">\(\mathrm{ASL}_{成功}=\sum_{i=1}^{n}P_{i}(n-i+1)=\frac{n+1}{2}\)</span></p>
<p>不成功时，查找长度是n+1</p>
<h2 id="基本分类">基本分类</h2>
<h3 id="顺序查找">顺序查找</h3>
<p>查找成功的平均查找长度和一般线性表的顺序查找一样<br />
对有序表来说，查找失败的平均查找长度：<br />
<span class="math inline">\(\mathrm{ASL}_{不成功}=\sum_{j=1}^{n}q_{j}(l_{j}-1)={\frac{1+2+\cdots+n+n}{n+1}}={\frac{n}{2}}+{\frac{n}{n+1}}\)</span><br />
其中<span class="math inline">\(q_j\)</span>是到达第j个失败节点的概率，相等概率时为 <span class="math inline">\(\frac{1}{n+1}\)</span> <span class="math inline">\(l_j\)</span>是第j个失败节点所在判断树的层数<br />
可以是链式存储结构</p>
<h3 id="二分查找">二分查找</h3>
<p>概念略，其判断树是平衡二叉树，平均查找长度：<br />
<span class="math inline">\(\operatorname{ASL}={\frac{1}{n}}\sum_{i=1}^{n}l_{i}={\frac{1}{n}}(1\times1+2\times2+\cdots+h\times2^{h-1})={\frac{n+1}{n}}\log_{2}(n+1)-1\approx\log_{2}(n+1)-1\)</span><br />
最大查找长度： <span class="math inline">\(\lceil\log_2^{n+1}\rceil\)</span> 也是查找不成功时的比较次数 其中h是树高</p>
<h3 id="分块查找">分块查找</h3>
<p>分为彼此间有顺序关系，但内部无序的块，平均查找长度为索引查找和块内查找的平均长度之和<br />
将长度为n的查找表均匀地分为b块，每块有s个记录,等概率的情况下：</p>

$$ \mathbf{ASL}=L_{I}+L_{\mathrm{{S}}}={\frac{b+1}{2}}+{\frac{s+1}{2}}={\frac{s^{2}+2s+n}{2s}} $$  

<p><span class="math inline">\(s={\sqrt{n}}\)</span>时，取最小值 <span class="math inline">\({\sqrt{n}}+1\)</span></p>
<div class="note warning"><ul>
<li>折半查找过程所对应的判定树是平衡二叉树，左右子树高度相差最多为1</li>
<li>根据上一条可推断，查找失败时，比较次数最多相差1</li>
</ul>
</div>
<h2 id="使用树的查找">使用树的查找</h2>
<h3 id="bst">BST</h3>
<p>对二叉排序树BST进行中序遍历，可以得到一个递增的有序序列<br />
查找效率取决于是否平衡<br />
基本操作:</p>
<ol type="1">
<li>查找
<ol type="1">
<li>从根节点出发，根据当前节点与key大小关系向下前进</li>
<li>找到或进入空节点时，返回当前节点</li>
</ol></li>
<li>插入
<ol type="1">
<li>类似查找，但记录前驱节点</li>
<li>key和当前节点重合时，直接退出</li>
<li>正常应前进到空节点，此时根据key与pre节点的大小关系决定插入点</li>
</ol></li>
<li>删除(最复杂)
<ol type="1">
<li>类似查找，但记录前驱</li>
<li>查找无结果时，直接退出</li>
<li>找到后分两种情况
<ol type="1">
<li>0或1一个孩子，优先和存在的孩子交换，然后删除即可</li>
<li>2个孩子，遍历右子树的最左节点(相反也行)，和当前节点交换，然后(递归)删除交换后对应子树的待删除节点</li>
</ol></li>
</ol></li>
</ol>
<p>c++实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">search</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;data &gt; num)</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* cur = root, * pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data == num)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;data &lt; num)</span><br><span class="line">        pre-&gt;right = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre-&gt;left = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(TreeNode* root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root, * pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;data &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 子节点数量 = 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> || cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点</span></span><br><span class="line">        TreeNode* child = cur-&gt;left != <span class="literal">nullptr</span> ? cur-&gt;left : cur-&gt;right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (cur != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;left == cur)</span><br><span class="line">                pre-&gt;left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre-&gt;right = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若删除节点为根节点，则重新指定根节点</span></span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点数量 = 2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        TreeNode* tmp = cur-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmpVal = tmp-&gt;data;</span><br><span class="line">        <span class="comment">// 递归删除节点 tmp</span></span><br><span class="line">        <span class="built_in">remove</span>(root, tmp-&gt;data);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur-&gt;data = tmpVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="平衡二叉树avlbalanced-binary-tre">平衡二叉树AVL(Balanced Binary Tre)</h3>
<p><a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_tree/avl_tree">平衡二叉树</a>的定义:</p>
<ul>
<li>一棵空树</li>
<li>具有下列性质的二叉树
<ul>
<li>它的左子树和右子树都是平衡二叉树</li>
<li>左子树和右子树的高度差的绝对值不超过1</li>
</ul></li>
</ul>
<p>定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AVL 树节点类 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val&#123;&#125;;          <span class="comment">// 节点值</span></span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;     <span class="comment">// 节点高度(该节点到它的最远叶节点的距离)</span></span><br><span class="line">    TreeNode *left&#123;&#125;;   <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode *right&#123;&#125;;  <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="built_in">TreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> x)</span> : val(x)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rightRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;left;</span><br><span class="line">    TreeNode *grandChild = child-&gt;right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;right;</span><br><span class="line">    TreeNode *grandChild = child-&gt;left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="旋转">旋转</h4>
<ol type="1">
<li>右旋LL:失衡节点的左子树加入新节点高度+1，失衡因子达到2</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_rotate_with_grandchild.png" /></p>
<ol start="2" type="1">
<li>左旋RR:右旋的镜像</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_rotate_with_grandchild.png" /></p>
<ol start="3" type="1">
<li>先左旋后右旋LR: 失衡节点左倾，其子节点右倾</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_right_rotate.png" /></p>
<ol start="4" type="1">
<li>先右旋后左旋RL:LR的镜像</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_left_rotate.png" /></p>
<table>
<thead>
<tr class="header">
<th>失衡节点平衡因子</th>
<th>子节点平衡因子</th>
<th>旋转方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;1</td>
<td>≥0</td>
<td>右旋</td>
</tr>
<tr class="even">
<td>&gt;1</td>
<td>&lt;0</td>
<td>先左旋后右旋</td>
</tr>
<tr class="odd">
<td>&lt; -1</td>
<td>≤0</td>
<td>左旋</td>
</tr>
<tr class="even">
<td>&lt; -1</td>
<td>&gt;0</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
<p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png" /></p>
<h4 id="常见操作">常见操作</h4>
<ol type="1">
<li>插入:类似BST,唯一的区别在于，在 AVL 树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此从该节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡</li>
<li>删除:类似BST，在BST的删除节点方法的基础上，需要从底至顶执行旋转操作(或者从找到的第一个不平衡子树开始向上)，使所有失衡节点恢复平衡</li>
<li>构造:执行n次插入</li>
</ol>
<h3 id="红黑树">红黑树</h3>
<p>满足如下红黑性质的二叉排序树:</p>
<ol type="1">
<li>每个结点或是红色，或是黑色的.</li>
<li>根结点是黑色的.</li>
<li>叶结点(虚构的外部结点、NULL结点)都是黑色的。</li>
<li>不存在两个相邻的红结点(即红结点的父结点和孩子结点均是黑色的)。</li>
<li>对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。</li>
</ol>
<p><strong>性质</strong>:</p>
<ol type="1">
<li>从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的黑高（记为bh）,黑高的概念是由性质5确定的;根结点的黑高称为红黑树的黑高<br />
</li>
<li>从根到叶结点的最长路径不大于最短路径的2倍
<ol type="1">
<li>由5.从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成</li>
<li>由4.某条路径最长时，这条路径必然是由黑结点和红结点相间构成的</li>
</ol></li>
<li>有n个内部结点的红黑树的高度 h≤2 $ log_2^{n+1} $
<ol type="1">
<li>从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为h/2,因此 $ n≥2^{h/2}-1 $ (可以数学归纳法证明)</li>
</ol></li>
<li>新插入红黑树中的结点z初始着为红色，过程:
<ol type="1">
<li>若新插入结点z的父结点是黑色的，无须做任何调整，此时就是一棵标准的红黑树</li>
<li>若结点z是根结点，则将z着为黑色（树的黑高增1）</li>
<li>若结点z不是根结点，且z的父结点z.p是红色的:
<ol type="1">
<li>若z的叔结点y是黑色的，且z是一个右孩子:先左旋，再右旋</li>
<li>若z的叔结点y是黑色的，且z是一个左孩子:右单旋</li>
<li>若z的叔结点y是红色的:将z.p和y都着为黑色，将z.p.p着为红色;然后，把z.p.p作为新结点z来重复循环，指针z在树中上移两层</li>
</ol></li>
</ol></li>
</ol>
<p>红黑树任意一个结点左右子树的高度，相差不超过2倍(例如C++中的map和set;Java中的TreeMap和TreeSet用红黑树实现)</p>
<p><img src="/assets/resources/Pasted%20image%2020241111165247.png" /> <img src="/assets/resources/Pasted%20image%2020241111171032.png" /> <img src="/assets/resources/Pasted%20image%2020241111171040.png" /> <img src="/assets/resources/Pasted%20image%2020241111171051.png" /></p>
<h3 id="b树">B树</h3>
<p><img src="/assets/resources/Pasted%20image%2020241112103548.png" /></p>
<p>m阶B树是所有结点的平衡因子均等于0的m路平衡查找树<br />
一棵m阶B树或为空树，或为满足如下特性的叉树:</p>
<ol type="1">
<li>树中每个结点至多有m棵子树，即至多有m-1个关键字</li>
<li>若根结点不是叶结点，则至少有2棵子树，即至少有1个关键字</li>
<li>除根结点外的所有非叶结点至少有 <span class="math inline">\(\lceil m/2 \rceil\)</span> 棵子树，即至少有 <span class="math inline">\(\lceil m/2 \rceil -1\)</span> 个关键字</li>
<li>所有的叶结点.都出现在同一层次上，并且不带信息(可以视为外部结点或类似于折半查找判定树的失败结点，实际用空指针表示)</li>
<li>所有非叶结点的结构如下:</li>
</ol>
<table>
<thead>
<tr class="header">
<th>n</th>
<th>P0</th>
<th>K1</th>
<th>P1</th>
<th>K2</th>
<th>P2</th>
<th>……</th>
<th>Kn</th>
<th>Pn</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>其中:</p>
<ul>
<li>Ki为结点的关键字，且从K1至Kn递增</li>
<li>Pi(从0开始)为指向子树根结点的指针，即指针数为关键字数+1
<ul>
<li>P(i-1)所指子树中所有结点的关键字均小于Ki</li>
<li>Pi所指子树中所有结点的关键字均大于Ki</li>
</ul></li>
<li><span class="math inline">\(n\ \left(\lceil m/2\rceil-1\leqslant n\leqslant m-1\right)\)</span> 为结点中关键字的个数</li>
</ul>
<h4 id="常见操作-1">常见操作</h4>
<p>查找:</p>
<ol type="1">
<li>在B树中找结点(常在磁盘，找到后读入内存)</li>
<li>在结点内找关键字(常在内存)</li>
</ol>
<p>磁盘存取次数(高度): B树中的大部分操作所需的磁盘存取次数与B树的高度成正比<br />
若n≥1,则对任意一棵包含n个关键字、高度为h、阶数为m的B树：</p>
<ol type="1">
<li>若让每个结点中的关键字个数达到最多，则容纳同样多关键字的B树的高度达到最小
<ol type="1">
<li>关键字的个数满足 <span class="math inline">\(n\leq(m-1)(1+m+m^{2}+\cdots+m^{h-1})=m^{h}-1\)</span></li>
<li>h满足 <span class="math inline">\(h\geq\log_{m}(n+1)\)</span></li>
</ol></li>
<li>若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大
<ol type="1">
<li>对查找不成功的节点满足 <span class="math inline">\(n+1\geq2(\lceil m/2\rceil)^{h-1}\)</span></li>
<li>h满足 <span class="math inline">\(h\leq\log\lceil_{m/2}\rceil((n+1)/2)+1\)</span></li>
</ol></li>
</ol>
<p>插入:</p>
<ol type="1">
<li>查找算法找出插入该关键字的终端结点</li>
<li>每个非根结点的关键字个数都有范围 <span class="math inline">\([\lceil~m/2\rceil-1,~m-1]\)</span>
<ol type="1">
<li>若结点插入后的关键字个数小于m，可以直接插入</li>
<li>若结点插入后的关键字个数大于m-1，对结点进行分裂
<ol type="1">
<li>取一个新结点，在插入key后的原结点，从中间位置 <span class="math inline">\(\lceil m/2 \rceil\)</span> 将其中的关键字分为两部分,左半留在原结点，右半给新结点，中间位置结点插入原结点的父结点</li>
<li>若导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1</li>
</ol></li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020241112103600.png" /></p>
<p>删除:</p>
<ol type="1">
<li>被删关键字k不在终端结点中时,用k的前驱或者后继替代k，并在来源结点删除这个替代元素</li>
<li>被删关键字k在终端结点中时
<ol type="1">
<li>若k所在结点删除前的关键字个数 $ ≥m/2 $ ,则可直接删除该关键字</li>
<li>k所在结点删除前的关键字个数 $ =m/2 $, 该结点相邻节点关键字个数 $ ≥m/2 $,则借一个兄弟的结点过来(先父子换位，然后借一个兄弟给父结点)</li>
<li>k所在结点删除前的关键字个数 $ =m/2 $, 该结点相邻节点关键字个数 $ =m/2 $ ,将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020241112103610.png" /> <img src="/assets/resources/Pasted%20image%2020241112103620.png" /></p>
<p>若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点成为根;<br />
若双亲结点不是根结点，且关键字个数减少不满足要求，则向上递归直到满足要求</p>
<h4 id="b树-1">B+树</h4>
<p>B+树是应数据库所需而出现的一种B树的变形<br />
一棵m阶B+树应满足下列条件:</p>
<ol type="1">
<li>每个分支结点最多有m棵子树（孩子结点）</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有 <span class="math inline">\(\lceil m/2 \rceil\)</span> 棵子树</li>
<li>结点的子树个数与关键字个数相等</li>
<li>所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列,并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）</li>
<li>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针</li>
</ol>
<p>m阶B+树与m阶B树的主要差异:</p>
<ol type="1">
<li>在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有n+1棵子树</li>
<li>在B+树中，每个结点（非根内部结点）的关键字个数范围是[ <span class="math inline">\(\lceil m/2 \rceil\)</span> , m ] (非叶根节点是<code>[2,m]</code>) ;B树中，每个结点（非根内部结点）的关键字个数n的范围是 [ <span class="math inline">\(\lceil m/2 \rceil\)</span> -1 , m - 1 ] (根节点是<code>[1,m-1]</code>)</li>
<li>B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的</li>
<li>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有对应记录的存储地址。这样能使一个磁盘块存储更多的关键字，使得磁盘读/写次数更少，查找速度更快</li>
<li>在B+树中，用一个指针指向关键字最小的叶结点，将所有叶结点串成一个线性链表</li>
</ol>
<p>注: 非叶根结点指孩子不为空的根结点</p>
<p><img src="/assets/resources/Pasted%20image%2020241112103632.png" /></p>
<p>通常有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点;因此可以从最小关键字开始顺序查找或者从根结点开始多路查找<br />
B+树的查找、插入和删除操作和B树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止<br />
在B+树中，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径</p>
<h2 id="字符串匹配kmp算法">字符串匹配KMP算法</h2>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">参考链接</a></p>
<ol type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050103.png" /></p>
<p>首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位</p>
<ol start="2" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050104.png" /></p>
<p>因为B与A不匹配，搜索词再往后移</p>
<ol start="3" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050105.png" /></p>
<p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止</p>
<ol start="4" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050106.png" /></p>
<p>接着比较字符串和搜索词的下一个字符，还是相同</p>
<ol start="5" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" /></p>
<p>直到字符串有一个字符，与搜索词对应的字符不相同为止</p>
<ol start="6" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050108.png" /></p>
<p>最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样可行，但效率很差，因为要把"搜索位置"移到已经比较过的位置，重比一遍</p>
<ol start="7" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" /></p>
<p>当空格与D不匹配时，我们知道前面六个字符是"ABCDAB"。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率</p>
<ol start="8" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" /></p>
<p>怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》(Partial Match Table)</p>
<ol start="9" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050107.png" /></p>
<p>已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：</p>
<blockquote>
<p>　　移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>
</blockquote>
<p>因为 6 - 2 等于4，所以将搜索词向后移动4位</p>
<ol start="10" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050110.png" /></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2("AB")，对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位</p>
<ol start="11" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050111.png" /></p>
<p>因为空格与A不匹配，继续后移一位</p>
<ol start="12" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050112.png" /></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位</p>
<ol start="13" type="1">
<li></li>
</ol>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050113.png" /></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索(即找出全部匹配)，移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png" /> 前缀指除最后一个字符以外，字符串的所有头部子串；后缀指除第一个字符外，字符串的所有尾部子串;"部分匹配值"是"前缀"和"后缀"的最长的共有元素的长度<br />
如'ababa'的前缀{a,ab,aba,abab} ∩ 后缀{a,ba,aba,baba} = {a,aba},公共元素有两个，最长相等前后缀长度为3<br />
部分匹配值i号表项则是对<code>[0-i]</code>索引的字符串的部分匹配值</p>
<p>对前后缀匹配可以这样理解:</p>
<ol type="1">
<li>如果一位都不匹配，直接跳到下一个字符</li>
<li>匹配了n位时，相当于这n位子串是对的，而对这个子串来说的部分匹配值表示从后面数，有个子串和前缀这个匹配正确的子串一样，因此跳转到后缀子串肯定保留着n位匹配的性质。此时，移动位数 = 已匹配的字符数 - 对应的部分匹配值</li>
<li>当第n+1位匹配失败时，如果这时移动少于kmp规定的移动次数也能匹配上，那么就会与部分匹配表矛盾
<ol type="1">
<li>此时我们知道前n位匹配，第n+1位不匹配，若移动次数少于规定，那么肯定不会移到最大的公共前后缀上，也就是不会完全匹配上</li>
<li>使用反证法，假设移动次数少于规定还能完全匹配，那么字符串在最长公共后缀前的一个子串可以匹配前缀，这个匹配前缀的子串又成了新的最长公共后缀，与定义矛盾</li>
</ol></li>
</ol>
<p>将next数组右移一位，最左侧填-1，则匹配中每次右移位数=<code>j-1-next[j]</code>为了方便也可以+1<br />
求next数组可视为以下递归过程:</p>
<ol type="1">
<li>已知<code>next[j]=k</code>,即前j-1个元素中前k-1(next右移过一位且整体+1)个元素和后k-1个元素相同,j+1分为以下两种情况
<ol type="1">
<li>pk=pj,<code>next[j+1]=next[j]+1</code></li>
<li>pk!=pj,目前<code>p1~pj-1</code>部分已知有k-1长度的公共前后缀(因为next加过1)，但无法和pj匹配，因此在<code>1~k-1</code>找一个更小的公共前后缀(肯定要公共前后缀才能继续接上pj)，即<code>k=next[k]</code>，看这个更小的前公共子序列能否和pj组成更大的公共序列，如此重复
<ol type="1">
<li>也就是说，要求<code>next[j+1]</code>,当pj匹配不上pk时，查<code>next[j]</code>会得到j前面部分的公共前后缀长度<code>k-1</code>，下一个有可能匹配上的就是前面的公共前缀<code>[1~k-1]</code>后面第一个元素( <span class="math inline">\(p_{next[next[j]]}\)</span> 即 <span class="math inline">\(p_{next[k]}\)</span> )与pj,如果这次还匹配不上，就继续递归</li>
</ol></li>
</ol></li>
</ol>
<p>next的优化:由于每次右移<code>next[j]</code>,即下一个比较的一直是<code>p[next[j]]</code>，如果和<code>p[j]</code>相同，则这样的比较没有意义，因此对相等的<code>pj和p_next[j]</code>要不断将<code>next[j]修正为next[next[j]]</code>;更新后的数组命名为nextval</p>
<p>时间复杂度O是(m+n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string T, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//为了方便运算将next整体+!</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.<span class="built_in">at</span>(i) == T.<span class="built_in">at</span>(j)) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            next[i] = j; <span class="comment">//若 Pi=Pj，则 next [ j +1 ] =next [ j ] +1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">//否则令 j=next [ j ],循环继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(string S, string T, <span class="type">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.<span class="built_in">length</span>() &amp;&amp; j &lt;= T.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j -= <span class="number">0</span> || S.<span class="built_in">at</span>(i) == T.<span class="built_in">at</span>(j)) &#123;</span><br><span class="line">            ++i; ++j; <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">return</span> i - T.<span class="built_in">length</span>(); <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get__nextval</span><span class="params">(string T, <span class="type">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.<span class="built_in">at</span>(i) == T.<span class="built_in">at</span>(j)) &#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            <span class="keyword">if</span> (T.<span class="built_in">at</span>(i) != T.<span class="built_in">at</span>(j)) nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span> nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更好理解的版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextval</span><span class="params">(<span class="type">char</span>* p, <span class="type">int</span>* next)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, len = <span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[next[i]])</span><br><span class="line">      next[i] = next[next[i]];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      next[i] = next[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="哈希">哈希</h2>
<p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr<br />
散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。<br />
应满足以下条件：</p>
<ol type="1">
<li>定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围</li>
<li>计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突</li>
<li>应尽量简单</li>
</ol>
<p>常见的哈希函数：</p>
<ol type="1">
<li>直接定址法,直接取关键字的某个线性函数值为散列地址:<span class="math inline">\(H(\mathrm{key})=a\times \mathrm{key}+b\)</span></li>
<li>除留余数法,取不超过且尽可能接近表长m的质数p,<span class="math inline">\(H(\mathrm{key})=\mathrm{key}\ \% p\)</span></li>
<li>数字分析法,选取r进制的r个数码分布较为均匀的若干位作为散列地址</li>
<li>平方取中法，取关键字的平方值的中间几位作为散列地址</li>
</ol>
<h3 id="冲突处理">冲突处理</h3>
<ol type="1">
<li>开放寻址，<span class="math inline">\(H_{i}=(H(\mathrm{key})+d_{i})\%m\)</span> 其中 <span class="math inline">\(d_i\)</span> 为增量序列，删除需要特殊标记(<strong>i从1开始</strong>),再散列方法(第一次散列失败后开始使用)如下:
<ol type="1">
<li>线性探测法，di为<code>[1,m-1](循环，但下一次循环从0开始)</code>，遇到连续元素时效率较低</li>
<li>平方探测法,di为 <span class="math inline">\(0^2,1^2,-1^2,……,-k^2\)</span> ,其中<code>k&lt;=m/2</code>,散列表长度m必须是一个可以表示成<code>4k + 3</code>的素数，又称二次探测法;可以避免出现“堆积”问题，缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元</li>
<li>双散列法,<span class="math inline">\(d_{i}=\operatorname{Hash}_{2}(key)\)</span>,即 <span class="math inline">\(H_{i}=(H(\mathrm{key})+i\times\mathrm{Hash}_{2}(\mathrm{key}))\ \% \,m\)</span> (i从0开始)</li>
<li>伪随机序列法,di为伪随机序列</li>
</ol></li>
<li>链接(拉链)法,映射相同哈希值的元素形成链表<br />
哈希表的装载因子α=n/m，影响平均查找和删除时间，假设均匀散列，插入元素(需要一次查找失败)至多期望1/(1-α)次查找</li>
</ol>
<div class="note warning"><ul>
<li>查找的初始情况由散列函数可能的哈希值决定，例如mod的分母</li>
</ul>
</div>
<hr />
<h1 id="排序">排序</h1>
<p>408设计的排序基本是将给定序列规律化。输入是线性表<br />
<strong>稳定性</strong>：若输入两元素key相等，输出序列若两者相对顺序不变，则该算法稳定，否则不稳定</p>
<ul>
<li>内部排序，是指在排序期间元素全部存放在内存中的排序</li>
<li>外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序</li>
</ul>
<h2 id="插入排序">插入排序</h2>
<p>介绍略</p>
<ul>
<li>空间复杂度O(1)</li>
<li>平均时间复杂度O( <span class="math inline">\(n^2\)</span> )</li>
<li>稳定，且同时适用顺序和链式 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Insertsort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++) <span class="comment">//依次将A[2] ~A[n]插入前面己排序序列</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123; <span class="comment">//若A[i]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i]; <span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>;A[<span class="number">0</span>] &lt; A[j];--j)<span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j + <span class="number">1</span>] = A[j]; <span class="comment">//向后挪位</span></span><br><span class="line">            A[j + <span class="number">1</span>] = A[<span class="number">0</span>]; <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="折半插入">折半插入</h3>
<p>在已排序部分找插入点时使用二分查找，性能相对更好但复杂度不变，稳定但只适用于顺序表<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort_byhalf</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, low, high, mid; <span class="comment">//依次将A[2]~A[n]插入前面的巳排序序列</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123; <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];</span><br><span class="line">        low = <span class="number">1</span>;high = i - <span class="number">1</span>; <span class="comment">//设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; A[<span class="number">0</span>]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>;j &gt;= high + <span class="number">1</span>;--j)</span><br><span class="line">                A[j + <span class="number">1</span>] = A[j]; <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">            A[high + <span class="number">1</span>] = A[<span class="number">0</span>]; <span class="comment">//插入操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="希尔shell排序">希尔(shell)排序</h3>
<ol type="1">
<li>将表内元素以步长d1分为d1组，各组内部进行插入排序</li>
<li>取一个<code>d2&lt;d1</code>,重复上述操作，直到取到一个步长为1</li>
<li>进行插入排序</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//A[0]是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span></span><br><span class="line">    <span class="type">int</span> dk, i, j;</span><br><span class="line">    <span class="keyword">for</span> (dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk / <span class="number">2</span>) <span class="comment">//增量变化(无统一规定)</span></span><br><span class="line">        <span class="keyword">for</span> (i = dk + <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - dk]) &#123; <span class="comment">//需将A [i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>] = A[i]; <span class="comment">//暂存在 A[0]</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - dk;j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j];j -= dk)</span><br><span class="line">                    A[j + dk] = A[j]; <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j + dk] = A[<span class="number">0</span>]; <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>空间复杂度O(1),当n在某个特定范围时,希尔排序的时间复杂度约为O( <span class="math inline">\(N^{1.3}\)</span>),在最坏情况下希尔排序的时间复杂度为O( <span class="math inline">\(N^2\)</span> )</li>
<li>当相同关键字的记录被划分到不同的子表时，可能改变相对次序，因此不稳定</li>
<li>仅适用于顺序存储</li>
</ul>
<h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<p>正序或逆序开始，两两排序相邻两位，一趟可以确定一个最小(大)值,最多n-1趟就能排完</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j]) &#123; <span class="comment">//若为逆序</span></span><br><span class="line">                <span class="built_in">swap</span>(A[j - <span class="number">1</span>], A[j]); <span class="comment">//交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>空间复杂度O(1)</li>
<li>最坏情况下完全逆序，第i趟需要比n-i次，比较次数为 <span class="math inline">\(\sum_{i=1}^{n-1}(n-i)={\frac{n(n-1)}{2}}\)</span>,即时间复杂度O( $ N^2 $ )</li>
<li>稳定</li>
</ul>
<h3 id="快速排序">快速排序</h3>
<p>每次划分出以枢纽值为界的两个区间，并对左右分别递归<br />
枢纽值可以随机确定，或取三个元素中值来保证期望复杂度为nlogn，常用第一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123; <span class="comment">//一趟划分</span></span><br><span class="line">    ElemType pivot = A[low]; <span class="comment">//将当前表中第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123; <span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;</span><br><span class="line">        A[low] = A[high]; <span class="comment">//将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low;</span><br><span class="line">        A[high] = A[low]; <span class="comment">//将比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot; <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low; <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quicksort</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123; <span class="comment">//递归跳出的条件</span></span><br><span class="line">        <span class="comment">//Partition ()就是划分操作，将表A [low…high]划分为满足上述条件的两个子表</span></span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">Partition</span>(A, low, high); <span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">Quicksort</span>(A, low, pivotpos - <span class="number">1</span>); <span class="comment">//依次对两个子表进行递归排序</span></span><br><span class="line">        <span class="built_in">Quicksort</span>(A, pivotpos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>空间复杂度由于涉及栈，平均为logn，最坏O(N)</li>
<li>时间复杂度同理，但相对来说，最坏情况可能性较低，因此平均性能为内部排序算法最佳</li>
<li>划分时，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，因此不稳定</li>
</ul>
<h2 id="选择排序">选择排序</h2>
<h3 id="简单选择排序">简单选择排序</h3>
<p>每次选择第i小关键字和第i个元素交换，进行n-1次 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">//一共进行 n-1 趟</span></span><br><span class="line">        <span class="type">int</span> min = i; <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) <span class="comment">//在A[i~n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min]) min = j; <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) <span class="built_in">swap</span>(A[i], A[min]); <span class="comment">//swap()函数共移动元素 3 次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>空间复杂度O(1)</li>
<li>比较次数必为n(n-1)/2,时间复杂度固定O( <span class="math inline">\(N^2\)</span> )</li>
<li>在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同关键字元素的相对位置发生改变,因此不稳定</li>
</ul>
<h3 id="堆排序">堆排序</h3>
<p>极大(小)堆的概念略，以极小堆为例的基本操作：</p>
<ol type="1">
<li>向上维护：直到该节点大于等于父节点，不断将其与父节点交换</li>
<li>向下维护：直到该节点小于其两个子节点，与一个比它大的子节点交换</li>
<li>构建：对一个数组从中点开始到起点向下维护</li>
<li>删除顶部节点：顶部节点与数组最后节点交换，然后对交换后的顶部节点向下维护</li>
<li>插入节点：插入的节点到数组尾部，对其向上维护</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(ElemType A[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(ElemType A[], <span class="type">int</span> k, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数HeadAdjust将元素k为根的子树进行调整</span></span><br><span class="line">    A[<span class="number">0</span>] = A[k]; <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * k; i &lt; len; i *= <span class="number">2</span>) &#123;<span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len&amp;&amp; A[i] &lt; A[i + <span class="number">1</span>])</span><br><span class="line">            i++; <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>; <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = A[i]; <span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k = i; <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>]; <span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span>;i &gt; <span class="number">0</span>;i--) <span class="comment">//从 i = [n / 2]〜1, 反复调整堆</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(A, len); <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123; <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        <span class="built_in">Swap</span>(A, i, <span class="number">1</span>); <span class="comment">//输出堆顶元素(和堆底元素交换)</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, <span class="number">1</span>, i - <span class="number">1</span>); <span class="comment">//调整，把剩余的i-1个元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序就是不断移除首部节点的过程</p>
<ul>
<li>空间复杂度O(1)</li>
<li>建堆的时间复杂度为O(N)，每次移除top并维护平均需要logN复杂度，因此最好、最坏和平均情况下，堆排序的时间复杂度为O(Nlog2N)</li>
<li>进行筛选时，有可能把后面相同关键字的元素调整到前面，因此不稳定</li>
</ul>
<h2 id="归并排序">归并排序</h2>
<p>等长划分数组，然后排序，如此不断递归</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ElemType* B; <span class="comment">//辅助数组 B</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表A的两段A[low...mid]和A [mid+l...high]各自有序，将它们合并成一个有序表</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (k = low;k &lt;= high;k++)</span><br><span class="line">        B[k] = A[k]; <span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    <span class="keyword">for</span> (i - low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) <span class="comment">//比较B的左右两段中的元素</span></span><br><span class="line">            A[k] = B[i++]; <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) A[k++] = B[i++]; <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) A[k++] = B[j++]; <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>; <span class="comment">//从中间划分两个子序列</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A, low, mid); <span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A, mid + <span class="number">1</span>, high); <span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">        <span class="built_in">Merge</span>(A, low, mid, high); <span class="comment">//归并</span></span><br><span class="line">    &#125;<span class="comment">//if *</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就2路归并排序来说：</p>
<ul>
<li>空间复杂度O(N)</li>
<li>需要logn趟归并，每次O(N),因此时间复杂度是O(NlogN)</li>
<li>Merge()操作不会改变相同关键字记录的相对次序，因此稳定<br />
</li>
<li>比较次数的数量级与序列的初始状态无关</li>
</ul>
<p>对于N个元素进行k路归并排序时，排序的趟数m满足 <span class="math inline">\(k^{m}=N\)</span></p>
<h2 id="基数排序">基数排序</h2>
<p>根据r进制的每位数字，从高位或低位开始以此排序，最后就能得到有序数组<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">digit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num / exp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数排序(根据 nums 第 k 位排序) */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSortDigit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">digit</span>(nums[i], exp); <span class="comment">// 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d]++;                <span class="comment">// 统计数字 d 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        counter[i] += counter[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">digit</span>(nums[i], exp);</span><br><span class="line">        <span class="type">int</span> j = counter[d] - <span class="number">1</span>; <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i];       <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">        counter[d]--;           <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nums[i] = res[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基数排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    <span class="type">int</span> m = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 按照从低位到高位的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; exp &lt;= m; exp *= <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">        <span class="built_in">countingSortDigit</span>(nums, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>空间复杂度为O(r)</li>
<li>时间复杂度为O(d(N+r)),与序列的初始状态无关(d为趟数),与序列的初始状态无关</li>
<li>只要对相同位排序时使用的算法稳定，就稳定，除了常用的计数排序，也可以直接链接</li>
</ul>
<h2 id="内部排序小结">内部排序小结</h2>
<p><img src="/assets/resources/Pasted%20image%2020240511224819.png" /></p>
<ul>
<li>若n较小，可采用直接插入排序或简单选择排序</li>
<li>若初始状态基本有序，则选用直接插入或冒泡排序较好</li>
<li>若n较大,快速排序、堆排序或归并排序较好，需要稳定时只能使用归并</li>
<li>若n很大，记录的关键字位数较少且可以分解时，基数排序较好</li>
<li>比较排序的决策树是完全二叉树，因此高度h&gt;=lg(叶节点数),叶结点数是排列数量，即n!,因此下界是nlogn</li>
</ul>
<h2 id="外部排序">外部排序</h2>
<p>指待排序文件较大，内存无法完全存放，需存放在外存的文件的排序<br />
通常采用归并排序法，分为两步：</p>
<ol type="1">
<li>根据内存缓冲区大小，将外存上的文件分成若干长度为l的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串</li>
<li>对这些归并段进行逐趟归并，直至得到整个有序文件</li>
</ol>
<p><strong>外部排序的总时间=内部排序所需的时间+外存信息读写的时间+内部归并所需的时间</strong><br />
增加路数可以显著减少IO<br />
在k个元素中选择关键字最小的记录需要比较k-1次。每趟归并n个元素需要做(n-1)(k-1)次比较,则S趟归并总共需要的比较次数为：<br />
<span class="math inline">\(S(n-1)(k-1)=\left \lceil \log_{k}r\right \rceil (n-1)(k-1)=\left \lceil \log_{2}r \rceil(n-1)(k-1)/\lceil\log_{2}k\right\rceil\)</span><br />
为了使内部归并不受k的增大的影响，引入了败者树，k个叶结点分别存放k个归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的"失败者”，而让<strong>胜者往上继续进行比较</strong>，一直到根结点。<br />
若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数<br />
<img src="/assets/resources/Pasted%20image%2020240522232019.png" /></p>
<p>k个记录中选择最小关键字，最多需要 <span class="math inline">\(\lceil\log_2^{k}\rceil\)</span> 次比较(败者树深度为比较次数+1)。所以总的比较次数为：<br />
<span class="math inline">\(S(n-1)\left\lceil\log_{2}\!k\right\rceil=\left\lceil\log_{k}\!r\right\rceil(n-1)\left\lceil\log_{2}\!k\right\rceil=(n-1)\left\lceil\log_{2}r\right\rceil\)</span><br />
使用败者树时，内部归并的比较次数与k无关，只要内存空间允许，增大归并路数上将有效地减少归并树的高度，减少I/O次数，提高速度</p>
<h3 id="置换-选择排序">置换-选择排序</h3>
<p>用来产生更长的初始归并段，减少段个数r,从而减少归并趟数S<br />
设初始待排文件为FI初始归并段输出文件为FO,内存工作区为WA, FO和WA的初始状态为空，WA可容纳w个记录：</p>
<ol type="1">
<li>从FI输入w个记录到工作区WA</li>
<li>从WA中选出其中关键字取最小值的记录，记为MINIMAX记录(选择MINIMAX记录的过程用败者树实现)</li>
<li>将MINIMAX记录输出到FO中去</li>
<li>若FI不空，则从FI输入下一个记录到WA中</li>
<li>从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录(使用败者树)，作为新的MINIMAX记录</li>
<li>重复3.~5.直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到F0中去</li>
<li>重复2.~6.直至WA为空。由此得到全部初始归并段</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240522233010.png" /></p>
<h3 id="最佳归并树">最佳归并树</h3>
<p>将哈夫曼树的思想推广到m叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的I/O次数最少的最佳归并树<br />
若初始归并段不足以构成一棵严格k叉树时，需添加长度为0的"虚段"<br />
<img src="/assets/resources/Pasted%20image%2020240522234037.png" /><br />
设度为0的结点有n0个，度为k的结点有nk个，归并树的结点总数为n,则：</p>
<ul>
<li>n=nk + n0; n=k.nk + 1</li>
<li>对严格k叉树有 <span class="math inline">\(n_0=(k-1)n_k+1\)</span> ,由此可得 <span class="math inline">\(n_k=(n0-1)/(k- 1)\)</span><br />
</li>
<li>若 <span class="math inline">\((n_{0}-1)\%(k-1)==0\)</span>,则说明这n0个叶结点(初始归并段)正好可以构造k叉归并树。此时，内结点有nk个</li>
<li>若 <span class="math inline">\((n_{0}-1)\%(k-1)=u\ne0\)</span> ,则对于这n0个叶结点，其中有u个多余，不能包含在k叉归并树中,应在原有个nk内结点的基础上再增加1个内结点
<ul>
<li>添加的节点取代叶节点，加上k-u-1个空归并段可以构成一颗归并树</li>
</ul></li>
</ul>
<div class="note warning"><ul>
<li>每次冒泡排序后可以检查是否已经有序</li>
<li>对n个关键字进行快速排序，最多递归n次，最少logn次(二分)</li>
<li>取一大堆数据中的k个最大(最小)的元素时，优先采用堆排序</li>
<li>堆删除一个元素后，除了向下比较，还要比较左右两个子节点的大小关系，选择一个子树向下递归</li>
<li>将两个各有N个元素的有序表合并，最少比N次，最多2N-1次</li>
<li>带权连通图的任意一个环中所包含的边的权值均不相同时，其MST(最小(代价)生成树)唯一</li>
</ul>
</div>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 数据结构与算法</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/thinklive/26286/" rel="prev" title="研distance——操作系统部分">
                  <i class="fa fa-angle-left"></i> 研distance——操作系统部分
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/thinklive/14434/" rel="next" title="迪瑞克拉世界观轶事集">
                  迪瑞克拉世界观轶事集 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">thinklive</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">623k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">37:47</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 技术支持
  </div><script defer src="/lib/three.js"></script><script defer src="/lib/lines.js"></script><script defer src="/lib/waves.js"></script>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>


  <script src=""></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>


<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  <script src="/js/third-party/addtoany.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://thinklive1.github.io/thinklive/24155/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"thinklive1/blog_comments","issue_term":"pathname","theme":"photon-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script>
<script>
    const snowflakes = ["❄", "❄", "❆", "❅", "✥","❄", "❄", "❆", "❅", "✥","✻"];
    // 创建雪花
    function createSnowflake() {
        const snowflake = document.createElement("span");
        snowflake.classList.add("snowflake");
        const randomIndex = Math.floor(Math.random() * snowflakes.length);
        snowflake.textContent = snowflakes[randomIndex];
        
        // 起始位置
        /* 80%概率 生成在页面两侧 30% 的位置
        const probability = Math.random();
        let startPosition = Math.random() * 100;

        if (probability < 0.8) {
            startPosition = Math.random() < 0.5 ? Math.random() * 30 : (Math.random() * 30) + 70;
        }
        snowflake.style.left = `${startPosition}vw`;
        */
        snowflake.style.left = `${Math.random() * 100}vw`;
        snowflake.style.top = `-30px`;
        // 雪花大小与透明度
        const size = Math.random() * 18 + 10;
        snowflake.style.fontSize = `${size}px`;
        const opacity = Math.random() * 0.6 + (size > 18 ? 0.4 : 0);
        snowflake.style.setProperty("--opacity", opacity);
        // 动画持续时间
        const fallDuration = Math.random() * 10 + 10;
        // 旋转持续时间
        const rotateDuration = Math.random() * 3 + 1;

        snowflake.style.animationDuration = `${fallDuration}s, ${fallDuration}s`; // 向 CSS 添加淡出动画的持续时间
        // 横向幅度
        const translateX = (Math.random() * 500 - 200);
        snowflake.style.setProperty("--translateX", `${translateX}px`);
        // 纵向幅度
        snowflake.style.setProperty("--translateY", `${window.innerHeight}px`);

        document.body.appendChild(snowflake);
        // 移除雪花
        setTimeout(() => {
            snowflake.remove();
        }, fallDuration * 1000);
    }
    
    function snowfallAnimation() {
        // 载入时若边栏是隐藏状态则不加载雪花
        const sidebarnav = document.querySelector('.sidebar');
        const sidebarnavdisplay = window.getComputedStyle(sidebarnav).getPropertyValue('display'); 
        if (sidebarnavdisplay !== 'none') {
            createSnowflake();
        }
        setTimeout(snowfallAnimation, 500); // 生成速度，毫秒
    }
    snowfallAnimation();
function toggleMode() {
    console.log("change color!");
    const root1 = document.documentElement;

    // 检查当前 color-scheme
    const isLightMode = getComputedStyle(root1).getPropertyValue('--content-bg-color').trim() === '#fff';

    if (isLightMode) {
        // 切换到暗模式
        const images = document.querySelectorAll('img'); // 选择所有<img>标签
        images.forEach(img => {
            img.style.filter = 'brightness(50%)'; // 设置亮度为50%
        });

        root1.style.setProperty('--content-bg-color', '#333');
        root1.style.setProperty('--link-color', '#aaa');
        root1.style.setProperty('--text-color', '#fff');
        root1.style.setProperty('--highlight-background', '#444');
        root1.style.setProperty('--highlight-foreground', '#bbb');
        root1.style.setProperty('--btn-default-bg', '#777');
        root1.style.setProperty('--menu-item-bg-color', '#777');
        root1.style.setProperty('--table-row-odd-bg-color', '#444');
        root1.style.setProperty('--note-warning-bg-color', '#555');
        root1.style.setProperty('--note-bg-color', '#555');
        root1.style.setProperty('--note-info-bg-color', '#555');
        root1.style.setProperty('--highlight-gutter-foreground', '#98d9ffff');
        root1.style.setProperty('', '#777');
        root1.style.transition = 'all 0.5s ease';

    }

    else {
        const images = document.querySelectorAll('img'); // 选择所有<img>标签
        images.forEach(img => {
            img.style.filter = 'brightness(100%)'; // 设置亮度为50%
        });
        root1.style.setProperty('--content-bg-color', '#fff');
        root1.style.setProperty('--text-color', '#555');
        root1.style.setProperty('--highlight-background', '#eaeef3');
        root1.style.setProperty('--highlight-foreground', '#00193a');
        root1.style.setProperty('--btn-default-bg', '#fff');
        root1.style.setProperty('--menu-item-bg-color', '#f5f5f5');
        root1.style.setProperty('--note-warning-bg-color', '#fdf8ea');
        root1.style.setProperty('--note-bg-color', '#f9f9f9');
        root1.style.setProperty('--note-info-bg-color', '#eef7fa');
        root1.style.setProperty('--table-row-odd-bg-color', '#f9f9f9');
        root1.style.setProperty('--highlight-gutter-foreground', '#172e4c');
        root1.style.transition = 'all 0.5s ease';
    }
}

function DarkTrigger() {
    console.log('dark!!')
    let isDarkMode = getComputedStyle(document.documentElement).getPropertyValue('--content-bg-color').trim() === '#000';
    console.log(isDarkMode)
    if (isDarkMode) {
        // 切换到暗模式
        const warningNotes = document.querySelectorAll('.post-body .note.warning');
        // 修改背景颜色
        warningNotes.forEach(note => {
        note.style.background = '#666';
        });

        const infoNotes = document.querySelectorAll('.post-body .note.info');
        // 修改背景颜色
        infoNotes.forEach(note => {
        note.style.background = '#666';
        });
    }
}


</script>

 <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<button style="background: #868686;
  width: 3rem;
  height: 3rem;
  position: fixed;
  border-radius: 50%;
  border: none;
  right: unset;
  bottom: 2rem;
  left: 2rem;
  cursor: pointer;
  transition: all 0.5s ease;
  display: flex;
  justify-content: center;
  align-items: center;" class="darkmode-toggle" role="checkbox" onclick="toggleMode()">🌓</button>

  <video autoplay loop muted playsinline style="position:fixed;top:50%;opacity: 0.8;left:50%;min-width:100%;min-height:100%;transform:translateX(-50%)translateY(-50%);z-index:-2;">
  <source src="/images/red.mp4" type="video/mp4">
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
