<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinklive1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#66CCFF","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="概论 历史： 电子管-&gt;晶体管-&gt;集成电路 比较成熟的集成电路出现于1972 冯诺依曼机：  采用“存储程序”的工作方式。程序和原始数据送入主存后才能执行，计算机自动逐条执行指令，直至执行结束 计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。  存储器分为主存和辅存，对应现在的内存和硬盘，由存储单元组成，存储单元可存储一串二进制代码，称这串代码为存储字，称这串代">
<meta property="og:type" content="article">
<meta property="og:title" content="研distance——计算机组成部分">
<meta property="og:url" content="https://thinklive1.github.io/thinklive/47457/index.html">
<meta property="og:site_name" content="thinklive">
<meta property="og:description" content="概论 历史： 电子管-&gt;晶体管-&gt;集成电路 比较成熟的集成电路出现于1972 冯诺依曼机：  采用“存储程序”的工作方式。程序和原始数据送入主存后才能执行，计算机自动逐条执行指令，直至执行结束 计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。  存储器分为主存和辅存，对应现在的内存和硬盘，由存储单元组成，存储单元可存储一串二进制代码，称这串代码为存储字，称这串代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240110161646.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240110162758.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240110163330.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240110164350.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240110165934.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240113163128.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240113172028.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240114164836.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240114164843.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240114172944.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240114230633.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240114231045.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115000800.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115195328.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115195554.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115200514.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115201121.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115214143.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115215314.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115215614.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115220452.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240116102453.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240116102504.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240116102537.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240116102700.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240115222444.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240116204934.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240116215743.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240116215753.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240116221404.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240117165807.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240117214529.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240117214601.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240117215030.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240117215509.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240117221818.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240117222135.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240118225544.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240119160205.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240119160435.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240119160847.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240119161006.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240119161132.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240119185327.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240122110823.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240122112021.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240122113344.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240122133449.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240122134549.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240122135305.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240122134749.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240123125249.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240123125834.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240123130334.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240123130559.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240123130618.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240123145932.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240124111231.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240125183517.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240125183707.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240125183803.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240125184233.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240125184328.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240125184543.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240125184736.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240125184742.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240128210356.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240128214452.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240128220028.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240130232317.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240130232819.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240130233021.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240130233135.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240131152608.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240201115435.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240201153814.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240201155051.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240202151001.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240202151110.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240202151345.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240202153841.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240202153846.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240202150944.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240203173011.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240203173806.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240203234024.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240205131527.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240205131918.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240205142318.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240205142507.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240205152611.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240205152802.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240205222012.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240205222956.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206103615.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206124440.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206154237.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206155937.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206161017.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206161514.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206164528.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206161445.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240206161017.png">
<meta property="article:published_time" content="2023-11-29T13:12:21.000Z">
<meta property="article:modified_time" content="2025-09-09T07:53:29.844Z">
<meta property="article:author" content="thinklive">
<meta property="article:tag" content="研distance">
<meta property="article:tag" content="计组">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thinklive1.github.io/assets/resources/Pasted%20image%2020240110161646.png">


<link rel="canonical" href="https://thinklive1.github.io/thinklive/47457/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://thinklive1.github.io/thinklive/47457/","path":"thinklive/47457/","title":"研distance——计算机组成部分"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>研distance——计算机组成部分 | thinklive</title>
  







<script type="text/javascript" async src="/js/fairyDustCursor.js"></script>
<script type="text/javascript" async src="/js/tab-title.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script src="/js/tab-title.js"></script>

<!--pjax：防止跳转页面音乐暂停-->
<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script>
const options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: false, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}

const darkmode = new Darkmode(options);
</script>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="thinklive" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>


  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">thinklive</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">dirichlet library</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索 | search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页-|-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页 | home</a></li><li class="menu-item menu-item-标签-|-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags</a></li><li class="menu-item menu-item-分类-|-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories</a></li><li class="menu-item menu-item-归档-|-archive"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archive</a></li><li class="menu-item menu-item-相册-|-photo"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册 | photo</a></li><li class="menu-item menu-item-留言-|-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言 | guestbook</a></li><li class="menu-item menu-item-感谢-|-thank"><a href="/thanks/" rel="section"><i class="fa custom thanks fa-fw"></i>感谢 | thank</a></li><li class="menu-item menu-item-游戏-|-game"><a href="/game/bad1.html" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏 | game</a></li><li class="menu-item menu-item-神龛-|-shrine"><a href="/cyberblog/" rel="section"><i class="fa fa-microchip fa-fw"></i>神龛 | shrine</a></li><li class="menu-item menu-item-资源地图-|-resourcemap"><a href="/webstack/" rel="section"><i class="fa fa-list fa-fw"></i>资源地图 | resourcemap</a></li><li class="menu-item menu-item-思维导图-|-mindmap"><a href="/mindmap/index.html" rel="section"><i class="fa fa-map fa-fw"></i>思维导图 | mindmap</a></li><li class="menu-item menu-item-网站地图-|-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>网站地图 | sitemap</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">


<!--网易云音乐插件-->
<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->
<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--网易云playlist外链地址-->   
<meting-js
    server="netease"
    type="playlist" 
    id="2762741085"
    mini="false"
    fixed="false"
    list-folded="true"
    autoplay="false"
    volume="0.2"
    theme="#4c4c4c"
    order="random"
    loop="all"
    preload="auto"
    mutex="true">
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">概论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.</span> <span class="nav-text">性能指标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE"><span class="nav-number">2.</span> <span class="nav-text">数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">数制与编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E5%80%BC%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.</span> <span class="nav-text">定点数值的运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E9%83%A8%E4%BB%B6"><span class="nav-number">2.2.1.</span> <span class="nav-text">基本部件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.2.</span> <span class="nav-text">移位运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">定点数的数学运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E5%87%8F"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">加减</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%98%E9%99%A4"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">乘除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.2.4.</span> <span class="nav-text">数据的存储与表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="nav-number">2.3.</span> <span class="nav-text">浮点数的表示和运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="nav-number">2.3.1.</span> <span class="nav-text">浮点数的加减运算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text">主存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8Ecpu%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.3.</span> <span class="nav-text">主存储器与CPU的连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">外部存储器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.5.</span> <span class="nav-text">高速缓冲存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.1.</span> <span class="nav-text">Cache工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">3.5.2.</span> <span class="nav-text">地址映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%9D%97%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.3.</span> <span class="nav-text">主存块的替换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-number">3.5.4.</span> <span class="nav-text">写策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">3.6.</span> <span class="nav-text">虚拟存储器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.1.1.</span> <span class="nav-text">基本格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">操作类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">指令寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">4.2.1.</span> <span class="nav-text">数据寻址的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96"><span class="nav-number">4.3.</span> <span class="nav-text">汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4"><span class="nav-number">4.3.1.</span> <span class="nav-text">常见指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">4.3.2.</span> <span class="nav-text">控制指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">过程调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8C%87%E4%BB%A4"><span class="nav-number">4.3.3.</span> <span class="nav-text">选择指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4"><span class="nav-number">4.3.4.</span> <span class="nav-text">循环指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.4.</span> <span class="nav-text">指令系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cpu"><span class="nav-number">5.</span> <span class="nav-text">cpu</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">基本功能结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8"><span class="nav-number">5.1.1.</span> <span class="nav-text">运算器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">5.1.2.</span> <span class="nav-text">控制器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">指令执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="nav-number">5.3.</span> <span class="nav-text">数据通路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8-1"><span class="nav-number">5.4.</span> <span class="nav-text">控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">5.4.1.</span> <span class="nav-text">硬布线控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">5.4.2.</span> <span class="nav-text">微程序控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">5.5.</span> <span class="nav-text">异常和中断机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">5.6.</span> <span class="nav-text">指令流水线</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.6.1.</span> <span class="nav-text">基本实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">5.6.2.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E9%99%A9"><span class="nav-number">5.6.3.</span> <span class="nav-text">冒险</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-1"><span class="nav-number">5.6.4.</span> <span class="nav-text">性能指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="nav-number">5.6.5.</span> <span class="nav-text">高级流水线技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">5.7.</span> <span class="nav-text">多处理器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-number">6.</span> <span class="nav-text">总线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="nav-number">6.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6"><span class="nav-number">6.2.</span> <span class="nav-text">总线事务与定时</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#io%E8%AE%BE%E5%A4%87"><span class="nav-number">7.</span> <span class="nav-text">IO设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.1.</span> <span class="nav-text">IO接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">IO方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.1.</span> <span class="nav-text">程序查询方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.2.</span> <span class="nav-text">程序中断方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dma"><span class="nav-number">7.2.3.</span> <span class="nav-text">DMA</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-number">8.</span> <span class="nav-text">杂项</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="thinklive"
      src="/images/thive.png">
  <p class="site-author-name" itemprop="name">thinklive</p>
  <div class="site-description" itemprop="description">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinklive1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinklive1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/t469631989@gmail.com" title="E-Mail → t469631989@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/38099250?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;38099250?spm_id_from&#x3D;333.1007.0.0" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/thinkliving" title="steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;thinkliving" rel="noopener me" target="_blank"><i class="fa custom steam fa-fw"></i>steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

<div style="Text-align:center;width:100%"><div style="margin:0 auto"><canvas id="canvas" style="width:60%" height="100" width="700">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){function t(t,e){for(var a=0;a<l[e].length;a++)for(var n=0;n<l[e][a].length;n++)1==l[e][a][n]&&(h.beginPath(),h.arc(14*(g+2)*t+2*n*(g+1)+(g+1),2*a*(g+1)+(g+1),g,0,2*Math.PI),h.closePath(),h.fill())}function e(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a=[];a.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var r=c.length-1;r>=0;r--)a[r]!==c[r]&&t.push(r+"_"+(Number(c[r])+1)%10);for(var r=0;r<t.length;r++)n.apply(this,t[r].split("_"));c=a.concat()}function a(){for(var t=0;t<d.length;t++)d[t].stepY+=d[t].disY,d[t].x+=d[t].stepX,d[t].y+=d[t].stepY,(d[t].x>i+g||d[t].y>f+g)&&(d.splice(t,1),t--)}function n(t,e){for(var a=[1,2,3],n=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],r=0;r<l[e].length;r++)for(var o=0;o<l[e][r].length;o++)if(1==l[e][r][o]){var h={x:14*(g+2)*t+2*o*(g+1)+(g+1),y:2*r*(g+1)+(g+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*a[Math.floor(Math.random()*a.length)],color:n[Math.floor(Math.random()*n.length)],disY:1};d.push(h)}}function r(){o.height=100;for(var e=0;e<c.length;e++)t(e,c[e]);for(var e=0;e<d.length;e++)h.beginPath(),h.arc(d[e].x,d[e].y,g,0,2*Math.PI),h.fillStyle=d[e].color,h.closePath(),h.fill()}var l=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],o=document.getElementById("canvas");if(o.getContext){var h=o.getContext("2d"),f=100,i=700;o.height=f,o.width=i,h.fillStyle="#f00",h.fillRect(10,10,50,50);var c=[],d=[],g=o.height/20-1;!function(){var t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date);c.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6])}(),clearInterval(v);var v=setInterval(function(){e(),a(),r()},50)}}()</script></div>
<img class= 'logo' src="/images/thinklive_cyber.png"; z-index: '0'; style="max-width: 100%; width: auto; height: auto;background-color: --content-bg-color;">

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thinklive1.github.io/thinklive/47457/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/thive.png">
      <meta itemprop="name" content="thinklive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="thinklive">
      <meta itemprop="description" content="起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="研distance——计算机组成部分 | thinklive">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          研distance——计算机组成部分
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-29 21:12:21" itemprop="dateCreated datePublished" datetime="2023-11-29T21:12:21+08:00">2023-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-09 15:53:29" itemprop="dateModified" datetime="2025-09-09T15:53:29+08:00">2025-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">考研笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/%E7%A0%94distance/" itemprop="url" rel="index"><span itemprop="name">研distance</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>40k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:26</span>
    </span>
</div>

        
        </div>
      </header>
   

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="概论">概论</h1>
<p>历史： 电子管-&gt;晶体管-&gt;集成电路 比较成熟的集成电路出现于1972</p>
<p>冯诺依曼机：</p>
<ol type="1">
<li>采用“存储程序”的工作方式。程序和原始数据送入主存后才能执行，计算机自动逐条执行指令，直至执行结束</li>
<li>计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。
<ul>
<li>存储器分为主存和辅存，对应现在的内存和硬盘，由存储单元组成，存储单元可存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长</li>
<li>主存由地址寄存器MAR和数据寄存器MDR以及时序控制逻辑组成，MAR用于寻址，其位数对应着存储单元的个数，存放访问地址，需要译码才能定位到存储单元，MDR的位数和存储字长相等，暂存要从存储器读写的信息，时序控制逻辑产生操作的时序信号</li>
<li>运算器的核心是算术逻辑单元ALU，运算器包含若干通用寄存器，用于暂存操作数和中间结果，程序状态寄存器(PSW),也称标志寄存器用于存放运算中的一些状态信息</li>
<li>控制器由程序计数器(PC)、指令寄存器(IR)和控制单元(CU)组成
<ul>
<li>PC用来存放当前欲执行指令的地址，可以自增1来寻址到下一个指令</li>
<li>IR用来存放当前的指令，其内容来自主存的MDR，指令中操作码送到CU，地址码送至MAR</li>
<li>CU通过操作码产生需要的命令序列</li>
</ul></li>
</ul></li>
<li>指令和数据以同等地位存储在存储器中，形式上没有区别，CPU用<strong>指令周期的不同阶段</strong>区分他们</li>
<li>指令和数据均用二进制代码表示。指令由操作码和地址码组成，操作码指出操作的类型,地址码指出操作数的地址</li>
</ol>
<span id="more"></span>
<figure>
<img src="/assets/resources/Pasted%20image%2020240110161646.png" alt="" /><figcaption>主存的组成</figcaption>
</figure>
<p>运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器共同构成主机。其他设备 称为外部设备</p>
<p><img src="/assets/resources/Pasted%20image%2020240110162758.png" /></p>
<p>软件按其功能分类，可分为系统软件和应用软件。<br />
语言可分为：</p>
<ul>
<li>机器语言，二进制代码语言，计算机可以直接识别和执行的语言</li>
<li>汇编语言，用英文单词或其缩写代替二进制的指令代码，必须被汇编程序翻译为机器语言后，才可以执行</li>
<li>高级语言，现在使用的绝大部分编程语言，最后会被编译成汇编或者机器语言执行</li>
</ul>
<p>翻译程序可分为：</p>
<ul>
<li>汇编程序(汇编器)。将汇编语言程序翻译成机器语言程序。</li>
<li>解释程序(解释器)。将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行。</li>
<li>编译程序(编译器)。将高级语言程序翻译成汇编语言或机器语言程序</li>
</ul>
<p>对某一功能来说，既可以由硬件实现，又可以由软件实现，从用户的角度来看，它们在功能上是等价的。这一等价性被称为软、硬件逻辑功能的等价性。例如浮点数运算</p>
<p><img src="/assets/resources/Pasted%20image%2020240110163330.png" /> 没有配备软件的纯硬件系统称为裸机。第3层〜第5层称为虚拟机，上层依赖于下层<br />
软件和硬件之间的界面就是指令集体系结构(ISA), ISA定义了一台计算机可以执行的所有指令的集合，ISA是软件能感知到的部分，也称软件可见部分</p>
<h2 id="工作原理">工作原理</h2>
<ol type="1">
<li>根据PC取指令</li>
<li>指令译码，INC PC</li>
<li>取操作数，执行</li>
<li>送结果</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240110164350.png" /></p>
<ol type="1">
<li>预处理，例如头文件插入程序文件</li>
<li>编译阶段产生一个汇编程序，每条语句都对应一个机器语言指令</li>
<li>汇编阶段，翻译成机器语言指令(二进制)</li>
<li>将可重定位文件与标准库函数合并成可执行文件</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240110165934.png" /></p>
<p>执行过程(以取数指令为例)</p>
<ol type="1">
<li>取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR<br />
根据PC取指令到IR。将PC的内容送MAR, MAR中的内容直接送地址线 ，同时控制器将读信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR从数据线接收指令信息，并传送到IR中。<br />
</li>
<li>分析指令：OP(IR)-&gt;CU<br />
指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR中是取数指令，因此读控制信号被送到总线的控制线上。<br />
</li>
<li>执行指令：Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC<br />
取数操作：将IR中指令的地址码送MAR, MAR中的内容送地址线，同时控制器将读信号送读/写信号线，从主存中读出操作数，并通过数据线送至MDR,再传送到ACC中。每取完一条指令，还须为取下条指令做准备，计算下条指令的地址，即(PC)+1 -&gt; PC</li>
</ol>
<div class="note warning"><ul>
<li>冯•诺依曼机基本工作方式是控制流驱动方式</li>
<li>IR存放当前执行的指令代码，PC存放下一条指令的地址</li>
<li>地址译码器是主存的构成部分，不属于CPU(但一般现代cpu也集成)</li>
<li>速度上：寄存器＞Cache &gt; 内存</li>
<li>n位计算机表明计算机字长，与地址位数无关</li>
<li>由高级语言转化为汇编语言的过程称为编译，把汇编语言源程序翻译成机器语言程序的过程称为汇编</li>
<li>相联存储器既可以按地址寻址又可以按内容(通常是某些字段)寻址</li>
<li>CPU可以根据指令周期的不同阶段来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的是数据</li>
</ul>
</div>
<h2 id="性能指标">性能指标</h2>
<ul>
<li><strong>字长</strong>:计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数,一般等于寄存器大小，且是字节的整数倍<br />
</li>
<li><strong>数据通路带宽</strong>：数据总线一次能并行传送信息的位数(不是cpu内部的数据总线)<br />
</li>
<li><strong>主存容量</strong>：主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数x字长(如<code>512K*16位</code>)来表示存储容量。其中，MAR的位数反映了存储单元的个数，MDR的位数反映了存储单元的字长<br />
</li>
<li><strong>吞吐量</strong>：指系统在单位时间内处理请求的数量，主要取决于主存的存取周期<br />
</li>
<li><strong>响应时间</strong>：从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括CPU时间与等待时间。操作系统有相同概念<br />
</li>
<li><strong>CPU时钟周期</strong>：通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位<br />
</li>
<li><strong>主频(CPU时钟频率)</strong>：机器内部主时钟的频率<br />
</li>
<li><strong>CPI (Cycle Per Instruction)</strong>：执行一条指令所需的时钟周期数，对一个程序来说，指的是平均值<br />
</li>
<li><strong>CPU执行时间</strong>：运行一个程序所花费的时间，即<span class="math inline">\(cpu时间周期数/主频=(指令条数*CPI)/主频\)</span><br />
</li>
<li><strong>MIPS (Million Instructions Per Second)</strong>：即每秒执行多少百万条指令:</li>
</ul>
<p><span class="math display">\[ MIPS =指令条数/(执行时间*10^6)=主频/(CPI*10^6) \]</span></p>
<ul>
<li>1ms 1毫秒=0.001秒=10-3秒</li>
<li>1μs 1微秒=0.000001=10-6秒</li>
<li>1ns 1纳秒=0.0000000001秒=10-9秒</li>
<li>1ps 1皮秒=0.0000000000001秒=10-12秒</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240113163128.png" /></p>
<ul>
<li><strong>基准程序(Benchmarks)</strong>:是专门用来进行性能评价的一组程序,对于不同的应用场合，应该选择不同的基准程序。<br />
</li>
<li><strong>固件</strong>:将程序固化在ROM中组成的部件称为固件</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240113172028.png" /></p>
<div class="note warning"><ul>
<li>存储字长等于MDR的位数，数据字长是数据总线一次能并行传送信息的位数，机器字长是CPU内部用于整数运算的数据通路的宽度，指令字长是一个指令字中包含的二进制代码的位数，且指令字长一般是存储字长整数倍</li>
<li>指令集更类似一个接口集合，或者说结构，相同指令不代表实现相同，接口是体系结构，实现则是计组</li>
<li>cpu的指令寄存器对用户是完全透明的</li>
<li>计算机“运算速度”指标的含义是每秒能执行多少条指令</li>
<li>cpu速度提高是通过提高频率实现的，也就是增加50%的cpu时间，相当于原来的时间除以1.5</li>
<li>机器字长一定等于CPU内部用于整数运算的运算器位数和通用寄存器宽度</li>
<li>全面代表计算机性能的是实际软件的运行情况</li>
<li>向后兼容是指时间上向后兼容，即新机器兼容使用以前机器的指令系统</li>
</ul>
</div>
<h1 id="数据">数据</h1>
<h2 id="数制与编码">数制与编码</h2>
<p>计算机使用二进制的原因：非1即0，在物理上容易区分，可以方便地转换成逻辑值，运算规则简单<br />
r进制数可以表示为：</p>
<p><span class="math display">\[
K_{n}r^{n}+K_{n-1}r^{n-1}+\cdots+K_{0}r^{0}+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_{i}r^{i}
\]</span></p>
<p>转换时高位补0，有倍数关系的进制可以若干位转换对应一位，否则一般使用基数乘除法<br />
对小数的进制转换，只需要分别对小数点前后的数字部分进行转换，然后拼接起来 ，但因为小数是离散的，所以不一定可以完全转化<br />
<img src="/assets/resources/Pasted%20image%2020240114164836.png" /> <img src="/assets/resources/Pasted%20image%2020240114164843.png" /> 符号“数字化”的数称为机器数，例如0表正， 1表负<br />
十位数字的4位二进制码叫BCD码</p>
<p>根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示,通常用定点补码整数表示整数，用定点原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分， <img src="/assets/resources/Pasted%20image%2020240114172944.png" /></p>
<p>定点数编码表示法主要有4种：原码、补码、反码和移码</p>
<ol type="1">
<li>原码 首位是符号位，其他位与数值相等，不足字长的补零，小数尾部补零，整数头部补零，字长n+1时，小数表示范围是：</li>
</ol>
<p><span class="math inline">\({\mathrm{-}}(1-2^{-n})\leqslant x\leqslant1-2^{-n}\)</span><br />
整数范围是：</p>
<p><span class="math inline">\(-(2^{n}-1)\leqslant x\leqslant2^{n}-1\)</span><br />
原码简单直观，但0的表示不唯一，且运算较复杂</p>
<ol start="2" type="1">
<li>补码 正数的补码是他自己<br />
负小数的补码是其与+2的和，小数表示范围为：</li>
</ol>
<p><span class="math inline">\(-1\leqslant x\leqslant1-2^{-n}\)</span><br />
若字长是n+1负整数的补码相当于其与 <span class="math inline">\(2^{(n+1)}\)</span> 的和，表示范围是</p>
<p><span class="math inline">\(-2^{n}\leqslant x\leqslant2^{n}-1\)</span><br />
优点：零的补码唯一，相比原码可以多表示一个-2^n,补码运算规则比较简单，且符号位可以和数值位一起参加运算</p>
<ul>
<li>变形补码，又称模4补码，双符号位00表示正，11表示负，类似补码，区别只是负数加的是4</li>
<li>真值转换为补码：正数与原码一直，负数符号位取1，其他位由原码取反并加一得到</li>
<li>补码转换成真值：正数与原码一致，负数符号取负，其他位取反并加一</li>
</ul>
<ol start="3" type="1">
<li>反码，正数与原码一致，负数符号位不变，其他取反</li>
<li>移码，在真值上加上一个常数(偏置值)，通常这个常数取2^n
<ol type="1">
<li>移码中零的表示唯一,都是2^n</li>
<li>一个真值的移码和补码仅差一个符号位，符号位取反就能相互转化</li>
<li>移码全0时，对应真值的最小值<span class="math inline">\(-2^n\)</span>,移码全1时，对应真值的最大值<span class="math inline">\(2^n-1\)</span>。</li>
<li>移码可以反映数据原有的大小顺序</li>
</ol></li>
</ol>
<p><strong>无符号整数</strong>默认为正数，由于不需要符号位，表示的最大数更大 <span class="math inline">\(2^{n+1}-1\)</span></p>
<div class="note warning"><ul>
<li>二进制小数可以用十进制表示，反过来不行，因为相对于十进制，二进制小数是离散的</li>
<li>x补所有位取反加一就会得到(-x)补</li>
<li>N位的二进制小数可以表示的数的个数为 <span class="math inline">\(2^n\)</span> 而十进制小数能表示的数的个数为 <span class="math inline">\(10^n\)</span> ,意味着占比 <span class="math inline">\({0.2}^n\)</span> 的十进制小数可以用二进制精确表示</li>
<li>对负数的补码来说，数值部分越大，真值的绝对值越小，真值越大</li>
<li>H结尾一般表示16进制数</li>
<li>移码与补码表示的最小值绝对值比最大值绝对值大一，真值取反可能溢出</li>
<li>补码的符号位可以和数值部分一起参加运算</li>
</ul>
</div>
<h2 id="定点数值的运算">定点数值的运算</h2>
<h3 id="基本部件">基本部件</h3>
<ol type="1">
<li><p>一位全加器FA <img src="/assets/resources/Pasted%20image%2020240114230633.png" /> 和表达式：<span class="math inline">\(S_{i}=A_{i}\oplus B_{i}\oplus C_{i-1}\)</span><br />
进位表达式：<span class="math inline">\(C_{i}=A_{i}B_{i}+(A_{i}\oplus B_{i})C_{i-1}\)</span></p></li>
<li><p>串行进位加法器 把n个全加器相连可得到几位加法器，称为串行进位加法器,由于位数有限，高位自动丢失，所以实际是模2^n的加法运算<br />
<img src="/assets/resources/Pasted%20image%2020240114231045.png" /><br />
串行运算的效率会依赖于位数</p></li>
<li><p>并行进位加法器 <span class="math display">\[G_{i}=A_{i}B_{i},\;\;P_{i}=A_{i}\oplus B_{i},\]</span><br />
<span class="math display">\[C_{i}=G_{i}+P_{i}C_{i-1}\;\;\]</span></p></li>
</ol>
<p>称为<span class="math inline">\(A_iB_i\)</span>为进位产生函数，称<span class="math inline">\(A_{i}\oplus B_{i}\)</span>为进位传递函数<br />
G仅与Ai,Bi及最低进位C0有关，相互间的进位没有依赖关系</p>

$$\begin{array}{l}{{C_{1}=G_{1}+P_{1}C_{0}}}\\ {{C_{2}=G_{2}+P_{2}G_{1}+P_{2}P_{1}C_{0}}}\\ {{C_{3}=G_{3}+P_{3}C_{2}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}C_{0}}}\\ {{C_{4}=G_{4}+P_{4}G_{3}+P_{4}P_{3}G_{2}+P_{4}P_{3}P_{2}G_{1}+P_{4}P_{3}P_{2}P_{1}C_{0}}}\\ \end{array}$$


<p><img src="/assets/resources/Pasted%20image%2020240115000800.png" /><br />
随着加法器位数的增加，Ci的逻辑表达式会变得越来越长，这会使电路结构变得很复杂,可以分组，组内先行进位，组间串行进位，甚至组内组间都并行，通常采用两级或多级先行进位加法器。</p>
<ol type="1">
<li><p>带标志加法器 <img src="/assets/resources/Pasted%20image%2020240115195328.png" /></p></li>
<li><p>ALU(算术逻辑单元) 能进行多种算术运算和逻辑运算，核心是带标志加法器，同时也能执行“与” “或”“非”等逻辑运算<br />
其中A和B是两个n位操作数输入端，Cin是进位输入端，ALUop是操作控制端，用来决定ALU所执行的处理功能<br />
<img src="/assets/resources/Pasted%20image%2020240115195554.png" /></p></li>
</ol>
<h3 id="移位运算">移位运算</h3>
<p><strong>算术移位</strong></p>
<table>
<thead>
<tr class="header">
<th></th>
<th>码制</th>
<th>添补代码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>正数</td>
<td>原码补码反码</td>
<td>0</td>
</tr>
<tr class="even">
<td>负数</td>
<td>原码</td>
<td>0</td>
</tr>
<tr class="odd">
<td>负数</td>
<td>补码</td>
<td>左移添0，右移添1</td>
</tr>
<tr class="even">
<td>负数</td>
<td>反码</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>三种机器数算术移位后的符号位均不变。</p>
<p>双符号位的最高符号位代表真正的符号，而低位符号位用于参与移位操作以判断是否发生溢出，如01表示结果正溢出，10表示结果负溢出<br />
算术移位的情况下，补码左移不丢失精度的前提条件是其原最高有效位与原符号位要相同</p>
<p><strong>逻辑移位</strong> 将操作数视为无符号数，逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0。</p>
<p><strong>循环移位</strong> 分为带进位标志位CF的循环移位(大循环)和不带进位标志位的循环移位(小循环)<br />
<img src="/assets/resources/Pasted%20image%2020240115200514.png" /></p>
<h3 id="定点数的数学运算">定点数的数学运算</h3>
<p>定点数的实质是事先规定小数点位置，数据无需储存小数点，只关注具体运算</p>
<h4 id="加减">加减</h4>
<ol type="1">
<li>补码 符号位与数值位一起参与运算：<br />
<span class="math inline">\([A+B]_{\mathbb{补}}=[A]_{\mathbb{补}}+[B]_{\mathbb{补}}{\ \mathrm{(mod}\ 2^{n+1})}\)</span><br />
<span class="math inline">\([A-B]_{\mathbb{补}}=[A]_{\mathbb{补}}+[-B]_{\mathbb{补}}{\ \mathrm{(mod}\ 2^{n+1})}\)</span></li>
</ol>
<p>一个数真值的相反数的补码等于其补码所有位(包括符号位)取反并+1</p>
<p>其电路实现上，则相当于对Y和Y的取反进行一个选择，并对是否输入一个1进行选择，由一个sub控制端的0/1来决定，无符号整数的二进制表示相当于正整数的补码表示，因此，该电路同时也能实现无符号整数的加/减运算<br />
<img src="/assets/resources/Pasted%20image%2020240115201121.png" /> OF(Overflow Flag)溢出标志，用于判断带符号数加减运算是否溢出。OF=1 溢出；OF=0 未溢出<br />
<span class="math inline">\(\mathrm{OF}\equiv C_{\mathrm{n}}\oplus C_{\mathrm{n-1}}\)</span>符号位进位与最高数位进位的异或<br />
SF(Sign Flag)符号标志，用于判断带符号数加减运算结果的正负性。SF=1 结果为负；SF=0 结果为正<br />
<span class="math inline">\(\mathrm{SF}=\mathrm{S}_{n}\)</span>即运算结果最高位<br />
ZF(Zero Flag)零标志，用于判断加减运算结果是否为0。ZF=1 表示结果为0；ZF=0 表示结果不为0<br />
<span class="math inline">\(\mathrm{ZF}=\overline{S_{n}+\cdots+S_{2}+S_{1}}\)</span><br />
CF(Carry Flag)进位/借位标志，用于判断<strong>无符号数</strong>加减运算是否溢出。CF=1 溢出；CF=0 未溢出。无符号加减法，加法溢出必有(最高位)进位，减法溢出必有(最高位)借位<br />
<span class="math inline">\({\mathrm{CF}}=C_{\mathrm{out}}\oplus Sub\)</span> (Cout表示进位输出，即最高位进位，Sub是低位加法器的进位输入，为0表示加法运算，为1表示减法，被减数除了符号位取反，同时则作为低位进位实现补码加1的效果)</p>
<p>这些标志信息通常会被送入 PSW 程序状态字寄存器或者标志寄存器FR(Flag Register)<br />
<strong>溢出的判断</strong></p>
<ul>
<li>单符号位： 仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，例如正数之和符号位为1<br />
无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。<br />
设A的符号为As, B的符号为Bs，运算结果的符号为Ss，则溢出逻辑表达式为(0表示无溢出)</li>
</ul>


$$
V={A_{\mathrm{s}}}{B_{\mathrm{s}}}{\overline{{S_{\mathrm{s}}}}}+\overline{A_s}.\overline{B_{\mathrm{s}}}S_{\mathrm{s}}
$$  


<ul>
<li><p>双符号位(模4补码)： 运算结果的两个符号位Ss1Ss2相同，表示未溢出；运算结果的两个符号位不同，表示溢出<br />
Ss1Ss2的结果：</p>
<ul>
<li>00，正数无溢出</li>
<li>01，正溢出</li>
<li>10，负溢出</li>
<li>11，负数无溢出</li>
</ul></li>
</ul>
<p>进位情况:<br />
若符号位的进位Cs与最高数位的进位C1相同，则说明没有溢出，否则表示发生溢出。<br />
CS为0时是上溢，相反是负溢，类似双符号位<br />
溢出逻辑判断表达式为<span class="math inline">\(V=C_{s}\oplus C_{1},\)</span>，若V=0,表示无溢出；V=1,表示有溢出。</p>
<p>具体运算：</p>
<ol type="1">
<li><p>原码 加法：符号位相同的情况略，不同则用绝对值较大的减去较小的，取较大者的符号<br />
减法：转换成A与-B的加法</p></li>
<li><p>无符号整数<br />
加法略，减法将减数所有位取反再加一与被减数相加得到结果<br />
无符号数加法的溢出判断：最高位产生的进位=1时，发生溢出，否则未溢出。<br />
无符号数减法的溢出判断：减法变加法，最高位产生的进位=0时，发生溢出，否则未溢出</p></li>
</ol>
<h4 id="乘除">乘除</h4>
<ol type="1">
<li>乘法运算由累加和右移操作实现，可分为原码一位乘法和补码一位乘法。</li>
</ol>
<ul>
<li>原码一位乘法 <img src="/assets/resources/Pasted%20image%2020240115214143.png" /></li>
</ul>
<p>无符号数乘法运算电路，从低到高进行加法，每加一次就逻辑右移<br />
<img src="/assets/resources/Pasted%20image%2020240115215314.png" /></p>
<ul>
<li>补码一位乘法(Booth算法) <img src="/assets/resources/Pasted%20image%2020240115215614.png" /> <code>x*y=-0.10001111</code><br />
电路实现：每次从寄存器丫移出的最低位和它的前一位来决定是<code>-[x]补、+［x］补还是+0</code>。<br />
<img src="/assets/resources/Pasted%20image%2020240115220452.png" /></li>
</ul>
<ol start="2" type="1">
<li>除法 分为原码除法和补码除法</li>
</ol>
<div class="note info"><p>符号拓展：把低位整数转换成高位整数，但符号与真值不变<br />
正数的符号扩展非常简单，即符号位不变，新表示形式的所有扩展位都用0进行填充。<br />
负数的符号扩展方法则根据机器数的不同而不同。原码表示负数的符号扩展方法与正数相同<br />
补码表示负数的符号扩展方法：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1 (对于整数)或0(对于小数)进行填充。</p>
</div>
<ul>
<li><p>原码除法运算(不恢复余数法) <img src="/assets/resources/Pasted%20image%2020240116102453.png" /> <img src="/assets/resources/Pasted%20image%2020240116102504.png" /></p></li>
<li><p>补码除法运算(加减交替法) <img src="/assets/resources/Pasted%20image%2020240116102537.png" /></p></li>
</ul>
<p><span class="math inline">\([x/y]_{补}=1.0101\,,\ \ 余\ 0.0111\times2^{-4}.\)</span></p>
<p>电路实现： <img src="/assets/resources/Pasted%20image%2020240116102700.png" /> 寄存器RQ分别存放被除数的高位低位，每次计算时同步左移</p>
<p>原码加减交替法最多加减N+2次(最后不够减要恢复余数)，最后够减就是N+1次<br />
补码加减交替法最多加减N+1次，商末尾恒置1</p>
<h3 id="数据的存储与表示">数据的存储与表示</h3>
<div class="note info"><ul>
<li>同字长的类型，c语言中强制类型转换的结果保持位值不变，仅改变了解释这些位的方式，例如<code>short</code> 和<code>unsigned short</code></li>
<li>当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接截断，低位直接赋值</li>
<li>短字长到长字长的转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行零扩展，扩展后的高位部分用0填充。否则进行符号扩展，扩展后的高位部分用原数字符号位填充。(char类型为8位无符号整数，其在转换为int时高位补0)</li>
</ul>
</div>
<p>通常用最低有效字节(LSB)和最高有效字节(MSB)来分别表示数的低位和高位。例如，在32位计算机中，一个int型变量i的机器数为<code>01 23 45 67H</code>,其最高有效字节MSB = 01H,最低有效字节LSB = 67H<br />
现代计算机基本上都采用字节编址，即每个地址编号中存放1字节,多字节数据都存放在连续的字节序列中，排列方式可分为：</p>
<ul>
<li>大端方式按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面</li>
<li>小端方式按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面</li>
</ul>
<p>对于机器字长为32位的计算机，数据如果以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍<br />
数据不按边界对齐时，节省空间，但会增加访问地址的次数与连接不同数据的计算量<br />
<img src="/assets/resources/Pasted%20image%2020240115222444.png" /></p>
<div class="note warning"><ul>
<li>ALU是由组合逻辑电路构成的，最基本的部件是并行加法器</li>
<li>数据总线供ALU与外界交互数据使用，也是运算器部件</li>
<li>不带进位的循环左移将最高位进入最低位和标志寄存器C位</li>
<li>模4补码具有模2补码的全部优点且更易检查加减运算中的溢出问题</li>
<li>存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的</li>
<li>采用双符号位时，第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出，可用一个异或判断</li>
<li>补码一位乘法中，最多需要n次移位，n+1次加法运算。原码乘法移位和加法运算最多均为n次</li>
<li>补码乘法右移n次，因此结果长度为2N</li>
<li>原码不恢复余数虽然名字如此，但最后一步不够减时需要恢复余数</li>
<li>做减法时，低位进位为Sub,即为1(Sub决定多路选择器是否将y的各位取反，也就是说补码的话之后还需要用多路复用器mux+1)</li>
<li>c语言中short是半字，int是字，char是1B，在常见的32位计算机中，按边界对齐就是一个32位的字可以放两个short一个int四个char</li>
<li>乘法运算可以通过加法和移位来实现。编译器可以将乘法运算转换为一个循环代码段,在循环代码段中通过比较、加法和移位等指令实现乘法运算</li>
<li>阵列乘法器实现的乘法指令比使用ALU与位移器实现的快，只需要一个时钟周期</li>
<li>对无符号整数乘法，高n位都是0时，结果不会溢出</li>
<li>ALU生成标志位时只负责计算，而不管运算对象是有符号数还是无符号数，CF= 1表示当作无符号数运算时溢出，OF= 1表示当作有符号数运算时溢出</li>
</ul>
</div>
<h2 id="浮点数的表示和运算">浮点数的表示和运算</h2>
<p>浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动，一般表示为：<span class="math inline">\({\cal N}=(-1)^{S}\times M\times R^{E}\)</span><br />
S取值0或1,用来决定浮点数的符号；M是一个二进制定点小数，称为尾数，一般用定点原码小数表示；E是一个二进制定点整数，称为阶码或指数，用移码表示。R是约定好的基数<br />
阶码的值反映浮点数的小数点的实际位置；阶码的位数反映浮点数的表示范围；尾数的位数反映浮点数的精度。<br />
<img src="/assets/resources/Pasted%20image%2020240116204934.png" /> 浮点数的范围关于原点对称，超出范围会导致溢出，其中，下溢会被视为0</p>
<p><strong>规格化操作</strong><br />
指通过调整一个非规格化浮点数的尾数和阶码的大小,使非零的浮点数在尾数的最高数位上保证是一个有效值</p>
<ul>
<li>左规：当运算结果的尾数的最高数位不是有效位。左规时，尾数每左移一位、阶码减1 (基数为2时)。左规可能要进行多次</li>
<li>右规：当运算结果的尾数的有效位进到小数点前面时，需要进行右规。将尾数右移一位、阶码加1 (基数为2时)。需要右规时，只需进行一次。</li>
</ul>
<p>规格化浮点数的尾数M的绝对值应该满足<span class="math inline">\(1/R\leqslant|M|\lt 1,\)</span>对原码来说，其绝对值的上下界分别是<span class="math inline">\((1-2^{-n})\)</span>和1/2</p>
<p><strong>IEEE 754标准</strong></p>
<ul>
<li>短浮点数(单精度、float型)</li>
<li>长浮点数(双精度、double型)</li>
<li>临时浮点数 <img src="/assets/resources/Pasted%20image%2020240116215743.png" /> <img src="/assets/resources/Pasted%20image%2020240116215753.png" /> 规格化的浮点数最高位总是1，因此可以隐去，短浮点数与长浮点数都采用隐藏尾数最高数位的方法，因此可多表示一位尾数<br />
存储浮点数阶码之前，偏置值要先加到阶码真值上。<br />
eg.规格化的短浮点数真值为：<br />
<span class="math display">\[(-1)^{S}\times1.M\times2^{E-127}\]</span></li>
</ul>
<p>短浮点数E的取值为1〜254 (8位表示)，M为23位，共32位<br />
长浮点数E的取值为1〜2046 (11位表示)，M为52位,共64位。<br />
最值则分别在EM的同时最小与同时最大处取，分别是<span class="math inline">\(2^{-(偏置值-1)}\)</span>与<span class="math inline">\(2^{E_{max}-偏置值}*(2-2^{-M})\)</span><br />
<strong>IEEE 754格式的浮点数，阶码偏移量不是2^n，是固定值127与1023</strong><br />
阶码全0或全1时，有其特别的解释<br />
<img src="/assets/resources/Pasted%20image%2020240116221404.png" /></p>
<p>与定点数区别：</p>
<ul>
<li>相同字长时浮点数范围更大</li>
<li>相同字长时浮点数精度更低</li>
<li>浮点运算需要规格化，并运算阶码和尾码，更为复杂</li>
<li>定点数结果超出表示范围则溢出，浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。</li>
</ul>
<h3 id="浮点数的加减运算">浮点数的加减运算</h3>
<ol type="1">
<li>对阶，使两个操作数的小数点位置对齐，阶码相等。将阶码小的尾数右移一位(基数为2),阶加1,直到两个数的阶码相等为止，过程可能舍弃有效位影响精度</li>
<li>尾数求和，尾数按定点数规则运算</li>
<li>对结果进行规格化(左规一次相当于乘2,右规一次相当于除2)
<ol type="1">
<li>1.xxxx时，右规</li>
<li>0.0xx01xxxx时，左规</li>
</ol></li>
<li>在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将低位移出位保留下来，参加中间过程的运算，最后将运算结果进行舍入
<ol type="1">
<li>0舍1入法，舍入为最近的可表示数,正好中间时，则选择结果为偶数。这样可能会使尾数溢出，此时需再做一次右规</li>
<li>恒置1法，都把右移后的尾数末位恒置1。</li>
<li>截断法：直接截取所需位数，丢弃后面的所有位</li>
</ol></li>
<li>溢出判断，在尾数规格化和尾数舍入时，可能会对阶码执行加/减运算。这时可能指数溢出
<ol type="1">
<li>右规时数值很大的尾数舍入时，可能因为末位加1而发生尾数溢出，此时需要通过右规来调整尾数和阶，导致阶数加一，若右规后阶数全1则发生上溢</li>
<li>左规时类似前者，阶数全0则下溢</li>
</ol></li>
</ol>
<div class="note info"><p>C语言中的float和double类型分别对应于IEEE 754单精度浮点数和双精度浮点数。long double类型对应于扩展双精度浮点数.<br />
常见的类型转换中：</p>
<ul>
<li>char-&gt;int-&gt;long-&gt;double和float-&gt;double不会损失精度</li>
<li>int转换为float时，虽然不会发生溢出，但float尾数连隐藏位共24位，当int型数的第24〜31位非0时，无法精确转换成24位浮点数的尾数，需进行舍入处理，影响精度。</li>
<li>double-&gt;float可能损失精度或溢出</li>
<li>float或double转换为int时，只保留整数部分，且可能溢出</li>
</ul>
<p>用移码表示阶码的优点：</p>
<ul>
<li>浮点数进行加减运算时要比较阶码的大小，移码比较大小更方便</li>
<li>检验移码的特殊值(0和max)时比较容易，0时相当于分母无穷大，表示负无穷大，max表示指数正无穷大，但若max时尾数不为0，则表示运算错误</li>
</ul>
<p>浮点数舍入方法应该使误差尽可能对称，且高效</p>
<ul>
<li>就近舍入，舍入为最近可表示的数</li>
<li>正向舍入，取右侧的数</li>
<li>负向舍入</li>
<li>截取，取绝对值小的数</li>
</ul>
<p><strong>关于基数</strong><br />
现假设尾数(含符号位)用4位2进制存储，则某以2为基数的浮点数规格化后为:<code>0.101*2^(-1)</code><br />
如果换乘以4为基数，规格化后就是:<code>0.010(1)*4^0</code><br />
由于基数更大，就需要更长的尾数表达一个数，因此尾数越大，前面没必要存的0就越多，这些对精度没有任何贡献的0占据的位置越多，精度就越低<br />
基数不等于进制，基数越大精度越低，进制越大精度越高。<strong>本质上说基数与阶码相对，更大的基数会减少尾数的表达能力，但增加阶码即整个浮点数的表示范围</strong><br />
或者说，更大的基数，其阶码的变动就需要尾数更大幅度的变化，从而使表示的数变得稀疏</p>
<p><strong>关于溢出的总结</strong></p>
<ul>
<li>阶码上溢出。一个正指数超过了最大允许值时，浮点数发生上溢出(即向∞方向溢出)。若结果是正数，则发生正上溢出(有的机器把值置为+∞);若结果是负数，则发生负上溢出(有的机器把值置为-∞)<strong>右规和尾数舍入都可能引起阶码上溢(尾数溢出时结果不一定溢出)</strong></li>
<li>阶码下溢出。一个负指数比最小允许值还小时，浮点数发生下溢出。一般机器把下溢出时的值置为0 (+0或-0)。<strong>左规时可能引起阶码下溢</strong></li>
<li>尾数溢出。当尾数最高有效位有进位时，发生尾数溢出。此时，进行“右规”操作：尾数右移一位，阶码加1,直到尾数不溢出为止。此时，只要阶码不发生上溢出，浮点数就不会溢出</li>
<li>非规格化尾数。当数值部分高位不是一个有效值时(如原码时为0或补码时与符号位相同)，尾数为非规格化形式。此时，进行“左规”操作：尾数左移一位，阶码减1，直到尾数为规格化形式为止</li>
<li>对阶不会引起阶码上溢或下溢(阶码维持在与较大者一致)</li>
</ul>
</div>
<div class="note warning"><ul>
<li>可表示的数据个数取决于编码所采用的位数,编码位数一定，编码出来的数据个数就是一定的，浮点数和定点数没有不同(除非编码和值不是一一对应)</li>
<li>基数越大，范围越大，但精度变低(数变稀疏)，运算中尾数右移的可能性越小，运算的精度损失越小，规格化更少，运算速度也更高</li>
<li>补码规格化的尾数，符号位与尾数最高位相反</li>
<li>对阶是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减小、尾数左移的情况</li>
<li>采用规格化浮点数的目的主要是为了增加数据的表示精度</li>
<li>上下溢都是绝对值超出表示范围，和正负无关</li>
<li><code>IEEE 754</code>标准格式中，阶码全为0,尾数不全为0表示非规格化数，非规格化数可用于处理阶码下溢,上溢则只能报错(这种情况下尾数前不用补1,即实际数值为0.M,实际阶码固定为-126，用于表示绝对值极小的数)</li>
<li>浮点数舍入的情况有两种：对阶、右规格化，定点数不需要舍入</li>
<li>float保存24位整数，<span class="math inline">\(2^{24}\)</span>以内的整数int可以无损转换</li>
<li>浮点数的加减运算，右规不会超过一次，左规不会超过n次</li>
<li>阶码上溢可能出现于运算完的右规或尾数舍入，下溢可能出现于运算完左规</li>
</ul>
</div>
<h1 id="存储器">存储器</h1>
<h2 id="概念">概念</h2>
<p><strong>功能分类</strong></p>
<ul>
<li>主存，存放cpu计算需要的程序与数据可以和cache与辅存交换数据</li>
<li>辅助存储器，也就是外存，可以在寿命内长时间存放信息</li>
<li>高速缓冲存储器，cache，位于主存与cpu之间，通常和cpu集成</li>
</ul>
<p><strong>存取方式分类</strong></p>
<ul>
<li>随机存储器(RAM)</li>
<li>只读存储器(ROM),断电不会丢失数据</li>
<li>串行访问存储器，需按其物理位置的先后顺序寻址
<ul>
<li>顺序存取存储器，只能按某种顺序存取(磁带)</li>
<li>直接存取存储器，寻找到一定区域，在区域内顺序查找(磁盘，光盘)</li>
</ul></li>
</ul>
<p><strong>可保存性分类</strong></p>
<ul>
<li>易失性存储器，如RAM</li>
<li>非易失性存储器，如ROM、磁表面存储器和光存储器</li>
</ul>
<p><strong>指标</strong>：</p>
<ul>
<li>存储容量=存储字数X字长(1Byte=8bit)</li>
<li>单位成本：每位价格=总成本/总容量。</li>
<li>存储速度：数据传输率=数据的宽度/存取周期
<ul>
<li>存取时间(Ta)：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间</li>
<li>存取周期(Tm)：存取周期又称读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，也就是连续两次访问存储器之间所必需的最短时间间隔</li>
<li>主存带宽(Bm)：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量(B/s)</li>
</ul></li>
</ul>
<p>在读写操作之后，总要有一段恢复内部状态的复原时间,因此一般存取周期大于存取时间</p>
<p><img src="/assets/resources/Pasted%20image%2020240117165807.png" /> 上一层的存储器一般作为低一层存储器的高速缓存，Cache-主存层和主存-辅存层中，上层内容是下一层的一部分</p>
<div class="note info"><p>主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的<br />
而主存和辅存之间的数据调动则是由硬件和操作系统共同完成的，对应用程序员是透明的。</p>
<ul>
<li>存取时间是执行一次读操作或写操作的时间，分为读出时间和写入时间</li>
<li>存储周期是指存储器进行连续两次独立地读或写操作所需的最小时间间隔</li>
</ul>
</div>
<div class="note warning"><ul>
<li>1MB=<span class="math inline">\(2^{20}B\)</span></li>
<li>1s=<span class="math inline">\(10^3ms\)</span>=<span class="math inline">\(10^6\)</span>μs=<span class="math inline">\(10^9ns\)</span></li>
<li>速度排名：寄存器-Cache-主存-辅存</li>
<li>两个不同速度的存储器共同访问时，快者未命中时总访问时间是慢者时间，不同时访问则是两者时间之和</li>
<li>Cache主存系统的效率=访问Cache的时间/平均访存时间</li>
</ul>
</div>
<h2 id="主存储器">主存储器</h2>
<p>主存储器由DRAM实现，靠处理器的那一层(Cache)则由SRAM实现，它们都属于易失性存储器，只要电源被切断，原来保存的信息便会丢失。DRAM的每位价格低于SRAM,速度也慢于SRAM<br />
DRAM电容上的电荷一般只能维持1〜2ms,每隔一定时间必须刷新，通常取2ms,称为刷新周期。</p>
<ul>
<li>集中刷新：指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”。</li>
<li>分散刷新：把对每行的刷新分散到各个工作周期中。增加了存取周期，但没有死区</li>
<li>异步刷新：具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔。利用逻辑电路每隔时间t产生一次刷新请求。减少刷新次数，也能避免死区过多</li>
</ul>
<div class="note info"><ul>
<li>刷新对CPU是透明的，即刷新不依赖于外部的访问</li>
<li>动态RAM的刷新单位是行，由芯片内部自行生成行地址</li>
<li>刷新时不需要选片，即整个存储器中的所有芯片同时被刷新</li>
</ul>
</div>
<p><img src="/assets/resources/Pasted%20image%2020240117214529.png" /> <img src="/assets/resources/Pasted%20image%2020240117214601.png" /> 存储器芯片由存储体、I/O读写电路、地址译码和控制电路等部分组成。</p>
<ul>
<li>存储体(存储矩阵)。存储体是存储单元的集合,它由行选择线(X)和列选择线(Y)来选择所访问单元</li>
<li>地址译码器。用来将地址转换为译码输出线上的高电平，以便驱动相应的读写电路</li>
<li>I/O控制电路。用以控制被选中的单元的读出或写入</li>
<li>片选控制信号,访问某个字必须选中且只选中其所在芯片，因此需要信号加以控制</li>
<li>读/写控制信号。根据CPU给出的读命令或写命令，控制被选中单元进行读或写 <img src="/assets/resources/Pasted%20image%2020240117215030.png" /></li>
</ul>
<p><strong>只读存储器(ROM)</strong> 结构更简单，存储密度更高，且更可靠</p>
<ul>
<li>掩模式只读存储器MROM，制造时厂商写入，无法更改</li>
<li>一次可编程只读存储器PROM，可以用专门设备写入且只能写入一次</li>
<li>可擦除可编程只读存储器EPROM，可以多次写入，但次数有限，且写入时间较长</li>
<li>flash存储器，不加电可以长期保存信息，也可以快速擦除重写，且价格较便宜，集成度高,存储元由MOS管组成，是一种半导体存储器,采用随机访问方式，可替代计算机外部存储器</li>
<li>固态硬盘SSD，长期保存信息、快速擦除与重写，读写速度快、低功耗</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240117215509.png" /> <strong>主存储器(Main Memory, MM)</strong></p>
<ul>
<li>记忆单元，储存一个个0/1，构成存储矩阵的基本单位</li>
<li>编制单位，有相同地址的存储元件构成的单位，一般按字节编址</li>
</ul>
<p>指令访问主存的过程:</p>
<ol type="1">
<li>cpu将地址送到MAR，并通过地址线将其送到主存的地址寄存器</li>
<li>与1.同时,将读写信号送到主存的读写控制电路(通过控制线)</li>
<li>执行指令，读写期间MDR用于存放具体数据</li>
</ol>
<p>数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同，地址线位数会决定主存地址空间的寻址范围(从0开始索引)<br />
DRAM通常采用地址引脚复用技术，行地址和列地址通过相同的引脚分先后两次输入</p>
<p><strong>多模块存储器</strong><br />
多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体低位交叉存储器</p>
<ol type="1">
<li>单体多字系统,存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。
<ul>
<li>一个存取周期中，从同一个地址取m条指令，依次送到cpu,每隔1/m存取周期，CPU向主存取一条指令,提高效率，但不适用于非连续的指令或数据</li>
</ul></li>
<li>多体并行存储器,由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作
<ol type="1">
<li>高位交叉编址(顺序方式)，高位地址表示体号，低位地址为体内地址。把低位的体内地址送到由高位体号确定的模块内进行译码，访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，本质依旧是串行</li>
<li>低位交叉编址(交叉方式)，低位地址为体号，高位地址为体内地址。每个模块按“模加”交叉编址，模块号=单元地址% m，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽
<ul>
<li>通俗易懂地理解：存取周期包括数据的传送和存储器的恢复，总线周期r是单纯读取数据的时间，因此所有要读的字存在不同模块时，读完一个模块就可以去下一个模块读，读完剩下的模块后，第一个模块已经恢复，这样就可以一直读下去</li>
<li>设模块字长等于数据总线宽度，模块存取一个字的存取周期为T,总线传送周期为r,为实现流水线方式存取，存储器交叉模块数应大于等于<span class="math inline">\(m=T/r\)</span>,m称为交叉存取度。每经过r时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于等于m，以保证启动某模块后经过加<code>m*r</code>的时间后再次启动该模块时，其上次的存取操作已经完成(即流水线不间断)。</li>
<li>连续存取m个字所需的时间为<span class="math inline">\(t_{1}=T+(m-1)r\)</span>,远少于顺序读取时间mT</li>
</ul></li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240117221818.png" /> <img src="/assets/resources/Pasted%20image%2020240117222135.png" /> <img src="/assets/resources/Pasted%20image%2020240118225544.png" /></p>
<div class="note warning"><ul>
<li>芯片若是<span class="math inline">\({2^n}\times{x}\)</span> ，则说明需要n根地址线，x根数据线，此外还需要两条读写线和一条片选线</li>
<li>DRAM芯片的集成度高于SRAM</li>
<li>sram用两个稳定电路存储，dram用电容暂存，1是有电情况</li>
<li>使用地址复用时，地址线减半，增加两条行/列通选线，其中行通选线兼用于片选(仅用于DRAM)</li>
<li>随机存取与随机存取存储器(RAM)不同，支持随机存取的存储器不一定是RAM，如u盘基于flash，因此其实是ROM</li>
<li>DRAM刷新只需要一个存储周期</li>
<li>高位交叉存储器在单个存储器中的字是连续存放的，不满足程序的局部性原理(连续读出彼此地址相差一个存储体容量的字)；而低位交叉存储器是交叉存放,满足局部性原理</li>
<li>双端口存储器具有两套独立读/写口，具有各自的地址寄存器和译码电路,所以可以同时访问同一区间、同一单元</li>
<li>ROM较慢，不可用作Cache</li>
<li>根据历年408真题的描述, 交叉编址方式就是指低位交叉编址,这种情况下最低位<span class="math inline">\(\log_{2}m\)</span>决定体号</li>
<li>ROM写速度小于读速度(需要擦除)</li>
<li>可能发生访存冲突的情况：给定的访存地址在<strong>相邻的m次访问</strong>中出现在同一个存储模块内</li>
<li>一个存储周期可对所有芯片各读取相同位置的1字节，因此不是从0号芯片存取的<span class="math inline">\(m*n\)</span>位数据，需要n+1轮周期</li>
</ul>
</div>
<h2 id="主存储器与cpu的连接">主存储器与CPU的连接</h2>
<ol type="1">
<li>主存储器通过数据总线、地址总线和控制总线与CPU连接</li>
<li>数据总线的位数与工作频率的乘积正比于数据传输率</li>
<li>地址总线的位数决定了可寻址的最大内存空间</li>
<li>控制总线(读/写)指出总线周期的类型和本次输入/输出操作完成的时刻 <img src="/assets/resources/Pasted%20image%2020240119160205.png" /><br />
主存一般由多个芯片集成而成，通过总线与cpu相连<br />
<img src="/assets/resources/Pasted%20image%2020240119160435.png" /><br />
内存条插槽就是存储器总线，内存条主存中的信息通过内存条的引脚，再通过插槽内的引线连接到主板上，通过主板上的导线连接到CPU芯片</li>
</ol>
<p>有时需要对芯片字与位进行拓展，满足容量需求</p>
<ul>
<li>位拓展，CPU的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位，将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出，例如八片1位芯片并联，每片作为cpu数据线的一位(需要片选信号CS来进行这种全选)</li>
<li>字拓展，将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。每次片选信号只会选中一个芯片</li>
<li>字位同时扩展，结合两者，此时各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号或采用译码器设计连接到相应的芯片</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240119160847.png" alt="地址线A12〜A0、CS＞砺都分别连在一起" /> <img src="/assets/resources/Pasted%20image%2020240119161006.png" alt="D0〜D7和WE都分别连在一起。将A15A14用作片选信号" /> <img src="/assets/resources/Pasted%20image%2020240119161132.png" /> cpu选择存储芯片，称为片选，随后选择存储单元，称为字选<br />
片内的字选通常是由CPU送出的N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端(N由片内存储容量<span class="math inline">\(2^N\)</span>决定) 片选信号的产生则分为：</p>
<ul>
<li>线选法：除片内寻址外的高位地址线直接(或经反相器)分别接至各个存储芯片的片选端,，某条地址线为0时表示选中对应芯片，低位线A10~A0用于字选。这样不需要地址译码器，线路简单，地址空间不连续产生浪费。如以下表格所示</li>
<li>译码片选法：用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号，例如字选剩下的可用地址线不足时，剩下的若干位用于地址译码，即视作直接的二进制信号</li>
</ul>
<table>
<thead>
<tr class="header">
<th>芯片</th>
<th>A14~A11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0#</td>
<td>1110</td>
</tr>
<tr class="even">
<td>1#</td>
<td>1101</td>
</tr>
<tr class="odd">
<td>2#</td>
<td>1011</td>
</tr>
<tr class="even">
<td>3#</td>
<td>0111</td>
</tr>
</tbody>
</table>
<div class="note info"><p>若干注意点：存储芯片，地址，数据，读写命令，片选线：</p>
<ul>
<li>通常选用ROM存放系统程序、标准子程序和各类常数，RAM则是为用户编程而设置的</li>
<li>CPU的地址线数往往比存储芯片的地址线数要多。通常将CPU地址线的低位与存储芯片的地址线相连,用于字选，译码由存储芯片实现，而CPU地址线的高位则在扩充存储芯片时使用，用于片选，译码由外接译码器实现</li>
<li>cpu数据线数与存储芯片数据线数也可能不等，需要扩位</li>
<li>CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写，有时cpu会分为两条线，<span class="math inline">\(\overline{RD}\)</span>和<span class="math inline">\(\overline{WE}\)</span>，均为低电平有效，需要分别连接到存储芯片的允许读/写控制端</li>
<li>片选有效信号与CPU的访存控制信号<span class="math inline">\(\overline{MREQ}\)</span>(低电平有效)，为高是表示cpu正在访问内存</li>
</ul>
</div>
<div class="note warning"><ul>
<li>片选信号的译码器的输入地址线是去掉用于产生字数的位的首n根地址线</li>
<li>MAR的位数必须能访问整个主存地址空间，因此可以大于实际的物理空间</li>
</ul>
</div>
<h2 id="外部存储器">外部存储器</h2>
<p>磁盘存储器：</p>
<ol type="1">
<li>容量大，价格低</li>
<li>可重复使用</li>
<li>可长期保存不易丢失</li>
<li>非破坏性读出</li>
<li>存取相对较慢，且机械结构对环境有一定要求</li>
</ol>
<p>组成：</p>
<ul>
<li>磁盘驱动器
<ul>
<li>磁头组件</li>
<li>盘片组件</li>
</ul></li>
<li>磁盘控制器</li>
<li>盘片</li>
</ul>
<p>存储：一块硬盘有若干记录面，记录面有若干磁道，磁盘划分若干扇区，扇区是最小单位</p>
<ul>
<li>磁头数：对应记录面数</li>
<li>柱面数：对应磁道数，指不同盘片上垂直分布的各个磁道</li>
<li>扇区数</li>
</ul>
<p>原理：磁头与磁盘相对运动时，电磁转换产生信号<br />
指标：</p>
<ul>
<li>记录密度。记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积</li>
<li>磁盘的容量。磁盘容量有非格式化容量和格式化容量之分。非格式化容量是指磁记录表面可利用的磁化单元总数，它由道密度和位密度计算而来；格式化容量是指按照某种特定的记录格式所能存储信息的总量。格式化后的容量比非格式化容量要小</li>
<li>平均存取时间。平均存取时间由寻道时间(磁头移动到目的磁道的时间)、旋转延迟时间(磁头定位到要读写扇区的时间)和传输时间(传输数据所花费的时间)三部分构成。</li>
<li>数据传输率。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。假设磁盘转数为r转/秒，每条磁道容量为N字节，则数据传输率为<span class="math inline">\(D_{r}=r N\)</span></li>
</ul>
<p>地址的常见格式(位数取决与需要编址的数量)：</p>
<table>
<thead>
<tr class="header">
<th>驱动器号</th>
<th>柱面号</th>
<th>盘面号</th>
<th>扇区号</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>硬盘的主要操作是寻址、读盘、 写盘。 每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。</p>
<p><strong>磁盘阵列</strong><br />
将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</p>
<ul>
<li>RAID0：无冗余和无校验的磁盘阵列。</li>
<li>RAID1：镜像磁盘阵列。</li>
<li>RAID2：采用纠错的海明码的磁盘阵列。</li>
<li>RAID3：位交叉奇偶校验的磁盘阵列。</li>
<li>RAID4：块交叉奇偶校验的磁盘阵列。</li>
<li>RAID5：无独立校验的奇偶校验磁盘阵列。</li>
</ul>
<p>ssd:基于闪存技术的存储器,与u盘原理相同，由一个或多个闪存芯片和闪存翻译层组成，翻译层翻译cpu请求<br />
一个闪存有B块，每块有P页，数据以页为单位读写，但写任何数量的页需要擦除整个块，因此写相对读更慢，且会消耗固态寿命<br />
<img src="/assets/resources/Pasted%20image%2020240119185327.png" /></p>
<div class="note warning"><ul>
<li>读一个扇区中数据所用的时间=找磁道的时间+找扇区的时间+磁头扫过一个扇区的时间。找磁道的时间是指磁头从当前所处磁道运动到目标磁道的时间,即寻道时间，可用移动1/2半径的时间估算；找扇区的时间是指磁头从当前所处扇区运动到目标扇区的时间，一般用转半圈的时间估算；磁头扫过一个扇区的时间一般用转一圈的时间除以磁道的扇区数估算</li>
<li>磁盘存储器的最小读写单位为一个扇区</li>
</ul>
</div>
<div class="note info"><p>考研无关：<br />
408(准确地说是王道)告诉我们，固态硬盘写入需要先擦除整块，因此比读更慢，实际测试一下的话，(在我的硬盘上)连续读写和多线程随机读写确实如此，但单线程就不对了，随机读比随机写慢了快一倍，这是为什么呢<br />
​这主要是因为王道写书的时候没有去固态硬盘吧看看，现在很多民用盘会给缓存，比如sn550就有slc缓存，写入可以直接写到缓存里，而随机读就很难缓存，当然这也无所谓，考试也不会考500预算有缓无缓盘买哪个<br />
​下一个问题是为什么多线程读就变好了，比较直观的猜想是，读可以并行或者流水线，写要阻塞很久才能进行下一次，不过这个大概只有专业人士才知道细节……</p>
</div>
<h2 id="高速缓冲存储器">高速缓冲存储器</h2>
<p><strong>程序访问的局部性原理</strong>(略)<br />
高速缓冲技术就是利用局部性原理，把程序中正在使用的部分数据存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而提高程序的执行速度。</p>
<h3 id="cache工作原理">Cache工作原理</h3>
<p>Cache位于存储器层次结构的顶层，通常由SRAM构成<br />
Cache和主存都被划分为相等的块，Cache块又称Cache行，每块由若干字节组成，块的长度称为块长(Cache行长) Cache块数要远少于主存中的块数.其替换过程由硬件实现<br />
CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cache块为单位<br />
对Cache的访问可以和主存同步或者异步进行，同步时，命中则主存访问终止，不命中则替换<br />
CPU欲访问的信息已在Cache中的比率称为Cache的命中率。设一个程序执行期间，Cache<br />
的总命中次数为<span class="math inline">\(N_C\)</span>，访问主存的总次数为<span class="math inline">\(N_m\)</span>,则命中率为 <span class="math display">\[H=N_{\mathrm{c}}/(N_{\mathrm{c}}+N_{\mathrm{m}})\]</span> <span class="math inline">\(t_ct_m\)</span>分别是命中与未命中的访问时间，平均访问时间为：<br />
<span class="math display">\[T_{\mathrm{a}}=H t_{\mathrm{c}}+(1-H)\,t_{\mathrm{m}}\]</span> <img src="/assets/resources/Pasted%20image%2020240122110823.png" /></p>
<ol type="1">
<li>数据查找。判断数据是否在Cache</li>
<li>地址映射。主存如何存放在Cache,如何进行地址转换</li>
<li>替换策略。</li>
<li>写入策略。保证数据一致性并提高效率</li>
</ol>
<h3 id="地址映射">地址映射</h3>
<p><strong>地址映射</strong>是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cache<br />
Cache中要为每块加一个标记，指明它是主存中哪一块的副本；说明Cache行中的信息是否有效，每个Cache行需要一个有效位。</p>
<p>地址映射方式：</p>
<ol type="1">
<li><p>直接映射，主存中的每一块只能装入Cache中的唯一位置，若这个位置已有内容，原来的块将无条件地被替换出去(块冲突概率最高，空间利用率最低), 即：Cache行号=主存块号mod Cache总行数<br />
假设Cache有<span class="math inline">\(2^c\)</span>行，主存有<span class="math inline">\(2^m\)</span>块，主存块号的低c位正好是它要装入的Cache行号。给每个Cache行设置一个长为<code>t = m - c</code>的标记，当主存某块调入Cache后，就将其块号的高t位设置在对应Cache行的标记中<br />
如图，主存地址去除t位的剩下c位，就会对应实际上的Cache地址(如果有效的话)<br />
访存过程：</p>
<ol type="1">
<li>根据c位行号找到对应Cache行</li>
<li>比较标记与主存高t位标记，若相等且有效位为1，则命中，根据主存的低位地址读取信息</li>
<li>不等或有效位0，从主存读出地址的信息，送到对应Cache行，有效位置1，标记设为地址中高t位，数据送到CPU <img src="/assets/resources/Pasted%20image%2020240122112021.png" /></li>
</ol></li>
<li><p>全相联映射<br />
主存中的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块,所以CPU访存时需要与所有Cache行的标记进行比较<br />
优点是比较灵活,Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的比较速度较慢，实现成本较高<br />
<img src="/assets/resources/Pasted%20image%2020240122113344.png" /></p></li>
<li><p>组相联映射<br />
将Cache分成Q个大小相等的组，每个主存块可以装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式<br />
如图，当Q=1时变为全相联映射，当Q=Cache行数时变为直接映射.假设每组有r个Cache行,则称之为r路组相联<br />
Cache组号=主存块号 mod Cache组数(Q) 选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。<br />
<img src="/assets/resources/Pasted%20image%2020240122133449.png" /> 地址结构：</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th>标记</th>
<th>组号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>访存过程：</p>
<ol type="1">
<li>根据组号找到对应的组，将对应Cache组中每个行的标记与主存地址的高位标记进行比较，若相等且有效位1，则命中</li>
<li>不命中时，从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲行中，将有效位置1并设置标记，同时将该地址中的内容送CPU。</li>
</ol>
<p><strong>总结</strong><br />
三种映射方式中，直接映射的每个主存块只能映射到Cache中的某一固定行；全相联映射可以映射到所有Cache行；N路组相联映射可以映射到N行。当Cache大小、主存块大小一定时：</p>
<ul>
<li>直接映射的命中率最低，全相联映射的命中率最高</li>
<li>直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长</li>
<li>直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大</li>
</ul>
<h3 id="主存块的替换算法">主存块的替换算法</h3>
<p>直接映射时，主存块对应唯一行，无需考虑替换算法，其他两种情况则需要考虑</p>
<ol type="1">
<li>随机算法：随机地确定替换的Cache块，实现简单，但不符合局部性原理</li>
<li>先进先出算法：选择最早调入的行进行替换，优缺点同上</li>
<li>近期最少使用算法(LRU)：选择近期内长久未访问过的Cache行作为替换的行。对每个Cache行设置一个计数器，用计数值来记录主存块的使用情况，计数值的位数取组大小的对数，规则如下：
<ol type="1">
<li>命中时，所命中的行的计数器清零，比其低的计数器加1,其余不变;</li>
<li>未命中且还有空闲行时，新装入的行的计数器置0,其余全加1</li>
<li>未命中且无空闲行时，计数值为3的行的信息块被淘汰，新装行的块的计数器置0,其余全加1</li>
<li>当集中访问的存储区超过Cache组的大小时，LRU命中率可能变得很低，这种现象称为抖动</li>
</ol></li>
<li>最不经常使用算法：将一段时间内被访问次数最少的存储行换出,每行设置计数器，每访问一次，被访问的行计数器加1，每次替换选择计数最小的一行，类似LRU <img src="/assets/resources/Pasted%20image%2020240122134549.png" /></li>
</ol>
<h3 id="写策略">写策略</h3>
<p>当对Cache中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致，分为：</p>
<ul>
<li>全写法(写直通法、write-through)：当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。实现简单且准确，但效率较低
<ul>
<li>写缓冲：为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲(Write Buffer)，CPU同时写数据到Cache和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，频繁写入可能溢出</li>
</ul></li>
<li>回写法(write-back)：当CPU对Cache写命中时，只把数据写入Cache,而不立即写入主存，只有当此块被换出时才写回主存。增加效率，但有可能有不一致问题
<ul>
<li>每个Cache行设置一个修改位(脏位)。1表示修改过，替换时需要写回主存，为0则相反 <img src="/assets/resources/Pasted%20image%2020240122135305.png" alt="写缓冲示意图" /></li>
</ul></li>
</ul>
<p>不命中时也有两种情况：</p>
<ul>
<li>写分配法(write-allocate)。加载主存中的块到Cache中，然后更新这个Cache块。更符合局部性原理，但可能开销更大，一般和回写法合用</li>
<li>非写分配法(not-write-allocate)只写入主存，不进行调块。一般和全写法合用</li>
</ul>
<div class="note info"><p>现代Cache往往使用指令数据分离的多级Cache<br />
假定设3级Cache,按离CPU的远近可各自命名为L1 Cache&gt; L2 Cache&gt; L3 Cache。 离CPU越远，访问速度越慢，容量越大。<br />
指令Cache与数据Cache分离一般在L1级，此时通常为写分配法与回写法合用。<br />
下图是一个含有两级Cache的系统，L1 Cache对L2 Cache使用全写法，L2 Cache对主存使用回写法，由于L2 Cache的存在,其访问速度大于主存，因此避免了因频繁写时造成的写缓冲饱和溢出。<br />
<img src="/assets/resources/Pasted%20image%2020240122134749.png" /></p>
<p>较大的行可以利用空间局部性增加命中机会，但会放大未命中损失，在项数层面减少命中率</p>
<p>取指令缺失时：</p>
<ol type="1">
<li>程序计数器恢复当前指令的值。</li>
<li>对主存进行读的操作。</li>
<li>将读入的指令写入Cache中，更改有效位和标记位。</li>
<li>重新执行当前指令。</li>
</ol>
</div>
<div class="note warning"><ul>
<li>标记位地址映射时需要加一个有效位，这个数字乘以Cache行数就是地址映射表大小</li>
<li>当CPU访存时，先要到Cache中查看该主存地址是否在Cache中，所以发送的是主存物理地址。只有在虚拟存储器中，CPU发出的才是虚拟地址</li>
<li>Cache行数 = Cache数据区大小/主存块大小</li>
<li>Cache位数 = 数据位 + tag位(根据映射方式决定，数值上等于主存地址位数-组号/行号-块内地址位) + 1(脏位，根据写策略决定) +1(有效位，必然存在)</li>
<li>对空间局部性良好的连续数据和代码，访问Cache时会把之后会使用的数据调入主存，因此，这次调入的n个数据只有第一个是不命中的</li>
<li>n路相联映射就会需要n个标记位数的比较器来并行比较</li>
<li>有安全性要求时，采用全写法</li>
<li>脏位和有效位独立于tag位存在</li>
<li>全相联Cache，按先后顺序从0开始分配Cache行</li>
<li>一次读突发传送总线事务包括一次地址传送和若干次数据传送，地址传送用一个总线周期，如果是低位交叉读数据，就需要一整个存储周期(第一个存储器读数据)+<code>存储体数量*总线时间周期</code>(传输数据)</li>
<li><code>Cache命中时的一条指令执行时间=Cache命中时的CPI * 时钟周期</code></li>
<li>一条指令执行过程中因Cache缺失而导致的平均额外开销=<code>平均访存次数*Cache缺失率*一次读突发传送总线事务时间</code></li>
<li>物理地址可以同时是页号+偏移量，以及Cache中的块号(标记)+行号+块内地址</li>
</ul>
</div>
<h2 id="虚拟存储器">虚拟存储器</h2>
<p>虚拟存储器将主存或辅存的地址空间统一编址，使用虚拟地址时不用关系具体的地址空间和其实现<br />
用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。实际的主存单元地址称为实地址或物理地址<br />
<img src="/assets/resources/Pasted%20image%2020240123125249.png" /> CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，如果在，则需要进行地址映射，否则需要调入，或者进行置换算法<br />
虚拟存储机制采用全相联映射，每个虚页面可以存放到对应主存区域的任何一个空闲页位置，在处理一致性问题时，采用回写法</p>
<p>虚拟存储器分为页式，段式，和段页式</p>
<ol type="1">
<li>页式虚拟存储器，便于利用空间，实现简单，但最后一页会产生碎片</li>
</ol>
<p>以页为基本单位。虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页、页框，虚存的页称为虚页。虚拟地址分为两个字段：虚页号和页内地址。<br />
虚拟地址到物理地址的转换是由页表实现的。页表是一张存放在主存中的虚页号和实页号的对照表，一般驻留内存中<br />
如图，有效位表示是否调入主存中，脏位表示是否修改过，为1时需要把修改写回磁盘；引用位配合置换算法<br />
<img src="/assets/resources/Pasted%20image%2020240123125834.png" /> 页表基址寄存器存放进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项</p>
<ul>
<li>若装入位为1,则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址；</li>
<li>若装入位为0,则说明缺页，需要操作系统进行缺页处理。</li>
</ul>
<p><strong>快表TLB</strong><br />
由高速缓冲器组成，根据局部性原理缓存一些表项。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。 <img src="/assets/resources/Pasted%20image%2020240123130334.png" /> 快表通常采用全相联或组相联方式。每个TLB项由页表表项内容加上一个TLB标记字段组成,TLB标记用来表示该表项取自页表中哪个虚页号对应的页表项<br />
TLB标记的内容在全相联方式下就是该页表项对应的虚页号；组相联方式下则是对应虚页号的高位部分，而虚页号的低位部分用于选择TLB组的组索引<br />
如图，Cache采用二路组相联方式，TLB采用全相联方式，cpu给出虚拟地址后，比较虚页号和TLB标记字段，命中则通过TLB地址转换，否则查询主存页表，并调入或置换TLB。完成地址转换后，Cache根据上节的步骤，根据物理地址找到对应Cache行，将数据取送cpu<br />
<img src="/assets/resources/Pasted%20image%2020240123130559.png" /> 查找时，快表和慢表也可以同步进行<br />
可能的缺失情况：</p>
<ul>
<li>TLB缺失，没有对应页表项</li>
<li>Cache，访问的主存不在Cache</li>
<li>Page缺失，访问的页面不在主存 <img src="/assets/resources/Pasted%20image%2020240123130618.png" /> 第1种组合，此时无须访问主存；第2种和第3种组合都需要访问一次主存;第4种组合需要访问两次主存；第5种组合发生“缺页异常”，需要访问磁盘，并且至少访问两次主存。<br />
Cache缺失处理由硬件完成；缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现；而TLB缺失既可以用硬件又可以用软件来处理</li>
</ul>
<ol start="2" type="1">
<li><p>段式虚拟存储器<br />
段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两部分：段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度<br />
<img src="/assets/resources/Pasted%20image%2020240123145932.png" /> 给出虚拟地址后，根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存，调入时将起始地址和段内地址相加就是实际地址<br />
段式存储器具有逻辑独立性，易于编译、管理、修改，保护，多道程序的共享，但容易产生碎片</p></li>
<li><p>段页式虚拟存储器<br />
把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页.每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍,段的起点必须是某一页的起点<br />
虚地址分为段号、段内页号、页内地址三部分。CPU根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址<br />
可以按段实现共享和保护,但两次查表的开销较大</p></li>
</ol>
<div class="note info"><p><strong>虚拟存储器与Cache</strong></p>
<ol type="1">
<li>相同之处
<ol type="1">
<li>最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度</li>
<li>都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大</li>
<li>都有地址的映射、替换算法、更新策略等问题</li>
<li>依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中</li>
</ol></li>
<li>不同之处
<ol type="1">
<li>Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量</li>
<li>Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明</li>
<li>对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大</li>
<li>CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信</li>
</ol></li>
</ol>
</div>
<div class="note warning"><ul>
<li>虚存需要通过对操作系统实现地址映射，因此对操作系统的设计者即系统程序员是不透明的,只对应用程序员透明</li>
<li>Cache和TLB命中必然page命中，其他情况下则没有制约</li>
<li>缺页是在地址转换时CPU检测到的一种异常，缺页处理完成后回到发生缺页的指令继续执行</li>
<li>Cache由SRAM组成；TLB通常由相联存储器组成，也可由SRAM组成</li>
<li>主存与Cache之间的信息调度功能全部由硬件自动完成</li>
<li>组相联的TLB，需要把虚页号拆分成低位组号与高位标记，分开计算</li>
<li>虚拟地址的后若干位是通用的偏移量，可以根据这部分信息算出Cache组号等信息</li>
</ul>
</div>
<h1 id="指令">指令</h1>
<h2 id="概念-1">概念</h2>
<p>指令(机器指令)是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是指令集体系结构(ISA)中最核心的部分<br />
ISA规定的内容主要包括：指令格式，数据类型及格式，操作数的存放方式，程序可访问的寄存器个数、位数和编号,存储空间的大小和编址方式，寻址方式，指令执行过程的控制方式等。</p>
<h3 id="基本格式">基本格式</h3>
<table>
<thead>
<tr class="header">
<th>操作码字段</th>
<th>地址码字段</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>指令的长度是指一条指令中所包含的二进制代码的位数。指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数,与机器字长没有固定的关系,可分为单子长,半字长等</p>
<ol type="1">
<li>零地址指令
<ol type="1">
<li>不需要操作数</li>
<li>堆栈计算机中，操作数隐式地从栈顶和次栈顶弹出，结果隐式地压入堆栈</li>
</ol></li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="2" type="1">
<li>一地址指令，按地址取操作数，运算结束后放回原处；可隐含约定另一个操作数由ACC (累加器)提供，运算结果也将存放在ACC中</li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th><span class="math inline">\(A_1\)</span></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="3" type="1">
<li>二地址指令，分别给出目的操作数和源操作数的地址,目的操作数的地址保存本次运算结果</li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th><span class="math inline">\(A_1\)</span></th>
<th><span class="math inline">\(A_2\)</span></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="4" type="1">
<li>三地址指令，</li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th><span class="math inline">\(A_1\)</span></th>
<th><span class="math inline">\(A_2\)</span></th>
<th><span class="math inline">\(A_3(结果)\)</span></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="5" type="1">
<li>四地址指令,<span class="math inline">\(A_4\)</span>是下一条将要执行指令的地址</li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th><span class="math inline">\(A_1\)</span></th>
<th><span class="math inline">\(A_2\)</span></th>
<th><span class="math inline">\(A_3(结果)\)</span></th>
<th><span class="math inline">\(A_4(下址)\)</span></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="6" type="1">
<li>定长操作码指令，在指令字的最高位部分分配固定的若干位(定长)表示操作码。一般n位操作码字段的指令系统最大能够表示<span class="math inline">\(2^n\)</span>条指令。</li>
<li>扩展操作码指令<br />
变长操作码：指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上<br />
常见的变长操作码方法是扩展操作码：操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码<br />
注意点：</li>
</ol>
<ul>
<li>短码不能是长码的前缀</li>
<li>操作码不能重复 如图，把<code>1111</code>作为一种前缀表示操作码拓展到下个非1111的四位 <img src="/assets/resources/Pasted%20image%2020240124111231.png" /></li>
</ul>
<h3 id="操作类型">操作类型</h3>
<ul>
<li>数据传送</li>
<li>算术和逻辑运算</li>
<li>移位</li>
<li>转移操作，无条件转移(JMP)、条件转移(BRANCH)、调用(CALL)、返回(RET)、陷阱(TRAP)等，转移操作不返回执行，与调用指令根据返回地址返回主程序不同</li>
<li>I/O操作</li>
</ul>
<div class="note warning"><ul>
<li>PC存放当前欲执行指令的地址，而指令的地址码字段则保存操作数地址</li>
<li>程序控制类指令主要包括无条件转移、有条件转移、子程序调用和返回指令、循环指令等</li>
<li>按字节编址时指令长度应该是8的倍数</li>
<li>运算器的进位等硬件部分与ISA无关</li>
<li>求拓展操作码指令数的最值可以根据地址数由大到小的顺序列方程求解</li>
<li>可能的指令格式:操作码-寻址特征-位移量/操作数</li>
<li>使用扩展操作码时，设地址位数为n,地址指令操作码每减少一个，就可以多构成<span class="math inline">\(2^n\)</span>条一地址指令操作码；一地址指令操作码每减少一个，就可以多构成<span class="math inline">\(2^n\)</span>条零地址指令操作码</li>
</ul>
</div>
<h2 id="指令寻址方式">指令寻址方式</h2>
<p>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法 指令中的地址码字段称为形式地址(A)，结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址(EA)。 <code>(A)</code>表示地址为A的数值</p>
<p>寻址方式可分为：</p>
<ul>
<li>指令寻址
<ul>
<li>顺序寻址，程序计数器加一形成下一条指令地址</li>
<li>跳跃寻址，下条指令地址由本条指令给出计算方式，修改PC值，根据修改后的PC定位指令</li>
</ul></li>
<li>数据寻址 ，用操作数地址通过某些方法得出地址</li>
</ul>
<h3 id="数据寻址的分类">数据寻址的分类</h3>
<p>指令格式：</p>
<table>
<thead>
<tr class="header">
<th>操作码</th>
<th>寻址特征</th>
<th>形式地址A</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol type="1">
<li><p>隐含寻址，在指令中隐含操作数的地址，例如使用累加器作为第二操作数地址<br />
有利于缩短指令字长；但需增加存储操作数或隐含地址的硬件。 <img src="/assets/resources/Pasted%20image%2020240125183517.png" /></p></li>
<li><p>立即数寻址，指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数，采用补码表示<br />
指令在执行阶段不访问主存，指令执行时间最短；但A的位数限制了立即数的范围</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th>OP</th>
<th>立即寻址特征</th>
<th>立即数</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ol start="3" type="1">
<li><p>直接寻址，指令字中的形式地址A是操作数的真实地址EA,即EA = A <img src="/assets/resources/Pasted%20image%2020240125183707.png" /> 指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址，但A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改</p></li>
<li><p>间接寻址，地址字段给出操作数有效地址所在的存储单元的地址，即EA=(A) <img src="/assets/resources/Pasted%20image%2020240125183803.png" /> 图中，主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为0时，表示取得的是操作数的地址<br />
可扩大寻址范围,便于编制程序(用间接寻址可方便地完成子程序返回);但指令在执行阶段要多次访存，相比寄存器间接寻址不常用</p></li>
<li><p>寄存器寻址，指令字中直接给出操作数所在的寄存器编号，即EA = Ri<br />
寄存器少所以指令可以较短，执行速度快，支持向量/矩阵运算；但寄存器个数有限</p></li>
<li><p>寄存器间接寻址，在寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(Ri) <img src="/assets/resources/Pasted%20image%2020240125184233.png" /> 与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存</p></li>
<li><p>相对寻址,PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA =(PC)+A,A是相对于当前PC值的位移量,补码表示 <img src="/assets/resources/Pasted%20image%2020240125184328.png" /> 操作数的地址随PC值的变化而变化,与指令地址之间总是相差一个固定值，因此便于程序浮动,适用于转移指令<br />
例如，对于转移指令JMP A,当CPU从存储器中取出一字节时，会自动执行(PC)+1-&gt;PC。<br />
若转移指令的地址为X,且占2B,在取出该指令后，PC的值会增2,即(PC) = X + 2,这样在执行完该指令后，会自动跳转到X + 2+A的地址继续执行</p></li>
<li><p>基址寻址,CPU中基址寄存器(BR)的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(BR)+A。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器 <img src="/assets/resources/Pasted%20image%2020240125184543.png" /> 基址寄存器内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变(作为基地址),形式地址可变(作为偏移量)。<br />
可扩大寻址范围(基址寄存器的位数大于形式地址A的位数)；用户不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序,但偏移量(形式地址A)的位数较短</p></li>
<li><p>变址寻址，有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，即EA =(IX) + A,其中IX为变址寄存器(专用)，也可用通用寄存器作为变址寄存器<br />
在程序执行过程中，变址寄存器的内容可由用户改变(作为偏移量)，形式地址A不变(作为基地址)。<br />
可扩大寻址范围(寄存器位数大于A位数，足以表示整个存储空间)，适合循环程序<br />
基址寄存器其值不可变，而执行中指令字中的A是可变的；变址寄存器的内容由用户设定，其值在程序执行中可变，而指令字中的A是不可变的<br />
<img src="/assets/resources/Pasted%20image%2020240125184736.png" /></p></li>
<li><p>堆栈寻址 <img src="/assets/resources/Pasted%20image%2020240125184742.png" /> 堆栈区由特定的寄存器——堆栈指针SP管理</p></li>
</ol>
<ul>
<li>寄存器堆栈又称硬堆栈，成本较高</li>
<li>主存划出一定区域作为堆栈是软堆栈</li>
</ul>
<p>使用堆栈的系统，一般指令无操作数，隐含使用堆栈的push,pop作为操作数</p>
<div class="note warning"><ul>
<li>采用不同寻址方式的目的是为了缩短指令字长，扩大寻址空间</li>
<li>以低字节为字地址的存放方式即是小端方式</li>
<li>进、出堆栈时对栈顶指针的操作顺序相反，如果进栈是先数据再指针，出栈就是先指针后数据</li>
<li>相对寻址中，由于取出本条指令时，PC会自增到下一条指令，因此偏移量加上下一条指令地址才是有效地址</li>
<li>跳跃寻址可以实现程序的条件或无条件转移</li>
<li>程序计数器(PC)给出下一条指令字的访存地址(指令在内存中的地址)，因此取决于存储器的字数；指令寄存器(IR)用于接收取得的指令，因此取决于指令字长</li>
<li>无符号减法中出现进位/借位表明被减数更大</li>
<li>sizeof (数据类型)，指的是占用的存储单元，也就是编址的单位</li>
<li>内存地址都是无符号数</li>
<li>相对寻址转移指令的转移范围取决于PC与偏移量范围的和(主存地址)，且必须&gt;=0</li>
<li>转移指令计算转移地址，需要对偏移量进行符号拓展,逻辑左移(看指令字长与编址关系)，并与自增后的PC相加得到转移地址，与标志位一起送到多路选择器进行转移的判断</li>
<li>除了用不同操作码，不同地址数的指令也可以把用不到的操作数地址位全部填0表示操作数个数 <img src="/assets/resources/Pasted%20image%2020240128210356.png" /></li>
</ul>
</div>
<h2 id="汇编">汇编</h2>
<p>x86处理器中有8个32位的通用寄存器，汇编指令一般有AT&amp;T与intel格式两类<br />
<img src="/assets/resources/Pasted%20image%2020240128214452.png" /><br />
八个32位通用寄存器EAX(4B)等可拆为AX(2B),AX可拆为AH,AL(1B)用：</p>
<ul>
<li>EAX(AX) 累加寄存器(Accumulator)</li>
<li>EBX(BX) 基地址寄存器 (Base Register)</li>
<li>ECX(CX) 计数寄存器(Count Register)</li>
<li>EDX(DX) 数据寄存器(Data Register)</li>
<li>ESI EDI 变址寄存器(Index Register)</li>
<li>EBP 堆栈基指针(Base Pointer)</li>
<li>ESP 堆栈顶指针(Stack Pointer)</li>
</ul>
<p><strong>常见名词</strong>：<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;reg&gt;表示任意寄存器，形如&lt;reg32&gt;表示32位寄存器</span><br><span class="line">&lt;mem&gt;表示内存地址，包括一些简单表达式</span><br><span class="line">&lt;con&gt;表示常识，如&lt;con8&gt;表示8位常数</span><br><span class="line">[n]表示n对应内存地址的数据，其中n可能是寄存器的值,AT&amp;T使用()表示内存地址数据</span><br><span class="line">R[r]表示寄存器r的内容，M[addr]表示主存单元addr的内容</span><br></pre></td></tr></table></figure> x86中的指令机器码长度为1字节，对同一指令的不同用途有多种编码方式</p>
<h3 id="常见指令">常见指令</h3>
<p><strong>mov</strong>:复制数据，但不能用于直接从内存复制到内存 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov &lt;reg&gt;, &lt;reg&gt;</span><br><span class="line">mov &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">mov &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">mov &lt;mem&gt;, &lt;con&gt;</span><br><span class="line">mov &lt;reg&gt;, &lt;con&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">mov eax, ebx</span><br><span class="line">mov byte ptr [var] , 5 </span><br></pre></td></tr></table></figure></p>
<p><strong>lea</strong>:将一个内存地址(而不是其所指的内容)加载到目的寄存器</p>
<p><strong>pop</strong>:将push压入的操作数取出，然后(<strong>这里与push顺序相反</strong>)ESP+4<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push &lt;reg32&gt;</span><br><span class="line">push &lt;mem&gt;</span><br><span class="line">push &lt;con32&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">push [var]</span><br><span class="line">pop [ebx]</span><br></pre></td></tr></table></figure></p>
<p><strong>add/sub</strong>:运算结果均保存到第一个操作数<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add/sub &lt;reg&gt;, &lt;reg&gt; </span><br><span class="line">add/sub &lt;reg&gt;, &lt;mem&gt; </span><br><span class="line">add/sub &lt;mem&gt;, &lt;reg&gt; </span><br><span class="line">add/sub &lt;reg&gt;, &lt;con&gt;</span><br><span class="line">add/sub &lt;mem&gt;&lt; &lt;con&gt; </span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">sub eax, 10</span><br><span class="line">add byte ptr [var], 10    //10与var值指示的内存地址的一字节值相加，并将结果保存在var值指示的内存地址的字节中</span><br></pre></td></tr></table></figure></p>
<p><strong>inc/dec</strong>:自增/自减 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inc/dec &lt;reg&gt;</span><br><span class="line">inc/dec &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">dec eax</span><br><span class="line">inc dword ptr [var] //dword表示四字节的值</span><br></pre></td></tr></table></figure></p>
<p><strong>imul</strong>:带符号整数乘法,<strong>第一个操作数必须是寄存器</strong>,三操作数版本将后两者的乘积存入第一个操作数,可能溢出，溢出时OF置1<br />
<strong>idiv</strong>:有符号整数除法指令，唯一的操作数是除数，被除数则为edx:eax中的内容(共64位)，操作结果的商送到eax,余数则送到edx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">imul &lt;reg32&gt;, &lt;reg32&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;mem&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;reg32&gt;, &lt;con&gt;</span><br><span class="line">imul &lt;reg32&gt;, &lt;mem&gt;, &lt;con&gt;</span><br><span class="line"></span><br><span class="line">idiv &lt;reg32&gt;</span><br><span class="line">idiv &lt;mem&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">imul eax, [var]</span><br><span class="line">imul esi, edi, 25</span><br><span class="line"></span><br><span class="line">idiv ebx</span><br><span class="line">idiv dword ptr [var]</span><br></pre></td></tr></table></figure>
<p><strong>and/or/xor</strong>:逻辑与，或，异或,用法一样，结果放到第一个操作数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">and &lt;reg&gt;, &lt;reg&gt; </span><br><span class="line">and &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">and &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">and &lt;reg&gt;, &lt;con&gt;</span><br><span class="line">and &lt;mem&gt;, &lt;con&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">and eax, 00H</span><br></pre></td></tr></table></figure></p>
<p><strong>not</strong>,对所有位取非;<strong>neg</strong>对值取负数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">not/neg &lt;reg&gt;/&lt;mem&gt;</span><br><span class="line">eg.</span><br><span class="line">not byte ptr [var]</span><br><span class="line">neg eax</span><br></pre></td></tr></table></figure></p>
<p><strong>shl/shr</strong>:逻辑移位，移动第一个操作数的位数是第二操作数的值 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shl &lt;reg&gt;, &lt;con8&gt; / shr &lt;reg&gt;, &lt;con8&gt;</span><br><span class="line">shl &lt;mem&gt;, &lt;con8&gt; / shr &lt;mem&gt;, &lt;con8&gt;</span><br><span class="line">shl &lt;reg&gt;, &lt;cl&gt; / shr &lt;reg&gt;, &lt;cl&gt;</span><br><span class="line">shl &lt;mem&gt;, &lt;cl&gt; / shr &lt;mem&gt;, &lt;cl&gt;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">shl eax, 1</span><br><span class="line">shr ebx, cl</span><br></pre></td></tr></table></figure></p>
<h3 id="控制指令">控制指令</h3>
<p><strong>jmp</strong>:跳转到label指示的地址的指令执行 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp &lt;label&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>jcondition</strong>:根据cpu状态字条件转移 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">je &lt;label&gt; (jump when equal)</span><br><span class="line">jne &lt;label&gt; (jump when not equal)</span><br><span class="line">jz &lt;label&gt; (jump when last result was zero)</span><br><span class="line">jg &lt;label&gt; (jump when greater than)</span><br><span class="line">jge &lt;label&gt; (jump when greater than or equal to)</span><br><span class="line">j1 &lt;label&gt; (jump when less than)</span><br><span class="line">jle &lt;label&gt; (jump when less than or equal to)</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">cmp eax, ebx</span><br><span class="line">jle done  //eax&lt;=ebx时跳转到done</span><br></pre></td></tr></table></figure></p>
<p><strong>cmp/test</strong>:根据运算结果设置cpu状态字，其中cmp相当于不保存结果的sub,test对操作数进行逐位与运算<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmp &lt;reg&gt;, &lt;reg&gt; </span><br><span class="line">cmp &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line">cmp &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line">cmp &lt;reg&gt;, &lt;con&gt; </span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">jz eax, eax #测试eax是否是0</span><br><span class="line">jz xxxx  #为零则置标志ZF为1,转跳到xxxx处执行</span><br></pre></td></tr></table></figure></p>
<h4 id="过程调用">过程调用</h4>
<p><strong>call/ret</strong>:call将当前指令地址入栈，随后无条件转移到label(保存调用之前的地址),ret用于返回到之前保存的指令地址(通过出栈原先指令的地址并无条件转移并执行) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call &lt;label&gt;</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p>
<p>过程P调用过程Q的执行步骤：</p>
<ol type="1">
<li>P将入口参数(实参)放到Q能访问到的地方。</li>
<li>P将返回地址存到特定的地方，然后将控制转移到Q。(<code>call</code>指令)</li>
<li>Q保存P的现场(通用寄存器的内容)，并为自己的非静态局部变量分配空间。</li>
<li>执行过程Q。</li>
<li>Q恢复P的现场，将返回结果放到P能访问到的地方，并释放局部变量所占空间。</li>
<li>Q取出返回地址，将控制转移到P。(<code>ret</code>)</li>
</ol>
<p>调用者和被调用者需共享(用户可见的)寄存器，规定：</p>
<ul>
<li>寄存器EAX、ECX和EDX是调用者保存寄存器，当P调用Q时，若Q需用到这些寄存器，则由P将这些寄存席的内容保存到栈中，并在返回后由P恢复它们的值</li>
<li>寄存器EBX、ESI和EDI是被调用者保存寄存器，当P调用Q时，Q必须先将这些寄存器的内容保存在栈中才能使用它们，并在返回P之前先恢复它们的值</li>
</ul>
<p>每个过程都有自己的栈区，称为栈帧，一个栈由若干栈帧组成,寄存器EBP指示栈帧的起始位置，寄存器ESP指示栈顶，栈从高地址向低地址增长,出入栈只更改ESP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leave指令功能相当于以下两条指令的功能：</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>
<h3 id="选择指令">选择指令</h3>
<p><strong>if-else</strong>: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(test expr) # test_expr是一个整数表达式，它的取值为0 (假)，或为非0 (真)</span><br><span class="line">then_statement</span><br><span class="line">else</span><br><span class="line">else_statement</span><br><span class="line"></span><br><span class="line">即过程：</span><br><span class="line">t=test expr;</span><br><span class="line">if (!t)</span><br><span class="line">    goto false;</span><br><span class="line">then_statement</span><br><span class="line">goto done;</span><br><span class="line">false:</span><br><span class="line">else_statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></p>
<h3 id="循环指令">循环指令</h3>
<p><strong>do-while</strong>和<strong>while</strong>: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">    body_statement</span><br><span class="line">    while(test_expr);</span><br><span class="line"></span><br><span class="line">while (test_expr) </span><br><span class="line">    body_statement</span><br><span class="line">#while与do-while的不同:第一次执行body_statement之前，就会测test_expr的值，循环有可能中止</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">do-while的过程:</span><br><span class="line">loop:</span><br><span class="line">body_statement</span><br><span class="line">t=test_expr;</span><br><span class="line">if (t)</span><br><span class="line">    goto loop;</span><br><span class="line"></span><br><span class="line">while的过程:</span><br><span class="line">t=test_expr;</span><br><span class="line">if (!t)</span><br><span class="line">    goto done;</span><br><span class="line">loop:</span><br><span class="line">body_statement</span><br><span class="line">t=test_expr;</span><br><span class="line">if(t)</span><br><span class="line">    goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></p>
<p><strong>for</strong>: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for(init expr; test expr; update expr)</span><br><span class="line">    body statement</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">init expr;</span><br><span class="line">t=test_expr;</span><br><span class="line">if(!t)</span><br><span class="line">    goto done;</span><br><span class="line">loop:</span><br><span class="line">body_s tatement</span><br><span class="line">update expr;</span><br><span class="line">t=test_expr;</span><br><span class="line">if(t)</span><br><span class="line">    goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure></p>
<h2 id="指令系统">指令系统</h2>
<ul>
<li>复杂指令系统计算机(CISC)，典型如x86架构
<ul>
<li>数量一般200以上</li>
<li>长度不定，格式，寻址方式较多</li>
<li>访存的指令不受限制</li>
<li>指令使用频度差别大，执行时间差别大，显示出二八定律，但也可以实现指令流水线</li>
<li>控制器大多用微程序控制</li>
<li>难以优化编译</li>
</ul></li>
<li>精简指令系统计机(RISC),典型的有ARM、MIPS架构的计算机
<ul>
<li>指令较简单，复杂功能需要组合，一般少于100</li>
<li>长度固定，格式更少</li>
<li>只有Load/Store指令可以访存，其他指令用寄存器进行</li>
<li>cpu的通用寄存器更多</li>
<li>必须实现指令流水线，指令时间较短</li>
<li>硬布线控制为主，少见微程序</li>
<li>重视编译优化</li>
</ul></li>
</ul>
<p>RISC的优点：</p>
<ul>
<li>更能充分利用VLSI芯片的面积，硬布线逻辑比微程序控制器占地更小</li>
<li>提高运算速度，(指令长度一致、按边界对齐存放、仅Load/Store指令访存便于形成流水线)</li>
<li>便于设计，成本低且可靠</li>
<li>利于编译程序代码优化</li>
</ul>
<h1 id="cpu">cpu</h1>
<h2 id="基本功能结构">基本功能结构</h2>
<p>中央处理器(CPU)由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令；运算器的功能是对数据进行加工。基本功能有：</p>
<ul>
<li>指令控制，即程序的顺序控制</li>
<li>操作控制，控制各个部件按指令的要求动作</li>
<li>时间控制(提供按时间顺序的控制信号)</li>
<li>数据加工，算术与逻辑运算</li>
<li>中断处理</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240128220028.png" /></p>
<h3 id="运算器">运算器</h3>
<ul>
<li>算术逻辑单元</li>
<li>暂存寄存器，寄存主存读来的数据(对应用程序员透明)</li>
<li>累加寄存器ACC，通用寄存器，可作为加法的输入，可暂存ALU运算信息</li>
<li>通用寄存器组，AX,BX,CX,DX,SP等，存放数据，其中SP是堆栈指针，指示栈顶地址</li>
<li>程序状态字寄存器PSW，存放溢出标志OF,符号SF,零ZF,进位CF</li>
<li>移位器，进行移位运算</li>
<li>计数器CT，控制乘除的操作步数</li>
</ul>
<h3 id="控制器">控制器</h3>
<p>指挥全机协调工作，基本功能是执行指令,指令的执行是由控制器发出的一组微操作实现的，分为硬布线与微程序控制器</p>
<ul>
<li>程序计数器PC，指出欲执行指令在主存的存放地址，可以自增</li>
<li>指令寄存器IR，保存当前正在执行的指令</li>
<li>指令译码器，对操作码字段译码</li>
<li>存储器地址寄存器MAR</li>
<li>存储器数据寄存器MDR</li>
<li>时序系统，产生时序信号，用统一时钟分频得到</li>
<li>微操作信号发生器，根据IR内容，PSW内容与时序信号，产生各种控制信号</li>
</ul>
<p>通用寄存器组、程序状态字寄存器，程序计数器对用户可见，且可编程<br />
存储器地址寄存器、存储器数据寄存器、指令寄存器对用户透明，不可对其编程</p>
<div class="note warning"><ul>
<li>CPU的位数n与数据总线线数相等</li>
<li>PC的值可以在cpu执行指令过程的取指周期修改</li>
<li>转移指令需要判断转移是否成功，不成功的话下一条指令依旧是自增地址</li>
<li>程序计数器存放指令地址，需要和存储器地址位数一致</li>
<li>指令寄存器可以被用户编程，不能由通用寄存器代替</li>
<li>间址周期结束时，CPU内寄存器MDR中的内容为操作数地址</li>
</ul>
</div>
<h2 id="指令执行过程">指令执行过程</h2>
<p>CPU从主存中取出并执行一条指令的时间称为指令周期，常用若干机器周期(cpu周期)来表示，一个机器周期又包含若干时钟周期<br />
每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等<br />
如果使用中断机制，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，又称中断周期<br />
<img src="/assets/resources/Pasted%20image%2020240130232317.png" /> 带有间址周期、中断周期的指令周期：</p>
<table>
<thead>
<tr class="header">
<th>取指周期</th>
<th>间址周期</th>
<th>执行周期</th>
<th>中断周期</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>其中，取指周期访存取指令，间址周期取有效地址，执行周期取操作数，中断周期保存程序断点<br />
为了区别不同的工作周期，在CPU内设置4个标志触发器FE、IND、EX和INT,它们分别对应取指、间址、执行和中断周期，并以“1”状态表示有效<br />
<em>中断周期中的进栈操作是将SP减1(堆栈都是向低地址增加)</em></p>
<p><strong>数据流</strong><br />
数据流是根据指令要求依次访问的数据序列。</p>
<ol type="1">
<li><p>取指周期 <img src="/assets/resources/Pasted%20image%2020240130232819.png" /></p></li>
<li><p>间址周期 例如一次间址中，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。<br />
间址周期的数据流向如下:</p>
<ol type="1">
<li>Ad(IR)(或MDR)①MAR②地址总线③主存。</li>
<li>CU发出读命令④控制总线⑤主存。</li>
<li>主存⑥数据总线⑦MDR (存放有效地址)。<br />
其中 ,Ad(IR)表示取出IR中存放的指令字的地址字段。<br />
<img src="/assets/resources/Pasted%20image%2020240130233021.png" /></li>
</ol></li>
<li><p>执行周期 取操作数，并根据IR中的指令字的操作码通过ALU操作产生执行结果</p></li>
<li><p>中断周期<br />
处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据<br />
断点 <img src="/assets/resources/Pasted%20image%2020240130233135.png" /></p></li>
</ol>
<p>指令执行方案：</p>
<ul>
<li>单指令周期。所有指令都选用相同的执行时间来完成，串行完成，每条花费一个时钟周期，因此时钟周期取决于时间最长的指令</li>
<li>多指令周期。不同类型的指令选用不同的执行步骤，称为多指令周期方案，串行执行，但可以用不同时钟周期来完成不同指令</li>
<li>流水线方案。指令可以并行执行，尽可能让每个时钟脉冲周期内完成一条指令的执行过程，让多条指令同时运行，但各自处在不同的执行步骤中</li>
</ul>
<div class="note warning"><ul>
<li>转移指令的原理是更改PC，因此指令地址总是PC的值</li>
<li>机器周期通常由存取周期(相对最长)确定</li>
<li>取指周期和操作只和指令字长(与存储字长的大小关系)有关</li>
<li>冯•诺依曼计算机根据指令周期的不同阶段来区分从存储器取出的是指令还是数据</li>
</ul>
</div>
<h2 id="数据通路">数据通路</h2>
<p>数据在功能部件之间传送的路径称为数据通路，包括数据通路上流经的部件<br />
<strong>基本结构</strong>：</p>
<ul>
<li>CPU内部单总线方式。将所有寄存器的输入端和输出端都连接到一条公共通路上，存在冲突问题，性能差</li>
<li>CPU内部多总线方式。将所有寄存器的输入端和输出端都连接到多条公共通路上</li>
<li>专用数据通路方式。根据指令执行过程中的数据和地址的流动方向安排连接线路，硬件多但效率高 <img src="/assets/resources/Pasted%20image%2020240131152608.png" /> 图中，字母加“in”表示该部件的允许输入控制信号;字母加“out”表示该部件的允许输出控制信号。<br />
内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存和各类I/O接口间互相连接的总线。</li>
</ul>
<p><strong>组成</strong>：</p>
<ol type="1">
<li>组合逻辑元件(操作元件)，任何时刻产生的输出仅取决于当前的输入。组合电路不含存储信号的记忆单元，也不受时钟信号的控制，输出与输入之间无反馈通路，信号是单向传输的,包括：
<ol type="1">
<li>加法器</li>
<li>ALU</li>
<li>译码器(操作码或地址码译码,n位输入转化成 <span class="math inline">\(2^n\)</span> 个输出)</li>
<li>多路选择器(控制信号<code>Select</code>来确定选择哪个输入被输出)</li>
<li>三态门(控制信号<code>EN</code>决定信号线的通断)</li>
</ol></li>
<li>时序逻辑元件(状态元件)：任何时刻的输出不仅与该时刻的输入有关，还与该时刻以前的输入有关，包含存储信号的记忆单元，在时钟节拍下工作。包括：
<ol type="1">
<li>通用寄存器组</li>
<li>PC</li>
<li>状态/移位/暂存/锁存寄存器</li>
</ol></li>
</ol>
<p><strong>过程</strong>：</p>
<ol type="1">
<li><p>寄存器之间的数据传送(在寄存器和总线之间有两个控制信号：Rin和Rout,in信号使总线向寄存器R输入数据，out信号让寄存器输出数据给总线)<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(PC) -&gt; MAR   //PCout 和 MARin 有效,PC内容-&gt;MAR</span><br></pre></td></tr></table></figure></p></li>
<li><p>主存与cpu的数据传送<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">取指阶段：</span><br><span class="line">(PC) -&gt; MAR  //PCout 和 MARin 有效,PC 内容-&gt;MAR</span><br><span class="line">1 -&gt; R   //CU发读命令</span><br><span class="line">MEM(MAR) -&gt; MDR  (PC)+1-&gt;PC   //MDRin有效</span><br><span class="line">(MDR) -&gt; IR      //MDRout和IRin有效,现行指令-&gt;IR</span><br><span class="line"></span><br><span class="line">将数据写入主存:</span><br><span class="line">(R1) -&gt; MDR      //R1out 和 MDRin 有效</span><br><span class="line">(R2) -&gt; MAR        //R2out 和 MARin 有效</span><br><span class="line">MDR -&gt; MEM(MAR)   //MDRout有效，CU发出写命令</span><br></pre></td></tr></table></figure></p></li>
<li><p>算术或逻辑运算,alu没有存储功能，相加的两个数必须在ALU的两个输入端同时有效，所以需要暂存区Y<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(MDR) -&gt; MAR  //MDRout和MARin有效，操作数有效地址→MAR</span><br><span class="line">1 -&gt; R        //CU发读命令</span><br><span class="line">MEM(MAR) -&gt; MDR     //操作数从存储器→MDR</span><br><span class="line">(MDR) -&gt; Y      //MDRout和Yin有效，操作数→Y</span><br><span class="line">(ACC) + (Y) -&gt; Z    //ACCout和ALUin有效，CU向ALU发加命令，结果-&gt;Z</span><br><span class="line">(Z) -&gt; ACC      //Zout和ACCin有效，结果→ACC</span><br></pre></td></tr></table></figure></p></li>
</ol>
<div class="note warning"><ul>
<li>单总线数据通路将所有寄存器的输入输出端都连接在一条公共通路上，一个时钟内只允许一次操作,无法用于单周期处理器</li>
<li>内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存和各类I/O接口间互相连接的总线</li>
<li>一个时钟周期内控制信号并不会变化</li>
<li>数据通路包括ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑</li>
<li>ALU内部没有寄存器，需要计算时一般一个暂存器输入加上总线直接输入，并用一个控制信号来表示运算类型(Add,Sub等)</li>
<li>信号SRout所控制的部件是一个三态门，用于控制移位器与总线之间数据通路的连接与断开</li>
<li>总线可以通过一个二路选择器连接ALU的输入端，一个用来PC自增，一个用来输入ALU</li>
</ul>
</div>
<h2 id="控制器-1">控制器</h2>
<p><strong>主要连接关系</strong>：</p>
<ol type="1">
<li>运算器部件通过数据总线与内存储器，IO设备传送数据</li>
<li>IO设备通过接口电路与总线相连</li>
<li>存储器，IO设备与地址，控制，数据总线连接</li>
<li>控制器从数据线接受指令，从运算器接受指令转移地址，送地址到地址总线，并产生控制信号</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240201115435.png" /> 控制器的主要功能：</p>
<ol type="1">
<li>从主存取指令，并指出下一个指令的地址</li>
<li>对指令译码，产生控制信号</li>
<li>指挥主存，CPU，IO设备的数据流动方向</li>
</ol>
<p>根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器,两者的PC和IR相同</p>
<h3 id="硬布线控制器">硬布线控制器</h3>
<p><img src="/assets/resources/Pasted%20image%2020240201153814.png" /> CU的输入信号来源:</p>
<ol type="1">
<li>指令译码器译码产生的指令信息</li>
<li>时序系统产生的机器周期信号和节拍信号</li>
<li>来自执行单元的反馈信息,即标志。</li>
<li>系统总线(控制总线)的控制信号</li>
</ol>
<p>CU的输入来自操作码译码电路ID、节拍发生器及状态标志，其输出到CPU内部或外部控制总线上</p>
<p><strong>时序系统</strong>：</p>
<ol type="1">
<li>时钟周期，时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。</li>
<li>机器周期。机器周期可视为所有指令执行过程中的一个基准时间。通常以存取周期作为基准时间(从存储器读一个指令字)在一个机器周期里可完成若干微操作</li>
<li>指令周期</li>
<li>微操作命令分析，需要发出各种操作命令(控制信号)序列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">取指周期：</span><br><span class="line">(PC) -&gt; MAR 现行指令地址-&gt;MAR</span><br><span class="line">1-&gt; R 命令存储器读</span><br><span class="line">M (MAR) -&gt; MDR 现行指令从存储器中读至MDR</span><br><span class="line">(MDR) -&gt;IR 现行指令-&gt;IR</span><br><span class="line">OP (IR) -&gt; CU 指令的操作码-&gt;CU译码</span><br><span class="line">(PC) + 1 -&gt; PC 形成下一条指令的地址</span><br><span class="line"></span><br><span class="line">间址周期:</span><br><span class="line">Ad(IR) -&gt;MAR 将指令字中的地址码(形式地址)-&gt;MAR</span><br><span class="line">1-&gt;R 命令存储器读</span><br><span class="line">M (MAR) -&gt; MDR 将有效地址从存储器读至MDR</span><br><span class="line"></span><br><span class="line">执行周期视指令而定</span><br><span class="line"></span><br><span class="line">如加法：</span><br><span class="line">Ad (IR)-&gt;MAR, 1-&gt;R</span><br><span class="line">M(MAR) -&gt; MDR</span><br><span class="line">(ACC) + (MDR)-&gt;ACC</span><br><span class="line"></span><br><span class="line">存数:</span><br><span class="line">Ad (IR)-&gt;MAR, 1-&gt;W</span><br><span class="line">(ACC) -&gt; MDR</span><br><span class="line">(MDR)-&gt;M(MAR)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>控制方式</strong>：</p>
<ul>
<li>同步控制，系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号,一般最长的操作序列为标准，使用相同的节拍为机器周期，电路简单但低效</li>
<li>异步控制，不存在基准时标信号，部件间用应答方式联络，速度快但电路复杂</li>
<li>联合控制，不同的指令大部分同步控制，少部分异步控制</li>
</ul>
<div class="note "><p><strong>设计步骤</strong>：</p>
<ol type="1">
<li>列出操作时间表，包括各个机器周期、节拍下的每条指令完成的微操作控制信号</li>
<li>微操作信号综合，根据时间表写出各个操作控制信号的逻辑表达式，如<code>微操作控制信号=机器周期^节拍^脉冲^操作码人机器状态条件</code></li>
<li>画出微操作命令的逻辑图,并用逻辑门电路实现。</li>
</ol>
<p>表中FE、IND和EX为CPU工作周期标志，T0〜T2为节拍，I为间址标志,指令若有表中所列出的微操作命令，其对应的单元格内为1<br />
取指周期的T2时刻,若测得I=1,则IND触发器置“1”，标志进入间址周期；若I= 0,则EX触发器置“1”,标志进入执行周期。同理，在间址周期的T2时刻，若测得IND = 0(表示一次间接寻址),则EX触发器置“1”，进入执行周期；若测得IND=1 (表示多次间接寻址)，则继续间接寻址。在执行周期的T2时刻，CPU要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则INT触发器置“1”，标志进入中断周期。<br />
<img src="/assets/resources/Pasted%20image%2020240201155051.png" /></p>
</div>
<h3 id="微程序控制器">微程序控制器</h3>
<p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，每条机器指令转化成为一段微程序并存入一个专门的存储器(控制存储器)中，微操作控制信号由微指令产生。</p>
<div class="note info"><p><strong>一些名词</strong></p>
<p>一条机器指令可以分解成一个<strong>微操作</strong>序列，<strong>微操作</strong>是原子化不可分的操作，微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为<strong>微命令</strong>，是构成控制序列的最小单位<br />
微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。<br />
可以同时产生的微命令是<strong>相容</strong>的，否则是<strong>互斥</strong>的，这是相互之间的关系，一个微命令可以和一些相容，一些互斥</p>
<p><strong>微指令</strong>是若干微命令的集合。存放微指令的控制存储器的单元地址称为<strong>微地址</strong>。执行一条微指令的时间称为<strong>微周期</strong>，一般是一个时钟周期<br />
微指令的构成：</p>
<ul>
<li>操作控制字段，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。</li>
<li>顺序控制字段，又称微地址码字段，用于控制产生下一条要执行的微指令地址。</li>
</ul>
<p><strong>主存储器</strong>用于存放程序和数据，在CPU外部，用RAM实现;<strong>控制存储器</strong>(CM)用于存放微程序，在CPU内部，用ROM实现。</p>
<p><strong>程序</strong>是指令的有序集合，用于完成特定的功能；<strong>微程序</strong>是微指令的有序集合，一条指令的功能由一段微程序来实现。<br />
微程序由微指令组成，用于描述机器指令，实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，对程序员透明。程序最终由机器指令组成</p>
<p>与MAR和IR对标的是<strong>微地址寄存器</strong>CMAR(存放控制存储器的读/写微指令的地址)与<strong>微指令寄存器</strong>CMDR/μIR(存放控制存储器读出的微指令)</p>
</div>
<p><img src="/assets/resources/Pasted%20image%2020240202151001.png" /></p>
<p><strong>基本组成</strong></p>
<ol type="1">
<li>控制存储器CM，存放微程序，用ROM构成</li>
<li>微指令寄存器，存放CM取出的微指令，位数等于微指令字长</li>
<li>微地址形成部件，形成微地址，保证其连续进行</li>
<li>微地址寄存器，接受地址形成部件送来的微地址</li>
</ol>
<p><strong>工作过程</strong></p>
<ol type="1">
<li>执行取微指令操作，将机器启动时，取指微程序入口地址(一般是CM的0号单元)送入CMAR，从CM读出微指令送入CMDR，取指微程序执行过程中，主存取出的机器指令会被存入IR</li>
<li>机器指令操作码通过微地址形成部件产生该指令对应的微程序入口地址，送入CMAR</li>
<li>CM逐条取出微指令执行</li>
<li>执行完一个微程序后，回到1.继续循环</li>
</ol>
<p>通常，一条机器指令对应一个微程序，取指令的微命令会被统一编成微程序，用于从主存取出指令送入IR，间址和中断周期也可以编成公共微程序，这三者和机器指令数的和就是总微程序数</p>
<p><strong>微指令的编码(控制)方式</strong><br />
指如何对微指令的控制字段进行编码，以形成控制信号</p>
<ol type="1">
<li><p>直接编码(控制)，微指令的微命令字段中每位都代表一个微命令，约定某位置0表示哪个微命令 <img src="/assets/resources/Pasted%20image%2020240202151110.png" /></p></li>
<li><p>字段直接编码，将微指令的微命令字段分成若干小字段，每个字段独立编码，每种编码代表一个微命令，且各字段编码含义单独定义,与其他字段无关</p>
<ol type="1">
<li>互斥性微命令分在同一段内，相容性微命令分在不同段内。</li>
<li>每段信息位较少</li>
<li>每段留出一个状态，表示字段是否不操作 <img src="/assets/resources/Pasted%20image%2020240202151345.png" /></li>
</ol></li>
<li><p>字段间接编码(隐式编码)，一个字段的某些微命令需由另一个字段中的某些微命令来解释,缩短微指令字长，但削弱了微指令的并行控制能力,一般用于辅助</p></li>
</ol>
<p><strong>微指令的地址形成方式</strong><br />
通电时第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向CMAR输入微指令的地址，这个地址即为取指周期微程序的入口地址。</p>
<ol type="1">
<li>基本类型
<ol type="1">
<li>断定方式，直接由微指令的下地址字段指出，微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址</li>
<li>根据机器指令的操作码形成。机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成</li>
</ol></li>
<li>其他方式
<ol type="1">
<li>增量计数器法，类似PC的自增1，适用于指令地址连续情况</li>
<li>根据各种标志决定</li>
<li>测试网络形成</li>
<li>硬件直接产生</li>
</ol></li>
</ol>
<p><strong>微指令格式</strong></p>
<ol type="1">
<li>水平型，指令字中的一位对应一个控制信号，有输出为1，否则为0。微程序短，指令执行时间短，可以并行操作；但指令长，编写困难</li>
<li>垂直型,设置操作码字段，由其规定指令功能，每个指令定义一种操作。指令较短，编写简单；但效率低，执行时间长，微程序长</li>
<li>在垂直型的基础上增加一些不太复杂的并行操作</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240202153841.png" /> <img src="/assets/resources/Pasted%20image%2020240202153846.png" /> <strong>控制单元的设计步骤</strong></p>
<ol type="1">
<li>写出对应机器指令的微操作命令及节拍安排,例如取指时和硬布线不同的是T2节拍将IR的OP送往微地址形成部件，硬布线则送往指令译码器；且多一条将下一条微指令地址送到CMAR的操作 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">取指操作</span><br><span class="line">(PC)-&gt;MAR, 1-*R</span><br><span class="line">Ad (CMDR) -&gt;CMAR  //将微指令下地址字段送至CMAR</span><br><span class="line">M(MAR)-&gt;MDR, (PC) + 1-&gt;PC</span><br><span class="line">Ad (CMDR)-*&gt;CMAR</span><br><span class="line">(MDR)-&gt;IR</span><br><span class="line">OP (IR)-&gt;微地址形成部件-&gt;CMAR</span><br></pre></td></tr></table></figure></li>
<li>确定微指令格式</li>
<li>编写微指令码点</li>
</ol>
<div class="note info"><p>在一台微程序控制的计算机中，假如能根据用户的要求改变微程序,则这台机器就具有<strong>动态微程序设计</strong>功能,需要可写控制寄存器的支持例如EPROM<br />
在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制<br />
若硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的,这个第二级控制存储器就称为<strong>毫微存储器</strong>，直接控制硬件的是<strong>毫微微指令</strong></p>
</div>
<h3 id="总结">总结</h3>
<ul>
<li>硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快；缺点是由于控制逻辑用电路实现，难以额外修改</li>
<li>微程序控制器的优点是更规整灵活；缺点是采用存储程序，取指访存较为影响速度</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240202150944.png" /></p>
<div class="note warning"><ul>
<li>控制存储器中存放微指令</li>
<li>通常控制存储器采用ROM组成</li>
<li>指令周期是从一条指令启动到下一条指令启动的间隔时间，而CPU周期是机器周期，是指令执行中每步操作所需的时间</li>
<li>状态条件寄存器属于运算器</li>
<li>主存可以用RAM和ROM实现</li>
<li>微指令寄存器对汇编程序员是透明的</li>
<li>pc自增和取指，存IR和取IR操作码给Id可以放在同一个节拍(硬布线中)</li>
</ul>
</div>
<h2 id="异常和中断机制">异常和中断机制</h2>
<p>CPU内部产生的意外事件被称为异常，也称内中断，CPU外部的设备向CPU发出的中断请求被称为中断或者外中断</p>
<ul>
<li>异常是CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件；</li>
<li>中断是由外部设备触发的、与当前正在执行的指令无关的异步事件。</li>
</ul>
<p>一般来说，cpu检测到异常和中断时，打断当前程序，保护现场，然后处理异常，如果能处理完成，则回到程序的当前指令或下一条指令(可能刚执行完一个指令就触发异常)，否则终止程序</p>
<p><strong>异常与中断的分类</strong>：</p>
<ul>
<li>异常(按软硬件)
<ul>
<li>硬故障中断，硬连线异常引起</li>
<li>程序性异常(软件中断),cpu内部执行指令引起的错误，如除0，溢出等</li>
</ul></li>
<li>异常(按产生原因)
<ul>
<li>故障，引起故障的指令启动后、执行结束前被检测到的异常事件，如缺页，除0等，前者可以回到断点继续执行，后者必须终止程序。软件中断</li>
<li>自陷Trap，执行这种指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令(如果是转移自陷指令则返回转移地址)执行。软件中断</li>
<li>终止，执行指令时出现无法继续执行的硬件问题，只能中断来重启系统。硬件中断</li>
</ul></li>
<li>中断，外部I/O设备通过特定的中断请求信号线向CPU提出中断请求，CPU每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断响应周期
<ul>
<li>可屏蔽中断，通过可屏蔽中断请求线INTR向CPU发出的中断请求，可以选择屏蔽</li>
<li>不可屏蔽中断，通过专门的不可屏蔽中断请求线NMI向CPU发出的中断请求，需要cpu立即处理</li>
</ul></li>
</ul>
<p><strong>中断响应</strong>：</p>
<ol type="1">
<li>关中断，通常通过设置"中断允许"(IF)触发器来实现，置0不响应中断</li>
<li>保存断点，将程序断点(返回地址)与状态字寄存器送入栈或寄存器中，一般是栈，便于嵌套处理</li>
<li>识别中断，转到相应处理程序
<ol type="1">
<li>软件识别，CPU设置一个异常状态寄存器，用于记录异常原因，操作系统按优先级顺序查询该寄存器，检测类型，先查到的先处理，转到内核对应处理程序，多用于异常</li>
<li>硬件识别(向量中断)，异常或中断处理程序的首地址称为中断向量，所有中断向量都存放在中断向量表中。在中断向量表中，中断类型号和中断向量一一对应，因而可以根据类型号快速找到对应的处理程序<br />
中断响应过程是原子化的，响应过程结束后，CPU就从PC中取出中断服务程序的第一条指令开始执行，直至中断返回，处理过程由软硬件协同实现</li>
</ol></li>
</ol>
<div class="note warning"><ul>
<li>CPU所执行指令的地址序列称为CPU的控制流。在程序正常执行时，通过顺序执行指令或转移指令得到的控制流称为正常控制流。在正常执行过程中，因遇到异常或中断事件而引起用户程序的正常执行被打断所形成的意外控制流，称为异常控制流</li>
<li>部分异常/中断的处理是硬件进行</li>
<li>外部中断请求信号的检测总是在一条指令执行完之后，取下一条指令之前,内部中断则在指令执行过程中出现</li>
<li>典型的外中断(外是相当于cpu和内存):定时器到达，网络数据包到达，IO相关，用户输入信号(如ctrl-c)，硬件相关</li>
<li>典型的内中断/异常:地址非法/越界，浮点数上溢(下溢就是0)，缺页，计算溢出，除0，用户程序执行特权指令，存取访问错误，切换到内核态，时间片到期</li>
</ul>
</div>
<h2 id="指令流水线">指令流水线</h2>
<p>指令流水线技术用于提高处理机并行性：</p>
<ul>
<li>时间上并行，将任务分解为不同子阶段，每个阶段在不同功能部件上并行执行，称为流水线技术</li>
<li>空间上并行，一个处理机内设置多个执行相同功能的部件，并行工作，称为超标量处理机</li>
</ul>
<p><strong>对应指令执行过程的分解</strong>：</p>
<ul>
<li>取指，从指令寄存器或者Cache取指令</li>
<li>译码/读寄存器：控制器对指令译码，从寄存器取操作数</li>
<li>执行/计算地址：执行运算操作或计算地址</li>
<li>访存：读写主存</li>
<li>写回：指令执行结果写回寄存器堆</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240203173011.png" /> 如图，第k+1条指令的取指提前到k条指令的译码，从而前者的译码与后者的执行阶段可以并行<br />
理想情况下每个指令用一个时钟周期完成，实际的流水线设计中，以最复杂操作的阶段数量与时间为准，也就是最长阶段的用时<code>*</code>阶段数量，这样流水线执行单条指令的耗时大于等于单周期处理机，但总时间大大减少</p>
<p>对指令集的要求：</p>
<ul>
<li>指令长度一致或近似，简化取指和译码的时间差别与译码难度</li>
<li>指令格式一致或近似，尽量使源寄存器位置相同，可以直接取寄存器减少用时</li>
<li>采用Load/Store统一访存，便于通过简化LS指令来减少周期数量</li>
<li>数据与指令对齐存放，减少访存次数</li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240203173806.png" /></p>
<h3 id="基本实现">基本实现</h3>
<p><img src="/assets/resources/Pasted%20image%2020240203234024.png" /> <img src="/assets/resources/Pasted%20image%2020240205131527.png" /></p>
<ul>
<li>IF段包括程序计数器(PC)、指令存储器、下条指令地址的计算逻辑；</li>
<li>ID段包括操作控制器、取操作数逻辑、立即数符号扩展模块；</li>
<li>EX段主要包括算术逻辑单元(ALU)、分支地址计算模块；</li>
<li>MEM段主要包括数据存储器读写模块;</li>
<li>WB段主要包括寄存器写入控制模块。<br />
每个流水段后面都需要增加一个<strong>流水段寄存器</strong>，锁存处理完成的数据和控制信号<br />
各种寄存器和数据存储器均采用统一时钟CLK进行同步，每来一个时钟，就会有一条新的指令进入流水线IF段；同时流水段寄存器会锁存前段加工处理完成的数据和控制信号，为下一段的功能部件提供数据输入。<br />
即每两个相邻的流水段之间设置一个流水段寄存器，存放前一个流水段中产生的并需要传输到其后所有流水段的信息，包括各种数据(PC、指令、立即数、运算结果、寄存器号等)和控制信号两大类信息。每个流水段的功能不一样，所需传递的信息也不同，因此各流水段寄存器的长度也不同</li>
</ul>
<div class="note "><p><img src="/assets/resources/Pasted%20image%2020240205131918.png" /> <strong>流水线执行过程</strong>：</p>
<ol type="1">
<li>取指，取出PC值，计算PC+4送入PC输入端，通过PC值取指令字，PC+4与指令字(通过RD输出端)送入IF/ID流水寄存器，以备后续使用，时钟到来时将更新后的PC值和指令字锁存到IF/ID流水寄存器中；本条指令<span class="math inline">\(I_1\)</span>进入ID段，IF段取出下条指令<span class="math inline">\(I_2\)</span></li>
<li>译码/读寄存器ID，控制器通过流水寄存器生产后续需要的控制信号，例如读写寄存器，符号拓展指令字，多路选择器生成寄存器编号，这些数据与信号连同PC+4锁入流水寄存器。指令<span class="math inline">\(I_1\)</span>进入EX段，下条指令<span class="math inline">\(I_2\)</span>进入ID段，下下条指令<span class="math inline">\(I_3\)</span>进入IF段</li>
<li>执行/计算地址EX，功能由具体指令确定，不同指令经ID段译码后得到不同的控制信号，可用于生成访存，分支地址等。时钟到来后，数据和后段需要的控制信号都会锁存到EX/MEM流水寄存器中；指令<span class="math inline">\(I_1\)</span>进入MEM段，后续指令<span class="math inline">\(I_2I_3I_4\)</span>分别进入EX、ID、IF段</li>
<li>访存MEM，由具体指令确定功能，例如根据EX/MEM流水寄存器的访存地址进行读写。时钟到来后，这些数据和后段需要的控制信号都会锁存到MEM/WB流水寄存器中，EX/MEM的信号与数据也会一起送入；指令<span class="math inline">\(I_1\)</span>进入WB段，后续指令<span class="math inline">\(I_2I_3I_4I_5\)</span>分别进入MEM、EX、ID、IF段</li>
<li>写回WB，由具体指令确定功能，将MEM/WB流水寄存器中数据存储器读出的数据写回指定寄存器；时钟到来时会完成数据写入寄存器，指令<span class="math inline">\(I_1\)</span>离开流水线。此时，指令<span class="math inline">\(I_2\)</span>进入最后的WB段，指令<span class="math inline">\(I_3I_4I_5\)</span>分别进入MEM、EX、ID段，指令<span class="math inline">\(I_6\)</span>进入IF段</li>
</ol>
<h3 id="分类">分类</h3>
<ul>
<li>根据流水线使用的级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。
<ul>
<li>部件功能级流水就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。<br />
</li>
<li>处理机级流水是把一条指令解释过程分成多个子过程，如取指、译码、执行、访存及写回5个子过程。<br />
</li>
<li>处理机间流水是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。<br />
</li>
</ul></li>
<li>按流水线可以完成的功能，分为单功能多功能
<ul>
<li>单功能流水线指只能实现一种固定的专门功能的流水线；</li>
<li>多功能流水线指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线</li>
</ul></li>
<li>按同一时间内各段之间的连接方式，流水线可分为静态流水线和动态流水线。
<ul>
<li>静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</li>
<li>动态流水线指在同一时间内，不同的段可以进行不同运算，效率更高，控制更复杂</li>
</ul></li>
<li>按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。
<ul>
<li>线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。</li>
<li>非线性流水线存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，适合进行线性递归</li>
</ul></li>
</ul>
</div>
<h3 id="冒险">冒险</h3>
<p>可能遇到一些情况使得流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象称为<strong>流水线冒险</strong></p>
<ol type="1">
<li>结构冒险，多条指令在同一时刻争用同一资源而形成的冲突，也称为资源冲突，解决方法：
<ol type="1">
<li>前一指令访存时，使后一条相关指令(以及其后续指令)暂停一个时钟周期</li>
<li>一个部件每条指令只能使用一次，且只能在特定阶段使用</li>
<li>单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行，如L1Cache将指令数据分离，避免这种问题</li>
</ol></li>
<li>数据冒险，下一条指令会用到当前指令计算出的结果，此时这两条指令发生数据冲突，分为：
<ol type="1">
<li>写后读RAW，当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据,否则读到的就是旧数据</li>
<li>读后写WAR,表示当前指令读出数据后，下一条指令才能写该寄存器,否则读到的就是新数据</li>
<li>写后写WAW,当前指令写入寄存器后，下一条指令才能写,否则寄存器的值就不是最新值</li>
<li>load-use问题，数据在mem阶段存入主存前就要被读出(涉及到主存无法用旁路解决，只能阻塞或者编译优化)</li>
<li>解决方案：
<ol type="1">
<li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为硬件阻塞(stall,根据指令流程分析耗时)和软件插入“NOP”(空)指令两种方法</li>
<li>设置相关专用通路，不经过寄存器，直接把前一条指令的ALU的计算结果作为下一条的输入数据开始计算过程，称为数据旁路技术</li>
<li>编译器对数据相关指令编译优化，调整到合理顺序</li>
</ol></li>
</ol></li>
<li>控制冒险，执行转移、调用或返回等改变原有顺序的指令时，会改变PC值，会造成断流，从而引起控制冒险。解决方法：
<ol type="1">
<li>延迟后续指令</li>
<li>对转移指令进行分支预测，尽早生成转移目标地址，分为简单(静态)预测(每次的预测结果一样,若总是预测条件不满足，跳过分支指令，直接执行后续指令)和动态预测(根据历史进行预测，准确率更高)</li>
<li>预取转移成功和不成功两个控制流方向上的目标指令。</li>
<li>加快和提前形成条件码</li>
<li>提高转移方向的猜准率</li>
</ol></li>
</ol>
<h3 id="性能指标-1">性能指标</h3>
<ol type="1">
<li><p>吞吐率，单位时间内流水线所完成的任务数量，或输出结果的数量。 <span class="math display">\[\mathrm{TP}={\frac{n}{T_{k}}}\]</span> n 是任务数，<span class="math inline">\(T_k\)</span>是处理完n个任务所用的总时间。设k为流水段的段数，Δt为时钟周期。<br />
在输入流水线中的任务连续的理想情况下，一条k段流水线能在上<code>k+n-1</code>个时钟周期内完成n个任务。<br />
<span class="math display">\[\mathbf{TP}={\frac{n}{(k+n-1)\Delta t}}\]</span></p></li>
<li><p>加速比，同样任务不使用流水线与使用流水线所用的时间之比</p></li>
</ol>
<p><span class="math display">\[s={\frac{T_{\mathrm{0}}}{T_{\mathrm{K}}}}\]</span></p>
<p><span class="math inline">\(T_0\)</span>是不用流水线的总时间，<span class="math inline">\(T_k\)</span>流水线所用的总时间</p>
<p><span class="math display">\[S={\frac{k n\Delta t}{(k+n-1)\Delta t}}={\frac{k n}{k+n-1}}\]</span></p>
<h3 id="高级流水线技术">高级流水线技术</h3>
<ol type="1">
<li><p>超标量流水线技术也称动态多发射技术，每个时钟周期内可发多条独立指令，以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件,<code>CPI&lt;1</code>,不能调整指令的执行顺序,配置多个功能部件通过编译优化技术，把可并行执行的指令搭配起来<br />
多数超标量CPU都结合动态流水线调度技术，通过动态分支预测等手段，指令不按顺序执行，这种执行方式称为乱序执行 <img src="/assets/resources/Pasted%20image%2020240205142318.png" /></p></li>
<li><p>超长指令字技术也称静态多发射技术，编译程序将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字(可达几百位)，需要多个处理部件</p></li>
<li><p>超流水线技术，划分更短的功能段与时钟周期，提高流水线主频，也就是级数来提升流水线性能，会增加寄存器开销，CPI依旧=1</p></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240205142507.png" /></p>
<div class="note warning"><ul>
<li>按序流动的流水线只可能出现RAW相关(某条指令要读取上一条指令所写入的寄存器)</li>
<li>非按序流动的流水线中，RAW,WAR,WRW都可能发生</li>
<li>吞吐能力是指单位时间内完成的指令数,稳定后的m段流水线和m个处理器cpu吞吐能力相同</li>
<li>译码和读寄存器通常在一个周期</li>
<li>数据通路不包括控制部件！！！</li>
<li>每访问一次内存数据就会查一次TLB,缺页后需要等调页后再重新访问</li>
</ul>
</div>
<h2 id="多处理器">多处理器</h2>
<p>基于指令流的数量和数据流的数量，将计算机体系结构分为SISD、SIMD、MISD和MIMD四类。</p>
<ol type="1">
<li>单指令流单数据流(SISD)结构，只有一个处理器一个存储器，处理器在一段时间内仅执行一条指令，按指令流规定的顺序串行执行指令流中的若干条指令，可以采用流水线技术，也可以设置多个功能部件使用多模块交叉方式的存储器</li>
<li>单指令流多数据流(SIMD)结构，一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。这种计算机通常由一个指令控制部件、多个处理单元组成。每个单元有自己的地址寄存器，也就是都有不同的数据地址，因此可以有多种组织方式</li>
<li>多指令流单数据流(MISD)结构不存在</li>
<li>多指令流多数据流(MIMD)结构，同时执行多条指令分别处理多个不同的数据，MIMD分为多计算机系统和多处理器系统，前者每个节点有私有存储器和主存地址空间，且相互隔绝，需要消息传递(消息传递MIMD)；后者共享地址空间，存取指令来访问所有存储器(共享存储MIMD)</li>
</ol>
<p>其中SIMD是一种数据级并行模式，而MIMD是一种并行程度更高的线程级并行或线程级以上并行计算模式</p>
<div class="note info"><p>向量处理器是SIMD的变体，是一种实现了直接操作一维数组(向量)指令集的CPU，将从存储器中收集的一组数据按顺序放到一组向量寄存器中，然后以流水化的方式对它们依次操作，最后将结果写回寄存器，适用于数值模拟等领域</p>
</div>
<p><strong>硬件多线程</strong><br />
硬件实现的多线程为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，提高效率</p>
<ol type="1">
<li>细粒度多线程，多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行，每个时钟周期都可以切换线程</li>
<li>粗粒度多线程，一个线程阻塞时才切换线程，流水线阻塞时，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，切换开销更大</li>
<li>同时多线程SMT，实现指令级并行与线程级并行，在同一个时钟周期中，发射多个不同线程中的多条指令执行。例如intel的超线程就是SMT，单核中线程有自己的状态组件(需要芯片组、操作系统和应用软件的支持) <img src="/assets/resources/Pasted%20image%2020240205152611.png" /></li>
</ol>
<p><strong>多核处理器</strong><br />
多个处理单元集成到单个CPU中，每个处理单元称为一个核，核一般都是对称的，并且共享主存储器，Cahe可独立可共用，因此多核属于共享存储的对称多处理器，可以实现真正的线程并行执行 <img src="/assets/resources/Pasted%20image%2020240205152802.png" /> 具有共享的单一物理地址空间的多处理器被称为<strong>共享内存多处理器(SMP)</strong>，可以通过存储器的共享变量实现通信，所有处理器都可以访问整个存储器，但可以通过虚拟地址空间独立运行程序</p>
<ul>
<li>统一存储访问(UMA)多处理器，访问时间与哪个处理器提出访存请求及访问哪个字无关，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器</li>
<li>非统一存储访问(NUMA)多处理器，访问请求直接有时间区别，处理器中不带高速缓存时，被称为NC-NUMA；处理器中带有一致性高速缓存时，被称为CC-NUMA</li>
</ul>
<p>早期计算机的cpu通过北桥芯片统一访存，但随后cpu数量增加，总线告急，因此每个cpu都要设置独立的内存控制器，连接一部分内存(本地内存)，访问非本地内存时再通过总线访问<br />
在操作共享变量时需要进行同步机制，例如加锁</p>
<div class="note info"><p>组合逻辑电路是具有一组输出和一组输入的非记忆性逻辑电路, 它的基本特点是任何时刻的输出信号状态仅取决于该时刻各个输入信号状态的组合，而与电路在输入信号作用前的状态无关。组合电路不含存储信号的记忆单元，输出与输入之间无反馈通路，信号是单向传输的。<br />
时序逻辑电路中任意时刻的输出信号不仅和当时的输入信号有关，而且与电路原来的状态有关，这是时序逻辑电路在逻辑功能上的特点。因而时序逻辑电路必然包含存储记忆单元。<br />
此外，组合逻辑电路没有统一的时钟控制，而时序逻辑电路则必须在时钟节拍下工作</p>
</div>
<div class="note warning"><ul>
<li>UMA构架由于所有CPU共享相同的内存，增加CPU路数会加大访存冲突，通常2或4路的性能最好，而NUMA理论上支持无限扩展</li>
<li>多核系统的Cache 一致性既包括Cache和内存之间的一致性，还包括各CPU的Cache之间的一致性,对内存同一位置的数据,即不同CPU的Cache不应该有不一致的内容</li>
</ul>
</div>
<h1 id="总线">总线</h1>
<h2 id="概念-2">概念</h2>
<p><strong>总线的定义</strong> 一组能为多个部件分时共享的公共信息传送线路</p>
<ul>
<li>分时：同一时刻只允许有一个部件向总线发送信息。若系统中有多个部件，则它们只能分时地向总线发信息</li>
<li>共享：总线可以挂多个部件，部件交换信息可以用总线分时共享</li>
</ul>
<p>总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种</p>
<ul>
<li>主设备：获得总线控制权的设备<br />
</li>
<li>从设备：被主设备访问的设备，它只能响应从主设备发来的各种总线命令</li>
</ul>
<p><strong>分类</strong>：</p>
<ol type="1">
<li>片内总线，芯片内部的总线，如寄存器，ALU之间或者相互的连接</li>
<li>系统总线，各个功能部件的连接线
<ol type="1">
<li>数据总线，双向传输，位数与机器字长和存储字长有关</li>
<li>地址总线，单向传输，用于访问主存和IO端口，位数与主存地址空间有关</li>
<li>控制总线，传输控制信息</li>
</ol></li>
<li>I/O总线，连接低速的IO设备，通过IO接口连接系统总线，如USB,PCI总线</li>
<li>通信总线，系统之间(包括非计算机的电子设备)的总线，也称外部总线</li>
</ol>
<p>也有同步/异步,并行/串行的分类</p>
<p><strong>结构(靠近CPU的总线速度较快)</strong>：</p>
<ol type="1">
<li>单总线结构，CPU、主存、I/O设备(通过I/O接口)都挂在<strong>一组</strong>总线上，允许I/O设备之间、I/O设备与主存之间直接交换信息，结构简单，成本低</li>
<li>双总线结构，一条是主存总线，用于在CPU、主存和通道之间传送数据；另一条是I/O总线，用于在多个外部设备与通道之间传送数据；需要增加通道等硬件设备</li>
<li>三总线结构，主存总线(cpu与主存)、I/O总线(IO与cpu)和直接内存访问(DMA)总线(内存和高速外设)；提高吞吐量，但任意时刻只能使用一种总线,效率较低</li>
</ol>
<div class="note "><p><strong>总线标准</strong>：国际上公布的互连各个模块的标准</p>
<ul>
<li>ISA(系统)</li>
<li>EISA(拓展前者)</li>
<li>VESA(视频)</li>
<li>PCI(外接设备显卡声卡等)</li>
<li>AGP(视频)</li>
<li>PCI-E(取代PCI,AGP，以上四者都是局部总线)</li>
<li>USB(IO)</li>
<li>IDE/ATA(磁盘接口)</li>
<li>SATA(硬盘)</li>
</ul>
</div>
<p><strong>性能指标</strong>：</p>
<ol type="1">
<li>传输周期，一次总线操作所需时间，包括申请，寻址，传输和结束</li>
<li>总线时钟周期，受到计算机时钟控制</li>
<li>总线工作频率，总线操作的频率，为总线周期倒数</li>
<li>总线时钟频率，与机器时钟频率相同</li>
<li>总线宽度(位宽)，通常是数据总线根数</li>
<li>总线带宽，总线最大数据传输率，字节/秒，总线带宽= 总线工作频率x(总线宽度/8)</li>
<li>总线复用，一种信号线在不同时间传输不同信息</li>
<li>信号线数，三种总线的线数和<br />
最主要性能指标为总线宽度、总线(工作)频率、总线带宽<br />
总线带宽=总线宽度x总线频率</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240205222012.png" /> <img src="/assets/resources/Pasted%20image%2020240205222956.png" /></p>
<p>桥接器用于连接不同的总线，具有数据缓冲、转换和控制功能。</p>
<div class="note warning"><ul>
<li>地址总线不仅可以指定主存单元，也可用来指定IO端口</li>
<li>地址总线是用于CPU到主存和I/O端口地址的单向总线,控制信息和状态信息也类似</li>
<li>CPU的控制总线提供的控制信号包括时序信号、I/O设备和存储器的响应信号等</li>
<li>PCI、EISA、ISA均是并行总线，USB是通用串行总线</li>
<li>突发(猝发)传输方式可以连续传送地址连续的数据，但需要先传一个地址</li>
<li>USB是一种连接外部设备的I/O总线标准，属于设备总线，是设备和设备控制器之间的接口。而PCI、AGP、PCIE作为计算机系统的局部总线标准，通常用来连接主存、网卡、视频卡等</li>
<li>PCI-Express总线采用串行数据包传输数据</li>
</ul>
</div>
<h2 id="总线事务与定时">总线事务与定时</h2>
<p><strong>总线事务</strong>：从请求总线到完成总线使用的操作序列</p>
<ol type="1">
<li>请求，主设备(cpu/dma)发出总线传输请求，获取总线控制权</li>
<li>仲裁，总线仲裁机构决定将下个周期的总线使用权交给某个申请者</li>
<li>寻址，主设备通过总线给出要访问的从设备地址和相关命令，启动从模块</li>
<li>传输，主从模块数据交互,分为寻址阶段、申请分配阶段、传输阶段</li>
<li>释放，主模块信息从系统总线上撤出，让出总线使用权</li>
</ol>
<div class="note info"><p>上升(下降)沿：数字电平从0(1)变为1(0)的一瞬间,可通过这两个信号规定总线连接设备操作的时间次序<br />
突发(猝发)传送方式能够进行连续成组数据的传送，其寻址阶段发送的是连续数据单元的首地址，在传输阶段传送多个连续单元的数据，每个时钟周期可以传送<strong>一个字长</strong>的信息，但是不释放总线，直到一组数据全部传送完毕后，再释放总线<br />
在某个总线周期内，总线上只有一个主设备控制总线，选择一个从设备与之进行通信(一对一)，或对所有设备进行广播通信(一对多)</p>
</div>
<p><strong>总线定时</strong>是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步和异步两种基本定时方式。</p>
<ul>
<li>同步定时方式，系统用统一的时钟信号协调发送接受方的传送定时关系，一个时钟周期构成总线周期，周期内发送接收方可以进行数据传送。速度快且控制逻辑简单，但可靠性交叉，适用于总线较短且部件存取时间相近的系统(高速部件会被拖累)</li>
<li>异步定时方式，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。没有固定周期，可靠性高，更复杂且低速,每个字符都要用开始位和停止位作为字符开始和结束的标志。根据“请求”和“回答”信号的撤销是否互锁，可分为：
<ul>
<li>不互锁，主设备请求后，一段时间没有接受则撤销，从设备也一样自动撤销</li>
<li>半互锁，请求必须在回答后才撤销，回答则可以自动撤销(隔一段时间后自动撤销“回答”信号)</li>
<li>全互锁，请求回答彼此都需要回复</li>
</ul></li>
<li>分离式：
<ol type="1">
<li>各模块均有权申请占用总线,包括接收方和发送方</li>
<li>采用同步方式通信，不等对方回答，每次发送都是单方向</li>
<li>各模块准备数据时，不占用总线</li>
<li>总线利用率提高,但控制复杂</li>
</ol></li>
</ul>
<p><img src="/assets/resources/Pasted%20image%2020240206103615.png" /></p>
<div class="note info"><p>半同步通信总线既保留了同步通信的特点，又能采用异步应答方式连接速度相差较大的设备。通过在异步总线中引入时钟信号，其就绪和应答等信号都在时钟的上升沿或下降沿有效，而不受其他时间的信号干扰。<br />
例如从某个时钟开始，在每个时钟到来时，采样Wait信号，若无效，则说明数据未准备好，下个时钟到来时，再采样Wait信号，直到检测到有效再取数据</p>
</div>
<h1 id="io设备">IO设备</h1>
<h2 id="io接口">IO接口</h2>
<p>I/O接口(I/O控制器)是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换<br />
<strong>主要功能</strong>：</p>
<ul>
<li>地址译码和设备选择，译码cpu送来的外设地址码，选择指定的设备</li>
<li>主机和外设的通信控制，协调不同工作速度，时序的外设和主机之间交换信息</li>
<li>数据缓冲，为了协调速度，接口需要用寄存器暂存部分数据</li>
<li>信号格式转换，电平，数据格式的转换</li>
<li>传送控制命令和状态信息，负责启动关闭，中断等信息的传送</li>
</ul>
<p><strong>基本结构</strong>：<br />
I/O接口在主机侧通过I/O总线与内存、CPU相连。通过数据总线，在数据缓冲寄存器与内存或CPU的寄存器之间进行数据传送。同时接口和设备的状态信息被记录在状态寄存器中，通过数据线将状态信息送到CPU。CPU对外设的控制命令也通过数据线传送，一般将其送到I/O接口的控制寄存器。<br />
接口中的地址线用于给出要访问的I/O接口中的寄存器的地址，它和读/写控制信号(通过控制线)一起被送到I/O接口的控制逻辑部件<br />
接口中的I/O控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能。<br />
对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为I/O指令，I/O指令只能在操作系统内核的底层I/O软件中使用，它们是一种特权指令<br />
<img src="/assets/resources/Pasted%20image%2020240206124440.png" /></p>
<p><strong>接口类型</strong>：</p>
<ol type="1">
<li>按数据传送方式分
<ol type="1">
<li>并行接口(一个字/字节的所有位同时传送)</li>
<li>串行接口(一次传送一位)</li>
</ol></li>
<li>主机控制方式分
<ol type="1">
<li>程序查询接口</li>
<li>中断接口</li>
<li>DMA接口</li>
</ol></li>
<li>功能选择分
<ol type="1">
<li>可编程接口</li>
<li>不可编程接口</li>
</ol></li>
</ol>
<p><strong>IO端口</strong>：I/O端口是指接口电路中可被CPU直接访问的寄存器，主要有数据端口、状态端口和控制端口，若干端口加上相应的控制逻辑电路组成接口<br />
通常，数据端口可RW,状态端口只能R，控制端口只能W<br />
各个端口有自己的编号，对应一个端口地址，编址方式分为：</p>
<ul>
<li>统一编址，存储器映射方式，将IO端口当做存储器单元分配地址，可以用统一访存指令访问。编址空间较大，不需要专用指令，但占用存储器地址，且执行较慢</li>
<li>独立编址，IO映射方式，需要专门的IO指令访问IO端口，IO地址空间和主存独立。更清晰，但控制逻辑更复杂</li>
</ul>
<div class="note warning"><ul>
<li>I/O总线分为三类：数据线、控制线和地址线。数据缓冲寄存器和命令/状态寄存器的内容都是通过数据线来传送的；地址线用以传送与CPU交换数据的端口地址；而控制线用以给I/O端口发送读/写信号</li>
<li>IO指令格式和其他通用指令相比有所不同</li>
<li>磁盘驱动器是由磁头、磁盘和读/写电路等组成的，也就是我们平常所说的磁盘本身</li>
</ul>
</div>
<h2 id="io方式">IO方式</h2>
<p>常用的I/O方式有程序查询、程序中断、DMA和通道等</p>
<h3 id="程序查询方式">程序查询方式</h3>
<p>信息交换的控制完全由CPU执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器(数据端口)和一个设备状态寄存器(状态端口)<br />
IO操作时，先发出询问信号，再根据设备状态决定传送时间<br />
<strong>工作流程</strong>：</p>
<ol type="1">
<li>cpu执行初始化程序，预置传送参数</li>
<li>向IO口发出命令字，启动设备</li>
<li>从外设接口读取状态</li>
<li>cpu查询状态，直到就绪</li>
<li>传送数据</li>
<li>修改地址和计数器参数</li>
<li>若计数器不为0(传送未结束)则转3，否则结束</li>
</ol>
<p>结构最简单，但cpu需要忙等待，与io串行工作，效率低<br />
<img src="/assets/resources/Pasted%20image%2020240206154237.png" /></p>
<h3 id="程序中断方式">程序中断方式</h3>
<p>cpu启动io流程后，继续工作，直到io发送中断请求，再用中断服务程序处理(IO准备数据过快的话，可能来不及取就数据溢出)<br />
<img src="/assets/resources/Pasted%20image%2020240206155937.png" /> <strong>工作流程</strong>：</p>
<ol type="1">
<li>中断请求，一般每个中断源有中断请求标记触发器，置1为中断请求，触发器组成中断请求标记寄存器，可放置于cpu或中断源。请求分为可屏蔽(INTR线，关中断时不响应)，不可屏蔽(NMI线)，内部异常
<ol type="1">
<li>当 IF=1 时，若 INTR 保持高电平，则在当前指令执行完毕后就进入中断响应周期</li>
<li>NMI 中断不必检查 IF 标志位是否为 1,强制需要处理</li>
<li>INTA：中断响应(interrupt acknowledge)信号，输出。响应 INTR 输入。该引脚常用来选通中断向量码以响应中断请求</li>
</ol></li>
<li>中断响应判优，一般来说，不可屏蔽中断 &gt; 内部异常(硬件故障 &gt; 软件中断) &gt; 可屏蔽中断;DMA &gt; IO(高速设备&gt;低速设备，输入设备&gt;输出设备，实时设备&gt;普通设备)</li>
<li>响应中断的条件
<ol type="1">
<li>中断源有中断请求</li>
<li>开中断(异常和不可屏蔽中断不受限制)</li>
<li>指令执行完毕(异常不受此限制)，只有这时cpu会查询中断信号</li>
</ol></li>
<li>中断响应，中断服务程序由硬件直接实现的,称为<strong>中断隐指令(与指令系统的指令性质不同),隐指令引出中断服务程序</strong>
<ol type="1">
<li>关中断</li>
<li>保存断点，一般是PC,PSW内容保存在栈或者特定寄存器</li>
<li>中断服务程序，根据中断源选择合适服务程序，将服务程序入口地址送入PC</li>
</ol></li>
<li>中断向量，每个中断都有一个唯一的类型号，每个中断类型号都对应一个中断服务程序，其入口地址就是中断向量，一般中断向量表集中存于主存。(也可以软件查询法，使用向量法的中断称为向量中断)</li>
<li>中断处理过程，一般而言如下图，其中现场指的是用户可见的工作寄存器内容,图中如果不允许嵌套中断，中断服务前后的开关中断省去</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206161017.png" /> 若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，cpu暂停现行中断服务去处理新的中断，这种中断称为多重中断(中断嵌套)需要满足：</p>
<ol type="1">
<li>中断服务程序中提前设置开中断指令</li>
<li>优先级别高的中断源有权中断优先级别低的中断源</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206161514.png" /> 现代计算机一般使用中断屏蔽技术，每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。利用屏蔽技术可以动态调整优先级，否则处理和响应优先级相同(表示中断源自身的位置1)<br />
屏蔽字就类似于官僚系统，可以屏蔽的(即寄存器中的1)越多，其优先级越高</p>
<h3 id="dma">DMA</h3>
<p>在外设与内存之间开辟一条“直接数据通道”<br />
适用于磁盘、显卡等高速设备大批量数据的传送，硬件开销较大，中断的作用仅限于故障和正常传送结束时的处理</p>
<ul>
<li>主存和DMA接口之间有一条直接数据通路。IO访存无需经过cpu，与主机并行。</li>
<li>数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</li>
<li>主存中要开辟专用缓冲区，及时供给和接收外设的数据</li>
<li>传送速度快，且传送前需要程序预处理，结束时需要通过中断进行后处理</li>
</ul>
<p><strong>组成</strong>： 对数据传送过程进行控制的硬件称为<strong>DMA控制器(DMA接口)</strong>，控制器向cpu发出传送请求，响应后cpu让出整个系统总线，由DMA控制器接管总线传送数据</p>
<ol type="1">
<li>接受外设的dma请求，向cpu请求总线</li>
<li>cpu发出总线响应信号后，dma接管总线</li>
<li>确定传送数据的地址与长度(由设备驱动程序设置传送参数)</li>
<li>规定数据传送方向，发送读写等控制信号进行传送</li>
<li>结束后向cpu报告</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206164528.png" /></p>
<p><strong>传送方式</strong></p>
<ol type="1">
<li>停止cpu访存,与上文一致</li>
<li>周期挪用(窃取)；IO请求时如果cpu正在访存，则等到存取周期结束；IO请求如果与cpu访存请求同时，则IO(优先级更高)挪用若干存取周期，传送一个数据就立刻释放总线</li>
<li>DMA和cpu交替访存，CPU的工作周期比主存存取周期长时，可以将cpu周期分为dma和cpu分别的访存周期，分时控制</li>
</ol>
<p><strong>传送过程</strong></p>
<ol type="1">
<li>预处理,CPU完成一些必要的准备工作。测试设备状态，设置传送方向，寄存器等，随后cpu执行原有程序，直到IO就绪请求DMA</li>
<li>数据传送,可以以单字节(或字)为基本单位，也可以以数据块为基本单位(DMA控制器用循环实现)</li>
<li>后处理，DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验数据是否正确，传送是否出错等</li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206161445.png" /></p>
<p><strong>与中断的区别</strong>：</p>
<ol type="1">
<li>中断需要保护恢复现场；DMA方式不中断现行程序，无需保护现场，除了预处理和后处理不占用cpu</li>
<li>cpu只在指令结束时响应中断；但任意周期结束时都可以响应DMA请求,<strong>即每个机器周期结束时都可以响应</strong></li>
<li>中断需要cpu干预，DMA不需要且更加高效</li>
<li>DMA请求优先级高于中断</li>
<li>中断可以处理异常，DMA只用于传送数据</li>
<li>中断通过程序层面传送数据，DMA则是硬件层</li>
</ol>
<div class="note warning"><ul>
<li>中断向量是中断服务程序的入口地址，中断向量地址是内存中存放中断向量的地址，即中断服务程序入口地址的地址</li>
<li>内部异常都是不可屏蔽的内中断，外部中断区分NMI,INTR</li>
<li>cache等硬件错误不属于中断</li>
<li>浮点数上溢，表示超过了浮点数的表示范围，属于内中断(下溢是0不需要处理)</li>
<li>CPU会在每个存储周期结束后检查是否有DMA请求</li>
<li>中断优先级由高至低为访管-&gt;程序性-&gt;重新启动</li>
<li>允许中断触发器置0表示关中断，在中断响应周期由硬件自动完成，即中断隐指令完成;恢复现场和屏蔽字时，由关中断指令完成</li>
<li>中断屏蔽标志的一种作用是实现中断升级，即改变中断处理完成的次序(中断响应次序由硬件排队电路决定)</li>
<li>与中断不同，DMA请求的响应时间可以发生在每个机器周期结束时，只要CPU不占用总线</li>
<li>指令寄存器IR和标志寄存器FR的输出信号会连到控制部件的输入端</li>
<li>关中断; 保存断点;识别中断源由硬件完成，现场保护恢复与开中断由中断服务完成</li>
<li>外部设备通常不能发出不可屏蔽中断</li>
<li>CPU检测不到处理优先级更低的中断请求信号,检测到中断请求信号，则说明其处理优先级更高</li>
</ul>
</div>
<h1 id="杂项">杂项</h1>
<p><strong>透明性总结</strong>:</p>
<ol type="1">
<li>所有用户可见
<ol type="1">
<li>pc</li>
<li>psw</li>
<li>通用寄存器(组)</li>
<li>ACC</li>
</ol></li>
<li>汇编程序员可见
<ol type="1">
<li>中断字寄存器(相应优先级是硬件写死的，屏蔽字可以更改，置1表示屏蔽)</li>
<li>基址寄存器</li>
<li>变址寄存器</li>
<li>虚拟存储空间</li>
</ol></li>
<li>所有用户不可见
<ol type="1">
<li>MDR</li>
<li>MAR</li>
<li>IR</li>
<li>微程序相关寄存器</li>
<li>Cache</li>
</ol></li>
</ol>
<p><img src="/assets/resources/Pasted%20image%2020240206161017.png" /></p>
<ul>
<li>I/O总线分为三类：数据线、控制线和地址线。数据缓冲寄存器和命令/状态寄存器的内容都是通过数据线来传送的；地址线用以传送与CPU交换数据的端口地址；而控制线用以给I/O端口发送读/写信号</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A0%94distance/" rel="tag"><i class="fa fa-tag"></i> 研distance</a>
              <a href="/tags/%E8%AE%A1%E7%BB%84/" rel="tag"><i class="fa fa-tag"></i> 计组</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/thinklive/44607/" rel="prev" title="迪瑞克拉rpg设定集">
                  <i class="fa fa-angle-left"></i> 迪瑞克拉rpg设定集
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/thinklive/26286/" rel="next" title="研distance——操作系统部分">
                  研distance——操作系统部分 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">thinklive</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">610k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">36:56</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 技术支持
  </div><script defer src="/lib/three.js"></script><script defer src="/lib/lines.js"></script><script defer src="/lib/waves.js"></script>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>


  <script src=""></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>
  <script src="/%5Bobject%20Object%5D"></script>


<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  <script src="/js/third-party/addtoany.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://thinklive1.github.io/thinklive/47457/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"thinklive1/blog_comments","issue_term":"pathname","theme":"photon-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script>
<script>
    const snowflakes = ["❄", "❄", "❆", "❅", "✥","❄", "❄", "❆", "❅", "✥","✻"];
    // 创建雪花
    function createSnowflake() {
        const snowflake = document.createElement("span");
        snowflake.classList.add("snowflake");
        const randomIndex = Math.floor(Math.random() * snowflakes.length);
        snowflake.textContent = snowflakes[randomIndex];
        
        // 起始位置
        /* 80%概率 生成在页面两侧 30% 的位置
        const probability = Math.random();
        let startPosition = Math.random() * 100;

        if (probability < 0.8) {
            startPosition = Math.random() < 0.5 ? Math.random() * 30 : (Math.random() * 30) + 70;
        }
        snowflake.style.left = `${startPosition}vw`;
        */
        snowflake.style.left = `${Math.random() * 100}vw`;
        snowflake.style.top = `-30px`;
        // 雪花大小与透明度
        const size = Math.random() * 18 + 10;
        snowflake.style.fontSize = `${size}px`;
        const opacity = Math.random() * 0.6 + (size > 18 ? 0.4 : 0);
        snowflake.style.setProperty("--opacity", opacity);
        // 动画持续时间
        const fallDuration = Math.random() * 10 + 10;
        // 旋转持续时间
        const rotateDuration = Math.random() * 3 + 1;

        snowflake.style.animationDuration = `${fallDuration}s, ${fallDuration}s`; // 向 CSS 添加淡出动画的持续时间
        // 横向幅度
        const translateX = (Math.random() * 500 - 200);
        snowflake.style.setProperty("--translateX", `${translateX}px`);
        // 纵向幅度
        snowflake.style.setProperty("--translateY", `${window.innerHeight}px`);

        document.body.appendChild(snowflake);
        // 移除雪花
        setTimeout(() => {
            snowflake.remove();
        }, fallDuration * 1000);
    }
    
    function snowfallAnimation() {
        // 载入时若边栏是隐藏状态则不加载雪花
        const sidebarnav = document.querySelector('.sidebar');
        const sidebarnavdisplay = window.getComputedStyle(sidebarnav).getPropertyValue('display'); 
        if (sidebarnavdisplay !== 'none') {
            createSnowflake();
        }
        setTimeout(snowfallAnimation, 500); // 生成速度，毫秒
    }
    snowfallAnimation();
function toggleMode() {
    console.log("change color!");
    const root1 = document.documentElement;

    // 检查当前 color-scheme
    const isLightMode = getComputedStyle(root1).getPropertyValue('--content-bg-color').trim() === '#fff';

    if (isLightMode) {
        // 切换到暗模式
        const images = document.querySelectorAll('img'); // 选择所有<img>标签
        images.forEach(img => {
            img.style.filter = 'brightness(50%)'; // 设置亮度为50%
        });

        root1.style.setProperty('--content-bg-color', '#333');
        root1.style.setProperty('--link-color', '#aaa');
        root1.style.setProperty('--text-color', '#fff');
        root1.style.setProperty('--highlight-background', '#444');
        root1.style.setProperty('--highlight-foreground', '#bbb');
        root1.style.setProperty('--btn-default-bg', '#777');
        root1.style.setProperty('--menu-item-bg-color', '#777');
        root1.style.setProperty('--note-warning-bg-color', '#555');
        root1.style.setProperty('--note-bg-color', '#555');
        root1.style.setProperty('--note-info-bg-color', '#555');
        root1.style.setProperty('--highlight-gutter-foreground', '#98d9ffff');
        root1.style.setProperty('', '#777');
        root1.style.transition = 'all 0.5s ease';

    }

    else {
        const images = document.querySelectorAll('img'); // 选择所有<img>标签
        images.forEach(img => {
            img.style.filter = 'brightness(100%)'; // 设置亮度为50%
        });
        root1.style.setProperty('--content-bg-color', '#fff');
        root1.style.setProperty('--text-color', '#555');
        root1.style.setProperty('--highlight-background', '#eaeef3');
        root1.style.setProperty('--highlight-foreground', '#00193a');
        root1.style.setProperty('--btn-default-bg', '#fff');
        root1.style.setProperty('--menu-item-bg-color', '#f5f5f5');
        root1.style.setProperty('--note-warning-bg-color', '#fdf8ea');
        root1.style.setProperty('--note-bg-color', '#f9f9f9');
        root1.style.setProperty('--note-info-bg-color', '#eef7fa');
        root1.style.setProperty('--table-row-odd-bg-color', '#f9f9f9');
        root1.style.setProperty('--highlight-gutter-foreground', '#172e4c');
        root1.style.transition = 'all 0.5s ease';
    }
}

function DarkTrigger() {
    console.log('dark!!')
    let isDarkMode = getComputedStyle(document.documentElement).getPropertyValue('--content-bg-color').trim() === '#000';
    console.log(isDarkMode)
    if (isDarkMode) {
        // 切换到暗模式
        const warningNotes = document.querySelectorAll('.post-body .note.warning');
        // 修改背景颜色
        warningNotes.forEach(note => {
        note.style.background = '#666';
        });

        const infoNotes = document.querySelectorAll('.post-body .note.info');
        // 修改背景颜色
        infoNotes.forEach(note => {
        note.style.background = '#666';
        });
    }
}


</script>

 <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<button style="background: #868686;
  width: 3rem;
  height: 3rem;
  position: fixed;
  border-radius: 50%;
  border: none;
  right: unset;
  bottom: 2rem;
  left: 2rem;
  cursor: pointer;
  transition: all 0.5s ease;
  display: flex;
  justify-content: center;
  align-items: center;" class="darkmode-toggle" role="checkbox" onclick="toggleMode()">🌓</button>

  <video autoplay loop muted playsinline style="position:fixed;top:50%;opacity: 0.8;left:50%;min-width:100%;min-height:100%;transform:translateX(-50%)translateY(-50%);z-index:-2;">
  <source src="/images/red.mp4" type="video/mp4">
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
