<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinklive1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#66CCFF","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一些查找和排序算法 二分查找法  最坏情况：log2n">
<meta property="og:type" content="article">
<meta property="og:title" content="基于斯坦福cs106b的c++数据结构笔记">
<meta property="og:url" content="https://thinklive1.github.io/thinklive/16615/index.html">
<meta property="og:site_name" content="thinklive">
<meta property="og:description" content="一些查找和排序算法 二分查找法  最坏情况：log2n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230226101843.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230224172126.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230226090109.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230226090958.png">
<meta property="og:image" content="https://thinklive1.github.io/images/obsidian/20230226093232.png">
<meta property="article:published_time" content="2024-01-20T11:53:48.573Z">
<meta property="article:modified_time" content="2023-11-27T12:47:59.687Z">
<meta property="article:author" content="thinklive">
<meta property="article:tag" content="课程笔记">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="斯坦福">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thinklive1.github.io/images/obsidian/20230226101843.png">


<link rel="canonical" href="https://thinklive1.github.io/thinklive/16615/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://thinklive1.github.io/thinklive/16615/","path":"thinklive/16615/","title":"基于斯坦福cs106b的c++数据结构笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>基于斯坦福cs106b的c++数据结构笔记 | thinklive</title>
  







<script type="text/javascript" async src="/js/fairyDustCursor.js"></script>
<script type="text/javascript" async src="/js/tab-title.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="thinklive" type="application/atom+xml">
</head>
<script src="/js/tab-title.js"></script>
<script type="text/javascript" async src="/js/text.js"></script>

<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>



  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">thinklive</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">dirichlet library</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索 | search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页-|-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页 | home</a></li><li class="menu-item menu-item-标签-|-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags</a></li><li class="menu-item menu-item-分类-|-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories</a></li><li class="menu-item menu-item-归档-|-archive"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archive</a></li><li class="menu-item menu-item-相册-|-photo"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册 | photo</a></li><li class="menu-item menu-item-留言-|-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言 | guestbook</a></li><li class="menu-item menu-item-感谢-|-thank"><a href="/thanks/" rel="section"><i class="fa custom thanks fa-fw"></i>感谢 | thank</a></li><li class="menu-item menu-item-游戏-|-game"><a href="/game/bad1.html" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏 | game</a></li><li class="menu-item menu-item-神龛-|-shrine"><a href="/cyberblog/" rel="section"><i class="fa fa-microchip fa-fw"></i>神龛 | shrine</a></li><li class="menu-item menu-item-资源地图-|-resourcemap"><a href="/webstack/" rel="section"><i class="fa fa-list fa-fw"></i>资源地图 | resourcemap</a></li><li class="menu-item menu-item-思维导图-|-mindmap"><a href="/mindmap/index.html" rel="section"><i class="fa fa-map fa-fw"></i>思维导图 | mindmap</a></li><li class="menu-item menu-item-网站地图-|-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>网站地图 | sitemap</a></li><li class="menu-item menu-item-蒸汽-|-steam"><a href="/steamgames/index.html" rel="section"><i class="fa fa custum steam fa-fw"></i>蒸汽 | steam</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">


<!--网易云音乐插件-->
<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->
<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--网易云playlist外链地址-->   
<meting-js
    server="netease"
    type="playlist" 
    id="2762741085"
    mini="false"
    fixed="false"
    list-folded="true"
    autoplay="false"
    volume="0.2"
    theme="#4c4c4c"
    order="random"
    loop="all"
    preload="auto"
    lrc-type="2"
    mutex="true">
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">一些查找和排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">容器类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%85%83%E7%B4%A0"><span class="nav-number">1.</span> <span class="nav-text">检查表中是否存在元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E8%A1%A8%E4%B8%AD"><span class="nav-number">2.</span> <span class="nav-text">将元素插入表中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">3.</span> <span class="nav-text">从表中删除一个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%97%E5%AE%BE%E6%B1%89%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">“罗宾汉哈希表”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">string类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">一些实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">6.1.</span> <span class="nav-text">优先队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">6.2.</span> <span class="nav-text">计数排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E9%A2%98%E9%9B%86"><span class="nav-number">7.</span> <span class="nav-text">错题集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96"><span class="nav-number">7.1.</span> <span class="nav-text">递归的效率优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%AE%A1%E7%AE%97%E7%BB%99%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BB%93%E6%9E%84%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">7.2.</span> <span class="nav-text">递归计算给定元素的不同结构哈夫曼树的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E5%90%83%E5%B7%A7%E5%85%8B%E5%8A%9B%E9%97%AE%E9%A2%98"><span class="nav-number">7.3.</span> <span class="nav-text">递归解决吃巧克力问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%82%E5%87%BA%E5%90%83%E6%B3%95%E6%95%B0%E9%87%8F"><span class="nav-number"></span> <span class="nav-text">求出吃法数量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%AF%8F%E7%A7%8D%E5%90%83%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">打印每种吃法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E7%BF%BB%E7%85%8E%E9%A5%BC%E9%97%AE%E9%A2%98"><span class="nav-number">0.1.</span> <span class="nav-text">递归解决翻煎饼问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E5%A4%A9%E5%B9%B3%E9%97%AE%E9%A2%98"><span class="nav-number">0.2.</span> <span class="nav-text">递归解决天平问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98"><span class="nav-number">0.3.</span> <span class="nav-text">递归解决找零问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BF%86%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number"></span> <span class="nav-text">不使用记忆的情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BF%86%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="nav-number"></span> <span class="nav-text">使用记忆进行优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%A9%B7%E4%B8%BE%E4%BB%98%E8%B4%A6%E5%8D%95"><span class="nav-number">0.1.</span> <span class="nav-text">递归穷举付账单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AF%BB%E6%89%BE%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E5%88%97"><span class="nav-number">0.2.</span> <span class="nav-text">递归寻找完全平方数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92"><span class="nav-number">0.3.</span> <span class="nav-text">汉诺塔递归</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="thinklive"
      src="/images/thive.png">
  <p class="site-author-name" itemprop="name">thinklive</p>
  <div class="site-description" itemprop="description">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinklive1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinklive1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/t469631989@gmail.com" title="E-Mail → t469631989@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/38099250?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;38099250?spm_id_from&#x3D;333.1007.0.0" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/thinklive" title="steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;thinklive" rel="noopener me" target="_blank"><i class="fa custom steam fa-fw"></i>steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

<div style="Text-align:center;width:100%"><div style="margin:0 auto"><canvas id="canvas" style="width:60%" height="100" width="700">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){function t(t,e){for(var a=0;a<l[e].length;a++)for(var n=0;n<l[e][a].length;n++)1==l[e][a][n]&&(h.beginPath(),h.arc(14*(g+2)*t+2*n*(g+1)+(g+1),2*a*(g+1)+(g+1),g,0,2*Math.PI),h.closePath(),h.fill())}function e(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a=[];a.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var r=c.length-1;r>=0;r--)a[r]!==c[r]&&t.push(r+"_"+(Number(c[r])+1)%10);for(var r=0;r<t.length;r++)n.apply(this,t[r].split("_"));c=a.concat()}function a(){for(var t=0;t<d.length;t++)d[t].stepY+=d[t].disY,d[t].x+=d[t].stepX,d[t].y+=d[t].stepY,(d[t].x>i+g||d[t].y>f+g)&&(d.splice(t,1),t--)}function n(t,e){for(var a=[1,2,3],n=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],r=0;r<l[e].length;r++)for(var o=0;o<l[e][r].length;o++)if(1==l[e][r][o]){var h={x:14*(g+2)*t+2*o*(g+1)+(g+1),y:2*r*(g+1)+(g+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*a[Math.floor(Math.random()*a.length)],color:n[Math.floor(Math.random()*n.length)],disY:1};d.push(h)}}function r(){o.height=100;for(var e=0;e<c.length;e++)t(e,c[e]);for(var e=0;e<d.length;e++)h.beginPath(),h.arc(d[e].x,d[e].y,g,0,2*Math.PI),h.fillStyle=d[e].color,h.closePath(),h.fill()}var l=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],o=document.getElementById("canvas");if(o.getContext){var h=o.getContext("2d"),f=100,i=700;o.height=f,o.width=i,h.fillStyle="#f00",h.fillRect(10,10,50,50);var c=[],d=[],g=o.height/20-1;!function(){var t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date);c.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6])}(),clearInterval(v);var v=setInterval(function(){e(),a(),r()},50)}}()</script></div>
<img src="/images/thinklive_cyber.png"; z-index: 0; style="max-width: 100%; width: auto; height: auto;background-color: #fff;">

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thinklive1.github.io/thinklive/16615/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/thive.png">
      <meta itemprop="name" content="thinklive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="thinklive">
      <meta itemprop="description" content="起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="基于斯坦福cs106b的c++数据结构笔记 | thinklive">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于斯坦福cs106b的c++数据结构笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-20 19:53:48" itemprop="dateCreated datePublished" datetime="2024-01-20T19:53:48+08:00">2024-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-27 20:47:59" itemprop="dateModified" datetime="2023-11-27T20:47:59+08:00">2023-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课程笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        
        </div>
      </header>
   

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="一些查找和排序算法">一些查找和排序算法</h2>
<p>二分查找法 <img src="/images/obsidian/20230226101843.png" title="image" alt="图片" /> 最坏情况：log2n <span id="more"></span> 寻找最小排序 <img src="/images/obsidian/20230224172126.png" title="image" alt="图片" /> 向前插入算法 <img src="/images/obsidian/20230226090109.png" title="image" alt="图片" /></p>
<p>合并算法接受两个排序的 列出并将它们组合成一个 排序列表。 ● 虽然两个列表都是非空的，但比较它们的 第一要素。 删除较小的元素 并将其附加到输出。 ● 一旦一个列表为空，添加所有元素 另一个列表输出。 ● 它运行时间为 O(n)，其中 n 是总数 合并的元素数量。 <img src="/images/obsidian/20230226090958.png" title="image" alt="图片" /> 无限递归后的合并算法 <img src="/images/obsidian/20230226093232.png" title="image" alt="图片" /> 复杂度：nlog2n</p>
<h2 id="容器类">容器类</h2>
<p><code>set（集合）：无序不允许重复的容器类，可以添加删除元素 You can add a value to a Set by writing   set += value;  s. ● You can remove a value from a Set by writing   set -= value;   ● You can check if a value exists in a Set by writing   set.contains(value)</code>map(键值对的集合) 如果没有对应key的value，返回默认值（见定义文件） `vector vector的remove根据移除元素的索引有1-n的复杂度，移除尾部为O(1)，如果不在意索引，可以交换要移除元素和尾部元素再移除</p>
<h1 id="哈希表">哈希表</h1>
<p>哈希表的负载因子α表示元素和表格键数量的比，决定了查找速度</p>
<h2 id="检查表中是否存在元素">检查表中是否存在元素</h2>
<p>● 计算元素的散列码。 ● 跳转到表格中的那个位置。 ● 向前扫描——必要时环绕——直到项目或一个 发现空插槽。</p>
<h2 id="将元素插入表中">将元素插入表中</h2>
<p>● 如果项目已经存在，什么也不做。 ● 否则，跳转到元素哈希码给定的槽。 向前走——必要时环绕——直到一个空白点或 找到墓碑插槽。 然后，将项目放在那里。</p>
<h2 id="从表中删除一个元素">从表中删除一个元素</h2>
<p>● 跳转到由元素的散列码给定的槽。 ● 向前走——必要时环绕——直到物品或 发现空插槽。 如果找到该项目，请将其替换为 墓碑。</p>
<h2 id="罗宾汉哈希表">“罗宾汉哈希表”</h2>
<ul>
<li>如果插入的值比其将插入的位置的值距离索引更远，则替换插入值和当前值</li>
<li>删除值时，将后其离原键远的元素前移</li>
<li>★ 罗宾汉哈希一览 ★</li>
<li>检查表中是否存在元素：</li>
<li>● 跳转到表中由元素的散列码给出的位置。</li>
<li>● 向前扫描——如有必要环绕——记录有多少步 你拿走了。 当您找到该项目、找到一个空白槽或找到一个 离家更近的空位比你走的步数还多。</li>
<li>将元素插入表中：</li>
<li>● 如果该元素已在表中，则什么也不做。</li>
<li>● 跳转到由元素的散列码给出的表槽。 向前扫描 - 换行 如有必要，四处走走——记录所走的步数。 如果你找到一个 空插槽，将元素放在那里。 否则，如果当前插槽已满并且 比您插入的元素更靠近家，将要插入的项目放在那里， 替换那个位置的元素，然后继续插入，就好像你 正在插入被置换的元素。</li>
<li>从表中删除一个元素：</li>
<li>● 跳转到由元素的散列码给定的槽。</li>
<li>● 向前走——如有必要，环绕——直到物品或空槽被放置 成立。 如果找到该项目，请将其删除。 然后，继续前进——包裹 around as necessary – 将表中的元素向后移动一个槽位，直到 找到空插槽或位于其原始位置的项目</li>
</ul>
<h2 id="string类">string类</h2>
<p>str::npos表示容器的最后一个成员位置 if (s.find("e") != string::npos) //find函数找不到时返回npos if s in str: string obj; obj.substr(int pos) //pos为要包含的第一个字符串的位置 <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> a = "0123456789abcdefghij";</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    // count is npos, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub1 = a.substr(10);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub1 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // both pos and pos+count are within bounds, returns [pos, pos+count)</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub2 = a.substr(5, 3);</span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub2 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    // pos is within bounds, pos+count is not, returns [pos, size())</span><br><span class="line">    [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub4 = a.substr(a.size()-3, 50);</span><br><span class="line">    // this is effectively equivalent to</span><br><span class="line">    // std::string sub4 = a.substr(17, 3);</span><br><span class="line">    // since a.size() == 20, pos == a.size()-3 == 17, and a.size()-pos == 3</span><br><span class="line"></span><br><span class="line">    [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub4 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // pos is out of bounds, throws</span><br><span class="line">        [std::string](http://en.cppreference.com/w/cpp/string/basic_string) sub5 = a.substr(a.size()+3, 50);</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; sub5 &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125; catch(const [std::out_of_range](http://en.cppreference.com/w/cpp/error/out_of_range)&amp; e) &#123;</span><br><span class="line">        [std::cout](http://en.cppreference.com/w/cpp/io/cout) &lt;&lt; &quot;pos exceeds string size\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">abcdefghij</span><br><span class="line">567</span><br><span class="line">hij</span><br><span class="line">pos exceeds string size</span><br></pre></td></tr></table></figure>
<p>`replace和insert str1.insert(start, str2) str1.replace(start, length, str2)</p>
<h2 id="一些实现">一些实现</h2>
<h3 id="优先队列">优先队列</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"># include &quot;HeapPQueue.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">HeapPQueue::HeapPQueue() &#123;</span><br><span class="line">    elems = new DataPoint[INITIAL_SIZE] &#123;&#125;;</span><br><span class="line">    for (int i=0;i&lt;INITIAL_SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        elems[i].weight=0;</span><br><span class="line">    &#125;</span><br><span class="line">    allocatedSize=INITIAL_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapPQueue::~HeapPQueue() &#123;</span><br><span class="line">    delete [] elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int HeapPQueue::size() const &#123;</span><br><span class="line">    return logicalSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool HeapPQueue::isEmpty() const &#123;</span><br><span class="line">    return logicalSize==0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapPQueue::enqueue(const DataPoint&amp; data) &#123;</span><br><span class="line">    if (logicalSize+1&lt;allocatedSize)</span><br><span class="line">    &#123;</span><br><span class="line">        if (logicalSize==0)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[1]=data;</span><br><span class="line">            logicalSize++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            logicalSize++;</span><br><span class="line">            int i=1;</span><br><span class="line">            while (data.weight&gt;elems[i].weight &amp;&amp; i&lt;=logicalSize &amp;&amp; elems[i].weight!=0)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i&lt;logicalSize)</span><br><span class="line">            &#123;</span><br><span class="line">                DataPoint temp=elems[i];</span><br><span class="line">                elems[i]=data;</span><br><span class="line">                for(i;i&lt;logicalSize;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    DataPoint temp_plus=elems[i+1];</span><br><span class="line">                    elems[i+1]=temp;</span><br><span class="line">                    temp=temp_plus;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                elems[i]=data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::peek() const &#123;</span><br><span class="line">    return elems[logicalSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataPoint HeapPQueue::dequeue() &#123;</span><br><span class="line">    DataPoint to_return=elems[1];</span><br><span class="line">    if(!isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for (int i=1;i&lt;logicalSize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            elems[i]=elems[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        elems[logicalSize]=&#123;&#125;;</span><br><span class="line">        logicalSize--;</span><br><span class="line">    &#125;</span><br><span class="line">    return to_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计数排序">计数排序</h3>
<p>首先算出最大值，然后用一个数组的索引存储待排序数组的成员，其索引对应值存储出现次数，然后用两个同步的for循环和递增的next参数表示排序中的索引值来进行排序（也就是重新赋值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/* Given a Vector&lt;int&gt;, returns the largest number in that Vector. */</span><br><span class="line">int maxOf(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Bounds-check inputs. */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        error(&quot;Can&#x27;t find the maximum of no values.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int result = values[0];</span><br><span class="line">    for (int i = 1; i &lt; values.size(); i++) &#123;</span><br><span class="line">        result = max(result, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a list of numbers, creates a histogram from those numbers. */</span><br><span class="line">Vector&lt;int&gt; histogramFor(const Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Create a histogram with the right number of slots. Initially, all values</span><br><span class="line">     * in the histogram will be zero.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; histogram(maxOf(values) + 1);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the input vector, incrementing the histogram values. */</span><br><span class="line">    for (int value: values) &#123;</span><br><span class="line">        histogram[value]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return histogram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void countingSort(Vector&lt;int&gt;&amp; values) &#123;</span><br><span class="line">    /* Edge Case: If the array is empty, then it&#x27;s already sorted. This is</span><br><span class="line">     * needed because we can&#x27;t take the maximum value of an empty vector.</span><br><span class="line">     */</span><br><span class="line">    if (values.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Form the histogram. */</span><br><span class="line">    auto histogram = histogramFor(values);</span><br><span class="line">    </span><br><span class="line">    /* Scan across the histogram writing out the appropriate number of copies</span><br><span class="line">     * of each value. We track the index of the next free spot to write to,</span><br><span class="line">     * as it varies based on how many items we&#x27;ve written out so far.</span><br><span class="line">     */</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (int value = 0; value &lt; histogram.size(); value++) &#123;</span><br><span class="line">        /* Write out the right number of copies. */</span><br><span class="line">        for (int copy = 0; copy &lt; histogram[value]; copy++) &#123;</span><br><span class="line">            values[next] = value;</span><br><span class="line">            next++;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="错题集">错题集</h2>
<h3 id="递归的效率优化">递归的效率优化</h3>
<p>每次递归都会创造所有变量的临时复制 基于递归的这种性质，它会需要巨大的时间和空间来完成任务，并且会造成算力上的浪费。 通过记忆表机制能部分解决这个问题，方法是每次递归的返回值都会按索引存入一个表格，并且每次递归前查询表格中是否有结果，这样可以让每个临时副本的运算结果能被所有函数共享。</p>
<h3 id="递归计算给定元素的不同结构哈夫曼树的数量">递归计算给定元素的不同结构哈夫曼树的数量</h3>
<p>对每个给定元素集来说，首先要做到是确定根节点元素是第几个大的元素，确定之后，左子树和右子树的元素数也随之确定，在此之后分别对左节点和右节点作为根节点做同样的递归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int numBSTsOfSize(int n) &#123;</span><br><span class="line"></span><br><span class="line">  /* Base case: There’s only one tree of size 0, namely, the empty BST. */</span><br><span class="line">  if (n == 0) return 1;</span><br><span class="line">  </span><br><span class="line">  /* Recursive case: Imagine all possible ways to choose a root and build the</span><br><span class="line">   * left and right subtrees.</span><br><span class="line">  */</span><br><span class="line">  int result = 0;</span><br><span class="line">  </span><br><span class="line">  /* Put the the nodes at indices 0, 1, 2, ..., n-1 up at the root. */</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    /* Each combination of a BST of i elements and a BST of n - 1 - i elements</span><br><span class="line">     * can be used to build one BST of n elements. The number of pairs of</span><br><span class="line">     * trees we can make this way is given by the product of the number of</span><br><span class="line">     * trees of each type.</span><br><span class="line">     */</span><br><span class="line">     result += numBSTsOfSize(i) * numBSTsOfSize(n - 1 - i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决吃巧克力问题">递归解决吃巧克力问题</h3>
<h1 id="求出吃法数量">求出吃法数量</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (numSquares&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">    error(&quot;输入数据不能为负数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (numSquares&lt;=1)</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    return numWaysToEat(numSquares-1)+numWaysToEat(numSquares-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打印每种吃法">打印每种吃法</h1>
<p>`需要一个辅助向量储存历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* Print all ways to eat numSquares more squares, given that we&#x27;ve</span><br><span class="line"> * already taken the bites given in soFar.</span><br><span class="line"> */</span><br><span class="line">void printWaysToEatRec(int numSquares, const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /* Base Case: If there are no squares left, the only option is to use</span><br><span class="line">     * the bites we&#x27;ve taken already in soFar.</span><br><span class="line">     */</span><br><span class="line">    if (numSquares == 0) &#123;</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If there is one square lfet, the only option is to eat</span><br><span class="line">     * that square.</span><br><span class="line">     */</span><br><span class="line">    else if (numSquares == 1) &#123;</span><br><span class="line">        cout &lt;&lt; soFar + 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Otherwise, we take take bites of size one or of size two. */</span><br><span class="line">    else &#123;</span><br><span class="line">        printWaysToEatRec(numSquares - 1, soFar + 1);</span><br><span class="line">        printWaysToEatRec(numSquares - 2, soFar + 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printWaysToEat(int numSquares) &#123;</span><br><span class="line">    if (numSquares &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me some chocolate!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We begin without having made any bites. */</span><br><span class="line">    printWaysToEatRec(numSquares, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决翻煎饼问题">递归解决翻煎饼问题</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">bool isSorted(Stack&lt;double&gt; pancakes) &#123;</span><br><span class="line">    double last = -1; // No pancakes have negative size;</span><br><span class="line"></span><br><span class="line">    while (!pancakes.isEmpty()) &#123;</span><br><span class="line">        /* Check the next pancake. */</span><br><span class="line">        double next = pancakes.pop();</span><br><span class="line">        if (next &lt; last) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Pancakes are in increasing order! */</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Given a stack of pancakes and a flip size, flips that many pancakes</span><br><span class="line"> * on the top of the stack.</span><br><span class="line"> */</span><br><span class="line">Stack&lt;double&gt; flip(Stack&lt;double&gt; pancakes, int numToFlip) &#123;</span><br><span class="line">    /* Take the top pancakes off the stack and run them into a queue.</span><br><span class="line">     * This preserves the order in which they were removed.</span><br><span class="line">     */</span><br><span class="line">    Queue&lt;double&gt; buffer;</span><br><span class="line">    for (int i = 0; i &lt; numToFlip; i++) &#123;</span><br><span class="line">        buffer.enqueue(pancakes.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Move the pancakes back. */</span><br><span class="line">    while (!buffer.isEmpty()) &#123;</span><br><span class="line">        pancakes.push(buffer.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pancakes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; sortStack(Stack&lt;double&gt; pancakes, int numFlips) &#123;</span><br><span class="line">    /* Base Case: If the stack is sorted, great! We&#x27;re done, and no flips</span><br><span class="line">     * were needed.</span><br><span class="line">     */</span><br><span class="line">    if (isSorted(pancakes)) &#123;</span><br><span class="line">        return &#123; &#125;; // No flips</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base Case: If the stack isn&#x27;t sorted and we&#x27;re out of flips, then</span><br><span class="line">     * there is no way to sort things.</span><br><span class="line">     */</span><br><span class="line">    else if (numFlips == 0) &#123;</span><br><span class="line">        return Nothing;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive Case: The stack isn&#x27;t sorted and we still have flips left.</span><br><span class="line">     * The next flip could flip 1, 2, 3, ..., or all N of the pancakes.</span><br><span class="line">     * Try each option and see whether any of them work.</span><br><span class="line">     */</span><br><span class="line">    for (int numToFlip = 1; numToFlip &lt;= pancakes.size(); numToFlip++) &#123;</span><br><span class="line">        /* Make the flip and see if it works. */</span><br><span class="line">        auto result = sortStack(flip(pancakes, numToFlip), numFlips - 1);</span><br><span class="line">        if (result != Nothing) &#123;</span><br><span class="line">            /* The result holds all the remaining flips but doesn&#x27;t know about</span><br><span class="line">             * the flip we just did. Insert that flip at the beginning.</span><br><span class="line">             */</span><br><span class="line">            result.value().insert(0, numToFlip);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we&#x27;re here, then no matter which flip we make first, we cannot</span><br><span class="line">     * get the pancakes sorted. Give up.</span><br><span class="line">     */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归解决天平问题">递归解决天平问题</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool isMeasurableRec(int amount, const Vector&lt;int&gt;&amp; weights, int index) &#123;</span><br><span class="line">  if (index == weights.size()) &#123;</span><br><span class="line">      return amount == 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      return isMeasurableRec(amount,                  weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount + weights[index], weights, index + 1) ||</span><br><span class="line">             isMeasurableRec(amount - weights[index], weights, index + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMeasurable(int amount, const Vector&lt;int&gt;&amp; weights) &#123;</span><br><span class="line">    return isMeasurableRec(amount, weights, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象一下，我们首先将要测量的数量（称为 <em>n</em> ）放在天平的左侧。 这使得规模上的不平衡等于 <em>n</em> 。 想象一下，有某种方法可以测量 <em>n</em> 。 如果我们一次将一个重量放在秤上，我们可以查看第一个重量的放置位置（假设它的重量为 <em>w</em> ）。 它必须：</p>
<ul>
<li>向左走，使规模上的净不平衡 <em>n + w</em> ，或</li>
<li>向右走，使规模上的净不平衡 <em>n – w</em> ，或</li>
<li>根本不习惯，留下净不平衡 <em>n</em> 。</li>
</ul>
<p>如果确实有可能测量 <em>n</em> ，那么这三个选项之一必须是实现它的方法，即使我们不知道它是哪一个。 然后我们要问的问题是，是否有可能使用剩余的权重来衡量新的净失衡——我们可以递归地确定！ 另一方面，如果无法测量 <em>n</em> ，那么无论我们选择哪个选项，我们都会发现没有办法使用剩余的权重来使一切平衡！</p>
<p>如果我们递归地进行，我们在这里，我们需要考虑我们的基本情况。 我们可以选择的选项有很多。 一个简单的方法如下：假设我们根本没有任何重量，我们被要求查看是否可以不使用重量来测量某些重量。 在什么情况下我们可以这样做？ 好吧，如果我们称重的东西有一个非零重量，我们就不可能测量它——把它放在秤上会使它倾斜到某一边，但这并不能告诉我们它有多少重量。 另一方面，如果我们称量的东西是完全失重的，那么把它放在秤上也不会导致它倾斜，让我们相信它确实是失重的！ 因此，作为我们的基本情况，我们会说当我们减少到没有剩余权重时， <em>，我们可以精确测量n</em> 如果 <em>n = 0</em> 。 考虑到这一点，这是我们的代码：</p>
<h3 id="递归解决找零问题">递归解决找零问题</h3>
<h1 id="不使用记忆的情况">不使用记忆的情况</h1>
<p>`从第一个硬币开始遍历，并穷举它的所有枚数，将其作为下一枚硬币的参数传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    else if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (coins.isEmpty()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins.first();</span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsFor(cents - copies * coin,</span><br><span class="line">                                                     coins - coin);</span><br><span class="line">          /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用记忆进行优化">使用记忆进行优化</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/* How few coins are needed to make the total, given that we can only use</span><br><span class="line"> * coins from index startIndex and onward?</span><br><span class="line"> */</span><br><span class="line">int fewestCoinsRec(int cents, const Vector&lt;int&gt;&amp; coins, int startIndex,Grid&lt;int&gt;&amp; memo) &#123;</span><br><span class="line">    /* Base case: You need no coins to give change for no cents. */</span><br><span class="line">    if (cents == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: No coins exist. Then it&#x27;s not possible to make the</span><br><span class="line">     * amount. In that case, give back a really large value as a</span><br><span class="line">     * sentinel.</span><br><span class="line">     */</span><br><span class="line">    else if (startIndex == coins.size()) &#123;</span><br><span class="line">        return cents + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Base case: We already know the answer. */</span><br><span class="line">    else if (memo[cents][startIndex] != -1) &#123;</span><br><span class="line">        return memo[cents][startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: Pick a coin, then try using each distinct number of</span><br><span class="line">     * copies of it that we can.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        /* The best we&#x27;ve found so far. We initialize this to a large value so</span><br><span class="line">         * that it&#x27;s replaced on the first iteration of the loop. Do you see</span><br><span class="line">         * why cents + 1 is a good choice?</span><br><span class="line">         */</span><br><span class="line">        int bestSoFar = cents + 1;</span><br><span class="line"></span><br><span class="line">        /* Pick a coin. */</span><br><span class="line">        int coin = coins[startIndex];</span><br><span class="line"></span><br><span class="line">        /* Try all amounts of it. */</span><br><span class="line">        for (int copies = 0; copies * coin &lt;= cents; copies++) &#123;</span><br><span class="line">            /* See what happens if we make this choice. Once we use this</span><br><span class="line">             * coin, we won&#x27;t use the same coin again in the future.</span><br><span class="line">             */</span><br><span class="line">            int thisChoice = copies + fewestCoinsRec(cents - copies * coin,</span><br><span class="line">                                                     coins, startIndex + 1,</span><br><span class="line">                                                     memo);</span><br><span class="line"></span><br><span class="line">            /* Is this better than what we have so far? */</span><br><span class="line">            if (thisChoice &lt; bestSoFar) &#123;</span><br><span class="line">                bestSoFar = thisChoice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Return whatever worked best. */</span><br><span class="line">        memo[cents][startIndex] = bestSoFar;</span><br><span class="line">        return bestSoFar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fewestCoinsFor(int cents, const Set&lt;int&gt;&amp; coins) &#123;</span><br><span class="line">    /* Can&#x27;t have a negative number of cents. */</span><br><span class="line">    if (cents &lt; 0) &#123;</span><br><span class="line">        error(&quot;You owe me money, not the other way around!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Convert from a Set&lt;int&gt; to a Vector&lt;int&gt; so we have a nice ordering</span><br><span class="line">     * on things.</span><br><span class="line">     */</span><br><span class="line">    Vector&lt;int&gt; coinVec;</span><br><span class="line">    for (int coin: coins) &#123;</span><br><span class="line">        coinVec += coin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build our memoization table. Since the number of cents left ranges from</span><br><span class="line">     * 0 to cents, we need cents+1 rows. Since the start index of the coin</span><br><span class="line">     * ranges from 0 to coins.size(), we make coins.size() + 1 columns.</span><br><span class="line">     *</span><br><span class="line">     * -1 is used as a sentinel to indicate &quot;nothing has been computed here</span><br><span class="line">     * yet.&quot;</span><br><span class="line">     */</span><br><span class="line">    Grid&lt;int&gt; memo(cents + 1, coins.size() + 1, -1);</span><br><span class="line"></span><br><span class="line">    /* Now ask how many coins are needed to make the total, using any coins</span><br><span class="line">     * from index 0 onward.</span><br><span class="line">     */</span><br><span class="line">    return fewestCoinsRec(cents, coinVec, 0, memo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归穷举付账单">递归穷举付账单</h3>
<p>递归机制：对第一个人来说，0-total所有金额都会付一遍，随后传递给下一个人，当只有一人时，付清所有余额并打印账单 传递参数：string,int的映射存储目前为止的账单，string集合存储所有付账者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void listPossiblePaymentsRec(int total, const Set&lt;string&gt;&amp; people,const Map&lt;string, int&gt;&amp; payments) &#123;</span><br><span class="line">    /* Base case: if there&#x27;s one person left, they have to pay the whole bill. */</span><br><span class="line">    if (people.size() == 1) &#123;</span><br><span class="line">        Map&lt;string, int&gt; finalPayments = payments;</span><br><span class="line">        finalPayments[people.first()] = total;</span><br><span class="line">        cout &lt;&lt; finalPayments &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Recursive case: The first person has to pay some amount between 0 and the</span><br><span class="line">     * total amount. Try all of those possibilities.</span><br><span class="line">     */</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int payment = 0; payment &lt;= total; payment++) &#123;</span><br><span class="line">            /* Create a new assignment of people to payments in which this first</span><br><span class="line">             * person pays this amount.</span><br><span class="line">             */</span><br><span class="line">            Map&lt;string, int&gt; updatedPayments = payments;</span><br><span class="line">            updatedPayments[people.first()] = payment;</span><br><span class="line">            listPossiblePaymentsRec(total - payment, people - people.first(),updatedPayments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void listPossiblePayments(int total, const Set&lt;string&gt;&amp; people) &#123;</span><br><span class="line">    /* Edge cases: we can&#x27;t pay a negative total, and there must be at least one</span><br><span class="line">     * person.</span><br><span class="line">     */</span><br><span class="line">    if (total &lt; 0) error(&quot;Guess you&#x27;re an employee?&quot;);</span><br><span class="line">    if (people.isEmpty()) error(&quot;Dine and dash?&quot;);</span><br><span class="line"> listPossiblePaymentsRec(total, people, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归寻找完全平方数列">递归寻找完全平方数列</h3>
<p>主要参数为sofar——用于存储目前的序列和一个set用于存储还没放入数列的数字，`确保这两者同时被传递，且其并集为所有数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSquareSequence(int n) &#123;</span><br><span class="line">    /*Validate input.*/</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        error(&quot;Don&#x27;t be so negative!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Build a set of the numbers 1, 2, 3, ..., n. */</span><br><span class="line">    Set&lt;int&gt; options;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        options += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return findSequenceRec(options, &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;Vector&lt;int&gt;&gt; findSequenceRec(const Set&lt;int&gt;&amp; unused,</span><br><span class="line">                                      const Vector&lt;int&gt;&amp; soFar) &#123;</span><br><span class="line">    /*Base Case: If all numbers are used, we have our sequence!*/</span><br><span class="line">    if (unused.isEmpty()) &#123;</span><br><span class="line">        return soFar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Recursive Case: Some number comes next. Try each of them and see which</span><br><span class="line">     * one we should pick.</span><br><span class="line">     */</span><br><span class="line">    for (int next: unused) &#123;</span><br><span class="line">        /* We can use this if either</span><br><span class="line">         *</span><br><span class="line">         * 1. the sequence is empty, so we&#x27;re first in line, or</span><br><span class="line">         * 2. the sequence is not empty, but we sum to a perfect square</span><br><span class="line">         *    with the previous term.</span><br><span class="line">         */</span><br><span class="line">        if (soFar.isEmpty() ||</span><br><span class="line">            isPerfectSquare(next + soFar[soFar.size() - 1])) &#123;</span><br><span class="line">            /* See what happens if we extend with this number. */</span><br><span class="line">            auto result = findSequenceRec(unused - next, soFar + next);</span><br><span class="line">            if (result != Nothing) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Tried all options and none of them worked. Oh well! */</span><br><span class="line">    return Nothing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="汉诺塔递归">汉诺塔递归</h3>
<p>假设有三座汉诺塔，<code>start ,temp ,finish</code> 对n层的汉诺塔问题，先考虑n-1层的，随后考虑n-2层，到最后只需要考虑两层问题，两层的汉诺塔非常容易解决，起点为start,终点是temp,临时塔为finish，最后我们得到temp上的两层汉诺塔 这时将start的3移动到finish塔，这时只要将两层汉诺塔转移到finish则完成了三层汉诺塔，这个过程中的起点为temp,终点是finish,临时塔是start 以此类推，四层塔基于三层塔，<code>n</code>层塔基于<code>n-1</code>塔，汉诺塔问题解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int moveTower(int numDisks, char start, char finish, char temp) &#123;</span><br><span class="line">    if (numDisks == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int movesOne = moveTower(numDisks - 1, start, temp, finish);</span><br><span class="line">        moveSingleDisk(start, finish);</span><br><span class="line">        int movesTwo = moveTower(numDisks - 1, temp, finish, start);</span><br><span class="line"></span><br><span class="line">        return 1 + movesOne + movesTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 课程笔记</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 数据结构与算法</a>
              <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c++</a>
              <a href="/tags/%E6%96%AF%E5%9D%A6%E7%A6%8F/" rel="tag"><i class="fa fa-tag"></i> 斯坦福</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/thinklive/48468/" rel="prev" title="基于斯坦福cs106l的c++编程规范笔记">
                  <i class="fa fa-angle-left"></i> 基于斯坦福cs106l的c++编程规范笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/thinklive/15197/" rel="next" title="基于c++ primer plus的读书笔记">
                  基于c++ primer plus的读书笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">thinklive</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">367k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:13</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 技术支持
  </div><script defer src="/lib/three.js"></script><script defer src="/lib/lines.js"></script><script defer src="/lib/waves.js"></script>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  <script src="/js/third-party/addtoany.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://thinklive1.github.io/thinklive/16615/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"thinklive1/blog_comments","issue_term":"pathname","theme":"photon-dark"}</script>
<script src="/js/third-party/comments/utterances.js"></script>
<script>
    const snowflakes = ["❄", "❄", "❆", "❅", "✥","❄", "❄", "❆", "❅", "✥","✻"];
    // 创建雪花
    function createSnowflake() {
        const snowflake = document.createElement("span");
        snowflake.classList.add("snowflake");
        const randomIndex = Math.floor(Math.random() * snowflakes.length);
        snowflake.textContent = snowflakes[randomIndex];
        
        // 起始位置
        /* 80%概率 生成在页面两侧 30% 的位置
        const probability = Math.random();
        let startPosition = Math.random() * 100;

        if (probability < 0.8) {
            startPosition = Math.random() < 0.5 ? Math.random() * 30 : (Math.random() * 30) + 70;
        }
        snowflake.style.left = `${startPosition}vw`;
        */
        snowflake.style.left = `${Math.random() * 100}vw`;
        snowflake.style.top = `-30px`;
        // 雪花大小与透明度
        const size = Math.random() * 18 + 10;
        snowflake.style.fontSize = `${size}px`;
        const opacity = Math.random() * 0.6 + (size > 18 ? 0.4 : 0);
        snowflake.style.setProperty("--opacity", opacity);
        // 动画持续时间
        const fallDuration = Math.random() * 10 + 10;
        // 旋转持续时间
        const rotateDuration = Math.random() * 3 + 1;

        snowflake.style.animationDuration = `${fallDuration}s, ${fallDuration}s`; // 向 CSS 添加淡出动画的持续时间
        // 横向幅度
        const translateX = (Math.random() * 500 - 200);
        snowflake.style.setProperty("--translateX", `${translateX}px`);
        // 纵向幅度
        snowflake.style.setProperty("--translateY", `${window.innerHeight}px`);

        document.body.appendChild(snowflake);
        // 移除雪花
        setTimeout(() => {
            snowflake.remove();
        }, fallDuration * 1000);
    }
    
    function snowfallAnimation() {
        // 载入时若边栏是隐藏状态则不加载雪花
        const sidebarnav = document.querySelector('.sidebar');
        const sidebarnavdisplay = window.getComputedStyle(sidebarnav).getPropertyValue('display'); 
        if (sidebarnavdisplay !== 'none') {
            createSnowflake();
        }
        setTimeout(snowfallAnimation, 150); // 生成速度，毫秒
    }
    snowfallAnimation();
</script>

 <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

  <video autoplay loop muted playsinline style="position:fixed;top:50%;opacity: 0.8;left:50%;min-width:100%;min-height:100%;transform:translateX(-50%)translateY(-50%);z-index:-2;">
  <source src="/images/red.mp4" type="video/mp4">
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
