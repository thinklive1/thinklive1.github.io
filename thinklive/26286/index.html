<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinklive1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="概论 操作系统：控制管理计算机的硬件，协调控制资源分配，并为应用程序和用户提供接口以供使用 基本特征 操作系统的基本特征包括并发，共享，虚拟和异步  并发 并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。这是通过类似时间片轮转的机制实现的。 并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成两">
<meta property="og:type" content="article">
<meta property="og:title" content="考研笔记——操作系统部分">
<meta property="og:url" content="https://thinklive1.github.io/thinklive/26286/index.html">
<meta property="og:site_name" content="thinklive">
<meta property="og:description" content="概论 操作系统：控制管理计算机的硬件，协调控制资源分配，并为应用程序和用户提供接口以供使用 基本特征 操作系统的基本特征包括并发，共享，虚拟和异步  并发 并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。这是通过类似时间片轮转的机制实现的。 并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成两">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231204211804.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231204215335.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231204220927.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231205144922.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231205151119.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231206201905.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231206202831.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231206213642.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231207185300.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231207212550.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231208111859.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231209141033.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231209141146.png">
<meta property="og:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231212105100.png">
<meta property="article:published_time" content="2023-12-03T15:35:54.425Z">
<meta property="article:modified_time" content="2023-12-12T09:46:31.468Z">
<meta property="article:author" content="thinklive">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thinklive1.github.io/assets/%E8%8B%8F%E5%A4%A7linux_ppt/Pasted%20image%2020231204211804.png">


<link rel="canonical" href="https://thinklive1.github.io/thinklive/26286/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://thinklive1.github.io/thinklive/26286/","path":"thinklive/26286/","title":"考研笔记——操作系统部分"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>考研笔记——操作系统部分 | thinklive</title>
  







 <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
<script type="text/javascript" async src="/js/fairyDustCursor.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="thinklive" type="application/atom+xml">
</head>
<script src="/js/tab-title.js"></script>
<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">thinklive</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">dirichlet labrary</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索 | search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页-|-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页 | home</a></li><li class="menu-item menu-item-标签-|-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签 | tags</a></li><li class="menu-item menu-item-分类-|-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | categories</a></li><li class="menu-item menu-item-归档-|-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档 | archives</a></li><li class="menu-item menu-item-相册-|-photos"><a href="/photos/" rel="section"><i class="fa fa-camera fa-fw"></i>相册 | photos</a></li><li class="menu-item menu-item-留言-|-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言 | guestbook</a></li><li class="menu-item menu-item-感谢-|-thanks"><a href="/thanks/" rel="section"><i class="fa custom thanks fa-fw"></i>感谢 | thanks</a></li><li class="menu-item menu-item-游戏-|-game"><a href="/game/bad1.html" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏 | game</a></li><li class="menu-item menu-item-神龛-|-shrine"><a href="/cyberblog/" rel="section"><i class="fa fa-microchip fa-fw"></i>神龛 | shrine</a></li><li class="menu-item menu-item-资源地图-|-resourcemap"><a href="/webstack/" rel="section"><i class="fa fa-list fa-fw"></i>资源地图 | resourcemap</a></li><li class="menu-item menu-item-思维导图-|-mindmap"><a href="/mindmap/index.html" rel="section"><i class="fa fa-map fa-fw"></i>思维导图 | mindmap</a></li><li class="menu-item menu-item-网站地图-|-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>网站地图 | sitemap</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">


<!--网易云音乐插件-->
<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->
<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--网易云playlist外链地址-->   
<meting-js
    server="netease"
    type="playlist" 
    id="2762741085"
    mini="false"
    fixed="false"
    list-folded="true"
    autoplay="false"
    volume="0.2"
    theme="#4c4c4c"
    order="random"
    loop="all"
    preload="auto"
    lrc-type="2"
    mutex="true">
    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">概论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">1.1.</span> <span class="nav-text">基本特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%86%E5%8F%B2"><span class="nav-number">1.3.</span> <span class="nav-text">历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">1.4.</span> <span class="nav-text">运行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.1.</span> <span class="nav-text">内核机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">1.4.2.</span> <span class="nav-text">中断和异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC"><span class="nav-number">1.6.</span> <span class="nav-text">引导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">1.7.</span> <span class="nav-text">虚拟机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E6%88%90"><span class="nav-number">2.1.1.</span> <span class="nav-text">组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6"><span class="nav-number">2.1.2.</span> <span class="nav-text">控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1"><span class="nav-number">2.1.3.</span> <span class="nav-text">通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">线程和多线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.2.</span> <span class="nav-text">属性和状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.3.</span> <span class="nav-text">多线程模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-number">2.3.</span> <span class="nav-text">处理机调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.2.</span> <span class="nav-text">调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">2.4.</span> <span class="nav-text">同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.1.</span> <span class="nav-text">实现互斥的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">2.4.2.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.4.3.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">基于信号量的同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">信号量实现互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">信号量实现前驱关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">2.4.4.</span> <span class="nav-text">管程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.4.5.</span> <span class="nav-text">同步问题实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">生产者-消费者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">哲学家进餐问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%B8%E7%83%9F%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.5.4.</span> <span class="nav-text">吸烟问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="thinklive"
      src="/images/thive.png">
  <p class="site-author-name" itemprop="name">thinklive</p>
  <div class="site-description" itemprop="description">起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinklive1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinklive1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/t469631989@gmail.com" title="E-Mail → t469631989@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/38099250?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;38099250?spm_id_from&#x3D;333.1007.0.0" rel="noopener me" target="_blank"><i class="fa custom bilibili fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/thinklive" title="steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;thinklive" rel="noopener me" target="_blank"><i class="fa custom steam fa-fw"></i>steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
<img src="/images/thinklive_cyber.png"; z-index: 0; style="max-width: 100%; width: auto; height: auto;background-color: #fff;">

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://thinklive1.github.io/thinklive/26286/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/thive.png">
      <meta itemprop="name" content="thinklive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="thinklive">
      <meta itemprop="description" content="起初，世界是一团思索，它向所有的方向迈了一步，于是万物由此而生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="考研笔记——操作系统部分 | thinklive">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          考研笔记——操作系统部分
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-03 23:35:54" itemprop="dateCreated datePublished" datetime="2023-12-03T23:35:54+08:00">2023-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-12 17:46:31" itemprop="dateModified" datetime="2023-12-12T17:46:31+08:00">2023-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">考研笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:11</span>
    </span>
</div>

        
        </div>
      </header>
   

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="概论">概论</h1>
<p><code>操作系统</code>：控制管理计算机的硬件，协调控制资源分配，并为应用程序和用户提供接口以供使用</p>
<h2 id="基本特征">基本特征</h2>
<p><code>操作系统</code>的基本特征包括并发，共享，虚拟和异步</p>
<ol type="1">
<li><p>并发<br />
<code>并发</code>是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。这是通过类似时间片轮转的机制实现的。<br />
<code>并行性</code>是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的动作<code>并行性</code>要有相关硬件的支持,如多流水线或多处理机硬件环境</p></li>
<li><p>共享<br />
<code>共享</code>：系统内的某些资源可以供并发的不同进程使用，分为以下几种方式<br />
<span id="more"></span></p>
<ol type="1">
<li>互斥共享 规定在一段时间内只充许一个进程访问该资源，系统分配该资源前，必须确保没有其他进程正在使用它，分配后，在进程访问并释放该资源后，其他进程对资源的申请才会被操作系统允许。<br />
这种一段时间内只能被一个进程占有的资源被称为<code>临界资源</code><br />
大部分硬件，某些软件的栈，变量等都属于<code>临界资源</code><br />
</li>
<li>同时访问 某些系统资源可以在同一时间段内被多个进程同时访问，例如文件系统，这种同时访问可能是交替进行。<br />
互斥共享要求一种资源在一段时间内（哪怕是一段很小的时间）只能满足一个请求，同时访问通常要求一个请求可以分时间片间隔地完成，效果和连续完成相同</li>
</ol></li>
</ol>
<p>并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件：</p>
<ul>
<li>资源共享是以程序的并发为条件的：若系统不充许程序并发执行，则自然不存在资源共享问题<br />
</li>
<li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，其至根本无法并发执行。</li>
</ul>
<ol start="3" type="1">
<li><p>虚拟<br />
<code>虚拟</code>是指把一个物理上的实体变为若干逻辑上的对应物。<br />
虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务<br />
把一个物理cpu虚拟成多个虚拟cpu,称为虚拟处理器<br />
虚拟技术可以在时间或者空间上进行相应的现实虚拟转换</p></li>
<li><p>异步<br />
虽然进程可以并发进行，但推进速度，时间等是不确定的，操作系统必须确保，相同环境下相同操作的进程得到相同的结果，不论时间多久</p></li>
</ol>
<h2 id="功能">功能</h2>
<ol type="1">
<li>管理系统资源
<ol type="1">
<li>处理机（进程）的管理，包括创建，调度，死锁检测和恢复等</li>
<li>存储器管理，即内存的分配和管理</li>
<li>文件管理，即操作系统的文件系统空间，目录，格式等</li>
<li>设备管理，处理用户的I/O请求</li>
</ol></li>
<li>提供用户接口操作硬件和程序</li>
<li>命令接口
<ol type="1">
<li>联机命令接口（交互式命令接口，适用于实时或分时系统）：用户通过终端实时输入命令与操作系统交换，输入一条，操作系统解释并执行一条，然后才可以输入下一条(shell)</li>
<li>脱机命令接口（批处理命令接口,适用于批处理系统）：用作业控制命令写成一本作业说明书，操作系统读取说明书，逐条解释执行(脚本)</li>
</ol></li>
<li>程序接口：有一系列系统调用组成，，用户在程序中使用这些系统调用命令来让操作系统提供相应服务，例如GUI界面(严格的说gui界面只是使用了操作系统提供的图形相关的系统调用)</li>
<li>实现了对计算机资源的扩充</li>
</ol>
<h2 id="历史">历史</h2>
<ol type="1">
<li>手工操作阶段<br />
缺点：1，cpu利用不充分。2，计算机资源利用率低下</li>
<li>批处理阶段
<ol type="1">
<li>单道批处理系统：操作系统一次只执行一个程序，依次处理，特征：
<ol type="1">
<li>自动性，磁带上的作业可以自动依次进行</li>
<li>顺序性，作业有明确顺序依次进入内存</li>
<li>单道性，内存中只有一个程序运行，任务完成或异常后才调入下一个 问题：任务间隔等待下一个调入时，I/O效率低下<br />
</li>
</ol></li>
<li>多道批处理程序，内存中可以有多个程序共享系统资源，交替运行，避免I/O期间的算力浪费，特点是：
<ol type="1">
<li>多道，内存存放多道程序</li>
<li>宏观上并行，内存中的程序都处于运行状态</li>
<li>微观上串行，程序交替使用cpu</li>
</ol></li>
</ol></li>
</ol>
<p>问题：处理器资源，内存资源和I/O的分配，以及如何组织处理大量的程序和数据<br />
在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。</p>
<ul>
<li>优点：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用：系统吞吐量大，CPU和其他资源保持“忙碌”状态。</li>
<li>缺点：用户响应的时间较长：不提供人机交互能力，用户既不能了解自已的程序的运行情况，又不能控制计算机。</li>
</ul>
<ol start="3" type="1">
<li><p>分时操作系统 所谓分时技术，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己已独占一台计算机。<br />
分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰，同时有较快的交互速度<br />
特性：</p>
<ol type="1">
<li>同时性，允许多个用户同时使用一台计算机（多终端）</li>
<li>交互性</li>
<li>独立性，各个用户相对独立，不会互相影响</li>
<li>及时性，对用户请求用较快的速度回应</li>
</ol></li>
<li><p>实时操作系统 一些特殊场合（比如飞行器系统），对操作的时限有硬性要求（或者软性要求），这样的操作系统叫做实时操作系统<br />
其中绝对无法违反时限的是硬实时系统，偶尔可以违反的是软实时系统<br />
特点：</p></li>
</ol>
<ul>
<li>及时性</li>
<li>可靠性</li>
</ul>
<ol start="5" type="1">
<li><p>其他<br />
网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网 络中各种资源的共享及各台计算机之间的通信。<br />
分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息：系统中的每台计算机都具有同等的地位，即没有主机也没有从机：每台计算 机上的资源为所有用户共享：系统中的任意台计算机都可以构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的 操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。</p></li>
<li><p>个人计算机操作系统<br />
个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有Windows、Linux和Macintosh等。</p></li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231204211804.png" /></p>
<h2 id="运行环境">运行环境</h2>
<p>cpu一般执行两种程序，一种是操作系统内核程序，另一种是用户程序，因此对cpu指令需要做区分</p>
<ul>
<li>特权指令，是指不允许用户直接使用的指令，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</li>
<li>非特权指令，是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限子访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。 在具体实现上，将CPU的运行模式划分为用户态（目态）和核心态 （又称管态，内核态）</li>
</ul>
<h3 id="内核机制">内核机制</h3>
<ol type="1">
<li>时钟管理，提供计时功能，是时间片轮转，实时系统的截止时间等功能的基础</li>
<li>中断机制，操作系统的大部分功能都依赖中断，可以说现代操作系统是中断驱动的，中断机制只有一小部分属于内核，负责保护和恢复现场等</li>
<li>原语，操作系统的底层小程序，有以下特点
<ol type="1">
<li>最底层，最接/近硬件</li>
<li>操作有原子性，不可分割</li>
<li>运行时间短调用频繁</li>
</ol></li>
<li>系统控制的数据结构和处理,常见操作有
<ol type="1">
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ol></li>
</ol>
<h3 id="中断和异常">中断和异常</h3>
<p>由于用户态的某些操作需要核心态的一些功能，需要中断和异常机制，来让cpu从用户态进入核心态（这通过硬件实现，比如一个特殊寄存器）<br />
<code>中断</code>（Interruption）也称外中断，是指来自CPU执行指令外部的事件，通常用于信息输入/输出，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成。时钟中断，表示一个固定 的时间片已到，让处理机处理计时、启动定时运行的任务等<br />
<code>异常</code>（Exception）也称内中断，是指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺负及专门的陷入指令等引起的事件。异常不能被屏蔽，一出现，就应立即处理。<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231204215335.png" /> 二者的分类如图，其中故障（Fault）通常是由指令执行引起的异常，如非法操作码，缺页故障、除数为0、运算溢出等。自陷（Trap）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序。终止（Abort）是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。故障异常和自陷异常属于软件中断（程序性异常，终止异常和外部中断属于硬件中断。</p>
<p>中断处理流程：操作系统发现中断请求或者异常后，打断当前程序，调转到中断或者异常的处理程序，如果程序能解决问题，就再次回到现场继续执行，如果是致命错误，则终止程序</p>
<h3 id="系统调用">系统调用</h3>
<p>一般涉及对系统资源的请求，都需要系统调用，系统调用可以视为一种特殊的公共子程序 常见类型：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能</li>
</ul>
<p>用户程序可以执行陷入指令（又称访管指令或trap指令）来发起系统调用，此时相当于cpu使用权被交给内核，来让cpu进入核心态执行特权指令，最后结果和cpu返还给程序 当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序：也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行 <img src="/assets/苏大linux_ppt/Pasted%20image%2020231204220927.png" /></p>
<p>执行系统调用的过程如下：正在运行的进程先传递系统调用参数，然后由陷入（trap）指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核态服务程序，最后返回用户态。</p>
<div class="note warning"><p>注意：</p>
<ul>
<li>由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的,此外，这个转变是硬件完成的，核心态到用户态则是操作系统完成</li>
<li>(访管指令在用户态使用，因此不是特权指令)</li>
<li>输入输出这种涉及到中断机制的指令，必须在核心态执行</li>
<li>命令解释这种与用户交互的程序在用户态执行，而进程调度则需要核心态(单个用户不应能影响进程这样的全局状态，否则就可以只让自己的进程优先执行)</li>
<li>一般来说，中断处理除了保留现场，还需要用一个寄存器存储程序的状态字</li>
<li>外部中断时，通用寄存器由操作系统保存，PC(程序计数器)则由中断指令自动保存</li>
<li>时钟中断后，服务程序应当更新内核中时钟变量的值,当前进程占用CPU的时间,当前进程在时间片内的剩余执行时间等全部时钟相关的数据</li>
<li>操作系统通过提供系统调用避免用户程序直接访问外设</li>
<li>当CPU检测到中断信号后，由硬件自动保存被中断程序的断点（即程序计数器PC），之后，硬件找到该中断信号对应的中断向量，中断向量指明中断服务程序入口地址（各中断向量保存PSW、保存中断屏蔽字、保存各通用寄存器的值，并提供与中断信号对应的中断服务，中断服务程序属于操作系统内核</li>
<li>能在内核态下执行。常见的特权指令有：
<ul>
<li>有关对IO设备操作的指令</li>
<li>有关访问程序状态的指令</li>
<li>存取特殊寄存器的指令</li>
</ul></li>
<li>通道技术和中断技术结合起来就可实现CPU与I/O设备并行工作，即CPU启动通道传输数据后便进行其他程序的计算工作，而通道则进行输入输出操作；通道工作结束后，通过中断让cpu进行处理，处理完再各自进行对应的工作</li>
</ul>
</div>
<h2 id="结构">结构</h2>
<ol type="1">
<li>分层法<br />
最底层为硬件，最高层为用户接口，每个高层只能调用它向下单层的功能和服务<br />
优点：</li>
<li>便于调试和验证，由于每层都相对独立，可以隔绝问题，在单层定位问题</li>
<li>易于扩充维护，只要确保层间接口不便，就可以随意修改单层内的模块</li>
</ol>
<p>问题：1，难于定义各层。2，由于有时需要跨多层调用，额外开销较大，效率较低</p>
<ol start="2" type="1">
<li>模块化 将操作系统定义成各种有自己接口的模块，各模块通过接口进行组合和通信 <img src="/assets/苏大linux_ppt/Pasted%20image%2020231205144922.png" /> 这样的结构需要保证模块之间的独立性，即：</li>
</ol>
<ul>
<li>内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。</li>
<li>耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。 模块化的优点：①提高了操作系统设计的正确性、可理解性和可维护性：②增强了操作系统 的可适应性：③加速了操作系统的开发过程。 模块化的缺点：①模块间的接口规定很难满足对接口的实际需求。②各模块设计者齐头并进 每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。</li>
</ul>
<ol start="3" type="1">
<li><p>宏内核<br />
宏内核，指将系统的主要功能模块作为整体运行在核心态，从而为用户程序提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。<br />
主流操作系统都使用了宏内核，但事实上也在逐渐引进微内核技术，成为一种混合结构</p></li>
<li><p>微内核<br />
微内核构架，是指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。 一般可以分为两个部分：</p></li>
</ol>
<ul>
<li>微内核,实现操作系统最基本核心功能的小型内核
<ul>
<li>与硬件紧密相关的功能</li>
<li>基本功能</li>
<li>客户和服务器的通信</li>
</ul></li>
<li>多个服务器</li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231205151119.png" /> 为了实现高可靠性，只有微内核运行在内核态，其余模块都运行在用户态，一个模块的错误不会影响整个系统 微内核的功能：</p>
<ul>
<li>进程（线程）管理：进程的通信，切换，调度，多处理器的同步等都应该放入微内核，但进程分类，优先级确定等不涉及机制的功能可以放入进程管理服务器</li>
<li>低级存储器管理：比如页表机制和地址变换机制，而虚拟存储器的管理，页面置换算法等则有存储器管理服务器管理</li>
<li>中断和陷入处理，捕获相关事件，进行中断响应处理，然后发送给相关服务器来处理</li>
</ul>
<p>优点：</p>
<ul>
<li>拓展性和灵活性</li>
<li>可靠性和安全性</li>
<li>可移植性（和硬件有关的都在微内核中，其他服务器和硬件无关）</li>
<li>分布式计算，通信采用消息传递机制，很好的支持分布式系统和网络系统</li>
</ul>
<p>微内核结构的主要问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作 系统的执行开销偏大。</p>
<ol start="5" type="1">
<li>外核<br />
不同于虚拟机克隆真实机器，另一种策略是对机器进行分区，给每个用户整个资源的一个子集。在底层中，一种称为外核（exokernel）的程序在内核态中运行。它的任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机有自己的操作系统，但资源是受限制的<br />
外核机制的优点是减少了映射层。在其他的设计中，每个虚拟机都认为它有自己的磁盘，这样虚拟机监控程序就必须维护一张表格以重映像磁盘地址，有外核就不需要维护这个表格了，并且实现了各个虚拟机之间的安全划分，没有冲突</li>
</ol>
<h2 id="引导">引导</h2>
<p>操作系统引导是指计算机利用CPU运行定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统一环扣一一环地完成上述过程。</p>
<ol type="1">
<li>激活CPU。激活的CPU读取ROM中的boot程序，将指令寄存器置为BIOS（基本输入/输出系统）的第一条指令，即开始执行BIOS的指令。</li>
<li>硬件自检。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止：如果没有故障，屏幕会显示CPU、内存、硬盘等信息。</li>
<li>加载带有操作系统的硬盘。硬件自检后，BIOS开始读取BootSequence（通过CMOS里保存的启动顺序，或者通过与用户交互的方式），把控制权交给启动顺序排在第一位的存储设备，然后CPU将该存储设备引导扇区的内容加载到内存中。</li>
<li>加载主引导记录MBR。硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统。</li>
<li>扫描硬盘分区表，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。</li>
<li>加载分区引导记录PBR。读取活动分区的第一个扇区，这个扇区称为分区引导记录（PBR），其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）</li>
<li>加载启动管理器。分区引导记录搜索活动分区中的启动管理器，加载启动管理器</li>
<li>加载操作系统</li>
</ol>
<h2 id="虚拟机">虚拟机</h2>
<p>虚拟机是一台逻辑计算机，是指利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。有两类虚拟化方法。</p>
<ol type="1">
<li>唯一运行在最高特权的程序，它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机、这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。</li>
</ol>
<div class="note info"><p>虚拟机作为用户态的一个进程运行，不充许执行敏感指令。然而，虚拟机上的操作系统认为自已运行在内核态（实际上不是），称为虚拟内核态。虚拟机中的用户进程认为自已运行在用户态（实际上确实是）。当虚拟机操作系统执行了一条CPU处于内核态才充许执行的指令时，会陷入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。</p>
</div>
<ol start="2" type="1">
<li>类似一个依赖宿主机的普通进程，操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）。客户操作系统安装完成后，就能启动并运行。 此时，虚拟机管理程序伪装成一台计算机（比如vmware）</li>
</ol>
<p>有的教材将第一类虚拟化技术称为裸金属架构，将第二类虚拟化技术称为寄居架构</p>
<div class="note warning"><ul>
<li>通常可以从四个方面来描述微内核OS：①内核足够小；②基于客户/服务器模式；③应用“机制与策略分离”原理；④采用面向对象技术。</li>
<li>常驻内存的只是操作系统内核，其他部分仅在需要时才调入。</li>
<li>操作系统的引导程序位于磁盘活动分区的引导扇区中。引导程序分为两种：一种是位于ROM中的自举程序（BIOS的组成部分），用于启动具体的设备；另一种是位于装有操作系统硬盘的活动分区的引导扇区中的引导程序（称为启动管理器），用于引导操作系统</li>
<li>CPU激活后，会从最顶端的地址FFFF0H获得第一条指令来执行，这个地址仅仅只有16字节，放不下一段程序，所以是一条JMP指令，以跳到更低地址去执行BIOS程序。BIOS程序在内存最开始的空间构建中断向量表和相应服务程序,在后续POST过程中要用到中断调用等功能。然后进行通电自检POST （Power-on Self Test）以检测硬件是否有故障。完成POST后，BIOS需要在硬盘、光驱或软驱等存储设备搜寻操作系统内核的位置以启动操作系统</li>
<li>BIOS将控制权交给排在首位的启动设备后，CPU将该设备主引导扇区的内容（主引导记录MBR）加载到内存中，然后由MBR检查分区表，查找活动分区，并将该分区的引导扇区的内容（分区引导记录PBR）加载到内存加以执行</li>
<li>机制是指实现某一功能的具体执行机构。策略则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。在传统的OS中，将机制放在OS内核的较低层中，把策略放在内核的较高层中。而在微内核OS中，通常将机制放在OS的微内核中。正因如此，才可以将内核做得很小</li>
<li>处于用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，访管中断处理程序将按系统调用的操作数和参数转到相应的例行子程序。完成服务功能后，退出中断，返回到用户程序断点继续执行。</li>
</ul>
</div>
<hr />
<h1 id="进程和线程">进程和线程</h1>
<h2 id="进程">进程</h2>
<p>为了更好的控制并发的多个程序，引入了进程(process)的概念<br />
进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。进程一定是一个动态的、过程性的概念<br />
对每个进程必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block, PCB）,PCB是对进程的唯一标志</p>
<p>特征：</p>
<ul>
<li>动态性</li>
<li>并发性，多个进程实体同时存在于内存，在一段时间内并发执行</li>
<li>独立性，进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</li>
<li>异步性，进程推进的速度不可预知，因此需要相应的同步策略</li>
</ul>
<p>状态（前三个是基本状态）：</p>
<ol type="1">
<li>运行态，在处理机上运行</li>
<li>就绪态，进程得到了处理机外的所有资源，就绪的进程一般用就绪队列管理</li>
<li>阻塞态，进程正在等待某个事件或者资源，一般会用多个阻塞队列管理这样的进程</li>
<li>创建态，进程正在创建，还没进入就绪态，比如没有足够分配的资源时创建进程</li>
<li>终止态，结束进程时先设置成终止态，随后进行资源释放等工作</li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231206201905.png" /></p>
<h3 id="组成">组成</h3>
<ol type="1">
<li><p><strong>PCB</strong><br />
PCB是进程实体的一部分，是进程存在的唯一标志 <div class="note info"><p>当操作系统欲调度某进程运行时，要从该进程的PCB中查出其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB；当进程由于某种原因而暂停运行时，又需将其断点的处理机环境保存在PCB中。在进程的整个生命期中，系统通过PCB对进程进行控制的</p>
</div> <img src="/assets/苏大linux_ppt/Pasted%20image%2020231206202831.png" /> PCB的组成如图，其中寄存器值一般用于切换进程时保护现场，以备之后从断点执行，这些信息也被称上下文。<br />
对进程的管理一般通过对PCB进行组织来进行，一般可以分为链表和索引两种组织方式，不同进程状态对应不同索引或队列（链式队列）</p></li>
<li><p><strong>程序段</strong><br />
程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可被多个进程共享，即多个进程可以运行同一个程序。<br />
进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为<strong>原语</strong></p></li>
<li><p><strong>数据段</strong><br />
一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生 的中间或最终结果。</p></li>
</ol>
<h3 id="控制">控制</h3>
<ol type="1">
<li><p><strong>创建</strong><br />
子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，通常也会同时撤销其所有的子进程。<br />
操作系统创建一个新进程的过程如下（创建原语）：</p>
<ol type="1">
<li>为新进程分配一个唯一的进程标识号，并申请一个空白PCB （PCB是有限的）。若PCB申 请失败，则创建失败。</li>
<li>为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等（在PCB中体现）。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。</li>
<li>初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li>
<li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行</li>
</ol></li>
<li><p><strong>终止</strong><br />
引起进程终止的事件主要有：</p>
<ul>
<li>正常结束，表示进程的任务己完成并准备退出运行。</li>
<li>异常结束，表示进程在运行时，发生了某种异常事件，如存储区越界、I/O故障等。</li>
<li>外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止</li>
</ul></li>
<li><p><strong>阻塞和唤醒</strong><br />
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败等，进程便通过调用阻塞原语（Block）,使自己由运行态变为阻塞态。</p></li>
</ol>
<p>阻塞原语的执行过程如下：</p>
<ol type="1">
<li>找到将要被阻塞进程的标识号对应的PCB</li>
<li>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</li>
<li>把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程</li>
</ol>
<p>当被阻塞进程所期待的事件出现时，如它所期待的I/O操作已完成或其所期待的数据已到达，由有关进程调用唤醒原语（Wakeup）,将等待该事件的进程唤醒。</p>
<p>唤醒原语的执行过程如下：</p>
<ol type="1">
<li>在该事件的等待队列中找到相应进程的PCB</li>
<li>将其从等待队列中移出，并置其状态为就绪态。</li>
<li>把该PCB插入就绪队列，等待调度程序调度。</li>
</ol>
<div class="note info"><p>就像c++的new和delete一样，阻塞和唤醒必须成对进行，否则就会出现"睡美人"</p>
</div>
<h3 id="通信">通信</h3>
<p>进程通信是指进程之间的信息交换</p>
<ol type="1">
<li><p><strong>共享存储</strong><br />
在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换,此时需要PV等机制来进行同步。<br />
共享存储又分为两种：</p>
<ul>
<li>低级方式的共享是基于数据结构的共享</li>
<li>高级方式的共享则是基于存储区的共享 <div class="note info"><p>进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的</p>
</div></li>
</ul></li>
<li><p><strong>消息传递</strong><br />
在消息传递系统中，进程间的数据交换以格式化的消息（Message）为单位。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。 这种方式公开透明，简化了程序的设计，因此应用比较广泛<br />
在微内核操作系统中，微内核与服务器之间的通信就采用了消息传递机制。由于该机制能很好地支持多处理机系统、分布式系统和计算机网络，因此也成为这些领域最主要的通信工具。<br />
分为：</p>
<ol type="1">
<li>直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息</li>
<li>间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中。</li>
</ol></li>
<li><p><strong>管道通信</strong> <img src="/assets/苏大linux_ppt/Pasted%20image%2020231206213642.png" /> 管道通信允许两个进程按生产者-消费者方式进行通信,生产者向管道的一端写，消费者从管道的另一端读。<br />
数据在管道中是先进先出的。只要管道非空，进程就能从管道中读出数据，若数据被读空，则读进程阻塞，直到写进程往管道中写入新的数据，再将读进程唤醒。<br />
只要管道不满，写进程就能往管道中写入数据，若管道写满，则写进程阻塞，直到读进程读出数据，再将写进程唤醒。<br />
为了协调双方的通信，管道机制必须提供三方面的协调能力：互斥、同步和确定对方的存在。<br />
<div class="note info"><p>实例：<br />
在linux中，管道是一种文件，准确的说是一个固定大小(4KB)的缓冲区，写满时自动阻塞，直到部分数据被读取，被读空时，则对读操作阻塞，直到有新的内容写入</p>
</div> 管道只能由创建进程所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并使用它来与父进程进行通信</p></li>
</ol>
<h2 id="线程和多线程模型">线程和多线程模型</h2>
<h3 id="概念">概念</h3>
<p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。<br />
线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。<br />
一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。<br />
<div class="note info"><p>线程也有就绪、阻塞和运行三种基本状态<br />
进程是除CPU外的系统资源的分配单元，而线程则作为处理机的分配单元。</p>
</div></p>
<p><strong>和进程的比较</strong>：</p>
<ol type="1">
<li>调度，引入线程后，线程才是独立调度的基本单位，而线程切换的代价远低于进程,同一进程的线程可以随意切换，而避免较大的上下文切换开销</li>
<li>并发，引入线程后，一个进程的线程，以及不同进程的线程都可以并发执行，提高了系统的资源利用率和吞吐量</li>
<li>拥有资源，进程是拥有系统资源的最小单位，线程除了极少必要资源不占有资源，同一进程的线程有相同的地址空间，可以共享该进程资源</li>
<li>独立性，进程之间相互独立，除了共享资源无法互相访问，线程则可以共享资源和地址空间</li>
<li>系统开销，由于避免创建PCB，分配资源，切换上下文，通信等开销,线程开销更小</li>
<li>支持多处理器系统，一个进程的不同线程可以用多个处理器同时运算</li>
</ol>
<h3 id="属性和状态">属性和状态</h3>
<ol type="1">
<li>每个线程都有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</li>
<li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。</li>
<li>同一进程中的各个线程共享该进程所拥有的资源。</li>
<li>线程是处理机的独立调度单位,可以并发执行。在单CPU的计算机系统中，各线程交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU,若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。</li>
<li>一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li>
</ol>
<ul>
<li>执行状态：线程己获得处理机而正在运行。</li>
<li>就绪状态：线程已具备各种执行条件，只需再获得CPU便可立即执行。</li>
<li>阻塞状态：线程在执行中因某事件受阻而处于暂停状态</li>
</ul>
<div class="note info"><p><strong>线程的组织与控制</strong></p>
<ul>
<li>线程控制块通常包括：①线程标识符；②一组寄存器，包括程序计数器、状态寄存器和通用寄存器；③线程运行状态，用于描述线程正处于何种状态；④优先级；⑤线程专有存储区，线程切换时用于保存现场等；⑥堆栈指针，用于过程调用时保存局部变量及返回地址等。<br />
</li>
<li>各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。<br />
</li>
<li>用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后，将返回一个线程标识符</li>
<li>通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行</li>
</ul>
</div>
<p><strong>分类</strong></p>
<ol type="1">
<li><p>用户级线程(ULT)<br />
用户级线程的所有管理都在用户空间进行，和内核无关，通常应用从单线程开始，运行中可以随意创建删除线程<br />
优点：</p>
<ol type="1">
<li>不需要切换到内核空间，减少开销</li>
<li>调度算法可以各个进程专用，便于灵活选择</li>
<li>不会影响到操作系统层，所有线程只是应用程序，比较稳定</li>
</ol></li>
</ol>
<p>缺点：</p>
<pre><code>1. 一个线程发起系统调用时，所有同进程的线程都要阻塞
2. 不能发挥多处理机优势</code></pre>
<ol start="2" type="1">
<li>内核级线程(KLT)</li>
</ol>
<p>线程管理在内核空间进行，由内核分配线程管理块，加以管理</p>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231207185300.png" /> 优点：</p>
<pre><code>1. 发挥多处理机优势，多个线程可以并行  
2. 一个线程被阻塞，同进程的其他线程依然可以被调度  
3. 内核支持的线程会占用更小的空间，并有更小的开销  
4. 内核也可以使用多线程，更加灵活地调度线程  </code></pre>
<p>缺点：</p>
<pre><code>1. 对同一进程的线程切换，由于需要切换到内核态才能切换，会产生较大开销   </code></pre>
<ol start="3" type="1">
<li>组合方式</li>
</ol>
<p>内核和用户空间各自可以创建线程，一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。同一进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞</p>
<div class="note info"><p><strong>线程库</strong>(thread library)是为程序员提供创建和管理线程的API。实现线程库主要的方法有如下两种：</p>
<ul>
<li>在用户空间中提供一个没有内核支持的库。这种库的所有代码和数据结构都位于用户空间中。这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用。<br />
</li>
<li>实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个API函数通常会导致对内核的系统调用。</li>
</ul>
<p>目前使用的三种主要线程库是：POSIX Pthreads、Windows APL Java., Pthreads作为POSIX标准的扩展，可以提供用户级或内核级的库。Windows API是用于Windows系统的内核级线程库。Java线程API允许线程在Java程序中直接创建和管理。由于JVM实例通常运行在宿主操作系统之上，Java线程API通常采用宿主系统的线程库来实现，因此在Windows系统中Java线程通常采用Windows API来实现，在类UNIX系统中采用Pthreads来实现。</p>
</div>
<h3 id="多线程模型">多线程模型</h3>
<ol type="1">
<li>多对一模型。，多个用户线程(一般属于同一进程)映射到一个内核线程,线程管理在用户空间进行，需要内核访问时，挂载到一个内核线程(每次只能一对一映射)<br />
优点：用户空间管理进程效率较高<br />
缺点：无法多处理机运行，挂载内核线程时线程堵塞则整个进程堵塞<br />
</li>
<li>一对一模型,一个用户线程映射一个内核线程<br />
优点：当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。<br />
缺点：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。<br />
</li>
<li>多对多模型。将n个用户线程映射到m个内核级线程上，要求n&gt;=m。克服了多对一模型并发度不高的缺点，也克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。但实现较复杂。</li>
</ol>
<div class="note warning"><ul>
<li>程序这种静态概念难以描述程序的并发执行，因此需要进程这样的动态概念</li>
<li>引入线程后，进程仍然是资源分配的单位。内核级线程是处理器调度和分派的单位</li>
<li>PCB内所含的数据结构内容，主要有四大类：进程标志信息、进程控制信息、进程资源信息、CPU现场信息</li>
<li>唯有进程中某线程的栈指针（包含在线程TCB中）是属于线程的，属于进程的资源可以共享，属于线程的栈指针是独享的，对其他线程透明</li>
<li>父进程可与子进程共享一部分资源，但不能共享虚拟地址空间，在创建子进程时，会为子进程分配资源，如虚拟地址空间等</li>
<li>执行一条命令或运行一个应用程序时，进程和程序之间形成一对一的关系。进程在执行过程中可以加载执行不同的应用程序，从而形成一对多的关系；以不同的参数或数据多次执行同一个应用程序时，形成多对一的关系；并发地执行不同的应用程序时，形成多对多的关系</li>
<li>父进程与子进程同时执行（并发）。主程序调用子程序后，主程序暂停在调用点，子程序开始执行</li>
<li>主要的进程通信方式：共享内存，共享文件，管道，消息传递</li>
</ul>
</div>
<h2 id="处理机调度">处理机调度</h2>
<p><code>处理机调度</code>是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。 <img src="/assets/苏大linux_ppt/Pasted%20image%2020231207212550.png" /></p>
<p><strong>调度的层级</strong></p>
<ol type="1">
<li>高级调度(作业调度)，从外存的后备队列中作业中选取一个调入内存，并分配资源，建立进程。多见于多道批处理系统<br />
</li>
<li>中级调度(内存调度)，把暂时不能运行的进程调到外存等待，进程进入挂起态，等内存有所空余时调入进入就绪态的进程进入内存，修改成就绪态，入队就绪队列<br />
</li>
<li>低级调度(进程调度)，从就绪队列选取一个进程交给处理机，最常见最频繁的调度</li>
</ol>
<p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。</p>
<p><strong>调度的目标</strong></p>
<ol type="1">
<li>CPU利用率(cpu有效工作时间/(有效工作时间+等待时间))</li>
<li>系统吞吐量，单位时间内cpu完成作业的数量</li>
<li>周转时间，作业完成时间-作业提交时间。
<ol type="1">
<li>平均周转时间</li>
<li>带权周转时间(作业周转时间/作业实际运行时间)</li>
<li>平均带权周转时间，带权周转时间的平均值</li>
</ol></li>
<li>等待时间，进程等待时间之和</li>
<li>响应时间，用户提交需求到系统首次响应需要的时间，对交互式系统是一个重要指标</li>
</ol>
<p>以上指标不可能兼顾，必须有所取舍</p>
<h3 id="实现">实现</h3>
<p>用于调度和分派CPU的组件称为调度程序，一般由三部分组成</p>
<ol type="1">
<li>排队器，把系统内部的就绪进程排列从一个或者多个就绪队列</li>
<li>分派器，根据调度程序选择的进程，把指定进程从队列中拉出，分配cpu</li>
<li>上下文切换器，需要进行两个上下文操作
<ol type="1">
<li>保存当前程序的上下文到其PCB,装入分派程序的上下文<br />
</li>
<li>移出分派程序的上下文，将其PCB内的cpu现场信息装入cpu的寄存器</li>
</ol></li>
</ol>
<p>通常采用两组寄存器，其中一组供内核使用，一组供用户使用。这样，上下文切换时，只需改变指针，让其指向当前寄存器组即可<br />
<img src="/assets/苏大linux_ppt/Pasted%20image%2020231208111859.png" /></p>
<div class="note info"><p><strong>不能立刻进行调度的特殊情况</strong>：</p>
<ol type="1">
<li>处理中断时，理论上中断是系统级工作，不应被进程影响</li>
<li>进程在系统内核临界区，由于此时一般进程被加锁，解锁前不应切换进程</li>
<li>其他需要屏蔽中断的原子操作</li>
</ol>
<p><strong>需要进行调度的情况</strong>：</p>
<ol type="1">
<li>发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。属于非剥夺调度。</li>
<li>中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。属于剥夺方式的调度</li>
</ol>
<p>现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p>
<p>有一种特殊的闲逛进程，在没有就绪进程时被处理机运行，一旦有就绪进程就被抢占</p>
</div>
<p>进程调度分为两种：</p>
<ul>
<li>抢占调度(剥夺方式)，一个进程在处理机执行时，允许暂停该进程分配处理机给另一个进程</li>
<li>非抢占调度(非剥夺方式)，在进程运行完成或者进入阻塞态前，不允许其他进程获得它的处理机</li>
</ul>
<p>线程调度：</p>
<ul>
<li>用户级线程，调度和内核无关，交给进程调度</li>
<li>内核级线程，内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。</li>
</ul>
<h3 id="调度算法">调度算法</h3>
<ol type="1">
<li><p><strong>FCFS先来先服务</strong>(非抢占)<br />
进程先进先出地进入队列，算法每次都选取最先进入就绪队列的进程运行，直到完成或阻塞才释放 相对利好长作业和cpu密集作业</p></li>
<li><p><strong>SJF短作业优先</strong>(非抢占) 从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机 SJF调度算法的平均等待时间、平均周转时间最少,但会产生饥饿问题，且没有考虑优先级，依赖的估计也未必准确</p></li>
<li><p><strong>优先级调度</strong></p></li>
</ol>
<p>调度算法按照优先级从就绪队列调入进程给处理机，可分为抢占与非抢占 根据优先级是否改变，也可以分为静态和动态优先级 优先级设置的可能原则：</p>
<ul>
<li>系统进程&gt;用户进程</li>
<li>交互进程&gt;非交互进程</li>
<li>I/O密集大于cpu密集</li>
</ul>
<ol start="4" type="1">
<li>高响应比优先</li>
</ol>
<p>响应比Rp=((等待时间+要求服务时间)/要求服务时间) 等待时间相同时类似SJF，要求服务时间相同时类似FCFS，但解决了饥饿问题</p>
<ol start="5" type="1">
<li>时间片轮转调度</li>
</ol>
<p>主要适用于分时系统，按时间片以此选取进程运行</p>
<ol start="6" type="1">
<li>多级队列调度</li>
</ol>
<p>设置多个就绪队列，每个队列有不同的调度策略</p>
<ol start="7" type="1">
<li>多级反馈队列调度</li>
</ol>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231209141033.png" /></p>
<ul>
<li>设置多个就绪队列，优先级依次递减，优先级越高的队列，时间片越短</li>
<li>对一个新进程来说，首先进入第一个队列末尾，如果在第一个时间片内成功则撤离，否则进入第二个队列末尾，这样依次进行，最后一级队列按时间片轮转调度</li>
<li>只有前面的队列为空，才会轮到下一级的队列，如果有更高优先级的进程来到，可以抢占低优先级或者说低层的进程，被抢占的进程放到该队列末尾</li>
</ul>
<p><code>上下文切换</code>：切换进程时,保存上一个进程的状态，并恢复另一个进程的状态 <strong>上下文切换的过程</strong></p>
<ol type="1">
<li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>跳转到新进程PCB中的程序计数器所指向的位置执行。</li>
<li>恢复处理机上下文</li>
</ol>
<ul>
<li>上下文切换对系统来说意味着消耗大量的CPU时间。有些处理器提供多个寄存器组，这样，上下文切换就只需要简单改变当前寄存器组的指针。</li>
<li>用户态和内核态之间的切换称为模式切换，而不是上下文切换，因为没有改变当前的进程。上下文切换只能发生在内核态，它是多任务操作系统中的一个必需的特性。</li>
<li>一般来说，先有资源的调度，然后才有进程的切换。</li>
</ul>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231209141146.png" /></p>
<h2 id="同步与互斥">同步与互斥</h2>
<p>为了协调进程之间的相互制约关系，引入了进程同步的概念</p>
<ol type="1">
<li><strong>临界资源</strong>，一次仅允许一个进程使用的资源称为临界资源，对其的访问可分为
<ol type="1">
<li>进入区，需要在此检查是否可以进入，在进入后设置标志，阻止其他进程进入</li>
<li>临界区，进程访问临界资源的代码</li>
<li>退出区，将对临界资源的访问标志清除</li>
<li>剩余区，代码剩余的部分</li>
</ol></li>
<li><strong>同步</strong>,进程之间由于次序关系产生的等待，传递信息的制约关系</li>
<li><strong>互斥</strong>，也称间接制约关系，一个进程使用临界资源时，另一个进程必须等待</li>
</ol>
<p>同步机制应该遵守以下准则：</p>
<ol type="1">
<li>空闲让进，临界区空闲时允许进入</li>
<li>忙则等待,有进程在临界区内，其他进程必须等待</li>
<li>有限等待，对所有请求进程，应该保证有限时间内能进入临界区</li>
<li>让权等待，进程不能进入时，应该释放处理器防止忙等待</li>
</ol>
<h3 id="实现互斥的方法">实现互斥的方法</h3>
<p><strong>软件实现</strong>：</p>
<ol type="1">
<li>单标志法</li>
</ol>
<p>设置标志turn,若turn = 0,则允许P0进程进入临界区<br />
两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区,违反了空闲让进原则 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>); <span class="comment">//进入区</span></span><br><span class="line">critical section; <span class="comment">//临界区</span></span><br><span class="line">turn=l; <span class="comment">//退出区</span></span><br><span class="line">remainder section; </span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>); <span class="comment">//进入区</span></span><br><span class="line">critical section; <span class="comment">//临界区</span></span><br><span class="line">turn=O; <span class="comment">//退出区</span></span><br><span class="line">remainder section; <span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>双标志法先检查</li>
</ol>
<p>在每个进程访问临界区资源之前，先查看临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。<br />
设置数组flag,如第i个元素<code>flag[i]</code>为FALSE,表示Pi进程未进 入临界区，如为TRUE,表示Pi进程进入临界区。<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]); </span><br><span class="line">flag[i]=TRUE;  <span class="comment">//进入区</span></span><br><span class="line">critical section; <span class="comment">//临界区</span></span><br><span class="line">flag[i]=FALSE; <span class="comment">//退出区</span></span><br><span class="line">remainder section; <span class="comment">//剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Pj进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[i]); </span><br><span class="line">flag[j]=TRUE;  <span class="comment">//进入区</span></span><br><span class="line">critical section; <span class="comment">//临界区</span></span><br><span class="line">flag[j]=FALSE; <span class="comment">//退出区</span></span><br><span class="line">remainder section; <span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure> 在检查对方的flag后和切换自己的flag前有一段时间，有可能都检查通过</p>
<ol start="3" type="1">
<li>双标志法后检查</li>
</ol>
<p>先将自己的标志设置为TRUE,再检测对方的状态标志，若对方标志为TRUE,则进程等待； 否则进入临界区。 当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，结果导致都无法进入的饥饿问题 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程</span></span><br><span class="line">flag[i]=TRUE; </span><br><span class="line"><span class="keyword">while</span>(flag[j]); </span><br><span class="line">critical section;</span><br><span class="line">flag[i]=FALSE; </span><br><span class="line">remainder section; </span><br><span class="line"><span class="comment">//Pj进程</span></span><br><span class="line">flag[j]=TRUE;</span><br><span class="line"><span class="keyword">while</span>(flag[i]);</span><br><span class="line">critical section;</span><br><span class="line">flag[j]=FALSE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure></p>
<ol start="4" type="1">
<li>Peterson's Algorithm</li>
</ol>
<p>每个进程在先设置自己的标志后再设置turn标志。这时，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程</span></span><br><span class="line">flag [i] =TRUE; turn=j ; </span><br><span class="line"><span class="keyword">while</span>(flag[j]&amp;&amp;turn==j);</span><br><span class="line">critical section;</span><br><span class="line">flag[i]-FALSE;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//Pj进程</span></span><br><span class="line">flag [j] =TRUE; turn=j ; </span><br><span class="line"><span class="keyword">while</span>(flag[i]&amp;&amp;turn==j);</span><br><span class="line">critical section;</span><br><span class="line">flag[j]-FALSE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure> 利用flag解决临界资源的互斥访问，而利用turn解决"饥饿”现象</p>
<p><strong>硬件实现</strong></p>
<ol type="1">
<li>中断屏蔽方法</li>
</ol>
<p>一个进程进入临界区后直接禁止中断的产生，这种方法有损处理机运行效率，且有中断不被再次启用的风险 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关中断；</span><br><span class="line">临界区；</span><br><span class="line">开中断；</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>硬件指令方法</li>
</ol>
<p>block表示资源的两种状态：true表示正被占用，初值为false。进程在进入临界区之前，利用TestAndSet检查标志lock,若无进程在临界区，贝信值为fhlse,可以进入，关闭临界资源，把lock置为true,使任何进程都不能进入临界区；若有进程在临界区，则循环检查，直到进程退出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *lock)</span> </span>&#123;<span class="comment">//原子指令,设置某个标志为真，并读出旧标志</span></span><br><span class="line">	boolean old;</span><br><span class="line">	old=*lock;</span><br><span class="line">	*lock=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(boolean *a, boolean *b) &#123;</span><br><span class="line">	boolean temp;</span><br><span class="line">	temp=*a;</span><br><span class="line">	*a=*b; .</span><br><span class="line">	*b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">while</span> <span class="title">TestAndSet</span><span class="params">(&amp;lock)</span> </span>; *</span><br><span class="line"><span class="comment">//进程的临界区代码段；</span></span><br><span class="line">lock=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//进程的其他代码；</span></span><br></pre></td></tr></table></figure>
<p><strong>硬件实现的优点</strong></p>
<ul>
<li>适用于任意数目的进程，而不管是单处理机还是多处理机；</li>
<li>简单、容易验证其正确性。</li>
<li>可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量</li>
</ul>
<p><strong>硬件实现的缺点</strong></p>
<ul>
<li>进程等待进入临界区时要耗费处理机时间，不能实现让权等待。</li>
<li>从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致"饥饿”现象</li>
</ul>
<h3 id="互斥锁">互斥锁</h3>
<p>解决临界问题的有效机制是<code>互斥锁</code>，进程进入临界区前得到锁，退出时释放锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">acquire</span>()&#123;<span class="comment">//原子</span></span><br><span class="line">	<span class="keyword">while</span>(!available); <span class="comment">//忙等待</span></span><br><span class="line">	available=<span class="literal">false</span>; <span class="comment">//获得锁</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">release</span>()&#123;<span class="comment">//原子</span></span><br><span class="line">	available=<span class="literal">true</span>; <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号量">信号量</h3>
<p>另一种有效机制是信号量,它只能被两个标准的原语wait(S)和signal⑶访问，也可记为“P操作”和"V操作”</p>
<h4 id="分类">分类</h4>
<ol type="1">
<li>整型信号量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;</span><br><span class="line">	<span class="keyword">while</span>(S&lt;=<span class="number">0</span>);</span><br><span class="line">	S-S<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(S)(</span><br><span class="line">	S=S+<span class="number">1</span>;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在整型信号量机制中的wait操作，只要信号量S&lt;=0,就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。</p>
<ol start="2" type="1">
<li>记录型信号量</li>
</ol>
<p>除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L,用于链接所有等待该资源的进程<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">process</span> *L;</span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(semaphore S)</span> </span>&#123; <span class="comment">//相当于申请资源</span></span><br><span class="line">	S.value——;</span><br><span class="line">	<span class="keyword">if</span>(S.value&lt;<span class="number">0</span>) &#123;</span><br><span class="line">	add <span class="keyword">this</span> process to S.L;</span><br><span class="line">	<span class="built_in">block</span>(S.L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span> <span class="params">(semaphore S)</span> </span>&#123; <span class="comment">//相当于释放资源</span></span><br><span class="line">	S.value ++;</span><br><span class="line">	<span class="keyword">if</span> (S. value&lt;<span class="number">3</span>s0) &#123;</span><br><span class="line">	remove a process P from S.L;</span><br><span class="line">	<span class="built_in">wakeup</span>(P);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="基于信号量的同步">基于信号量的同步</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>; <span class="comment">//初始化信号量</span></span><br><span class="line"><span class="built_in">P1</span>() &#123;</span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">	x;</span><br><span class="line">	<span class="built_in">V</span>(S);<span class="comment">//告诉进程P2,语句x巳经完成</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>() &#123;</span><br><span class="line">	<span class="comment">//其他操作</span></span><br><span class="line">	<span class="built_in">P</span>(S);<span class="comment">//检查语句x是否运行完成</span></span><br><span class="line">	y;<span class="comment">//检查无误，运行y语句</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>y想要运行必须得到X释放的信号量，由此实现了同步</p>
<h4 id="信号量实现互斥">信号量实现互斥</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">1</span>; <span class="comment">//初始化信号量</span></span><br><span class="line"><span class="built_in">P1</span>() &#123;</span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">	<span class="built_in">P</span>(S);<span class="comment">//加锁</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">	<span class="built_in">V</span>(S);<span class="comment">//解锁</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>() &#123;</span><br><span class="line">	<span class="comment">//其他操作</span></span><br><span class="line">	<span class="built_in">P</span>(S);<span class="comment">//加锁</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">	<span class="built_in">V</span>(S);<span class="comment">//访问结束，解锁</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有进程在临界区时，任意一个进程要进入临界区，就要执行P操作，把S的值减为0,然后进入临界区；当有进程存在于临界区时，S的值为0,再有进程要进入临界区，执行P操作时将会被阻塞，直至在临界区中的进程退出，这样便实现了临界区的互斥。<br />
互斥问题中，P, V操作要紧夹使用互斥资源的那个行为，中间不能有其他冗余代码。</p>
<h4 id="信号量实现前驱关系">信号量实现前驱关系</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1=a2=b1=b2=c=d=e=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">Sl</span>() &#123; <span class="comment">//初始化信号量</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">	<span class="built_in">V</span>(a1); <span class="built_in">V</span>(a2); <span class="comment">//S1已经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">S2</span>() &#123;</span><br><span class="line">	<span class="built_in">P</span>(a1); <span class="comment">//检查S1是否运行完成</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">	<span class="built_in">V</span>(b1);<span class="built_in">V</span>(b2); <span class="comment">//S2已经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">S3</span>() &#123;</span><br><span class="line">	<span class="built_in">P</span>(a2); <span class="comment">//检查S1是否己经运行完成</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">	<span class="built_in">V</span>(c); <span class="comment">//S3己经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">S4</span>() &#123;</span><br><span class="line">	<span class="built_in">P</span>(b1); <span class="comment">//检查S2是否已经运行完成</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">	<span class="built_in">v</span>(d); <span class="comment">//S4已经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">S5</span>() &#123;</span><br><span class="line">	<span class="built_in">P</span>(b2); <span class="comment">//检查S2是否已经运行完成</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">	<span class="built_in">V</span>(e); <span class="comment">//S5已经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">S6</span>() &#123;</span><br><span class="line">	<span class="built_in">P</span>(c); <span class="comment">//检查S3是否已经运行完成</span></span><br><span class="line">	<span class="built_in">P</span>(d); <span class="comment">//检查S4是否已经运行完成</span></span><br><span class="line">	<span class="built_in">P</span>(e); <span class="comment">//检查S5是否已经运行完成</span></span><br><span class="line">	<span class="comment">//其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管程">管程</h3>
<div class="note info"><p>利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为<code>管程(monitor)</code>。</p>
</div>
<p>管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。 <strong>管程的组成</strong></p>
<ol type="1">
<li>名称</li>
<li>管程内部的共享数据结构说明</li>
<li>对该数据结构操作的一组过程</li>
<li>对管程内部共享数据设置初值的语句</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123; <span class="comment">//1.定义一个名称为“Demo”的管程</span></span><br><span class="line">	<span class="comment">//2.定义共享数据结构，对应系统中的某种共享资源</span></span><br><span class="line">	<span class="comment">//共享数据结构 S;</span></span><br><span class="line">	<span class="comment">//4.对共享数据结构初始化的语句</span></span><br><span class="line">	<span class="built_in">init_code</span>() &#123;</span><br><span class="line">		S=<span class="number">5</span>; <span class="comment">//初始资源数等于5</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.过程1:申请一个资源</span></span><br><span class="line">	<span class="built_in">take_away</span>()&#123;</span><br><span class="line">		对共享数据结构x的一系列处理；</span><br><span class="line">		S --; <span class="comment">//可用资源数-1</span></span><br><span class="line">		<span class="comment">//其他</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.过程2；归还一个资源</span></span><br><span class="line">	<span class="built_in">give_back</span>() &#123;</span><br><span class="line">		<span class="comment">//对共享数据结构x的一系列处理；</span></span><br><span class="line">		S++; <span class="comment">//可用资源数+1</span></span><br><span class="line">		<span class="comment">//其他</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享资源</li>
<li>每次只允许一个进程进入管程，如果多个进程想进入，只能依次进行</li>
</ul>
<p><strong>条件变量</strong><br />
将阻塞原因定义为条件变量condition，在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即wait和signaL<br />
x.wait：当x对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。<br />
x.signal： x对应的条件发生了变化，则调用x.signal,唤醒一个因x条件而阻塞的进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo &#123;</span><br><span class="line">	<span class="comment">//共享数据结构S;</span></span><br><span class="line">	condition x; <span class="comment">//定义一个条件变量x</span></span><br><span class="line">	<span class="built_in">init_code</span>()&#123;<span class="comment">/*其他*/</span> &#125;</span><br><span class="line">	<span class="built_in">take_away</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (S&lt;=<span class="number">0</span>) x.<span class="built_in">wait</span> (); <span class="comment">//资源不够，在条件变量x上阻塞等待</span></span><br><span class="line">		<span class="comment">//资源足够，分配资源，做一系列相应处理：</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">give_back</span>() &#123;</span><br><span class="line">		<span class="comment">//归还资源，做一系列相应处理；</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="comment">/*有进程在等待*/</span>) x.<span class="built_in">signal</span> () ;<span class="comment">//唤醒一个阻塞进程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与信号量不同的是，条件变量不需要记录剩余资源数，这个部分由管程的共享数据结构记录</p>
<h3 id="同步问题实例">同步问题实例</h3>
<h4 id="生产者-消费者">生产者-消费者</h4>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为”的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源；它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//临界区互斥信号量</span></span><br><span class="line">semaphore empty=n;<span class="comment">//空闲缓冲区</span></span><br><span class="line">semaphore full=O;<span class="comment">//缓冲区初始化为空</span></span><br><span class="line"><span class="comment">/*信号量mutex作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量初值为1;信号量full用于记录当前缓冲池中的满缓冲区数，初值为0。信号量empty用于记录当前缓冲池中的空缓冲区数，初值为n*/</span></span><br><span class="line"><span class="built_in">producer</span>() &#123;<span class="comment">//生产者进程</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//produce an item in nextp;生产数据</span></span><br><span class="line">		<span class="built_in">P</span> (empty);<span class="comment">//获取空缓冲区单元</span></span><br><span class="line">		<span class="built_in">P</span> (mutex);<span class="comment">//进入临界区</span></span><br><span class="line">		<span class="comment">//add nextp to buffer;//将数据放入缓冲区</span></span><br><span class="line">		<span class="built_in">V</span> (mutex);<span class="comment">//离开临界区，释放互斥信号量</span></span><br><span class="line">		<span class="built_in">V</span>(full);<span class="comment">//满缓冲区数加1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">consumer</span>() &#123;<span class="comment">//消费者进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">P</span>(full);<span class="comment">//获取满缓冲区单元</span></span><br><span class="line">		<span class="built_in">P</span>(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">		<span class="comment">//remove an item from buffer;从缓冲区中取出数据</span></span><br><span class="line">		<span class="built_in">V</span>(mutex);<span class="comment">//离开临界区，释放互斥信号量</span></span><br><span class="line">		<span class="built_in">V</span>(empty);<span class="comment">//空缓冲区数加1</span></span><br><span class="line">		consume the item;<span class="comment">//消费数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须确保先获取一个缓冲区单元再进入临界区，否则缓冲区满时，由于临界区已经锁住，只能无限等待对方释放空/满缓冲区，陷入死锁</p>
<p><strong>更复杂的变种</strong>：</p>
<p><img src="/assets/苏大linux_ppt/Pasted%20image%2020231212105100.png" /> 桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出<br />
两个生产者和两个消费者被连接到大小为1的缓冲区上。爸爸妈妈互斥，爸爸女儿，妈妈儿子是同步关系 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate=l, apple=<span class="number">0</span>, orange=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*首先将信号量plate设置互斥信号量，表示是否允许向盘子放入水果，.初值为1表示允许放入，且只允许放入一个。信号量apple表示盘子中是否有苹果，初值为0表示盘子为空，不许取，apple=1表示可以取。信号量orange表示盘子中是否有橘子，初值为0表示盘子为空，不许取，orange = 1表示可以取。*/</span></span><br><span class="line"><span class="built_in">dad</span> () &#123; <span class="comment">//父亲进程</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//prepare an apple;</span></span><br><span class="line">		<span class="built_in">P</span>(plate); <span class="comment">//互斥向盘中取、放水果</span></span><br><span class="line">		<span class="comment">//put the apple on the plate; //向盘中放苹果</span></span><br><span class="line">		<span class="built_in">V</span>(apple); <span class="comment">//允许取苹果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mom</span>() &#123; <span class="comment">//母亲进程</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//prepare an orange;</span></span><br><span class="line">		<span class="built_in">P</span>(plate); <span class="comment">//互斥向盘中取、放水果</span></span><br><span class="line">		<span class="comment">//put the orange on the plate; //向盘中放橘子</span></span><br><span class="line">		<span class="built_in">V</span>(orange); <span class="comment">//允许取橘子</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>() &#123; <span class="comment">//儿子进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">P</span>(orange); <span class="comment">//互斥向盘中取橘子</span></span><br><span class="line">		<span class="comment">//take an orange from the plate;</span></span><br><span class="line">		<span class="built_in">V</span>(plate); <span class="comment">//允许向盘中取、放水果</span></span><br><span class="line">		<span class="comment">//eat the orange;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">daughter</span>() &#123;<span class="comment">//女儿进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">P</span>(apple); <span class="comment">//互斥向盘中取苹果</span></span><br><span class="line">		<span class="comment">//take an apple from the plate;</span></span><br><span class="line">		<span class="built_in">V</span>(plate); 〃允许向盘中取、放水果</span><br><span class="line">		<span class="comment">//eat the orange;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="读者-写者问题">读者-写者问题</h4>
<p>有读者和写者两组并发进程，共享一个文件，读进程并行执行没有问题，写进程和其他进程同时访问共享数据时 则可能导致数据不一致的错误。<br />
<strong>要求</strong>：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作</li>
<li>只允许一个写者往文件中写信息</li>
<li>任意一个写者在完成写操作之前不允许其他读者或写者工作</li>
<li>写者执行写操作前，应让己有的读者和写者全部退出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//用于记录当前的读者数量</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//用于保护更新count变量时的互斥 </span></span><br><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//用于保证读者和写者互斥地访问文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">P</span>(rw); <span class="comment">//互斥访问共享文件</span></span><br><span class="line">    writing;</span><br><span class="line">    <span class="built_in">V</span>(rw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;<span class="comment">//读者进程 </span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">P</span>(mutex);<span class="comment">//互斥访问count变量</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="comment">//互斥访问count变量</span></span><br><span class="line">      <span class="built_in">P</span>(rw);<span class="comment">//阻止写进程写  </span></span><br><span class="line">	count++; <span class="comment">//读者计数器加1</span></span><br><span class="line">	<span class="built_in">V</span>(mutex); <span class="comment">//释放互斥变量count</span></span><br><span class="line">	reading; <span class="comment">//读取</span></span><br><span class="line">	<span class="built_in">P</span>(mutex); <span class="comment">//互斥访问count变量</span></span><br><span class="line">	count--; <span class="comment">//读者计数器减1  </span></span><br><span class="line">	<span class="keyword">if</span>(count==<span class="number">0</span>)&#123;<span class="comment">//当最后一个读进程读完共享文件</span></span><br><span class="line">		<span class="built_in">V</span>(rw); <span class="comment">//允许写进程写释放互斥变量count</span></span><br><span class="line">		<span class="built_in">V</span>(mutex);<span class="comment">//释放互斥变量count</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是一种读进程优先的情形，只要读进程存在，就会一直阻塞写进程 若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到己在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。增加一个信号量并在上面程序的writer。和reader。函数中各增加一对PV操作，就可以得到写进程优先的解决程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//用于记录当前的读者数量</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;  <span class="comment">//用于保护更新count变量时的互斥</span></span><br><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//用于保证读者和写者互斥地访问文件 </span></span><br><span class="line">semaphore w=<span class="number">1</span>;<span class="comment">//用于实现“写优先”</span></span><br><span class="line"><span class="built_in">writer</span>() &#123;<span class="comment">//写者进程</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="built_in">P</span>(w);<span class="comment">//在无写进程请求时进入</span></span><br><span class="line">   <span class="built_in">P</span>(rw); <span class="comment">//互斥访问共享文件</span></span><br><span class="line">   writing; </span><br><span class="line">   <span class="built_in">V</span>(rw); <span class="comment">//释放共享文件</span></span><br><span class="line">   <span class="built_in">V</span>(w); <span class="comment">//恢复对共享文件的访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;<span class="comment">//读者进程</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="built_in">P</span>(w); <span class="comment">//在无写进程请求时进入</span></span><br><span class="line">	<span class="built_in">P</span>(mutex); <span class="comment">//互斥访问count变量</span></span><br><span class="line">	<span class="keyword">if</span> (count==<span class="number">0</span>)<span class="comment">//当第一个读进程读共享文件时</span></span><br><span class="line">		<span class="built_in">P</span>(rw); <span class="comment">//阻止写进程写</span></span><br><span class="line">	count++;<span class="comment">//读者计数器加1  </span></span><br><span class="line">	<span class="built_in">V</span>(mutex); <span class="comment">//释放互斥变量count</span></span><br><span class="line">	<span class="built_in">V</span>(w); <span class="comment">//恢复对共享文件的访问</span></span><br><span class="line">	reading;<span class="comment">//读取</span></span><br><span class="line">	<span class="built_in">P</span>(mutex);<span class="comment">//互斥访问count变量</span></span><br><span class="line">	count--;<span class="comment">//读者计数器减1</span></span><br><span class="line">	<span class="keyword">if</span> (count==<span class="number">0</span>)<span class="comment">//当最后一个读进程读完共享文件</span></span><br><span class="line">		<span class="built_in">V</span>(rw);<span class="comment">//允许写进程写</span></span><br><span class="line">	<span class="built_in">V</span>(mutex);<span class="comment">//释放互斥变量count</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哲学家进餐问题">哲学家进餐问题</h4>
<p>当哲学家饥饿时，尝试拿起左、右两根筷子(一根一根地拿起)。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，进餐完毕后，释放筷子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] =&#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//定义信号量数组 chopstick[5],并初始化</span></span><br><span class="line"><span class="comment">/*定义互斥信号量数组chopstick[5]=(1, 1, 1, 1, 1),用于对5个筷子的互斥访问。哲学家按顺序编号为0〜4,哲学家i左边筷子的编号为i，哲学家右边筷子的编号为(i + 1)%5*/</span></span><br><span class="line"><span class="built_in">Pi</span>() &#123;<span class="comment">//i号哲学家的进程</span></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">P</span>(chopstick[i]); <span class="comment">//取左边筷子</span></span><br><span class="line">		<span class="built_in">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]); <span class="comment">//取右边筷子</span></span><br><span class="line">		<span class="built_in">eat</span>(); <span class="comment">//进餐</span></span><br><span class="line">		<span class="built_in">V</span> (chopstick[i]); <span class="comment">//放回左边筷子</span></span><br><span class="line">		<span class="built_in">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//放回右边筷子</span></span><br><span class="line">		<span class="built_in">think</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法存在以下问题：当5名哲学家都想要进餐并分别拿起左边的筷子时(都恰好执行完wait(chopstick[i]);)筷子已被拿光，等到他们再想拿右边的筷子时(执行wait(chopstick[(i + 1)%5]);)就全被阻塞，因此出现了死锁。 为防止死锁发生，可对哲学家进程施加一些限制条件，</p>
<ul>
<li>至多允许4名哲学家同时进餐；</li>
<li>仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子；</li>
<li>对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边的筷子，而偶数号哲学家刚好相反。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">semaphore <span class="title">chopstick</span><span class="params">(<span class="number">5</span>] = (lz1,<span class="number">1</span>,<span class="number">1</span>&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">semaphore mutex=l;</span></span></span><br><span class="line"><span class="params"><span class="function">Pi() &#123;<span class="comment">//当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">do</span>&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	P(mutex);<span class="comment">//在取筷子前获得互斥量</span></span></span></span><br><span class="line"><span class="params"><span class="function">	P(chopstick[i]);</span></span></span><br><span class="line"><span class="params"><span class="function">	P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span></span></span><br><span class="line"><span class="params"><span class="function">	V(mutex);<span class="comment">//释放取筷子的信号量</span></span></span></span><br><span class="line"><span class="params"><span class="function">	eat;</span></span></span><br><span class="line"><span class="params"><span class="function">	V(chopstick[i]); <span class="comment">//放回左边筷子</span></span></span></span><br><span class="line"><span class="params"><span class="function">	V(chopstick[ (i+<span class="number">1</span>) %<span class="number">5</span>] ) ; <span class="comment">//放回右边筷子</span></span></span></span><br><span class="line"><span class="params"><span class="function">	think; <span class="comment">//思考</span></span></span></span><br><span class="line"><span class="params"><span class="function">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="吸烟问题">吸烟问题</h4>
<p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉己完成，此时供应者就会将另外两种材料放到桌上，如此重复(让三个抽烟者轮流地抽烟)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">semaphore offer1=<span class="number">0</span>; </span><br><span class="line">semaphore offer2=<span class="number">0</span>;</span><br><span class="line">semaphore offer3=<span class="number">0</span>;</span><br><span class="line">semaphore finish=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号量offerl, offer2, offer3分别表示烟草和纸组合的资源、烟草和胶水组合的资源、纸和胶水组合的资源。信号量finish用于互斥进行抽烟动作。*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    num++;</span><br><span class="line">    num=num%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>) </span><br><span class="line">      <span class="built_in">V</span>(offer1);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">1</span>)  </span><br><span class="line">      <span class="built_in">V</span>(offer2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">V</span>(offer3);</span><br><span class="line">    <span class="comment">//任意两种材料放在桌子上</span></span><br><span class="line">    <span class="built_in">P</span>(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">P</span>(offer3);  </span><br><span class="line">    <span class="comment">//拿纸和胶水,卷成烟,抽掉</span></span><br><span class="line">    <span class="built_in">V</span>(finish); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">P</span>(offer2);</span><br><span class="line">    <span class="comment">//拿烟草和胶水,卷成烟,抽掉</span></span><br><span class="line">    <span class="built_in">V</span>(finish);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">P</span>(offer1);</span><br><span class="line">    <span class="comment">//拿烟草和纸,卷成烟,抽掉</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>为了协调进程之间的相互制约关系，引入了进程同步的概念。 同步是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。 互斥是指当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
<div class="note info">
</div>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/thinklive/24155/" rel="prev" title="考研笔记——数据结构部分">
                  <i class="fa fa-angle-left"></i> 考研笔记——数据结构部分
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/thinklive/27168/" rel="next" title="对加州房地产数据集的数据分析">
                  对加州房地产数据集的数据分析 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">thinklive</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">209k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">12:42</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 技术支持
  </div><script defer src="/lib/three.js"></script><script defer src="/lib/lines.js"></script><script defer src="/lib/waves.js"></script><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/wavedrom.min.js","integrity":"sha256-IRMDzTC+wK5stMucZ/XSXkeS5VNtxZ+/Bm8Mcqfoxdo="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.3.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  <script src="/js/third-party/addtoany.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://thinklive1.github.io/thinklive/26286/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"thinklive1/blog_comments","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

   <!--js: 线条特效-->
  <script type="text/javascript" color="255,255,255" opacity='1' zIndex="-1" count="300" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
