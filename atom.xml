<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thinklive</title>
  
  <subtitle>dirichlet labrary</subtitle>
  <link href="https://thinklive1.github.io/atom.xml" rel="self"/>
  
  <link href="https://thinklive1.github.io/"/>
  <updated>2023-11-27T12:50:13.887Z</updated>
  <id>https://thinklive1.github.io/</id>
  
  <author>
    <name>thinklive</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于mit6.006的作业解析</title>
    <link href="https://thinklive1.github.io/2023/11/20/mit6.006%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/"/>
    <id>https://thinklive1.github.io/2023/11/20/mit6.006%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/</id>
    <published>2023-11-20T13:48:48.565Z</published>
    <updated>2023-11-27T12:50:13.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hw1">hw1</h1><h2 id="时间复杂度分析">时间复杂度分析</h2><p>对这种形式的函数可以这样比较</p><p><span class="math display">\[f_1=n^{\sqrt{n}}=(2^{lgn})^{\sqrt{n}}\]</span> <span class="math display">\[f_2=n^{10}.2^{n/2}=2^{lg(10n)+n/2}\]</span></p><h2 id="复杂度计算">复杂度计算</h2><p>对于T(n,n): T (x, y) = Θ(x + y) + T (x/2, y/2). 化成</p><p><img src="assets/mit6.006作业解析/image-20231120213425020.png" /></p><p>得到θ(n) <span id="more"></span></p><p>T (x, y) = Θ(x) + T (x, y/2). 等于lgy个θ(x) 即，θ(nlgn)</p><p>T (x, y) = Θ(x) + S(x, y/2), S(x, y) = Θ(y) + T (x/2, y).</p><p>化成T (x, y) = Θ(x) + Θ(y/2) + T (x/2, y/2). 与第一个例子相似，θ(n)</p><h2 id="寻峰算法">寻峰算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm1</span>(<span class="params">problem, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># the recursive subproblem will involve half the number of columns</span></span><br><span class="line">    mid = problem.numCol // <span class="number">2</span></span><br><span class="line">    <span class="comment"># information about the two subproblems</span></span><br><span class="line">    (subStartR, subNumR) = (<span class="number">0</span>, problem.numRow)</span><br><span class="line">    (subStartC1, subNumC1) = (<span class="number">0</span>, mid)</span><br><span class="line">    (subStartC2, subNumC2) = (mid + <span class="number">1</span>, problem.numCol - (mid + <span class="number">1</span>))</span><br><span class="line">    subproblems = []</span><br><span class="line">    subproblems.append((subStartR, subStartC1, subNumR, subNumC1))</span><br><span class="line">    subproblems.append((subStartR, subStartC2, subNumR, subNumC2))</span><br><span class="line">    <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">    divider = crossProduct(<span class="built_in">range</span>(problem.numRow), [mid])</span><br><span class="line">    <span class="comment"># find the maximum in the dividing column</span></span><br><span class="line">    bestLoc = problem.getMaximum(divider, trace)</span><br><span class="line">    <span class="comment"># see if the maximum value we found on the dividing line has a better</span></span><br><span class="line">    <span class="comment"># neighbor (which cannot be on the dividing line, because we know that</span></span><br><span class="line">    <span class="comment"># this location is the best on the dividing line)</span></span><br><span class="line">    neighbor = problem.getBetterNeighbor(bestLoc, trace)</span><br><span class="line">    <span class="comment"># this is a peak, so return it</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == bestLoc:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(bestLoc)</span><br><span class="line">        <span class="keyword">return</span> bestLoc</span><br><span class="line">    <span class="comment"># otherwise, figure out which subproblem contains the neighbor, and</span></span><br><span class="line">    <span class="comment"># recurse in that half</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, neighbor)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm1(sub, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm2</span>(<span class="params">problem, location = (<span class="params"><span class="number">0</span>, <span class="number">0</span></span>), trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    nextLocation = problem.getBetterNeighbor(location, trace)</span><br><span class="line">    <span class="keyword">if</span> nextLocation == location:</span><br><span class="line">        <span class="comment"># there is no better neighbor, so return this peak</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(location)</span><br><span class="line">        <span class="keyword">return</span> location</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># there is a better neighbor, so move to the neighbor and recurse</span></span><br><span class="line">        <span class="keyword">return</span> algorithm2(problem, nextLocation, trace)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm3</span>(<span class="params">problem, bestSeen = <span class="literal">None</span>, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    midRow = problem.numRow // <span class="number">2</span></span><br><span class="line">    midCol = problem.numCol // <span class="number">2</span></span><br><span class="line">    <span class="comment"># first, get the list of all subproblems</span></span><br><span class="line">    subproblems = []</span><br><span class="line">    (subStartR1, subNumR1) = (<span class="number">0</span>, midRow)</span><br><span class="line">    (subStartR2, subNumR2) = (midRow + <span class="number">1</span>, problem.numRow - (midRow + <span class="number">1</span>))</span><br><span class="line">    (subStartC1, subNumC1) = (<span class="number">0</span>, midCol)</span><br><span class="line">    (subStartC2, subNumC2) = (midCol + <span class="number">1</span>, problem.numCol - (midCol + <span class="number">1</span>))</span><br><span class="line">    subproblems.append((subStartR1, subStartC1, subNumR1, subNumC1))</span><br><span class="line">    subproblems.append((subStartR1, subStartC2, subNumR1, subNumC2))</span><br><span class="line">    subproblems.append((subStartR2, subStartC1, subNumR2, subNumC1))</span><br><span class="line">    subproblems.append((subStartR2, subStartC2, subNumR2, subNumC2))</span><br><span class="line">    <span class="comment"># find the best location on the cross (the middle row combined with the</span></span><br><span class="line">    <span class="comment"># middle column)</span></span><br><span class="line">    cross = []</span><br><span class="line">    cross.extend(crossProduct([midRow], <span class="built_in">range</span>(problem.numCol)))</span><br><span class="line">    cross.extend(crossProduct(<span class="built_in">range</span>(problem.numRow), [midCol]))</span><br><span class="line">    crossLoc = problem.getMaximum(cross, trace)</span><br><span class="line">    neighbor = problem.getBetterNeighbor(crossLoc, trace)</span><br><span class="line">    <span class="comment"># update the best we&#x27;ve seen so far based on this new maximum</span></span><br><span class="line">    <span class="keyword">if</span> bestSeen <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> problem.get(neighbor) &gt; problem.get(bestSeen):</span><br><span class="line">        bestSeen = neighbor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setBestSeen(bestSeen)</span><br><span class="line">    <span class="comment"># return if we can&#x27;t see any better neighbors</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == crossLoc:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(crossLoc)</span><br><span class="line">        <span class="keyword">return</span> crossLoc</span><br><span class="line">    <span class="comment"># figure out which subproblem contains the largest number we&#x27;ve seen so</span></span><br><span class="line">    <span class="comment"># far, and recurse</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, bestSeen)</span><br><span class="line">    newBest = sub.getLocationInSelf(problem, bestSeen)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm3(sub, newBest, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm4</span>(<span class="params">problem, bestSeen = <span class="literal">None</span>, rowSplit = <span class="literal">True</span>, trace = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># if it&#x27;s empty, we&#x27;re done</span></span><br><span class="line">    <span class="keyword">if</span> problem.numRow &lt;= <span class="number">0</span> <span class="keyword">or</span> problem.numCol &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    subproblems = []</span><br><span class="line">    divider = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> rowSplit:</span><br><span class="line">        <span class="comment"># the recursive subproblem will involve half the number of rows</span></span><br><span class="line">        mid = problem.numRow // <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># information about the two subproblems</span></span><br><span class="line">        (subStartR1, subNumR1) = (<span class="number">0</span>, mid)</span><br><span class="line">        (subStartR2, subNumR2) = (mid + <span class="number">1</span>, problem.numRow - (mid + <span class="number">1</span>))</span><br><span class="line">        (subStartC, subNumC) = (<span class="number">0</span>, problem.numCol)</span><br><span class="line">  </span><br><span class="line">        subproblems.append((subStartR1, subStartC, subNumR1, subNumC))</span><br><span class="line">        subproblems.append((subStartR2, subStartC, subNumR2, subNumC))</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">        divider = crossProduct([mid], <span class="built_in">range</span>(problem.numCol))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># the recursive subproblem will involve half the number of columns</span></span><br><span class="line">        mid = problem.numCol // <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># information about the two subproblems</span></span><br><span class="line">        (subStartR, subNumR) = (<span class="number">0</span>, problem.numRow)</span><br><span class="line">        (subStartC1, subNumC1) = (<span class="number">0</span>, mid)</span><br><span class="line">        (subStartC2, subNumC2) = (mid + <span class="number">1</span>, problem.numCol - (mid + <span class="number">1</span>))</span><br><span class="line">  </span><br><span class="line">        subproblems.append((subStartR, subStartC1, subNumR, subNumC1))</span><br><span class="line">        subproblems.append((subStartR, subStartC2, subNumR, subNumC2))</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># get a list of all locations in the dividing column</span></span><br><span class="line">        divider = crossProduct(<span class="built_in">range</span>(problem.numRow), [mid])</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># find the maximum in the dividing row or column</span></span><br><span class="line">    bestLoc = problem.getMaximum(divider, trace)</span><br><span class="line">    neighbor = problem.getBetterNeighbor(bestLoc, trace)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># update the best we&#x27;ve seen so far based on this new maximum</span></span><br><span class="line">    <span class="keyword">if</span> bestSeen <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> problem.get(neighbor) &gt; problem.get(bestSeen):</span><br><span class="line">        bestSeen = neighbor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setBestSeen(bestSeen)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># return when we know we&#x27;ve found a peak</span></span><br><span class="line">    <span class="keyword">if</span> neighbor == bestLoc <span class="keyword">and</span> problem.get(bestLoc) &gt;= problem.get(bestSeen):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.foundPeak(bestLoc)</span><br><span class="line">        <span class="keyword">return</span> bestLoc</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># figure out which subproblem contains the largest number we&#x27;ve seen so</span></span><br><span class="line">    <span class="comment"># far, and recurse, alternating between splitting on rows and splitting</span></span><br><span class="line">    <span class="comment"># on columns</span></span><br><span class="line">    sub = problem.getSubproblemContaining(subproblems, bestSeen)</span><br><span class="line">    newBest = sub.getLocationInSelf(problem, bestSeen)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trace <span class="keyword">is</span> <span class="literal">None</span>: trace.setProblemDimensions(sub)</span><br><span class="line">    result = algorithm4(sub, newBest, <span class="keyword">not</span> rowSplit, trace)</span><br><span class="line">    <span class="keyword">return</span> problem.getLocationInSelf(sub, result)</span><br></pre></td></tr></table></figure><p>算法一二如课程笔记所述，均是正确的，以下是证明</p><ul><li>algo1</li></ul><ol type="1"><li>证明算法不可能返回一个空值，首先算法不可能得到一个负索引的子数组（在只有一列的时候必然会得到结果而不是继续划分），在最小问题的情况下，如果此时子问题有一列，那么必然返回一个峰值，如果有两列，不管目前讨论的列是不是最大值，都会递归成最小为1为列的子问题，不会返回空值</li><li>证明返回的位置确实是峰值位置，如果算法1返回一个位置（r1，c1），则该位置必须具有列c1中的最大值，并且必须是某个递归子问题中的峰值。为了推导矛盾，假设（r1，c1）不是原始问题中的峰值。在某个子问题中，位置（r1，c1）与列c2相邻（|c1 - c2| = 1），并且值必须满足不等式val（r1，c1）&lt; val（r1，c2）。<br />让（r2，c2）是算法1在c2列中找到的最大值的位置。因此，必定有val（r1，c2）≤ val（r2，c2）。因为c2是分割线，且算法选择在包含（r1，c1）的一半上进行递归，所以我们知道val（r2，c2）&lt; val（r2，c1）。因此，我们有以下不等式链：<br />val（r1，c1）&lt; val（r1，c2）≤ val（r2，c2）&lt; val（r2，c1）<br />但是，为了使算法1将（r1，c1）作为峰值返回，（r1，c1）处的值必须是其列中的最大值，即val（r1，c1）≥ val（r2，c1）。因此，我们得到了一个矛盾。</li></ol><ul><li>algo3是错误的</li></ul><p>时间复杂度是θ(n)，情况类似复杂度题目的第一个情况，1+1/2+1/4……</p><p><strong>反例</strong></p><p>如图所示的反例会选择返回一个在当前子问题中看起来像一个峰值，但是与子问题外部的某个更大值相邻的位置</p><table><thead><tr class="header"><th>0</th><th>0</th><th>9</th><th>8</th><th>0</th><th>0</th><th>0</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="odd"><td>0</td><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="odd"><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr class="odd"><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>对算法四的证明</p><ul><li>algo4</li></ul><p>时间复杂度是θ(n),类似算法3</p><p>算法四交叉进行行和列的最大值寻找</p><ol type="1"><li>如果峰值问题不为空，则算法将始终返回一个位置。在算法中，根据是在行还是列上分割，递归子问题的维度会相应地减少。所以算法要么在某个时刻停止并返回一个位置，要么最终检查一个行数或列数为非正的子问题。但是，问题的行数或列数变为严格负数的唯一方式是在某个时刻m=0或n=0。因此，如果算法没有返回位置，它必定最终检查一个空的子问题。然而，证明假设该情况不会发生。</li><li>如果算法返回一个位置，则该位置将是原始问题中的一个峰值。如果算法返回一个位置(r1, c1)，那么该位置必定是某个递归子问题中的峰值。另外，如果(r2, c2)是算法执行过程中的最佳位置（存储在bestSeen变量中的位置），那么必定满足val(r1, c1) ≥ val(r2, c2)。证明假设(r1, c1)不是原始问题的峰值。那么当位置(r1, c1)通过递归调用链向上传递时，它必定在某个级别停止是不是峰值。因此，必定存在一个包含位置(r1, c1)的子问题，在该级别中，该子问题的某个邻居(r3, c3)的值满足val(r1, c1) &lt; val(r3, c3)。对于(r3, c3)既是递归子问题的邻居又不包含在子问题中，它必定在算法的执行过程中被检查过。因此，必定满足val(r3, c3) ≤ val(r2, c2)。因此，我们得到以下不等式链：val(r1, c1) &lt; val(r3, c3) ≤ val(r2, c2) ≤ val(r1, c1)。这导致了矛盾。</li></ol><h1 id="hw2">hw2</h1><h2 id="科赫雪花">科赫雪花</h2><figure><embed src="/game/fractal.html" /><figcaption>简单的演示</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SNOWFLAKE(n)</span><br><span class="line"> e1, e2, e3 = edges of an equilateral triangle with side length 1</span><br><span class="line"> SNOWFLAKE-EDGE(e1, n)</span><br><span class="line"> SNOWFLAKE-EDGE(e2, n)</span><br><span class="line"> SNOWFLAKE-EDGE(e3, n)</span><br><span class="line">SNOWFLAKE-EDGE(edge, n)</span><br><span class="line"> if n = = 0</span><br><span class="line">  edge is an edge on the snowflake</span><br><span class="line"> else</span><br><span class="line">  e1, e2, e3 = split edge in 3 equal parts</span><br><span class="line"> SNOWFLAKE-EDGE(e1, n − 1)</span><br><span class="line"> f2, g2 = edges of an equilateral triangle whose 3rd edge is e2, pointing outside the snowflake</span><br><span class="line"> ∆(f2, g2, e2) is a triangle on the snowflake’s surface</span><br><span class="line"> SNOWFLAKE-EDGE(f2, n − 1)</span><br><span class="line"> SNOWFLAKE-EDGE(g2, n − 1)</span><br><span class="line"> SNOWFLAKE-EDGE(e3, n − 1)</span><br></pre></td></tr></table></figure><p>从主函数（层数视为-1)开始对每条边进行处理，这一层有三个节点。 而对边处理的函数则遵从这样的流程</p><ol type="1"><li>把边等分成三个部分e1,e2,e3</li><li>对e1进行递归</li><li>以e2为一条边向外侧生成一个等边三角形，f2,g2是这个三角形的另外两条边</li><li>以此对f2,g2,e3进行递归 函数实际上把一条边拓展出了一个三角形 因此第i层的节点数是:<span class="math display">\[3*4^i\]</span> <img src="assets/mit6.006作业解析/image-20231122203735331.png" /></li></ol><h3 id="d-硬件加速渲染">3D 硬件加速渲染</h3><p>在这种渲染方式中，cpu计算分解出的三角形顶点的集合，发给gpu进行绘制，因此cpu的执行时间只取决于分解出的三角形数量，也就是θ(4^n)</p><h3 id="d-硬件加速渲染-1">2D 硬件加速渲染</h3><p>在这种渲染方式中，cpu实际上只计算不断分割出的线段集合，在本题中就是计算最外侧的轮廓的顶点的集合，计算结束后发给gpu绘制 时间复杂度依旧是θ(4^n)，但需要注意的是由于计算完了才开始渲染，因此递归树的中间节点不会对渲染产生时间消耗</p><h3 id="软件渲染">软件渲染</h3><p>在没有硬件加速器的2D渲染（也称为软件渲染）中，CPU 像上一部分一样，为每个路径编译一个线段列表，但它也负责 用于“光栅化”每个线段。 光栅化获取线段端点的坐标 并计算位于线段上的所有像素的坐标。 用这些像素在显示器上绘制线段。光栅化算法在时间上的消耗与线段的长度成正比，线段上的像素数量与线段的长度成正比。 在整个问题中，假设所有线段的长度至少为一个像素，因此 光栅化的成本大于编译线段的成本。 需要注意的是：</p><ol type="1"><li>中间节点依旧对渲染无影响</li><li>由于每次对边处理实际上增加了该边1/3的像素点，所以最后一层产生的代价是<span class="math display">\[θ({(1/3)}^n)\]</span></li><li>同理，总渲染代价和cpu处理（只处理像素点）的时间复杂度都是<span class="math display">\[θ({(4/3)}^n)\]</span></li></ol><h3 id="没有硬件加速的-3d-渲染">没有硬件加速的 3D 渲染</h3><p>在这种情况下， CPU 编译三角形列表，然后光栅化每个三角形。 我们知道一种算法 栅格化一个三角形，其运行时间与三角形的表面积成正比。三角形内的像素数量与三角形的面积成正比。可以假设边长为 l 的三角形的面积为 θ(l^2)。 顺着递归树进行分析，首层只增加了三个节点，每个新节点对应一个边长是原边长1/3的新三角形，增加了1/3的面积，之后的每一层都有4^i个节点，对应4/9的面积增长，即每层的增长是 <span class="math display">\[\frac{1}{3}.\frac{4}{9}^i\]</span> 可以用等比数列的求和算出答案，但时间复杂度必然是θ(1)</p><h2 id="电路模拟">电路模拟</h2><p><img src="assets/mit6.006作业解析/image-20231124185516359.png" /> 如图是对一个异或门的模拟，两个输入端AB产生的信号会在2ns的延迟后在输出端产生一个结果，除此以外没有延迟 按照题意运行<code>python -m cProfile -s time circuit.py &lt; tests/5devadas13.in</code> 得到如下结果（不完全），可以看到消耗最多时间的是lt(lower than)和find_min两个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">625762426  319.980    0.000  319.980    0.000 circuit.py:286(__lt__)</span><br><span class="line">   259964  315.431    0.001  635.431    0.002 circuit.py:381(_find_min)</span><br><span class="line">    64400    1.371    0.000  639.636    0.010 circuit.py:423(step)</span><br><span class="line">828793/634381    0.463    0.000    0.612    0.000 &#123;built-in method builtins.len&#125;</span><br><span class="line">   194381    0.421    0.000  635.865    0.003 circuit.py:361(min)</span><br><span class="line">    32768    0.352    0.000    0.352    0.000 &#123;method &#x27;write&#x27; of &#x27;_io.TextIOWrapper&#x27; objects&#125;</span><br><span class="line">    65554    0.309    0.000    0.723    0.000 circuit.py:163(transition_output)</span><br><span class="line">        1    0.290    0.290  640.116  640.116 circuit.py:456(run)</span><br></pre></td></tr></table></figure><p>随后题意要求基于原来的api实现一个优先队列(最小堆)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Array-based priority queue implementation.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initially empty priority queue.&quot;&quot;&quot;</span></span><br><span class="line">        self.queue = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leftchid</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*key+<span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightchild</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*key+<span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> (key-<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">self,key1,key2</span>):</span><br><span class="line">        temp=self.queue[key2]</span><br><span class="line">        self.queue[key2]=self.queue[key1]</span><br><span class="line">        self.queue[key1]=temp</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Number of elements in the queue.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sift_up</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            p=self.parent(key)</span><br><span class="line">            <span class="keyword">if</span> (p&lt;<span class="number">0</span> <span class="keyword">or</span> self.queue[p]&lt;=self.queue[key]):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.swap(p,key)</span><br><span class="line">                key=p</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Inserts an element in the priority queue.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Cannot insert None in the queue&#x27;</span>)</span><br><span class="line">        self.queue.append(key)</span><br><span class="line">        self.sift_up(self.__len__()-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;The smallest element in the queue.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            lft,rht = self.leftchid(key),self.rightchild(key)</span><br><span class="line">            min_key=key</span><br><span class="line">            <span class="keyword">if</span> (lft&lt;self.__len__() <span class="keyword">and</span> self.queue[lft]&lt;self.queue[key]):</span><br><span class="line">                min_key=lft</span><br><span class="line">            <span class="keyword">if</span> (rht&lt;self.__len__() <span class="keyword">and</span> self.queue[rht]&lt;self.queue[min_key]):</span><br><span class="line">                min_key=rht</span><br><span class="line">            <span class="keyword">if</span> (min_key==key): <span class="keyword">break</span></span><br><span class="line">            self.swap(min_key,key)</span><br><span class="line">            key =min_key</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Removes the minimum element in the queue.</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            The value of the removed element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.swap(<span class="number">0</span>,self.__len__()-<span class="number">1</span>)</span><br><span class="line">        min_val=self.queue.pop(self.__len__()-<span class="number">1</span>)</span><br><span class="line">        self.sift_down(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> min_val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_find_min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Computes the index of the minimum element in the queue.</span></span><br><span class="line">        <span class="comment"># This method may crash if called when the queue is empty.</span></span><br><span class="line">        <span class="keyword">if</span> self.__len__==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;cannot find min of empty queue&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>python3可以运行所有测试，但无法运行可视化程序，不过也无所谓了，优化后再次运行一开始的输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">    65583    2.826    0.000    5.321    0.000 circuit.py:389(sift_down)</span><br><span class="line">    65583    1.006    0.000    1.901    0.000 circuit.py:366(sift_up)</span><br><span class="line">  1930321    0.807    0.000    1.109    0.000 circuit.py:362(__len__)</span><br><span class="line">  1349048    0.772    0.000    0.772    0.000 circuit.py:357(swap)</span><br><span class="line">  1432334    0.719    0.000    0.719    0.000 circuit.py:286(__lt__)</span><br><span class="line">    64400    0.698    0.000    9.608    0.000 circuit.py:451(step)</span><br><span class="line">2450781/2256369    0.473    0.000    0.567    0.000 &#123;built-in method builtins.len&#125;</span><br></pre></td></tr></table></figure><p>问题解决了,amdtel的offer什么时候发？</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;hw1&quot;&gt;hw1&lt;/h1&gt;
&lt;h2 id=&quot;时间复杂度分析&quot;&gt;时间复杂度分析&lt;/h2&gt;
&lt;p&gt;对这种形式的函数可以这样比较&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[f_1=n^{&#92;sqrt{n}}=(2^{lgn})^{&#92;sqrt{n}}&#92;]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;&#92;[f_2=n^{10}.2^{n/2}=2^{lg(10n)+n/2}&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;复杂度计算&quot;&gt;复杂度计算&lt;/h2&gt;
&lt;p&gt;对于T(n,n): T (x, y) = Θ(x + y) + T (x/2, y/2). 化成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;assets/mit6.006作业解析/image-20231120213425020.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;得到θ(n)</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法" scheme="https://thinklive1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="麻省理工" scheme="https://thinklive1.github.io/tags/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>对加州房地产数据集的数据分析项目</title>
    <link href="https://thinklive1.github.io/2023/11/17/houses/"/>
    <id>https://thinklive1.github.io/2023/11/17/houses/</id>
    <published>2023-11-17T04:35:28.139Z</published>
    <updated>2023-11-27T12:50:13.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加利福尼亚房价数据集">加利福尼亚房价数据集</h1><h2 id="内容">内容</h2><p>这些数据涉及在加州某个地区的街区以及基于 1990 年人口普查数据的一些汇总统计数据：</p><ol type="1"><li>房屋中位价值：一个街区内家庭的房屋中位价值（以美元计算）</li><li>收入中位数：一栋房屋内的家庭收入中位数（以万美元衡量）</li><li>中位年龄：街区内房屋的中位年龄； 数字较小的是较新的建筑</li><li>房间总数：一个街区内的房间总数</li><li>卧室总数：一个街区内的卧室总数</li><li>人口：居住在一个街区内的总人数</li><li>家庭：一个街区的家庭总数</li><li>纬度：衡量房屋向北有多远的指标； 值越高越北 [°]</li><li>经度：衡量房屋向西有多远的量度； 数值越高，越西 [°]</li><li>距离海岸：到最近海岸点的距离[m]</li><li>到洛杉矶的距离：到洛杉矶市中心的距离[m]</li><li>到圣地亚哥的距离：到圣地亚哥中心的距离[m]</li><li>到圣何塞的距离: 到圣何塞中心的距离 [m]</li><li>到旧金山的距离：到旧金山市中心的距离[m] <span id="more"></span></li></ol><ol type="1"><li>Median House Value: Median house value for households within a block (measured in US Dollars)</li><li>Median Income: Median income for households within a block of houses (measured in tens of thousands of US Dollars)</li><li>Median Age: Median age of a house within a block; a lower number is a newer building [years]</li><li>Total Rooms: Total number of rooms within a block</li><li>Total Bedrooms: Total number of bedrooms within a block</li><li>Population: Total number of people residing within a block</li><li>Households: Total number of households, a group of people residing within a home unit, for a block</li><li>Latitude: A measure of how far north a house is; a higher value is farther north [°]</li><li>Longitude: A measure of how far west a house is; a higher value is farther west [°]</li><li>Distance to coast: Distance to the nearest coast point [m]</li><li>Distance to Los Angeles: Distance to the centre of Los Angeles [m]</li><li>Distance to San Diego: Distance to the centre of San Diego [m]</li><li>Distance to San Jose: Distance to the centre of San Jose [m]</li><li>Distance to San Francisco: Distance to the centre of San Francisco [m]</li></ol><h2 id="导入python库">导入python库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入python库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">training_data = pd.read_csv(<span class="string">&#x27;California_Houses.csv&#x27;</span>)</span><br><span class="line">training_data.head()</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Median_House_Value</th><th>Median_Income</th><th>Median_Age</th><th>Tot_Rooms</th><th>Tot_Bedrooms</th><th>Population</th><th>Households</th><th>Latitude</th><th>Longitude</th><th>Distance_to_coast</th><th>Distance_to_LA</th><th>Distance_to_SanDiego</th><th>Distance_to_SanJose</th><th>Distance_to_SanFrancisco</th></tr></thead><tbody><tr><th>0</th><td>452600.0</td><td>8.3252</td><td>41</td><td>880</td><td>129</td><td>322</td><td>126</td><td>37.88</td><td>-122.23</td><td>9263.040773</td><td>556529.158342</td><td>735501.806984</td><td>67432.517001</td><td>21250.213767</td></tr><tr><th>1</th><td>358500.0</td><td>8.3014</td><td>21</td><td>7099</td><td>1106</td><td>2401</td><td>1138</td><td>37.86</td><td>-122.22</td><td>10225.733072</td><td>554279.850069</td><td>733236.884360</td><td>65049.908574</td><td>20880.600400</td></tr><tr><th>2</th><td>352100.0</td><td>7.2574</td><td>52</td><td>1467</td><td>190</td><td>496</td><td>177</td><td>37.85</td><td>-122.24</td><td>8259.085109</td><td>554610.717069</td><td>733525.682937</td><td>64867.289833</td><td>18811.487450</td></tr><tr><th>3</th><td>341300.0</td><td>5.6431</td><td>52</td><td>1274</td><td>235</td><td>558</td><td>219</td><td>37.85</td><td>-122.25</td><td>7768.086571</td><td>555194.266086</td><td>734095.290744</td><td>65287.138412</td><td>18031.047568</td></tr><tr><th>4</th><td>342200.0</td><td>3.8462</td><td>52</td><td>1627</td><td>280</td><td>565</td><td>259</td><td>37.85</td><td>-122.25</td><td>7768.086571</td><td>555194.266086</td><td>734095.290744</td><td>65287.138412</td><td>18031.047568</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">training_data.columns.values</span><br></pre></td></tr></table></figure><pre><code>array([&#39;Median_House_Value&#39;, &#39;Median_Income&#39;, &#39;Median_Age&#39;, &#39;Tot_Rooms&#39;,       &#39;Tot_Bedrooms&#39;, &#39;Population&#39;, &#39;Households&#39;, &#39;Latitude&#39;,       &#39;Longitude&#39;, &#39;Distance_to_coast&#39;, &#39;Distance_to_LA&#39;,       &#39;Distance_to_SanDiego&#39;, &#39;Distance_to_SanJose&#39;,       &#39;Distance_to_SanFrancisco&#39;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">training_data.describe()</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Median_House_Value</th><th>Median_Income</th><th>Median_Age</th><th>Tot_Rooms</th><th>Tot_Bedrooms</th><th>Population</th><th>Households</th><th>Latitude</th><th>Longitude</th><th>Distance_to_coast</th><th>Distance_to_LA</th><th>Distance_to_SanDiego</th><th>Distance_to_SanJose</th><th>Distance_to_SanFrancisco</th></tr></thead><tbody><tr><th>count</th><td>20640.000000</td><td>20640.000000</td><td>20640.000000</td><td>20640.000000</td><td>20640.000000</td><td>20640.000000</td><td>20640.000000</td><td>20640.000000</td><td>20640.000000</td><td>20640.000000</td><td>2.064000e+04</td><td>2.064000e+04</td><td>20640.000000</td><td>20640.000000</td></tr><tr><th>mean</th><td>206855.816909</td><td>3.870671</td><td>28.639486</td><td>2635.763081</td><td>537.898014</td><td>1425.476744</td><td>499.539680</td><td>35.631861</td><td>-119.569704</td><td>40509.264883</td><td>2.694220e+05</td><td>3.981649e+05</td><td>349187.551219</td><td>386688.422291</td></tr><tr><th>std</th><td>115395.615874</td><td>1.899822</td><td>12.585558</td><td>2181.615252</td><td>421.247906</td><td>1132.462122</td><td>382.329753</td><td>2.135952</td><td>2.003532</td><td>49140.039160</td><td>2.477324e+05</td><td>2.894006e+05</td><td>217149.875026</td><td>250122.192316</td></tr><tr><th>min</th><td>14999.000000</td><td>0.499900</td><td>1.000000</td><td>2.000000</td><td>1.000000</td><td>3.000000</td><td>1.000000</td><td>32.540000</td><td>-124.350000</td><td>120.676447</td><td>4.205891e+02</td><td>4.849180e+02</td><td>569.448118</td><td>456.141313</td></tr><tr><th>25%</th><td>119600.000000</td><td>2.563400</td><td>18.000000</td><td>1447.750000</td><td>295.000000</td><td>787.000000</td><td>280.000000</td><td>33.930000</td><td>-121.800000</td><td>9079.756762</td><td>3.211125e+04</td><td>1.594264e+05</td><td>113119.928682</td><td>117395.477505</td></tr><tr><th>50%</th><td>179700.000000</td><td>3.534800</td><td>29.000000</td><td>2127.000000</td><td>435.000000</td><td>1166.000000</td><td>409.000000</td><td>34.260000</td><td>-118.490000</td><td>20522.019101</td><td>1.736675e+05</td><td>2.147398e+05</td><td>459758.877000</td><td>526546.661701</td></tr><tr><th>75%</th><td>264725.000000</td><td>4.743250</td><td>37.000000</td><td>3148.000000</td><td>647.000000</td><td>1725.000000</td><td>605.000000</td><td>37.710000</td><td>-118.010000</td><td>49830.414479</td><td>5.271562e+05</td><td>7.057954e+05</td><td>516946.490963</td><td>584552.007907</td></tr><tr><th>max</th><td>500001.000000</td><td>15.000100</td><td>52.000000</td><td>39320.000000</td><td>6445.000000</td><td>35682.000000</td><td>6082.000000</td><td>41.950000</td><td>-114.310000</td><td>333804.686371</td><td>1.018260e+06</td><td>1.196919e+06</td><td>836762.678210</td><td>903627.663298</td></tr></tbody></table></div><h2 id="数据过滤">数据过滤</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_distribution</span>(<span class="params">data, label</span>):</span><br><span class="line">    fig, axs = plt.subplots(nrows=<span class="number">2</span>)</span><br><span class="line">    sns.histplot(</span><br><span class="line">        data[label], </span><br><span class="line">        ax=axs[<span class="number">0</span>]</span><br><span class="line">    )</span><br><span class="line">    sns.boxplot(</span><br><span class="line">        x=data[label],</span><br><span class="line">        width=<span class="number">0.3</span>, </span><br><span class="line">        ax=axs[<span class="number">1</span>],</span><br><span class="line">        showfliers=<span class="literal">False</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    spacer = np.<span class="built_in">max</span>(data[label]) * <span class="number">0.05</span></span><br><span class="line">    xmin = np.<span class="built_in">min</span>(data[label]) - spacer</span><br><span class="line">    xmax = np.<span class="built_in">max</span>(data[label]) + spacer</span><br><span class="line">    axs[<span class="number">0</span>].set_xlim((xmin, xmax))</span><br><span class="line">    axs[<span class="number">1</span>].set_xlim((xmin, xmax))</span><br><span class="line"></span><br><span class="line">    plt.subplots_adjust(hspace=<span class="number">0</span>)</span><br><span class="line">    fig.suptitle(<span class="string">&quot;Distribution of &quot;</span> + label)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#观察数据分布</span></span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Age&#x27;</span>);</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Income&#x27;</span>);</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_8_0.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_8_1.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_8_2.png" alt="" /><figcaption>png</figcaption></figure><p>可以看到收入和售价数据的右侧末端比较不合理，应该过滤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据清洗函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_outliers</span>(<span class="params">data, variable, lower=-np.inf, upper=np.inf</span>):</span><br><span class="line">    df = data.copy()</span><br><span class="line">    df = df[df[variable] &gt; lower]</span><br><span class="line">    df = df[df[variable] &lt; upper]</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Median_Income&#x27;</span>,<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Median_House_Value&#x27;</span>,<span class="number">0</span>,<span class="number">400000</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Distance_to_coast&#x27;</span>,<span class="number">0</span>,<span class="number">70000</span>)</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;Households&#x27;</span>,<span class="number">0</span>,<span class="number">1500</span>)</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Age&#x27;</span>);</span><br><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Median_Income&#x27;</span>);</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_11_0.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_11_1.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_11_2.png" alt="" /><figcaption>png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">training_data.describe()</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Median_House_Value</th><th>Median_Income</th><th>Median_Age</th><th>Tot_Rooms</th><th>Tot_Bedrooms</th><th>Population</th><th>Households</th><th>Latitude</th><th>Longitude</th><th>Distance_to_coast</th><th>Distance_to_LA</th><th>Distance_to_SanDiego</th><th>Distance_to_SanJose</th><th>Distance_to_SanFrancisco</th></tr></thead><tbody><tr><th>count</th><td>14651.000000</td><td>14651.000000</td><td>14651.000000</td><td>14651.000000</td><td>14651.000000</td><td>14651.000000</td><td>14651.000000</td><td>14651.000000</td><td>14651.000000</td><td>14651.000000</td><td>1.465100e+04</td><td>1.465100e+04</td><td>14651.000000</td><td>14651.000000</td></tr><tr><th>mean</th><td>199561.517917</td><td>3.696580</td><td>29.953996</td><td>2356.678657</td><td>496.034742</td><td>1367.255341</td><td>468.929561</td><td>35.372597</td><td>-119.555017</td><td>21259.751408</td><td>2.490542e+05</td><td>3.721187e+05</td><td>359123.874456</td><td>397236.235539</td></tr><tr><th>std</th><td>79310.711796</td><td>1.419884</td><td>12.191439</td><td>1425.953928</td><td>287.919292</td><td>814.994880</td><td>266.065608</td><td>2.077014</td><td>2.063217</td><td>16562.862059</td><td>2.475190e+05</td><td>2.905277e+05</td><td>226985.441402</td><td>262135.238533</td></tr><tr><th>min</th><td>14999.000000</td><td>0.499900</td><td>1.000000</td><td>11.000000</td><td>3.000000</td><td>3.000000</td><td>3.000000</td><td>32.540000</td><td>-124.350000</td><td>120.676447</td><td>4.205891e+02</td><td>4.849180e+02</td><td>569.448118</td><td>456.141313</td></tr><tr><th>25%</th><td>140600.000000</td><td>2.625000</td><td>20.000000</td><td>1410.000000</td><td>296.000000</td><td>816.000000</td><td>286.000000</td><td>33.880000</td><td>-121.890000</td><td>8077.199272</td><td>2.631262e+04</td><td>1.550810e+05</td><td>88700.495102</td><td>92070.783507</td></tr><tr><th>50%</th><td>187500.000000</td><td>3.551100</td><td>31.000000</td><td>2053.000000</td><td>431.000000</td><td>1190.000000</td><td>412.000000</td><td>34.140000</td><td>-118.360000</td><td>17596.867293</td><td>1.385490e+05</td><td>1.872540e+05</td><td>484362.783196</td><td>552023.712780</td></tr><tr><th>75%</th><td>252000.000000</td><td>4.625000</td><td>38.000000</td><td>2968.000000</td><td>631.000000</td><td>1725.000000</td><td>595.000000</td><td>37.690000</td><td>-117.980000</td><td>28063.195081</td><td>5.221622e+05</td><td>7.009827e+05</td><td>519935.107297</td><td>587792.558476</td></tr><tr><th>max</th><td>399400.000000</td><td>7.988700</td><td>52.000000</td><td>12837.000000</td><td>2219.000000</td><td>8733.000000</td><td>1499.000000</td><td>41.950000</td><td>-114.550000</td><td>69995.382339</td><td>1.018260e+06</td><td>1.196919e+06</td><td>836762.678210</td><td>903627.663298</td></tr></tbody></table></div><h2 id="数据处理">数据处理</h2><p>对一些数值过大的数据进行log处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log_transform</span>(<span class="params">data, col</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Add the log transformation of a column to the data frame&quot;&quot;&quot;</span></span><br><span class="line">    data[<span class="string">&#x27;Log &#x27;</span> + col] = np.log(data[col])</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">training_data=log_transform(training_data,<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br><span class="line">training_data=log_transform(training_data,<span class="string">&#x27;Distance_to_coast&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot_distribution(training_data, label=<span class="string">&#x27;Log Median_House_Value&#x27;</span>);</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_16_0.png" alt="" /><figcaption>png</figcaption></figure><h2 id="数据分析寻找与房屋价格有线性关系的列">数据分析——寻找与房屋价格有线性关系的列</h2><h3 id="可视化房屋价格与距离远近的关系">可视化房屋价格与距离远近的关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">places=[<span class="string">&#x27;Distance_to_coast&#x27;</span>, <span class="string">&#x27;Distance_to_LA&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Distance_to_SanDiego&#x27;</span>, <span class="string">&#x27;Distance_to_SanJose&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Distance_to_SanFrancisco&#x27;</span>]</span><br><span class="line">training_data[places].describe()</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>Distance_to_coast</th><th>Distance_to_LA</th><th>Distance_to_SanDiego</th><th>Distance_to_SanJose</th><th>Distance_to_SanFrancisco</th></tr></thead><tbody><tr><th>count</th><td>14651.000000</td><td>1.465100e+04</td><td>1.465100e+04</td><td>14651.000000</td><td>14651.000000</td></tr><tr><th>mean</th><td>21259.751408</td><td>2.490542e+05</td><td>3.721187e+05</td><td>359123.874456</td><td>397236.235539</td></tr><tr><th>std</th><td>16562.862059</td><td>2.475190e+05</td><td>2.905277e+05</td><td>226985.441402</td><td>262135.238533</td></tr><tr><th>min</th><td>120.676447</td><td>4.205891e+02</td><td>4.849180e+02</td><td>569.448118</td><td>456.141313</td></tr><tr><th>25%</th><td>8077.199272</td><td>2.631262e+04</td><td>1.550810e+05</td><td>88700.495102</td><td>92070.783507</td></tr><tr><th>50%</th><td>17596.867293</td><td>1.385490e+05</td><td>1.872540e+05</td><td>484362.783196</td><td>552023.712780</td></tr><tr><th>75%</th><td>28063.195081</td><td>5.221622e+05</td><td>7.009827e+05</td><td>519935.107297</td><td>587792.558476</td></tr><tr><th>max</th><td>69995.382339</td><td>1.018260e+06</td><td>1.196919e+06</td><td>836762.678210</td><td>903627.663298</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(data = training_data, x = <span class="string">&quot;Distance_to_coast&quot;</span>, \</span><br><span class="line">              y = <span class="string">&quot;Log Median_House_Value&quot;</span>, \</span><br><span class="line">              kind = <span class="string">&quot;hex&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.suptitle allows us to shift the title up so it does not overlap with the histogram</span></span><br><span class="line">plt.suptitle(<span class="string">&quot;coast distance agginst value&quot;</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.9</span>);</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_20_0.png" alt="" /><figcaption>png</figcaption></figure><p>可以看出距海岸线距离似乎与房价有关系</p><h3 id="用折线图表示平均房价与海岸线与城市距离关系">用折线图表示平均房价与海岸线与城市距离关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_mean_lineplot</span>(<span class="params">dis,val,df=training_data,thisbins=<span class="number">200</span></span>):</span><br><span class="line">    categories = pd.cut(df[dis], bins=thisbins)</span><br><span class="line">    mids = [c.mid <span class="keyword">for</span> c <span class="keyword">in</span> categories]  </span><br><span class="line">    df[<span class="string">&#x27;distance_bin&#x27;</span>] = mids</span><br><span class="line">    mean_price = df.groupby(<span class="string">&#x27;distance_bin&#x27;</span>)[val].mean()</span><br><span class="line">    newdf=pd.DataFrame()</span><br><span class="line">    newdf[<span class="string">&#x27;mean_price&#x27;</span>]=mean_price</span><br><span class="line">    newdf[<span class="string">&#x27;distance_bin&#x27;</span>]=mean_price.index</span><br><span class="line">    sns.lineplot(x=<span class="string">&#x27;distance_bin&#x27;</span>,y=<span class="string">&#x27;mean_price&#x27;</span>,data=newdf)</span><br><span class="line">    plt.title(<span class="string">&quot;mean house price with the same &quot;</span>+dis)</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="keyword">for</span> pla <span class="keyword">in</span> places:</span><br><span class="line">    draw_mean_lineplot(dis=pla,val=<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_23_0.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_23_1.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_23_2.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_23_3.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_23_4.png" alt="" /><figcaption>png</figcaption></figure><p>根据可视化发现，只有海岸线距离与房价有类似线性关系</p><h3 id="房屋数和卧室数与房价是否相关">房屋数和卧室数与房价是否相关</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Tot_Rooms&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">50</span>)</span><br><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Tot_Bedrooms&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_26_0.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_26_1.png" alt="" /><figcaption>png</figcaption></figure><p>可以看出单独两列和房价都无明显关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;bedroom_proportion&#x27;</span>] =training_data[<span class="string">&#x27;Tot_Bedrooms&#x27;</span>] / training_data[<span class="string">&#x27;Tot_Rooms&#x27;</span>]</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;bedroom_proportion&#x27;</span>,<span class="number">0</span>,<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">sns.lmplot(data = training_data, x = <span class="string">&quot;bedroom_proportion&quot;</span>, \</span><br><span class="line">           y = <span class="string">&quot;Median_House_Value&quot;</span>,x_bins=<span class="number">100</span>,x_ci=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&quot;proportion of bedroom against house value&quot;</span>);</span><br></pre></td></tr></table></figure><pre><code>C:\Users\thive\anaconda3\Lib\site-packages\seaborn\axisgrid.py:118: UserWarning: The figure layout has changed to tight  self._figure.tight_layout(*args, **kwargs)</code></pre><figure><img src="/assets/houses/output_28_1.png" alt="" /><figcaption>png</figcaption></figure><p>两者比例和房价近似线性有关</p><h3 id="和房屋年龄关系">和房屋年龄关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_mean_lineplot(dis=<span class="string">&#x27;Median_Age&#x27;</span>,val=<span class="string">&#x27;Median_House_Value&#x27;</span>,thisbins=<span class="number">500</span>)</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_31_0.png" alt="" /><figcaption>png</figcaption></figure><p>可以看出和年龄没有明显关系</p><h3 id="和家庭平均人口数的关系">和家庭平均人口数的关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;people_house_proportion&#x27;</span>] =training_data[<span class="string">&#x27;Population&#x27;</span>] / training_data[<span class="string">&#x27;Households&#x27;</span>]</span><br><span class="line">training_data=remove_outliers(training_data,<span class="string">&#x27;people_house_proportion&#x27;</span>,<span class="number">0</span>,<span class="number">3.5</span>)</span><br><span class="line">sns.lmplot(data = training_data, x = <span class="string">&quot;people_house_proportion&quot;</span>, \</span><br><span class="line">           y = <span class="string">&quot;Median_House_Value&quot;</span>,x_bins=<span class="number">50</span>,x_ci=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&quot;proportion of people in house against house value&quot;</span>);</span><br></pre></td></tr></table></figure><pre><code>C:\Users\thive\anaconda3\Lib\site-packages\seaborn\axisgrid.py:118: UserWarning: The figure layout has changed to tight  self._figure.tight_layout(*args, **kwargs)</code></pre><figure><img src="/assets/houses/output_34_1.png" alt="" /><figcaption>png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">training_data[<span class="string">&#x27;people_house_proportion&#x27;</span>].describe()</span><br></pre></td></tr></table></figure><pre><code>count    9213.000000mean        2.722022std         0.422372min         1.06060625%         2.43264750%         2.74084575%         3.044444max         3.499266Name: people_house_proportion, dtype: float64</code></pre><p>可以看出和家庭平均人数有线性关系</p><h3 id="与中位数收入的关系">与中位数收入的关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(data = training_data, x = <span class="string">&quot;Median_Income&quot;</span>, \</span><br><span class="line">           y = <span class="string">&quot;Median_House_Value&quot;</span>,x_bins=<span class="number">50</span>)</span><br><span class="line">plt.title(<span class="string">&quot;median income against house value&quot;</span>);</span><br></pre></td></tr></table></figure><pre><code>C:\Users\thive\anaconda3\Lib\site-packages\seaborn\axisgrid.py:118: UserWarning: The figure layout has changed to tight  self._figure.tight_layout(*args, **kwargs)</code></pre><figure><img src="/assets/houses/output_38_1.png" alt="" /><figcaption>png</figcaption></figure><p>可以看出和中位数收入线性有关</p><h3 id="验证相关性可视化">验证——相关性可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">correlation = training_data.corr()[<span class="string">&#x27;Median_House_Value&#x27;</span>].sort_values(ascending = <span class="literal">False</span>).to_frame()</span><br><span class="line">sns.heatmap(correlation, annot = <span class="literal">True</span>, cmap = <span class="string">&#x27;Blues&#x27;</span>, fmt = <span class="string">&#x27;.2f&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>&lt;Axes: &gt;</code></pre><figure><img src="/assets/houses/output_41_1.png" alt="" /><figcaption>png</figcaption></figure><h2 id="建立模型">建立模型</h2><h3 id="拆分数据">拆分数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_val_split</span>(<span class="params">data, train_pct=<span class="number">0.8</span></span>):</span><br><span class="line">    data_len = data.shape[<span class="number">0</span>]</span><br><span class="line">    shuffled_indices = np.random.permutation(data_len)</span><br><span class="line">    </span><br><span class="line">    split_index = <span class="built_in">int</span>(<span class="number">0.8</span> * data_len)</span><br><span class="line">    train_indices = shuffled_indices[:split_index]</span><br><span class="line">    val_indices = shuffled_indices[split_index:]</span><br><span class="line">    </span><br><span class="line">    train = data.iloc[train_indices]</span><br><span class="line">    validation = data.iloc[val_indices]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train, validation</span><br><span class="line"></span><br><span class="line">train_m1, valid_m1 = train_val_split(training_data)</span><br><span class="line">train_m2, valid_m2 = train_val_split(training_data)</span><br><span class="line">features=[<span class="string">&#x27;Median_Income&#x27;</span>,<span class="string">&#x27;Distance_to_coast&#x27;</span>,<span class="string">&#x27;bedroom_proportion&#x27;</span>,<span class="string">&#x27;people_house_proportion&#x27;</span>]</span><br><span class="line"><span class="comment">#模型1</span></span><br><span class="line">X_train_m1 = train_m1[[<span class="string">&#x27;Median_Income&#x27;</span>]]</span><br><span class="line">y_train_m1 = train_m1[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line">X_valid_m1 = valid_m1[[<span class="string">&#x27;Median_Income&#x27;</span>]]</span><br><span class="line">y_valid_m1 = valid_m1[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line"><span class="comment">#模型2</span></span><br><span class="line">X_train_m2 = train_m2[features]</span><br><span class="line">y_train_m2 = train_m2[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br><span class="line">X_valid_m2 = valid_m2[features]</span><br><span class="line">y_valid_m2 = valid_m2[[<span class="string">&#x27;Median_House_Value&#x27;</span>]]</span><br></pre></td></tr></table></figure><h3 id="建立线性模型">建立线性模型</h3><p><span class="math display">\[\hat{y}_i = \theta_0 + \theta_1 x_i\]</span></p><p>建立线性回归模型，并可视化预测值的分布与实际分布比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model <span class="keyword">as</span> lm</span><br><span class="line">linear_model_m1 = lm.LinearRegression()</span><br><span class="line">linear_model_m2 = lm.LinearRegression()</span><br><span class="line"><span class="comment"># Fit the 1st model</span></span><br><span class="line">linear_model_m1.fit(X_train_m1, y_train_m1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the fitted and predicted values for 1st model</span></span><br><span class="line">y_fitted_m1 = linear_model_m1.predict(X_train_m1)</span><br><span class="line">y_predicted_m1 = linear_model_m1.predict(X_valid_m1)</span><br><span class="line">predictions_series = pd.Series(y_predicted_m1[:,<span class="number">0</span>])</span><br><span class="line">predictions_df = predictions_series.to_frame()</span><br><span class="line">predictions_df=predictions_df.rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;house value&#x27;</span>&#125;)</span><br><span class="line">plot_distribution(predictions_df,<span class="string">&#x27;house value&#x27;</span>)</span><br><span class="line">plot_distribution(valid_m1,<span class="string">&#x27;Median_House_Value&#x27;</span>)</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_46_0.png" alt="" /><figcaption>png</figcaption></figure><figure><img src="/assets/houses/output_46_1.png" alt="" /><figcaption>png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linear_model_m2.fit(X_train_m2, y_train_m2)</span><br><span class="line">y_fitted_m2 = linear_model_m2.predict(X_train_m2)</span><br><span class="line">y_predicted_m2 = linear_model_m2.predict(X_valid_m2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear_model_m1.score(X_train_m1, y_train_m1)</span><br></pre></td></tr></table></figure><pre><code>0.4072930993173016</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear_model_m2.score(X_train_m2, y_train_m2)</span><br></pre></td></tr></table></figure><pre><code>0.5179760889801486</code></pre><p>可以看出使用更多特征列的模型二有更好的性能</p><h3 id="误差评估">误差评估</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = y_valid_m1 - y_predicted_m1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m1, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Log Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for Model 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_52_0.png" alt="" /><figcaption>png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Calculate residuals </span></span><br><span class="line">residuals = y_valid_m2 - y_predicted_m2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create scatter plot</span></span><br><span class="line">plt.scatter(y_valid_m2, residuals, alpha=<span class="number">0.5</span>, s=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Label axes</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Log Sale Price&#x27;</span>) </span><br><span class="line">plt.ylabel(<span class="string">&#x27;Residuals&#x27;</span>)</span><br><span class="line"><span class="comment"># Set plot title</span></span><br><span class="line">plt.title(<span class="string">&#x27;Residuals vs. Sale Price for Model 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show plot</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_53_0.png" alt="" /><figcaption>png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rmse</span>(<span class="params">predicted, actual</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.mean((actual - predicted)**<span class="number">2</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rmse_m1 = rmse(y_predicted_m1, y_valid_m1)</span><br><span class="line">rmse_m2 = rmse(y_predicted_m2, y_valid_m2)</span><br><span class="line">plt.bar([<span class="string">&#x27;Model 1&#x27;</span>, <span class="string">&#x27;Model 2&#x27;</span>], [rmse_m1, rmse_m2])</span><br><span class="line">plt.ylabel(<span class="string">&#x27;RMSE&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Model Comparison on RMSE&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><img src="/assets/houses/output_55_0.png" alt="" /><figcaption>png</figcaption></figure><p>to_do:交叉验证，正则化，主成分分析，逻辑回归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;加利福尼亚房价数据集&quot;&gt;加利福尼亚房价数据集&lt;/h1&gt;
&lt;h2 id=&quot;内容&quot;&gt;内容&lt;/h2&gt;
&lt;p&gt;这些数据涉及在加州某个地区的街区以及基于 1990 年人口普查数据的一些汇总统计数据：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;房屋中位价值：一个街区内家庭的房屋中位价值（以美元计算）&lt;/li&gt;
&lt;li&gt;收入中位数：一栋房屋内的家庭收入中位数（以万美元衡量）&lt;/li&gt;
&lt;li&gt;中位年龄：街区内房屋的中位年龄； 数字较小的是较新的建筑&lt;/li&gt;
&lt;li&gt;房间总数：一个街区内的房间总数&lt;/li&gt;
&lt;li&gt;卧室总数：一个街区内的卧室总数&lt;/li&gt;
&lt;li&gt;人口：居住在一个街区内的总人数&lt;/li&gt;
&lt;li&gt;家庭：一个街区的家庭总数&lt;/li&gt;
&lt;li&gt;纬度：衡量房屋向北有多远的指标； 值越高越北 [°]&lt;/li&gt;
&lt;li&gt;经度：衡量房屋向西有多远的量度； 数值越高，越西 [°]&lt;/li&gt;
&lt;li&gt;距离海岸：到最近海岸点的距离[m]&lt;/li&gt;
&lt;li&gt;到洛杉矶的距离：到洛杉矶市中心的距离[m]&lt;/li&gt;
&lt;li&gt;到圣地亚哥的距离：到圣地亚哥中心的距离[m]&lt;/li&gt;
&lt;li&gt;到圣何塞的距离: 到圣何塞中心的距离 [m]&lt;/li&gt;
&lt;li&gt;到旧金山的距离：到旧金山市中心的距离[m]</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据科学" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="python" scheme="https://thinklive1.github.io/tags/python/"/>
    
    <category term="数据科学" scheme="https://thinklive1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于中科大郑烇老师授课的计算机网络笔记(待续)</title>
    <link href="https://thinklive1.github.io/2023/10/14/%E8%AE%A1%E7%BD%91/"/>
    <id>https://thinklive1.github.io/2023/10/14/%E8%AE%A1%E7%BD%91/</id>
    <published>2023-10-14T12:37:40.032Z</published>
    <updated>2023-11-27T12:50:13.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章概论">第一章——概论</h2><h3 id="互联网">互联网</h3><p><code>链路层</code>相邻节点传输数据 <code>网络层</code>提供源主机到目标主机之间(端到端end to end)的服务(没有保障)</p><ol type="1"><li>传统方式：IP协议，路由协议（路由器交换路由信息，根据算法算出路由表，由ip协议根据目标ip查询路由表确定找到合适端口，进行转发）</li><li>SDN(数据平面：交换机，控制平面：网络操作系统)，控制平面中的网络应用根据信息算出有大量字段的流表给交换机，根据字段匹配相应表项 <code>传输层</code>区分进程，为进程中多个应用提供服务 <code>传输协议</code>:tcp提供可靠的数据传输，udp更强调实时性 <code>tcp</code>：往返建立连接得到响应后再传输 <code>udp</code>：不会先建立连接再传输 <code>应用层协议</code>：客户端，服务器等应用之间如何交互来实现功能 <code>网络</code>：节点和边的形成的拓扑结构 <code>计算机网络</code>：</li></ol><ul><li>节点：主机节点，数据交换节点（转发数据，交换机，路由器等等）</li><li>边被称为链路：接入网链路（主机连接到互联网），主干链路（路由器之间）</li><li>协议：网络设备的工作标准 <code>互联网</code>：世界上最大的互联计算机网络，网络的网络 <span id="more"></span></li><li>节点：数以亿计的互联设备，主机(host/end system),一般方节点是主机，圆节点是交换机</li><li>通信链路(link)：光纤，卫星，无线电等，传输速率 = 带宽(bps每秒传输的位)</li><li>分组交换设备(packets):路由器和交换机</li><li>协议和标准(tcp,ip,udp,)：不同实体之间通讯方式的规定(在RFC官网公布) 协议定义了发送信息的格式，次序，动作等</li></ul><p>从服务角度：应用层以下是基础设施，为其上的分布式应用提供通讯，两者一起组成了互联网 提供通讯使用操作系统提供的网络api(socket)和其他节点建立连接和通讯</p><h3 id="网络边缘">网络边缘</h3><p><img src="assets/计网/image-20231010191525639.png" /> 互联网的三个子系统</p><ul><li><code>网络边缘</code>：主机和应用程序</li><li><code>网络核心</code>：实现大规模的数据交换，互联的路由器（网络的网络）</li><li><code>网络的接入</code>:把边缘接入到核心</li></ul><p>边缘的模式</p><ol type="1"><li>C/S模式(主从模式)，客户端-服务器(客户端发送请求，服务器响应请求，并把结果发送给客户端) 缺点：可扩展性较差，负载达到一定阈值，响应能力断崖式下降</li><li>P2P模式(Peer to Peer)，对等模式，每个节点既是客户端又是服务器，分布式通信 可以在不同的节点上得到分段的资源</li></ol><p>通信方式</p><ol type="1"><li>面向连接的通讯方式，先建立连接(发送连接请求，响应请求，准备好缓冲区等)，再相互通讯 特点：连接状态仅仅是端系统维持 eg. tcp协议（流量控制）</li><li>无连接通信，不建立连接 eg. udp协议（无流量控制）</li></ol><h3 id="网络核心">网络核心</h3><p>路由器的网状网络 <img src="assets/计网/image-20231013084440297.png" /> 网络资源可以被分成片，给每个呼叫分配片，如果没有数据交换，则可以不占用资源片（频分，波分等） 资源交换除了时间还有电磁波的传播延迟 <img src="assets/计网/image-20231013103915204.png" /> 电路交换不适合计算机通信（计算机通信有突发性）</p><p>分组交换(共享性)：交换节点存储数据包，并分组转发，从而实现通信，按需使用网络资源 由于中间节点的存在，延迟比线路交换更高 可能出现分组的排队，甚至丢失 路由：决定源主机到目标主机的路径 转发：把输入链路转移到输出链路 <code>复用方式</code>：时分复用（时间片），统计多路复用(不固定) 问题：流媒体等需要速度保证的场景有更高的性能需求</p><p>分组交换网络：</p><ul><li>数据报网络：两主机不需要建立连接，不需要维护通信状态，每个主机都有目标主机的地址，可以独立路由地运作，路由器根据分组的目标地址进行路由</li><li>虚电路网络：两个主机通信前建立连接，每个分组有一个虚电路表，按照虚电路号标识进行存储转发，过程中虚电路号可能变化</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第一章概论&quot;&gt;第一章——概论&lt;/h2&gt;
&lt;h3 id=&quot;互联网&quot;&gt;互联网&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;链路层&lt;/code&gt;相邻节点传输数据 &lt;code&gt;网络层&lt;/code&gt;提供源主机到目标主机之间(端到端end to end)的服务(没有保障)&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;传统方式：IP协议，路由协议（路由器交换路由信息，根据算法算出路由表，由ip协议根据目标ip查询路由表确定找到合适端口，进行转发）&lt;/li&gt;
&lt;li&gt;SDN(数据平面：交换机，控制平面：网络操作系统)，控制平面中的网络应用根据信息算出有大量字段的流表给交换机，根据字段匹配相应表项 &lt;code&gt;传输层&lt;/code&gt;区分进程，为进程中多个应用提供服务 &lt;code&gt;传输协议&lt;/code&gt;:tcp提供可靠的数据传输，udp更强调实时性 &lt;code&gt;tcp&lt;/code&gt;：往返建立连接得到响应后再传输 &lt;code&gt;udp&lt;/code&gt;：不会先建立连接再传输 &lt;code&gt;应用层协议&lt;/code&gt;：客户端，服务器等应用之间如何交互来实现功能 &lt;code&gt;网络&lt;/code&gt;：节点和边的形成的拓扑结构 &lt;code&gt;计算机网络&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;节点：主机节点，数据交换节点（转发数据，交换机，路由器等等）&lt;/li&gt;
&lt;li&gt;边被称为链路：接入网链路（主机连接到互联网），主干链路（路由器之间）&lt;/li&gt;
&lt;li&gt;协议：网络设备的工作标准 &lt;code&gt;互联网&lt;/code&gt;：世界上最大的互联计算机网络，网络的网络</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="中科大" scheme="https://thinklive1.github.io/tags/%E4%B8%AD%E7%A7%91%E5%A4%A7/"/>
    
    <category term="计算机网络" scheme="https://thinklive1.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>基于mit6.006和hello-algo的算法笔记</title>
    <link href="https://thinklive1.github.io/2023/10/14/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/"/>
    <id>https://thinklive1.github.io/2023/10/14/mit6.006%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-14T12:31:46.082Z</published>
    <updated>2023-11-28T03:04:36.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础">基础</h1><figure><img src="/assets/mit6.006总和笔记/algo.png" alt="" /><figcaption>算法合订本</figcaption></figure><h2 id="数据结构">数据结构</h2><p><img src="/assets/mit6.006总和笔记/image-20231016191822017.png" /></p><h2 id="算法性质">算法性质</h2><p><code>循环不变式</code>主要用来帮助我们理解算法的正确性。关千<code>循环不变式</code>，我们必须证明三条<br />性质：<br />初始化：循环的第一次迭代之前，它为真。<br />保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。<br />终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助千证明算法是正确的。</p><span id="more"></span><p>f(n) = O(g(n)) 类似于 a&lt;=b</p><p>f(n) = Ω (g(n)) 类似于 a&gt;=b</p><p>f(n) = θ (g(n)) 类似于 a=b</p><p>f(n) = o(g(n)) 类似于 a&lt;b</p><p>f(n) = w(g(n)) 类似于 a&gt;b <img src="/images/obsidian/20230519150021.png" title="image" alt="图片" /></p><h2 id="分治法递归">分治法（递归）</h2><h3 id="选择排序">选择排序</h3><ul><li>在A[:i+1]内找到最大的元素，和A[i]交换</li><li>递归地排序A[:i]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def selection_sort(A, i = None): # T(i)</span><br><span class="line">’’’Sort A[:i + 1]’’’</span><br><span class="line">    if i is None: i = len(A) - 1 # O(1)</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        j = prefix_max(A, i) # S(i)</span><br><span class="line">        A[i], A[j] = A[j], A[i] # O(1)</span><br><span class="line">        selection_sort(A, i - 1) # T(i - 1)</span><br><span class="line"></span><br><span class="line">def prefix_max(A, i): # S(i)找到最大元素的索引值</span><br><span class="line">’’’Return index of maximum in A[:i + 1]’’’</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        j = prefix_max(A, i - 1) # S(i - 1)</span><br><span class="line">        if A[i] &lt; A[j]: # O(1)</span><br><span class="line">            return j # O(1)</span><br><span class="line">    return i # O(1)</span><br></pre></td></tr></table></figure><p>python实现(迭代)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        k = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[k]:</span><br><span class="line">                k = j  <span class="comment"># 记录最小元素的索引</span></span><br><span class="line">        <span class="comment"># 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        nums[i], nums[k] = nums[k], nums[i]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">• prefix max analysis:</span><br><span class="line">– Base case: for i = 0, array has one element, so index of max is i</span><br><span class="line">– Induction: assume correct for i, maximum is either the maximum of A[:i] or A[i],</span><br><span class="line">returns correct index in either case</span><br><span class="line">• selection sort analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, last number of a sorted output is a largest number of</span><br><span class="line">the array, and the algorithm puts one there; then A[:i] is sorted by inductio</span><br></pre></td></tr></table></figure><p>性质：O(n^2)，非稳定原地排序</p><h3 id="插入排序">插入排序</h3><ul><li>类似扑克牌，从右侧选择未排序元素，逐个插入左侧的已排序部分</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def insertion_sort(A, i = None): # T(i)</span><br><span class="line">’’’Sort A[:i + 1]’’’</span><br><span class="line">    if i is None: i = len(A) - 1 # O(1)</span><br><span class="line">    if i &gt; 0: # O(1)</span><br><span class="line">        insertion_sort(A, i - 1) # T(i - 1)</span><br><span class="line">        insert_last(A, i) # S(i)</span><br><span class="line"></span><br><span class="line">def insert_last(A, i): # S(i)</span><br><span class="line">’’’Sort A[:i + 1] assuming sorted A[:i]’’’</span><br><span class="line">    if i &gt; 0 and A[i] &lt; A[i - 1]: # O(1)</span><br><span class="line">        A[i], A[i - 1] = A[i - 1], A[i] # O(1)</span><br><span class="line">        insert_last(A, i - 1) # S(i - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• insert last analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, if A[i] &gt;= A[i - 1], array is sorted; otherwise,</span><br><span class="line">swapping last two elements allows us to sort A[:i] by induction</span><br><span class="line"></span><br><span class="line">• insertion sort analysis:</span><br><span class="line">– Base case: for i = 0, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for i, algorithm sorts A[:i] by induction, and then</span><br><span class="line">insert last correctly sorts the rest as proved above</span><br></pre></td></tr></table></figure><p>python实现（迭代）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;插入排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        base = nums[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; base:</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]  <span class="comment"># 将 nums[j] 向右移动一位</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = base  <span class="comment"># 将 base 赋值到正确位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特性：复杂度O(n^2)，原地稳定排序</p><h3 id="归并排序">归并排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">A, a = <span class="number">0</span>, b = <span class="literal">None</span></span>): <span class="comment"># T(b - a = n)</span></span><br><span class="line">’’’Sort A[a:b]’’’</span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span>: b = <span class="built_in">len</span>(A) <span class="comment"># O(1)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> &lt; b - a: <span class="comment"># O(1)</span></span><br><span class="line">        c = (a + b + <span class="number">1</span>) // <span class="number">2</span> <span class="comment"># O(1)</span></span><br><span class="line">        merge_sort(A, a, c) <span class="comment"># T(n / 2)</span></span><br><span class="line">        merge_sort(A, c, b) <span class="comment"># T(n / 2)</span></span><br><span class="line">        L, R = A[a:c], A[c:b] <span class="comment"># O(n)</span></span><br><span class="line">        merge(L, R, A, <span class="built_in">len</span>(L), <span class="built_in">len</span>(R), a, b) <span class="comment"># S(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">L, R, A, i, j, a, b</span>): <span class="comment"># S(b - a = n)</span></span><br><span class="line">’’’Merge <span class="built_in">sorted</span> L[:i] <span class="keyword">and</span> R[:j] into A[a:b]’’’</span><br><span class="line">    <span class="keyword">if</span> a &lt; b: <span class="comment"># O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= <span class="number">0</span>) <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> L[i - <span class="number">1</span>] &gt; R[j - <span class="number">1</span>]): <span class="comment"># O(1)</span></span><br><span class="line">            A[b - <span class="number">1</span>] = L[i - <span class="number">1</span>] <span class="comment"># O(1)</span></span><br><span class="line">            i = i - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># O(1)</span></span><br><span class="line">        A[b - <span class="number">1</span>] = R[j - <span class="number">1</span>] <span class="comment"># O(1)</span></span><br><span class="line">        j = j - <span class="number">1</span> <span class="comment"># O(1)</span></span><br><span class="line">    merge(L, R, A, i, j, a, b - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">• merge analysis:</span><br><span class="line">– Base case: for n = 0, arrays are empty, so vacuously correct</span><br><span class="line">– Induction: assume correct for n, item in A[r] must be a largest number from remaining</span><br><span class="line">prefixes of L and R, and since they are sorted, taking largest of last items suffices;</span><br><span class="line">remainder is merged by induction</span><br><span class="line"> merge sort analysis:</span><br><span class="line">– Base case: for n = 1, array has one element so is sorted</span><br><span class="line">– Induction: assume correct for k &lt; n, algorithm sorts smaller halves by induction, and then merge merges into a sorted array as proved above.</span><br></pre></td></tr></table></figure><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, mid: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并左子数组和右子数组&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 左子数组区间 [left, mid], 右子数组区间 [mid+1, right]</span></span><br><span class="line">    <span class="comment"># 创建一个临时数组 tmp ，用于存放合并后的结果</span></span><br><span class="line">    tmp = [<span class="number">0</span>] * (right - left + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 初始化左子数组和右子数组的起始索引</span></span><br><span class="line">    i, j, k = left, mid + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 当左右子数组都还有元素时，比较并将较小的元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt;= nums[j]:</span><br><span class="line">            tmp[k] = nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp[k] = nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将左子数组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        tmp[k] = nums[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">        tmp[k] = nums[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(tmp)):</span><br><span class="line">        nums[left + k] = tmp[k]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;归并排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 当子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="comment"># 划分阶段</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span>  <span class="comment"># 计算中点</span></span><br><span class="line">    merge_sort(nums, left, mid)  <span class="comment"># 递归左子数组</span></span><br><span class="line">    merge_sort(nums, mid + <span class="number">1</span>, right)  <span class="comment"># 递归右子数组</span></span><br><span class="line">    <span class="comment"># 合并阶段</span></span><br><span class="line">    merge(nums, left, mid, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特性：O(nlgn)，稳定排序</p><h3 id="寻峰算法">寻峰算法</h3><p>一维情况： 实际上是一种二分查找，先查看中点是不是峰值，如果不是则选取邻居节点较大的一侧递归寻找 复杂度lgn</p><p>二维情况下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">• Pick middle column j = m/2</span><br><span class="line">• Find global maximum on column j at (i, j)</span><br><span class="line">• Compare (i, j − 1), (i, j), (i, j + 1)</span><br><span class="line">• Pick left columns of (i, j − 1) &gt; (i, j)</span><br><span class="line">• Similarly for right</span><br><span class="line">• (i, j) is a 2D-peak if neither condition holds</span><br><span class="line">• Solve the new problem with half the number of columns.</span><br><span class="line">• When you have a single column, find global maximum and you‘re done.</span><br><span class="line"></span><br><span class="line">T (n, m) = T (n, m/2) + Θ(n) (to find global maximum on a column — (n rows))</span><br><span class="line">T (n, m) = (Θ(n) + . . . + Θ(n))log m= Θ(n log m) = Θ(n log n) if m = n</span><br></pre></td></tr></table></figure><p>这种解法思路是：</p><ol type="1"><li><p>对数组的中间一列寻找最大值</p></li><li><p>如果最大值是峰值，可以返回</p></li><li><p>否则对数组最大的邻居所在的一侧进行递归(即子问题大小为原来的一半)</p></li></ol><p>除此以外还有一种贪心解法：从(0,0)开始，不断寻找当前节点的最大邻居，并不断迭代，时间复杂度O(n^2) 还有一种θ(n)的解法，详见<a href="https://thinklive1.github.io/2023/11/20/mit6.006%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/">作业解析</a></p><h3 id="最大子数组">最大子数组</h3><p>算法思路： 元素和最大的子数组有三种情况：在左半数组，右半数组，或者跨越中点，第一和第二种情况可以用递归遍历解决，第三种情况则分为两个半边数组的组合，只要从中点出发寻找最大子数组，然后组合就可以了</p><p><code>时间复杂度分析</code>：，其中线性时间为跨越中点的子数组，最终需要时间为O(NlogN) <img src="/images/obsidian/20230522103507.png" title="image" alt="图片" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">FIND-MAXIMUM-SUBARRAY(A, low， high)  </span><br><span class="line">    if high== low  </span><br><span class="line">        return (low, high, A[low])  </span><br><span class="line">    else mid=mod((low 十 high)/2) </span><br><span class="line">        (left-low, left-high, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid)  </span><br><span class="line">    </span><br><span class="line">        (right-low, right-high, right-sum) =  FIND-MAXIMUM-SUBARRAY(A, mid+l. high)  </span><br><span class="line">    </span><br><span class="line">        (cross-low, cross-high, cross-sum) =  FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)  </span><br><span class="line">    </span><br><span class="line">    if left-sum&gt;=right-sum and left-sum&gt;=cross-sum  </span><br><span class="line">        return (left-low, left-high, left-sum)  </span><br><span class="line">    </span><br><span class="line">    elseif rightr-sum&gt;= left-sum and right-sum&gt;= cross-sum  </span><br><span class="line">        return (right-low, right-high, right-sum)  </span><br><span class="line">    </span><br><span class="line">    else return (cross-low, cross-high, cross-sum)</span><br><span class="line"></span><br><span class="line">FIND-MAX-CROSSING--SUBARRAY(A, low, mid, high)  </span><br><span class="line">    left-sum = -oo  </span><br><span class="line">    sum=O  </span><br><span class="line">    for i = mid downto low  </span><br><span class="line">        sum=sum+A[i]  </span><br><span class="line">        if sum&gt; left-sum  </span><br><span class="line">            left-sum = sum  </span><br><span class="line">            max-left = i  </span><br><span class="line">    right-sum= -oo  </span><br><span class="line">    sum=O  </span><br><span class="line">    for j = mid + 1 to high</span><br><span class="line">        sum=sum + A[j]  </span><br><span class="line">        if sum &gt; right-sum  </span><br><span class="line">            right-sum = sum  </span><br><span class="line">            max-right = j  </span><br><span class="line">    return (max-left, max-right, left-sum + right-sum)</span><br></pre></td></tr></table></figure><h1 id="选择和查找">选择和查找</h1><h2 id="二分搜索">二分搜索</h2><p>普通的二分查找：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_lcro</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找（左闭右开）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 循环，当搜索区间为空时跳出（当 i = j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            i = m + <span class="number">1</span>  <span class="comment"># 此情况说明 target 在区间 [m+1, j) 中</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">            j = m  <span class="comment"># 此情况说明 target 在区间 [i, m) 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> m  <span class="comment"># 找到目标元素，返回其索引</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标元素，返回 -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的二分查找只适用于不重复元素，如果有重复元素，需要寻找到左边界作为插入点，则需要进一步处理 即：当找到等于目标的索引值后，进一步在左侧区间运行二分查找，直到找到最左侧的值 循环完成后， i指向最左边的 <code>target</code> ， j指向首个小于 <code>target</code> 的元素，<strong>因此索引</strong> <code>i</code><strong>就是插入点</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_insertion</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找插入点（存在重复元素）&quot;&quot;&quot;</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">        m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            i = m + <span class="number">1</span>  <span class="comment"># target 在区间 [m+1, j] 中</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">            j = m - <span class="number">1</span>  <span class="comment"># target 在区间 [i, m-1] 中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = m - <span class="number">1</span>  <span class="comment"># 首个小于 target 的元素在区间 [i, m-1] 中</span></span><br><span class="line">    <span class="comment"># 返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找左边界</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_left_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找最左一个 target&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 等价于查找 target 的插入点</span></span><br><span class="line">    i = binary_search_insertion(nums, target)</span><br><span class="line">    <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[i] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到 target ，返回索引 i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>我们可以利用查找最左元素的函数来查找最右元素，具体方法为：<strong>将查找最右一个 <code>target</code> 转化为查找最左一个 <code>target + 1</code></strong>。搜索结束后<code>j</code>指向最右一个 <code>target</code> ，<strong>因此返回</strong><code>j</code> <strong>即可</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_right_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;二分查找最右一个 target&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 转化为查找最左一个 target + 1</span></span><br><span class="line">    i = binary_search_insertion(nums, target + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># j 指向最右一个 target ，i 指向首个大于 target 的元素</span></span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> nums[j] != target:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 找到 target ，返回索引 j</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当数组不包含 <code>target</code> 时，最终 <code>i</code>和<code>j</code></p><p>会分别指向首个大于、小于 <code>target</code> 的元素。</p><p>因此，可以构造一个数组中不存在的元素，用于查找左右边界。</p><ul><li>查找最左一个 <code>target</code> ：可以转化为查找 <code>target - 0.5</code> ，并返回指针<code>i</code></li><li>查找最右一个 <code>target</code> ：可以转化为查找 <code>target + 0.5</code> ，并返回指针<code>j</code></li></ul><h2 id="哈希查找">哈希查找</h2><p>Q:给定一个整数数组 <code>nums</code> 和一个目标元素 <code>target</code> ，请在数组中搜索“和”为 <code>target</code> 的两个元素，并返回它们的数组索引。返回任意一个解即可。</p><p>借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组</p><ol type="1"><li>判断数字 <code>target - nums[i]</code> 是否在哈希表中，若是则直接返回这两个元素的索引。</li><li>将键值对 <code>nums[i]</code> 和索引 <code>i</code> 添加进哈希表。</li></ol><p><img src="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_brute_force.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">two_sum_hash_table</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;方法二：辅助哈希表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 辅助哈希表，空间复杂度 O(n)</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="comment"># 单层循环，时间复杂度 O(n)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> [dic[target - nums[i]], i]</span><br><span class="line">        dic[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>时间复杂度O(n),由于需要维护一个额外的哈希表，因此空间复杂度为O(n)</p><h2 id="随机查找">随机查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT (A, p, r, i)</span><br><span class="line">    if p==r</span><br><span class="line">        return A[p]</span><br><span class="line">    q = RANDOMlZED-PARTITION(A, p, r)</span><br><span class="line">    k = q-p+I</span><br><span class="line">    if i == k // the pivot value is the answer</span><br><span class="line">        return A[q]</span><br><span class="line">    else if i&lt;k</span><br><span class="line">        return RANOOMIZED-SELECT(A, p, q-1, i)</span><br><span class="line">    else return RANOOMIZED-SELECT(A, q+l, r, i-k</span><br></pre></td></tr></table></figure><h1 id="比较排序">比较排序</h1><p><img src="/assets/mit6.006总和笔记/image-20231016192215938.png" /></p><h2 id="决策树">决策树</h2><p>决策树</p><ul><li>任何算法都可以被视为所执行操作的决策树</li><li>内部节点表示二进制比较，分支为 True 或 False</li><li>对于比较算法，决策树是二元的</li><li>叶子代表算法终止，产生算法输出</li><li>根到叶路径表示算法在某些输入上的执行</li><li>比较排序的决策树是完全二叉树，因此高度h&gt;=lg(叶节点数)</li><li>叶结点数是排列数量，即n!</li><li>决策树高度，或者说每条路径的长度就是时间复杂度 <span class="math display">\[n! = \sqrt{2\pi n}\Bigl(\frac{n}{\mathrm{e}}\Bigr)^{n}\Bigl(1 + \frac{1}{12n} + \frac{1}{288n^2} + \cdots\Bigr),\]</span> <span class="math display">\[\ln n! = n\ln n - n +\frac{1}{2}\ln(2\pi n) + \frac{1}{12n} - \frac{1}{360n^3} + \cdots.\]</span> 因此排序下界是nlgn</li></ul><p>对应的，搜索算法的叶节点数为n个，因此下界是lgn</p><h2 id="堆排序">堆排序</h2><p><img src="/assets/mit6.006总和笔记/image-20231017150534371.png" /> <strong>本质上是在序列数据结构（数组）之上实现集合数据结构</strong></p><p>二叉堆：将数组解释为完全二叉树，深度 i 处最多有 2i 个节点，除了 在最大深度，所有节点均左对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left(i) = 2i + 1</span><br><span class="line">right(i) = 2i + 2</span><br><span class="line">parent(i) = mod(i-1/2)</span><br></pre></td></tr></table></figure><p><img src="/assets/mit6.006总和笔记/image-20231014112423645.png" /></p><h3 id="最大堆的生成">最大堆的生成</h3><p>本质上是自底向上建堆，从下到上维护最大堆属性，即从倒数第二层由大索引值向顶部进行最大堆性质的维护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Max_Heapify(A,i)</span><br><span class="line">    l = left(i)</span><br><span class="line">    r = right(i)</span><br><span class="line">    if (l &lt;= heap-size(A) and A[l] &gt; A[i])</span><br><span class="line">        then largest = l </span><br><span class="line">    else largest = i</span><br><span class="line">    if (r &lt;= heap-size(A) and A[r] &gt; A[largest])</span><br><span class="line">        then largest = r</span><br><span class="line">    if largest != i</span><br><span class="line">        then exchange A[i] and A[largest]</span><br><span class="line">    Max_Heapify(A, largest)</span><br><span class="line"></span><br><span class="line">//Converts A[1…n] to a max heap</span><br><span class="line">Build_Max_Heap(A):</span><br><span class="line">    for i=n/2 downto 1</span><br><span class="line">        do Max_Heapify(A, i)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Why start at n/2?</span><br><span class="line">Because elements A[n/2 + 1 … n] are all leaves of the tree</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析">时间复杂度分析</h3><p>每层的时间代价等于节点数乘以节点高度 <img src="https://www.hello-algo.com/chapter_heap/build_heap.assets/heapify_operations_count.png" /> <span class="math display">\[\begin{aligned}T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \dots + 2^{(h-1)}\times1 \newline2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \dots + 2^{h-1} + 2^h \newline\end{aligned}\]</span> <span class="math display">\[\begin{aligned}T(h) &amp; = 2 \frac{1 - 2^h}{1 - 2} - h \newline&amp; = 2^{h+1} - h - 2 \newline&amp; = O(2^h)\end{aligned}\]</span> 综上得到 <span class="math display">\[O(2^h) = O(n)\]</span></p><h3 id="排序策略">排序策略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sorting Strategy:</span><br><span class="line">1. 从未排序数组中构建一个堆</span><br><span class="line">2. 找到最大元素 A[1]并与A[n]交换;</span><br><span class="line">3. n索引处元素出堆，从顶部节点开始维护最大堆属性</span><br><span class="line">4. 顶部节点开始和比它大的最大子节点交换，直到叶节点</span><br></pre></td></tr></table></figure><h3 id="top-k问题">top-k问题</h3><p>基于堆更加高效地解决 Top-K 问题</p><ol type="1"><li><p>初始化一个最小堆</p></li><li><p>前k个元素入堆</p></li><li><p>对之后的元素，如果有比堆顶大的元素，则堆顶出堆，该元素入堆</p></li><li><p>最后得到top-k元素组成的堆</p></li></ol><p>时间复杂度是nlgk，不超过nlgn</p><h2 id="动态规划和二分搜索树">动态规划和二分搜索树</h2><p>实例——机场的动态规划：</p><ol type="1"><li>机场维护一个跑道队列</li><li>未来的着陆预定登记到队列</li><li>一架飞机着陆后就出队</li><li>有新的请求且需要着陆时间t时，如果k时间内没有其他需求，则需求t时间的请求入队(k可以实时改变)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init: R = [ ]</span><br><span class="line">req(t): if t &lt; now: return &quot;error&quot;</span><br><span class="line">for i in range (len(R)):</span><br><span class="line">    if abs(t-R[i]) &lt; k: return &quot;error&quot;</span><br><span class="line">R.append(t)</span><br><span class="line">R = sorted(R)</span><br><span class="line">land: t = R[0]</span><br><span class="line">if (t != now) return error</span><br><span class="line">R = R[1: ] (drop R[0] from R)</span><br></pre></td></tr></table></figure><p>Goal: Run this system efficiently in O(lg n) time 常见数据结构运行时间分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">排序链表</span><br><span class="line">- 添加元素并排序需要Θ(nlgn)时间。但是,可以找到插入新时间/航班的位置而不需要添加并排序,但是插入需Θ(n)时间。一旦找到插入位置,k分钟检查可以在O(1)时间内完成。</span><br><span class="line"></span><br><span class="line">排序数组</span><br><span class="line">- 可以使用二分搜索在O(lg n)时间内找到插入位置。使用二分搜索,找到插入索引i,即大于或等于t的最小元素。然后将R[i]和R[i-1]与t进行比较。然而,实际插入需要移位元素,需Θ(n)时间。</span><br><span class="line"></span><br><span class="line">未排序链表/数组</span><br><span class="line">- k分钟检查需要O(n)时间。</span><br><span class="line"></span><br><span class="line">最小堆</span><br><span class="line">- 可以在O(lg n)时间内插入。但是,k分钟检查仍需O(n)时间。</span><br><span class="line"></span><br><span class="line">字典或Python集合</span><br><span class="line">- 插入需要O(1)时间。k分钟检查需要Ω(n)时间</span><br></pre></td></tr></table></figure><p>BST的定义： 每个节点都有一个key,左节点的key小于等于父节点，右节点的key大于等于父节点</p><p>所有操作都是O(h)即O(lgn)</p><p>动态规划中需要找到比一个值大的值中的最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">next-larger(x) # x is a node in the BST</span><br><span class="line">if right child not NIL, return minimum(right)</span><br><span class="line">else y = parent(x)</span><br><span class="line">while y not NIL and x = right(y)</span><br><span class="line">    x = y; y = parent(y)</span><br><span class="line">return(y);</span><br></pre></td></tr></table></figure><p><code>子问题</code>：如何计算小于等于时间t内着陆的飞机数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 遍历树找到目标时间</span><br><span class="line">2. 从左子树开始遍历，把左侧节点的数量加一则是当前节点的排名，排名则是问题的答案</span><br></pre></td></tr></table></figure><p><strong>搜索二叉树可以使用set或者sequence两种数据结构</strong></p><p>set:遍历顺序由key的顺序决定</p><p>sequence:数组索引就是遍历顺序</p><p><img src="/assets/mit6.006总和笔记/image-20231017101953076.png" /> <strong>查找第i大的节点(sequence)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 查找当前节点的排序rank</span><br><span class="line">2. 如果rank &lt; i在右子树寻找排名i-rank的节点</span><br><span class="line">3. 如果rank &gt; i在左子树递归寻找</span><br><span class="line">4. 如果等于，则找到了目标</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>也可以对每个节点维护一个size属性，用左子树的size确认排名</li><li>搜索二叉树插入节点很容易实现，但删除节点，如果是有子树的节点，就需要把左子树的最大值或者右子树的最小值与其交换后删除</li><li>二叉树的中序遍历正好就是一个排序数组</li></ul><h2 id="平衡二叉搜索树avl">平衡二叉搜索树AVL</h2><p><img src="/assets/mit6.006总和笔记/image-20231017102411122.png" /> • 在动态操作下保持 O(log n) 高度的二叉树称为平衡二叉树 – 有许多平衡方案（红黑树、八字树、2-3 树……） – 第一个提出的平衡方案是 AVL 树 <strong>树的旋转</strong> <img src="/assets/mit6.006总和笔记/image-20231017102819736.png" /> • 定理：O(n) 次旋转可以将二叉树转换为具有相同遍历顺序的任何其他二叉树。 • 证明：按照遍历顺序重复执行最后可能的右旋转； 结果树是 规范链。 每次旋转都会使最后一个节点的深度增加 1。 最后一个节点的深度最多为 n − 1，因此最多执行 n − 1 次旋转，就可以将输入树旋转为目标树。</p><p><strong>平衡</strong> AVL 树保持高度平衡（也称为 AVL 属性）</p><ul><li>如果一个节点的左右子树的高度最多相差 1，则该节点是高度平衡的</li><li>节点的倾斜为其右子树的高度减去左子树的高度</li><li>如果节点的倾斜度为 −1、0 或 1，则该节点是高度平衡的</li></ul><p><strong>平衡的维持</strong> 每次对树的修改最多导致左右子树高度相差2，如果相差2，一次旋转就可以重新平衡树 <img src="/assets/mit6.006总和笔记/image-20231017105216748.png" /> <img src="/assets/mit6.006总和笔记/image-20231018222936126.png" /> <img src="/assets/mit6.006总和笔记/image-20231018223015529.png" /> <img src="/assets/mit6.006总和笔记/image-20231018223211763.png" /></p><p>AVL 树通过在每个节点存储额外的高度信息,并在每个节点做平衡操作来保持平衡。其平衡调整原则如下:</p><ol type="1"><li>如果左右子树高度相差大于 1,进行旋转操作调整;</li><li>进行左旋转的情况:左子树高度 - 右子树高度 &gt; 1,即左子树比右子树高(左重),需要右旋;</li><li>进行右旋转的情况:右子树高度 - 左子树高度 &gt; 1,即右子树比左子树高(右重),需要左旋;</li><li>旋转后更新节点的高度信息。</li><li>每进行一次插入或删除节点后,从该节点开始向上遍历,如果发现任一节点的左右子树高度差大于 1,则在该节点进行旋转操作,调整树的平衡。 由于树的高度最高为lgn，所以logn时间内就可以完成增删节点的操作 <strong>高度属性的维护</strong> 必须确保每个节点的height属性可以通过对height属性的一个O(1)操作完成，这样维护height就不会改变动态操作的复杂度</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">balanceFactor</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>旋转的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rightRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;left;</span><br><span class="line">    TreeNode *grandChild = child-&gt;right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;right;</span><br><span class="line">    TreeNode *grandChild = child-&gt;left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一共有四种需要平衡的情况 <img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png" /></p><table><thead><tr class="header"><th>失衡节点的平衡因子</th><th>子节点的平衡因子</th><th>应采用的旋转方法</th></tr></thead><tbody><tr class="odd"><td>&gt;1（即左偏树）</td><td>&gt;=0</td><td>右旋</td></tr><tr class="even"><td>&gt;1（即左偏树）</td><td>&lt;0</td><td>先左旋后右旋</td></tr><tr class="odd"><td>&lt;-1（即右偏树）</td><td>&lt;=0</td><td>左旋</td></tr><tr class="even"><td>&lt;-1（即右偏树）</td><td>&gt;0</td><td>先右旋后左旋</td></tr></tbody></table><p><strong>数据结构的选取</strong> • Set AVL trees achieve O(lg n) time for all set operations, except O(n log n) time for build and O(n) time for iter • Sequence AVL trees achieve O(lg n) time for all sequence operations, except O(n) time for build and iter <strong>插入和删除</strong> 此外，插入节点和删除节点在搜索二叉树基础上，需要分别自底向上和自上向下进行恢复平衡的操作</p><h1 id="哈希">哈希</h1><p>哈希有可能产生碰撞，需要特定处理或者数据结构，检索元素时间最后会由负载因数(n/m)决定 <img src="/assets/mit6.006总和笔记/image-20231016200400451.png" /> 一般有<strong>链表</strong>和<strong>开放寻址</strong>两种方式解决碰撞</p><ul><li>链表 期望的查找时间，θ(1+α)，1是哈希函数用时，阿尔法则是查找具体链表需要的时间（链表的期望长度）</li><li>开放寻址</li></ul><h2 id="哈希函数">哈希函数</h2><p>常见的哈希函数</p><ol type="1"><li><code>h(k) = k mod m（m是素数，慢)</code></li><li><code>h(k) = [(a · k) mod 2w] &gt;&gt; (w − r)</code>(where a is random, k is w bits, and m = 2r.且需要a处于2<sup>(w-1)和2</sup>w之间，且不靠近端点)</li><li><code>h(k) = [(ak + b) mod p]</code> mod m where a and b are random ∈ {0, 1, . . . p − 1}, and p is a large prime (&gt; |U|).(了解即可,6.046内容)</li></ol><h2 id="哈希的优化">哈希的优化</h2><p><strong>rehash</strong></p><p>Θ(n + m) time = Θ(n) if m = Θ(n)</p><p><strong>shrink</strong></p><p>当n到达m/4时，收缩到n/2</p><h2 id="利用哈希的字符串匹配算法">利用哈希的字符串匹配算法</h2><h3 id="karp-rabin-algorithm">Karp-Rabin Algorithm</h3><p>Rabin-Karp算法是一种字符串匹配算法,利用滚动哈希技术实现。其基本思想是:</p><ol type="1"><li>对文本和模式分别计算哈希值;</li><li>滚动文本,每次比较文本窗口和模式的哈希值;</li><li>如果哈希值相同,则进行字符匹配确认;</li><li>如果不相同,则可以直接跳到下一位置。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• Compare h(s) == h(t[i : i + len(s)])</span><br><span class="line">• If hash values match, likely so do strings</span><br><span class="line">– can check s == t[i : i + len(s)] to be sure ∼ cost O(|s|)</span><br><span class="line">– if yes, found match — done</span><br><span class="line">– if no, happened with probability &lt; 1/|s|</span><br><span class="line">= expected cost is O(1) per i.</span><br><span class="line">⇒</span><br><span class="line">• need suitable hash function.</span><br><span class="line">• expected time = O(|s| + |t| · cost(h)).</span><br><span class="line">– naively h(x) costs |x|</span><br><span class="line">– we’ll achieve O(1)!</span><br><span class="line">– idea: t[i : i + len(s)] ≈ t[i + 1 : i + 1 + len(s)]</span><br></pre></td></tr></table></figure><p><strong>rolling hash</strong></p><p>Rolling Hash ADT</p><p>Maintain string x subject to</p><ul><li>r(): reasonable hash function h(x) on string x</li><li>r.append(c): add letter c to end of string x</li><li>r.skip(c): remove front letter from string x, assuming it is</li></ul><p>伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for c in s: rs.append(c)</span><br><span class="line">for c in t[:len(s)]: rt.append(c)</span><br><span class="line">if rs() == rt(): ...</span><br><span class="line">//This first block of code is O( s )</span><br><span class="line">for i in range(len(s), len(t)):</span><br><span class="line">rt.skip(t[i-len(s)])</span><br><span class="line">rt.append(t[i])</span><br><span class="line">if rs() == rt(): ...</span><br><span class="line">//The second block of code is O(|t|) + O(# matches − |s|) to verify.</span><br></pre></td></tr></table></figure><p><img src="/assets/mit6.006总和笔记/image-20231019194313076.png" /></p><h2 id="开放寻址">开放寻址</h2><p>哈希时需要引入哈希次数i，持续哈希直到找到空槽 <strong>插入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in xrange(m):</span><br><span class="line">    if T [h(k, i)] is None: #empty slot</span><br><span class="line">        T [h(k, i)] = (k, v) #store item</span><br><span class="line">        return</span><br><span class="line">raise ‘full&#x27;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in xrange(m):</span><br><span class="line">    if T [h(k, i)] is None: #empty slot?</span><br><span class="line">        return None #end of “chain”</span><br><span class="line">    elif T [h(k, i)][∅] == k: #matching key</span><br><span class="line">        return T [h(k, i)] #return item</span><br><span class="line">    return None ˙ #exhausted table</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>由于防止查找操作误判，需要特定的删除标志，把待删除函数设置为已删除，让插入视为None,查找视为存在 <img src="/assets/mit6.006总和笔记/image-20231019195835085.png" /></p><h3 id="优化">优化</h3><p>问题：可能出现<em>簇</em>现象，某些元素连续聚集于一处，导致查找操作耗时较高</p><p>eg.线性哈希h(k, i) = (h′(k) +i)</p><p>更好的解决方案：<code>h(k, i) =(h1(k) +i·h2(k)) mod m</code> where h1(k) and h2(k) are two ordinary hash func-tions.</p><h3 id="性能">性能</h3><p>第一次查找成功的概率p=m-n/m</p><p>第二次概率为m-n/m-1大于p</p><p>由此类推，成功概率至少为p</p><p>1/p=1/1-α</p><p>所以期望时间为O(1/(1 − α))</p><h3 id="与链表的比较">与链表的比较</h3><p>优点：更有效地利用空间，不需要储存指针</p><p>缺点：链表对哈希函数和负载值的要求更低，开放寻址高负载时性能大降，且无法有大于一的α</p><h2 id="安全领域的哈希">安全领域的哈希</h2><p>哈希在加密上应用广泛，例如：</p><ol type="1"><li>加密密码，存储密码的哈希码来防止泄露的危害</li><li>文件完整性校验，利用哈希来给出文件几乎唯一的哈希值来防止对文件的暗中篡改，也用于git之类的版本控制软件</li><li>数字签名，用私钥加密数据，其他人可以用公钥检验，来确保发信者身份正规 <a href="https://thinklive1.github.io/2023/10/12/sysadmin/">详细可见Sysadmin decal笔记</a></li></ol><h1 id="没涉及的其他排序">6.006没涉及的其他排序</h1><h2 id="冒泡排序">冒泡排序</h2><p>「冒泡排序 bubble sort」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。 设数组的长度为n，冒泡排序的步骤</p><ol type="1"><li>首先，对 <code>n</code> 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>，</li><li>接下来，对剩余<code>n-1</code>个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li><li>以此类推，经过<code>n-</code>轮“冒泡”后，<strong>前</strong><code>n-1</code> <strong>大的元素都被交换至正确位置</strong>。</li><li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li></ol><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_sort_overview.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>性能和特性</strong>： - 最差和平均都是O(n^2)，但比较适合数组有一定秩序性的时候 - 原地稳定排序</p><h2 id="快速排序">快速排序</h2><p>「快速排序 quick sort」是一种基于分治策略的排序算法，核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</p><ol type="1"><li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li><li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li><li>循环执行步骤 <code>2.</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ol><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PARTITION(A, p, r)</span><br><span class="line"> i =RANOOM(p, r)</span><br><span class="line"> exchange A[r] with A[i]</span><br><span class="line"> x = A[r]</span><br><span class="line"> i = p —1</span><br><span class="line"> for j=p to r-1</span><br><span class="line">  if A[j]&lt;=x</span><br><span class="line">  i = i + 1</span><br><span class="line">  exchange A[i] with A[j]</span><br><span class="line"> exchange A[i+ l] with A[r]</span><br><span class="line"> return i + 1</span><br><span class="line"></span><br><span class="line">QUICKSORT(A, p, r)</span><br><span class="line">if p&lt;r</span><br><span class="line"> q = PARTITION(A, p, r)</span><br><span class="line"> QUICKSORT(A, p, q-1)</span><br><span class="line"> QUICKSORT(A, q+ 1, r)</span><br></pre></td></tr></table></figure><p>python实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;哨兵划分&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 以 nums[left] 作为基准数</span></span><br><span class="line">    i, j = left, right</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt;= nums[left]:</span><br><span class="line">            j -= <span class="number">1</span>  <span class="comment"># 从右向左找首个小于基准数的元素</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[left]:</span><br><span class="line">            i += <span class="number">1</span>  <span class="comment"># 从左向右找首个大于基准数的元素</span></span><br><span class="line">        <span class="comment"># 元素交换</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    <span class="comment"># 将基准数交换至两子数组的分界线</span></span><br><span class="line">    nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i  <span class="comment"># 返回基准数的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 哨兵划分</span></span><br><span class="line">    pivot = self.partition(nums, left, right)</span><br><span class="line">    <span class="comment"># 递归左子数组、右子数组</span></span><br><span class="line">    self.quick_sort(nums, left, pivot - <span class="number">1</span>)</span><br><span class="line">    self.quick_sort(nums, pivot + <span class="number">1</span>, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化： - 对主元选取可以用随机数或者取样一些元素选取中位数来实现稳定的nlgn性能 - 对相等元素较多的数组，可以进行三路快排，只需要递归排序不等于主元的两路 - 尾递归优化,在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过n/2 ，因此这种方法能确保递归深度不超过lgn ，从而将最差空间复杂度优化至lgn。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">self, nums: <span class="built_in">list</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速排序（尾递归优化）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 子数组长度为 1 时终止</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 哨兵划分操作</span></span><br><span class="line">        pivot = self.partition(nums, left, right)</span><br><span class="line">        <span class="comment"># 对两个子数组中较短的那个执行快排</span></span><br><span class="line">        <span class="keyword">if</span> pivot - left &lt; right - pivot:</span><br><span class="line">            self.quick_sort(nums, left, pivot - <span class="number">1</span>)  <span class="comment"># 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>  <span class="comment"># 剩余未排序区间为 [pivot + 1, right]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.quick_sort(nums, pivot + <span class="number">1</span>, right)  <span class="comment"># 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>  <span class="comment"># 剩余未排序区间为 [left, pivot - 1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆排序-1">堆排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span>, i: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;堆的长度为 n ，从节点 i 开始，从顶至底堆化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">        ma = i</span><br><span class="line">        <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> nums[l] &gt; nums[ma]:</span><br><span class="line">            ma = l</span><br><span class="line">        <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> nums[r] &gt; nums[ma]:</span><br><span class="line">            ma = r</span><br><span class="line">        <span class="comment"># 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> ma == i:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 交换两节点</span></span><br><span class="line">        nums[i], nums[ma] = nums[ma], nums[i]</span><br><span class="line">        <span class="comment"># 循环向下堆化</span></span><br><span class="line">        i = ma</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;堆排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 建堆操作：堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift_down(nums, <span class="built_in">len</span>(nums), i)</span><br><span class="line">    <span class="comment"># 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 交换根节点与最右叶节点（即交换首元素与尾元素）</span></span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 以根节点为起点，从顶至底进行堆化</span></span><br><span class="line">        sift_down(nums, i, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>性质：nlgn,原地非稳定</p><h2 id="计数排序">计数排序</h2><ol type="1"><li>遍历数组，找出数组中的最大数字，记为 ，然后创建一个长度为- 的辅助数组 <code>counter</code> 。</li><li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加即可。</li><li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经被排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字的出现次数，将它们按从小到大的顺序填入 <code>nums</code> 即可。 <img src="https://www.hello-algo.com/chapter_sorting/counting_sort.assets/counting_sort_overview.png" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">COUNTlNG-SORT(A, B, k)</span><br><span class="line">let C[O .. k] be a new array</span><br><span class="line">for i=O to k</span><br><span class="line"> C[i] = O</span><br><span class="line">for j = 1 to A. length</span><br><span class="line"> C[A[j]]=C[A[j]J+ 1</span><br><span class="line">//C[i] now contains the number of elements equal to i.</span><br><span class="line">for i=1 to k</span><br><span class="line"> C[i]=C[i]+C[i-1]</span><br><span class="line">//C[i] now contains the number of elements less than or equal to i.</span><br><span class="line">for j = A. length downto 1</span><br><span class="line"> B[C[A[j]J]=A[j]</span><br><span class="line"> C[A[j]]=C[A[j]]-1</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计数排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 完整实现，可排序对象，并且是稳定排序</span></span><br><span class="line">    <span class="comment"># 1. 统计数组最大元素 m</span></span><br><span class="line">    m = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="comment"># 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment"># counter[num] 代表 num 的出现次数</span></span><br><span class="line">    counter = [<span class="number">0</span>] * (m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        counter[num] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span><br><span class="line">    <span class="comment"># 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        counter[i + <span class="number">1</span>] += counter[i]</span><br><span class="line">    <span class="comment"># 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span><br><span class="line">    <span class="comment"># 初始化数组 res 用于记录结果</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        num = nums[i]</span><br><span class="line">        res[counter[num] - <span class="number">1</span>] = num  <span class="comment"># 将 num 放置到对应索引处</span></span><br><span class="line">        counter[num] -= <span class="number">1</span>  <span class="comment"># 令前缀和自减 1 ，得到下次放置 num 的索引</span></span><br><span class="line">    <span class="comment"># 使用结果数组 res 覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特性</strong>：虽然是线性时间O(n+m)，实际上时间复杂收到输入数据大小范围的影响,不能直接支持负数，需要将负数数组转换成非负数的排序,非原地稳定排序，空间也是O(n+m)</p><h2 id="基数排序">基数排序</h2><p>假设数字的最低位是第1位，最高位是第8位，基数排序的流程:</p><ol type="1"><li>初始化位数`k=1</li><li>对学号的第<code>k</code>位执行“计数排序”。完成后，数据会根据第<code>k</code> 位从小到大排序。</li><li>将<code>k</code>增加 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li></ol><p><img src="https://www.hello-algo.com/chapter_sorting/radix_sort.assets/radix_sort_overview.png" /> 获取第k位数的方法： <span class="math display">\[x_k = \lfloor\frac{x}{d^{k-1}}\rfloor \bmod d\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">digit</span>(<span class="params">num: <span class="built_in">int</span>, exp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取元素 num 的第 k 位，其中 exp = 10^(k-1)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num // exp) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort_digit</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], exp: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计数排序（根据 nums 第 k 位排序）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 十进制的位范围为 0~9 ，因此需要长度为 10 的桶</span></span><br><span class="line">    counter = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        d = digit(nums[i], exp)  <span class="comment"># 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d] += <span class="number">1</span>  <span class="comment"># 统计数字 d 的出现次数</span></span><br><span class="line">    <span class="comment"># 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        counter[i] += counter[i - <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    res = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        d = digit(nums[i], exp)</span><br><span class="line">        j = counter[d] - <span class="number">1</span>  <span class="comment"># 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i]  <span class="comment"># 将当前元素填入索引 j</span></span><br><span class="line">        counter[d] -= <span class="number">1</span>  <span class="comment"># 将 d 的数量减 1</span></span><br><span class="line">    <span class="comment"># 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nums[i] = res[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基数排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    m = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="comment"># 按照从低位到高位的顺序遍历</span></span><br><span class="line">    exp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> exp &lt;= m:</span><br><span class="line">        <span class="comment"># 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment"># k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment"># k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment"># 即 exp = 10^(k-1)</span></span><br><span class="line">        counting_sort_digit(nums, exp)</span><br><span class="line">        exp *= <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特性： - 时间复杂度O(k(n+d))，k是位数，d是进制,d会决定计数排序需要的数组长度，k决定进行几次计数排序 - 空间复杂度O(n+d),稳定排序(从低到高排序)</p><h2 id="桶排序">桶排序</h2><ol type="1"><li>初始化 <code>k</code> 个桶，将<code>n</code>个元素分配到<code>k</code>个桶中</li><li>对每个桶分别执行排序</li><li>按照桶的从小到大的顺序，合并结果 <img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/bucket_sort_overview.png" /></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">float</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;桶排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span><br><span class="line">    k = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    <span class="comment"># 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">        i = <span class="built_in">int</span>(num * k)</span><br><span class="line">        <span class="comment"># 将 num 添加进桶 i</span></span><br><span class="line">        buckets[i].append(num)</span><br><span class="line">    <span class="comment"># 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="comment"># 使用内置排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        bucket.sort()</span><br><span class="line">    <span class="comment"># 3. 遍历桶合并结果</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">            nums[i] = num</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特性：</p><ol type="1"><li><strong>时间复杂度</strong><code>O(n+k)</code> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为<code>n/k</code> 。假设排序单个桶使用<code>(n/k)*lg(n/k)</code>时间，则排序所有桶使用<code>n*lg(n/k)</code>时间。<strong>当桶数量</strong><code>k</code><strong>比较大时，时间复杂度则趋向于<code>O(n)</code></strong> 。合并结果时需要遍历所有桶和元素，花费<code>O(n+k)</code>时间。在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用<code>O(n^2)</code>时间。</li><li><strong>空间复杂度</strong>O(n+k)</li><li><strong>非原地排序</strong>：需要借助<code>k</code>个桶和总共<code>n</code> 个元素的额外空间。</li><li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li></ol><p>改良： 平均分配可以对较大的桶递归 <img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/scatter_in_buckets_recursively.png" /> 或者根据概率正态分布划分桶</p><h2 id="总结">总结</h2><p><img src="https://www.hello-algo.com/chapter_sorting/summary.assets/sorting_algorithms_comparison.png" /></p><h1 id="数值运算">数值运算</h1><h2 id="catalan-numbers">Catalan numbers</h2><p>Set P of balanced parentheses strings(平衡括号字符串) are recursively defined as • λ ∈ P (λ is empty string) • If α, β ∈ P , then (α)β ∈ P Cn: number of balanced parentheses strings with exactly n pairs of parentheses 也等于n+1个叶节点构成满二叉树的形状个数 <img src="/assets/mit6.006总和笔记/image-20231020131123959.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印前 n 个卡特兰数</span></span><br><span class="line">ans, n = <span class="number">1</span>, <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br></pre></td></tr></table></figure><h2 id="newtons-method牛顿迭代法">Newton’s Method牛顿迭代法</h2><p><span class="math display">\[x_{i+1} = x_{i} - \frac{f(x_{i})}{f&#39;(x_{i})}\]</span></p><h3 id="高精度乘法">高精度乘法</h3><p>Multiplying two n-digit numbers (radix r = 2, 10) 0 ≤ x, y &lt; rn x1 = high half;x0 = low half <span class="math display">\[x = x_{1} \cdot r^{\frac{n}{2}} + x_{0}\]</span> <span class="math display">\[y = y_{1} \cdot r^{\frac{n}{2}} + y_{0}\]</span> <span class="math display">\[z = x · y = x_1y_1 · r^n + (x_0 · y_1 + x_1 · y_0)r^{n/2} + x_0 · y_0\]</span></p><p>θ(n^2) time</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Schönhage-Strassen算法是一种快速整数乘法算法,由Arnold Schönhage和Volker Strassen在1971年提出。它比传统的乘法算法要快得多,其时间复杂度为O(n log n log log n)。</span><br><span class="line">Schönhage-Strassen算法的基本思想是:</span><br><span class="line">1. 将两个n位数a和b拆分成大约n/2位数的块。例如,1234 = 12, 34;   2345 = 23, 45。</span><br><span class="line">2. 计算所有块之间的乘积,得到4个结果:a1b1, a1b2, a2b1, a2b2。这可以用递归方式计算。</span><br><span class="line">3. 根据分块的位数 Shift 加上进位,得到a1b1*(10^n), a1b2*10^n/2, a2b1*10^n/2, a2b2。</span><br><span class="line">4. 最后将4个结果相加,得到a*b。</span><br><span class="line">5. 例如,计算12345 * 6789:</span><br><span class="line">6. 分块:12, 34,   67, 892. 计算块间乘积:12 * 67 = 804,   12 * 89 = 1068, 34 * 67 = 2298, 34 * 89 = 3026 </span><br><span class="line">7. Shift并加进位:804 * 10000, 1068 * 5000, 2298 * 5000, 30264. </span><br><span class="line">8. 相加:8040000 + 5340000 + 11490000 + 15130000 = 123456791这种算法通过分块和递归减少每一步的计算量,在计算两个大整数的乘积时有很高的效率,尤其适用于超长整数的相乘。它在一定程度上简化了超长整数运算,是数论和计算机科学中很有价值的一种算法。</span><br></pre></td></tr></table></figure><p><strong>优化</strong> <img src="/assets/mit6.006总和笔记/image-20231020135416200.png" /> <strong>误差分析</strong> <img src="/assets/mit6.006总和笔记/image-20231020140715299.png" /> <span class="math display">\[ε_{n+1} =  \frac{ε_n^2}{2*(1+ε_n)}\]</span></p><h3 id="高精度除法">高精度除法</h3><p>a/b -&gt; 1/b*a - &gt; mod(R/b) // R是一个容易除的较大值</p><p><img src="/assets/mit6.006总和笔记/image-20231020141331913.png" /> <img src="/assets/mit6.006总和笔记/image-20231020141401286.png" /> 除法的复杂度等于乘法 To understand this, assume that the complexity of multiplication is Θ(nα) for n- digit numbers, with α ≥ 1. Division requires multiplication of different-sized numbers at each iteration. Initially the numbers are small, and then they grow to d digits.</p><p>We apply a first level of Newton’s method to solve f (x) = x2 − a. Each iteration of this first level1 requires a division. If we set the precision to d digits right from the beginning, then convergence at the first level will require lg d iterations. This means the complexity of computing a square root will be Θ(dα lg d) if the complexity of multiplication is Θ(dα), given that we have shown that the complexity of division is the same as the complexity of multiplication. However, we can do better, if we recognize that the number of digits of precision we need at beginning of the first level of Newton’s method starts out small and then grows. If the complexity of a d-digit division is Θ(dα), then a similar summation to the one above tells us that the complexity of computing square roots is Θ(dα)</p><h1 id="图论">图论</h1><h2 id="概念">概念</h2><p>图：for each vertex u ∈ V, Adj[u] stores u’s neighbors, i.e., {v ∈ V | (u, v) ∈ E}. Adj 的大小为 θ(|V |)，而每个 Adj(u) 的大小为 θ(deg(u))</p><p>表示分为邻接表和邻接矩阵 <img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png" /> <img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png" /> <img src="/assets/mit6.006总和笔记/QQ图片20231121160100.png" /></p><h3 id="路径">路径</h3><ul><li>路径是顶点序列p=(v1,v2,...,vk),其中(vi,vi+1)∈E, 1≤i&lt;k<br /></li><li>如果路径上没有重复顶点,则为简单路径<br /></li><li>路径p的长度为路径上的边数<br /></li><li>u到v的距离δ(u,v)为从u到v的最短路径长度</li></ul><p><strong>路径问题</strong>:</p><ul><li>图中的多种路径问题:<br />  - 单源可达性:s是否可达t<br />  - 单源最短路径:返回δ(s,t)和s到t的最短路径<br />  - 单源最短路径:返回从s到所有v的δ(s,v)和最短路径树<br /></li><li>如何对每个顶点返回从源s的最短路径?<br /></li><li>返回所有路径需Ω(|V|^2)时间<br /></li><li>只存储每个v的父节点P(v),s的父节点为空<br /></li><li>父节点构成包含从s可达所有最短路径的最短路径树,大小为O(|V|)</li></ul><h2 id="bst">BST</h2><p><strong>应用</strong></p><ul><li>网络抓取（Google 如何查找页面）</li><li>社交网络（Facebook 好友查找器）</li><li>网络广播路由</li><li>垃圾收集</li><li>模型检查（有限状态机）</li><li>检查数学猜想</li><li>解决谜题和游戏</li></ul><p>如何计算图中所有顶点v的δ(s,v)和P(v)?</p><ul><li>使用集合数据结构来存储每个顶点v对应的δ(s,v)距离和P(v)父节点。<br /></li><li>如果从起点s到v没有路径,则不存储在P中,δ(s,v)设为无穷大。</li></ul><p><strong>基本思路</strong>: - 按照与起点s的距离依次增大的顺序探索图的节点。</p><p><strong>目标</strong>:<br />- 计算所有与起点s距离为i的顶点的集合Li。结论:<br />- Li中的任意顶点v必须与L_{i-1}中的某个顶点u相连。<br />- 不会有任何距离起点距离为j(j&lt;i)的顶点出现在Li中。</p><p><strong>循环不变量:</strong><br />- 在计算到Li之前,δ(s,v)和P(v)对于所有Lj(j&lt;i)中的顶点v都已正确赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BFS (V,Adj,s): See CLRS for queue-based implementation</span><br><span class="line">    level = &#123; s: 0 &#125;</span><br><span class="line">    parent = &#123;s : None &#125;</span><br><span class="line">    i = 1</span><br><span class="line">    frontier = [s] # previous level, i − 1</span><br><span class="line">    while frontier:</span><br><span class="line">        next = [ ] # next level, i</span><br><span class="line">        for u in frontier:</span><br><span class="line">            for v in Adj [u]:</span><br><span class="line">                if v not in level: # not yet seen</span><br><span class="line">                    level[v] = i # = level[u] + 1</span><br><span class="line">                    parent[v] = u</span><br><span class="line">                    next.append(v)</span><br><span class="line">        frontier = next</span><br><span class="line">        i + =1</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">graph_bfs</span>(<span class="params">graph: GraphAdjList, start_vet: Vertex</span>) -&gt; <span class="built_in">list</span>[Vertex]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;广度优先遍历 BFS&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">    <span class="comment"># 顶点遍历序列</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    visited = <span class="built_in">set</span>[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 队列用于实现 BFS</span></span><br><span class="line">    que = deque[Vertex]([start_vet])</span><br><span class="line">    <span class="comment"># 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(que) &gt; <span class="number">0</span>:</span><br><span class="line">        vet = que.popleft()  <span class="comment"># 队首顶点出队</span></span><br><span class="line">        res.append(vet)  <span class="comment"># 记录访问顶点</span></span><br><span class="line">        <span class="comment"># 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> adj_vet <span class="keyword">in</span> graph.adj_list[vet]:</span><br><span class="line">            <span class="keyword">if</span> adj_vet <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 跳过已被访问过的顶点</span></span><br><span class="line">            que.append(adj_vet)  <span class="comment"># 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adj_vet)  <span class="comment"># 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment"># 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本情况(i=1):</p><ul><li>L0={s},δ(s,s)=0,P(s)=None归纳步骤: (L表示level)</li><li>计算Li时:<br />  - 对Li-1中的每个顶点u:<br />    - 对于任一不在Lj(j&lt;i)中的相邻顶点v:<br />      - 将v加入Li,设置δ(s,v)=i,P(v)=u重复计算:</li><li>按i递增顺序重复计算Li,直到Li为空集<br /></li><li>对任一不可达顶点v,设置δ(s,v)=∞</li><li>因此通过归纳证明,广度优先搜索可以正确计算所有δ(s,v)和P(v)。</li></ul><p><strong>时间复杂度分析</strong>:</p><ul><li>用支持快速遍历和插入的数据结构存储Li<br /></li><li>通过检查P来判断一个顶点是否在Lj(j&lt;i)中<br /></li><li>用支持O(1)操作的字典结构存储δ和P<br /></li><li>每个顶点u最多加入一个Li,并对每个邻点v做O(1)操作<br /></li><li>以上这些部分是O(|E|)</li><li>最后处理不可达顶点需O(|V|)<br /></li><li>所以总时间复杂度是O(|V|+|E|)</li></ul><p><span class="math display">\[level[v] = \begin{cases}           level &amp; \text{if } v \text{ assigned level} \\\\           \infty &amp; \text{else (no path)}\end{cases}\]</span></p><h2 id="dst">DST</h2><p>基本思想:</p><ul><li>递归访问出边邻接顶点,但不重复访问已访问过的顶点。<br /></li><li>尽可能深入探索路径,直到无法继续,然后回溯找到未探索的路径。 执行步骤:</li><li>初始化P(s)=None,执行visit(s)过程:<br />  - 对每个未在P中出现的邻接顶点v:设P(v)=u并递归调用visit(v)<br />  - 标记访问完顶点u(用于拓扑排序) 不用返回distance,因此时间是O(E)</li></ul><p>全BFS和全DFS:</p><ul><li>目标是探索整个图,而不仅仅是一个源点可达的部分。<br /></li><li>重复在任一未访问顶点s上运行BFS或DFS,直到所有顶点都被访问。<br /></li><li>时间复杂度都是O(|V| + |E|)</li></ul><p>连通分量:</p><ul><li>将无向图的顶点集分割成子集Vi,使每个Vi内部连通,Vi之间无边。连通性算法:<br /></li><li>任意单源可达性算法A都可以求解连通分量。<br /></li><li>重复运行全A,每次A访问的顶点集就是一个连通分量。</li></ul><p>连通性算法:</p><ul><li>任意单源可达性算法A都可以求解连通分量。<br /></li><li>重复运行全A,每次A访问的顶点集就是一个连通分量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parent = &#123;s: None&#125;</span><br><span class="line">DFS-visit (V, Adj, s):</span><br><span class="line">    for v in Adj [s]:</span><br><span class="line">        if v not in parent:</span><br><span class="line">            parent [v] = s</span><br><span class="line">            DFS-visit (V, Adj, v)</span><br><span class="line">DFS (V, Adj):</span><br><span class="line">    parent = &#123; &#125;</span><br><span class="line">    for s in V:</span><br><span class="line">        if s not in parent:</span><br><span class="line">            parent [s] = None</span><br><span class="line">            DFS-visit (V, Adj, s)</span><br></pre></td></tr></table></figure><p>O(V + E)</p><p><strong>总结</strong>：</p><ul><li>Single-Source Shortest Paths with BFS in O(|V | + |E|) time (return distance per vertex)</li><li>Single-Source Reachability with BFS or DFS in O(|E|) time (return only reachable vertices)</li><li>Connected components with Full-BFS or Full-DFS in O(|V | + |E|) time</li><li>Topological Sort of a DAG with Full-DFS in O(|V | + |E|) time</li></ul><h3 id="拓扑排序算法">拓扑排序算法</h3><ul><li>DFS访问每个顶点v时,记录DFS结束顺序finish[v]<br /></li><li>按finish[v]递减顺序输出顶点具体步骤:</li></ul><ol type="1"><li>通过DFS遍历图<br /></li><li>将顶点按finish[v]时间降序插入order<br /></li><li>将order反转 <strong>正确性证明</strong>:<br />对任意边(u,v)有u在v之前</li></ol><ul><li>如果u先访问:<br />  - 在访问u结束前会访问v(直接或间接)<br />  - 因此v结束时间在u之前<br /></li><li>如果v先访问:<br />  - 图无环<br />  - 无法从v访问u<br />  - 因此v结束时间在u之前因此DFS结束时间递减顺序即为拓扑排序顺序。</li></ul><h3 id="循环检测算法">循环检测算法</h3><p><strong>利用全DFS检测环</strong>:</p><ul><li>如果无向图无环,全DFS的反序order就是拓扑排序。<br /></li><li>对每条边 (u, v)，反序中如果v不在u前，就有环<br /></li><li>可以在O(|E|)时间内检测反序是否有环（哈希或者数组的数据结构）</li></ul><p><strong>定位环的算法</strong>:</p><ul><li>在全DFS过程中维护当前顶点的祖先集合</li><li>如果DFS遍历到一条从v到其祖先的边,则存在环。</li></ul><p><strong>正确性证明</strong>:</p><ul><li>设图包含环(v0,v1,...,vk,v0),假设v0首先被DFS访问。<br /></li><li>对每个vi,在访问vi结束前会访问vi+1并结束。<br /></li><li>最后在访问vk结束前会访问v0,此时v0是vk的祖先。</li></ul><h2 id="最短路径">最短路径</h2><p><img src="/assets/mit6.006总和笔记/image-20231024194703867.png" /></p><ul><li>路径π的权重w(π)是路径上所有边权重之和<br /></li><li>s到t的最短路径是从s到t权重最小的路径</li><li>δ(s,t)表示从s到t的最短路径权重</li><li>对一般权图,还不知道O(|V|+|E|)的最短路径算法<br /></li><li>但对DAG可以在O(|V|+|E|)时间内求解</li></ul><h3 id="简单最短路径">简单最短路径</h3><p>简单的最短路径 • 如果图表包含循环和负权重，则可能包含负权重循环 • 如果图形不包含负权环，则最短路径很简单！ • 主张 1：如果 δ(s, v) 是有限的，则存在一条到 v 的最短路径，该路径很简单 • 证明： 通过反证法： – 假设没有简单的最短路径； 设 π 为顶点最少的最短路径 – π 不简单，所以 π 中存在环 C； C 具有非负权重（或者 δ(s, v) = −∞） – 从 π 中删除 C 形成路径 π0，具有更少的顶点和权重 w(π0) ≤ w(π) • 由于简单路径不能重复顶点，因此有限最短路径最多包含 |V | − 1 条边</p><h3 id="有权图基础">有权图基础</h3><h4 id="最小生成树">最小生成树</h4><p>If know δ(s, v) for all vertices v ∈ V , can construct shortest-path tree in O(|V | + |E|) time</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Initialize empty parent pointer P and set P(s) = NoneFor each vertex u ∈ V where δ(s, u) is finite:  </span><br><span class="line">  For each outgoing neighbor v ∈ Adj+(u):  </span><br><span class="line">    If P(v) is not assigned and δ(s, v) = δ(s, u) + w(u, v):  </span><br><span class="line">      There exists a shortest path through edge (u, v), so set P(v) = uParent pointers may traverse cycles of zero weight. Mark each vertex in such a cycle.For each unmarked vertex u ∈ V (including vertices later unmarked):  </span><br><span class="line">  For each v ∈ Adj+(u) where v is marked and δ(s, v) = δ(s, u) + w(u, v):  </span><br><span class="line">    Unmark vertices in cycle containing v by traversing parent pointers from v  </span><br><span class="line">    Set P(v) = u, breaking the cycle</span><br></pre></td></tr></table></figure><ol type="1"><li>初始化父节点指针P，设置P(s)为空</li><li>对u的每条出边通向的节点v</li><li>如果P(v)为空且s-&gt;v最短路径是s-&gt;u-&gt;v,则P(v)=u</li><li>父节点可能导致一个权值为0的循环，如果有环则标记出来</li><li>对每个没有被标记的u(包括之后会被标记的)</li><li>如果有标记的邻居v满足最短路径条件</li><li>通过遍历v的父节点清除对它和它的父节点的标记</li><li>设置P(v)=u，打破循环</li></ol><h4 id="dag松弛算法">DAG松弛算法:</h4><ol type="1"><li><p>对每个顶点v维护一个距离估计d(s,v),初始化为无穷大,始终上界真实最短距离δ(s,v)</p></li><li><p>当边(u,v)违反三角不等式时,通过松弛操作将d(s,v)降低为d(s,u)+w(u,v)</p></li><li><p>松弛操作保证了d(s,v)始终是到v的某条路径的权重(或无穷大)</p></li><li><p>算法流程:<br />  - 初始化d(s,v)=无穷大,d(s,s)=0<br />   - 按拓扑排序顺序遍历每个顶点u<br />     - 对每个出边(u,v),如果d(s,v) &gt; d(s,u)+w(u,v),执行松弛操作</p></li><li><p>可以证明当算法结束时,d(s,v)=δ(s,v),即正确计算出最短距离</p></li><li><p>时间复杂度为O(V+E),是线性时间算法</p></li><li><p>主要思想是利用DAG没有环的特点,通过松弛操作逐步收紧距离上界,直到使其等于最短距离</p></li><li><p>利用拓扑排序的顺序,保证每次松弛时通过的顶点u的d(s,u)已经是最短距离</p></li></ol><h3 id="generic-s.p.-algorithm通用最短路径算法">Generic S.P. Algorithm通用最短路径算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Initialize:            for v in V:</span><br><span class="line">                            d[v] ← ∞</span><br><span class="line">                            Π[v] ← NIL</span><br><span class="line">                        d[s] ← 0</span><br><span class="line"></span><br><span class="line">Main:                  Repeat</span><br><span class="line">                       select edge (u, v)</span><br><span class="line">Relax edge (u, v):         if d[v] &gt; d[u] + w(u, v):</span><br><span class="line">                               d[v] ← d[u] + w(u, v)</span><br><span class="line">                               Π[v] ← u</span><br><span class="line">                        until you can’t relax any more edges or you’re tired or . .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从 u 到 v 的最短路径权重是 δ(u, v)。 如果从 u 无法到达 v，则 δ(u, v) 为 Infini， 如果从 u 到 v 的某个路径上存在负循环，则未定义。 <img src="/assets/mit6.006总和笔记/image-20231023103416467.png" /> <img src="/assets/mit6.006总和笔记/image-20231023104514707.png" /> PATHological示例:设置n个节点,前3对节点的边权为2<sup>n/2,第二组节点边权为2</sup>(n/2)-1,以此类推。这样设置权重,从v0到vn-1的距离约为2<sup>n。算法可能每次只将距离减少1,需重复2</sup>n次,时间复杂度为O(2^n)。 因此最短路径算法的性能很大程度上取决于图的结构,存在PATHological情况时算法效率很低。需设计改进的算法,避免指数时间复杂度。</p><h3 id="迪杰斯特拉无负数边的图">迪杰斯特拉（无负数边的图）</h3><ol type="1"><li>初始化:对每个顶点v,设置d(s,v)=∞,d(s,s)=0。</li><li>构建一个优先队列Q,每个顶点v以(v,d(s,v))为项加入Q。</li><li>循环直到Q为空:<br />   - 出队Q中key最小的顶点u<br />   - 对每个出边(u,v):<br />      - 如果d(s,v) &gt; d(s,u) + w(u,v):<br />         - 进行松弛操作         -  降低Q中v的key值到新的d(s,v)</li><li>时间复杂度O(E+VlogV),使用二叉堆可以达到O(E+VlogV)</li></ol><p><a href="https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html">演示</a> 1. 对每个边(u,v),假设权重w(u,v)≥0,维护一个集合S,包含已确定最短路径权重的顶点。 2. 重复地从V-S中选择一个离源点最近的顶点u,将u加入S,松弛u的所有出边,即比较点u连通的其他节点，从点u出发的路径是否比距离表内的短 3. 伪代码: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Dijkstra (G, W, s) //uses priority queue Q</span><br><span class="line"> Initialize (G, s)</span><br><span class="line"> S ← φ</span><br><span class="line"> Q ← V [G] //Insert into Q</span><br><span class="line"> while Q != φ</span><br><span class="line">  do u ← EXTRACT-MIN(Q) //deletes u from Q</span><br><span class="line">  S = S ∪ &#123;u&#125;</span><br><span class="line">  for each vertex v ∈ Adj[u]</span><br><span class="line">   do RELAX (u, v, w) ← this is an implicit DECREASE KEY operation</span><br><span class="line"></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RELAX(u, v, w)</span><br><span class="line"> if d[v] &gt; d[u] + w(u, v)</span><br><span class="line">  then d[v] ← d[u] + w(u, v)</span><br><span class="line">  Π[v] ← u</span><br><span class="line">放松是安全的</span><br><span class="line"> 引理：松弛算法对于所有的情况都保持 d[v] ≥ δ(s, v) 的不变量</span><br><span class="line"> v ∈ V 。</span><br><span class="line"> 证明：通过步数归纳。</span><br><span class="line"> 考虑 RELAX(u, v, w)。  通过归纳法 d[u] ≥ δ(s, u)。  通过三角形 -</span><br><span class="line"> 等式，δ(s, v) ≤ δ(s, u) + δ(u, v)。  这意味着 δ(s, v) ≤ d[u] + w(u, v)，因为</span><br><span class="line"> d[u] ≥ δ(s, u) 且 w(u, v) ≥ δ(u, v)。  因此设置 d[v] = d[u] + w(u, v) 是安全的。</span><br><span class="line"></span><br></pre></td></tr></table></figure> 4. 通过重复选择最近顶点,逐步确定最短路径,时间复杂度为O(|E|+|V|log|V|)。 <img src="/assets/mit6.006总和笔记/image-20231024112814756.png" /></p><h4 id="证明">证明</h4><p>归纳法证明当顶点v从Q中取出时,d(s,v) = δ(s,v)成立: 基础:s第一个取出,d(s,s)=0 = δ(s,s)成立 - 归纳假设:对前k-1个顶点成立 - 考虑第k个顶点v0:    - 取v0到s的最短路径π,w(π)=δ(s,v0)   - 设(x,y)是π中第一个y不在前k-1个顶点的边    - 当x取出时,d(s,x)=δ(s,x)(归纳假设)    - 所以取出x时松弛(x,y),d(s,y) ≤ δ(s,x) + w(x,y) = δ(s,y)   - 由于松弛操作的安全性,d(s,v0) ≤ δ(s,v0)    - 又因为v0是Q中key最小的,d(s,v0) ≥ δ(s,v0)    - 所以d(s,v0) = δ(s,v0)</p><h4 id="时间复杂度">时间复杂度</h4><div class="line-block">操作 | 时间复杂度 | 在Dijkstra中的出现次数|</div><p>|-|-|-| <br />|Q.build(X) (n = |X|)| Bn | 1 |<br />|Q.delete min()| Mn | |V| |<br />|Q.decrease key(id, k)| Dn | |E| | 总计O(B|V | + |V | · M|V | + |E| · D|V |) 对一个对顶点所有节点可达的图（修建过）： <img src="/assets/mit6.006总和笔记/image-20231025202308176.png" /> 对不同稀疏密度的图,使用不同的数据结构实现Dijkstra算法可以得到不同的时间复杂度: - 如果图是密集的,即 |E| = Θ(|V|<sup>2),使用数组实现优先队列Q,时间复杂度为O(|V|</sup>2) - 如果图是稀疏的,即 |E| = Θ(|V|),使用二叉堆实现Q,时间复杂度为 O(|V|log|V|) - Fibonacci堆在理论上对任意图都很好,但是实践中不常用 - 在理论分析中,通常假设Dijkstra算法的时间复杂度为O(|E| + |V|log|V|) 总结 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Dijkstra Complexity</span><br><span class="line"> Θ(v) inserts into priority queue</span><br><span class="line"> Θ(v) EXTRACT MIN operations</span><br><span class="line"> Θ(E) DECREASE KEY operations</span><br><span class="line">Array impl:</span><br><span class="line"> Θ(v) time for extra min</span><br><span class="line"> Θ(1) for decrease key</span><br><span class="line"> Total: Θ(V.V + E.1) = Θ(V 2 + E) = Θ(V 2)</span><br><span class="line">Binary min-heap:</span><br><span class="line"> Θ(lg V ) for extract min</span><br><span class="line"> Θ(lg V ) for decrease key</span><br><span class="line"> Total: Θ(V lg V + E lg V )</span><br><span class="line">Fibonacci heap (not covered in 6.006):</span><br><span class="line"> Θ(lg V ) for extract min</span><br><span class="line"> Θ(1) for decrease key</span><br><span class="line"> amortized cost</span><br><span class="line"> Total: Θ(V lg V + E)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="优化双向搜索">优化——双向搜索</h4><p>如果只需要s到t的最短路径，则只需要进行到t出队时结束算法 1. 双向搜索可以加速搜索,但不改变最坏时间复杂度,实际上可以减少访问的节点数。 2. 双向搜索同时进行:     - 从s节点进行正向搜索    - 从t节点进行反向搜索(沿边反向移动) 3. 正向搜索距离标记为df(u),反向为db(u) 4. 当一个节点w同时被两边搜索删除出队列时,搜索终止。 5. 终止后,找到df(x)+db(x)最小的节点x,x不一定是终止节点w。 6. 使用正向predecessor树Πf找到s到x的最短路径,使用反向树Πb找到t到x的最短路径。 7. 节点x一定已经被某一边搜索删除出队列。 <img src="/assets/mit6.006总和笔记/image-20231024193957638.png" /></p><h4 id="a算法">A*算法</h4><ol type="1"><li>A*通过势函数修改边权重指引搜索方向:w'(u,v) = w(u,v) - λ(u) + λ(v)</li><li>选择势函数使修改后的权重保持最短路径不变,且权重非负,以适用于Dijkstra算法。</li><li>设定目标势值为0,源点势值足够大,可以引导搜索方向。</li><li>使用landmark技巧:预计算顶点到一些landmark节点的最短距离δ(u,l)。定义势函数λ(u)=δ(u,l)-δ(t,l),可以证明是可行的。</li><li>对每个landmark l计算势函数λ,取最大值作为最终势函数,仍可行。</li><li>A*相比普通搜索可以显著减少搜索范围,提高效率。但最坏情况时间复杂度未改变。</li></ol><p>Modify edge weights with potential function over vertices <span class="math display">\[\overline{w}(u, v) = w(u, v) - λ(u) + λ(v)\]</span></p><p>So shortest paths are maintained in modified graph with w(overline) weights <span class="math display">\[\overline{w}(p) = w(p) - λ_t(u) + λ_t(t)\]</span> Small set of landmarks LCV . For all u ∈ V, l ∈ L, pre-compute δ(u, l). Potential <span class="math display">\[λ_t^{(l)}(u) = δ(u, l) − δ(t, l)\]</span> <img src="/assets/mit6.006总和笔记/image-20231024193915317.png" /></p><h3 id="贝尔曼福特">贝尔曼福特</h3><h4 id="负循环检测">负循环检测</h4><ol type="1"><li>定义k边距离δk(s,v):从s到v的路径中最多包含k条边的最小路径权重。</li><li>计算出δ|V|-1(s,v)和δ|V|(s,v),如果δ|V|(s,v)&lt;δ|V|-1(s,v),则v是一个负环见证人(witness)。</li><li>任意有向图中，对每个v∈V，计算δ(s,v)和δ|V|-1(s,v):<br />   - 如果δ(s,v)&lt;δ|V|-1(s,v),则δ|V |(s, v) =- ∞，把v视为负循环见证人    - 如果δ(s,v)!=−∞,则δ(s,v)=δ|V|-1(s,v)(简单最短路径原理)    - 如果δ(s,v)=−∞,v可以从某个见证人出发而到达</li><li>证明思路:<br /></li></ol><ul><li>假设某个负环C可达且不包含见证人,则对C中任一顶点v有:<br />δ|V|(s,v) ≤ δ|V|-1(s,v的前驱)+w(v的前驱,v) &lt; δ|V|-1(s,v)<br /></li><li>矛盾,所以C中必须存在见证人。</li><li><img src="/assets/mit6.006总和笔记/image-20231025082230441.png" /></li></ul><h4 id="定义">定义</h4><p><img src="/assets/mit6.006总和笔记/image-20231025092945965.png" /> 正确性： s到vk(k表示层数)的最短路径是每层可能的路径的最短者，贝尔曼福特算法穷举每一种可能，所以最后能得出最短的|V|-1层路径，从|V|-1到|V|则取决于图有没有负循环，如果有负循环，则s到见证人可达的结点路径为负无穷长 运行时间 1. 构建多层图G'需O(|V|(|V|+|E|)) 2. 在G'上运行DAG最短路径算法需O(|V|(|V|+|E|))，即G'大小的线性时间 3. 处理每个负环见证人需O(1),找到一个见证人的所有可达结点是O(|E|)见证人最多V个，找到所有见证人的可达性需O(|V||E|) 4. 如果把G修整成s开始的s可达子图，时间复杂度为O(|V||E|)</p><p>扩展思考: <img src="/assets/mit6.006总和笔记/image-20231025093817635.png" /></p><p><img src="/assets/mit6.006总和笔记/image-20231025080815803.png" /> • |V | + 1 levels: vertex vk in level k represents reaching vertex v from s using ≤ k edges • If edges only increase in level, resulting graph is a DAG • Construct new DAG G0 = (V 0, E0) from G = (V, E): – G' has |V |(|V | + 1) vertices v_k for all v ∈ V and k ∈ {0, . . . , |V |} – G' has |V |(|V | + |E|) edges: ∗ |V | edges (vk−1, vk) for k ∈ {1, . . . , |V |} of weight zero for each v ∈ V ∗ |V | edges (uk−1, vk) for k ∈ {1, . . . , |V |} of weight w(u, v) for each (u, v) ∈ <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Bellman-Ford(G,W,s)</span><br><span class="line"> Initialize ()</span><br><span class="line"> for i = 1 to |V | − 1</span><br><span class="line">  for each edge (u, v) ∈ E:</span><br><span class="line">   Relax(u, v)</span><br><span class="line"> for each edge (u, v) ∈ E</span><br><span class="line">  do if d[v] &gt; d[u] + w(u, v)</span><br><span class="line">   then report a negative-weight cycle exists</span><br><span class="line">//At the end, d[v] = δ(s, v), if no negative-weight cycles</span><br><span class="line"></span><br></pre></td></tr></table></figure> 1. 初始化,进行|V|-1轮松弛操作,每轮对每个边(u,v)做relax操作，非负的图最多需要|V|-I次操作就可以松弛到任意点出发的任意路径都是最短路径 2. 如果第|V|轮还可以relax任意边,说明存在负权环。 3. 如果图中无负权环,Bellman-Ford执行结束后d[v]=δ(s,v)。 4. 推论:如果d[v]在|V|-1轮未收敛,说明存在从s可达的负权环。 5. Bellman-Ford时间复杂度为O(|V||E|),适合稠密图。</p><h4 id="最长简单路径和最短简单路径">最长简单路径和最短简单路径</h4><p>在具有非负边权重的图中找到最长的简单路径是一个 NP- hard问题，不存在已知的多项式时间算法。 假设一个 只需否定每个边权重并运行 Bellman-Ford 来计算最短 路径。 贝尔曼-福特不一定会计算原始路径中的最长路径 图，因为可能存在可从源到达的负权重循环，并且 算法将中止。 类似地，如果我们有一个具有负循环的图，并且我们希望找到最长的 从源 s 到顶点 v 的简单路径，我们不能使用 Bellman-Ford。 最短的 简单路径问题也是NP- hard问题</p><h2 id="johnsons-algorithm">Johnson’s Algorithm</h2><h3 id="all-pairs-shortest-paths-apsp">All-Pairs Shortest Paths (APSP)</h3><ul><li>输入:有向带权图G=(V,E),权值函数w:E→Z</li><li>输出:对所有u,v∈V,求出δ(u,v),如果有负权回路则报错</li><li>应用:理解整个网络,如交通、电路布线、供应链等</li><li>直接运行|V|次单源算法时间复杂度:     - DAG松弛: |V|·O(|V|+|E|),无环<br />  - BFS: |V|·O(|V|+|E|),非负权值<br />  - Dijkstra: |V|·O(|V|log|V|+|E|),非负权值<br />  - Bellman-Ford: |V|·O(|V||E|),一般图</li></ul><p>思路：重构权值函数,使G变为G',其中G'没有负权边,且G的最短路径在G'上也是最短路径。如果成功,就可以在G'上运行Dijkstra 实现： 对每个顶点v:<br />- 从v出发的边权加上h<br />- 进入v的边权减去h<br />- 这样可以保证最短路径不变<br />- 证明:<br />  - 任意从v开始的路径权值改变了h<br />  - 任意到v结束的路径权值改变了-h<br />  - 通过v的路径权值局部不变</p><p><img src="/assets/mit6.006总和笔记/image-20231025213904004.png" /></p><h3 id="算法">算法</h3><ul><li>构造含新顶点x的图Gx,x到每个顶点v有权值为0的边</li><li>对Gx运行Bellman-Ford算法计算δx(x,v)</li><li>如果δx(x,v)为无穷大,说明G中有负权回路,报错退出</li><li>否则,用δx重新调整每个边的权值构造G'</li><li>对G'运行Dijkstra算法|V|次计算每个顶点的最短路径 </li><li>从G'的最短路径恢复G的最短路径</li></ul><h3 id="时间复杂度-1">时间复杂度</h3><ul><li>构造Gx需O(|V|+|E|)</li><li>Bellman-Ford需O(|V||E|)</li><li>构造G'需O(|V|+|E|)</li><li>|V|次Dijkstra需O(|V|(|V|log|V| + |E|))</li><li>用G'恢复G的距离需O(|V|^2)</li><li>总计O({|V|^2}log|V| + |V||E|)</li></ul><h1 id="概率">概率</h1><p>雇佣问题 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">best = 0</span><br><span class="line">hired = null</span><br><span class="line">for i = 1 to n</span><br><span class="line">if candidates[i] &gt; best</span><br><span class="line"> best = candidates[i]</span><br><span class="line"> hired = i</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="指示器随机变量">指示器随机变量</h2><p>指示器随机变量可以用于对随机输入的算法分析 <span class="math display">\[I(A) = \begin{cases}             1 &amp; \text{event A occurs} \\             0 &amp; \text{otherwise}  \end{cases}\]</span> 把期望转化成指示器期望的相加</p><h2 id="随机算法">随机算法</h2><p>在此基础上可以在算法中进行随机数处理，排除输入的影响 比如在雇佣问题中，对输入的候选者数组进行随机排序 随机排序： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">n = A.length</span><br><span class="line">let P[1-n] be a new array</span><br><span class="line">for i=1 to n</span><br><span class="line"> P[i] = RANDOM(1,n^3)</span><br><span class="line">sort A,use P</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="递归和动态规划">递归和动态规划</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># recursive solution (top down)</span><br><span class="line">def fib(n):</span><br><span class="line"> memo = &#123;&#125;</span><br><span class="line"> def F(i):</span><br><span class="line">  if i &lt; 2: return i # base cases</span><br><span class="line">  if i not in memo: # check memo</span><br><span class="line">   memo[i] = F(i - 1) + F(i - 2) # relation</span><br><span class="line">  return memo[i]</span><br><span class="line"> return F(n) # original</span><br><span class="line"># iterative solution (bottom up)</span><br><span class="line">def fib(n):</span><br><span class="line"> F = &#123;&#125;</span><br><span class="line"> F[0], F[1] = 0, 1 # base cases</span><br><span class="line"> for i in range(2, n + 1): # topological order</span><br><span class="line">  F[i] = F[i - 1] + F[i - 2] # relation</span><br><span class="line"> return F[n] # original</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/assets/mit6.006总和笔记/image-20231027103835269.png" /> <img src="/assets/mit6.006总和笔记/image-20231027112657842.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># recursive solution (top down)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bowl</span>(<span class="params">v</span>):</span><br><span class="line"> memo = &#123;&#125;</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">B</span>(<span class="params">i</span>):</span><br><span class="line">  <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(v): <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># base cases</span></span><br><span class="line">  <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> memo: <span class="comment"># check memo</span></span><br><span class="line">  memo[i] = <span class="built_in">max</span>(B(i+<span class="number">1</span>), <span class="comment"># relation: skip pin i</span></span><br><span class="line">   v[i] + B(i+<span class="number">1</span>), <span class="comment"># OR bowl pin i separately</span></span><br><span class="line">   v[i] * v[i+<span class="number">1</span>] + B(i+<span class="number">2</span>)) <span class="comment"># OR bowl pins i and i+1 together</span></span><br><span class="line">   <span class="keyword">return</span> memo[i]</span><br><span class="line">  <span class="keyword">return</span> B(<span class="number">0</span>) <span class="comment"># original</span></span><br><span class="line"><span class="comment"># iterative solution (bottom up)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bowl</span>(<span class="params">v</span>):</span><br><span class="line"> B = &#123;&#125;</span><br><span class="line"> B[<span class="built_in">len</span>(v)] = <span class="number">0</span> <span class="comment"># base cases</span></span><br><span class="line"> B[<span class="built_in">len</span>(v)+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(v))): <span class="comment"># topological order</span></span><br><span class="line">  B[i] = <span class="built_in">max</span>(B[i+<span class="number">1</span>], <span class="comment"># relation: skip pin i</span></span><br><span class="line">   v[i] + B(i+<span class="number">1</span>), <span class="comment"># OR bowl pin i separately</span></span><br><span class="line">   v[i] * v[i+<span class="number">1</span>] + B(i+<span class="number">2</span>)) <span class="comment"># OR bowl pins i and i+1 together</span></span><br><span class="line"> <span class="keyword">return</span> B[<span class="number">0</span>] <span class="comment"># original</span></span><br></pre></td></tr></table></figure><p>如何关联子问题解决方案 • 我们遵循的一般方法来定义子问题解决方案的关系： - 确定一个有关子问题解决方案的问题，如果知道答案，则该问题将减少到“更小的”子问题 - 在打保龄球的情况下，问题是“我们如何打第一对球瓶？” - 然后通过尝试所有可能的答案并采取最好的答案来本地暴力解决问题 - 在保龄球的情况下，我们取最大值，因为问题要求最大化 - 或者，我们可以考虑正确猜测问题的答案，然后 直接递归； 但随后我们实际上检查所有可能的猜测，并返回“最佳” • 效率的关键是问题有少量（多项式）可能的可能性。答案，所以暴力破解并不太昂贵 • 通常（但并非总是）计算关系的非递归工作等于数字 我们正在尝试的答案</p><h2 id="动态规划">动态规划</h2><h3 id="lcs">LCS</h3><p>• x(i, j) = A[i :] 和 B[j :]的最大公共子序列 • For 0 &lt;= i &lt;= |A| and 0 &lt;=0 j &lt;= |B| 最长公共子序列问题(LCS): 1. 定义了子问题x(i,j),表示 A[i:]和B[j:]的最长公共子序列长度。 2. 列出了递归关系 - 如果A[i]==B[j],那么x(i,j)等于x(i+1,j+1)+1,否则等于x(i+1,j)和x(i,j+1)的最大值。 3. 指出了拓扑顺序,子问题依赖更大的i或j。 4. 给出了 base cases —— 当一个字符串为空时,LCS长度为0。x(i, |B|) = x(|A|, j) = 0 5. 原问题可以通过x(0,0)求解,同时需要parent pointers构建最长子序列。 6. 时间复杂度分析也正确,子问题数为O(|A|*|B|),每件工作为O(1),所以总时间为O(|A|*|B|)。 <span class="math display">\[x(i,j) =\begin{cases}   x(i+1,j+1)+1, &amp; \text{if }A[i]=B[j] \\   max(x(i + 1, j), x(i, j + 1)) , &amp; otherwise\end{cases}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">A, B</span>):</span><br><span class="line"> a, b = <span class="built_in">len</span>(A), <span class="built_in">len</span>(B)</span><br><span class="line"> x = [[<span class="number">0</span>] * (b + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a + <span class="number">1</span>)]<span class="comment">#x 的最终形状是一个 (a + 1) x (b + 1) 的二维列表,每个元素初始化为 0</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(b)):</span><br><span class="line">   <span class="keyword">if</span> A[i] == B[j]:</span><br><span class="line">    x[i][j] = x[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">    x[i][j] = <span class="built_in">max</span>(x[i + <span class="number">1</span>][j], x[i][j + <span class="number">1</span>])</span><br><span class="line"> <span class="keyword">return</span> x[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment">#如果A[i] == B[j],那么最长公共子序列可以在A[i+1:]和B[j+1:]的基础上再加上A[i]这个字符,所以x[i][j] = x[i+1][j+1] + 1。</span></span><br><span class="line"><span class="comment">#如果A[i] != B[j],那么A[i]和B[j]不可能同时在最长公共子序列中,需要舍弃一个字符。所以x[i][j]取x[i+1][j]和x[i][j+1]中的最大值。</span></span><br><span class="line"><span class="comment">#依次遍历,直到i或j变为-1,即遍历完两个字符串。</span></span><br></pre></td></tr></table></figure><h3 id="lis">LIS</h3><p><code>Longest Increasing Subsequence (LIS)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lis</span>(<span class="params">A</span>):</span><br><span class="line"> a = <span class="built_in">len</span>(A)</span><br><span class="line"> x = [<span class="number">1</span>] * a</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(a)):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, a):</span><br><span class="line">   <span class="keyword">if</span> A[j] &gt; A[i]:</span><br><span class="line">    x[i] = <span class="built_in">max</span>(x[i], <span class="number">1</span> + x[j])</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">max</span>(x)</span><br></pre></td></tr></table></figure><p>x(i)是A[i:]的最长递增子数组 O(|A|^2) running time - 外层循环i是在寻找以每个元素结尾的LIS长度。 - 内层循环j是在寻找可以接在A[i]后面的最大LIS长度。 - x数组缓存了每个位置的LIS长度,避免重复计算。 - 通过从后向前遍历,可以保证每个x[i]都是最新的最大LIS长度。</p><h3 id="alternating-coin-game">Alternating Coin Game</h3><ul><li>两名玩家（“我”和“你”）轮流</li><li>轮流取出剩余硬币中的第一个或最后一个硬币</li><li>我的目标是最大化我所拿走的硬币的总价值，这是我首先要做的 x(i, j) =我可以从 vi, . . . , vj中拿走的最大硬币总价值 <img src="/assets/mit6.006总和笔记/image-20231027200057225.png" /> 子问题: O(n^2) • 每个子问题相加: O(n) to compute sums • O(n^3) running time</li></ul><h4 id="优化-1">优化</h4><ol type="1"><li>扩展定义子问题x(i,j,p),添加了一个表示下一步该谁走的状态p。</li><li>列出了四个递归关系式,区分我方走与对方走的不同情况。</li><li>拓扑顺序及base case与第一种解法相同。</li><li>计算原问题时,状态为我方走。</li></ol><p>x(i, j, p) = maximum total value I can take when player p ∈ {me, you} starts from coins of values vi, . . . , vj</p><p>Player p must choose either coin i or coin j • If p = me, then I get the value; otherwise, I get nothing • Then it’s the other player’s turn • x(i, j, me) = max{vi + x(i + 1, j, you), vj + x(i, j + 1, you)} • x(i, j, you) = min{x(i + 1, j, me), x(i, j + 1, me)} <img src="/assets/mit6.006总和笔记/image-20231027200227456.png" /> <strong>时间</strong> • subproblems: ⇥(n2) • work per subproblem: ⇥(1) • ⇥(n2) running time 扩展子问题可以提供递归所需信息,但代价是子问题数目增加,计算复杂度上升。需要权衡取舍。</p><h3 id="rod-cutting">Rod Cutting</h3><p>切一根棍子，切割长度产生的收益如表</p><table><thead><tr class="header"><th>index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr class="odd"><td>value</td><td>0</td><td>1</td><td>10</td><td>13</td><td>18</td><td>20</td><td>31</td><td>32</td></tr></tbody></table><p>x(l): maximum value obtainable by cutting rod of length x(l) = max{v(p) + x(l-p) | p 2 {1, . . . ,l }} time: - subproblems: L + 1 - work per subproblem: O(l) = O(L) - O(L^2) running time</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># recursive</span></span><br><span class="line">x = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">l, v</span>):</span><br><span class="line"> <span class="keyword">if</span> l &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># base case</span></span><br><span class="line"> <span class="keyword">if</span> l <span class="keyword">not</span> <span class="keyword">in</span> x: <span class="comment"># check memo</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + cut_rod(l - piece, v) <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> (l <span class="keyword">not</span> <span class="keyword">in</span> x) <span class="keyword">or</span> (x[l] &lt; x_): <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line"> <span class="keyword">return</span> x[l]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iterative</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">L, v</span>):</span><br><span class="line"> x = [<span class="number">0</span>] * (L + <span class="number">1</span>) <span class="comment"># base case</span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L + <span class="number">1</span>): <span class="comment"># topological order</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + x[l - piece] <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> x[l] &lt; x_: <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line"> <span class="keyword">return</span> x[L]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iterative with parent pointers</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod_pieces</span>(<span class="params">L, v</span>):</span><br><span class="line"> x = [<span class="number">0</span>] * (L + <span class="number">1</span>) <span class="comment"># base case</span></span><br><span class="line"> parent = [<span class="literal">None</span>] * (L + <span class="number">1</span>) <span class="comment"># parent pointers</span></span><br><span class="line"> <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L + <span class="number">1</span>): <span class="comment"># topological order</span></span><br><span class="line">  <span class="keyword">for</span> piece <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l + <span class="number">1</span>): <span class="comment"># try piece</span></span><br><span class="line">   x_ = v[piece] + x[l - piece] <span class="comment"># recurrence</span></span><br><span class="line">   <span class="keyword">if</span> x[l] &lt; x_: <span class="comment"># update memo</span></span><br><span class="line">    x[l] = x_</span><br><span class="line">    parent[l] = l - piece <span class="comment"># update parent</span></span><br><span class="line"> l, pieces = L, []</span><br><span class="line"> <span class="keyword">while</span> parent[l] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># walk back through parents</span></span><br><span class="line">  piece = l - parent[l]</span><br><span class="line">  pieces.append(piece)</span><br><span class="line">  l = parent[l]</span><br><span class="line"> <span class="keyword">return</span> piece</span><br></pre></td></tr></table></figure><h3 id="subset-sum">Subset Sum</h3><p><a href="https://www.jianshu.com/p/0322014dc357?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes">相关博客</a> A = {a0, a1, . . . , an} 是否存在A的子集A'，A'的元素总和为T x(i, j): True if can make sum j using items 1 to i, False otherwis <span class="math display">\[x(i,j) =\begin{cases}   x(i - 1, j - A[i]), &amp; \text{if j &gt;= A[i] } \\   x(i - 1, j), &amp; always\end{cases}\]</span> - x(i, 0) = True for i ∈ {0, . . . , n} (trivial to make zero sum!) - x(0, j) = False for j ∈ {1, . . . , T} (impossible to make positive sum from empty set - for i ∈ {0, . . . , n}, j ∈ {0, . . . , T}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp_subset</span>(<span class="params">arr,S</span>):</span><br><span class="line">    </span><br><span class="line">    subset = np.zeros((<span class="built_in">len</span>(arr),S+<span class="number">1</span>),dtype=<span class="built_in">bool</span>) <span class="comment">#构造二维数组</span></span><br><span class="line">    subset[:,<span class="number">0</span>] = <span class="literal">True</span> <span class="comment"># 第一列 设为True</span></span><br><span class="line">    subset[<span class="number">0</span>,: ] = <span class="literal">False</span> <span class="comment">#第一列 设为 False</span></span><br><span class="line">    subset[<span class="number">0</span>,arr[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, S+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; s:</span><br><span class="line">                subset[i , s] = subset[i-<span class="number">1</span> , s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = subset[i-<span class="number">1</span> , s ]</span><br><span class="line">                B = subset[i-<span class="number">1</span> , s - arr[i]]</span><br><span class="line">                subset[i,s] = A <span class="keyword">or</span> B</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    row ,cell = subset.shape</span><br><span class="line">    <span class="keyword">return</span> subset[row-<span class="number">1</span>,cell-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">arr  = [<span class="number">1</span>,<span class="number">2</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]            </span><br><span class="line">dp_subset(arr,<span class="number">7</span>) </span><br><span class="line">out:<span class="literal">True</span></span><br></pre></td></tr></table></figure><p><img src="/assets/mit6.006总和笔记/image-20231028110550677.png" /></p><p>subproblems: O(nT ), O(1) work per subproblem, O(nT ) time</p><h1 id="其他">其他</h1><h2 id="多项式时间的判定">多项式时间的判定</h2><p>只有在算法时间复杂度仅与问题规模有多项式关系时，才可称为多项式时间复杂度算法。 存在如基数排序之类时间复杂度依赖于输入数据的算法，称为伪多项式时间复杂度，此时算法的时间复杂度是输入数据大小的多项式时间表达，但却是输入数据长度（输入规模）的指数时间表达</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">冒泡排序：给定 n 个64位的数字，进行 n-1 次扫描交换，将数字从小到大排序。</span><br><span class="line">素数测试：给定数字 n，通过从 2 到根号 n 的整数遍历，判断 n 是否为素数。</span><br><span class="line">字面上看，两者复杂度都是 O(n^k) ( k 为整数) 。但区别在于，前者的 n 是数字个数的多少，后者的 n 是数字的大小。</span><br><span class="line">因此，前者输入总规模 s1 增长与数字大小无关，s1 = 64n；后者增长规模与数字大小紧密相关，输入总规模为 s2 = logn 。</span><br><span class="line">所以可知冒泡排序中复杂度 O(n^2) = O(s1^2/64^2) 为多项式算法，后者素数测试O(n) = O(2^(s2)) 为伪多项式算法</span><br></pre></td></tr></table></figure><h2 id="复杂度">复杂度</h2><ul><li>决策问题:将输入归类为YES或NO的问题。</li><li>算法/程序:能够在一定时间内解决问题的常量长度代码。</li><li>如果问题有算法可以在有限时间内解决,则该问题是可判定的。</li><li>程序是有限的,问题是无限的,因此大多数决策问题是不可判定的。</li><li>即使可判定,也以不同的时间复杂度分类:</li></ul><ol type="1"><li>R类:有限时间可判定</li><li>EXP类:指数时间可判定</li><li>P类:多项式时间可判定(我们关注的)</li></ol><ul><li>这些类满足 P⊆EXP⊆R 的包含关系。 NP与P问题参考<a href="https://thinklive1.github.io/2023/10/06/61b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/">61b笔记</a></li></ul><p>mit的后续课程 <img src="/assets/mit6.006总和笔记/image-20231027201108930.png" /> <img src="/assets/mit6.006总和笔记/image-20231027201117355.png" /></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础&quot;&gt;基础&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/mit6.006总和笔记/algo.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;算法合订本&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/mit6.006总和笔记/image-20231016191822017.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法性质&quot;&gt;算法性质&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;循环不变式&lt;/code&gt;主要用来帮助我们理解算法的正确性。关千&lt;code&gt;循环不变式&lt;/code&gt;，我们必须证明三条&lt;br /&gt;
性质：&lt;br /&gt;
初始化：循环的第一次迭代之前，它为真。&lt;br /&gt;
保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。&lt;br /&gt;
终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助千证明算法是正确的。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法" scheme="https://thinklive1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="麻省理工" scheme="https://thinklive1.github.io/tags/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5/"/>
    
  </entry>
  
  <entry>
    <title>基于中科大linux101和苏大ppt的linux笔记</title>
    <link href="https://thinklive1.github.io/2023/10/14/%E8%8B%8F%E5%A4%A7linux_ppt/"/>
    <id>https://thinklive1.github.io/2023/10/14/%E8%8B%8F%E5%A4%A7linux_ppt/</id>
    <published>2023-10-14T12:27:26.442Z</published>
    <updated>2023-11-27T12:50:13.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="苏大部分">苏大部分</h1><h2 id="文件系统">文件系统</h2><h3 id="命名">命名</h3><p>•除/之外，所有的字符都合法</p><p>•大小写敏感</p><p>•有些字符最好不用，如空格符、制表符、退格符和字符：？, @ # $ &amp; ()  | ; ‘ ’ “ ” &lt; &gt;</p><p>•避免使用＋、－或. 来作为普通文件名的第一个字符</p><p>•可以使用长文件名或目录名（255个字符）</p><p>包括完整路径的文件名不超过4096字符 <span id="more"></span></p><h3 id="目录">目录</h3><table><tbody><tr class="odd"><td>bin</td><td>存放二进制的可执行程序</td></tr><tr class="even"><td>boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr class="odd"><td>dev</td><td>存放设备文件，用户通过这些文件访问外部设备</td></tr><tr class="even"><td>etc</td><td>存放系统的配置文件</td></tr><tr class="odd"><td>home</td><td>存放用户文件的目录，每个用户在该目录下有一个与该用户名对应的子目录</td></tr><tr class="even"><td>root</td><td>超级用户目录</td></tr><tr class="odd"><td>sbin</td><td>类似于/bin目录，存放二进制文件，只有root才能访问</td></tr><tr class="even"><td>tmp</td><td>用于放置各种临时文件</td></tr></tbody></table><table><tbody><tr class="odd"><td>var</td><td>用于存放需要随时改变的文件，如系统日志、脱机工作目录等</td></tr><tr class="even"><td>mnt</td><td>系统管理员安装临时文件系统的安装点</td></tr><tr class="odd"><td>opt</td><td>一般情况下，该目录不属于系统的基本文件系统，是额外安装的应用程序包所放置的地方</td></tr><tr class="even"><td>usr</td><td>用于存放系统应用程序</td></tr><tr class="odd"><td>lib</td><td>存放根文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr class="even"><td>proc</td><td>是一个虚拟文件系统，存放当前内存的映射，主要用于在不重启机器的情况下管理内核</td></tr><tr class="odd"><td>lost+ found</td><td>存放一些系统检查结果，发现不合法的文件或数据都存放在这里，通常此目录是空的，除非硬盘遭到损坏</td></tr></tbody></table><h3 id="链接文件">链接文件</h3><ul><li><p>硬链接 将两个文件名指向硬盘上同一个存储空间（inode），对任何一个文件的修改都将影响到另一个文件。 特性： 文件有相同的 inode 及 data block； 只能对已存在的文件进行创建； 不能交叉文件系统进行硬链接的创建； 不能对目录进行创建，只可对文件创建； 删除一个硬链接文件并不影响其他有相同 inode 号的文件。</p></li><li><p>符号链接 又称软链接，是指将一个文件指向另外一个文件的文件名。 特性： 软链接有自己的文件属性及权限等； 软链接可对文件或目录创建； 可对不存在的文件或目录创建软链接； 软链接可交叉文件系统； 若被指向的原文件被删除，则相关软连接被称为死链接 删除软链接并不影响被指向的文件，若被指向路径文件被重新创建，死链接可恢复为正常的软链接</p></li></ul><p><code>符号链接可以跨文件系统，即可以跨磁盘分区。硬链接不可以跨文件系统。它只能建立对文件的链接。</code> 链接文件命令  ln</p><table><tbody><tr class="odd"><td>ln file1 file2</td><td>创建源文件file1的硬链接file2</td></tr><tr class="even"><td>ln -s file1 file2</td><td>创建源文件file1的软链接file2</td></tr></tbody></table><p>符号链接可以跨文件系统，即可以跨磁盘分区。 硬链接不可以跨文件系统，只能建立对文件的链接。 硬链接删除只原文件或硬链接不影响文件内容 软连接删除源文件导致链接失效</p><h3 id="mbr">MBR</h3><p>硬盘的第一个扇区存有主引导记录(Master boot record, MBR)及分区表(partition table)</p><ul><li>MBR用于引导操作系统， 446 bytes ；</li><li>partition table用于记录分区信息， 64 bytes ； 一个MBR分区表类型的硬盘最多存在4个主分区，每个分区项占用16个字节 如果分区超过4个，则需要使用扩展分区，即一个物理硬盘上最多有3个主分区和1个扩展分区。 扩展分区不能直接使用，必须分割成为逻辑分区，一个扩展分区中的逻辑分区可以任意多个。</li></ul><h3 id="gpt">GPT</h3><p>全称全局唯一标识分区表 GUID Partition Table</p><ul><li>主分区数量任意（Win 128个）</li><li>支持最大18EB（NTFS 256TB） 1EB=1024PB=1,048,576TB 可能需要EFI支持（Win、Mac）</li></ul><h3 id="ext2">ext2</h3><p>磁盘分区完毕后还需要进行格式化(format)，不同操作系统默认的文件系统不同，所以需要格式化成不同格式的分区。 EXT2（second extended filesystem）是LINUX内核默认的文件系统。 EXT2中的主要构成： •SuperBlock  记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等； •Block   实际记录文件的内容，若文件较大，则占用多个 block。 •Inode   记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码</p><h4 id="inode">inode</h4><p>ext2 创建一个目录时，分配1个 inode 与至少1块 block 给目录 •inode 记录目录权限与属性，并记录分配到 block号码 •block 记录目录下文件名与该文件名占用的 inode</p><p>inode 数量与大小在格式化时固定 特征：</p><ul><li>每个 inode 大小均固定为 128 bytes；</li><li>每个文件仅占用一个 inode；</li><li>文件系统能够创建的文件数量与 inode 的数量有关；</li><li>系统读取文件时先找到 inode，分析 inode 所记录的权限与用户是否符合，若符合读取 block 的内容。 <img src="assets/苏大linux_ppt/image-20231014145226727.png" /></li></ul><h4 id="升级">升级</h4><p><code>EXT2</code>文件系统高效稳定，但不提供日志 <code>EXT3</code> 提供日志模式： data=journal模式 对所有的文件数据及metadata（定义文件系统中数据的数据,即数据的数据）进行日志记录 data=ordered或data=writeback模式 只对metadata记录日志，而不对数据进行日志记录</p><p><code>EXT4</code> EXT3的扩展升级，可以提供更佳的性能和可靠性，包括支持更大的分区和文件大小，更快的文件操作速度。</p><h3 id="实例">实例</h3><h4 id="fdisk">fdisk</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">           fdisk      [-options]     &lt;disk&gt;</span><br><span class="line">选项：</span><br><span class="line">-l 列出分区信息表</span><br><span class="line">/dev/sda    对sda磁盘进行分区</span><br></pre></td></tr></table></figure><p>中科大的xubuntu镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ustc@ustclug-linux101:~/桌面$ sudo fdisk -l</span><br><span class="line">[sudo] ustc 的密码： </span><br><span class="line">Disk /dev/sda：5 GiB，5368709120 字节，10485760 个扇区</span><br><span class="line">Disk model: VMware Virtual S</span><br><span class="line">单元：扇区 / 1 * 512 = 512 字节</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：gpt</span><br><span class="line">磁盘标识符：12526913-E330-4CA7-A379-90A87EF858B0</span><br><span class="line"></span><br><span class="line">设备         起点     末尾    扇区  大小 类型</span><br><span class="line">/dev/sda1    2048   499711  497664  243M EFI 系统</span><br><span class="line">/dev/sda2  499712 10483711 9984000  4.8G Linux 文件系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="mkfs格式化">mkfs格式化</h4><p>mkfs      [-t 磁盘格式名]     &lt;partition&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs  -t ext3  /dev/sdb1</span><br></pre></td></tr></table></figure><h4 id="mount挂载">mount挂载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mount [-t vfstype] [-o options]    device    <span class="built_in">dir</span></span><br><span class="line">mount                         显示所有挂载的信息</span><br><span class="line"></span><br><span class="line">mount –a                   将所有未挂载设备挂载</span><br><span class="line"></span><br><span class="line">mount   /dev/hda2   /mnt/myhd2    将hda2设备挂载到/mnt/myhd2</span><br><span class="line"></span><br><span class="line">mount -t iso9660 /dev/cdrom  /media/cdrom  挂载光驱</span><br><span class="line">umount [选项] <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-f     强制卸载</span><br><span class="line"></span><br><span class="line">-all   卸载所有挂载</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"></span><br><span class="line">umount  /media/cdrom     卸载刚才挂载的光驱</span><br></pre></td></tr></table></figure><h2 id="shell">shell</h2><h3 id="重定向">重定向</h3><p>lLinux启动后，默认打开3个文件描述符 •标准输入：standard input   0 •标准输出：standard output  1 •错误输出：error output     2 每条shell命令执行，都会继承父进程的文件描述符。因此，所有运行的shell命令，都会有默认3个文件描述符。 <code>重定向</code> 是指不使用系统的标准输入，标准输出或标准错误端口，而重新指定输入输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入重定向</span><br><span class="line"></span><br><span class="line">&lt;          输入重定向，从普通文件获取</span><br><span class="line"></span><br><span class="line">&lt;&lt;!...!    输入重定向， here文件，即从命令行获取</span><br><span class="line"></span><br><span class="line">输出重定向</span><br><span class="line"></span><br><span class="line">&gt;          输出重定向，覆盖模式</span><br><span class="line"></span><br><span class="line">&gt;&gt;         输出重定向，追加模式</span><br><span class="line"></span><br><span class="line">2&gt;         错误重定向，覆盖模式</span><br><span class="line"></span><br><span class="line">2&gt;&gt;        错误重定向，追加模式</span><br><span class="line"></span><br><span class="line">&amp;&gt;         同时实现输出重定向和错误重定向，覆盖模式</span><br><span class="line"></span><br><span class="line">&amp;&gt;&gt;        同时实现输出重定向和错误重定向，追加模式</span><br></pre></td></tr></table></figure><h3 id="管道">管道</h3><p>管道是一种两个进程间进行单向通信的机制 每个命令的输出作为下一条命令的输入，管道线中的命令从左到右顺序执行的，管道线是单向的 因为管道传递数据的单向性，管道又称为半双工管道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls –l | wc -l</span><br></pre></td></tr></table></figure><h3 id="命令替换">命令替换</h3><p>Shell中的命令参数可以由另一个命令执行的结果来替代</p><p>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$cmd1 `cmd2  arguments`</span><br><span class="line">或</span><br><span class="line">$cmd1 $(cmd2 arguments)</span><br></pre></td></tr></table></figure><p>其中cmd2  arguments的输出作为cmd1的参数y</p><h3 id="命令聚合">命令聚合</h3><p>在一个命令行上使用若干shell元字符将若干命令聚合在一起运行。</p><p>执行聚合的几种方式：</p><p>•<code>cmd1;cmd2</code>   顺序执行若干命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd;date;ls</span><br></pre></td></tr></table></figure><p>•<code>cmd1&amp;&amp;cmd2</code> 当cmd1运行成功时才运行cmd2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip mylargefile&amp;&amp;echo &quot;OK.&quot;</span><br></pre></td></tr></table></figure><p>•<code>cmd1||cmd2</code>   当cmd1运行失败时才运行cmd2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip mylargefile||echo &quot;FALSE.&quot;</span><br></pre></td></tr></table></figure><p>•<code>(cmdlist)</code>   在子shell中执行命令序列，命令不影响当前shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(date;who|wc -l)&gt;~/login-users.log</span><br></pre></td></tr></table></figure><h1 id="linux101">linux101</h1><p><img src="/assets/苏大linux_ppt/clitool.png" /></p><h2 id="apt">apt</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ apt search firefox</span><br><span class="line">Sorting... Done</span><br><span class="line">Full Text Search... Done</span><br><span class="line">(Output omitted)</span><br><span class="line"></span><br><span class="line">firefox/bionic-updates,bionic-security,now 72.0.2+build1-0ubuntu0.18.04.1 amd64</span><br><span class="line">  Safe and easy web browser from Mozilla</span><br><span class="line"></span><br><span class="line">(Output omitted)</span><br></pre></td></tr></table></figure><p>中间两行每个字段的含义：</p><table><thead><tr class="header"><th>样例中的字段</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>firefox</code></td><td>即为在软件仓库中的包名</td></tr><tr class="even"><td><code>bionic-updates,bionic-security,now</code></td><td>为包含这个软件包的仓库源</td></tr><tr class="odd"><td><code>72.0.2+build1-0ubuntu0.18.04.1</code></td><td>为软件包的版本</td></tr><tr class="even"><td><code>amd64</code></td><td>软件包的架构；还可能为<code>i386</code>、<code>all</code>等</td></tr><tr class="odd"><td><code>Safe and easy web browser from Mozilla</code></td><td>在软件仓库中对这个软件包的描述</td></tr></tbody></table><div class="note warning"><p>请避免直接使用 <code>dpkg -i</code> 安装 deb 包。 在绝大多数情况下，都应该使用 <code>apt</code> 来安装 deb 文件。 如果不小心执行了 <code>dpkg -i</code> 导致系统出现依赖问题，可以尝试通过如下的方式调用 <code>apt</code> 帮助修复依赖管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -f install</span><br></pre></td></tr></table></figure></div><h2 id="环境变量">环境变量</h2><p>我们不能每次在需要编译程序的时候输入如此长的路径找到 <code>clang</code> 和 <code>clang++</code>，而更希望的是能够像 <code>apt</code> 那样在任何地方都可以直接运行。</p><p>我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将 clang+llvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04 目录下的所有内容复制到 /usr/local/ 下</span><br><span class="line">sudo cp -R * /usr/local/</span><br></pre></td></tr></table></figure><p>为什么是 <code>/usr/local</code> 呢？因为 <code>/usr/local/bin</code> 处在 PATH 环境变量下。当我们在终端输入命令时，终端会先判断是否为终端的内建命令，如果不是，则会在 $PATH 环境变量中包含的目录下进行查找。因此，只要我们将一个可执行文件放入了 $PATH 中的目录下面，我们就可以像 <code>apt</code> 一样，在任意地方调用我们的程序。 通过这个命令可以看到当前的 PATH 环境变量有哪些目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure><p>在上面的复制过程中，源目录和目标目录的两个 <code>bin</code> 目录会相互合并，<code>clang</code> 和 <code>clang++</code> 两个可执行文件也就被复制到了 <code>/usr/local/bin/</code> 目录中。这样子也就达到了我们希望能够在任意地方调用我们的可执行文件的目的。此外，在复制的时候 lib、doc 等文件夹也会和 <code>/usr/local</code> 下的对应目录合并，将 clang 的库和文档加到系统当中。</p><h2 id="模式匹配">模式匹配</h2><p>许多现代的 shell 都支持一定程度的模式匹配。举个例子，bash 的匹配模式被称为 <a href="https://mywiki.wooledge.org/glob">glob</a>，支持的操作如下：</p><table><thead><tr class="header"><th>模式</th><th>匹配的字串</th></tr></thead><tbody><tr class="odd"><td><code>*</code></td><td>任意字串</td></tr><tr class="even"><td><code>foo*</code></td><td>匹配 foo 开头的字串</td></tr><tr class="odd"><td><code>*x*</code></td><td>匹配含 x 的字串</td></tr><tr class="even"><td><code>?</code></td><td>一个字符</td></tr><tr class="odd"><td><code>a?b</code></td><td><code>acb</code>、<code>a0b</code> 等，但不包含 <code>a00b</code></td></tr><tr class="even"><td><code>*.[ch]</code></td><td>以 .c 或 .h 结尾的文件</td></tr></tbody></table><div class="note info no-icon"><p>除了上面提到的 glob，bash 还支持 <a href="https://www.linuxjournal.com/content/bash-extended-globbing">extglob</a>，不过需要先用 <code>shopt -s extglob</code> 启用。</p></div><h2 id="进程">进程</h2><h3 id="htop">htop</h3><p>Htop 可以简单方便查看当前运行的所有进程，以及系统 CPU、内存占用情况与系统负载等信息。</p><p>使用鼠标与键盘都可以操作 htop。Htop 界面的最下方是一些选项，使用鼠标点击或按键盘的 F1 至 F10 功能键可以选择这些功能，常用的功能例如搜索进程（F3, Search）、过滤进程（F4, Filter，使得界面中只有满足条件的进程）、切换树形结构/列表显示（F5, Tree/List）等等。</p><p><strong>进程标识符</strong>（PID，Process Identifier（是一个数字，是进程的唯一标识。在 htop 中，最左侧一列即为 PID。当用户想挂起、继续或终止进程时可以使用 PID 作为索引。</p><p>在 htop 中，直接单击绿色条内的 PID 栏，可以将进程顺序按照 PID 升序排列，再次点击为降序排列，同理可应用于其他列。</p><div class="note info no-icon"><p>按照 PID 排序时，我们可以观察系统启动的过程。Linux 系统内核从引导程序接手控制权后，开始内核初始化，随后变为 <strong>init_task</strong>，初始化自己的 PID 为 0。随后创建出 1 号进程（init 程序，目前一般为 systemd）衍生出用户空间的所有进程，创建 2 号进程 kthreadd 衍生出所有内核线程。随后 0 号进程成为 idle 进程，1 号、2 号并非特意预留，而是产生进程的自然顺序使然。</p><p>由于 kthreadd 运行于内核空间，故需按大写 K（Shift + k）键显示内核进程后才能看到。然而无论如何也不可能在 htop 中看到 0 号进程本体，只能发现 1 号和 2 号进程的 PPID 是 0。</p></div><h4 id="linux对进程的分类">linux对进程的分类</h4><p><code>Status: R: running; S: sleeping; T: traced/stopped; Z: zombie; D: disk sleep</code> S 对应的 sleeping 又称 interruptible sleep，字面意思是「可以被中断」；而 D 对应的 disk sleep 又称 uninterruptible sleep，不可被中断，一般是因为阻塞在磁盘读写操作上。 Zombie 是僵尸进程，该状态下进程已经结束，只是仍然占用一个 PID，保存一个返回值。而 traced/stopped 状态正是下文使用 Ctrl + Z 导致的挂起状态（大写 T），或者是在使用 gdb 等调试（Debug）工具进行跟踪时的状态（小写 t）。</p><table><thead><tr class="header"><th>状态</th><th>缩写表示</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>Running</td><td>R</td><td>正在运行/可以立刻运行</td></tr><tr class="even"><td>Sleeping</td><td>S</td><td>可以被中断的睡眠</td></tr><tr class="odd"><td>Disk Sleep</td><td>D</td><td>不可被中断的睡眠</td></tr><tr class="even"><td>Traced / Stopped</td><td>T</td><td>被跟踪/被挂起的进程</td></tr><tr class="odd"><td>Zombie</td><td>Z</td><td>僵尸进程</td></tr></tbody></table><h3 id="ps">ps</h3><p>ps（<strong>p</strong>rocess <strong>s</strong>tatus）是常用的输出进程状态的工具。直接调用 <code>ps</code> 仅会显示本终端中运行的相关进程。如果需要显示所有进程，对应的命令为 <code>ps aux</code>。</p><h3 id="优先级与-nice-值">优先级与 nice 值</h3><p>有了进程，谁先运行？谁给一点时间就够了，谁要占用大部分 CPU 时间？这又是如何决定的？这些问题之中体现着优先权的概念。如果说上面所介绍的的那些进程属性描述了进程的控制信息，那么<strong>优先级</strong>则反映操作系统调度进程的手段。在 htop 的显示中有两个与优先级有关的值：Priority（PRI）和 <strong>nice（NI）</strong>。以下主要介绍用户层使用的 nice 值。</p><p>Nice 值越高代表一个进程对其它进程越 "nice"（友好），对应的优先级也就更低。Nice 值最高为 19，最低为 -20。通常，我们运行的程序的 nice 值为 0。我们可以打开 htop 观察与调整每个进程的 nice 值。</p><p>用户可以使用 <code>nice</code> 命令在运行程序时指定优先级，而 <code>renice</code> 命令则可以重新指定优先级。当然，若想调低 nice 值，还需要 <code>sudo</code>（毕竟不能随便就把自己的优先级设置得更高，不然对其他的用户不公平）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nice -n 10 vim # 以 10 为 nice 值运行 vim</span><br><span class="line">renice -n 10 -p 12345 # 设置 PID 为 12345 的进程的 nice 值为 10</span><br></pre></td></tr></table></figure><div class="note info no-icon"><p>如果你在 htop 中测试调整进程的 nice 值，可能会发现一个公式：<code>PRI = nice + 20</code>。这对于普通进程是成立的——普通进程的 PRI 会被映射到一个非负整数。</p><p>但在正常运行的 Linux 系统中，我们可能会发现有些进程的 PRI 值是 RT，或者是负数。这表明对应的进程有更高的实时性要求（例如内核进程、音频相关进程等），采用了与普通进程不同的调度策略，优先级也相应更高。</p></div><h3 id="用户进程控制">用户进程控制</h3><p><img src="https://101.lug.ustc.edu.cn/Ch04/images/signal_slide.png" /> 信号是 Unix 系列系统中进程之间相互通信的一种机制。发送信号的 Linux 命令叫作 <code>kill</code>。被称作 "kill" 的原因是：早期信号的作用就是关闭（杀死）进程。</p><h3 id="前后台">前后台</h3><p><img src="https://101.lug.ustc.edu.cn/Ch04/images/bg.gif" /> 默认情况下，在 shell 中运行的命令都在前台运行，如果需要在后台运行程序，需要在最后加上 <code>&amp;</code> 而如果需要将前台程序切换到后台，则需要按下 Ctrl + Z 发送 SIGTSTP 使进程挂起，控制权还给 shell 我们可以使用 <code>jobs</code> 命令，看到当前 shell 上所有相关的进程 任务前的代号在 fg，bg，乃至 kill 命令中发挥作用。使用时需要在前面加 <code>%</code>，如将 2 号进程放入后台，则使用 <code>bg %2</code> <div class="note info no-icon"><p>然而我们也许会关注一个细节，在图中显示的编号后面跟着的加号和减号是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1]  - running    ./signal handle</span><br><span class="line">[2]  + suspended  ping localhost</span><br></pre></td></tr></table></figure><p>这里的加号标记了 fg 和 bg 命令默认作用到的任务为 2，所以这里 <code>bg %2</code> 也可以直接简化为 <code>bg</code>。减号表示如果加号标记的进程退出了，它就会成为加号标记进程。我们也可以用 <code>%+</code> 和 <code>%-</code> 指代这两个任务。</p></div></p><h3 id="终止进程">终止进程</h3><p>标准的终止进程信号是 SIGTERM，意味着一个进程的自然死亡</p><ul><li>htop 中自带向进程发送信号的功能。按下 K 键，在左侧提示栏中选择需要的信号，按下回车发送。同时可以使用空格对进程进行标记，被标记的进程将改变显示颜色。此时重复上述过程，可对被标记进程批量发送信号。</li><li>如果不加任何参数，只有 PID，<code>kill</code> 命令将自动使用 15（SIGTERM）作为信号参数。</li><li>在信号中，9 代表 SIGKILL，收到这个信号之后，程序会立刻退出。在使用时，直接 <code>kill -9 PID</code> 即可。</li></ul><h3 id="其他类-kill-命令">其他类 kill 命令</h3><ul><li><p><code>pgrep</code> / <code>pkill</code> 后面接模糊名称，实际上类似于对名称进行 <code>grep</code> 命令。<code>pgrep</code> 仅列出搜索到的进程名称符合用户输入的进程标识符，而 <code>pkill</code> 会根据用户的输入向进程发送信号。</p></li><li><p><code>killall</code> 与 <code>pkill</code> 有一些类似，会向指定名字的进程发送信号。</p></li><li><p><code>xkill</code> <code>xkill</code> 是针对窗口的 kill，运行该命令后，鼠标点击程序对应的窗口，就可以杀死该程序。</p></li></ul><h3 id="脱离终端">脱离终端</h3><p>如果你使用过 SSH 连接到远程服务器执行任务，那么你会发现，你在 shell 中执行的程序在 SSH 断开之后会被关闭。这是因为终端一旦被关闭会向其中每个进程发送 SIGHUP（Signal hangup），而 SIGHUP 的默认动作即退出程序运行。</p><h4 id="nohup">nohup</h4><p>nohup，字面含义，就是「不要被 SIGHUP 影响」。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nohup ping 101.ustclug.org &amp;</span><br><span class="line">[1] 19258</span><br><span class="line">nohup: ignoring input and appending output to &#x27;/home/ustc/nohup.out&#x27;</span><br></pre></td></tr></table></figure><p>在需要屏蔽 SIGHUP 的程序前添加 nohup，则运行时的输出将被<a href="https://101.lug.ustc.edu.cn/Ch06/#redirect">重定向</a>到 nohup.out，也可以通过重定向手段自定义输出的文件。</p><h2 id="服务">服务</h2><h3 id="服务管理">服务管理</h3><p>目前绝大多数 Linux 发行版的 init 方案都是 systemd，其管理系统服务的命令是 <code>systemctl</code>。</p><p>若想了解全部服务内容，可以运行 <code>systemctl list-units</code> 来查看。该命令将显示所有 systemd 管理的单元，同时右面还会附上一句注释来表明该服务的任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ tldr systemctl</span><br><span class="line">systemctl</span><br><span class="line">Control the systemd system and service manager.</span><br><span class="line"></span><br><span class="line">    - List failed units:  # 列出运行失败的服务</span><br><span class="line">    systemctl --failed</span><br><span class="line"></span><br><span class="line">    - Start/Stop/Restart/Reload a service:  # 开启/关闭/重启/重载服务。Reload 代表重载配置文件而不重启进程。</span><br><span class="line">    systemctl start/stop/restart/reload &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Show the status of a unit:  # 显示服务状态</span><br><span class="line">    systemctl status &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Enable/Disable a unit to be started on bootup:  # 设置（Enable）/取消（Disable）服务开机自启</span><br><span class="line">    systemctl enable/disable &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Mask/Unmask a unit, prevent it to be started on bootup:  # 阻止/取消阻止服务被 enable</span><br><span class="line">    systemctl mask/unmask &#123;&#123;unit&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - Reload systemd, scanning for new or changed units:  # 重载 systemd，需要在创建或修改服务文件后执行</span><br><span class="line">    systemctl daemon-reload</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info no-icon"><p>wsl默认不支持systemctl,可以使用传统的service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ tldr service</span><br><span class="line">service</span><br><span class="line">Manage services by running init scripts.</span><br><span class="line">The full script path should be omitted (/etc/init.d/ is assumed).</span><br><span class="line"></span><br><span class="line"> - Start/Stop/Restart/Reload service (start/stop should always be available):</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; &#123;&#123;start|stop|restart|reload&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Do a full restart (runs script twice with start and stop):</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; --full-restart</span><br><span class="line"></span><br><span class="line"> - Show the current status of a service:</span><br><span class="line">   service &#123;&#123;init_script&#125;&#125; status</span><br><span class="line"></span><br><span class="line"> - List the status of all services:</span><br><span class="line">   service --status-all</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者手动打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[boot]</span><br><span class="line">systemd=true</span><br></pre></td></tr></table></figure><p>然后在windows终端wsl --shutdown再重启</p></div><div class="note info no-icon"><p><strong>编写 .service 文件并运行（以 Jupyter Notebook 为例）</strong></p><p>Jupyter Notebook 是基于浏览器的交互式编程平台，在数据科学领域非常常用。</p><p>首先使用文本编辑器在 <code>/etc/systemd/system</code> 目录下创建一个名为 <code>jupyter.service</code> 的文件。并填入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jupyter Notebook    # 该服务的简要描述</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">PIDFile=/run/jupyter.pid        # 用来存放 PID 的文件</span><br><span class="line">ExecStart=/usr/local/bin/jupyter-notebook --allow-root</span><br><span class="line">                                # 使用绝对路径标明的命令及命令行参数</span><br><span class="line">WorkingDirectory=/root          # 服务启动时的工作目录</span><br><span class="line">Restart=always                  # 重启模式，这里是无论因何退出都重启</span><br><span class="line">RestartSec=10                   # 退出后多少秒重启</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target      # 依赖目标，这里指进入多用户模式后再启动该服务</span><br></pre></td></tr></table></figure><p>将写好的配置文件保存为 <code>/etc/systemd/system/jupyter.service</code>，然后运行 <code>systemctl daemon-reload</code>，就可以使用 <code>systemctl</code> 命令来管理这个服务了，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start jupyter</span><br><span class="line">systemctl stop jupyter</span><br><span class="line">systemctl enable jupyter  # enable 表示标记服务的开机自动启动</span><br><span class="line">systemctl disable jupyter # 取消自启</span><br></pre></td></tr></table></figure></div><h3 id="例行性任务">例行性任务</h3><p>可以用at，crontab等工具创建例行性任务 详见<a href="https://101.lug.ustc.edu.cn/Ch04/#crontab">linux101</a></p><div class="note info no-icon"></div><h2 id="用户权限和文件系统">用户权限和文件系统</h2><p>可以查看 <code>/etc/passwd</code> 文件，来得到系统中用户的配置信息。 普通用户的文件存储于位于 <code>/home/username/</code>路径</p><div class="note info no-icon"><p>你是否常常忘记敲 <code>sudo</code>，结果还要把后面的整条命令重新敲一遍？在发现权限不足之后有一个方便的「补救方案」：<code>sudo !!</code>，效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ apt update</span><br><span class="line">Reading package lists... Done</span><br><span class="line">E: Could not open lock file /var/lib/apt/lists/lock - open (13: Permission denied)</span><br><span class="line">E: Unable to lock directory /var/lib/apt/lists/</span><br><span class="line">W: Problem unlinking the file /var/cache/apt/pkgcache.bin - RemoveCaches (13: Permission denied)</span><br><span class="line">W: Problem unlinking the file /var/cache/apt/srcpkgcache.bin - RemoveCaches (13: Permission denied)</span><br><span class="line">$ sudo !!</span><br><span class="line">sudo apt update</span><br><span class="line">[sudo] password for ustc:</span><br><span class="line">Hit:1 http://mirrors.ustc.edu.cn/ubuntu bionic InRelease</span><br><span class="line">（以下内容省略）</span><br></pre></td></tr></table></figure><p>其实，在 Shell 中，<code>!!</code> 即代表上一条命令，可以和其他的命令结合使用。</p></div><p>以 <code>root</code> 之外的用户的身份执行命令：加上 <code>-u 用户名</code> 的参数即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u nobody id</span><br><span class="line">uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)</span><br></pre></td></tr></table></figure><h3 id="用户组">用户组</h3><p>用户组是用户的集合。通过用户组机制，可以为一批用户设置权限。可以使用 <code>groups</code> 命令，查看自己所属的用户组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groups</span><br><span class="line">ustc adm cdrom sudo dip plugdev lxd</span><br></pre></td></tr></table></figure><p>用户组和用户一样，也有编号：GID (Group ID)。 <div class="note info no-icon"><p><code>adduser</code> 是 Debian 及其衍生发行版中附带的一个方便的用户管理脚本。它可以用来向系统添加用户、添加组，以及将用户加入组。输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser 用户名</span><br></pre></td></tr></table></figure><p>即可添加此用户。而输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser --group 组名</span><br></pre></td></tr></table></figure><p>即可添加此用户组。将用户加入指定用户组也非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser 用户名 组名</span><br></pre></td></tr></table></figure><p>在通过 <code>adduser</code> 创建了新的用户后，直接使用 <code>sudo</code> 以 <code>root</code> 身份运行程序可能会得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">[sudo] password for ustc:</span><br><span class="line">ustc is not in the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure><p>除了可以通过 <code>visudo</code> 命令编辑 <code>sudoers</code> 文件外，还可以直接通过将新的用户加入到 <code>sudo</code> 用户组，以能够使用 <code>sudo</code> 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser ustc sudo</span><br></pre></td></tr></table></figure><p>再次切换到新的用户即可看到使用 sudo 的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="line">See &quot;man sudo_root&quot; for details.</span><br></pre></td></tr></table></figure></div></p><h2 id="文本处理">文本处理</h2><h3 id="正则表达式">正则表达式</h3><p><a href="https://regex101.com/">在线编辑正则表达式</a> 正则表达式（regular expression）描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。</p><p>特殊字符表：</p><table><thead><tr class="header"><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>[]</code></td><td>方括号表达式，表示匹配的字符集合，例如 <code>[0-9]</code>、<code>[abcde]</code></td></tr><tr class="even"><td><code>()</code></td><td>标记子表达式起止位置</td></tr><tr class="odd"><td><code>*</code></td><td>匹配前面的子表达式零或多次</td></tr><tr class="even"><td><code>+</code></td><td>匹配前面的子表达式一或多次</td></tr><tr class="odd"><td><code>?</code></td><td>匹配前面的子表达式零或一次</td></tr><tr class="even"><td><code>\</code></td><td>转义字符，除了常用转义外，还有：<code>\b</code> 匹配单词边界；<code>\B</code> 匹配非单词边界等</td></tr><tr class="odd"><td><code>.</code></td><td>匹配除 <code>\n</code>（换行）外的任意单个字符</td></tr><tr class="even"><td><code>&#123;&#125;</code></td><td>标记限定符表达式的起止。例如 <code>&#123;n&#125;</code> 表示匹配前一子表达式 n 次；<code>&#123;n,&#125;</code> 匹配至少 n 次；<code>&#123;n,m&#125;</code> 匹配 n 至 m 次</td></tr><tr class="odd"><td><code>\|</code></td><td>表明前后两项二选一</td></tr><tr class="even"><td><code>$</code></td><td>匹配字符串的结尾</td></tr><tr class="odd"><td><code>^</code></td><td>匹配字符串的开头，在方括号表达式中表示不接受该方括号表达式中的字符集合</td></tr></tbody></table><p>若是想要匹配特殊字符本身，需要在之前加上转义字符 <code>\</code>。 <div class="note info no-icon"><p>匹配正整数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1-9][0-9]*</span><br></pre></td></tr></table></figure><p>匹配仅由 26 个英文字母组成的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z]+$</span><br></pre></td></tr></table></figure><p>匹配 Chapter 1-99 或 Section 1-99</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(Chapter|Section) [1-9][0-9]&#123;0,1&#125;$</span><br></pre></td></tr></table></figure><p>匹配“ter”结尾的单词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ter\b</span><br></pre></td></tr></table></figure><p>匹配rgb代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^#([0-9]&#123;6&#125;$|([0-9]|[A-F])&#123;3&#125;$)</span><br></pre></td></tr></table></figure></div></p><h4 id="基本扩展正则表达式">基本/扩展正则表达式</h4><p>基本正则表达式（Basic Regular Expressions, BRE）和扩展正则表达式（Extended Regular Expressions, ERE）是两种 POSIX 正则表达式风格。</p><p>BRE 可能是如今最老的正则风格了，对于部分特殊字符（如 <code>+</code>, <code>?</code>, <code>|</code>, <code>&#123;</code>）需要加上转义符 <code>\</code> 才能表达其特殊含义。</p><p>ERE 与如今的现代正则风格较为一致，相比 BRE，上述特殊字符默认发挥特殊作用，加上 <code>\</code> 之后表达普通含义。</p><h4 id="懒惰和贪婪">懒惰和贪婪</h4><p>使用 <code>*</code> <code>+</code> 的时候默认是贪婪模式，即尽可能匹配更多的子表达式。在 <code>*</code> <code>+</code> 之后加上 <code>?</code> 变为懒惰模式，即尽可能匹配更少的子表达式。</p><p>例如：<code>123456456</code></p><p>贪婪：<code>1.+6</code> -&gt; <code>123456456</code></p><p>懒惰：<code>1.+?6</code> -&gt; <code>123456</code> 后向引用可以将之前匹配到的具体内容再次利用。在正则表达式中，<code>()</code> 以及它们包含的内容为一个分组，每个分组默认拥有一个组号。</p><p>组号分配规则：</p><ul><li>0 代表整个表达式</li><li>从左至右，按左括号的出现顺序分配，第一个为 1，第二个为 2，以此类推</li><li>扫描两遍，第一次只分配未命名的组，第二次只分配命名的组。即任意命名组的组号都大于未命名的组号</li></ul><h4 id="后向引用">后向引用</h4><div class="note info no-icon"><p>示例</p><p><code>\b(\w+)\b\s+\1\b</code> 可以用来匹配用空白字符分割的两个重复的单词（例如 <code>linux linux</code>），其中 <code>\1</code> 是对组号为 1 的组 <code>(\w+)</code> 的引用。</p><p><code>\b(?'Word'\w+)\b\s+\k'Word'\b</code> 也可以起到同样的效果，其中 <code>?'Word'</code> 用于命名组，<code>\k'Word'</code> 用于引用组。</p></div><h4 id="零宽断言">零宽断言</h4><p>零宽断言用于查找某些内容进行定位，但内容并不放入匹配结果，就像 <code>\b</code> <code>^</code> <code>$</code> 的定位一样。<code>(?=exp)</code> 用于匹配表达式 <code>exp</code> 前面的位置，<code>(?&lt;=exp)</code> 用于匹配后面的位置。</p><h4 id="拓展阅读">拓展阅读</h4><p><a href="https://zhuanlan.zhihu.com/p/46294360">乱用正则引发的惨案</a></p><h3 id="其他的文本处理工具">其他的文本处理工具</h3><h4 id="grep">grep</h4><p>grep 全称 Global Regular Expression Print，是一个强大的文本搜索工具，可以在一个或多个文件中搜索指定 pattern 并显示相关行。</p><p>grep 默认使用 BRE，要使用 ERE 可以使用 <code>grep -E</code> 或 egrep。</p><p>命令格式：<code>grep [option] pattern file</code></p><p>一些用法：</p><ul><li><code>-n</code>：显示匹配到内容的行号</li><li><code>-v</code>：显示不被匹配到的行</li><li><code>-i</code>：忽略字符大小写</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls /bin | grep -n &quot;^man$&quot;  # 搜索内容仅含 man 的行，并且显示行号</span><br><span class="line">ls /bin | grep -v &quot;[a-z]\|[0-9]&quot;  # 搜索不含小写字母和数字的行</span><br><span class="line">ls /bin | grep -iv &quot;[A-Z]\|[0-9]&quot;  # 搜索不含字母和数字的行</span><br></pre></td></tr></table></figure><h4 id="sed">sed</h4><p>sed 全称 Stream EDitor，即流编辑器，可以方便地对文件的内容进行逐行处理。</p><p>sed 默认使用 BRE，要使用 ERE 可以 sed -E。</p><p>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed [OPTIONS] &#x27;command&#x27; file(s)</span><br><span class="line">sed [OPTIONS] -f scriptfile file(s)</span><br></pre></td></tr></table></figure><p>此处的 command 和 scriptfile 中的命令均指的是 sed 命令。</p><p>常见 sed 命令：</p><ul><li>s 替换</li><li>d 删除</li><li>c 选定行改成新文本</li><li>a 当前行下插入文本</li><li>i 当前行上插入文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e &quot;seD\nIS\ngOod&quot; &gt; sed_demo</span><br><span class="line">$ cat sed_demo</span><br><span class="line">seD</span><br><span class="line">IS</span><br><span class="line">gOod</span><br><span class="line">$ sed &quot;2d&quot; sed_demo  # 删除第二行</span><br><span class="line">seD</span><br><span class="line">gOod</span><br><span class="line">$ sed &quot;s/[a-z]/~/g&quot; sed_demo  # 替换所有小写字母为 ~</span><br><span class="line">~~D</span><br><span class="line">IS</span><br><span class="line">~O~~</span><br><span class="line">$ sed &quot;3cpErfeCt&quot; sed_demo  # 选定第三行，改成 pErfeCt</span><br><span class="line">seD</span><br><span class="line">IS</span><br><span class="line">pErfeCt</span><br></pre></td></tr></table></figure><h4 id="awk">awk</h4><p>awk 是一种用于处理文本的编程语言工具，名字来源于三个作者的首字母。相比 sed，awk 可以在逐行处理的基础上，针对列进行处理。默认的列分隔符号是空格，其他分隔符可以自行指定。</p><p>awk 使用 ERE。</p><p>命令格式：<code>awk [options] 'pattern &#123;action&#125;' [file]</code></p><p>awk 逐行处理文本，对符合的 patthern 执行 action。需要注意的是，awk 使用单引号时可以直接用 <code>$</code>，使用双引号则要用 <code>\$</code>。</p><p>一些示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat awk_demo</span><br><span class="line">Beth    4.00    0</span><br><span class="line">Dan     3.75    0</span><br><span class="line">kathy   4.00    10</span><br><span class="line">Mark    5.00    20</span><br><span class="line">Mary    5.50    22</span><br><span class="line">Susie   4.25    18</span><br><span class="line">$ # 选择第三列值大于 0 的行，对每一行输出第一列的值和第二第三列的乘积</span><br><span class="line">$ awk &#x27;$3 &gt;0 &#123; print $1, $2 * $3 &#125;&#x27; awk_demo</span><br><span class="line">kathy 40</span><br><span class="line">Mark 100</span><br><span class="line">Mary 121</span><br><span class="line">Susie 76.5</span><br></pre></td></tr></table></figure><p>示例中 <code>$1</code>，<code>$2</code>，<code>$3</code> 分别指代本行的第 1、2、3 列。特别地，$0 指代本行。</p><p>awk 语言是「图灵完全」的，这意味着理论上它可以做到和其他语言一样的事情。这里我们不仅可以对每行进行操作，还可以定义变量，将前面处理的状态保存下来，以下是一个求和的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; sum = 0 &#125; &#123; sum += $2 * $3 &#125; END &#123; print sum &#125;&#x27; awk_demo</span><br><span class="line">337.5</span><br></pre></td></tr></table></figure><h4 id="trsort">tr,sort</h4><p>除此之外，tr可用于进行简单的预处理，sort可以用于进行简单的排序、</p><h2 id="shell环境">shell环境</h2><p>组命令：</p><ul><li><p>使用 <code>&#123; 命令1; 命令2; … &#125;</code>，组命令在 shell 内执行，不会产生新的进程，注意花括号和命令之间的空格。</p></li><li><p>使用 <code>(命令1; 命令2; …)</code>，组命令会建立独立的 shell 子进程来执行组命令，这里的圆括号周围并不需要空格。</p></li></ul><p>可以在脚本开头加上 <code>set -u</code> 来实现使用未定义变量报错，否则会默认成空值</p><h3 id="位置参数">位置参数</h3><ul><li>Shell 解释用户的命令时，把命令程序名后面的所有字串作为程序的参数。分别对应 <code>$1</code>、<code>$2</code>、<code>$3</code>、……、<code>$9</code>，程序名本身对应 <code>$0</code>。</li><li>可用 <code>shift &lt;n&gt;</code> 命令，丢弃开头的 n 个位置变量，改变 <code>$1</code>、<code>$2</code>、<code>$3</code> 等的对应关系。</li><li>可用 <code>set</code> 命令，重置整个位置变量列表，从而给 <code>$1</code>、<code>$2</code>、<code>$3</code> 等赋值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ set one two three</span><br><span class="line">$ echo $1 $2 $3</span><br><span class="line">one two three</span><br><span class="line">$ shift 2</span><br><span class="line">$ echo $1 $2 $3</span><br><span class="line">three</span><br><span class="line">$ # 此时 $2 和 $3 已不存在</span><br></pre></td></tr></table></figure><h3 id="特殊变量">特殊变量</h3><table><thead><tr class="header"><th>特殊变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>$#</code></td><td>命令行上的参数个数，不包括 <code>$0</code></td></tr><tr class="even"><td><code>$?</code></td><td>最后命令的退出代码，0 表示成功，其它值表示失败</td></tr><tr class="odd"><td><code>$$</code></td><td>当前进程的 PID</td></tr><tr class="even"><td><code>$!</code></td><td>最近一个后台运行进程的进程号</td></tr><tr class="odd"><td><code>$*</code></td><td>命令行所有参数构成的一个字符串</td></tr><tr class="even"><td><code>$@</code></td><td>用双引号括起的命令行各参数拼接构成的一个字符串</td></tr></tbody></table><h3 id="特殊字符">特殊字符</h3><ul><li><p>反斜杠，消除单个字符的特殊含义。</p><ul><li>包含空白字符（空格和制表符）、反斜杠本身、各种引号，以及 <code>$</code>、<code>!</code> 等。</li><li>与其他语言不同，shell 中反斜杠不会将普通字符转义为其他含义（例如 <code>\n</code> 不会被视作换行符）。</li></ul></li><li><p>使用双引号包裹字符串可以消除空白字符切分参数的特殊含义，但是很多其他特殊字符的特殊含义仍然保留。双引号也被称为「弱引用」。</p></li><li><p>单引号，能消除所有特殊字符的特殊含义，包括反斜杠，因此单引号字符串中不能使用反斜杠转义单引号本身。单引号也被称为「强引用」。</p></li><li><p>反引号（<code>`</code>）括起的字符串，被 shell 解释为命令，执行时用命令输出结果代替整个反引号对界限部分。</p><ul><li>与反引号相同的语法是 <code>$(command)</code>，它的好处是界限更明确，且可以嵌套。因此编写新脚本时，更建议使用此语法。</li></ul></li></ul><h3 id="语法">语法</h3><p>具体语法可参考<a href="https://101.lug.ustc.edu.cn/Ch06/#bash-arithmetic">linux101</a></p><h2 id="拓展阅读-1">拓展阅读</h2><h3 id="进程与会话">进程与会话</h3><p>Fork 是类 UNIX 中创建进程的基本方法：将当前的进程完整复制一份。新进程和旧进程唯一的区别是 <code>fork()</code> 的返回值不同。程序员可以根据其返回值为新旧进程设置不同的逻辑。</p><p>除了最开始的 0 号进程外，绝大多数情况下其他进程是由另一个进程通过 fork 产生的。这里产生进程的一方为<strong>父进程</strong>，被产生的是<strong>子进程</strong>。在 Linux 中，父进程可以等待子进程，接收子进程退出信号以及返回值。 父进程如果先于子进程退出，产生孤儿进程，会被0号进程(init)接管 子进程先退出但父进程没有回应，产生僵尸进程，会被系统定时清理</p><p><strong>进程组</strong>大体上是执行同一工作的进程形成的一个团体，通常是由于父进程 fork 出子进程后子进程继承父进程的组 ID 而逐渐形成。</p><p><strong>会话</strong> (session) 可以说是面向用户的登录出现的概念。当用户从终端登录进入 shell，就会以该 shell 为会话首进程展开本次会话。一个会话中通常包含着多个进程组，分别完成不同的工作。用户退出时，这个会话会结束，但有些进程仍然以该会话标识符 (session ID) 驻留系统中继续运行。</p><table><thead><tr class="header"><th>进程属性</th><th>意义/目的</th></tr></thead><tbody><tr class="odd"><td>PID</td><td>Process ID，标识进程的唯一性。</td></tr><tr class="even"><td>PPID</td><td>Parent PID，标识进程父子关系。</td></tr><tr class="odd"><td>PGID</td><td>Process Group ID，标识共同完成一个任务的整体。</td></tr><tr class="even"><td>TPGID</td><td>标识一组会话中处于前台（与用户交流）的进程（组）。</td></tr><tr class="odd"><td>SID</td><td>Session ID，标识一组会话，传统意义上标识一次登录所做的任务的集合，如果是与具体登录无关的进程，其 SID 被重置。</td></tr></tbody></table><h3 id="终端-terminal-与控制台-console">终端 (Terminal) 与控制台 (Console)</h3><p>在上世纪六十年代，个人计算机尚未开始发展，用户使用计算机的一种常见方式就是通过终端，与远程的服务器连接交互。当时键盘和显示器连为一体，称为终端（terminal）。而主机自带的一套键盘与屏幕只能给系统管理员使用，称为控制台 (console)，用来输出启动 debug 信息（现在的 Linux 系统如果因故障而不得不进入单用户修复模式，则只有一个终端 <code>/dev/console</code> 开启）。</p><p>然而随着时代的发展，这种模式逐渐被家庭电脑的分布式主机取代，我们不需要，也没有多套终端了，只有显示器、键盘、鼠标。但是为了向前兼容性，我们需要假装这是一个（甚至多个）终端，所以一般发行版 <code>/dev</code> 目录下有 7 个终端 <code>tty1 ~ tty7</code>，通过 <code>Ctrl + Alt + F1 ~ F7</code> 切换键盘与显示器与哪个终端相对应。</p><p>再后来，随着时代发展，终端需要出现在图形界面上了，然而承载图形界面的也是终端，所以终端里的终端就需要终端模拟器来实现了。由此，出现在图形界面上的终端才叫终端模拟器。</p><p>没有图形界面时，shell 一般为控制台 (tty) 的子进程，在图形界面上 shell 建立在虚拟终端 (pty, pseudo tty) 之上。顺带一提，服务器常用的远程连接工具 <code>ssh</code> 的父进程也是一个 pty。</p><p>参考阅读: <a href="https://www.linuxdashen.com/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%88%E7%AB%AF%E5%90%97%EF%BC%9F">你真的知道什么是终端吗？</a></p><h3 id="文件系统的特殊权限位">文件系统的特殊权限位</h3><p>有三个特殊权限位：setuid, setgid 和 sticky。</p><ul><li><code>setuid</code>: 以文件所属的用户的身份 (UID) 执行此程序。</li><li><code>setgid</code>: 对文件来说，以文件所属的用户组的身份 (GID) 执行此程序；对目录来说，在这个目录下创建的文件的用户组都与此目录本身的用户组一致，而不是创建者的用户组。</li><li><code>sticky</code> (restricted deletion flag): 目录中的所有文件只能由文件所有者（除 <code>root</code> 以外）删除或者移动。一个典型的例子是临时文件夹 <code>/tmp</code>，在此文件夹中你可以创建、修改、重命名、移动、删除自己的文件，但是动不了别人的文件。</li></ul><p><code>/usr/bin/passwd</code> 的文件权限设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 root root 67992 Aug 29  2019 /usr/bin/passwd</span><br></pre></td></tr></table></figure><p>可以看到，本来是执行权限位的地方变成了 <code>s</code>。这代表此文件有 <code>setuid</code> 特殊权限位。在你执行 <code>passwd</code> 的时候，它的实际权限和 <code>root</code> 一样，只是它知道，执行它的人是你（而非 <code>root</code>），所以只提供修改你自己的密码的功能。</p><p>此外，passwd需要知道实际执行自己的用户是谁，在 Linux 中，有两个系统调用可以获取当前进程归属的 UID：<code>getuid()</code> 和 <code>geteuid()</code>。前者对应的是「实际用户」(Real user)，是实际运行（拥有）这个进程的用户，后者对应的是「有效用户」(Effective user)，对应进程拥有的权限。在运行 <code>passwd</code> 的时候，有效用户是 <code>root</code>，所以可以修改 <code>/etc/shadow</code>；而实际用户是你，所以它不会让你修改别人的密码。</p><p>对用户组来说，也有实际用户组 (GID) 和有效用户组 (EGID) 的区别。</p><h3 id="登录-shell和非登录-shell">登录 Shell和非登录 Shell</h3><p>「登录 Shell」是属于你的当前会话操作中的第一个进程，一般是在你输入用户名和密码之后打开的 Shell。常见的场景有：</p><ul><li><code>su -</code> 之后的 Shell。</li><li>SSH 登录机器后的 Shell</li><li>Ctrl + Alt + F[1-7] 之后 TTY 中的 Shell</li></ul><p>而「非登录 Shell」的常见场景：</p><ul><li><code>su</code> 打开的是「非登录 Shell」</li><li>在桌面环境中打开的终端（模拟器），启动的也是「非登录 Shell」</li></ul><p>一般地，「登录 Shell」会额外加载 <code>profile</code> 文件（文件名根据你使用的 Shell 的不同而有区别），且它的 <code>argv[0][0] == '-'</code>（相信你已经学过 C 语言了）。可以用以下方法验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ echo $0  # 查看当前 Shell 的 argv[0] 的值</span><br><span class="line">-bash</span><br><span class="line">$ # 是 Login shell</span><br><span class="line">$ sudo su # 进入 root</span><br><span class="line"># echo $0</span><br><span class="line">bash</span><br><span class="line"># # 是 Non-login shell</span><br></pre></td></tr></table></figure><h3 id="fork炸弹">fork炸弹</h3><p>Fork 炸弹有如下的这种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:()&#123; :|: &amp; &#125;;:</span><br></pre></td></tr></table></figure><p>这是一个函数定义以及对其的调用语句，可以格式化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:()</span><br><span class="line">&#123;</span><br><span class="line">    :|: &amp;</span><br><span class="line">&#125;;</span><br><span class="line">:</span><br></pre></td></tr></table></figure><p>在 Bash 中，<code>:</code>、<code>.</code>、<code>/</code> 等一些字符也能够被用于函数命名，因此，上面的代码等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func()</span><br><span class="line">&#123;</span><br><span class="line">    func | func &amp;</span><br><span class="line">&#125;;</span><br><span class="line">func</span><br></pre></td></tr></table></figure><p>fork 炸弹的核心是函数内容：<code>func | func &amp;</code></p><ul><li>第一个 func 代表递归执行这个函数。</li><li><div class="line-block">代表要将第一个函数的数据结果通过管道传输给后一个函数。</div></li><li>&amp; 代表要在后台执行这一条命令，如果其中一个函数被操作系统回收，其调用产生的子函数并不会被回收。</li></ul><p>于是运行一次这个函数就会创建两个 func 函数的实例，并不断地反复调用。实例的数量会指数爆炸式地增长，最终耗尽系统的资源。</p><h4 id="防范方法">防范方法</h4><p>一个有效的方式(https://101.lug.ustc.edu.cn/Ch06/supplement/#fn:1)是通过修改系统配置，限制一个用户能够拥有的进程数量多少。<code>ulimit -u 30</code> 可以限制当前用户能够拥有的进程数量为 30。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;苏大部分&quot;&gt;苏大部分&lt;/h1&gt;
&lt;h2 id=&quot;文件系统&quot;&gt;文件系统&lt;/h2&gt;
&lt;h3 id=&quot;命名&quot;&gt;命名&lt;/h3&gt;
&lt;p&gt;•除/之外，所有的字符都合法&lt;/p&gt;
&lt;p&gt;•大小写敏感&lt;/p&gt;
&lt;p&gt;•有些字符最好不用，如空格符、制表符、退格符和字符：？, @ # $ &amp;amp; ()  | ; ‘ ’ “ ” &amp;lt; &amp;gt;&lt;/p&gt;
&lt;p&gt;•避免使用＋、－或. 来作为普通文件名的第一个字符&lt;/p&gt;
&lt;p&gt;•可以使用长文件名或目录名（255个字符）&lt;/p&gt;
&lt;p&gt;包括完整路径的文件名不超过4096字符</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="linux" scheme="https://thinklive1.github.io/tags/linux/"/>
    
    <category term="苏州大学" scheme="https://thinklive1.github.io/tags/%E8%8B%8F%E5%B7%9E%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="中国科学技术大学" scheme="https://thinklive1.github.io/tags/%E4%B8%AD%E5%9B%BD%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于伯克利Sysadmin decal的linux笔记</title>
    <link href="https://thinklive1.github.io/2023/10/12/sysadmin/"/>
    <id>https://thinklive1.github.io/2023/10/12/sysadmin/</id>
    <published>2023-10-12T12:54:12.472Z</published>
    <updated>2023-11-27T12:50:13.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell脚本">shell脚本</h1><p>Shell 脚本通常以 shebang 行开头：#!path/to/interpreter。</p><p><code>#!</code>是一个人类可读的 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)#Magic_number">幻数表示</a> <code>0x23 0x21</code>它可以告诉 shell 将文件其余部分的执行传递给 指定翻译。 如果您的脚本作为可执行文件运行（例如 <code>./awesome_shell_script</code>) 加上 shebang 行，那么 shell 将调用 可执行文件（通常是解释器）位于 <code>path/to/interpreter</code>运行你的 脚本。 如果您的脚本作为参数传递给解释器，例如 <code>bash awesome_shell_script</code>，那么 shebang 没有效果并且 <code>bash</code>会处理 脚本的执行。 <span id="more"></span> <strong>为什么这很重要？</strong> shebang 可以被认为是一个有用的部分 执行脚本的关注 <em>如何</em> 元数据传递了用户 给程序的作者。 <code>awesome_shell_script</code>可能是一个 <code>bash</code>脚本，一个 <code>python</code>脚本，一个 <code>ruby</code>脚本等。这个想法是只有脚本的 对于调用的用户来说，行为而不是其实现细节应该重要。</p><p>您可能已经看到过一些变体 <code>#!/bin/sh</code>。 虽然最初参考的是 现代系统上的 Bourne shell <code>sh</code>已经提到了 <a href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html">Shell Command Language</a> ，这是一个具有多种实现的 POSIX 规范。 <code>sh</code>通常符号链接到这些符合 POSIX 标准的 shell 之一 实现 Shell 命令语言。 以 Debian 为例， <code>sh</code>是 符号链接到 shell <code>dash</code>。 重要的是要注意 <code>bash</code>不 **_** 遵守这个标准，虽然运行 <code>bash</code>作为 <code>bash --posix</code>做到了 更合规。</p><h3 id="管道"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#piping"></a>管道</h3><p>我们可以使用 <code>|</code>字符将多个命令链接在一行中。 例如： <code>command1 | command2</code> 将传递的输出 <code>command1</code>作为输入 <code>command2</code>。 我们可以根据需要多次重复此操作。</p><h3 id="循环使用-for"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#looping-with-for"></a>循环使用 <code>for</code></h3><p>Bash 可以使用 for 循环对多个对象重复操作。 语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for VARIABLE in LIST; do</span><br><span class="line"></span><br><span class="line">    CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>缩进不是必需的，但使代码更易于阅读。 这 <code>LIST</code>可以是包含多个文件的目录，也可以是包含多行 init 的文件、文件列表（ <code>file1 file2 file3</code>），甚至是一系列数字（ <code>&#123;start..end&#125;</code>).</p><h2 id="有用的命令"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#useful-commands"></a>有用的命令</h2><p>一些对于完成实验可能有用的命令。 当然，解决问题的方法有很多，并不需要使用这些命令。</p><h3 id="cat"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#cat"></a><code>cat</code></h3><p><code>cat</code> <a href="https://linux.die.net/man/1/cat">打印</a> 将文件 <a href="https://linuxhint.com/bash_stdin_stderr_stdout/">到标准输出</a> 。 对于打印一些内容以通过管道输入其他命令非常有用！</p><h3 id="cut"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#cut"></a><code>cut</code></h3><p><code>cut [options] [filename]</code>提取文件的某些部分（或管道输入） <a href="https://linux.die.net/man/1/cut">参数</a> 根据使用的 。 一些可能有用的：</p><p><code>-d</code>允许我们更改分隔符，或更改字符 <code>cut</code>寻找将字符串分成块。 如果省略该选项， <code>tab</code>用来。</p><p><code>-f</code>允许我们指定与要返回的字段对应的数字，例如 <code>cut -f1 -d" "</code>将返回句子中的第一个单词。 数字后跟一个 <code>-</code>也返回指定字段之后的所有字段，因此 <code>cut -f1- -d" "</code>将返回整个字符串。</p><p><code>--complement</code>告诉 <code>cut</code>返回除 <strong>之外的所有内容。</strong> 指定字段</p><h3 id="grep"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#grep"></a><code>grep</code></h3><p><code>grep [pattern] [filename]</code> <a href="https://linux.die.net/man/1/grep">过滤</a> 并返回文件（或管道输入）中包含指定模式的行。</p><h3 id="sed"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#sed"></a><code>sed</code></h3><p><code>sed</code>可以做 <a href="https://linux.die.net/man/1/sed">很多事情</a> ，比如编辑字符串和匹配正则表达式。 我们可以用 <code>sed</code>将一种模式替换为另一种模式，如下所示：</p><p><code>sed 's/&lt;PATTERN-TO-REPLACE&gt;/&lt;NEW-PATTERN&gt;/g &lt;INPUT&gt;'</code></p><p>sed` 还可以从其他东西获取管道输入，而不是显式输入。</p><p>这 <code>g</code>最后告诉 <code>sed</code>替换所有出现的模式； 如果我们只想替换模式的第一次出现，则可以省略它，或者用数字替换以仅替换一定次数的出现。</p><h3 id="xargs"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a1/#xargs"></a><code>xargs</code></h3><p><code>xargs</code>让我们将命令应用于从管道重定向的输出。 例如， <code>output | xargs command</code>会适用 <code>command</code>到 <code>output</code>。 一些有用的 <a href="https://linux.die.net/man/1/xargs">选项</a> ：</p><p><code>-n1</code>告诉 <code>xargs</code>将命令应用到中的每个项目 <code>output</code>如果输出中有多个项目（例如多个字符串的列表），则一次</p><p><code>-0</code>告诉 <code>xargs</code>用空字符（表示字符串的结尾）分割输出中的项目，而不是使用空格。 搭配 <code>-n1</code>， 这意味着 <code>xargs</code>会将命令应用于每个字符串，而不是将字符串分解为单个单词并将命令应用于每个单词。</p><p>与往常一样，有更多方法可以使用这些命令，因此请使用 Google 或 <a href="https://en.wikipedia.org/wiki/Man_page">手册页</a> 来了解更多信息</p><h2 id="语法">语法</h2><h3 id="shell-变量和类型">Shell 变量和类型</h3><p>与大多数其他编程语言一样， <code>bash</code>促进有状态分配 名称到值作为变量。</p><p>变量可以被赋值 <code>bash</code>语法如下： <code>NAME=value</code>。 请注意 赋值运算符之间缺少空格 <code>=</code>及其操作数。 任务 对空格敏感。</p><p>您可以通过在前面添加一个来检索变量的值 <code>$</code>以它的名字。 获取值 <code>NAME</code>必须完成 <code>$NAME</code>。 这就是所谓的变量 插值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ NAME = &quot;Tux&quot; # Incorrect</span><br><span class="line">-bash: NAME: command not found </span><br><span class="line">$ NAME=&quot;Tux&quot; # Correct</span><br><span class="line">$ echo NAME # Incorrect. We want the value we assigned to NAME, not the text </span><br><span class="line"># NAME itself.</span><br><span class="line">NAME</span><br><span class="line">$ echo $NAME # Correct</span><br><span class="line">Tux</span><br></pre></td></tr></table></figure><p><code>$?</code>保存最近执行的命令的退出代码。 在这个 上下文、退出代码 <code>0</code>一般表示程序已经执行 成功地。 其他 <a href="http://tldp.org/LDP/abs/html/exitcodes.html">退出代码</a> 指的是错误的性质 导致程序失败。</p><p>特殊 <em>位置参数</em> 允许将参数传递到脚本中。 <code>$0</code>是脚本的名称， <code>$1</code>是传递给的第一个参数 脚本， <code>$2</code>是传递给脚本的第二个参数， <code>$3</code>是第三个 论证等 <code>$#</code>给出传递给脚本的参数数量。</p><p>所以 <code>./awesome_shell_script foo bar</code>可以访问 <code>foo</code>从 <code>$1</code>和 <code>bar</code>从 <code>$2</code>.</p><p>Bash 变量是 <em>无类型的</em> 。 它们通常被视为文本（字符串），但是 如果变量包含数字和算术运算，则可以将其视为数字 对其应用操作。 请注意，这与大多数编程不同 语言。 <em>变量</em> 本身没有类型，但 <em>运算符</em> 会处理 在不同的环境下他们的价值观也不同。 换句话说， <code>bash</code>变量是文本，没有任何固有的行为或属性 可以操作的文本，但操作员会解释该文本 根据其内容（数字或无数字？）和上下文 表达。</p><h3 id="算术"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#arithmetic"></a>算术</h3><p>Bash 支持整数算术 <code>let</code>内置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ x=1+1</span><br><span class="line">$ echo $x # Incorrect. We wanted 2, not the text 1+1.</span><br><span class="line">1+1</span><br><span class="line">$ let x=1+1</span><br><span class="line">$ echo $x # Correct</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>注意 <code>let</code>对空格敏感。 操作数和运算符不得 用空格分隔。</p><p><code>bash</code>本身不支持浮点运算，所以我们必须依赖 如果我们想处理十进制数字，请使用外部实用程序。 一个常见的选择 这是 <code>bc</code>。 有趣的事实： <code>bc</code>实际上是它自己的完整语言！</p><p>我们经常访问 <code>bc</code>通过 <em>管道</em> （表示为 <code>|</code>），这允许 将一个命令的输出用作另一命令的输入。 我们包括 <code>-l</code> 选项 <code>bc</code>为了启用浮点运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo 1/2 | bc -l</span><br><span class="line">.50000000000000000000</span><br></pre></td></tr></table></figure><h3 id="test"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#test"></a><code>test</code></h3><p>Bash 脚本经常使用 <code>[</code>（同义词为 <code>test</code>) shell 内置的 表达式的条件评估。 <code>test</code>计算一个表达式并 以任一状态代码退出 <code>0</code>(true) 或状态代码 <code>1</code>（错误的）。</p><p><code>test</code>支持常见的字符串和数字运算符，以及许多 额外的二元和一元运算符在大多数情况下没有直接类似物 其他编程语言。 您可以看到这些运算符的列表，以及 其他有用的信息，通过输入 <code>help test</code>在你的壳里。 的输出 如下所示。 注意 <code>help</code>类似于 <code>man</code>，除非它用于 bash 函数而不是其他程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">$ help test</span><br><span class="line">test: test [expr]</span><br><span class="line">    Exits with a status of 0 (true) or 1 (false) depending on</span><br><span class="line">    the evaluation of EXPR.  Expressions may be unary or binary.  Unary</span><br><span class="line">    expressions are often used to examine the status of a file.  There</span><br><span class="line">    are string operators as well, and numeric comparison operators.</span><br><span class="line"></span><br><span class="line">    File operators:</span><br><span class="line"></span><br><span class="line">        -a FILE        True if file exists.</span><br><span class="line">        -b FILE        True if file is block special.</span><br><span class="line">        -c FILE        True if file is character special.</span><br><span class="line">        -d FILE        True if file is a directory.</span><br><span class="line">        -e FILE        True if file exists.</span><br><span class="line">        -f FILE        True if file exists and is a regular file.</span><br><span class="line">        -g FILE        True if file is set-group-id.</span><br><span class="line">        -h FILE        True if file is a symbolic link.</span><br><span class="line">        -L FILE        True if file is a symbolic link.</span><br><span class="line">        -k FILE        True if file has its `sticky&#x27; bit set.</span><br><span class="line">        -p FILE        True if file is a named pipe.</span><br><span class="line">        -r FILE        True if file is readable by you.</span><br><span class="line">        -s FILE        True if file exists and is not empty.</span><br><span class="line">        -S FILE        True if file is a socket.</span><br><span class="line">        -t FD          True if FD is opened on a terminal.</span><br><span class="line">        -u FILE        True if the file is set-user-id.</span><br><span class="line">        -w FILE        True if the file is writable by you.</span><br><span class="line">        -x FILE        True if the file is executable by you.</span><br><span class="line">        -O FILE        True if the file is effectively owned by you.</span><br><span class="line">        -G FILE        True if the file is effectively owned by your group.</span><br><span class="line">        -N FILE        True if the file has been modified since it was last </span><br><span class="line">read.</span><br><span class="line"></span><br><span class="line">      FILE1 -nt FILE2  True if file1 is newer than file2 (according to</span><br><span class="line">                       modification date).</span><br><span class="line"></span><br><span class="line">      FILE1 -ot FILE2  True if file1 is older than file2.</span><br><span class="line"></span><br><span class="line">      FILE1 -ef FILE2  True if file1 is a hard link to file2.</span><br><span class="line"></span><br><span class="line">    String operators:</span><br><span class="line"></span><br><span class="line">        -z STRING      True if string is empty.</span><br><span class="line"></span><br><span class="line">        -n STRING</span><br><span class="line">        STRING         True if string is not empty.</span><br><span class="line"></span><br><span class="line">        STRING1 = STRING2</span><br><span class="line">                       True if the strings are equal.</span><br><span class="line">        STRING1 != STRING2</span><br><span class="line">                       True if the strings are not equal.</span><br><span class="line">        STRING1 &lt; STRING2</span><br><span class="line">                       True if STRING1 sorts before STRING2 lexicographically.</span><br><span class="line">        STRING1 &gt; STRING2</span><br><span class="line">                       True if STRING1 sorts after STRING2 lexicographically.</span><br><span class="line"></span><br><span class="line">    Other operators:</span><br><span class="line"></span><br><span class="line">        -o OPTION      True if the shell option OPTION is enabled.</span><br><span class="line">        ! EXPR         True if expr is false.</span><br><span class="line">        EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.</span><br><span class="line">        EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.</span><br><span class="line"></span><br><span class="line">        arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,</span><br><span class="line">                       -lt, -le, -gt, or -ge.</span><br><span class="line"></span><br><span class="line">    Arithmetic binary operators return true if ARG1 is equal, not-equal,</span><br><span class="line">    less-than, less-than-or-equal, greater-than, or greater-than-or-equal</span><br><span class="line">    than ARG2.</span><br></pre></td></tr></table></figure><p>我们可以测试整数相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ [ 0 -eq 0 ]; echo $? # exit code 0 means true</span><br><span class="line">0</span><br><span class="line">$ [ 0 -eq 1 ]; echo $? # exit code 1 means false</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>字符串相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ [ zero = zero ]; echo $? # exit code 0 means true</span><br><span class="line">0</span><br><span class="line">$ [ zero = one ]; echo $? # exit code 1 means false</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>以及您可以自由进行的许多其他字符串和数字运算 探索。</p><h3 id="控制结构"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#flow-control"></a>控制结构</h3><p><code>bash</code>包括大多数编程语言典型的控制结构 – <code>if-then-elif-else</code>, <code>while</code> <code>for-in</code>等等。您可以阅读更多有关 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_07.html">条件语句</a> 和 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_09.html">迭代</a> 中的 <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html">Bash 指南 初学者</a> Linux 文档项目 (LDP) 的 。 我们鼓励您 请阅读这些部分，因为本指南仅提供了一些内容的简短摘要 重要特征。</p><h3 id="if-then-elif-else"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#if-then-elif-else"></a>if-then-elif-else</h3><p>if 语句的一般形式 <code>bash</code>是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if TEST-COMMANDS; then</span><br><span class="line"></span><br><span class="line">  CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">elif MORE-TEST-COMMANDS; then</span><br><span class="line"></span><br><span class="line">  MORE-CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">else </span><br><span class="line"></span><br><span class="line">  ALTERNATE-CONSEQUENT-COMMANDS;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>缩进是一种很好的做法，但不是必需的。</p><p>例如，如果我们写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">if [ $1 -eq $2 ]; then</span><br><span class="line">  echo args are equal</span><br><span class="line">else</span><br><span class="line">  echo args are not equal</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>我们看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./awesome_shell_script 0 0</span><br><span class="line">args are equal</span><br><span class="line">$ ./awesome_shell_script 0 1</span><br><span class="line">args are not equal</span><br></pre></td></tr></table></figure><h3 id="尽管"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#while"></a>尽管</h3><p>while 循环的一般形式 <code>bash</code>是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while TEST-COMMANDS; do</span><br><span class="line"></span><br><span class="line">  CONSEQUENT-COMMANDS</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>如果 <code>TEST-COMMANDS</code>退出并带有状态码 <code>0</code>, <code>CONSEQUENT-COMMANDS</code>将要 执行。 这些步骤将重复，直到 <code>TEST-COMMANDS</code>退出时带有一些非零值 地位。</p><p>例如，如果我们写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">n=$1</span><br><span class="line">while [ $n -gt 0 ]; do</span><br><span class="line">  echo $n</span><br><span class="line">  let n=$n-1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>我们看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./awesome_shell_script 5</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b3/#functions"></a>函数</h3><p><code>bash</code> supports functions, albeit in a crippled form relative to many other languages. Some notable differences include:</p><ul><li>函数不 <em>返回</em> 任何内容，它们只是产生输出流（例如 <code>echo</code>到标准输出）</li><li><code>bash</code>严格来说是按值调用。 也就是说，只有原子值（字符串）可以 被传递到函数中。</li><li>变量没有词法作用域。 <code>bash</code>使用一个非常简单的本地系统 范围接近动态范围。</li><li><code>bash</code>没有一流的函数（即没有将函数传递给 其他函数）、匿名函数或闭包。</li></ul><p>功能于 <code>bash</code>定义为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name_of_function() &#123;</span><br><span class="line"></span><br><span class="line">  FUNCTION_BODY</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_of_function $arg1 $arg2 ... $argN</span><br></pre></td></tr></table></figure><p>请注意函数签名中缺少参数。 参数在 <code>bash</code> 函数的处理方式与全局位置参数类似，其中 <code>$1</code> 含有 <code>$arg1</code>, <code>$2</code>含有 <code>$arg2</code>， ETC。</p><p>例如，如果我们写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  echo hello $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo $1</span><br></pre></td></tr></table></figure><p>我们看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./awesome_shell_script world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="实例">实例</h2><p><code>斐波那契</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of fibonacci</span><br><span class="line"></span><br><span class="line">if [ $# -eq 0 ]; then</span><br><span class="line">    echo &quot;fibonacci needs an argument&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">fib() &#123;</span><br><span class="line">    N=&quot;$1&quot;</span><br><span class="line">    if [ -z &quot;$&#123;N##*[!0-9]*&#125;&quot; ]; then</span><br><span class="line">        echo &quot;fibonacci only makes sense for nonnegative integers&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ &quot;$N&quot; -eq 0 ]; then</span><br><span class="line">        echo 0</span><br><span class="line">    elif [ &quot;$N&quot; -eq 1 ]; then</span><br><span class="line">        echo 1</span><br><span class="line">    else</span><br><span class="line">        echo $(($(fib $((N-2))) + $(fib $((N-1)))))</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib &quot;$1&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">read -p “send: ” FOO</span><br><span class="line"># enter “hi”</span><br><span class="line">echo “sent: $FOO”</span><br><span class="line">sent: hi</span><br><span class="line"></span><br><span class="line">FOO=$(expr 1 + 1)</span><br><span class="line">echo “$FOO”</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">-eq ==</span><br><span class="line">-ne !=</span><br><span class="line">-gt &gt;</span><br><span class="line">-ge &gt;=</span><br><span class="line">-lt &lt;</span><br><span class="line">-le &lt;=</span><br><span class="line"></span><br><span class="line">test zero = zero; echo $?</span><br><span class="line">0 # 0 means true</span><br><span class="line">test zero = one; echo $?</span><br><span class="line">1 # 1 means false</span><br><span class="line"></span><br><span class="line">if [ “$1” -eq 69 ];</span><br><span class="line">then</span><br><span class="line">echo “nice”</span><br><span class="line">elif [ “$1” -eq 42 ];</span><br><span class="line">then</span><br><span class="line">echo “the answer!”</span><br><span class="line">else</span><br><span class="line">echo “wat r numbers”</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">read -p &quot;are you 21?&quot; ANSWER</span><br><span class="line">case &quot;$ANSWER&quot; in</span><br><span class="line">“yes”)</span><br><span class="line">echo &quot;i give u cookie&quot;;;</span><br><span class="line">“no”)</span><br><span class="line">echo &quot;thats illegal&quot;;;</span><br><span class="line">“are you?”)</span><br><span class="line">echo “lets not”;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;please answer&quot;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">NAMES=&quot;a b c d&quot;</span><br><span class="line">for NAME in $NAMES</span><br><span class="line">do</span><br><span class="line">echo &quot;Hello $NAME&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">echo &quot;Hello $NAME&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>Bash 支持整数算术 <code>let</code>内置的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ x=1+1</span><br><span class="line">$ echo $x # Incorrect. We wanted 2, not the text 1+1.</span><br><span class="line">1+1</span><br><span class="line">$ let x=1+1</span><br><span class="line">$ echo $x # Correct</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>注意 <code>let</code>对空格敏感。 操作数和运算符不得 用空格分隔。 <code>test</code>计算一个表达式并 以任一状态代码退出 <code>0</code>(true) 或状态代码 <code>1</code>（错误的）</p><p><code>bash</code>支持函数，尽管相对于许多其他函数而言，其形式有缺陷 语言。 一些显着的差异包括：</p><ul><li>函数不 <em>返回</em> 任何内容，它们只是产生输出流（例如 <code>echo</code>到标准输出）</li><li><code>bash</code>严格来说是按值调用。 也就是说，只有原子值（字符串）可以 被传递到函数中。</li><li>变量没有词法作用域。 <code>bash</code>使用一个非常简单的本地系统 范围接近动态范围。</li><li><code>bash</code>没有一流的函数（即没有将函数传递给 其他函数）、匿名函数或闭包</li></ul><p>请注意函数签名中缺少参数。 参数在 <code>bash</code> 函数的处理方式与全局位置参数类似，其中 <code>$1</code> 含有 <code>$arg1</code>, <code>$2</code>含有 <code>$arg2</code>， ETC。</p><p>例如，如果我们写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># contents of awesome_shell_script</span><br><span class="line"></span><br><span class="line">foo() &#123;</span><br><span class="line">  echo hello $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo $1</span><br></pre></td></tr></table></figure><p>我们看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./awesome_shell_script world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h1 id="shell命令">shell命令</h1><h2 id="ssh安全外壳">SSH（安全外壳）</h2><p>SSH 允许您通过互联网登录远程计算机。 这相当于在远程计算机上打开 shell。</p><p>用法是 <code>ssh [remote username]@[remote host]</code>.</p><h3 id="问题"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#question"></a>问题</h3><ol type="1"><li>登录到 <code>tsunami.ocf.berkeley.edu</code>使用您的 OCF 用户名和密码。 有一个文件在 <code>~staff/public_html/decal</code>。 打开它。 文件中到底隐藏着什么秘密？</li></ol><h2 id="管道和重定向"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#pipes-and-redirection"></a>管道和重定向</h2><p>将命令链接在一起对于自动化 shell 操作至关重要。 这是一个快速备忘单：</p><p><code>&gt;</code>：将 <a href="https://linux.die.net/man/3/stdout">标准</a> 输出重定向到文件（将覆盖该文件）。</p><p><code>&gt;&gt;</code>：将标准输出附加到文件（与 <code>&gt;</code>除非不覆盖）。</p><p><code>&lt;</code>：从文件中读取输入。</p><p><code>|</code>：将一个程序的输出发送到下一个程序的输入。</p><p>下面是一个示例：假设您正在参加一门课程，需要您提交一个包含您的 SID 的文本文件。 您的第一反应可能是打开一个文本编辑器（例如 <code>vim</code>）并简单地输入它，但是有一种更快的方法来创建文件！ 这里是：</p><p><code>echo '123456789' &gt; sid.txt</code></p><h2 id="tmux">tmux</h2><h3 id="为什么是-tmux">为什么是 tmux？</h3><ul><li>当通过 ssh 连接到一台计算机时，您可以打开多个窗口。</li><li>您可以在编辑程序的同时对其进行编译和运行。</li><li>您可以注销并通过 ssh 重新登录，而无需重新打开所有文件。</li></ul><h3 id="入门"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b2/#getting-started"></a>入门</h3><ul><li>开始会话 <code>tmux</code>.</li><li>从会话中分离 <code>Ctrl-b d</code>（释放后按 d <code>Ctrl-b</code>)</li><li>分成 2 个窗格 <code>Ctrl-b %</code>（垂直）或 <code>Ctrl-b "</code>（水平的）</li><li>交换当前窗格 <code>Ctrl-b o</code></li><li>在线查找有关 tmux 的更多信息。 您可能会发现 <a href="https://gist.github.com/MohamedAlaa/2961058">此备忘单</a> 很有帮助！</li></ul><h1 id="包管理">包管理</h1><h2 id="debian简介-apt和-dpkg">Debian：简介 <code>apt</code>和 <code>dpkg</code></h2><p>在本课程中，我们将重点关注 Debian 的使用。 正如本周讲座中提到的，Debian 使用 apt/dpkg 作为其包管理器。 其他发行版使用不同的包管理器。</p><h3 id="apt"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#apt"></a><code>apt</code></h3><p>Debian 的前端包管理器是 <code>apt</code>。 大多数时候，当您需要与包管理器打交道时， <code>apt</code>通常是要走的路。 在做任何事情之前 <code>apt</code>，更新包列表通常是一个好习惯，以便包管理器可以找到并获取各种包的最新版本。 为此，您可以运行：</p><p><code>apt update</code></p><p>要查找要安装的包：</p><p><code>apt search [package|description]</code></p><p>要安装包：</p><p><code>apt install [package]</code></p><p>要删除包：</p><p><code>apt remove [package]</code></p><p>使用安装的软件包一段时间后，您可能会注意到它们不会自动更新，这一功能可能存在于为其他操作系统编写的程序中。 要更新已安装的软件包，请运行：</p><p><code>apt upgrade</code>或有时 <code>apt dist-upgrade</code></p><p>使用起来比较普遍 <code>apt upgrade</code>更新你的包，但有时你需要使用 <code>apt dist-upgrade</code>。 阅读有关两者之间差异的更多信息 <a href="https://askubuntu.com/questions/194651/why-use-apt-get-upgrade-instead-of-apt-get-dist-upgrade">您可以在此处</a> 。</p><p>在某些情况下，您希望完全确定要安装的软件包的版本。 要列出可以安装的潜在版本，您可以运行：</p><p><code>apt policy [package]</code></p><p>这根据其引脚优先级列出了要安装的候选版本以及与系统兼容的其他版本。 要安装特定目标版本的 aa 版本，您可以运行：</p><p><code>apt -t [targetrelease] install [package]</code></p><p>还有其他命令可以删除不需要的依赖项并清除包，但这就是 <code>man</code>页面是为了。 请注意，您将必须使用 <code>sudo</code>对于上述命令，因为您实际上是在修改系统本身。</p><h3 id="dpkg"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#dpkg"></a><code>dpkg</code></h3><p>后端包管理器是 <code>dpkg</code>。 传统上， <code>dpkg</code>用于安装本地软件包。 使用 <code>dpkg</code>，您还可以检查软件包并修复损坏的安装。 要安装本地软件包，请运行：</p><p><code>dpkg -i [packagefilename]</code></p><p>删除系统包：</p><p><code>dpkg --remove [package]</code></p><p>要检查包以获取有关该包的更多信息：</p><p><code>dpkg -I [packagefilename]</code></p><p>要修复/配置所有已解压但未完成的安装：</p><p><code>dpkg --configure -a</code></p><h2 id="入门-1"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#getting-started"></a>入门</h2><h3 id="创建一个简单的包">创建一个简单的包</h3><p>现在，我们将使用您将在接下来的步骤中创建的 hellopenguin 可执行文件创建一个简单的包。 首先，移至您在入门部分克隆的存储库中的 a2 文件夹：</p><p><code>cd decal-labs/a2</code></p><p>现在我们将创建一个文件夹来进行此练习：</p><p><code>mkdir ex1</code></p><p>现在进入该文件夹：</p><p><code>cd ex1</code></p><h3 id="编写和编译程序"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#writing-and-compiling-the-program"></a>编写和编译程序</h3><p>现在，我们将用 C 语言制作一个非常简单的应用程序，打印“Hello Penguin！” 名为地狱企鹅。 调用：</p><p><code>touch hellopenguin.c</code></p><p>这将创建一个名为的空文件 <code>hellopenguin.c</code>。 现在，使用您选择的首选文本编辑器，例如 <code>vim</code>, <code>emacs</code>， 或者 <code>nano</code>，将以下代码插入 <code>hellopenguin.c</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   printf(&quot;Hello Penguin!\n&quot;);</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在将编译您刚刚编写的源文件：</p><p><code>gcc hellopenguin.c -o hellopenguin</code></p><p>其作用是获取源文件 <code>hellopenguin.c</code>并将其编译为名为的可执行文件 <code>hellopenguin</code>与 <code>-o</code>输出标志。</p><h3 id="打包可执行文件"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a2/#packaging-the-executable"></a>打包可执行文件</h3><p>现在，我们将创建可执行文件所在的文件夹结构。在 Debian 中，用户级包通常驻留在该文件夹中 <code>/usr/bin/</code>:</p><p><code>mkdir -p packpenguin/usr/bin</code></p><p>现在移动你编译的 <code>hellopenguin</code>可执行到 <code>packpenguin/usr/bin/</code>文件夹。</p><p><code>mv hellopenguin packpenguin/usr/bin/</code></p><p>现在我们将创建一个名为 <code>hellopenguin</code>。 移动到父目录 <code>packpenguin</code>文件夹并调用以下命令：</p><p><code>fpm -s dir -t deb -n hellopenguin -v 1.0~ocf1 -C packpenguin</code></p><p>这指定您要使用目录 <code>-s</code>标志，并输出 <code>.deb</code>包使用 <code>-t</code>旗帜。 它接受一个名为的目录 <code>packpenguin</code>， 使用 <code>-C</code>标志，并输出 <code>.deb</code>文件名为 <code>hellopenguin</code>， 使用 <code>-n</code>，版本号为 <code>1.0~ocf1</code>， 使用 <code>-v</code>旗帜。</p><p>现在通过调用 apt 并安装它来测试它：</p><p><code>sudo dpkg -i ./hellopenguin_1.0~ocf1_amd64.deb</code></p><p>现在你应该能够运行 <code>hellopenguin</code>通过执行以下操作：</p><p><code>hellopenguin</code></p><h1 id="计算机网络">计算机网络</h1><h2 id="概述">概述</h2><p>不可否认，互联网是一个重新定义了我们世界的重要系统。 开发网络和允许设备通信的能力对于现代计算机系统至关重要。 本实验将研究计算机网络的基础知识，然后从系统管理员的角度检查网络。</p><p>我们将使用网页浏览作为类比来了解网络的基础知识。 当我上网浏览猫的图片时到底会发生什么？</p><p>但首先让我们简要了解一下网络的细节。</p><hr /><h2 id="硬件地址mac"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#mac"></a>硬件地址mac</h2><p>媒体访问控制 (MAC) 地址是唯一分配给网络接口的标识符。 <img src="https://upload.wikimedia.org/wikipedia/commons/9/94/MAC-48_Address.svg" title="MAC地址格式" alt="所有文字" /></p><p>由于 MAC 地址是唯一的，因此通常称为物理地址。 八位位组通常以十六进制书写并用冒号分隔。 MAC 地址示例是 <code>00:14:22:01:23:45</code>。 请注意，前 3 个八位位组指的是组织唯一标识符 (OUI)，它可以帮助识别制造商。 有趣的事实—— <code>00:14:22</code>以上是 Dell 的 OUI。</p><h2 id="ip"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#ip"></a>ip</h2><p>IP 地址是识别根据互联网协议连接到网络的设备的方法。 互联网协议有两个版本：IPv4 和 IPv6，它们的地址大小不同。 IPv6 地址示例是 <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>它比 IPv4 地址长得多，例如 <code>127.0.0.1</code>。 由于时间关系，我们只讨论 IPv4，但 IPv6 确实正在取得进展，值得一试！</p><p>IPv4 地址为 32 位，即 4 个字节，每个字节由点 (.) 分隔。 IPv4 地址示例是 <code>127.0.0.1</code>。 巧合的是，这个地址被称为环回地址，它映射到您自己机器上的环回接口。 这允许网络应用程序在同一台计算机（在本例中是您的计算机）上运行时相互通信。 但为什么 <code>127.0.0.1</code>并不是 <code>127.0.0.0</code>或者 <code>127.0.0.2</code>?</p><p>答案是 <code>127.0.0.1</code>是简单的约定，但从技术上讲，网络块中的任何地址 <code>127.0.0.0/8</code>是一个有效的环回地址。 但网络块到底是什么？</p><p>在 IPv4 中，我们可以将地址块划分为子网。 这是以 CIDR 格式编写的。 我们以上面的子网为例 <code>127.0.0.0/8</code>。 斜杠后面的数字 ( <code>/</code>)，在本例中为 8，是子网掩码。 这表示网络地址中有多少位，其余位标识网络内的主机。 在这种情况下，网络地址是 <code>127.0.0.0</code>面具是 <code>255.0.0.0</code>。 所以 <code>127.0.0.1</code>将是第一个主机 <code>127.0.0.0/8</code>网络等等。</p><p>该图提供了 CIDR 寻址的可视化细分 <img src="https://i.imgur.com/dEgcX0R.png" title="CIDR 寻址示例由 CS168 提供" alt="所有文字" /></p><h2 id="arp"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#arp"></a>ARP</h2><p>地址解析协议 (ARP) 是用于将 IP 地址解析为 MAC 地址的协议。 为了理解ARP，我们首先讨论发送帧的两种方式，单播和广播。 在第 2 层上下文中，单播帧意味着将该帧发送到一个 MAC 地址。 另一方面，通过将帧发送到广播地址来广播帧意味着该帧应该发送到网络上的每个设备，从而有效地“淹没”本地网络。</p><p>例如，让我们想象一个发送者 A，他有 MAC <code>00:DE:AD:BE:EF:00</code>，广播一条消息，本质上是询问“谁拥有 IP 地址 <code>42.42.42.42</code>请在 00:DE:AD:BE:EF:00 告诉 A”。</p><p>如果一台机器B，有MAC <code>12:34:56:78:9a:bc</code>有IP地址 <code>42.42.42.42</code>他们向发件人发送单播回复，其中包含以下信息“ <code>12:34:56:78:9a:bc</code>有 <code>42.42.42.42</code>”。 发送方将此信息存储在 arp 表中，因此每当它收到发往机器 B 的数据包时，即目标 IP 地址为 <code>42.42.42.42</code>它将数据包发送到从 B 收到的 MAC。</p><p>为了路由 IP 数据包，设备具有所谓的路由表。 路由条目存储在路由表中，它们本质上是告诉设备应如何基于 IP 转发数据包的规则。 路由条目指定子网以及与该条目对应的接口。 设备选择具有最特定于给定数据包的子网的条目，并将其转发出该条目上的接口。</p><p>路由表通常也有一个默认网关。 在没有更具体的匹配条目的情况下，这将用作数据包的默认捕获所有内容。</p><p>以此路由表为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default via 10.0.2.2 dev eth0</span><br><span class="line">10.0.2.0/24 dev eth0  proto kernel  scope link  src 10.0.2.15</span><br><span class="line">10.0.2.128/25 dev eth0  proto kernel  scope link  src 10.0.2.15</span><br><span class="line">192.168.162.0/24 dev eth1  proto kernel  scope link  src 192.168.162.162</span><br></pre></td></tr></table></figure><p>一个数据包的目的地是 <code>8.8.8.8</code>将从默认网关 eth0 转发出去。 一个数据包的目的地是 <code>10.0.2.1</code>将根据第二个条目从 eth0 转发。 一个数据包的目的地是 <code>10.0.2.254</code>将根据第三个条目从 eth0 转发。 一个数据包的目的地是 <code>192.168.162.254</code>将根据第四个条目从 eth1 转发。</p><h2 id="域名"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#dns"></a>域名</h2><p>我们已经讨论了 IP 地址以及它们如何通过 IP 与主机进行通信，但是虽然 IP 地址是机器友好的（计算机喜欢数字），但它们并不完全是人类友好的。 记住电话号码已经够难了，记住 32 位 IP 地址也不会更容易。</p><p>但我们更容易记住 &lt;www.google.com、www.facebook.com&gt; 或 Coolmath-games.com 等名称。 因此，在这种冲突中，域名系统 (DNS) 诞生了，它是机器友好的 IP 地址和人类友好的域名之间的折衷方案。</p><p>DNS 是一个将 google.com 等域名映射到 <code>172.217.6.78</code>。 当您查询 google.com 时，您的计算机会将 google.com 的 DNS 查询发送到 DNS 服务器。 假设配置正确并且 google.com 有一个有效的对应地址，您将收到来自权威服务器的响应，其实质上是“google.com 有 IP 地址” <code>x.x.x.x</code>”.</p><p>现在让我们稍微消除一下这个黑魔法……</p><h2 id="dns-记录"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#dns-records"></a>DNS 记录</h2><p>DNS 服务器以资源记录 (RR) 的形式存储数据。 资源记录本质上是（名称、值、类型、TTL）的元组。 虽然 DNS 记录的类型多种多样，但我们最关心的是</p><ol type="1"><li><p><strong>一条记录</strong> 名称 = 主机名 值 = IP 地址</p><p>该记录非常简单，包含给定主机名的 IP 地址，本质上是我们最终想要得到的信息。</p></li><li><p><strong>国民服役记录</strong> 名称=域名 值 = 域的 DNS 服务器名称</p><p>该记录指向另一个可以为该域提供权威答案的 DNS 服务器。 将此视为将您重定向到另一个名称服务器。</p></li><li><p><strong>CNAME 记录</strong> 名称 = 别名 值=规范名称</p><p>这些记录指向给定别名的规范名称，例如 docs.google.com 将是一个仅指向 document.google.com 的别名 尝试 &lt;www.facebook.com&gt;</p></li><li><p><strong>MX记录</strong> 邮件服务使用的记录。</p></li></ol><h2 id="tcp-和-udp"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#tcp-and-udp"></a>TCP 和 UDP</h2><p>现在我们将讨论传输层的协议。 这一层最著名的两个协议是传输控制协议（TCP）和用户数据报协议（UDP）。</p><p>TCP 是一种面向有状态流的协议，可确保可靠的传输。 可靠的传输本质上保证信息完整且有序地到达目的地。</p><p>TCP 是面向连接的协议，这意味着它在发送任何数据之前必须首先建立连接。 此连接交换信息，这是 TCP 用于在其他功能中提供可靠传输的机制。 TCP 连接以 TCP 握手开始。</p><p>TCP 握手包括在发送方和接收方之间交换的数据包的 TCP 标头中设置某些标志。 发送方首先发送 SYN（设置了 SYN 标志的数据包）来启动 TCP 连接。 服务器通过发回 SYN-ACK（一个同时设置了 SYN 和 ACK 标志的数据包）来确认此连接请求。 客户端通过向服务器发送一个最终 ACK 来确认这一点，然后建立连接。</p><p>TCP 然后开始传输数据，如果数据成功到达连接的另一端，则会发出 ACK。 因此，如果数据丢失、重新排序或损坏，TCP 能够识别这一点并发送重传任何丢失数据的请求。</p><p>TCP 也有一个关闭连接的过程。 我们在这里只考虑优雅终止，突然终止有不同的过程，我们不会讨论。 如果您有兴趣，CS168 <a href="https://drive.google.com/file/d/0B4GG2Ks7ZJf5RlpRby1Qbk8zcTg/view">这里</a> 有一些很棒的材料。 假设机器 A 想关闭与机器 B 的连接。</p><p>A 首先发送 FIN。 B 必须通过发送 FIN 和 ACK 进行响应。 如果 B 仅发送 ACK，则连接将持续存在，并且可以发送其他数据，直到发送 FIN。 另一方面，如果 B 准备好关闭连接并且不需要发送额外的数据，则 B 也可以只发送一个同时设置了 FIN 和 ACK 标志的数据包，即 FIN+ACK。发送最后一个 ACK​​ 来表示连接终止。</p><p>UDP是无状态无连接协议。 UDP 专注于以数据报的形式发送消息。 无连接 UDP 也不会产生 TCP 握手和终止的开销。 UDP 也不保证可靠传输，因此消息可能会损坏、无序到达或根本不到达。 因此，UDP 有时被称为不可靠数据报协议。</p><p>虽然 UDP 不保证可靠传输，但它不会像 TCP 那样遭受建立和关闭连接的开销。 因此，UDP 非常适合我们只想快速发送数据包并且丢失一些数据包也不会造成灾难性后果的使用情况。</p><p>此外，与 TCP 相比，发送的每个 UDP 数据报都需要单独接收。 而对于 TCP，您传递的数据流被透明地分成一定数量的发送，并且数据流在另一端透明地重建为一个整体。</p><h2 id="端口"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b5/#ports-optional"></a>端口</h2><p>广义上讲，端口定义了服务端点——端口标记了流量的入口和出口点。 IP 地址连接主机，而端口则连接在此类主机上运行的进程。 一次只能将一个进程绑定到一个端口。 端口由 16 位数字表示，范围从 0 到 65535。从 0 到 1023 的端口是众所周知的端口，即系统端口。 使用这些端口通常有更严格的要求。 1024 到 49151 是注册端口。 官方 <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">列表</a> IANA 维护着知名和注册范围的 。 从 49152 到 65535 的其余端口是临时端口，可以根据每个请求动态分配给通信会话。</p><h1 id="systemd-unit">systemd unit</h1><p><a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">unit的介绍和写法</a> Linux 发行版越来越多地采用 <code>systemd</code>初始化系统。 这套功能强大的软件可以管理服务器的许多方面，从服务到安装的设备和系统状态。</p><p>在 <code>systemd</code>， A <code>unit</code>指系统知道如何操作和管理的任何资源。 这是主要对象 <code>systemd</code>工具知道如何处理。 这些资源是使用称为单元文件的配置文件定义的。</p><p>单位是对象 <code>systemd</code>知道如何管理。 这些基本上是系统资源的标准化表示，可以由守护程序套件管理并由提供的实用程序操作。</p><p>单元可以说类似于其他 init 系统中的服务或作业。 然而，单元具有更广泛的定义，因为它们可用于抽象服务、网络资源、设备、文件系统挂载和隔离资源池。 系统的单元文件副本一般保存在 <code>/lib/systemd/system</code>目录。 当软件在系统上安装单元文件时，这是它们默认放置的位置。</p><p>存储在此处的单元文件可以在会话期间按需启动和停止。 这将是通用的普通单元文件，通常由上游项目的维护人员编写，应该适用于部署的任何系统 <code>systemd</code>在其标准实施中。 您不应编辑此目录中的文件。 相反，如果有必要，您应该使用另一个单元文件位置来覆盖该文件，该位置将取代该位置中的文件。 正确的方法是创建一个以单元文件命名的目录 <code>.d</code>附加在最后。 所以对于一个叫做 <code>example.service</code>，一个名为 <code>example.service.d</code>可以被创建。 在此目录中，有一个以以下结尾的文件 <code>.conf</code>可用于覆盖或扩展系统单元文件的属性。</p><p>大多数单元文件中的第一部分是 <code>[Unit]</code>部分。 这通常用于定义单元的元数据并配置单元与其他单元的关系。</p><p>尽管部分顺序并不重要 <code>systemd</code>解析文件时，此部分通常放置在顶部，因为它提供了单元的概述。 您可以在以下位置找到一些常见指令 <code>[Unit]</code>部分是：</p><ul><li><strong><code>Description=</code></strong>：该指令可用于描述单元的名称和基本功能。 它由各种返回 <code>systemd</code>工具，因此最好将其设置为简短、具体且信息丰富的内容。</li><li><strong><code>Documentation=</code></strong>：该指令提供了文档 URI 列表的位置。 这些可以是内部可用的 <code>man</code>页面或网络可访问的 URL。 这 <code>systemctl status</code>命令将公开此信息，以便于轻松发现。</li><li><strong><code>Requires=</code></strong>：该指令列出了该单元本质上依赖的所有单元。 如果当前单位已激活，则此处列出的单位也必须成功激活，否则该单位将失败。 默认情况下，这些单元与当前单元并行启动。</li><li><strong><code>Wants=</code></strong>：该指令类似于 <code>Requires=</code>，但不太严格。 <code>Systemd</code>当此单元被激活时，将尝试启动此处列出的任何单元。 如果未找到这些单元或无法启动，当前单元将继续运行。 这是配置大多数依赖关系的推荐方法。 同样，这意味着并行激活，除非被其他指令修改。</li><li><strong><code>BindsTo=</code></strong>：该指令类似于 <code>Requires=</code>，但也会导致当前单元在关联单元终止时停止。</li><li><strong><code>Before=</code></strong>：如果同时激活了该指令中列出的单元，则只有当前单元被标记为已启动后，它们才会启动。 这并不意味着依赖关系，并且如果需要的话必须与上述指令之一结合使用。</li><li><strong><code>After=</code></strong>：该指令中列出的单元将在启动当前单元之前启动。 这并不意味着依赖关系，如果需要，必须通过上述指令建立依赖关系。</li><li><strong><code>Conflicts=</code></strong>：这可用于列出不能与当前单元同时运行的单元。 启动具有这种关系的单元将导致其他单元停止。</li><li><strong><code>Condition...=</code></strong>: 有许多指令以 <code>Condition</code>这允许管理员在启动设备之前测试某些条件。 这可用于提供仅在适当的系统上运行的通用单元文件。 如果不满足条件，则会正常跳过该单元。</li><li><strong><code>Assert...=</code></strong>：类似于以 <code>Condition</code>，这些指令检查运行环境的不同方面，以决定是否应激活该单元。 然而，与 <code>Condition</code>指令，负结果会导致该指令失败。</li></ul><h1 id="安全管理">安全管理</h1><h2 id="加密与解密">加密与解密</h2><h3 id="基础知识">基础知识</h3><p>加密采用明文和密钥，返回密文。 解密需要密文和密钥，仅当解密密钥有效时才恢复并返回原始明文。 加密和解密的密钥是由随机位组成的长字符串，这使得攻击者在计算上无法猜测密钥并解密密文。</p><p><img src="https://docs.oracle.com/cd/E19424-01/820-4811/images/scrypt.gif" alt="一切" /> 安全性是指在面对攻击时保持系统按预期运行 这可以采取多种形式：</p><ol type="1"><li>保密性</li><li>完整性/真实性</li><li>可用性</li></ol><p>模块：</p><ol type="1"><li>认证</li><li>加密：防止攻击者读取您的文件，直到它们得到 联邦调查局和他们的密码学家参与其中</li><li>哈希：将大数据转化为小数据</li><li>签名和证书：确保您就是您所说的人 假设我想使用你的公钥来验证你的身份。 我 可以用它加密一些东西，并要求你解密它并且 显示正确的值。 如果您可以解密该值，那么您必须拥有密钥的私有部分并且可以进行身份​​验证。 假设你想证明你发送的消息实际上是由您发送。 您可以使用您的私钥来“签署”消息通过对其进行加密，您的公钥可用于解密签名以验证您（由您发布的公开信息识别）键）实际上确实发送了消息，因为只有您而不是其他人对手将拥有相应的私钥。 <code>根证书</code>：操作系统包含许多根证书 这是网络信任的基础。 证书是在通向根的链中签名； 如果链有效，则最后的 cert 被认为是可信的。</li></ol><p>网络攻击： 攻击网络系统的方法有很多： 窃听、中间人、拒绝服务、应用程序 缓冲区/堆溢出、SQL 注入等漏洞 目录遍历、CSRF、SSRF、XSS、蠕虫、rootkit、垃圾邮件、加密挖矿、勒索软件、网络钓鱼等等……</p><h3 id="对称密码学"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#symmetric-cryptography"></a>对称密码学</h3><p>在对称密码学中，用于加密和解密的密钥是相同的。</p><p>尝试一下：</p><ol type="1"><li><code>gpg --symmetric [FILE]</code>在任何文件上输出 <code>[FILE].gpg</code>文件是输入文件的加密版本。 加密文件时需要输入密码。</li><li><code>gpg --decrypt [FILE].gpg</code>在原始文件的加密版本上，您需要输入原始密码。</li></ol><p>在此 GPG 实现中，文件的加密和解密都需要知道单个密码，在本例中该密码充当对称密钥。</p><h3 id="非对称密码学"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#asymmetric-cryptography"></a>非对称密码学</h3><p>在非对称加密中，两个单独的密钥分别用于加密和解密。 这两个密钥是一对公私密钥。 公钥是公开的并用于加密数据。 而私钥由所有者保密并用于解密数据。 使用公钥加密文件意味着只有拥有相应私钥的人才能解密生成的加密文件。</p><h4 id="gpg-钥匙圈抽象"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#gpg-keyring-abstraction"></a>GPG 钥匙圈抽象</h4><p>GPG 使用“密钥环”作为集中位置来保存用户的所有密钥。 如果您想使用并保留它，则需要向密钥环添加/导入密钥。 同样，如果您希望与其他人共享密钥，您可以导出您的密钥（这会生成您的密钥的副本）并让他们将其导入到他们的密钥环中。</p><p>尝试一下：</p><ol type="1"><li><code>gpg --full-generate-key</code>生成 GPG 公私密钥对。 它会要求输入密码。 <em>如果您的机器需要一段时间才能生成密钥，则可能是由于缺乏长随机密钥所需的熵（随机性）。 <code>sudo apt-get install haveged</code>将安装一个生成熵的守护进程。</em></li><li><code>gpg --recipient [RECIPIENT] --encrypt [FILE]</code>这将加密 <code>[FILE]</code>和 <code>[RECIPIENT]</code>的公钥（目前，尝试使用您自己的公钥加密文件）。</li><li><code>gpg --decrypt [FILE].gpg</code>将搜索您的密钥环并使用适当的私钥解密文件（当然，如果您拥有正确的私钥）。 <em>您无需指定使用哪个密钥来解密文件，因为 GPG 加密的文件和密钥包含元数据，允许 GPG 从密钥环中选择正确的密钥来解密文件。</em></li></ol><h3 id="签名"><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/b8/#signatures"></a>签名</h3><p>公钥加密、私钥解密的非对称方案也可以反过来实现数字签名，其作用相当于物理签名。 在这个相反的方案中，私钥用于对文件进行签名，从而在该文件上生成签名。 并使用相应的公钥来验证签名。 因此，只有拥有私钥的人才能生成签名，但拥有相应公钥的任何人都可以验证该签名。 <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Illustration_of_digital_signature.svg/1920px-Illustration_of_digital_signature.svg.png" /></p><p>UNIX 权限模型有 3 个组成部分：授予文件的 (1) 所有者用户、(2) 所有者组和 (3) 其他人/其他所有人的权限。 权限本身有 3 个子组件：(1) 读取、(2) 写入和 (3) 执行，强制执行读取、写入或执行文件的能力。</p><p><img src="https://www.comentum.com/images/permissions.jpg" /></p><h3 id="gpg">gpg</h3><ol type="1"><li>解密b8/file1.txt.gpg:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --decrypt b8/file1.txt.gpg </span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>输入密码ocfdecal后,解密内容为: mYp@sw0rd2. 导入密钥的命令是:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --import &#123;key_file&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>将密钥导出到文件的命令:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --export --armor &#123;key_id&#125; &gt; &#123;output_file&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>查看钥匙圈所有钥匙的命令:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-keys</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>使用私钥b8/lab8privkey解密b8/file2.txt.gpg:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --import ./lab8privkey</span><br><span class="line">gpg --decrypt  ./file2.txt.gpg</span><br></pre></td></tr></table></figure><h3 id="hash">hash</h3><ol type="1"><li><code>sha1sum [FILE]</code>获取 SHA1 哈希值 <code>[FILE]</code>.</li><li><code>md5sum [FILE]</code>获取 MD5 哈希值 <code>[FILE]</code>.</li></ol><h2 id="安全系统">安全系统</h2><h3 id="威胁模型">威胁模型</h3><p>设计安全系统时要记住的最重要的事情是 了解您的威胁模型。 没有系统能够保证安全或能够 能够抵挡所有的攻击，甚至在极端的情况下也是不可能的。 对手。 但是，您可以（并且应该）针对威胁采取预防措施 你很可能会面临。 平衡授权用户访问的需求 在将未经授权的用户拒之门外的情况下，很容易出错。 幸运的是，聪明人已经将安全原则提炼为 中得到了很好的 <a href="http://www.icir.org/vern/cs161-sp17/notes/Principles.1.19.pdf">第一个讲义</a> 一些公理，在CS 161 的 介绍 （归功于大卫·瓦格纳教授）。 建议阅读讲义。</p><p><strong>构建威胁模型时，请记住以下问题：</strong></p><ol type="1"><li>你在保护什么？</li><li>谁是你的对手？</li><li>您需要保护它的可能性有多大？</li><li>如果不加以保护，会产生什么后果？</li><li>您应该投入多少资源来保护它？</li></ol><h3 id="加密解密">加密解密</h3><p><strong>对称密钥加密几乎对所有事物都有用，尤其是属于以下类别的事物：</strong></p><ul><li>加密传输中的数据（例如 HTTPS）</li><li>加密静态数据（例如手机上存储的数据）</li></ul><p>作为示例，我们来探讨一下 iPhone 如何使用加密来保证数据安全：</p><ol type="1"><li>iPhone 的内部存储使用一组 AES 密钥进行加密，这些密钥存储在手机内部芯片上，并在工厂生成。</li><li>这些密钥又使用您的 PIN 进行加密。 您的 PIN 码允许手机解锁密钥，从而解密文件系统的其余部分。</li></ol><p>与对称密钥加密不同，公钥加密中有 2 个密钥 ，密码系统由<strong>公钥</strong> 和 <strong>私钥</strong>组成 。 顾名思义， 公钥是公开共享的，这是其他人可以使用的方式 加密适合您的数据。 您使用您的私钥来解密此内容 数据。 只要没有人拥有你的私钥，任何人都可以使用你的公钥 加密数据并确保只有您可以解密它。 这是一个强大的 对称密钥范式的扩展，除了加密之外，它还允许 签名和不可否认性 公钥密码学与 <strong><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA 算法</a></strong> 同义， 是最早经过验证的双密钥方案之一。 <strong>RSA 公钥加密工作原理的简要概述</strong>：</p><ol type="1"><li>RSA算法，通过一些高等数学（涉及素数和模数） 算术），返回 3 个数字：一个公共指数（又名密钥），一个私有指数， 和一个模数。 两个密钥的工作方式使得用一个密钥加密的数据只能 可以用另一个密钥解密。</li><li>为了加密数据，需要使用指数和模数之一对数据执行模幂运算。</li><li>为了解密数据，对加密数据进行模幂运算 与合作伙伴密钥和模数。 常用时，使用较大的指数 作为私钥，用于解密数据和创建签名， 较小的指数作为公钥，用于加密数据 并验证签名。 比如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure><p>该命令将生成两个文件， <code>~/.ssh/id_rsa</code>和 <code>~/.ssh/id_rsa.pub</code>。 正如命令所示，此命令生成 4096 位 RSA 密钥对。 你 应该能够猜测哪个文件代表公钥以及哪个文件必须 因此是私钥。 为了影响安全 SSH 登录，请使用 RSA密钥，用户必须首先将他们想要使用的公钥传输到 提前向服务器表明自己的身份。 然后，一旦会话结束 服务器和客户端之间建立的，服务器会加密一个随机数 号码与用户的公钥并发送给用户。 用户将 然后使用他们的私钥解密该值并返回该值的哈希值 到服务器，然后服务器可以自己散列该值以确定用户是否 能够成功解密随机数，从而表明拥有 匹配的密钥并作为身份验证的证据。</p><h3 id="签名和证书">签名和证书</h3><p>一开始，您 将发布 Natoshi 的公钥，此后，对于您发布的每个帖子，您 将使用您（Natoshi）的私钥对消息内容进行加密，并且 将其与您的原始消息一起发布。 那么，想验证的人 Natoshi（即公钥对应的私钥的所有者 属于 Natoshi）实际上确实发布了一条特定的消息，可以简单地 使用 Natoshi 的公钥解密加密签名并比较 内容与原始消息相反。</p><p>Natoshi 王位的觊觎者将是 无法签署他们的虚假声明，以便可以与他们核实 Natoshi 公开了公钥，因为他们没有 Natoshi 的私钥， 您可以放心，没有人会过度影响您的项目 当你躲避 IRS 和 DEA 时，除非他们碰巧有 仓库里装满了 ASIC 和大量廉价电力。</p><p><strong>然而，在这个方案中，如何防止对手发布虚假信息 公钥并声称是您？</strong> （他们可以对此进行有效签名 假公钥）不知何故，你需要“引导”信任：有人需要 验证您的身份并公开确认您的公钥实际上 对应于你。</p><p>我们通过 <strong>证书</strong> 来做到这一点：签署的声明 声称特定的公钥实际上属于它所声称的人 属于。</p><p>谁签署此证书？ 一个 <strong>证书颁发机构</strong> ，我们的某人 信任负责验证身份和发布签名。</p><p>但是我们如何知道要信任哪些 CA，以及我们如何才能信任声称 真正值得信赖的是？ 他们可能还需要证书。 它 听起来好像一路下来都是海龟； 然而，链条确实结束了 某处：所谓的信任根，根 CA。 这些 CA 的 证书是由浏览器和操作系统预安装的，因此 本质上受信任，无需任何进一步的证书。 如果根 CA 签署您的证书，我们假设他们已经完成了必要的尽职调查 愿意冒着声誉风险签署您的证书，并且基本上 相信他们的话。 这种模型被称为“ <strong>信任网络”</strong> ，是网络如何 今天的安全工作正常进行。</p><p>不幸的是，它并不像我们希望的那样可靠： 有些 CA 很卑鄙，只要有足够的钱就会签署任何东西，从而导致有效的 为 microsoft.com 和 github.com 等域颁发的证书 显然不是 Microsoft 或 GitHub 的实体。 <a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/#fn:badwosign">1</a> 此外， 任何拥有足够边境控制的实体都可以强制安装自己的 根证书（例如哈萨克斯坦政府 <a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/#fn:badkazakh">2</a> ) 并截取 通过为任何域颁发自己的伪造证书来窃取任何流量。</p><p>您可能没有意识到，但 <strong>您使用并依赖证书和签名 每天。</strong> 每当您在网站地址栏附近看到绿色锁时， 访问，您正在通过 TLS 或 HTTPS 连接访问该网站，并且数据 您和网站之间的传输是加密的。 当你的浏览器 连接到网站的服务器，它会按顺序请求服务器的公钥 设置加密连接和服务器证书以便 验证其作为授权为您拥有的域提供服务的服务器的身份 要求。 然后，您的浏览器通过验证公钥来验证公钥 证书上的签名。 如果有人试图执行 对您进行中间人攻击，此证书验证步骤将失败， 因为受信任的 CA 不太可能颁发签名的证书 将您的域名转让给您以外的实体（除非您不幸 居住在哈萨克斯坦）。 您将收到一条非常侵入性的通知 这个事实，忽略证书验证是一个坏主意 失败通知。</p><p><a href="https://decal.ocf.berkeley.edu/archives/2022-spring/labs/a9/">怎么为自己的网站设置https加密传输数据</a> 现在您有了一个网站，您决定，作为一个优秀的互联网公民，您 希望保护您的访客免受政府的窥探，通过 设置 HTTPS。 您已经知道您将需要一个公钥和一个 为此，由受信任的根 CA 签署的证书。 你怎么去 关于得到一个？ 在互联网上搜索，你发现了一个很棒的项目，名为 <a href="https://letsencrypt.org">Let's Encrypt</a> 提供免费、签名的服务 证书。</p><h3 id="文件安全">文件安全</h3><p><img src="https://www.comentum.com/images/permissions.jpg" /> 作为 <code>root</code>用户。 当程序启动时，它会继承其用户 ID 和组 ID 父进程，并保留它们，除非手动删除权限。 如果你 以 root 用户身份启动程序，因为，例如，它需要更深入的 系统访问，程序中的漏洞意味着攻击者可以 以 root 用户身份与您的计算机进行交互。 这是一个常见问题 错误配置的网络服务器，其中服务器以根目录运行 遍历漏洞可能允许攻击者读取秘密凭证 存储在服务器的文件系统上。</p><p>这个故事的寓意与最小特权原则紧密相连：无论在哪里 可能的话，只给予尽可能少的许可或特权。 如果 程序不需要 root 凭据，请勿以特权用户身份运行它。 如果 文件包含敏感内容，请勿使其可读。</p><p>如何更改权限？ 有两个主要命令可以执行此操作： <code>chmod</code>和 <code>chown</code>. <code>chmod</code>更改文件模式，即权限，以及 其语法示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ls -la ~/</span><br><span class="line">drwxr-xr-x 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod 644 test</span><br><span class="line">$ ls -la</span><br><span class="line">drw-r--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod u+x test</span><br><span class="line">drwxr--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod 000 test</span><br><span class="line">d--------- 3 admin admin  4096 Oct  3 12:38 test</span><br><span class="line">$ chmod +r test</span><br><span class="line">dr--r--r-- 3 admin admin  4096 Oct  3 12:38 test</span><br></pre></td></tr></table></figure><p><code>chmod</code>接受八进制表示法的文件权限，即 下列的：</p><table><thead><tr class="header"><th>#</th><th>读写</th></tr></thead><tbody><tr class="odd"><td>7</td><td>读写</td></tr><tr class="even"><td>6</td><td>RW-</td></tr><tr class="odd"><td>5</td><td>接收</td></tr><tr class="even"><td>4</td><td>r–</td></tr><tr class="odd"><td>3</td><td>-wx</td></tr><tr class="even"><td>2</td><td>-在-</td></tr><tr class="odd"><td>1</td><td>-X</td></tr><tr class="even"><td>0</td><td>—</td></tr></tbody></table><h1 id="pueept">pueept</h1><p>● 流行的配置管理软件 ● 用于配置单个机器 ● 声明性哲学，必要时带有一些命令式组件 ● 最初基于 Ruby 构建，现在拥有自己的配置语言 流程： ● 客户端向服务器请求更新 ○ “我想配置为 Minecraft 服务器” ● 服务器向客户端询问事实列表 ○ “好的，请将您的主机名和 RAM 发送给我” ● 客户用事实回应 ○ “我的主机名是僵尸.ocf.berkeley.edu，我有 4GB RAM” ● 服务器响应配置 ○ “确保 Minecraft 服务器正在运行，主机名为僵尸.ocf.berkeley.edu，4GB RAM， 这个配置文件 ● 客户端进行必要的更改以确保其当前配置与 服务器给出的配置 ○ “minecraft服务器当前正在运行，但配置文件已更新，我将获取 更新后的版本 Puppet是一个配置管理工具,通过Puppet可以实现对大量服务器/主机的集中化、自动化的配置管理。Puppet的工作原理是:</p><ol type="1"><li>在Puppet Master服务器上面编写Puppet Manifests(配置文件)。这些文件使用Puppet语言定义了服务器的最终状态。</li><li>Puppet Agent安装在被管理的主机上面,它会定期从Puppet Master拉取配置。</li><li>Puppet Agent对本地服务器状态进行检查,然后根据Manifests对服务器进行配置,确保服务器状态与预期状态一致。</li><li>如果配置发生变化,Puppet会自动应用这些变化,无需手动操作。</li><li>Puppet Agent会定期运行,如果配置失效会再次修正。所以Puppet脚本就是编写Puppet Manifests的文件,它定义了需要配置什么,怎么配置。常见的配置包括:- 安装软件</li></ol><ul><li>管理服务<br /></li><li>配置文件内容<br /></li><li>用户和权限<br /></li><li>安全设置<br /></li><li>定时任务 等等通过Puppet脚本可以实现服务器配置的版本控制、自动化部署,大幅减少管理时间成本。它适用于需要管理大量Linux/Unix主机的场景。</li></ul><h1 id="git">git</h1><p>创建一个分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dice</span><br></pre></td></tr></table></figure><p>这使得一个新的本地分支称为 <code>dice</code>基于我们所在的分支机构 目前在（ <code>master</code>）并将您切换到 <code>dice</code>分支。 这个命令是 基本上简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dice       # Create new branch called &#x27;dice&#x27;</span><br><span class="line">git checkout dice     # Switch to branch called &#x27;dice&#x27;</span><br></pre></td></tr></table></figure><p>您可以通过键入来查看您创建的分支 <code>git branch</code>。 你应该看到 此时有两个分支，一个称为 <code>master</code>和一个叫 <code>dice</code>。 一个 星号位于您当前签出的分支旁边。 <code>git log</code>查看历史提交。 每个提交都有一些信息，例如提交的作者、 创建提交的时间戳和提交消息。</p><ul><li><p>每个提交条目的第一行都有一个长的十六进制字符串。 这是 commit <em>hash</em> ：将其视为可用于引用的唯一 ID 具体提交。</p></li><li><p>有些提交在提交哈希旁边的括号中包含分支信息， 表明它们是最近的提交或 <code>HEAD</code>那个分支的。 你的 最近的提交应该有类似的内容 <code>(HEAD -&gt; dice)</code>。 第四个 提交应该有 <code>(origin/master, origin/HEAD)</code>因为我们的分支机构 关闭 <code>master</code>并在其之上添加了三个新的提交。 请注意，如果 有人向本地或远程添加新提交 <code>master</code>， 分支 信息可能会更改或过时。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">commit adc45cd5110b59f76cefc2b862d0e4d550ccb183 (HEAD -&gt; dice)</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:32:35 2023 +0800</span><br><span class="line"></span><br><span class="line">    Restrict input range for dice iterations and sides</span><br><span class="line"></span><br><span class="line">commit a79a770157449a9d2fb1595a0b83ecc99070eabf</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:31:56 2023 +0800</span><br><span class="line"></span><br><span class="line">    Add dice rolling logic and output dice sum and sequence</span><br><span class="line"></span><br><span class="line">commit 924d0b1ebf050a043da434114187a290280ec660</span><br><span class="line">Author: thinklive1 &lt;469631989@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 12 15:30:45 2023 +0800</span><br><span class="line"></span><br><span class="line">    Add -s flag for number of sides on a die</span><br><span class="line"></span><br><span class="line">commit 3acb62af3eff4a1dbbe875e81ec1485d9d10c44b (origin/master, origin/HEAD, master)</span><br><span class="line">Merge: 4e2aac7 2aefa6c</span><br><span class="line">Author: Ishaan Dham &lt;56564174+Ishaandham19@users.noreply.github.com&gt;</span><br><span class="line">Date:   Tue Mar 21 21:39:51 2023 -0700</span><br><span class="line"></span><br><span class="line">    Merge pull request #34 from 0xcf/demo</span><br><span class="line"></span><br><span class="line">    Demo</span><br><span class="line"></span><br><span class="line">commit 2aefa6c51449ffcd39d945e3d74ce2b5e50acf7f (origin/demo)</span><br><span class="line">Author: Ishaan Dham &lt;ishaandham01@gmail.com&gt;</span><br></pre></td></tr></table></figure><p>除了查看提交历史记录之外，您可能还想查看实际的更改 在代码中。 您可以使用 <code>git diff &lt;old commit&gt; &lt;new commit&gt;</code>查看 两次提交之间的差异。</p><p>除了查看提交历史记录之外，您可能还想查看实际的更改 在代码中。 您可以使用 <code>git diff &lt;old commit&gt; &lt;new commit&gt;</code>查看 两次提交之间的差异。 有几种不同的方式可以引用 一次提交。 之前提到的一个是复制提交的哈希值（请注意 您的提交哈希值将与下面的示例不同）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 3368313c0afb6e306133d604ca72b0287124e8f2 762053064506810dee895219e5b2c2747a202829</span><br></pre></td></tr></table></figure><p>您还可以复制提交哈希开头的一小块，而不是 整个哈希。 由于哈希的工作方式，您不太可能 有两个具有完全相同的起始序列的提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 3368313 7620530</span><br></pre></td></tr></table></figure><p>如果你想尝试 <code>diff</code>两个提交非常接近 日志，一种更简单的方法是通过距提交的距离来引用提交 <code>HEAD</code> （最近）使用以下格式提交 <code>HEAD~&lt;number&gt;</code>。 由于我们添加了三个 提交新的提交 <code>dice</code>，我们可以查看之间的差异 <code>dice</code>和 <code>master</code>使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD~3 HEAD</span><br></pre></td></tr></table></figure><p>有多种方法可以处理合并冲突，但我们将采用的方法 在这个实验室中向您展示正在使用 <code>git rebase</code>。 我们的 <code>dice</code>分支是“基于” 这 <code>master</code>在某个时间点有分支，但是 <code>master</code>分行有 向前离开 <code>dice</code>基于过时的 <code>master</code>。 因此，我们想要 “重新基地” <code>dice</code>就目前的状态而言 <code>master</code>。 当你的 <code>dice</code>分支， 跑步 <code>git rebase master</code>。 Git 将回滚您所做的提交 <code>dice</code>， 复制 任何新的提交 <code>master</code>，并尝试在顶部重放您的提交。 有时 <code>rebase</code>无需您的干预即可运行完成，但是如果 存在合并冲突，您需要解决它。</p><p>Git 会告诉你如果遇到合并冲突该怎么办 在变基期间。 在这种情况下，打开 <code>rand.py</code>并找到冲突区域 应具有以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Lines of code from the base branch (in this case master)</span><br><span class="line">=======</span><br><span class="line">Lines of code from the branch you&#x27;re rebasing (in this case dice)</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Commit message of the commit that conflicts with the base branch</span><br></pre></td></tr></table></figure><p>要解决冲突，只需保留您想要的行（您的行来自 <code>dice</code>） 和 删除冲突区域中的其他行（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD`, `=======`, `&gt;&gt;&gt;&gt;&gt;&gt;&gt; dice`</span><br></pre></td></tr></table></figure><p>，以及来自 master 的不需要的代码），然后保存并退出 文件。 Git 会将您保存的内容作为文件的确切形式 看起来像在变基结束时，所以你所做的本质上是修复 文件，以便代码正常运行。 这意味着如果您有多个 合并冲突，您决定混合保留基础分支中的一些行 还有一些来自您的功能分支，您需要确保代码确实有效 正确。</p><p>现在您已经解决了合并冲突，请按照变基说明进行操作 暂存您的固定文件（ <code>git add rand.py</code>），然后运行 <code>git rebase --continue</code>。 如果 Git 发现其他文件有更多合并冲突，您将遵循相同的操作 程序如上。 然而，我们只有一个有冲突的文件，所以我们的变基是 完成的！ 跑步 <code>git log</code>查看我们 rebase 的结果。 你现在应该看到了 你想象中的队友 <code>"dice rolling WIP"</code>提交您分支的历史记录， 你的提交高于他们的提交。</p><h1 id="docker">docker</h1><p><a href="https://docs.docker.com/v17.09/engine/installation/linux/docker-ce/ubuntu/">安装 Docker</a> wsl2不支持systemctl命令，而是支持systemed命令 所以需要执行如下命令启动docker</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker <span class="keyword">start</span></span><br></pre></td></tr></table></figure><p><code>虚拟机</code> 你的电脑里有一台电脑！ ● 通过软件模拟抽象物理硬件 ● 虚拟机管理程序运行多个虚拟机 ● 隔离应用：更好的安全性、稳定性 ● 一些开销：需要不同的客户操作系统和模拟 每个应用程序的虚拟硬件数量 ● 需要一些时间来启动</p><p><code>容器</code> ● 通常与虚拟机进行比较，但更像是捆绑的进程 环境 ● 提供类似的隔离 ○ 然而，比虚拟机要少得多！ 出于这个原因，我们仍然经常在虚拟机内运行容器（但是 每个虚拟机可以运行 &gt;1 个容器） ● 启动速度比虚拟机快得多 ● 目标是通过共享代码提供轻量级隔离环境 ● 轻松打包应用程序以实现一致的部署 ● 常见的容器：Docker、rkt、LXC ● 很确定这是加州大学伯克利分校唯一使用的课程</p><table><thead><tr class="header"><th>Command</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>docker search</td><td>Search Docker Hub for pre-built images</td></tr><tr class="even"><td>docker pull</td><td>Pull an image or a repository from a registry</td></tr><tr class="odd"><td>docker images</td><td>List images</td></tr><tr class="even"><td>docker build</td><td>Build an image from a Dockerfile</td></tr><tr class="odd"><td>docker run</td><td>Run a command in a new container</td></tr><tr class="even"><td>docker ps</td><td>List containers</td></tr><tr class="odd"><td>docker start/stop/restart</td><td>Start/stop/restart a container</td></tr><tr class="even"><td>docker exec</td><td>Run a command in a running container</td></tr><tr class="odd"><td>docker inspect</td><td>Return low-level information on Docker objects</td></tr><tr class="even"><td>docker rm</td><td>Remove one or more containers</td></tr><tr class="odd"><td>docker rmi</td><td>Remove one or more images</td></tr></tbody></table><p><code>docker</code> ● 需要构建镜像 ● 通常使用 Dockerfile 来指定 如何构建快照 ● 快照是分层构建的 ○ 像洋葱一样 ○ 允许基于相同的快照层构建速度更快 ● 保持每一层最少化资源</p><p>自动化配置管理工具 ● 声明式：说出你想要什么，而不是如何做 ○ 应用程序弄清楚如何 ● 可以定义要安装的应用程序、要包含的文件等 ● 可以在不同“类别”的机器上安装不同的东西 （桌面与服务器） ● 常用工具：Puppet、Ansible、Chef</p><h2 id="docker的使用">docker的使用</h2><p><code>docker run hello-world</code></p><p>您应该看到一些友好的输出，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete </span><br><span class="line">Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此消息表明您的安装似乎运行正常。 为了生成此消息，Docker 采取了以下步骤：</p><ol type="1"><li>Docker 客户端联系了 Docker 守护进程。</li><li>Docker 守护进程从 Docker Hub 中提取“hello-world”镜像。</li><li>Docker 守护进程从该映像创建了一个新容器，该容器运行生成您当前正在读取的输出的可执行文件。</li><li>Docker 守护进程将该输出传输到 Docker 客户端，然后将其发送到您的终端。 在容器中默认以<code>root</code>用户身份登录。</li></ol><p>以交互方式运行容器。 如果您需要在裸系统上尝试和安装东西而不弄乱当前系统，那么这非常有用。 尝试运行以下命令：</p><p><code>docker run -it ubuntu:latest</code></p><p>这 <code>-i</code>flag 告诉 docker 保留 <code>STDIN</code>打开你的容器，然后 <code>-t</code>分配一个 <a href="https://en.wikipedia.org/wiki/Pseudoterminal">伪 TTY</a> flag为您 。 基本上，您需要两者才能在新启动的容器中拥有一个 shell。 尝试安装一些软件包 <code>apt</code>或者只是玩玩。 它看起来应该像一个裸露的 Linux 系统。</p><p>使用 CTRL+D 退出容器。 自然的问题是，Docker 镜像是如何构建的？ Dockerfile <strong>。</strong> 就像镜像的源代码 相反，Dockerfile允许您通过指定手动键入创建镜像的所有命令来定义镜像。 然后 Docker 可以从指定Dockerfile 构建镜像。 这些 Dockerfile 可以放入版本控制中，并将镜像上传到在线存储库。</p><p>Docker可以通过读取来自<code>Dockerfile</code>的指令来自动构建镜像 。 <code>Dockerfile</code>是一个文本文档，其中包含所有命令 用户可以在命令行上调用来构建镜像。 eg.下面是一个 <strong>Dockerfile</strong> ，通过将 Python 3 和软件包安装到基础 Fedora Linux 映像上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Specify Fedora Linux as base image</span><br><span class="line">FROM fedora:latest</span><br><span class="line"></span><br><span class="line"># Install Python with yum (Fedora&#x27;s Package Manager)</span><br><span class="line"># Install required Python packages</span><br><span class="line">RUN yum update -y &amp;&amp; yum install -y python3 python3-pip &amp;&amp; \</span><br><span class="line">    python3 -m pip install pyfiglet termcolor</span><br><span class="line"> </span><br><span class="line"># Add the missile.py file to the final image</span><br><span class="line">ADD missile.py /</span><br><span class="line"></span><br><span class="line"># Specify the command to be run on container creation</span><br><span class="line">CMD [&quot;/usr/bin/python3&quot;, &quot;missile.py&quot;]</span><br></pre></td></tr></table></figure><p><code>docker build -t missile:latest .</code></p><p>这告诉 Docker 在当前目录中查找 <code>Dockerfile</code>，并用该文件构建一个镜像。 这 <code>-t</code>flag 告诉 Docker 使用名称标记此构建 <code>missile:latest</code>。</p><p>查看系统上正在运行的容器。 使用以下命令：</p><p><code>docker ps</code></p><p>由于您（可能）没有运行任何容器，因此您可能不会看到任何有趣的东西。 但是，如果您传入 <code>-a</code>标志，您还可以看到已停止的容器：</p><p>要获取有关容器的更多信息，您可以使用 <code>docker logs</code>命令 获取容器的日志（无论它仍在运行还是已退出）：</p><p><code>docker logs &lt;container_id_or_name&gt;</code></p><p>在某些时候，您可能想要清理已退出且不打算再使用的容器：</p><p><code>docker rm &lt;container_id_or_name&gt;</code></p><p>将移除容器。</p><p>查看已经下载的镜像: <code>docker images</code> 图像可能会占用计算机上相当多的空间，因此您可能需要清理不打算使用的图像 使用。 如果您收到有关计算机上没有足够磁盘空间的错误，这一点尤其重要：</p><p><code>docker rmi &lt;image_id&gt;</code></p><p>镜像文件以及容器的各种文件系统都存储在 <code>/var/lib/docker</code></p><h3 id="分离容器">分离容器</h3><p>容器可以以后台服务的形式运行，这适用于一些后台服务的场合，Docker 支持这种方式 以 <code>-d</code>标志，见 <a href="https://docs.docker.com/engine/reference/run/#detached--d">分离 方式启动容器 模式</a></p><p>Docker 为容器创建一个单独的虚拟网络，因此您需要将主机端口转发到您的 容器的端口（这称为 <a href="https://en.wikipedia.org/wiki/Port_forwarding">端口转发</a> 或端口映射）。 容器正在侦听端口 80，因此让我们尝试将主机的端口 5050 转发到容器的端口 ：</p><p><code>docker run -d -p=5050:80 httpd</code></p><p><code>-p</code> 接受冒号分隔的一对 <code>HOST_PORT:CONTAINER_PORT</code></p><p>您实际上可以“附加”到正在运行的容器并在其中运行更多命令，类似于 <code>docker run</code>作品。 使用 这 <code>docker exec</code>命令：</p><p><code>docker exec &lt;container_id_or_name&gt; &lt;command&gt;</code></p><p>要停止此容器，请使用 <code>docker stop &lt;container_id_or_name&gt;</code>.</p><p>您可以使用以下命令重新启动容器 <code>docker restart &lt;container_id_or_name&gt;</code>.</p><h3 id="关于-docker-compose">关于 docker-compose</h3><p><code>docker-compose</code>允许您定义需要多个容器才能运行的应用程序。 例如，在网络上 应用程序，您可能希望实际的 Web 应用程序在单个容器内运行，并且数据库在其中运行 一个不同的容器。</p><p>通常，您根据 <strong>服务</strong> 来定义应用程序。 同样，以 Web 应用程序为例，有 两个不同的服务：应用程序本身和支持它的数据库。 <code>docker-compose</code>让您定义不同的服务 在 <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> 文件中并相应地运行服务。</p><p>其中一件好事是 <code>docker-compose</code>是它会自动为您的容器设置一个网络，其中：</p><ul><li>服务的每个容器都位于网络上，并且可以从网络上的其他容器访问</li><li>每个容器都可以通过其容器名称在网络上发现</li></ul><p>使用 <a href="https://docs.docker.com/compose/install/">Docker 官方网站上的说明安装 Docker Compose</a></p><h1 id="一些小脚本">一些小脚本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">PHONEBOOK_ENTRIES=&quot;phonelist.txt&quot;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">if [ &quot;$#&quot; -lt 1 ]; then</span><br><span class="line"></span><br><span class="line">    exit 1</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;new&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    echo $2 $3 &gt;&gt; phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;list&quot; ]; then</span><br><span class="line"></span><br><span class="line">    if [ ! -e $PHONEBOOK_ENTRIES ] || [ ! -s $PHONEBOOK_ENTRIES ]; then</span><br><span class="line"></span><br><span class="line">        echo &quot;phonebook is empty&quot;</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">        # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">        cat phonelist.txt</span><br><span class="line"></span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;lookup&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    grep $2 phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;remove&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    sed -i &quot;s/$2//g&quot; phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;clear&quot; ]; then</span><br><span class="line"></span><br><span class="line">    # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">    rm phonelist.txt</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">     # YOUR CODE HERE #</span><br><span class="line"></span><br><span class="line">     echo nothing</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">host=$1</span><br><span class="line"></span><br><span class="line">ping -c 1 $host &gt;&gt; log.txt</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line"></span><br><span class="line">    echo &quot;OK&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">    echo &quot;can&#x27;t access&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1/bin/bash</span><br><span class="line"></span><br><span class="line">ip addr show | grep &quot;link/ether&quot; | head -n 1 | cut -d&#x27; &#x27; -f 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;shell脚本&quot;&gt;shell脚本&lt;/h1&gt;
&lt;p&gt;Shell 脚本通常以 shebang 行开头：#!path/to/interpreter。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#!&lt;/code&gt;是一个人类可读的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)#Magic_number&quot;&gt;幻数表示&lt;/a&gt; &lt;code&gt;0x23 0x21&lt;/code&gt;它可以告诉 shell 将文件其余部分的执行传递给 指定翻译。 如果您的脚本作为可执行文件运行（例如 &lt;code&gt;./awesome_shell_script&lt;/code&gt;) 加上 shebang 行，那么 shell 将调用 可执行文件（通常是解释器）位于 &lt;code&gt;path/to/interpreter&lt;/code&gt;运行你的 脚本。 如果您的脚本作为参数传递给解释器，例如 &lt;code&gt;bash awesome_shell_script&lt;/code&gt;，那么 shebang 没有效果并且 &lt;code&gt;bash&lt;/code&gt;会处理 脚本的执行。</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="伯克利" scheme="https://thinklive1.github.io/tags/%E4%BC%AF%E5%85%8B%E5%88%A9/"/>
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="linux" scheme="https://thinklive1.github.io/tags/linux/"/>
    
    <category term="系统管理" scheme="https://thinklive1.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>基于伯克利ds100和cs231n的numpy笔记</title>
    <link href="https://thinklive1.github.io/2023/10/09/numpy/"/>
    <id>https://thinklive1.github.io/2023/10/09/numpy/</id>
    <published>2023-10-09T12:02:04.679Z</published>
    <updated>2023-11-27T12:50:13.887Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.numpy.org/">Numpy</a> 是 Python 中科学计算的核心库。 它提供了高性能的多维数组对象以及使用这些对象的工具 数组。</p><h2 id="数组">数组</h2><p>numpy 数组是一个值网格，所有值都具有相同的类型，并由非负整数组成的元组索引。 它的维度就是数组的秩 ；它的shape就是每个维度的大小组成的元组 <span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array</span><br><span class="line">print(b.shape)                     # Prints &quot;(2, 3)&quot;</span><br><span class="line">print(b[0, 0], b[0, 1], b[1, 0])   # Prints &quot;1 2 4&quot;</span><br></pre></td></tr></table></figure></p><p><a href="https://numpy.org/doc/stable/user/basics.creation.html#arrays-creation">官方数组创建教程</a> <a href="http://ds100.org/fa17/assets/notebooks/numpy/Numpy_Review.html">ds100的numpy教程</a> <a href="https://cs231n.github.io/python-numpy-tutorial/#numpy">cs231n的python numpy教程</a></p><h3 id="创建数组的方法">创建数组的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;np.array([[1.,2.], [3.,4.]])</span><br><span class="line"></span><br><span class="line">array([[ 1.,  2.],</span><br><span class="line">       [ 3.,  4.]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([x for x in range(5)])</span><br><span class="line"></span><br><span class="line">array([0, 1, 2, 3, 4])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([[&quot;A&quot;, &quot;matrix&quot;], [&quot;of&quot;, &quot;words.&quot;]])</span><br><span class="line"></span><br><span class="line">array([[&#x27;A&#x27;, &#x27;matrix&#x27;],</span><br><span class="line">       [&#x27;of&#x27;, &#x27;words.&#x27;]], </span><br><span class="line">      dtype=&#x27;&lt;U6&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.ones([3,2])</span><br><span class="line"></span><br><span class="line">array([[ 1.,  1.],</span><br><span class="line">       [ 1.,  1.],</span><br><span class="line">       [ 1.,  1.]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.random.randn(3,2)</span><br><span class="line"></span><br><span class="line">array([[ 0.3601399 ,  1.31206686],</span><br><span class="line">       [-0.95112397,  0.62475726],</span><br><span class="line">       [-1.24179768,  1.63392069]])</span><br><span class="line">       </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;c = np.full((2,2), 7)  # Create a constant array</span><br><span class="line">print(c)               # Prints &quot;[[ 7.  7.]</span><br><span class="line">                       #          [ 7.  7.]]&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;d = np.eye(2)         # Create a 2x2 identity matrix</span><br><span class="line">print(d)              # Prints &quot;[[ 1.  0.]</span><br><span class="line">                      #          [ 0.  1.]]&quot;</span><br></pre></td></tr></table></figure><h3 id="数组属性">数组属性</h3><ul><li>dtype</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;np.arange(1,5).dtype</span><br><span class="line"></span><br><span class="line">dtype(&#x27;int64&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;np.array([&quot;Hello&quot;, &quot;Worlddddd!&quot;]).dtype</span><br><span class="line"></span><br><span class="line">dtype(&#x27;&lt;U10&#x27;)</span><br><span class="line">/*</span><br><span class="line">What does `&lt;U6` mean?</span><br><span class="line">- `&lt;` Little Endian</span><br><span class="line">- `U` Unicode</span><br><span class="line">- `6` length of longest string</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; np.array([1,2,3]).astype(float)</span><br><span class="line"></span><br><span class="line">array([ 1.,  2.,  3.])</span><br></pre></td></tr></table></figure><p>数组的类型与其包含的数据类型相对应,可以用.astype改变类型</p><h3 id="数组编辑">数组编辑</h3><h4 id="重组和展开">重组和展开</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;np.arange(1,13).reshape(4,3)</span><br><span class="line"></span><br><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [ 4,  5,  6],</span><br><span class="line">       [ 7,  8,  9],</span><br><span class="line">       [10, 11, 12]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;A.flatten()</span><br><span class="line">array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])</span><br></pre></td></tr></table></figure><h4 id="切片索引和整数索引">切片索引和整数索引</h4><p>切片时，第一个参数是行，第二个是列，切片形成的是对原来数组的引用，修改子数组也会影响原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Use slicing to pull out the subarray consisting of the first 2 rows</span><br><span class="line"># and columns 1 and 2; b is the following array of shape (2, 2):</span><br><span class="line"># [[2 3]</span><br><span class="line">#  [6 7]]</span><br><span class="line">b = a[:2, 1:3]</span><br><span class="line"></span><br><span class="line"># A slice of an array is a view into the same data, so modifying it</span><br><span class="line"># will modify the original array.</span><br><span class="line">print(a[0, 1])   # Prints &quot;2&quot;</span><br><span class="line">b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]</span><br><span class="line">print(a[0, 1])   # Prints &quot;77&quot;</span><br></pre></td></tr></table></figure><p>可以混合整数索引和切片索引，这样做会产生一个比原始数组的秩更低的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Two ways of accessing the data in the middle row of the array.</span><br><span class="line"># Mixing integer indexing with slices yields an array of lower rank,</span><br><span class="line"># while using only slices yields an array of the same rank as the</span><br><span class="line"># original array:</span><br><span class="line">row_r1 = a[1, :]    # Rank 1 view of the second row of a</span><br><span class="line">row_r2 = a[1:2, :]  # Rank 2 view of the second row of a</span><br><span class="line">print(row_r1, row_r1.shape)  # Prints &quot;[5 6 7 8] (4,)&quot;</span><br><span class="line">print(row_r2, row_r2.shape)  # Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span><br><span class="line"></span><br><span class="line"># We can make the same distinction when accessing columns of an array:</span><br><span class="line">col_r1 = a[:, 1]</span><br><span class="line">col_r2 = a[:, 1:2]</span><br><span class="line">print(col_r1, col_r1.shape)  # Prints &quot;[ 2  6 10] (3,)&quot;</span><br><span class="line">print(col_r2, col_r2.shape)  # Prints &quot;[[ 2]</span><br><span class="line">                             #          [ 6]</span><br><span class="line">                             #          [10]] (3, 1)&quot;</span><br></pre></td></tr></table></figure><p>整数数组 索引允许你使用另一个数组的数据构造任意数组 大批。 这是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1,2], [3, 4], [5, 6]])</span><br><span class="line"></span><br><span class="line"># An example of integer array indexing.</span><br><span class="line"># The returned array will have shape (3,) and</span><br><span class="line">print(a[[0, 1, 2], [0, 1, 0]])  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># The above example of integer array indexing is equivalent to this:</span><br><span class="line">print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># When using integer array indexing, you can reuse the same</span><br><span class="line"># element from the source array:</span><br><span class="line">print(a[[0, 0], [1, 1]])  # Prints &quot;[2 2]&quot;</span><br><span class="line"></span><br><span class="line"># Equivalent to the previous integer array indexing example</span><br><span class="line">print(np.array([a[0, 1], a[0, 1]]))  # Prints &quot;[2 2]&quot;</span><br></pre></td></tr></table></figure><p>可以用整数数组索引修改数组部分值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create a new array from which we will select elements</span><br><span class="line">a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[ 1,  2,  3],</span><br><span class="line">          #                [ 4,  5,  6],</span><br><span class="line">          #                [ 7,  8,  9],</span><br><span class="line">          #                [10, 11, 12]])&quot;</span><br><span class="line"></span><br><span class="line"># Create an array of indices</span><br><span class="line">b = np.array([0, 2, 0, 1])</span><br><span class="line"></span><br><span class="line"># Select one element from each row of a using the indices in b</span><br><span class="line">print(a[np.arange(4), b])  # Prints &quot;[ 1  6  7 11]&quot;</span><br><span class="line"></span><br><span class="line"># Mutate one element from each row of a using the indices in b</span><br><span class="line">a[np.arange(4), b] += 10</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[11,  2,  3],</span><br><span class="line">          #                [ 4,  5, 16],</span><br><span class="line">          #                [17,  8,  9],</span><br><span class="line">          #                [10, 21, 12]])</span><br></pre></td></tr></table></figure><h4 id="数组的数学运算">数组的数学运算</h4><p>numpy 提供的数学函数的完整列表 <a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">文档</a> Numpy 提供了更多用于操作数组的函数； 完整的列表 <a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">文档</a></p><p>Numpy 提供了许多有用的函数来执行计算 数组； 最有用的之一是 <code>sum</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]])</span><br><span class="line"></span><br><span class="line">print(np.sum(x))  # Compute sum of all elements; prints &quot;10&quot;</span><br><span class="line">print(np.sum(x, axis=0))  # Compute sum of each column; prints &quot;[4 6]&quot;</span><br><span class="line">print(np.sum(x, axis=1))  # Compute sum of each row; prints &quot;[3 7]&quot;</span><br></pre></td></tr></table></figure><p>转置矩阵， 只需使用 <code>T</code>数组对象的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2], [3,4]])</span><br><span class="line">print(x)    # Prints &quot;[[1 2]</span><br><span class="line">            #          [3 4]]&quot;</span><br><span class="line">print(x.T)  # Prints &quot;[[1 3]</span><br><span class="line">            #          [2 4]]&quot;</span><br><span class="line"></span><br><span class="line"># Note that taking the transpose of a rank 1 array does nothing:</span><br><span class="line">v = np.array([1,2,3])</span><br><span class="line">print(v)    # Prints &quot;[1 2 3]&quot;</span><br><span class="line">print(v.T)  # Prints &quot;[1 2 3]&quot;</span><br></pre></td></tr></table></figure><h3 id="广播">广播</h3><p>我们有一个较小的数组和一个 较大的数组，并且我们想多次使用较小的数组来执行某些操作 在更大的阵列上。</p><p>例如，假设我们要向每个添加一个常数向量 矩阵的行。 我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = np.empty_like(x)   # Create an empty matrix with the same shape as x</span><br><span class="line"></span><br><span class="line"># Add the vector v to each row of the matrix x with an explicit loop</span><br><span class="line">for i in range(4):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"># Now y is the following</span><br><span class="line"># [[ 2  2  4]</span><br><span class="line">#  [ 5  5  7]</span><br><span class="line">#  [ 8  8 10]</span><br><span class="line">#  [11 11 13]]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>Numpy 广播允许我们执行此计算，而无需实际执行 创建多个副本 <code>v</code>。 考虑这个版本，使用广播：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = x + v  # Add v to each row of x using broadcasting</span><br><span class="line">print(y)  # Prints &quot;[[ 2  2  4]</span><br><span class="line">          #          [ 5  5  7]</span><br><span class="line">          #          [ 8  8 10]</span><br><span class="line">          #          [11 11 13]]&quot;</span><br></pre></td></tr></table></figure><p>线路 <code>y = x + v</code>尽管有效 <code>x</code>有形状 <code>(4, 3)</code>和 <code>v</code>有形状 <code>(3,)</code>由于广播； 这条线的工作原理就像 <code>v</code>实际上有形状 <code>(4, 3)</code>, 其中每一行都是一个副本 <code>v</code>，并且按元素求和。</p><p>一起广播两个数组遵循以下规则：</p><ol type="1"><li>如果数组没有相同的秩，则在前面添加较低秩数组的形状 1s 直到两个形状具有相同的长度。</li><li>如果两个数组具有相同的维度，则称 <em>兼容</em> 它们在维度上 维度中的大小，或者如果其中一个数组在该维度中的大小为 1。</li><li>如果数组在所有维度上都兼容，则可以一起广播。</li><li>广播后，每个数组的行为就好像它的形状等于元素方向 两个输入数组的形状的最大值。</li><li>在一个数组的大小为 1 而另一个数组的大小大于 1 的任何维度中， 第一个数组的行为就好像它是沿着该维度复制的</li></ol><p>一些应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Compute outer product of vectors</span><br><span class="line">v = np.array([1,2,3])  # v has shape (3,)</span><br><span class="line">w = np.array([4,5])    # w has shape (2,)</span><br><span class="line"># To compute an outer product, we first reshape v to be a column</span><br><span class="line"># vector of shape (3, 1); we can then broadcast it against w to yield</span><br><span class="line"># an output of shape (3, 2), which is the outer product of v and w:</span><br><span class="line"># [[ 4  5]</span><br><span class="line">#  [ 8 10]</span><br><span class="line">#  [12 15]]</span><br><span class="line">print(np.reshape(v, (3, 1)) * w)</span><br><span class="line"></span><br><span class="line"># Add a vector to each row of a matrix</span><br><span class="line">x = np.array([[1,2,3], [4,5,6]])</span><br><span class="line"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span><br><span class="line"># giving the following matrix:</span><br><span class="line"># [[2 4 6]</span><br><span class="line">#  [5 7 9]]</span><br><span class="line">print(x + v)</span><br><span class="line"></span><br><span class="line"># Add a vector to each column of a matrix</span><br><span class="line"># x has shape (2, 3) and w has shape (2,).</span><br><span class="line"># If we transpose x then it has shape (3, 2) and can be broadcast</span><br><span class="line"># against w to yield a result of shape (3, 2); transposing this result</span><br><span class="line"># yields the final result of shape (2, 3) which is the matrix x with</span><br><span class="line"># the vector w added to each column. Gives the following matrix:</span><br><span class="line"># [[ 5  6  7]</span><br><span class="line">#  [ 9 10 11]]</span><br><span class="line">print((x.T + w).T)</span><br><span class="line"># Another solution is to reshape w to be a column vector of shape (2, 1);</span><br><span class="line"># we can then broadcast it directly against x to produce the same</span><br><span class="line"># output.</span><br><span class="line">print(x + np.reshape(w, (2, 1)))</span><br><span class="line"></span><br><span class="line"># Multiply a matrix by a constant:</span><br><span class="line"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span><br><span class="line"># these can be broadcast together to shape (2, 3), producing the</span><br><span class="line"># following array:</span><br><span class="line"># [[ 2  4  6]</span><br><span class="line">#  [ 8 10 12]]</span><br><span class="line">print(x * 2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.numpy.org/&quot;&gt;Numpy&lt;/a&gt; 是 Python 中科学计算的核心库。 它提供了高性能的多维数组对象以及使用这些对象的工具 数组。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;p&gt;numpy 数组是一个值网格，所有值都具有相同的类型，并由非负整数组成的元组索引。 它的维度就是数组的秩 ；它的shape就是每个维度的大小组成的元组</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据科学" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="伯克利" scheme="https://thinklive1.github.io/tags/%E4%BC%AF%E5%85%8B%E5%88%A9/"/>
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="python" scheme="https://thinklive1.github.io/tags/python/"/>
    
    <category term="数据科学" scheme="https://thinklive1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    <category term="pandas" scheme="https://thinklive1.github.io/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>基于伯克利cs61b的java数据结构笔记</title>
    <link href="https://thinklive1.github.io/2023/10/06/61b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/"/>
    <id>https://thinklive1.github.io/2023/10/06/61b%E6%80%BB%E5%92%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-06T15:01:27.530Z</published>
    <updated>2023-11-27T12:50:13.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ppt部分">ppt部分</h1><h2 id="java基础">java基础</h2><p>类内static方法可以被类名调用，对象定义方法只有对象能调用 当类不独立时，嵌套类很有用,并且显然隶属于另一个类。</p><ul><li>如果其他类不应该使用嵌套类，则将嵌套类设为私有类 <img src="/assets/61b总和笔记/image-20230920083903996.png" alt="img" /> <span id="more"></span></li></ul><p>接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface List61B&lt;Item&gt; &#123;</span><br><span class="line">public void addFirst(Item x);</span><br><span class="line">public void addLast(Item y);</span><br><span class="line">public Item getFirst();</span><br><span class="line">public Item getLast();</span><br><span class="line">public Item removeLast();</span><br><span class="line">public Item get(int i);</span><br><span class="line">public void insert(Item x, int position);</span><br><span class="line">public int size();</span><br><span class="line">&#125;</span><br><span class="line">public static String longest(List61B&lt;String&gt; list) &#123;</span><br><span class="line">int maxDex = 0;</span><br><span class="line">for (int i = 0; i &lt; list.size(); i += 1) &#123;</span><br><span class="line">String longestString = list.get(maxDex);</span><br><span class="line">String thisString = list.get(i);</span><br><span class="line">if (thisString.length() &gt; longestString.length()) &#123;</span><br><span class="line">maxDex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list.get(maxDex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>override重写：特征值不变，子类重写父类 overload重载：特征值改变 Java 有 8 种基本类型。 所有其他类型都是引用类型。 对于每个基本类型，都有一个相应的引用类型，称为 包装类。</p><ul><li>例如，boolean的包装类是Boolean。 基本类型不能用在模板上，包装类可以</li><li>如果 Java 代码需要包装类型并获取原语，则会自动装箱。</li><li>如果代码需要一个原语并获得一个包装器，则它会被拆箱。</li><li>数组永远不会自动装箱/拆箱，例如 Integer[] 不能用于 int[] 的位置（反之亦然）。</li><li>自动装箱/拆箱会对性能产生可衡量的影响！</li><li>包装类型比原始类型使用更多的内存。 public final ArrayDeque&lt;String&gt; d = new ArrayDeque&lt;String&gt;();</li><li>The d variable can never change, but the referenced deque can Arrays are covariant:</li><li>A FrenchDog is-a Dog.</li><li>An FrenchDog[] is-a Dog[]. Generic types are invariant:</li><li>A List&lt;FrenchDog&gt; is NOT a List&lt;Dog&gt;.</li></ul><h3 id="java实现链表">java实现链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">public class LinkedListDeque&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public class Node &#123;</span><br><span class="line"></span><br><span class="line">        Node next,prev=null;</span><br><span class="line"></span><br><span class="line">        T value;</span><br><span class="line"></span><br><span class="line">        public Node(T val) &#123;</span><br><span class="line"></span><br><span class="line">            value=val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size=0;</span><br><span class="line"></span><br><span class="line">    Node firstnode = new Node();</span><br><span class="line"></span><br><span class="line">    public LinkedListDeque() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line"></span><br><span class="line">        return Objects.equals(size,0);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addFirst(T item) &#123;</span><br><span class="line"></span><br><span class="line">        Node new_node=new Node(item);</span><br><span class="line"></span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            firstnode.next=firstnode.prev=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.next=new_node.prev=firstnode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            firstnode.next.prev=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.next=firstnode.next;</span><br><span class="line"></span><br><span class="line">            firstnode.next=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.prev=firstnode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addLast(T item) &#123;</span><br><span class="line"></span><br><span class="line">        Node new_node=new Node(item);</span><br><span class="line"></span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            firstnode.next=firstnode.prev=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.next=new_node.prev=firstnode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            new_node.prev=firstnode.prev;</span><br><span class="line"></span><br><span class="line">            firstnode.prev.next=new_node;</span><br><span class="line"></span><br><span class="line">            firstnode.prev=new_node;</span><br><span class="line"></span><br><span class="line">            new_node.next=firstnode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line"></span><br><span class="line">        return size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printDeque() &#123;</span><br><span class="line"></span><br><span class="line">        Node temp=firstnode.next;</span><br><span class="line"></span><br><span class="line">        while (temp!= firstnode) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(temp.value);</span><br><span class="line"></span><br><span class="line">            temp=temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T removeFirst() &#123;</span><br><span class="line"></span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if (size()==1) &#123;</span><br><span class="line"></span><br><span class="line">            T val=firstnode.next.value;</span><br><span class="line"></span><br><span class="line">            firstnode.prev=firstnode.next=null;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            return val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            T val= firstnode.next.value;</span><br><span class="line"></span><br><span class="line">            firstnode.next.next.prev=firstnode;</span><br><span class="line"></span><br><span class="line">            firstnode.next=firstnode.next.next;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            return val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T removeLast() &#123;</span><br><span class="line"></span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        else if (size()==1) &#123;</span><br><span class="line"></span><br><span class="line">            T val;</span><br><span class="line"></span><br><span class="line">            val=firstnode.next.value;</span><br><span class="line"></span><br><span class="line">            firstnode.prev=firstnode.next=null;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            return val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            T val;</span><br><span class="line"></span><br><span class="line">            val=firstnode.prev.value;</span><br><span class="line"></span><br><span class="line">            firstnode.prev.prev.next=firstnode;</span><br><span class="line"></span><br><span class="line">            firstnode.prev=firstnode.prev.prev;</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            return val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T get(int index) &#123;</span><br><span class="line"></span><br><span class="line">        if (index&gt;size()-1) &#123;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line"></span><br><span class="line">            Node temp = firstnode;</span><br><span class="line"></span><br><span class="line">            for (int i=0;i&lt;index;i++) &#123;</span><br><span class="line"></span><br><span class="line">                temp=temp.next;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return temp.value;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java单元测试">java单元测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@test</span><br><span class="line">public void testMethod() &#123;</span><br><span class="line">    assertEquals(&lt;expected&gt;, &lt;actual&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 JUnit 测试文件时，应在每个测试方法前面加上 <code>@Test</code>注解，并且可以有一个或多个 <code>assertEquals</code>或者 <code>assertTrue</code>方法（由 JUnit 库提供）。 <strong>所有测试必须是非静态的。</strong> 这可能看起来很奇怪，因为您的测试不使用实例变量并且您 可能不会实例化该类。 然而，设计师们却是这样的 JUnit 决定应该编写测试，所以我们就这么做。</p><h3 id="权限控制">权限控制</h3><p><img src="/assets/61b总和笔记/image-20230920090532017.png" /></p><h2 id="bst-in-java">BST IN JAVA</h2><p><img src="/assets/61b总和笔记/image-20230920081714565.png" /> 表示连接的数组：若数字相同则这些节点互相可达 <img src="/assets/61b总和笔记/image-20230920081830858.png" /> 增加父节点后形成bst</p><h2 id="加权bst">加权bst</h2><p><img src="/assets/61b总和笔记/image-20230920082840743.png" /> 维护一个size数组，只能将较小的树加到较大的树上 <img src="/assets/61b总和笔记/image-20230920083245937.png" /></p><h3 id="完整代码">完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class WeightedQuickUnionDSWithPathCompression implements DisjointSets &#123;</span><br><span class="line">private int[] parent; private int[] size;</span><br><span class="line">public WeightedQuickUnionDSWithPathCompression(int N) &#123;</span><br><span class="line">parent = new int[N]; size = new int[N];</span><br><span class="line">for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">parent[i] = i;</span><br><span class="line">size[i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private int find(int p) &#123;</span><br><span class="line">if (p == parent[p]) &#123;</span><br><span class="line">return p;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">parent[p] = find(parent[p]);</span><br><span class="line">return parent[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean isConnected(int p, int q) &#123;</span><br><span class="line">return find(p) == find(q);</span><br><span class="line">&#125;</span><br><span class="line">public void connect(int p, int q) &#123;</span><br><span class="line">int i = find(p);</span><br><span class="line">int j = find(q);</span><br><span class="line">if (i == j) return;</span><br><span class="line">if (size[i] &lt; size[j]) &#123;</span><br><span class="line">parent[i] = j; size[j] += size[i];</span><br><span class="line">&#125; </span><br><span class="line">else &#123;</span><br><span class="line">parent[j] = i; size[i] += size[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的旋转">树的旋转</h3><p><img src="/assets/61b总和笔记/image-20230920093054610.png" /> 右旋同理</p><h3 id="如果叶节点有最大负载限制">如果叶节点有最大负载限制</h3><p><img src="/assets/61b总和笔记/image-20230920175806667.png" /> 分裂树(B树)具有完美的平衡。</p><ul><li>如果我们分裂根，每个节点都会被下推一层。</li><li>如果我们分割叶节点或内部节点，高度不会改变 所有操作Θ(log N)</li></ul><h3 id="红黑树">红黑树</h3><p>任何与 2-3 树保持等距的 BST 都具有以下属性：</p><ul><li>没有节点有两个红色链接（否则它就像一个 4 节点）。</li><li>从根到叶子的每条路径都有相同数量的黑色链接。</li><li>红色链接向左倾斜。</li><li>也称为“左倾红黑二叉搜索树（LLRB） <img src="/assets/61b总和笔记/image-20230920180350334.png" /></li></ul><h2 id="hash">hash</h2><p>如果 N 个项目分布在 M 个桶中，则平均时间取决于 N/M = L，也称为 负载系数 . ○ 平均运行时间为 Θ (L)。 <img src="/assets/61b总和笔记/image-20230920222654955.png" /></p><h2 id="最小堆">最小堆</h2><p>二叉最小堆：二叉树完整，并服从 最小堆属性 .</p><ul><li>最小堆：每个节点都小于或等于其两个子节点。</li><li>完整：仅在底层（如果有）缺少项目，所有节点都尽可能远 尽可能左。 <img src="/assets/61b总和笔记/image-20230921103325455.png" /></li></ul><h3 id="遍历">遍历</h3><ul><li>节点遍历：前中后序</li><li>层次遍历 实现指针接口——使用栈 <img src="/assets/61b总和笔记/image-20230921112835278.png" /> 两个类的equals实现，如果是哈希，一般需要同时确保hashcode方法对内容相同的类返回相同的哈希码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object o) &#123;  </span><br><span class="line">    if (o==this) return true;  </span><br><span class="line">    if (o==null) return false;  </span><br><span class="line">    if (o.getClass()!=this.getClass()) return false;  </span><br><span class="line">    SimpleOomage new_o=(SimpleOomage) o;  </span><br><span class="line">    return new_o.blue==this.blue &amp;&amp;new_o.red==this.red &amp;&amp; new_o.green==this.green;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图论">图论</h2><h3 id="迪杰斯特拉">迪杰斯特拉</h3><p><a href="https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&amp;loop=false&amp;delayms=3000#slide=id.g771336078_0_180">演示</a> <img src="/assets/61b总和笔记/image-20230923101738378.png" /> <img src="/assets/61b总和笔记/image-20230923101849254.png" /> <a href="https://algs4.cs.princeton.edu/44sp/DijkstraSP.java.html">伯克利实现</a></p><h3 id="最小生成树mst">最小生成树（MST)</h3><p>最短路径树取决于起始顶点：</p><ul><li>因为它告诉你如何从源头到达一切。 MST 没有来源。 尽管如此，MST 有时恰好是特定顶点的 SPT</li></ul><h2 id="排序">排序</h2><p><code>稳定性</code>：如果保留等价项的顺序，则称排序是稳定的。</p><ul><li>选择排序：找到最小的项并将其放在前面。</li><li>插入排序：找出当前项插入的位置。</li><li>归并排序：将两个已排序的半部分合并为一个已排序的整体。</li><li>分区（快速）排序：围绕枢轴对项目进行分区。 <img src="/assets/61b总和笔记/image-20231006205748498.png" /></li></ul><h3 id="快速排序">快速排序</h3><p><a href="https://docs.google.com/presentation/d/1DOnWS59PJOa-LaBfttPRseIpwLGefZkn450TMSSUiQY/pub?start=false&amp;loop=false&amp;delayms=3000#slide=id.g12b16fb6b6_0_2">演示</a> 不严谨地证明快排性能 <img src="/assets/61b总和笔记/image-20231006204101527.png" /> <code>Quicksort is BST Sort</code> <img src="/assets/61b总和笔记/image-20231006204242323.png" /></p><h3 id="优化">优化</h3><ul><li>切换到插入排序:- 当子问题大小减小到15或更小时,使用插入排序。</li><li>使排序自适应:<strong>利用数组中已有的顺序</strong>(插入排序,平滑排序,TimSort(Python和Java中的排序))。</li><li>利用键集的限制。如果键的个数是某个常数,例如[3, 4, 1, 2, 4, 3, ..., 2, 2, 2, 1, 4, 3, 2, 3],可以更快排序(参见三路快速排序,如果你好奇可以看这里:<a href="http://goo.gl/3sYnv3">http://goo.gl/3sYnv3</a>)。</li><li>对于快速排序:使算法具有自我检查能力,如果递归太深则切换到不同的排序方法。这只是确定性快速排序的问题。</li></ul><p>在 Java 中，Arrays.sort(someArray) 使用：</p><ul><li>合并排序（特别是 TimSort 变体）如果 someArray 包含 对象。</li><li>如果 someArray 由基本类型组成，则进行快速排序。</li></ul><h3 id="证明">证明</h3><ol type="1"><li>We have that N! &gt; (N/2) N/2</li></ol><ul><li>Taking the log of both sides, we have that log(N!) &gt; log((N/2) N/2 ).</li><li>Bringing down the exponent we have that log(N!) &gt; N/2 log(N/2).</li><li>Discarding the unnecessary constant, we have log(N!) ∈ Ω(N log (N/2)).</li><li>From there, we have that log(N!) ∈ Ω(N log N).</li></ul><ol start="2" type="1"><li><ul><li>log(N!) = log(N) + log(N-1) + log(N-2) + …. + log(1)</li></ul></li></ol><ul><li>N log N = log(N) + log(N) + log(N) + … log(N)</li><li>Therefore N log N ∈ Ω(log(N!)) 结论：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N log N ∈ Θ(log N!)</span><br><span class="line">log N! ∈ Θ(N log N)</span><br></pre></td></tr></table></figure><p>比较排序中：</p><ul><li>Decision tree needs N! leaves.</li><li>So we need lg(N!) rounded up levels, which is Ω(log(N!))</li></ul><h2 id="数据集">数据集</h2><h3 id="digit-by-digit">Digit-by-Digit</h3><p><a href="https://www.cs.princeton.edu/courses/archive/spring15/cos226/demo/52DemoTrie.mov">演示</a> Given a Trie with N keys, and a key with L digits. What is the:</p><ul><li>Worst case insert runtime? Θ(L)</li><li>Worst case search runtime? Θ(L)</li><li>Best case search runtime? Θ(1)</li></ul><p><img src="/assets/61b总和笔记/image-20231006215117117.png" /> <img src="/assets/61b总和笔记/image-20231006215302639.png" /> 优化:</p><ul><li>Data-indexed array: Max speed, max memory.</li><li>TreeMap/HashMap: Slower query performance, but less memory wasted. <img src="/assets/61b总和笔记/image-20231006215646467.png" /> <img src="/assets/61b总和笔记/image-20231006215851901.png" /></li></ul><h4 id="三元搜索">三元搜索</h4><p><a href="https://algs4.cs.princeton.edu/52trie/TST.java.html">实现</a></p><ul><li>为每个节点分配一个字符。</li><li>给每个节点 3 个链接： ○ 如果键的下一个字符 &lt; 节点的字符，则左链接。 ○ 如果键的下一个字符 == 节点的字符，则中间链接。 ○ 如果键的下一个字符 &gt; 节点的字符，则右链接。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TST&lt;Value&gt; &#123;</span><br><span class="line">    private int n;              // size</span><br><span class="line">    private Node&lt;Value&gt; root;   // root of TST</span><br><span class="line"></span><br><span class="line">    private static class Node&lt;Value&gt; &#123;</span><br><span class="line">        private char c;                        // character</span><br><span class="line">        private Node&lt;Value&gt; left, mid, right;  // left, middle, and right subtries</span><br><span class="line">        private Value val;                     // value associated with string</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>数据结构</th><th>平均复杂度</th><th>最坏情况</th><th>最好情况</th><th>内存消耗</th></tr></thead><tbody><tr class="odd"><td>哈希表</td><td>Θ(L)*</td><td></td><td> </td><td>Θ(NL)</td></tr><tr class="even"><td>二叉搜索树</td><td></td><td>Θ(L log N)</td><td>Θ(1)</td><td>Θ(NL)</td></tr><tr class="odd"><td>Trie (数组)</td><td></td><td>Θ(L)</td><td>Θ(1)</td><td>Θ(NLR)</td></tr><tr class="even"><td>Trie (哈希表)</td><td></td><td>Θ(L)</td><td>Θ(1)</td><td>Θ(NL)</td></tr><tr class="odd"><td>Trie (树)</td><td></td><td>Θ(L log R)</td><td>Θ(1)</td><td>Θ(NL)</td></tr><tr class="even"><td>TST</td><td></td><td>Θ(NL)</td><td>Θ(1)</td><td>Θ(NL)</td></tr></tbody></table><p><strong>N keys, L digits per key, R alphabet size. A miss means the key isn’t present.</strong></p><h2 id="编码和压缩">编码和压缩</h2><p>A prefix-free code is one in which no codeword is a prefix of any other. Example for English:</p><table><thead><tr class="header"><th>字符</th><th>编码</th></tr></thead><tbody><tr class="odd"><td>space</td><td>111</td></tr><tr class="even"><td>E</td><td>010</td></tr><tr class="odd"><td>T</td><td>1101</td></tr><tr class="even"><td>A</td><td>1011</td></tr><tr class="odd"><td>O</td><td>1001</td></tr><tr class="even"><td>I</td><td>1000</td></tr></tbody></table><p>I ATE: 100011110111101010</p><h3 id="shannon-fano编码">Shannon-Fano编码</h3><ul><li>Count relative frequencies of all characters in a text.</li><li>Split into ‘left’ and ‘right halves’ of roughly equal frequency. ○ Left half gets a leading zero. Right half gets a leading one. ○ Repeat.</li></ul><h3 id="huffman编码">Huffman编码</h3><ul><li>Assign each symbol to a node with weight = relative frequency.</li><li>Take the two smallest nodes and merge them into a super node with weight equal to sum of weights.</li><li>Repeat until everything is part of a tree.</li><li>将每个符号分配给一个节点，权重=相对频率。</li><li>取两个最小的节点，合并成一个带权重的超级节点 等于权重之和。</li><li>重复直到所有东西都是树的一部分。</li></ul><h3 id="霍夫曼压缩">霍夫曼压缩</h3><p>使用霍夫曼压缩的两种可能的原理：</p><ol type="1"><li>为每种输入类型构建一个语料库。</li><li>对于每个可能的输入文件，仅为该文件创建一个唯一的代码。 发送 代码与压缩文件一起。</li></ol><p>实例：<a href="https://docs.google.com/presentation/d/1DWuSkE9MxQPUTjbSJCMe54rCim4eAwM4aFRvhqq5_Hs/edit#slide=id.g2159afc5e6_0_1044">演示</a> 编码： 第 1 步：计算频率。 步骤2：构建编码数组和解码树。 步骤3：将解码trie写入output.huf。 步骤4：将每个符号的码字写入output.huf。 解码： 步骤1：读入解码树。 步骤 2：沿着 trie 遍历，每次都输出符号 当到达一片叶子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a file X.txt that we’d like to compress into X.huf:</span><br><span class="line">- Consider each b-bit symbol (e.g. 8-bit chunks, Unicode characters, etc.) of</span><br><span class="line">X.txt, counting occurrences of each of the 2 b possibilities, where b is the size</span><br><span class="line">of each symbol in bits.</span><br><span class="line">- Use Huffman code construction algorithm to create a decoding trie and</span><br><span class="line">encoding map. Store this trie at the beginning of X.huf.</span><br><span class="line">- Use encoding map to write codeword for each symbol of input into X.huf.</span><br><span class="line">To decompress X.huf:</span><br><span class="line">- Read in the decoding trie.</span><br><span class="line">- Repeatedly use the decoding trie’s longestPrefixOf operation until all bits in</span><br><span class="line">X.hug have been converted back to their uncompressed form.</span><br></pre></td></tr></table></figure><h3 id="lzw压缩">LZW压缩</h3><p><a href="https://docs.google.com/presentation/d/1U8XO6CWfcU4QgrFOZmGjAgmaKxLc8HXk6qB1JQVlqrg/edit#slide=id.g53705ba95_0259">演示</a> Key idea: Each codeword represents multiple symbols.</p><ul><li>Start with ‘trivial’ codeword table where each codeword corresponds to one ASCII symbol.</li><li>Every time a codeword X is used, record a new codeword Y corresponding to X concatenated with the next symbol</li><li>从“简单”码字表开始，其中每个码字对应 一个 ASCII 符号。</li><li>每使用一个码字X，记录一个对应的新码字Y 到 X 与下一个符号连接。</li></ul><h3 id="总结">总结</h3><p>霍夫曼编码：</p><ul><li>将公共符号表示为具有较少位的码字。</li><li>使用诸如 Map&lt;Character, BitSeq&gt; 之类的东西进行压缩。</li><li>使用 TrieMap&lt;Character&gt; 之类的东西进行解压缩。 LZW:</li><li>用单个码字表示多个符号。</li><li>使用 TrieMap&lt;Integer&gt; 之类的东西进行压缩。</li><li>使用诸如 Map&lt;Character, SymbolSeq&gt; 之类的东西进行解压缩。</li></ul><h2 id="附加内容">附加内容</h2><h3 id="柯尔莫哥洛夫复杂度">柯尔莫哥洛夫复杂度</h3><p>Given a target bitstream B, what is the shortest bitstream C B that outputs B.</p><ul><li>Definition: The Java-Kolmogorov complexity K J (B) is the length of the shortest Java program (in bytes) that generates B. ○ There IS an answer. It just might be very hard to find.</li></ul><ol type="1"><li>柯尔莫哥洛夫复杂度实际上与语言无关。</li></ol><ul><li>对于任何比特流，Java-Kolmogorov 复杂度不超过 大于 Python-Kolmogorov 复杂度的常数因子。—— I could just write a Python interpreter in Java and then run Kevin’s program. ○ K J (B) ≤ K P (B) + size(python interpreter)</li></ul><ol start="2" type="1"><li>It is impossible to write a program that calculates the Kolmogorov Complexity of any bitstream. Proof available here</li></ol><h3 id="独立集问题">独立集问题</h3><p>独立集是一组顶点，其中没有两个顶点相邻。 独立集问题：</p><ul><li>是否存在大小为 k 的独立集合？</li><li>即，k 个顶点的颜色为红色，这样就没有接触。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Give an algorithm for solving this problem.</span><br><span class="line">- For each of the possible 2 N colorings:</span><br><span class="line">○ Check if number of colored vertices is equal to k: O(N)</span><br><span class="line">○ For every red vertex, check that neighbors are all white: O(k*N)</span><br><span class="line">○ If both checks succeed, return true.</span><br><span class="line">○ If either check fails, go on to next coloring.</span><br><span class="line">- Runtime: O(k*N*2 N ). Since k ≤ N, O(N 2 *2 N )</span><br></pre></td></tr></table></figure><h3 id="npp">np=p</h3><p>We say that a problem is in the complexity class P if:</p><ul><li>It is a decision problem.</li><li>An answer can be found in O(N k ) time for some k</li></ul><p>We say that a problem is in the complexity class NP if:</p><ul><li>It is a decision problem.</li><li>A “yes” answer can be verified in O(N k ) time for some k. More precisely, we can verify a specific example of a “yes” answer in O(N k ) time</li></ul><p>Many (most?) practical problems can be cast as a problem in NP:</p><ul><li>Is there a way to route my airplanes at a total cost of less than $1B/yr?</li><li>Is there a way to route the wires inside this microchip with a total path length of less than 1 micrometer?</li><li>Given Z, are there two primes such that X*Y = Z?</li><li>Is there a protein configuration for amino acid sequence X whose total energy is less than Y?</li></ul><p>Nice features of P:</p><ul><li>O(N k ) is closed under addition and multiplication. ○ Run two P algorithms, overall still in P. ○ Run a P algorithm in N times, still in P <img src="/assets/61b总和笔记/image-20231006223527363.png" /> 共识意见</li><li>83%：P ≠ NP（126 名受访者）</li><li>9%：P = NP（12 名受访者）</li><li>9%：其他（13 名受访者）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“[针对我们现在所说的 NP 完全问题的线性或二次时间过程将会产生]最严重的后果。[对于这样的程序]将 明确表明，尽管Entscheidungs问题无法解决，数学家在回答是或否问题时的脑力劳动可以是完全被机器取代了。”  ——库尔特·哥德尔</span><br></pre></td></tr></table></figure><h2 id="总结-1">总结</h2><ul><li><p>基于对象的编程：围绕对象进行组织。</p></li><li><p>面向对象编程： ○ 接口继承。 ○ 实现继承。</p></li><li><p>动态类型与静态类型。</p></li><li><p>泛型编程，例如ArrayList&lt;Integer&gt;等。</p></li><li><p>内存模型是包含位的盒子。</p></li><li><p>正整数的位表示。</p></li><li><p>java</p></li><li><p>一些标准的编程习惯/模式： ○ 作为函数容器的对象（例如比较器、IntUnaryFunctions）。 ○ 接口中的默认方法规范（链接）。 ○ 迭代器和视图（例如keySet）。</p></li><li><p>Java 中重要的数据结构 重要数据结构接口：</p></li><li><p>java.util.Collection（及其子类型）。 ○ 特别强调 Map（及其子类型）。</p></li><li><p>我们自己的集合（例如Map61B、Deque）：实际上并没有扩展集合。</p></li><li><p>运行时间分析 时间复杂度表示 渐进分析 数学证明 最好，最坏，平均情况</p></li><li><p>数据结构 Array-Based Data Structures:</p></li><li><p>ArrayLists and ArrayDeque</p></li><li><p>HashSets, HashMaps, MyHashMap: Arrays of ‘buckets’</p></li><li><p>ArrayHeap (tree represented as an array) Linked Data Structures</p></li><li><p>Linked Lists ○ LinkedList, IntList, LinkedListDeque, SLList, DLList</p></li><li><p>Trees: Hierarchical generalization of a linked list. Aim for bushiness. ○ TreeSet, TreeMap, BSTMap, Tries (trie links often stored as arrays)</p></li><li><p>Graphs: Generalization of a tree (including many algorithms).</p></li><li><p>编程实践</p></li><li><p>Java 语法和习惯用法。</p></li><li><p>JUnit 测试（及其更极端的形式：测试驱动开发）。</p></li><li><p>挖掘网络代码。</p></li><li><p>调试： ○ 确定受错误影响的最简单的情况。 ○ 追捕它，让它无处藏身。 ○ 有了正确的方法，即使通过查找bug也能找到bug 手动代码检查是不可能的（参见lab3中的Horrible Steve）。</p></li><li><p>真正的工具：IntelliJ、git、命令行、Maven</p></li><li><p>数据结构选择（和API设计） ○ 推动整个计划的绩效和实施。</p></li><li><p>使用复杂的 API、规范：项目 2 和项目 3 ○ 项目 3 还涉及与现有代码库的交互。</p></li><li><p>其他 压缩：</p></li><li><p>霍夫曼编码，以及霍夫曼编码的数据结构选择。</p></li><li><p>其他方法：LZW 和游程编码（额外的幻灯片）。</p></li><li><p>观察：比特流的最佳压缩将提供 该位流的有用模型（例如，hugPlant.bmp -&gt; HugPlant.java）。 不可能且棘手的问题：</p></li><li><p>不可能：为任何输入找到最佳压缩的算法。</p></li><li><p>棘手问题：3SAT、独立集、NP 完备性。 ○ P = NP 吗？ “是”的答案具有戏剧性的意义。</p></li></ul><p><img src="/assets/61b总和笔记/image-20231006224146653.png" /></p><h1 id="作业中的实现待续">作业中的实现（待续）</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ppt部分&quot;&gt;ppt部分&lt;/h1&gt;
&lt;h2 id=&quot;java基础&quot;&gt;java基础&lt;/h2&gt;
&lt;p&gt;类内static方法可以被类名调用，对象定义方法只有对象能调用 当类不独立时，嵌套类很有用,并且显然隶属于另一个类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果其他类不应该使用嵌套类，则将嵌套类设为私有类 &lt;img src=&quot;/assets/61b总和笔记/image-20230920083903996.png&quot; alt=&quot;img&quot; /&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="伯克利" scheme="https://thinklive1.github.io/tags/%E4%BC%AF%E5%85%8B%E5%88%A9/"/>
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法" scheme="https://thinklive1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="JAVA" scheme="https://thinklive1.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>基于c++ primer plus的读书笔记</title>
    <link href="https://thinklive1.github.io/2023/10/05/cpp%20primer%20plus%E6%80%BB%E5%92%8C/"/>
    <id>https://thinklive1.github.io/2023/10/05/cpp%20primer%20plus%E6%80%BB%E5%92%8C/</id>
    <published>2023-10-05T14:45:42.281Z</published>
    <updated>2023-11-27T12:47:59.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言部分">c语言部分</h1><h2 id="基本函数构成">基本函数构成</h2><p>将数组传递为函数参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fcname(int arg[],int n)</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="基本输入输出">基本输入输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- cin及其衍生函数返回一个iostream函数的引用，即支持</span><br><span class="line">cin,get().get()</span><br><span class="line">iostream的其他成员</span><br><span class="line">- cout.put()显示字符</span><br><span class="line">- cout.write()显示字符串</span><br><span class="line">- cout&lt;&lt;flush刷新缓冲区</span><br><span class="line">- cout&lt;&lt;endl刷新缓冲区并提供换行符</span><br><span class="line">- dec,hex,oct控制输出数制</span><br><span class="line">hex(cout)控制cout为16进制</span><br><span class="line">- int width()返回字段宽度当前设置</span><br><span class="line"> int width(int i)设置字段宽度，返回以前字段宽度 </span><br><span class="line"> 只影响下一次输出</span><br><span class="line"> - fill()设置填充用字符</span><br><span class="line"> - precision()设置精度，即保留几位小数</span><br><span class="line"> - setf()设置各种输出格式</span><br><span class="line"> - 流状态stream_state(eof,fail,bad)</span><br><span class="line"> - cin.get(ch)读取下一个字符，跳过换行符和空白</span><br><span class="line"> - cin.get()读取空白和换行符</span><br><span class="line"> - cin.get()get的基础上读取到换行符并丢弃</span><br><span class="line"> - cin.read()读取内容，但不会在末尾加空字符</span><br><span class="line"> - cin.peek()读取输入流下一个字符但不抽取</span><br><span class="line"> - cin.putback(ch)把一个字符放到输入流最前</span><br></pre></td></tr></table></figure><h3 id="文件输入输出">文件输入输出</h3><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">写入文件</span><br><span class="line">ofstream fout;//ofstream继承ostream</span><br><span class="line">fout.open(&quot;hello.txt&quot;);</span><br><span class="line">fout &lt;&lt; &quot;i&#x27;m adding sth&quot;</span><br><span class="line">|| ofstream fout(&quot;hello.txt&quot;);</span><br><span class="line">读取文件也类似</span><br><span class="line">fin &gt;&gt; ch||string</span><br><span class="line">关闭流</span><br><span class="line">fout.close()</span><br><span class="line">fin.close()</span><br><span class="line">检测文件是否打开</span><br><span class="line">if (!fin.is_open())</span><br><span class="line">设置文件输入输出格式</span><br><span class="line">ios_base::</span><br></pre></td></tr></table></figure></p><h2 id="基本逻辑运算符">基本逻辑运算符</h2><p>break打断循环 continue，跳到更新表达式前开始执行 非const引用的函数不接受const参数</p><h2 id="基本数据类型">基本数据类型</h2><p>结构数组</p><figure class="highlight plaintext"><figcaption><span>stname;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stname stobj\[int x] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">union(类似结构，但相同数据类型只存一种)</span><br><span class="line">每个指针需要一个*用于初始化</span><br><span class="line">int * intlist=new int [10]</span><br><span class="line">delete-new</span><br><span class="line">delete []-new []</span><br><span class="line">typedef typename aliasname</span><br></pre></td></tr></table></figure><h2 id="名称空间">名称空间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HNAME_H</span><br><span class="line">#define HNAME_H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>如果在遇到另一个定义HNAME_H的头文件时，将他忽略</p><p>作用域： 1默认情况下，函数中声明的变量作用域位于代码块内，如果函数内外都声明一个同名变量，运行至内部代码块使用内部，离开代码块使用外部 2静态变量存在于整个程序运行周期，脱离作用域后只是无法使用并不消失 代码块外声明且不带static关键字：链接性外部，可以在其他程序使用 代码块外声明，且使用static：链接性内部，可以在整个程序使用 代码块内声明，且使用static：作用域于代码块内，但始终存在//由于静态变量只可以定义一次，所以即使离开代码块后变量依旧存在，且值不变，直到下一次修改 3运算符::放置于变量前时，使用同名变量（如果有）的全局版本 4namespace{</p><p>} 无法放置于代码块内，因此默认为全局名称，可以囊括声明和定义，可以随时添加 定义于类声明的函数自动成为内联函数</p><h1 id="c特性">c++特性</h1><h2 id="class">class</h2><p>1声明构造函数时，尽量使用explicit(显性转换)前缀，防止隐性转换带来的问题 mutable(摆动的)前缀声明变量，表示这些变量可能在const成员函数内被更改 用const_cast&lt;&gt;和static_cast&lt;&gt;与this指针可以实现const成员函数向非const的转变，反之则是错误的</p><p>2class初始化成员时，按构造函数声明变量的顺序，因此初始化成员时最好也以此顺序初始化 如果不希望class有copy和赋值(=)操作，则应该在private里定义copy和=运算符</p><p>3基类引用可以指向派生类对象，无需进行强制类型转换</p><p>4定义于类声明的函数自动成为内联函数</p><p>5类的函数对所有对象共用，但数据则各自私有</p><p>6要创造类对象数组，该类必须有默认构造函数</p><p>7只有一个构造函数参数的构造函数可以用于类的自动转换 classname t; t=20; 如果想禁止这种转换，可以声明explicit给构造函数</p><p>8类声明中可定义对于某种基本类型的转换函数 operator int();//可声明为显式转换，尽量避免过多的转换造成二义性</p><p>9如果定义类成员参数为static，则它在程序中只有一个地址，可以被所有类成员共享 但通过static实现共享成员时，需要重新定义复制和赋值函数来避免问题</p><h3 id="动态类的注意事项">动态类的注意事项</h3><p>*构造函数中如果用new初始化指针成员，则应该在析构函数中使用delete new对应delete,new[]对应delete[] 对多个构造函数，应用和析构函数兼容的new来初始化成员 重构复制和赋值运算符来实现深复制</p><p>10对于使用new创建的类，使用delete时其析构函数才会被调用 如果在使用new时，将对象地址赋予一个指针时，如果删除指针，则对应的对象会调用自己的析构函数 对与使用定位new创建的类对象，需要显式调用析构函数 object-&gt;~classname(); 且应该以创建顺序的相反顺序调用，因为后创建的对象可能依赖于前者</p><h3 id="类继承">类继承</h3><h4 id="公有继承">公有继承</h4><p>class sonclassname: public fatherclassname 派生类继承了基类的公有接口和数据 但只能用基类public和protected函数访问基类私有数据 派生类可添加函数和数据成员 派生类需要自己的构造函数，并由于权限问题，其构造函数必须包括基类构造函数，并且同样可以使用成员初始化列表 <code>指针</code> 基类指针和引用可以在不显式转化的情况下指向派生类对象反过来却不行 <code>虚函数</code></p><ul><li>对于基类和派生类的同名函数： 如果函数通过引用或指针调用，将确定使用哪种方法 ￥如果没有使用关键字virual，将根据引用类型或指针类型选择方法。 如果使用了关键字virtual，将根据引用或指针指向对象的类型选择方法</li><li>构造函数不能为虚函数</li><li>析构函数应当为虚函数</li><li>友元函数并非类成员，但可以使用虚函数</li><li>**重新定义继承方式（虚实）并非重载，会覆盖掉原先的虚函数定义，如果必须重新定义，则需要重新定义使用基类虚函数</li></ul><p><code>纯虚函数</code> virual typename func() const=0; 含有虚函数的类不能创建实例，只能用作基类</p><p><code>访问控制（protected）</code> 派生类成员函数可以访问protected成员，不能访问private成员</p><h4 id="私有继承">私有继承</h4><p>使用私有继承，基类的公有成员和保护成员都成为派生类的私有成员，只可以在派生类的成员函数中使用，可以实现has_a关系 私有继承访问基类方法时需要调动基类的命名空间 <code>访问基类对象</code> 如果要直接访问基类对象，则需要调用强制类型转化将派生类转化为基类</p><h4 id="保护继承">保护继承</h4><p>保护继承时，基类的公有和保护成员都成为派生类的保护成员，基类接口在派生类中可用</p><p>通过using指令可以让私有函数被当前作用域可用</p><h2 id="命令行参数">命令行参数</h2><p>int main(int argc,char* argv[]) argc为参数个数 argv为参数组成的字符串</p><h2 id="字符输入">字符输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; ***(读取输入中的结束字符为结束标志，会将换行符留在输入流)</span><br><span class="line">getline(stringname,length)通过换行符确定输入结束点</span><br><span class="line">cin.get()读取到换行符之前，不带参数则读取下一个字符(用于清除换行符)</span><br><span class="line">cin.clear()清空输入流</span><br><span class="line">&lt;string&gt;</span><br><span class="line">重载符号+实现拼接</span><br><span class="line">str.size()</span><br><span class="line">输入字符串使用getline(cin,str)</span><br><span class="line">结构数组</span><br><span class="line">struct stname;</span><br><span class="line">stname stobj[int x] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">字符函数库&lt;cctype&gt;</span><br><span class="line">isspace(ch)测试是否空白</span><br><span class="line">isalpha(ch)是否字符</span><br><span class="line">isdigit()是否数字</span><br><span class="line">ispunct()是否标点</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; ***(读取输入中的结束字符为结束标志，会将换行符留在输入流)</span><br><span class="line">getline(stringname,length)通过换行符确定输入结束点</span><br><span class="line">cin.get()读取到换行符之前，不带参数则读取下一个字符(用于清除换行符)</span><br><span class="line">cin.clear()清空输入流</span><br></pre></td></tr></table></figure><p>&lt;string&gt; 重载符号+实现拼接 str.size() 输入字符串使用getline(cin,str) 结构数组 struct stname; stname stobj[int x] = { {} {} } 字符函数库&lt;cctype&gt; isspace(ch)测试是否空白 isalpha(ch)是否字符 isdigit()是否数字 ispunct()是否标点</p><h2 id="指针">指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1，c++没有溢出检测机制，</span><br><span class="line">char name[]=&quot;hello&quot;;</span><br><span class="line">char c =name[10]导致未定义行为</span><br><span class="line">2，用一个常量指针指向常量需要两次const</span><br><span class="line">const char* const name=&quot;hhh&quot;</span><br><span class="line">如果需要一个class专属常量，则使用</span><br><span class="line">static const ***</span><br><span class="line">实现文件中，const int classname:: ***</span><br><span class="line">对于宏：</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline functionname</span><br><span class="line">3,const 出现在*左侧表示被指物为常量，右侧表示指针为常量指针</span><br><span class="line">4,函数名就是函数的地址</span><br><span class="line">double pam(int);</span><br><span class="line">double(*pt)(int);</span><br><span class="line">pt即为函数指针</span><br><span class="line">如果需要一个函数以相同相同返回值和参数的函数为一个参数，则可以考虑函数指针</span><br><span class="line">5，内联函数不能递归</span><br><span class="line">6,引用容器时，如果迭代器不引用，仍然传递临时副本o</span><br><span class="line">7,函数传递指针时按值传递，当向函数传递指针时，指针是按值传递的！这意味着你可以改变被指向的数组内容，因为在调用函数时，这些元素不会被复制！这意味着你可以改变被指向的数组的内容，因为这些元素在函数被调用时并没有被复制。另一方面，如果你改变了所指向的数组，这种改变在函数之外不会持续，因为你只改变了指针的拷贝，而不是原来的指针本身。</span><br></pre></td></tr></table></figure><h3 id="智能指针">智能指针</h3><p>auto_ptr&lt;string&gt; 和&lt;unique_ptr&gt;指针采用所有权模型，对特定对象只有一个智能指针可以拥有它，只有拥有它的指针可以删除它 shared_ptr&lt;string&gt;追踪引用对象的智能指针数量，最后一个指针过期时才会调用delete 使用new分配内存才能使用auto_ptr,unique_ptr</p><h2 id="异常">异常</h2><h3 id="try_catch">try_catch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"> func();</span><br><span class="line">&#125;</span><br><span class="line">catch(errortype e1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line">&#123;</span><br><span class="line"> do sth;</span><br><span class="line"> throw(error_type e1);8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>栈解退</code> 假设try块没有直接调用引发异常的函数，而是调用对引发异常的函数进行调用的函数，则程序从引发异常的函数跳到包含try块和处理程序的函数（追踪到一个地址位于try块的返回地址） <code>其他异常特性</code></p><ul><li>throw-catch类似函数参数和返回，但函数返回语句将控制器交给调用函数的函数，但throw语句将控制权向上返回到第一个这样的函数，包含能捕获相应异常的try-catch组合</li><li>throw语句总是生成副本，但catch参数使用基类引用能捕获所有派生类的异常对象</li></ul><h4 id="exception类">exception类</h4><p>exception类可作为其他异常类的基类，用what的虚函数（返回一个字符串）重载来指示错误类型 <code>失败时返回空指针的语法</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * pi= new (std::nothrow) int;</span><br></pre></td></tr></table></figure><h3 id="未捕获异常">未捕获异常</h3><p>未捕获的异常会使程序调用函数terminate(),默认情况下，terminate()调用abort()函数，可以指定terminate()调用的函数来修改其行为</p><h2 id="一些新特性">一些新特性</h2><h3 id="关键字">关键字</h3><p>关键字nullptr表示空指针</p><h3 id="rtti运行阶段类型识别">RTTI(运行阶段类型识别)</h3><h4 id="dynamiccast">dynamic——cast</h4><p>danamic_cast&lt;type *&gt; (pt) 如果可以安全将pt转化为type*指针，返回对象地址，否则返回空指针 如果对引用使用，错误时返回bad_cast异常</p><h4 id="typeid和type_info">typeid和type_info</h4><p>typeid返回对type_info对象的引用，type_ifo是定义在typeinfo的类，重载==和!=预算符，例如 typeid(obj1)==typeid(obj2)</p><h3 id="类型转换运算符">类型转换运算符</h3><ul><li>dynamic_cast</li><li>const_cast</li><li>static_cast</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//用于执行各种类型的数值转换static_cast &lt;typename&gt; (expression)</span><br><span class="line">//转换是允许隐式转换时才能通过（派生类和基类可以互相转换）</span><br></pre></td></tr></table></figure><ul><li>reinterpret_cast /执行危险的转换</li></ul><p>移动语义 通过指针转移右值的地址给新对象 或通过std::move()将左值转化为右值</p><p>someclass()=default default关键字显式声明编译器创建默认构造函数，复制构造函数 delete用于禁止类中的函数</p><p>关键字override可用于覆盖虚函数定义</p><h3 id="匿名函数">匿名函数</h3><p>返回类型编译器自动确定，可直接作为函数指针使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (double x) &#123;return x%3==0;&#125; </span><br></pre></td></tr></table></figure><p>可以返回类型后置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (double x)-&gt; double&#123;int y = x;return y-x;&#125;</span><br></pre></td></tr></table></figure><p>可以给匿名函数命名</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;c语言部分&quot;&gt;c语言部分&lt;/h1&gt;
&lt;h2 id=&quot;基本函数构成&quot;&gt;基本函数构成&lt;/h2&gt;
&lt;p&gt;将数组传递为函数参数&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int fcname(int arg[],int n)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="其他" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="c++" scheme="https://thinklive1.github.io/tags/c/"/>
    
    <category term="读书笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>hexo建立个人博客指北</title>
    <link href="https://thinklive1.github.io/2023/10/05/%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8C%97/"/>
    <id>https://thinklive1.github.io/2023/10/05/%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8C%97/</id>
    <published>2023-10-05T10:22:39.927Z</published>
    <updated>2023-11-27T12:47:59.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要">概要</h1><p>本文用于简要阐释我个人关于使用hexo建个人博客的经验，和解释hexo的各种自定义功能，也可以说是我个人的备忘录。网上很多教程都是直接告诉你怎么做，这在建站时很方便，但如果你要自定义就要知道hexo是怎么自定义的，本文可以帮你对此有一些了解 <span id="more"></span> 在进入正文前，我需要补充一些其他东西</p><h2 id="hexo的原理">hexo的原理</h2><p>网站分为静态和动态，简单地说，静态网站就是写好了不会改变的页面，可以利用js实现一些小的动态效果，但不会有后台服务，动态网站就是用户发送请求，后台处理后更新网站给用户反馈，大部分商业网站都是此类。 hexo搭建的博客属于典型的静态网站，因此很容易搭建和自定义。可以说，hexo就是根据你的设置和写作，用一定规则渲染出静态页面的一个工具</p><h2 id="如何网上访问你的页面">如何网上访问你的页面</h2><p>一般来说网站搭建在服务器上，但对静态页面来说，如Github之类的网站后提供免费的托管功能，只要你建一个github账号名.github.io的公共仓库，把静态页面放进去，就可以托管页面，用这个域名访问它(由于众所周知的原因，墙内有时候访问不太稳定)</p><h2 id="涉及的工具">涉及的工具</h2><h3 id="linux">linux</h3><p>我个人推荐你用linux虚拟机来做这件事，一是linux的包管理工具让装各种框架和插件很方便，二是linux的轻量级可以让你如果要切换生产环境，直接导出一个最多10gb左右的镜像拷贝走，就能换到另一台电脑，保留所有装好的环境,三是如果你是cs学生或者有编程需要,linux都是你几乎必学的系统。 这个博客就搭在微软提供的wsl(windows上的linux子系统)上 <a href="https://dowww.spencerwoo.com/">wsl的教程看这个</a> <a href="https://101.lug.ustc.edu.cn/">linux的教程看这个</a></p><h3 id="git">git</h3><p>git和linux是同一个作者，是当下最流行的版本控制工具，如果我们要用github托管页面，也需要用git来推送页面 git也可以帮我们很方便地给你的博客做备份，推送到github的仓库，切换生产环境后把备份拉过来就能继续维护博客</p><h3 id="markdown">markdown</h3><p>markdown是一门轻量级标记性语言，很容易学习，被用于hexo渲染出html页面 网上教程很多，比如 <a href="https://www.zhihu.com/question/276209281/answer/3045412944">如何优雅地使用 Markdown？</a></p><h1 id="建站和自定义">建站和自定义</h1><h2 id="建站">建站</h2><p>假设你有了一个linux系统，并且掌握了一些基本操作，那么建站教程看这个 <a href="https://zhuanlan.zhihu.com/p/552639819">【保姆级教程】含泪搭建hexo博客</a></p><h3 id="主题选择">主题选择</h3><p>hexo的大部分页面渲染工作由主题决定，直观地说，主题决定你的博客外观 <a href="https://hexo.io/themes/">hexo主题列表</a> 我建议新手选择一些比较流行的主题，比如next,butterfly，一般这些主题自定义比较方便，文档易读并且出了问题网上有解决方案</p><h3 id="以next为例讲讲主题的自定义">以next为例讲讲主题的自定义</h3><p><a href="https://brian-zzz.github.io/2022/05/02/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/">next的简单设置这篇博客有教程</a> <a href="https://theme-next.js.org/docs/getting-started/">next的官方文档</a> hexo的大部分设置有两个yml文件控制，一个是根目录下的_config.yml，可以设置语言，作者名，网站名，网站链接等，还有一个是主题目录的_config.yml，设置主题自己的功能，next的评论，访问统计等等功能都在这里设置 主题的目录一般是根目录/node_modules/hexo-theme-主题名/，但也有主题的配置文件放在根目录的命名成_config.主题名.yml的 关于部分主题功能的详解我会放在下文的主题使用说明</p><h2 id="hexo的工作流程">hexo的工作流程</h2><p>如果想进一步的自定义，就需要了解hexo的大致原理</p><h3 id="前端三件套">前端三件套</h3><ul><li>HTML（超文本标记语言）是一种用来描述网页内容的语言，它使用一系列的标签（tag）来定义网页中的元素，如标题，段落，图片，链接等。</li><li>CSS（层叠样式表）是一种用来控制网页外观的语言，它可以定义网页中元素的颜色，大小，位置，边框等属性。</li><li>JavaScript（简称JS）是一种用来实现网页交互的脚本语言，它可以在浏览器中运行，响应用户的操作，修改网页内容，发送和接收数据等。 hexo目录内的public文件夹就放着最后生成的页面，其中，你看到的页面就是一个个html文件，样式和动态效果则引用js和css文件夹中的文件，hexo g生成和你在github托管的也就是这个文件夹下的文件</li></ul><h3 id="源文件">源文件</h3><p>那么是什么文件会被推送到public文件夹呢？</p><ol type="1"><li>根目录下的source文件夹，有下划线_打头的文件夹一般有特殊性质，如根目录下的_data存放一些自定义样式文件，_post则存放具体文章，这些文件夹不会直接放进public，除此以外的文件夹都会被放进public，但如果文件可以被渲染的话，会经过解析然后储存到 <code>public</code> 文件夹，否则会直接拷贝到 <code>public</code> 文件夹。</li><li>主题目录下的source文件夹，一般来说这些文件夹用来放js,css和主题自定义的一些图片,同样，有下划线开头的不会被直接放进public，其他文件夹下会被放进去</li></ol><h4 id="如何跳过渲染">如何跳过渲染</h4><p>在根目录下设置skip_render，以下设置让source的webstack目录全部跳过渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">- webstack/**</span><br></pre></td></tr></table></figure><h2 id="写作">写作</h2><h3 id="文章布局">文章布局</h3><p>hexo有三种文章布局，其中post是普通的博文，page是带文件夹的新页面，比如tags,categories，如果主题支持的话，你可以设置page被特别渲染成目录，标签之类的特色页面并放进菜单，draft是草稿，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，默认不会被显示在页面中 你也可以禁用布局，根据 <code>_config.yml</code> 中 <a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>default_layout</code></a> 的设置，默认布局是 <code>post</code> 。当文章中的布局被禁用(<code>layout: false</code>)，它将不会使用主题处理。然而，它仍然会被任何可用的渲染引擎渲染：如果一篇文章是用 Markdown 写的，并且安装了 Markdown 渲染引擎（比如默认的 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>)，它将被渲染成HTML。</p><table><thead><tr class="header"><th>布局</th><th>路径</th></tr></thead><tbody><tr class="odd"><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr class="even"><td><code>page</code></td><td><code>source</code></td></tr><tr class="odd"><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><h3 id="文章标头">文章标头</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说： hexo用文章标头来识别文章，因此你可以不用命令行创建文章，把有标头的md文件放进_post就能发布博文了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于斯坦福cs106b的c++数据结构笔记</span><br><span class="line">tags:</span><br><span class="line">- 课程笔记</span><br><span class="line">- c++</span><br><span class="line">categories: 课程笔记</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr class="odd"><td><code>layout</code></td><td>布局</td><td><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr class="even"><td><code>title</code></td><td>标题</td><td>文章的文件名</td></tr><tr class="odd"><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr class="even"><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr class="odd"><td><code>comments</code></td><td>开启文章的评论功能</td><td><code>true</code></td></tr><tr class="even"><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr class="odd"><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr class="even"><td><code>permalink</code></td><td>覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td><code>null</code></td></tr><tr class="odd"><td><code>excerpt</code></td><td>纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td></td></tr><tr class="even"><td><code>disableNunjucks</code></td><td>启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>/ <code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td>错误的</td></tr><tr class="odd"><td><code>lang</code></td><td>设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td>继承自 <code>_config.yml</code></td></tr><tr class="even"><td><code>published</code></td><td>文章是否发布</td><td>对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td></tr></tbody></table><h4 id="目录和标签">目录和标签</h4><p>只有文章支持分类和标签，可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。 eg.如下的标头形成目录是（课程笔记/操作系统）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于恐龙书和苏大ppt的操作系统笔记</span><br><span class="line">tags:</span><br><span class="line">- 课程笔记</span><br><span class="line">- 操作系统</span><br><span class="line">categories:</span><br><span class="line">- 课程笔记</span><br><span class="line">- 操作系统</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>也可以并列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">并列分类 </span><br><span class="line">类别：  </span><br><span class="line">- [Linux]  </span><br><span class="line">- [工具]</span><br><span class="line"></span><br><span class="line">并列+子分类</span><br><span class="line">类别：  </span><br><span class="line">- [Linux, Hexo]  </span><br><span class="line">- [工具，PHP]</span><br></pre></td></tr></table></figure><h3 id="文章缩略">文章缩略</h3><p>一般来说我们不会希望首页显示全文，而是开头的一小部分或者是摘要，摘要可以在标头加上取代缩略，而文章的缩略可以由主题决定，也可以用hexo自己的方式，比如next现在就不支持自动缩进，你只能自己在觉得差不多的地方加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><p>每个主题怎么决定缩略或者摘要基本也会在文档里写</p><h2 id="主题说明">主题说明</h2><p>既然大部分渲染由主题决定，那么自定义往往也会取决于主题，以下是我本人用过的主题的一些经验</p><h3 id="next">next</h3><p><code>next</code>是一款典型的黑白简约风主题，并且提供了丰富的自定义性，因此迪瑞克拉的主站就使用了自定义非常方便的next next的文档比较易读，全部看一遍就知道设置里那些选项怎么用了 这里说说next的自定义 next的渲染由主题文件夹下"layout"目录中的njk文件控制（一些老版本是swig)，你也可以使用next提供的自定义文件，去掉注释符号就可以去_data文件新建自定义文件来控制渲染 比如说你想在所有页面加个js特效，就可以在主题文件夹下的layout/_layout.njk文件新增一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/js/jsname.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是next提供的自定义文件接口，可以对网站各个位置自定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  #postBodyStart: source/_data/post-body-start.njk</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  style: source/_data/styles.styl</span><br></pre></td></tr></table></figure><h3 id="webstack">webstack</h3><p>webstack主题基于github的一个开源项目，用来做一个导航页面，作为子站非常合适，自定义虽然没有next那么丰富，但作者慷慨地提供了一个随便插入html的head或者body的接口，可以使用html标签进行自定义，就在webstack的配置文件末尾 怎么做子站看下文的多主题 <a href="https://github.com/HCLonely/hexo-theme-webstack/blob/master/README_CN.md">使用方法看github主页的文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">custom:</span><br><span class="line">  head: |- # 以下内容插入到&lt;head&gt;&lt;/head&gt;标签内，可设置多行，注意每行开头至少四个空格</span><br><span class="line">    &lt;!-- 直接添加html内容即可 --&gt;</span><br><span class="line">    &lt;!-- 可设置多行 --&gt;</span><br><span class="line">  body: |- # 以下内容插入到&lt;/body&gt;标签之前，可设置多行，注意每行开头至少四个空格</span><br><span class="line">    &lt;!-- 直接添加html内容即可 --&gt;</span><br><span class="line">    &lt;!-- 可设置多行 --&gt;</span><br></pre></td></tr></table></figure><h3 id="icarus">icarus</h3><p>伊卡洛斯也是个简约风的主题，特色是两列或者三列式的美观布局，但最让我中意的是它的赛博朋克风格，伊卡洛斯使用jsx定义渲染，因此自定义比较麻烦，可以自己导入js和css，但没有直接插入html标签的接口 <a href="https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/">使用文档</a> 文档没说那些七七八八的窗口怎么关，但我亲测你不想要的直接在配置文件里删掉就行了 <a href="https://blog.mchook.cn/2021/07/22/icarus%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89/">自定义js和css</a> 顺便一提大部分主题渲染md会直接把正文放进Html,所以直接在文章里放html标签基本也能用，如果你想要一个效果只在文章页面出现可以试试，迪瑞克拉神龛的骇入文字特效就是此类</p><h3 id="多主题">多主题</h3><p>理论上讲，既然主题只是决定了渲染的方法，你自己可以调用主题的各种样式渲染实现 一个主题下渲染出另一个主题效果的页面，但这样做很麻烦，那么有没有更容易实现多主题的方法呢？ 前文说了，source文件夹所有目录都会推送到public，我们可以利用这点把其他主题的网站推送到主站的source文件夹，然后在主站开一个菜单跳转到该子站对应目录的index实现子站用不同主题的功能 具体步骤如下</p><ol type="1"><li>如之前的教程一样再建一个站，设置好想要的主题</li><li>根目录的设置这么改</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url: 主站目录/子站目录名</span><br><span class="line">index_generator:</span><br><span class="line"> path: &#x27;/子站目录名/&#x27;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>主站子站各自加一个跳转子站，返回主站的菜单 比如next这么改</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resourcemap: /webstack/ || fa fa-sitemap</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>如果你会写脚本，就写个子站生成网站后自动推送的练练手，不会或者嫌麻烦就拿我的改改</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">rm -rf /home/thinkliving/hexoblog/source/webstack/*</span><br><span class="line"></span><br><span class="line">cp -r /home/thinkliving/hexochild/public/* /home/thinkliving/hexoblog/source/webstack/</span><br><span class="line"></span><br><span class="line">cp -r /home/thinkliving/hexochild/public/webstack/* /home/thinkliving/hexoblog/source/webstack/</span><br></pre></td></tr></table></figure><h2 id="其他自定义">其他自定义</h2><h3 id="图标">图标</h3><p>大部分hexo主题使用fontawesome的图标，类似这种格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fas fa-tools//s指solid图标</span><br></pre></td></tr></table></figure><p>想自定义可以在css文件里定义图标再使用，比如next中是这样在styl里定义,不过不是所有主题都支持这种自定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.thanks &#123;</span><br><span class="line">  background-image: url(&#x27;/images/thanks.svg&#x27;);</span><br><span class="line">  background-size: 1em 1em;</span><br><span class="line">  background-position: 0.05rem 0.2rem;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  height: 1rem;</span><br><span class="line">  width: 1rem; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thanks: /thanks/ || fa custom thanks</span><br></pre></td></tr></table></figure><h3 id="hexo-s时自动刷新">hexo s时自动刷新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g browser-sync</span><br><span class="line">npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure><h3 id="加密博客">加密博客</h3><p><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">[hexo-blog-encrypt](https://github.com/D0n9X1n/hexo-blog-encrypt/tree/master)</a></p><h3 id="js动效">js动效</h3><p><a href="https://blog.csdn.net/qq_44036990/article/details/104932173">鼠标移动特效</a> 这种js小特效很多，好奇的话自己去探索吧</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概要&quot;&gt;概要&lt;/h1&gt;
&lt;p&gt;本文用于简要阐释我个人关于使用hexo建个人博客的经验，和解释hexo的各种自定义功能，也可以说是我个人的备忘录。网上很多教程都是直接告诉你怎么做，这在建站时很方便，但如果你要自定义就要知道hexo是怎么自定义的，本文可以帮你对此有一些了解</summary>
    
    
    
    <category term="建站经验" scheme="https://thinklive1.github.io/categories/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="hexo" scheme="https://thinklive1.github.io/tags/hexo/"/>
    
    <category term="next" scheme="https://thinklive1.github.io/tags/next/"/>
    
    <category term="webstack" scheme="https://thinklive1.github.io/tags/webstack/"/>
    
    <category term="icarus" scheme="https://thinklive1.github.io/tags/icarus/"/>
    
  </entry>
  
  <entry>
    <title>游戏简评</title>
    <link href="https://thinklive1.github.io/2023/09/30/%E6%B8%B8%E6%88%8F%E7%AE%80%E8%AF%84/"/>
    <id>https://thinklive1.github.io/2023/09/30/%E6%B8%B8%E6%88%8F%E7%AE%80%E8%AF%84/</id>
    <published>2023-09-30T11:47:32.003Z</published>
    <updated>2023-11-27T12:47:59.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="被封锁的涩谷">428被封锁的涩谷</h1><p>希腊神话将命运女神履行职能的过程写作织网，这无疑是一种极为贴切的比喻，对网状结构来说，在中心处的轻轻一拨，边缘处就是极大的震动，越是深入核心，就越是复杂，但所有分支无论看上去多么没有规律，最后都会收束到中心网点，我想这就是428的编剧想实现的叙事结构。 <span id="more"></span> 这样的结构需要极致的严谨和巨大的工作量，正如正统的本格派推理一样丝丝入扣，同时还要维持各个部分的信息量尽量均布，各个网点处都有关键悬念留待读者，但，他们做到了，7位主角的命运与城市里大大小小配角的命运，就这样纠缠在一起，并收束到了一个巨大的阴谋上，更令人称奇的是，尽管使用了这样的结构，制作组仍然做到了悬念的均布，几乎没有出现信息量失衡的情况。 于是，玩家得以在4月28日的涩谷当一天的命运女神，只要在一个个节点上轻轻拨正些许紊乱的蛛丝，蛛丝就会自然而然地化为网状，事实上没有我说的这么轻松，因为这些命运的线条起初似乎是绕成一团，理清它们的过程也少不了误解和错误。 为了确保这个过程的顺畅，85个bad end大部分都有提示，以每一小时为节点，只有理清一小时内的所有事件，命运才能向前推进，起初似乎是一些不成规律的线，但逐渐就开始交错，纠缠，而作为有着神力的玩家，只需要制造一些偶然，改变一两个小小的决定就能够造成一连串的蝴蝶效应。 对这种操控命运的讨论很容易回到一些宿命论的思潮上来，幸运的是428的编剧在这个方面却有着很积极的态度，于是在结局，命运的线条汇聚在一起，无数偶然交错下，产生的必然却孕育着希望，尽管多少有些日式的大团圆味道，但流露出的价值观确实积极的。 如果说这样精巧的叙事结构有没有问题，那么当然也是有的，叙事必须依靠逻辑的支撑，如此庞大的网状结构，逻辑当然不可能天衣无缝，事实上依然有很多巧合和偶然，为了配合结构的需要，甚至部分主角也免不了当工具人，但你很难对此苛责什么，通过有限的角色实现如此复杂的剧本，不免要让一些角色承担过多的推进剧情的作用，相对来说编剧已经做得很不错了。 此外的问题是大部分日式游戏难免的幼稚气，叙事结构是精巧且充满悬念的，但一些抒情节点，以及一些过度夸张以至于模板化的人物性格，依然为其减色不少。不过我也能理解编剧，毕竟这种精密的结构确实很难填补完全恰如其分的内容 总的来说428在叙事结构方面可以说是当今电子游戏的最高峰水平，尽管它的其他部分可能只是优秀或者不错的程度，依旧是一款剧情类的神作</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;被封锁的涩谷&quot;&gt;428被封锁的涩谷&lt;/h1&gt;
&lt;p&gt;希腊神话将命运女神履行职能的过程写作织网，这无疑是一种极为贴切的比喻，对网状结构来说，在中心处的轻轻一拨，边缘处就是极大的震动，越是深入核心，就越是复杂，但所有分支无论看上去多么没有规律，最后都会收束到中心网点，我想这就是428的编剧想实现的叙事结构。</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="其他游戏" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>龙腾世纪三部曲</title>
    <link href="https://thinklive1.github.io/2023/09/30/%E9%BE%99%E8%85%BE%E4%B8%96%E7%BA%AA/"/>
    <id>https://thinklive1.github.io/2023/09/30/%E9%BE%99%E8%85%BE%E4%B8%96%E7%BA%AA/</id>
    <published>2023-09-30T11:45:00.003Z</published>
    <updated>2023-11-27T12:47:59.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dao">dao</h1><p>本世纪的欧美rpg里最出名的应该是巫师三了，你可能曾因为好奇去搜过cdpr的发家史，也就是从卖盗版游戏到引进游戏并本土化赚到了第一桶金，这个引进的游戏是博德之门，博德之门的开发商是生软。 <span id="more"></span> 这里插一句，波兰人的首秀巫师一在开发阶段几乎遇到了一个新游戏能想到的所有问题，这时生软仗义地扶了波兰人一把，才有了巫师一的面世，遂成rpg界一段佳话，不过后来二者先后拉了（ 龙腾世纪本来在定位上是博德之门的替代品，因为版权问题生软不能继续开发博德之门，于是便做出了龙腾世纪起源，这一项目立项在02年，但直到07年得到了EA的支持才在09年把这一“神作”做了出来，直到这时EA还是带善人的形象，并没有露出狰狞的獠牙，而在生软的黄金时代打磨了7年的起源，我可以毫不夸张地说，哪怕今年推出这款游戏，它依然是年度最佳候选级别的神作。 我先说说，我为什么要做这个视频，其实在一开始，dao在我的心中的地位还没有要我做一个视频出来的程度，但在玩了龙腾世纪的后两作后，DAO在我心中地位飙升，可见对比的力量，这个杂谈系列会讲完我对龙腾世纪整个系列的感受，当然是纯个人感受，我不 是什么rpg遗老，只是一个当代rpg爱好者而已，如有不同意之处，反正我也不会改的。</p><p>当你打开dao建立存档时，你可以选择三个种族，三个职业，在种族内甚至有平民和贵族的区别，根据职业和种族的不同，光开头剧情就有六种，由此开始，玩家就能感受到dao的超高自由度。 当然，对于rpg来说，自由度并不是什么稀奇的东西，但dao的自由度是有其独特之处的，以自由度出名的上古卷轴五，它的自由度体现于扮演的角色的多样性，龙裔，战友团成员，冬堡法师等等，这几种身份并没有交集，是独立的，而起源的自由度体现在行为的自由，自由度再高的游戏也不能完全模拟现实，但高自由度的游戏只需要模拟到玩家一时间能想到或者能让他们觉得有趣的所有选项就够了，DAO做到了这点，举例来说，当你接到了调查黑恶势力的任务，你可以当个正义的使者把邪恶势力端了，也可以接受贿赂，甚至可以献祭奴隶来提高自己的力量，你可以与邪教合作玷污圣物，也可以屠杀邪教，杀死恶龙，扮演被选召的勇士，很多时候当你背叛道德时得到的奖励反而更好，高道德的行为除了增加部分队友的好感度并没有太多作用，与巫师类似，起源遵循着成人的价值观，尽管选择大部分时候不像巫师那么残酷，而且起源中后悔也是很容易的一件事，相对削弱了选择的分量。</p><p>我们再来说说提高起源代入感的另一个设计——队友系统，独身在一个苍茫浩瀚的魔幻世界冒险难免会感到孤独，巫师的解决方式是让杰洛特和爱人与亲友保持时不时的联系，上古卷轴的解决方式，嗯，我没感到有什么解决方式，至少本体没有，当然如果装了随从mod肯定就完全不一样了。在龙腾世纪起源中你绝不会感到孤独，相比其他知名rpg，生软最显著的优点应该就是队友塑造了，dao的队友大部分有着讨喜且有深度的人设，这是由海量的工作量撑起来的，在冒险时会随机出现队友间的闲聊，几乎所有队友两两组合都有为数不少的对话，或八卦，或正经或取笑，这让人感到队友都是活生生的人，同时也可想而知其中的工作量，单个角色的对话文字量往往都要以万为单位，此外，在营地和队友闲聊也能通过一些选项增减好感度，所有队友都有为数不少的对话树，并且随着好感度的增减还会解锁额外选项。 队友间除了友情也能发展出爱情，这就不得不提我认为在魔幻rpg中最有魅力的女角色——莫瑞甘，她是个荒野女巫的女儿，，价值观完全是混乱中立甚至偏邪恶的，你做好事她嫌你磨叽，做坏事说不定夸你有魄力，好感度低时会邀请你滚床单并声明只是玩玩，好感度高起来了反而不愿继续亲近——“明明说了只是玩玩，怎么你当真了呢”在游戏的结局莫瑞甘会不可避免地离去，而在一个（拿感情骗钱的）的dlc里沃顿却能不远万里追踪到正欲逃走的她，最终让莫瑞甘也承认了爱情的存在，不得不说我真被这段爱情所感动了，这种细腻的感情戏其实不输我们以感情线为特色的双剑系列（当然续作就没这么顶了） 代入感之外，起源的战斗系统也是极有意思的，多有意思呢，大概比巫师三好几十个上古卷轴五吧（不是）起源的系统在今天看也不算过时，采用一种可以随时暂停的即时战斗系统，同时可以为队友ai设置战术，选项极为详细，大佬光靠设置ai应该就可以全自动战斗，我这种咸鱼打boss还是要几步一暂停，很明显这是一种重策略轻即时的系统，不设技能栏上限让法师成为了团队灵魂，控制，辅助，aoe，单体爆发应有尽有，可以说带够蓝药，法师就是无敌的（大部分Boss远程攻击弱于近战），即便职业平衡不是那么好，但队友是可以随意搭配的，丰富的技能树，转职，加点策略，装备系统让起源的战斗和养成充满乐趣，当然大型迷宫各种怪潮难免会腻烦，不过比起后面两作真的是让我体验最好的战斗系统了。 最后我们来说说起源的剧情和任务设计，大恶魔苏醒，黑潮突起，作为临危受命的灰袍守护者，沃顿利用古老盟约集结联军，手刃大恶魔，可以说是一个很俗套的故事，怎么把这种看起来很俗的故事讲好呢，答案是独立的小故事相加辅以大量填充细节和设定，起源的几条线，法师，矮人，精灵，伯爵都是相对独立的故事，套路很简单：求援——当地陷入危机——解决危机——得到援助，期间夹杂背叛者洛根使绊的故事线，每个地方引出了一部分的世界观设定，起源有着极其繁杂的文本，尽管套路类似，但每条线提供的信息量都是复杂且独特的，同时也有着世界观内各个势力特有的风貌，安教的圣洁，矮人的森严都得到了体现，即使很想比较，龙腾世纪的世界观也是独特且复杂的，当然，相比起源的主线，支线反而比较一般，不乏收集的填充式支线，当然，队友的支线还是很有趣的，也有一些补充世界观的有趣支线。 说了这么多，应该基本说完了起源的特点，当然也有很多具体内容我并没有提及，事实上起源并不是没有缺点，比如优化太差，自带防沉迷，玩几个小时就会卡顿到没完继续，只能重启，此外，敌人种类稀缺，也存在强行推动剧情而忽略合理性的情节，甚至有手刃大恶魔实力的主角有的时候莫名其妙就当垫脚石了，但起源仍然是神作，作为一个玩惯了10年后游戏的人，我玩起源没有感到任何系统在恶心我，可见制作组对玩家体验的重视，这是龙腾世纪的续作都未能做到的，，这也是我为龙腾世纪和生软感到可惜的原因，下一期我会叙述我对两部续作的看法，当然批评为主，，， 出道即巅峰的起源全平台销量不过470w，或许正是这样的销量驱使着生软不惜与老玩家对立也要向着主机倾斜，只可惜了龙腾世纪成为了开幕即巅峰，出场即绝唱的一个悲剧……</p><h1 id="da2">da2</h1><p>今天我们来说说龙腾世纪二，，龙腾世纪二是系列中一部很，额，很独特的作品，他刚发售时的风评，作为后来人我不是很清楚，不过就现在来看，da2的风评呈现一种两极分化的形势。 这里插一句奥，我个人感觉rpg游戏的受众是个很宽容的群体，我这种认为2077是款好游戏的人放一些地方可能被叫孝子了，但对现在龙腾世纪的粉丝来说这可能都不算事，举个例子吧，写文案的这天龙腾世纪吧有个直接辱骂起源人气角色的，甚至没什么人骂回去，这放在其他单机游戏圈子里是难以想象的，所以对于龙腾世纪二这样极其赶工的，大部分玩家评价起来基本没什么戾气，当然事实上我很喜欢这一点，也是这点造成了da2并没有招致较为深入的批评，今天我会详细地阐述这部作品的缺点，当然是以我的角度，同时我也不会带有什么负面情绪，我个人其实很喜欢这个系列，二代我也不是那么讨厌，但它的问题确实是露骨的，毕竟太温和往往就意味着圈子的自净能力不够，对一些问题往往就不能看的那么透彻。 我之前说了da2是一部赶工明显的作品，有多赶工呢，2077和它相比那都不算事，生软甚至没有给二代一个后缀名…… 我们先从系统性的问题说起 首先作为一个rpg游戏，da2从头到尾（一共三章）几乎一直在重复利用十几个地图，一样的别墅，一样的山洞（还Tm贼亮）等等，这也是所有玩家都承认的一个问题，考虑到14个月的工期，这点可能也是难以避免的，不过这个问题实际上并不止这么简单，因为地图的数量太少，各种任务线又要在不停阶段换来换去，这就给玩家造成了一个两难的问题——如果按任务线推不得不忍受一个又一个重复度极高的地图，如果以最高效率的原则一个地点一个地点地清，又会错失现状的任务叙事，这种矛盾是稀缺的地图造成的，也是da2在叙事上的一个根本性的缺点 然后，整个战斗系统可以说在da2迎来了史诗性的大改，或许是制作组没有力气做大规模的技能，所以被官方钦定为法师的霍克技能远远没有一代多，对一个技能你要投至少两个点数进去才能强化到底，更别提一个系的被动build需要投入更多，法师的技能树相比战士盗贼完全没有优势，还有那个攻击动作，法师舞得和金箍棒似的，搞act化不能这么搞啊，怕不是设计师想起自己做《翡翠帝国》（生软以前的东方题材rpg）曾经看过的西游记，把法杖当金箍棒设计……然后是二代的刷兵机制，科克沃是个小城市，但在本作中你可以看到如同下饺子一样天降的敌人杂兵——分批次有顺序地入场，先不说不集结优势兵力在战术上有多不明智，二代的aoe法术是大削过的，我基本上要带两个输出法师才能确保范围伤害足够…… 然后是Boss战的秘之设计，堆血加流程化战斗，什么意思呢，举个例子，在最后一章有个杀龙的支线，Boss血贼厚，而且打一会它就会飞走留一堆小杂兵，自己在打不到的高台上放冷箭，有一说一，不难打，但确实恶心，我记得贴吧有个最高难度的老哥打了一小时，我估计啊，制作组对赶工做的boss没信心，所以用这种机制来给玩家提供“紧张感” 本作队友的战术槽给得更多了，这是个好事，但相应的队友的装备系统反而被砍了（武器能换）也就是当霍克捡到非自己职业的装备时，这就是垃圾，还有本作的dlc装备，又多又杂……steam上的全dlc装备过了100件，而且大多是毕业装备的水平，当然本来装备系统也没什么收集的乐趣，dlc出了应该也是破罐子破摔…… 当然成功的革新也不是没有，队友的感情线是得到了深化的，高对立和高友好都能得到buff和对应技能树，这有利于玩家不顾及队友好感度地遵循本心去做选择，也增加了build的多样性以及跨职业的连击，不过相应的礼物系统和营地闲聊也砍了……（但我个人还是更喜欢起源的策略性战斗）…… 随后的一大麻烦就是剧情，da的小格局剧情在魔幻rpg中应该算少见，虽然这种选择多半也是因为无奈，很多玩家或许是因为新奇而觉得这样的叙事很有意思，确实，不能说da2的故事无聊，但是缺点和漏洞也很明显，我们先把剧情大纲给复习一遍。 枯潮来袭，叛教法师之子霍克与家人逃难到科克沃，在一次矮人矿坑冒险中发家致富，几年后解决了库纳利人的叛乱成为捍卫者，最终面临圣法矛盾的激烈化，并在安德斯的一次恐怖袭击后解决了发布灭法师环令的圣殿骑士领导者梅疯子，圣法大战的时代就此拉开序幕。 只看大纲其实生软的编剧还是有点东西的，有转折，有历史大势，有多方势力的牵扯，看起来很好，是吧，但如果你抛开糟糕的跑任务体验去仔细审视这个故事，你就会发现很难立得住脚。 我猜想啊，14个月的工期一给，编剧拍脑子一想，咱做个小格局故事，矛盾层层激化，来点刺激的，然后开始考虑怎么让角色对号入座，为什么这么说呢，因为da2的故事是典型的情节推动型，霍克从始至终跟着情节走，不是说这么不好，不过da2处理得相对不太行，同年的巫师二也是分三章的小格局叙事，但他们着眼点是主角，杰洛特的立场很明确，找老婆顺便寻回过去记忆，政治那是附带的，他被牵着走，被逼着站队，很合理，互相利用嘛；da2有所不同，霍克从始至终都是城里有排面的人物，就是第一章也是和城里卫队小队长有裙带关系的王牌佣兵，他不能一直被动吧，你da招牌式的自由度呢？ 我们来按顺序捋一下故事线，第一章用一些小任务引出了血法师与激进派圣殿骑士两大毒瘤作为引子其实还行，不过霍克听了瓦里克几句忽悠就要下坑道了略显仓促，当然瓦叔是一代口才点满那种人物，系列里忽悠谁谁信，不过下坑道不带安德斯霍克的弟弟就会死着实是个离谱的安排，奥尔加过后大家应当都知道对一个重要人物的出退场不能那么仓促，但奥尔加死的仓促是因为不这么做编不下去，da2是图什么？沃顿和队友杀了不知道多少暗裔，就没受过伤？怎么就你卡沃毒抗负数，你要说是为了霍克成长也不现实，da这种强调主角就是自己的游戏是不会有主角成长的需要的，只能说这段是真的迷惑，除了让卡沃有机会当沃顿没有任何意义 然后进入第二章，这一章的主线是库纳利人线，这段剧情其实写得不错，库纳利人的塑造很有趣，但问题在于二代本就是个内容不足的游戏，着力想展现的圣法之争和库纳利人一点关系也没有，这段想抬升霍克地位的意图实在是明显过头了，再加上一大段剧情给了库纳利人，分散了玩家注意力不说，让圣法大战本就不足的铺垫和描写雪上加霜，当然第二章也有支线，支线讲了什么呢，全讲了血法师是怎么毒害大众的，事实上本作除了第一章有几个法师卖惨，其他的戏份几乎全给了血法师以及安德斯这种激进派，这就导致了一个很搞笑的问题，你说法师不能迫害，但梅疯子一开始也没杀人，你这城市逢一个法师十有八九练血魔法不管你管谁呢？其实圣法之争的核心问题很简单——法师到底多容易堕落，在一代中一个法师用血魔法能屠大半个法环，很危险，但召唤恶魔者本来就是个危险分子，血魔法对他来说只是工具，你要说恶魔诱惑法师有多容易就很难说，同是老血法师的莫姐不就啥事没有，这个问题不挑明，法师的存废很难有定论。 我们再来说说全游戏的高潮——第三章，da2的剧情呈现一个很神奇的现象，你要说层层递进那确实是这样，但递进的未免比较太快了，纵观全游戏你基本看不到什么温和派——无论圣法，对编剧来说激进派确实好用啊，超快节奏推剧情，但对玩家就会感到憋屈。全游戏最激进的梅疯子，她疯吧，但面对霍克这个叛教法师之子，公然的血魔法使用者她一点也不刁难你，霍克还有个顶着精灵和血法师双重debuff的梅丽尔，她也不管，霍克既然这么有面子，那联合一下城里的势力反对她不难吧，结果没给选项，更神奇的是圣殿和法师还有有识之士站出来想把梅疯子杀了，这时候编剧又觉得梅疯子真被保守派刀了结局没得放了，于是让这些人绑架了霍克的家人，这也算了，真密会了还有血法师跳出来把温和派圣殿杀了，你们搞秘密集会成员审查就这水平？放进来个血法师不说还在关键时刻内讧，真的可以，事实上你在游戏里遇到的法师不是莫名其妙疯了就是几乎没有塑造，情节推着所有角色在走，再举一个例子，蕾莉安娜这种间谍头子怎么着也是雷厉风行的实战派了吧，科城的局势像在火上烤，教皇把蕾莉安娜这种重量级角色派来，你猜派来做什么，派来劝现任主教快走，那科克沃怎么办呢，蕾妹连句懂得都懂都没和霍克说 几边都这么随波逐流，主线怎么推进呢，于是安德斯直接开始搞起来恐怖袭击，不得不说这段真的是异常生硬，安德斯前几章还一副弱受的样子没一点铺垫直接搞恐怖主义了，而且搞完还一副为大义牺牲的样子，问题的根源不解决，法师永远会被歧视，这样的情节有什么意义呢，要在魔幻世界观谈政治本就是件很难圆的事情，更别提生软还处理得这么生硬 可能有人会说这样神转折也很震撼啊，但正如我之前说的，奥尔加之死也是神转折，但没有足够铺垫的生硬转折在剧本创作里肯定是要避免的，可以说二代编剧本来应该想写出霍克身为科克沃捍卫者也对历史大势卷携着无能为力的剧本，但实际效果呢，是各路代表不了大势的牛鬼蛇神作死，而我们的霍日天在一边看着准备收拾残局。 我一直坚持在文艺创作领域风格和水平要分开看，就比如我知道二代有很多拥护者，但他们可能大部分是喜欢这种以小见大的叙事风格，而不是充满漏洞的叙事水平，da2虽然我说了他的很多缺点，但生软的剧本虽然很难跻身一流，但保持二流水平还是可以的，剧情演出的信息量能淹没很多人对不合理处的关注便是明证。 Da2故事上的失败很大部分要归因于赶工和工期的匮乏，这一游戏的大部分问题皆来自于此，至于一个世界观宏大的rpg讲小格局故事是否明智，从后见之明的角度看，da2在作为da3的引子方面还算是成功的，但无可否认da2在设定上根本没什么进展，我们要知道dao在世界观构建上只是刚刚展开，还没到成熟的地步，直接在这种半成品框架下讲故事对完善世界观有所期待的玩家肯定不会满意 大部分da2的玩家应该都为这款游戏感到可惜，如果再有一年的时间可能以上的问题能解决个大半，但奈何生软摊上ea这么一个急功近利的老板，而在下一作，生软带给我的就更多是愤怒，而不是惋惜了……to be continued 以下是个人的碎碎念 一代赶路神技加速术居然砍成限时Buff了,而且这游戏强调同性恋是不是有点过了，安德斯动不动一脸弱受的样子，而且那啥院居然还有不问你性取向直接调情的男妓……这算性骚扰了吧，伊莎贝拉一代可没那么黑啊，这是在海上漂了几十年人种都换了？生软搞zzzq真的由来已久</p><h1 id="dai">dai</h1><p>今天我们要介绍的这款游戏，于2014年以压倒性优势赢得了tga年度最佳，没有任何一个竞争者是与它同一个量级的，gta5，最后生还者为了避其锋芒不得不选择在13年发售，巫师三被吓得跳票到15年，在得知14年有这款游戏后，宫崎英高慌得只得把黑魂三继续打磨到16年，它就是古往今来最强的rpg游戏——龙腾世纪审判！！！ 对审判的评价有个很神奇的现象，刚推出的年份似乎风评尚可，但随着时间推移，评价越来越差，这似乎意味着这是一款开创先河的游戏，无论是填充式的开放世界，还是泛滥的政治正确，都在这款14年的游戏中得到了体现，当然我不怀疑生软的目的，毕竟制作组高层就有同性恋，甚至现在看来惨不忍睹的开放世界当初的生软可能真的觉得很好（虽然被第二年的巫师三干碎了） 审判在我心中一直是一部很独特的作品，如果你让我说明da系列的优点，一代的优点不胜枚举，二代我至少可以说风格很独特，三代就比较神奇，它的优点，额，藏得比较深 那我们不妨就先说说它的优点，审判在世界观和时间上的推进上有巨大的建树，我的意思是，填了几个坑的同时挖了更多的坑，生软在下一盘很大的棋，无论是揭开奥莱斯的帷幕，教会的黑暗过去，亦或是把古代精灵的设定全部推倒，都能让我们感受到生软在剧本上的用心，确实，理论上讲，dai的剧情是很有看头的，但生软把自己的缺点推向台前，把优点深藏幕后，让我在玩的时候频频破防，也是真的厉害 我们还是先从系统问题说起，不知道是什么给了制作组勇气，本作的引擎换成了做战地的寒霜，这个引擎对rpg的适配性极差，为了实现存档生软就不得不对其做了大量魔改，乃至系列核心功能的存档继承还要通过一个网站实现（没有中文支持哦），不知道是不是为了照顾主机，即时演算cg还是锁30帧的，配合僵硬的人物动作，让我感觉在看ppt，审判还有一种极为奇妙的油腻效果，你要用在植被景物上我就当做油画风格了，但奈何人物也是这个样子，个个都像青春期几个月不洗脸一样满脸反光，在这里我澄清一下啊，有黑子造谣叫索拉斯“蛋头”，索拉斯什么时候配碰瓷我们鸡蛋了，你家鸡蛋反光到这种程度？ 审判主打一个开放世界，什么叫开放世界呢，每个地图给你一堆无聊的收集式支线，跑断腿去吧，此外，除了某些装备词条，审判官没有任何提高那慢的像残废一样的移速的手段，偏偏生软还恶趣味地把地图做的很大，收集式支线的收集品路线拉得很长，如果不修改游戏速度，或者有什么特殊癖好我觉得是撑不下去的，顺便一提也基本没有什么像样的奖励，生软不会真的觉得这种任务能留得住玩家吧，就算14年大家还没有被育碧的填充式开放世界搞得审美疲劳，也不会对这种设计甘之若饴吧 当然了，也有人反驳，又没有强迫你做，不喜欢大可不做，首先呢，为了推主线总归是要做支线积攒势力点的，其次，这也涉及到游戏设计的一个问题，一个叙事向游戏，最根本的是什么，我认为就是像玩家提供信息，一个优秀的的叙事游戏必须在游玩过程中高密度同时高质量的提供给玩家信息，同时这个过程必须是有导向性的，要将玩家的注意力导向最能给予他们信息的方向，因此任务日志里主线永远要在c位，即使是巫师三这种支线质量领先业界的作品，也有粗制滥造纯跑腿的任务，但这些任务流程不会长，也就是，虽然提供不了什么和世界观塑造或者叙事相关的信息，但由于时间短，这段时间的信息密度并没有低到无法忍受，我们看看dai是怎么处理的，首先支线在基本没有信息量的同时，极度磨叽，当然这也就算了，毕竟不喜欢可以不玩嘛，但制作组自作聪明地把这些制作水平极度粗糙的支线，给塞在了日志里，一打开日志界面就是密密麻麻的0/X，我相信但凡是个正常人都会感到烦躁，这就是很失败的一点，它将玩家的注意力导向了最错误的方向，是个极度离谱的设计 同样是为了照顾主机，本作的技能栏进一步精简到了8个技能，8个技能，战士和盗贼都没有过这么吃紧的技能栏，你让法师玩什么？虽然是个人喜好问题，但这种革新是不是有点太过分了一点呢？说实话dai我是一点玩法师的欲望也没有，不是说强度有多少削弱，而是策略选择的灵活性没有了，说到策略，本作更迷惑的一点是取消了战术设定，可以说是向即时act全面转进，da系列每代都有极大的革新，我也不知道是图个什么，我们就当是因为商业利益不得不妥协了吧。 再说剧情和人设的问题，只看大纲，审判的剧情和一代很像，都是主角临危受命杀死大魔王拯救世界的故事，区别也是有点，审判的格局宏大的多，看得出编剧很有野心，一代的费罗登和仅仅提及过的奥莱斯都是本作的舞台，但问题在于呈现的方式，极度草率，我之前说dai是开放世界，其实这不完全准确，因为只有地图和任务是开放的，能去的地方其实就几个，而且大多是荒郊野外，根本不足以展示末日将临下两国的反应，当然生软也想了个办法，就是决策桌系统，说实话这就是个挂机文字游戏，而且频繁进出还很浪费时间，尽管事件很丰富，但寥寥几语文字提供不了多少信息量，一代通过支线我起码看出了点费罗登人应对枯潮的绝望与恐惧，审判恕我直言，完全没什么感觉，当然我不否认主线的几个大事件做的不错，但相应的小格局叙事的空缺让我感觉到这场灾难的苍白，试想一下，审判团之外判官直接接触过什么组织什么人，没几个，是吧。 再说人物，本作的大反派，考爷，不得不说异常苍白，一代的反派洛根虽然傲慢愚蠢但至少性格是有几个侧面的，考爷有什么呢，纯粹的邪恶与野心，其实这样也行，我一向认为刻画人物有两条路，一条是通过各种细节展示其多面性或者成长与突变，一种就是把一个性格特质发挥到极致，比如jojo福音的田最环，就是个坏人，但他诡计多端会演戏，文能严刑逼供心理施压，武能压着吉良和仗助打，这就是把恶这一性格写到极致，但考爷两边都不沾，风头全被我们男判官的好兄弟，女判官的好情人索光头抢走了，真的是惨。 反观入侵者dlc可以说才是真的点睛之笔，回过头来想想，几乎整个审判本体都在给这个dlc作铺垫，不得不说这个dlc确实让我感受到了生软最后的实力 再说队友，其实dai的队友一直给我一种神奇的疏离感，但本着科学严谨的态度，我思考了好一阵为什么会有这种感觉，在这里和大家分享一下 首先是身份上的疏离，一二代的队友都各有各的不同，但总归是人类，精灵，矮人三个基本分类，而且归属上都是费罗登的人，审判就比较神奇，铁牛是库纳利人，科尔是个灵体，其他队友从费罗登奥莱斯两对头，到遥不可及的德凡特，都有，当然这只是最浅显的一点，但身份的疏离明显加大了队友间的隔阂 其次，考虑一下一二代与三代主角的不同，一二代都是有所谓初始剧情的，因此他们都有自己的死忠与初始势力，一代的沃顿初始有同事A哥和受了母亲命令的莫姐两大死忠才开始招募队友的旅程，二代的霍克不仅有弟弟/妹妹还有艾芙琳的支持，更重要的是，加入的队友大部分是孤家寡人，都是孤身投奔梁山的类型，而审判就不同了，初始就有自己势力的卡姐，率部投奔的萨拉，间谍铁牛，法师领袖薇薇安，瓦里克还是霍克的死忠（十年老交情不可能完全站在判官这边）导致判官严格来说甚至没有可以信任的亲信，相反，还要应付各怀异心的队友 最后，对于角色的塑造来说，一共有三个过程，不成熟，成熟，升华，举例来说，一代鲜有不成熟的角色，成熟的利己人格莫姐最后接纳了爱情这是对其人设的升华，成熟的温奶最后决定牺牲自己造福世人，这也是一种升华，一代是不缺少有自己成熟价值观的人物的，看着傻白甜的蕾妹实际上早就身经百战了，而三代不成熟人格就多起来了，卡姐看着霸气，实际上被瓦里克骗了很久，而且天真的没有意识到圣殿骑士膨胀的权力必然导致的对法师的压迫，科尔更不必说，黑墙直到赎罪后才形成了成熟的人格 再说一些其他方面的问题，我是指，政治正确，不知何时起gayware的游戏已经成了同性恋人群的狂欢处了，在尊重同性恋的同时我能请生软尊重一下异性恋吗，队友里能推的只有卡姐？生软塑造女性角色的功底可以说在倒退了，相反的，光头倒颇有一代莫姐的风采，然后是黑人姐姐薇薇安，据我所知龙腾世纪并没有任何关于人种肤色的设定，但我们的薇薇安姐姐就这么不羁地出现在我们眼前，似乎不认为自己在满世界的白皮人中有任何特殊之处，更神奇的是这位姐姐的人设还是交际高手，我很好奇奥莱死的权贵们难道真能把薇薇安当同族看待？据我所知一个明显与交际圈所有人都不同的人，被排挤才是正常操作吧，而我们的薇薇安姐，不仅顶着异于常人的肤色，还有着其貌不扬的一张脸，能成为帝国圈内炙手可热的交际花也是相当励志了。顺便一提，有人说叠buff拿年度最佳是美末二首创，其实是dai玩剩下的，从这点看可以说是非常有创造性的一作了 总的来说，虽然定位上dai是一部中兴之作，但这部作品在最底层的设计逻辑上存在很大的问题，整个路都走错了，如果生软把做开放地图和低质量支线的精力拿来做出一代那种不乏少数有趣支线的线性地图，把决策桌换成各种小任务，那么呈现出的效果必然会好很多，同时，恼人的政治正确，油光满面的建模，浮夸的网游式特效，让审判在外观上都显得不讨喜，我由衷的希望da4里生软能认清自己，摆脱这些乱七八糟的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;dao&quot;&gt;dao&lt;/h1&gt;
&lt;p&gt;本世纪的欧美rpg里最出名的应该是巫师三了，你可能曾因为好奇去搜过cdpr的发家史，也就是从卖盗版游戏到引进游戏并本土化赚到了第一桶金，这个引进的游戏是博德之门，博德之门的开发商是生软。</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="wrpg" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/wrpg/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="龙腾世纪" scheme="https://thinklive1.github.io/tags/%E9%BE%99%E8%85%BE%E4%B8%96%E7%BA%AA/"/>
    
  </entry>
  
  <entry>
    <title>被所有人遗忘的故事，巫师二之殇</title>
    <link href="https://thinklive1.github.io/2023/09/30/%E5%B7%AB%E5%B8%88%E4%BA%8C/"/>
    <id>https://thinklive1.github.io/2023/09/30/%E5%B7%AB%E5%B8%88%E4%BA%8C/</id>
    <published>2023-09-30T11:41:52.363Z</published>
    <updated>2023-11-27T12:47:59.697Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉我的朋友都知道，我本人是巫师系列的死忠，如果让我给rpg游戏做一个排行，我会把巫师放在第一位，有的人可能会说，巫师固然是rpg佳作，但在浩如烟海，名作辈出的rpg里可未必排的上号，又有的人可能会说，说这么多不过是“情怀党”的矫情而已。 <span id="more"></span> 不错，巫师系列对我来说不只是一个游戏，如果说每个人最大的爱好都有一个启蒙物，那么可以说正是巫师，将我带进了那些着重于叙事的游戏的坑。不过与大部分人不同的是，我初次接触巫师系列是巫师的二代。 那是一个普通的暑假，我费力地思考着，家里残破的笔记本电脑到底能玩点什么游戏，这时我突然想到，听说有个叫巫师三的游戏挺有名，我不如试试它的前作好了。就这样我搜到了巫师一二，巫师一画面陈旧，操作蹩脚，我毫不犹豫地排除了它，但二代却有着在那个年代来说不错的画质，于是我找到了它的资源，试着玩了起来。 听到这里可能大家觉得我无非在说一些陈词滥调，但我想说的是，巫师二即使以我现在不知道涨了多少的阅历来看，依旧是一款特立独行的游戏。在此之前我也玩过不少游戏，但我从来没有见过一个没有政治诉求纯粹为了自己的利益行动的主角，我从来没有见过一个每个人都栩栩如生，有自己行事逻辑的世界，我从来都没有见过，一个以阴暗的政治冲突，种族歧视为背景的游戏，即使以rpg来说，巫师二也是个很有勇气的游戏，在巫师二不长的序章过后，就会面临两个截然不同的分歧，并且这两条分支路线的重复内容并不多，如此大的分支毫无疑问是不多见的。现在回想起来，巫师二可能是我唯一一个一点也没有碰支线的rpg游戏，固然因为当时我懵懂无知，但其波澜壮阔的主线确实无比吸引我， 是的，这是一个非常有突破性的游戏，可谓是cdpr写政治戏码的巅峰，但是，很神奇的是，这又是一个被遗忘的游戏，不仅是被引流来的巫师三玩家遗忘，就连cdpr好像也忘了它，巫师三和二代基本没有什么关系，可能有人会反驳我，巫师三的开头就要模拟二代抉择，但事实上，对一个强调选择的rpg游戏来说，重要的不仅是选择，更是选择带来的后果，而巫师二那些惊心动魄的选择，在三代中几乎都成了定局，无论上亚甸是否赢得了独立，最后的区别不过是沦陷在亨赛特的军队下还是尼弗嘉德军队下而已。无论是否救回泰莫利亚最后的王室血脉，罗契都只能带着他的兄弟们再度流亡。更神奇的是二代最成功的女性角色，龙女居然不知所踪，事实上龙女和伊欧菲斯在巫师三曾有过一个现在沦为废案的任务，但因为赶工期被砍掉了。我们对比一下同样三部曲的龙腾世纪，一代的诸多队友都会在二代亮相，甚至还能在三代中当重要角色。而巫师三部间的关联则少得可怜，一代的女主角夏妮在石之心才出场，也就雷索与罗契在三代的戏份多一点，这无疑大大削弱了巫师中选择的分量。当然，我也能理解cdpr，三代是系列中唯一重启主线的一部，与更像外传的一二部有着极大的区别，并且这一作有着不小的制作规模，必须放弃前作壁垒，放低身段吸引新玩家，种种考量下，三代注定是相对独立的一作，更何况在二代一番精心算计下，事线固然优秀，但已经形成了逻辑闭环，也很难找到延续的办法。而三代为了种种考量，强行让南北形成均势，更破坏了延续巫师二剧情的可能性，尽管可惜，但巫师二作为一个完整的故事，也可以称得上优秀。 接下来我们就来讨论一下一款游戏。 首先，依照惯例，巫师二的系统，巫师二的画面在当年算得上不错，但毕竟此时的cdpr并没有太大经验，因此整部游戏的一些地方仍然显得很生涩，比如说，巫师二是没有跳跃功能的，只能让玩家去寻找攀爬点才能上下移动，而这些攀爬点则都做的很隐蔽，配合拙劣的导路功能，跑图体验难言理想，随后巫师二的战斗相比巫师三繁琐不少，同样分为三种流派，近战，炼金和法印，法印有单独的储备槽，能随着时间恢复，这点有点像dnd，近战则有和三代近似华丽但破绽很大的剑术，并且翻滚是没有无敌帧的，也就是说翻滚途中被攻击打断是常用的事。药剂和炸弹都是一次性用品，众所周知，rpg游戏的一次性用品就是不打最终boss能不用就不用的东西，因此虽然炼金流算得上强力，但由于合成的琐碎以及造价昂贵，走这条线的并不算多。总的来说巫师的战斗系统基本都是在及格线上徘徊的水平，实在没有多少意思。 而论起剧情，就很有的说了 巫师二的叙事有什么特点呢？ 第一，选择 巫师二依旧采取了巫师系列道德困境式的抉择，有不少人批评说这种列车难题式的道德抉择千篇一律，然而，我很好奇的是，他们指望在一个商业游戏里看到怎么样的抉择设定呢？巫师的抉择可能算不上精巧，但在rpg可以说是独树一帜的有分量，重要人物的生死，一个王国的命运，巫师二充斥着各种意义上的抉择，甚至包括第二章两个截然不同的路线。放眼整个rpg史，我敢说有如此大主线分歧的也是寥寥无几，而这样独特的设计，其实与巫师二的剧情结构有不少关系。 第二，双线叙事 我们的杰洛特一向对政治敬而远之，而巫师二构思巧妙之处在于，让一个对政治最没有兴趣的人成了北境局势的关键人物，在游戏中，双线并进的结构被广泛的运用。杰洛特的态度是模糊的，归根到底他不过是想洗脱罪名并寻回自己的记忆，这两大主线目标，前者为主线后者为暗线，都被牵扯到了同一个人身上——雷索。而对于雷索的刺杀行动而言，女术士集会所的阴谋浮现在明处，而隐藏最深的则是尼弗伽德入侵的阴谋。对于游戏中涉及的北境势力而言，两大对抗者，上亚甸和科德温，杰洛特在游戏中任选其一作为明线，另一方便会成为暗线穿插其中。几条剧情路线互相交叉，且彼此间都有说不清道不明的关系，可以说巫师二颇有些戏剧的风格，重要人物算不上多，但却有着极为复杂的人物关系，整个故事都十分耐人寻味。 第三，演出水平 巫师在剧情演出上向来不遗余力，这点倒是颇有生软的师传，巫师二增强版的开场cg对一个11年的游戏来说可以说无比华丽，而在随后的剧情中，也有不少制作不错的cg的即时演出，更有趣的是，不知道是不是为了赶时髦，巫师二还做了两个系列中少有的巨型boss战，在11年来说，这样的演出效果可以说相当不错了，说到这里不得不佩服cdpr的勇气，只做过一部巫师一就敢砸这么多钱到一个前景不明的项目去。 第四，政治阴谋 大部分宫廷政治故事都是肮脏的，巫师二也不例外，开篇我们就能看到为了自己和妹妹的私生子发动王国内战的妹控王，要说这妹控王也是个有勇有谋之辈，但把自己荒淫无度的行径公开到整个国家民众面前的行为，着实是让人叹为观止。如果你觉得这已经很毁三观了，那么我可以负责任地告诉你说，福尔泰斯特在北境执政者里是道德楷模级别的存在，整部游戏里你碰到的政治家，浮港的总督是个没有下限的人渣，亨赛特是个粗暴蛮横的野心家，此时看上去正常的拉多维德对待自己的恩师也是“无微不至”，就连浓眉大眼的斯坦尼斯王子，都能为了上位一脸坦荡地毒害龙女。 当然了，也有萨奇亚这种浑身坦荡的完美领袖，上亚甸是巫师中难得直接描写非人种族抗争的一段剧情，十分正能量和主旋律，算是难得地调剂了巫师阴暗冷酷的风格，巫师对“义军”的描写并没有落入俗套，龙女一身正气但是并不迂腐，伊欧菲斯虽然仇恨人类，但并不是不择手段之辈，他会对萨奇亚动心，会对救了他的命的杰洛特予以回报，矮人往往看上去豪放，却不失狡诈和算计，而义军中也有斯坦尼斯王子和菲丽芭这种野心家。Cdpr对上亚甸线是很上了些功夫的，多种族混杂的特点被个性迥异的npc完美地体现了出来。可以说，在有政治戏码的rpg中，巫师二绝对是一部水准上的作品。 稍微扯开一点话题，巫师二的最终boss雷索，我个人认为是rpg游戏设计得最成功的反派人物之一，雷索的人物志在b站就有，在此不做赘述，纵观其生平，不得不说无论是公事还是私德上，雷索都是一个近乎完美的角色，公事上为了复兴自己的学派，雷索完美执行了恩希尔大帝的命令，他的刺杀行动无不是计划周详，下手果断，善后的处理的也无可挑剔，甚至面对女术士集会所的谋划，将计就计把北境的大部分术士架上了火刑架，要知道，让术士吃这种大亏，这恐怕是猎魔人历史上都没几个人能做的壮举，更可贵的是雷索在做这些事的时候完全秉持公事公办，各为其主的态度，他没有因为杰洛特是福尔泰斯特的护卫就下手迟疑，也没有把自己兄弟的死记在杰洛特头上，他始终清楚地认识到自己不过是尼弗伽德的一把刀这个事实，即使三代中被恩希尔背刺了一刀，也很难说他会有多么吃惊，而在私德方面，为了答谢杰洛特的救命之恩，他跟着杰洛特去迎战几乎没有胜机的狂猎大军，保护叶奈法，甚至在最后把特莉丝从大屠杀中救了出来，而在整场游戏中，他一次也没有对杰洛特下死手。这种文能算计整个北境的术士，武能压制失忆期杰洛特的全能型人才，实在是比工具人白狼不知道高到哪里去了。可能每个巫师系列的粉丝都对巫师四有自己的想法，不过如果是我的话，我是很希望能有以雷索为主角的一部游戏，这个人设实在是太强了。 上述是我个人认为巫师二的优点，不过如果你要问我有没有缺点，那我也可以很明确的说，有的，而且还很明显，并且这个缺点贯穿了整个巫师系列。 我们知道，rpg的意思就是角色扮演游戏，意思就是可以让玩家扮演一个虚拟角色在一个虚拟世界中做出种种行为，巫师系列是21世纪rpg的一大系列，但巫师却并不是一个完全标准的rpg，为什么呢？因为杰洛特是有性格的，杰洛特大体的性格是，外冷内热，自尊心强，外表冷酷无情，内心深处其实是一个傲娇老好人，这样问题就来了，你杰洛特都有性格了，那玩家怎么做选择，cdpr的回答是，尽量把所有选择都做成两难式的，即使是杰洛特本人来选也会犹豫的那种，这也是为什么cdpr总是喜欢这种两难抉择的原因，但还有问题，总有一些真正的杰洛特不会犹豫的选择，比如说真正的杰洛特必然是椰奶的舔狗，而面对这种选择，玩家只能扮演自己，这就让巫师的剧情流程也有了一种割裂感，你是要扮演杰洛特还是扮演自己，这是在你打开巫师游戏前要先做出的选择。当然，两种选择都无可厚非，但这也必然会造成一些矛盾性的情况，像巫师二里，无论哪条线路，不去救特莉丝都会都会对游戏的重要角色大有益处，作为玩家，如果你查了攻略，你就会知道好兄弟雷索会帮你把萌特救出来，然而如果真让杰洛特选他绝对不会放弃自己的情人，也就意味着，要么玩家放弃选择权，要么就要忍受杰洛特的ooc（人设崩塌）。 我个人觉得这是个不大不小的问题，只要做好心理准备还是能忍受的，毕竟一个小说改游戏，碰到这种问题也是难免的，cdpr其实已经把平衡性做的挺好了，没必要太苛求。额，如果这也算孝子那就算吧，不狡辩。 回过头去看，巫师二确实是一部难得的rpg佳作，但它未必是一个合格的承上启下之作，巫师二讲了一个太过精彩的故事，导致接下来不怎么好编了，尼国平推北方顺理成章却很无趣，北方反攻又是天方夜谭，导致巫师三的政治形势显得十分强行，迪胖和拉多维德其实都像开了挂一样，要知道，历史是没有个人英雄主义的，区区一个统治者就能逆转尼弗伽德和北方天堑一般的差距吗？这多少有点机械降神了。这么说来巫师二某种意义上近乎把故事讲死了，不过如果我是cdpr估计也会很无奈，小说基本已经写到恩希尔大帝快一统天下的地步了，巫师由于以杰洛特这种政治无关人士作为主角，搞点宫廷刺杀已经是政治戏的极限了，还能怎么编呢？ 写到这突然想到，巫师三里曾经对雷索喊打喊杀的杰洛特也成了“国王刺客”，这可真是，人终将活成自己最讨厌的样子。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;熟悉我的朋友都知道，我本人是巫师系列的死忠，如果让我给rpg游戏做一个排行，我会把巫师放在第一位，有的人可能会说，巫师固然是rpg佳作，但在浩如烟海，名作辈出的rpg里可未必排的上号，又有的人可能会说，说这么多不过是“情怀党”的矫情而已。</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="wrpg" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/wrpg/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="巫师二" scheme="https://thinklive1.github.io/tags/%E5%B7%AB%E5%B8%88%E4%BA%8C/"/>
    
  </entry>
  
  <entry>
    <title>影子工厂</title>
    <link href="https://thinklive1.github.io/2023/09/30/%E5%BD%B1%E5%AD%90%E5%B7%A5%E5%8E%82/"/>
    <id>https://thinklive1.github.io/2023/09/30/%E5%BD%B1%E5%AD%90%E5%B7%A5%E5%8E%82/</id>
    <published>2023-09-30T11:38:04.163Z</published>
    <updated>2023-11-27T12:47:59.697Z</updated>
    
    <content type="html"><![CDATA[<p>我本以为影子工厂会如简介说的一样，会是杂糅诸多风格的悬疑风，故事的一开始也的确如此，时间穿越配合豪宅血腥谋杀的经典模式别有一番风味，不过结合前传一贯的发展，不难想象出而在这之后又回到了我们熟悉的时间轴环节，比较特殊的是，这次高瞰老师罕见地采用了正叙的方式，而且此次的故事出奇的平淡，尽管感情上依旧无比细腻，但几乎没有什么出乎意料地发展。 <span id="more"></span> 而事实上，高瞰老师擅长的叙事诡计只是换了一种方式呈现在我们面前，这是一个一位身患绝症的女性在生活和事业中苦苦挣扎，在经历了孩子的夭折后，最后选择了事业的故事，尽管这个故事占了整部游戏大半的流程，但其实它本身并不是重点，因为在开头，影子工厂的主线就被堂而皇之地摆在了我们的面前，豪宅层出不穷的死亡案件，于是，在历览了女主的人生后，真相的追寻才真正开始，当然了，故事如何这里就不赘述了。 当然，相比前两作选材的独特，和层出不穷的叙事诡计，影子工厂显得平淡的多，正如lynri所说，昆西相比两位博士不过是一个观察者而已，他对于挚爱的lynri无能为力，面对自己不过是模拟的数据也无能为力，他的一生没有什么狂乱幻想，也没有多么丰富的内心世界，尽管他的内心是强大的，不过依旧没有什么意思。当昆西历览lynri的记忆时，我们会发现相比博士的聒噪，大部分时候他不过沉默地接受着，评价这一环节是在这段记忆中缺少的。而让这段记忆，一个不是最重要的故事占据叙事的大部分是可以的，但问题在于这一部分必须要穿插主线，否则会产生严重的割裂感，而就影子工厂来说，很难说这一部分和主线有着多大的关系，是否手术的分歧导致了之后的一切，但要拼凑出真相，我们需要知道的除了这个世界不是真实的以外，还有分歧点在于保大还是保小，以及lynri的姓氏，而这两点都没有结合进这个过程。抛开叙事结构，如果我们只看这个故事本身，昆西的爱情故事虽然不能说不好，但比起前作的惊艳未免显得俗套。可以说，如果把这个故事大刀阔斧地砍几笔，也不会有多大的差别，当然，就故事的首尾而言依旧是很有趣的。 不过即便如此，我也要说影子工厂是一部水准上的作品，它有着层层递归的脑洞，优秀的人物塑造，最重要的是，它还展示了高瞰老师填坑的一点点意愿，虽然到最后我们也不会知道两位博士之后到底会怎么发展。而对于系列中虽然重要但没有认真探讨过的记忆编辑技术，影子工厂也表明了一种态度，就是尽管这可能看上去虚无的，但就我们个人所及的知识与眼见来看，只有有过美好的时刻，它就是有意义的，这是一种积极向上的态度，尽管这只是一种态度，但对于虚无与否的讨论大部分时候都只能取决于我们的态度。能以合适的形式传达出这样的观点，就是一部很好的作品了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我本以为影子工厂会如简介说的一样，会是杂糅诸多风格的悬疑风，故事的一开始也的确如此，时间穿越配合豪宅血腥谋杀的经典模式别有一番风味，不过结合前传一贯的发展，不难想象出而在这之后又回到了我们熟悉的时间轴环节，比较特殊的是，这次高瞰老师罕见地采用了正叙的方式，而且此次的故事出奇的平淡，尽管感情上依旧无比细腻，但几乎没有什么出乎意料地发展。</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="独立游戏" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="影子工厂" scheme="https://thinklive1.github.io/tags/%E5%BD%B1%E5%AD%90%E5%B7%A5%E5%8E%82/"/>
    
  </entry>
  
  <entry>
    <title>游戏互动性的新探索——步行模拟器</title>
    <link href="https://thinklive1.github.io/2023/09/30/%E6%AD%A5%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    <id>https://thinklive1.github.io/2023/09/30/%E6%AD%A5%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8/</id>
    <published>2023-09-30T11:35:13.293Z</published>
    <updated>2023-11-27T12:47:59.707Z</updated>
    
    <content type="html"><![CDATA[<p>步行模拟器，在本视频中取操作只局限于步行和一些简单动作，主要获取信息的途径为阅读和观察的游戏，这是一种颇为先锋，也颇为小众的游戏类型，在其中有一些火到出圈的佳作，也有缺点明细的庸作，但都有着共性在其中，今天，我就用一个业余爱好者的身份来浅析一下这类游戏。 <span id="more"></span> 我们先从步行模拟器的历史说起，由于我不是专业人士，也不是什么老玩家，所以只能大概地说说。 溯及这类游戏的根源是一件很难且没有必要的事情，所以我们只把目光放在本世纪好了，在2007年，一个传奇的年份，当时的游戏界见证了巫师一，质量效应一，刺客信条一等传奇系列首作的诞生，也有一些人注意到一款名为《亲爱的艾斯特》的奇异游戏，对一个原教旨主义者来说它可能算不上游戏，玩家操控着一位失去妻子的男人在孤岛上步行，整部游戏唯一的信息来源就是沿途的风景，壁画，以及男人的自言自语，某种意义上这带来了一种推理小说式的体验，你需要在文本中领略事件的来龙去脉，同时体验它压抑深沉的环境氛围。 亲爱的艾斯特取得了意想不到的小范围成功，本作为免费游戏的它在12年发布了付费版，并取得了80万的销量，可以说，近十年的步行模拟器很大程度上是由它启蒙的。 因此，以12年为分水岭，逐渐涌现出不少的步行模拟器游戏。 13年亮相的是著名的meta游戏史丹利的寓言和较为平庸的到家（gone home） 14年问世的是解密风的伊森卡特的消失 15年艾斯特的工作室发行了同类型的万众狂欢 16年则有看火人与弗吉尼亚出现 而在17年，此类型的集大成者，艾迪芬奇的记忆横空出世，成为了此类型至今为止的最优者 可能不少对此类游戏毫无兴趣的玩家会好奇，步行模拟器的卖点到底在哪? 在这个媒体资源空前丰富的时代，每个人都能输出自己的思想，因此思想的输出变得极为廉价，而接受者的地位却会被拔高，因此，门槛越高的思想输出方式就有着越大的不被接受的风险，导致晦涩隐喻的内容就会不受待见。尽管如此，这些晦涩的思想与表达依旧是存在的，步行模拟器就是一种方式。 事实上，接受他人的思想表达一直都有很大的风险，只要作者多加一点私货，或者在莫名其妙的地方整个活，接受者的思想就会收到极大的冲击，例子我就不举了，懂得都懂。所以很多人都会倾向于不去接受，晦涩的作品他们根本不会碰，也有的人沉迷于此类快感，不顾风险地追寻自己认为好的输出者，这两种选择没有高下之分，但体现在游戏上，我们就会发现后者经常会成为所谓的小众游戏爱好者，这并不意味着他们很优越，相反，他们可能已经踩过不知道多少雷了。 为此前的论述做一个总结，步行模拟器可以作为一个高门槛的思想输出方法，因此能吸引一些喜欢此类体验的玩家。事实上，它和同样强调探索的avg可能存在一些关系，但由于我对此没有足够的知识，就不献丑了。 在此基础上，我们来分析此类游戏的一些特性。 首先，第一个问题是，为什么要用步行模拟器这种形式，毫无疑问这种游戏的互动性基本不是很强，也没有刺激官能的要素，然而，正是因为这种自断一臂式的操作，让它能够把自己的叙事能力提高到大部分游戏所不能及的程度，玩法单一也就意味着玩家的注意力会完全集中于一点，制作者只要专注于此方面，就能高频度地向玩家提供信息，而不会让人一头雾水，因为这样的特点，相比大部分游戏，步行模拟器可以聚焦于很多与众不同的题材，可以选用不同的叙事方式， 另一个优点是，较小的游戏规模与如今相对成熟的游戏工业，让制作者能以较为低廉的成本做出不同的场景，美术效果和环境在步行模拟器中有很大的作用，我之所以这么说，不仅是因为它有着渲染气氛的作用，在很多此类游戏中，环境本身就承担着叙事的任务，尤其以艾迪芬奇的记忆而言，环境在这款游戏中达到了当代游戏的新高度，不同的房间布置在无言中传达了房间主人的个性，甚至在一些细节中暗示了主人的命运。可以这么说，在很多步行模拟器中，环境有着超越装饰的作用 步行模拟器还有一个特点，那就是它是第一人称的，你可能单纯地觉得这是为了提高代入感，但事实上，因为互动性的匮乏，步行模拟器往往更趋向于探索和体验，而不是扮演，更形象的说法是，在步行模拟器中看到的是别人的故事，因此在我看来，第一人称更多的意义是类似侦探小说的叙述主体，也就是说，以这个故事而言，第一人称对应的角色就是最适合展现故事全貌的人，同时，这个主体具体的身份也可以是一个谜题，伊森卡特的消失，艾迪芬奇的记忆都在这方面上做了文章，非常有趣。 上述特点事实上还是很笼统的，实际上的步行模拟器在风格和题材上都是各具特色，特点也不尽相同，但由于到目前为止出名的步行模拟器实在不多，所以我们就用穷举的方法来说说这些步行模拟器。 先从最早的亲爱的艾斯特说起 在所有步行模拟器中，艾斯特应该是互动性最低的一个，你能做的只有控制一个喃喃自语的男人在孤岛上乱走，然而，艾斯特依然是一部很优秀的游戏，优秀的文本质量和环境建模完美地融合在了一起，配合迷雾重重的故事，与四个风格迥异的场景与种种细节，成功营造出了一种哀伤中透着迷幻的气氛。虽然选取了悼念亡妻的题材，但艾斯特并没有直接表现哀伤，叙事主体的男子呈现的态度是思辨的，其文本很有些深度，艾斯特的氛围塑造与文本水平，我个人认为是步行模拟器中最优秀的之一，并没有被后来者超越，甚至也没有被他们自己超越。 史丹利的寓言 这游戏很难归类，它更为众人所熟悉的标签是meta游戏，举个不恰当的例子，meta游戏和游戏的区别就像文学批评和文学的区别，很难说史丹利的目的是对游戏这一创作形式进行批判还是呈现一段故事。 这游戏几乎是靠作者一个人的天才撑起来的，即便在meta游戏中有史丹利寓言这么强烈批判属性的游戏，据我所知也是不存在的，它很有创设性的给予了游戏四个视角两个阵营，呈现者阵营的游戏系统（游戏作者？）与旁白，接受者阵营的史丹利与玩家本人，史丹利的故事几乎都是两个阵营间不同角色的互动，它实现了大部分游戏都做不到的一点，即让玩家直接与游戏的底层逻辑对话。 现代游戏互动性的本质是什么，无非不过是选择而已，拟真度高的游戏也不过是多提供了一些选项，史丹利抓住了这个底层逻辑，因此哪怕是步行模拟器这一形式只要用好“选择”，就不会缺少互动性。 这样的策略让史丹利显得不是那么“步行模拟器”，但实际上这还是一部叙事游戏，只不过它的故事千变万化，且富有批判意味，而且它的叙事有着“选择”的成分，因此它包含了十几个不同的故事。 归家 归家是一部很有实验意义的作品，如果你情商比较高的话，应该就知道我的意思是这游戏有着不少的缺点，归家的故事发生在20世纪末的一个美国家庭，一个暴风雨之夜，家中的姐姐回到家中，发现妹妹离家出走，于是开始寻找原因，归家的核心机制是拾取/查看物体触发回忆，核心谜题则是揭开妹妹的下落，然而这游戏的故事非常简单，简单到什么程度呢？在触发前三个回忆后你基本上就能猜到故事的梗概了——没错，一个俗套的恋爱被父母反对然后私奔的故事，稍微有些不同的是，主角是两位女同性恋，此外，游戏中有一些不怎么明显的机关且缺乏提示的机关，总体感觉实在是索然无味，尽管某种意义上它为有核心谜题的步行模拟器树了一个榜样，但论其素质十分乏善可陈，最大的优点可能是还算有20世纪风格的家居布置。 值得一提的是ign给了归家9.5的超高分，对ign来说这种分数是很少见的，我们之前提到的艾斯特得到了8分，史丹利寓言得到了8.8分，而品质平平的到家则得到了9.5分的超高评价，并且编辑的评论是没有缺点，联系其故事题材，此件原因令人深思，因为涉及敏感话题，我就不多说了 伊森卡特的消失 这是一部很有风格的作品，在场景建模上制作组创作性的采用了结合实景照片的做法，因此画质显得极为真实，配合微恐怖的风格，代入感极强，游戏的内容是一个有着回溯犯罪现场能力的侦探应伊斯卡特的邀请调查一个据说有着不可名状怪物的地区的系列凶杀案，抛开几乎为0的地图指引，游玩过程中你会觉得这似乎就是一个普通的解谜游戏，虽有称道之处，但综合来看质量一般，然而，这款游戏最值得称道的一点是，制作组为了一个有极大反转的结局在流程中埋了不少伏笔，因此伊森卡特的结局在我看来在叙事游戏中算最优秀的一档，当然实际上这也是见仁见智的一件事，或许也有不少人觉得铺垫不足。 在步行模拟器中悬疑风格的作品伊斯卡特应该可以说是最成功的。 万众狂欢 这是一部和亲爱的艾斯特风格迥异的作品，它没有叙事主体，玩家以超然的眼光去回顾一座村庄全员蒸发的惨剧，我认为这是一部失败的作品，为什么呢。作为一个拼凑出故事全貌的游戏，万众狂欢很不幸的选择了把最大的悬念放在开头——凶手是形似光球的不可名状生物，而游戏的过程则是目睹居民怎么一步步迈向死亡，整个过程中的互动，只有不如不做的触发回忆过程有——跟着手柄按QTE。具体到故事，恕我直言是很无聊的，寥寥几语的场景中大部分缺少让人身临其境的氛围营造，整部游戏有着浓郁的宗教风格，因此部分场景会有种神圣感，但也就仅此而已了，没有悬念，没有细腻的情感，没有复杂精彩的故事，更没有氛围的营造，万众狂欢在我看来是一部平庸的游戏 看火人 在众多步行模拟器中，看火人是极其冷门的纯写实题材，它选取了森林看护员这一冷门的职业视角来叙述故事，然而它的美术风格却是抽象的大色块风格，这造就了看火人实中有虚的奇妙质感，不论看火人的故事如何，这样的题材与美术创新是优秀的且值得鼓励的。 主角亨利在爱妻患病后心灰意冷，因为酗酒被妻子家人排挤的他最后来到了荒无人烟的森林公园成为了火情瞭望员，我们可以看到，游戏的主题几乎已经确定为心灵的救赎，但看火人的呈现方式是特别的，因为职业的特殊性，从始至终能与亨利交流的只有一位名为黛利拉的女性，在一片孤独的瞭望塔中这似乎是亨利唯一的情感支柱，事实上，看火人最大的优点就是情感的细腻，整个游戏几乎就是亨利与黛利拉互相的情感激励与救赎，最后这场类似柏拉图之恋的关系随着因为火情观察员撤离而收尾。 值得一提的是，看火人神奇的在游戏中夹杂了不少悬疑的成分，这让看火人的基调显得有些奇怪，由一开始的悠闲巡逻转到紧张的解密，随后又在急转直下后收尾，尽管不算无聊，但前后依旧有割裂感。 尽管如此，凭借细腻的情感描写，看火人依旧是一部优秀的游戏。 弗吉尼亚 这是一款很奇特的游戏，即使在步行模拟器里，它也是交互性最差的一类，它使用了一种极为抽象的风格，整个游戏由很多不明所以，充斥着象征的片段组成，而将这些片段串联到一起不过是一些点触的操作，坦白的说，我只能分离地去欣赏这些场景，单从象征的角度来说这些场景单独拿出来还挺有意思的，但你很难把这些片段连起来，事实上不让你把他们连起来可能正是这游戏的目的，此外，该游戏使用了很罕见的古典风格配乐，配合上本就很魔幻的内容产生了一种难以言喻的奇特的氛围。总的来说，这真的是一个很难评价的游戏，如果你有些猎奇心的话倒可以尝试一下 艾迪芬奇的记忆 艾迪芬奇的记忆是一款很优秀的游戏，但它的意义不仅如此，可以说在对互动性的新尝试方面，艾迪芬奇是游戏界最前沿的一个，游戏在叙事上最大的优势就是互动性，大部分游戏选择了剧情分支，qte之类的通解，而艾迪芬奇的记忆则在此基础上作出了创新，单论最简单的字幕，往往只被放置在屏幕底部用于阐释信息，而艾迪芬奇则将它放置在了场景之中，伴随着主角的前进逐渐浮现在路边，如此一来字幕甚至兼任了指引的作用。 依我看来，艾迪芬奇的主基调可以用魔幻二字来概括。随着艾迪依次探索旧宅，我们进入了一个个家族成员死前的景象中，但我们透过屏幕看到的不仅仅是一个个纪录片式的景象，还有情绪的具象化，例如令人啧啧称奇的操纵漫画中的角色一段，操纵角色在悬疑漫画的分镜中行走，这是一种崭新且绝妙的传递恐惧感的方式，艾迪芬奇的互动形式总是新颖的，角色伴随着开罐头喃喃自语，在切鱼的流水线上展开与工作融为一体的幻想，手柄的两遥感分别控制现实与幻想世界，此类新颖的设想，艾迪芬奇有近十种，可以这是一款极为奢侈的堆砌创意的游戏。 艾迪芬奇的家族大都耽于幻想，他们的幻想往往与现实融为一体，以此呈现出的情景显得分外的魔幻，以游戏的形式来叙述这样的故事，这一模式提供了一种特别的审视真实世界与内心世界的视角，这样类似魔幻现实主义的创作手法可以说极为前卫和有趣。 毫无疑问艾迪芬奇的互动性与创意是它最耀眼的闪光点，在此的映衬下，艾迪芬奇的剧情似乎显得暧昧不清，多个家庭成员的死亡都没有得到明确交代，尽管在一个个情景中我们能在画面中感知到情绪的具象化，尽管艾迪芬奇家族一向有着早死的诅咒，但艾迪芬奇没有，至少没有直接透露任何家庭成员对于死亡的看法，在一部探讨死亡的作品中这点显得很奇怪，似乎它只想将死亡本身呈现出来，却不想对此发表任何议论，我们很难说艾迪芬奇有什么主旨，在死亡这个主题上，制作组显得分外的冷漠，只留下玩家在原地回味。Steam上艾迪芬奇的商店页面有这样一句差评，艾迪芬奇的记忆有着美化死亡的嫌疑，这对那些有自杀倾向的人来说似乎太不友好了。这并不是没有道理。 总结 步行模拟器始终是个小众的品类，它固然有着一些创作上的优点，但成本和受众的因素始终制约着这一类型，导致作品寥寥无几，但在步行模拟器其实不乏对游戏这一创作形式的革新，作为新时代的叙事向avg游戏与独立游戏的一大阵营，步行模拟器的身上其实或多或少蕴含着电子游戏未来的一大方向，即作为有才能的作者表达自己的一种方式，对此我报以极大的期待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;步行模拟器，在本视频中取操作只局限于步行和一些简单动作，主要获取信息的途径为阅读和观察的游戏，这是一种颇为先锋，也颇为小众的游戏类型，在其中有一些火到出圈的佳作，也有缺点明细的庸作，但都有着共性在其中，今天，我就用一个业余爱好者的身份来浅析一下这类游戏。</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="独立游戏" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="步行模拟器" scheme="https://thinklive1.github.io/tags/%E6%AD%A5%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>不予播出——极端意识形态大乱斗</title>
    <link href="https://thinklive1.github.io/2023/09/30/%E4%B8%8D%E4%BA%88%E6%92%AD%E5%87%BA/"/>
    <id>https://thinklive1.github.io/2023/09/30/%E4%B8%8D%E4%BA%88%E6%92%AD%E5%87%BA/</id>
    <published>2023-09-30T11:29:37.573Z</published>
    <updated>2023-11-27T12:47:59.697Z</updated>
    
    <content type="html"><![CDATA[<p>吉姆哈克：当一个国家走在下坡路上，必须有一个给它踩一脚油门。 你生活在一个贫富差距分化严重，外部国家敌意渐升的民主国家，而在此危难关头，一个名为先进党的政党，凭借集体主义的价值观，以及消灭富人扶持穷人的竞选纲领上了台，时代变换的帷幕在你面前缓缓拉开，这时，你能做什么呢？ <span id="more"></span> 这大概就是不予播出想呈现的故事，这个游戏是我认为近年zz题材最出彩的一部独立游戏。 我们先从游戏的形式说起 它选取了一个很少见的视角——电视台导播，也就是在电视内容被播放前负责镜头切换与简单后期音效处理的一个职位，这是一个虽然默默无名却十分重要的职位，制作组对此的选择非常高明，在这个位置上你能接收到一切媒体信息，同时决定哪些内容会被最后播出。 游戏的背景设定是魔改版的80年代英国，想想就知道在这个电视台的黄金时代这个职位意味着什么。 在我们这个娱乐至死的年代，恐怕我们的印象中很难会有什么凭良心的办事的媒体人，但在游戏中，随着举足轻重的影响力而来的同样还有巨大的责任，我们可以看到游戏的封面是一个被操控的提线木偶端坐于导播台前，这似乎预示着你不过是政党口中的喉舌，事实上，面对zz大势，大部分时候你确实是无力的，但总有一些事是你可以做的。游戏中，你能做的包括切换各种机位设置，添加后期音效这些普通的工作，你也可以转而接收反对党的信号，甚至在暗中支持他们。 可以说这样的玩法绝对算不上丰富，但是，为了这些内容制作组拍摄了极为大量的采访，节目，等等实景拍摄，这些作品的文案，演出水平都极为突出，也就是说，让你去观看这些节目，决定他们如何被呈现于观众面前，才是它的核心玩法。 于是，我们可以说说它的剧情了。 我为不予播出的剧情概括了一些特点，首先是荒谬性 国家晚间新闻，是一家有不少zz性的电台，在游戏的一开始，作为新上任的导播，我们的第一次工作就见证了前文提到的先进党的上台，在游戏的一开始我们能感受到强烈的荒谬感，就拿先进党举例，该党的带头人是一对夫妇，丈夫粗俗不堪，而妻子却圆滑世故，这样一对其貌不扬的夫妇在自己上任的第一天就大声向“富人”宣战，我们知道，如果对这些拥有大量资产的人过于苛刻就会造成大量资产外流，对此这对夫妇甚至采用强制手法禁止他们出境，这对一个“民主”国家而言恐怕很难想象，更为魔幻的是这样的举措确实赢得了大众为他们叫好，收归民有资产为国有，强制推行福利政策，提倡集体主义，一副宏伟的蓝图就这样在我们面前展开，即使对民粹主义者来说，这样狂野的改革恐怕也有些吓人，而这些种种举措以极快的速度在游戏中发生了，并且让你切实的体会到厉害之处——也就是游戏中各种惊慌失措的小资产阶级。如果你问大资产阶级咋样了，就有限的情报来说，似乎他们在与国家合作后过得很好。 这是一家很有煽动性的政党，但如果你细细去看他们做了什么，建立国家养老机构（把老人送进去就可以不管了）成立青少年队伍（洗脑从娃娃抓起）半强制推行政党性而不是国家性的身份卡（很明显，只是后续动作的开始）甚至把反对的国家的个别城市用特工安置的核弹统统炸上天。 很荒谬，不是吗？但这些事情确实如此发生了。</p><p>如果你很好奇对此的政治评论是怎样的，那么我们很快就会见识到该游戏另一个厉害之处——现实性的缺席。 在游戏的一开始国家晚间新闻是一家较为严肃的新闻频道，但随着游戏的进程，娱乐性的报道和节目越来越多（而且不乏先进党资助的无聊作品），这次过程中有着不少精妙的讽刺，例如领着先进党资助大搞政治正确的校园舞台剧组合，光明正大搞热水器的女明星等等，此时在早期的一些政治性节目中，也有不少让人啼笑皆非的人物，例如奉行白人至上主义，热爱sm的警察局局长，似乎几个小丑粉墨登场就能谈起国家大事。作为理应为公众揭露真相的媒体，自己就陷入了娱乐至死的泥潭 不过他们又能怎么办呢？对于一个奉行强权政治的政党，让一个电视台说不了真话简直太容易了。所以我们在游戏中看到的趋势是，节目变得越来越无聊，又臭又长，当批评声变得刺耳，那么连赞扬得不够卖力也成了罪责。 但游戏中依然有着保存着良心的媒体人，杰里米的爆发大概处于游戏中期，他挟持了摄像头，指责所有人都失去了说话的勇气，随后自绝于心爱的镜头前。这段的演出可以说全游戏最大的一个亮点，荒诞的现实与理想的缺席构成了极大的对比，将游戏荒谬而现实的矛盾感体现得极为突出。 然后，我们要说到极端意识形态题材作品的一体两面——压迫与反抗 哪里有压迫，哪里就有反抗，对于极端意识形态题材而言，对其的呈现与对反抗的呈现是一枚硬币的两面，与其他反乌托邦作品伟光正的反抗者不同，不予播出的反对者仅仅是走向了另一个极端。在游戏中有一个明确的反对者——打断组织，这个组织是什么样的呢？很大程度上可能由一些小资产阶级与无产阶级组成，面对集权，他们选择了暴力，游行，破坏，暴动甚至军事政变，我们很难说打断是一个多好的选择，事实上他们根本没有提出什么解决方案，似乎只是因为自己的利益受到了侵犯而已，在游戏的结局我们可以看到打断组织不过是军方扶持的傀儡，用完即扔。 再说回先进党，这一党派在游戏的中期收到全世界的敌视与孤立，不得不进行完全的内循环经济，究其原因，或许是对有产阶级的镇压并不符合经济全球化的要求，从而招致了其他国家的敌视，随后，他们向全世界部分国家的城市引爆核弹，建立起核威慑。 试问，如果你是一位普通人，你能做出什么样的选择呢？ 说到这里，就不得不说不予播出另一个有趣的机制——在导播工作的间隙你将以视觉小说的形式看到作为普通人的自己如何在政治的漩涡中生活。与电视上光鲜亮丽的报道不同，即使作为被济的穷人，你也不过是从一贫如洗走向负债累累而已。 恐怕根本没有什么更好的选择。 最后，我们应该回归这部游戏贯穿始终的特点——讽刺性和娱乐性 可以说，这部游戏最终呈现的是一个荒谬的世界，在政治领域极端，疯狂，暴力构成了它的底色，这也是我称其为极端意识形态大乱斗的原因 你要问这样的构建是否过于疯狂而丢失了真实性，而且想要展现这样的世界观一个导播的视角也远远不够，可能的确是这样，但我认为这样极端之间的碰撞反而能增加不少的戏剧性。 可能根本不会有这么极端的政党，可能如此极端的政党根本得不到如此多的武力支持，或许吧，但说到底，这不过是个讽刺性游戏而已，用夸张的手法实属正常。 而在政治以外的社会领域呢？滑稽，疯癫，娱乐才是它的主题，你可以看到收藏大粪为乐的清洁工，无法控制肠道蠕动放出气体的“病患”等等极为魔幻的人物登上荧幕，可以说，游戏中所有的人物都是经过夸张化和娱乐化的，即使抛开政治性，你也可以当笑话看。这是我很欣赏不予播出的一点，它并不完全正经，但绝对有趣。</p><p>最后，做一个总结吧，根据关键节点的选择不同，游戏一共有14种结局，有一家独大，有天下大乱，也有非极端派兴起，这些结局有的因你而起，有的不过是大势所趋。不予播出从一个导播的小人物视角出发，呈现了一个极端意识形态偏向的荒谬社会的百态，有戏剧性的加工，也有对真实世界的化用与讽刺。 说实话，政治讽刺题材的乐趣不正是在此吗？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;吉姆哈克：当一个国家走在下坡路上，必须有一个给它踩一脚油门。 你生活在一个贫富差距分化严重，外部国家敌意渐升的民主国家，而在此危难关头，一个名为先进党的政党，凭借集体主义的价值观，以及消灭富人扶持穷人的竞选纲领上了台，时代变换的帷幕在你面前缓缓拉开，这时，你能做什么呢？</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="独立游戏" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="not for broadcast" scheme="https://thinklive1.github.io/tags/not-for-broadcast/"/>
    
  </entry>
  
  <entry>
    <title>【杀手3争议】拟真性与游戏性之争</title>
    <link href="https://thinklive1.github.io/2023/09/30/%E6%9D%80%E6%89%8B47/"/>
    <id>https://thinklive1.github.io/2023/09/30/%E6%9D%80%E6%89%8B47/</id>
    <published>2023-09-30T11:28:34.863Z</published>
    <updated>2023-11-27T12:47:59.707Z</updated>
    
    <content type="html"><![CDATA[<p>2022年一月份，杀手3将解除一周年的独占，登录steam，而早在21年初，杀手3就成了一款有点话题性的游戏，这是因为游戏的一张重庆的地图，这一地图因为缝合了赛博朋克，老大哥等元素被指责有乳制品嫌疑。 <span id="more"></span> 在仔细讨论这件事前，让我们先来看看这是一个什么样的游戏。平心而论，作为一个系列续作，杀手3可以说还算合格，虽然刺杀方式上有缩水，但看得出制作组在氛围营造上投入了不少努力，有很多截一帧就是壁纸的远景或者特写。杀手系列可以说是一个好游戏，甚至可以说是刺杀游戏这一细分品类的霸主，但ioi是纯纯的懒狗，犯下了版本混乱，高价低质量dlc，违背承诺种种重大错误，ioi并不是一个好开发商，如果你骂ioi，我举双手赞成，但对杀手三3有没有乳，我认为还是要谨慎讨论。 我所好奇的是，杀手是不是一个拟真的游戏？ 我想只要你玩过这个游戏，你就会知道答案是否定的，即便是游戏的核心——刺杀系统，也有很多方案并不具有现实可行性。，如果说起其他设定，就更没有真实性了，杀手三部曲的反派是一个势力遍及全球，由“社会精英”组成的阴谋论组织，我并不认为这样的组织有什么现实可行性，如果我们这种普通人都能知道这样的组织，那只有两个可能，1这样的组织情报保密工作很烂，那它早该被拿下来了2它故意泄露的，实际上我们对它一无所知，那就让我们一切的想法都成了臆测，阴谋论是一些无法质疑的假设，这样的假设我可以提出几百个。 当然，我们没必要对一个游戏上纲上线，即便涉及到阴谋论，也只能说杀手并不是一个拟真的游戏。那么，作为一个涉及到多个国家刺杀目标的游戏，杀手对其中的国家是怎么描写的呢？ 摩洛哥在杀手里被描绘成政府软弱无能被军阀控制，甚至准备发动政变，我们且不论这是不是真的，无论如何这都不是什么很友好的描写，我们提到过的阴谋论组织的一位高层在法国有一个大葡萄酒厂，很符合我们对法国的刻板印象吧，然而这位律师有私人武装，甚至包括一队直接听命的狙击手，我想法国不会放任私人权利到这个地步。孟买的街头扛着步枪的武装士兵到处走，北欧的高端别墅区一栋不算特别大的别墅有十几个全副武装的保镖，这些对我一个中国人来说都觉得不合理，可见杀手这个系列根本没有多少写实性。 我们可以做一个总结了，无论从什么角度看杀手都不是一个贴近现实的游戏，特别是在zz方面，尤其口无遮拦，什么都编的得出来。 那让我们再看看重庆这张图，这张图有什么呢，赛博朋克+老大哥，大量的监控摄像头，华人街一样的街道和餐馆，秘密暗杀组织的不人道实验，改造人类街头的流浪汉，我们之前也说了，杀手的地图里编的成分很大，更何况设定上ICA最重要的实验室就在这里，与其说ioi想还原什么地方，倒不如说估计是他们看到一些关于重庆很赛博朋克的新闻，然后觉得可以蹭一下人设。试问这些元素有多少是真正不合适的呢，脑子正常的人都不会觉得现在有技术能操控人的思想或者改造人类吧，既然你不会觉得这些情节是真的，你为什么会觉得这座城市是真的这样呢？ 当然，事实上这样的论述也是有模糊性的，你可以说不够还原就是不够尊重，也可以说法国，美国的图比中国的还原是歧视，在国际矛盾激化的今天，会在这样的事上比较敏感可以理解，但我想说，我希望并呼吁大家在至少在文娱领域多一些宽容，不要泛政治化，能疑罪从无就不要恶意去揣测。 47的目标有很多罪不至死，为了一己私欲杀死无罪者，这难道不是宣传不良价值观吗？但恐怕没人这么批评，为什么我们会在道德上对文娱作品这么宽容，在政治上却那么草木皆兵呢？ 我很希望大家能多一些宽容，我也希望文娱作品无论何时都应该是一片不被zz过分染指的净土</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022年一月份，杀手3将解除一周年的独占，登录steam，而早在21年初，杀手3就成了一款有点话题性的游戏，这是因为游戏的一张重庆的地图，这一地图因为缝合了赛博朋克，老大哥等元素被指责有乳制品嫌疑。</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="其他游戏" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="hitman" scheme="https://thinklive1.github.io/tags/hitman/"/>
    
  </entry>
  
  <entry>
    <title>基于伯克利cs61a的python笔记</title>
    <link href="https://thinklive1.github.io/2023/09/29/61a%E6%80%BB%E5%92%8C/"/>
    <id>https://thinklive1.github.io/2023/09/29/61a%E6%80%BB%E5%92%8C/</id>
    <published>2023-09-29T02:18:45.993Z</published>
    <updated>2023-11-27T12:47:59.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python语言特性">python语言特性</h2><h3 id="函数">函数</h3><p>名称也可以与函数绑定。例如，名称 <code>max</code> 就和我们之前使用的 <code>max</code> 函数进行了绑定。与数字不同，函数很难以文本呈现，因此当询问一个函数时，Python 会打印一个标识来描述： <span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max</span><br><span class="line">&lt;built-in function max&gt;</span><br></pre></td></tr></table></figure></p><p>赋值语句可以为现有函数赋予新名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = max</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;built-in function max&gt;</span><br><span class="line">&gt;&gt;&gt; f(2, 3, 4)</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>以下指南改编自 <a href="http://www.python.org/dev/peps/pep-0008">Python 代码风格指南</a>, 它可以作为所有（非叛逆的）Python 程序员的指南。这些共享的约定使开发者社区的成员之间的沟通能够顺利进行。作为遵循这些约定的副作用，你会发现你的代码在内部变得更加一致。</p><ol type="1"><li>函数名是小写的，单词之间用下划线分隔。鼓励使用描述性名称。</li><li>函数名称通常反映解释器应用于参数的操作（例如， <code>print, add, square</code> ）或结果（例如， <code>max, abs, sum</code> ）。</li><li>参数名称是小写的，单词之间用下划线分隔。首选单个词的名称。</li><li>参数名称应该反映参数在函数中的作用，而不仅仅是允许的参数类型。</li><li>当作用明确时，单字参数名称可以接受，但应避免使用 l（小写的 L）和 O（大写的 o）或 I（大写的 i）以避免与数字混淆。</li></ol><h3 id="函数设计原则">函数设计原则</h3><ul><li>每个函数应该只负责一个任务，且该任务要用一个简短的名称来识别，并在一行文本中进行描述。按顺序执行多个任务的函数应该分为多个函数。</li><li>不要重复自己（Don't repeat yourself）是软件工程的核心原则。这个所谓的 DRY 原则指出，多个代码片段不应该描述重复的逻辑。相反，逻辑应该只实现一次，为其指定一个名称后多次使用。如果你发现自己正在复制粘贴一段代码，那么你可能已经找到了进行函数抽象的机会。</li><li>定义通用的函数。比如作为 <code>pow</code> 函数的一个特例的平方函数就不在 Python 库中，因为 <code>pow</code> 函数可以将数字计算为任意次方。 当你使用函数名称作为参数调用 <code>help</code> 时，你会看到它的文档字符串（键入 q 以退出 Python help）。 Python 中的注释可以附加到 <code>#</code> 号后的行尾。例如，上面代码中的注释 <code>玻尔兹曼常数</code> 描述了 <code>k</code> 变量的含义。这些注释不会出现在 Python 的 <code>help</code> 中，而且会被解释器忽略，它们只为人类而存在。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; help(pressure)</span><br></pre></td></tr></table></figure><h2 id="数据结构">数据结构</h2><h3 id="链表">链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Link:</span><br><span class="line">        &quot;&quot;&quot;A linked list with a first element and the rest.&quot;&quot;&quot;</span><br><span class="line">        empty = ()</span><br><span class="line">        def __init__(self, first, rest=empty):</span><br><span class="line">            assert rest is Link.empty or isinstance(rest, Link)</span><br><span class="line">            self.first = first</span><br><span class="line">            self.rest = rest</span><br><span class="line">        def __getitem__(self, i):</span><br><span class="line">            if i == 0:</span><br><span class="line">                return self.first</span><br><span class="line">            else:</span><br><span class="line">                return self.rest[i-1]</span><br><span class="line">        def __len__(self):</span><br><span class="line">            return 1 + len(self.rest)</span><br></pre></td></tr></table></figure><h3 id="抽象障碍">抽象障碍</h3><p>每当程序的一部分可以使用更高级别的函数而不是使用较低级别的函数时，就会违反抽象障碍。例如，计算有理数平方的函数最好用 <code>mul_rational</code> 实现，它不对有理数的实现做任何假设。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square_rational(x):</span><br><span class="line">        return mul_rational(x, x)</span><br></pre></td></tr></table></figure><h3 id="序列">序列</h3><p>范围通常出现在 for 语句 header 中的表达式，以指定 <code>&lt;suite&gt;</code> 应执行的次数。如果 <code>&lt;name&gt;</code> 没有被用在 <code>&lt;suite&gt;</code>，一个惯用的使用方式是，使用下划线表示 <code>&lt;name&gt;</code>。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for _ in range(3):</span><br><span class="line">        print(&#x27;Go Bears!&#x27;)</span><br><span class="line"></span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br><span class="line">Go Bears!</span><br></pre></td></tr></table></figure><p>对解释器而言，下划线只是环境中的另一个名称，但对程序员具有约定俗成的含义，表示该名称不会出现在任何未来的表达式中。 列表推导式的一般形式是：</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;</span><br></pre></td></tr></table></figure><p>为了运算列表推导式，Python 首先评估 <code>&lt;sequence expression&gt;</code>，它必须返回一个 iterable 值。然后，每个元素依次绑定到 <code>&lt;name&gt;</code>，再运算 <code>&lt;filter expression&gt;</code>；如果产生一个真值，运算 <code>&lt;map expression&gt;</code>。最后 <code>&lt;map expression&gt;</code> 的值被收集到一个列表中</p><p><code>reduce</code> 可用于将序列的所有元素相乘。使用 <code>mul</code> 作为 <code>reduce_fn</code>， 1 作为 <code>initial</code> 值， <code>reduce</code> 可用于将各数字相乘。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(mul, [2, 4, 8], 1)</span><br><span class="line">64</span><br></pre></td></tr></table></figure><p><strong>多行文字 (Multiline Literals)</strong>。字符串不限于一行。跨越多行的字符串文字可以用三重引号括起。我们已经在文档字符串中广泛使用了这种三重引号。</p><h3 id="迭代器">迭代器</h3><p>迭代器的用处源自以下事实： 迭代器的一系列数据可能不会在内存中显式表示。 迭代器提供了一种考虑一系列值中的每一个的机制 轮，但所有这些元素不需要同时存储。 相反，当迭代器请求下一个元素时，该元素可能会 按需计算，而不是从现有内存中检索 来源。</p><p>范围能够惰性地计算序列的元素，因为 表示的序列是统一的，并且任何元素都很容易从 范围的开始和结束边界。 迭代器允许延迟生成 更广泛的底层序列数据集类别，因为它们不需要 提供对底层系列的任意元素的访问。 反而， 迭代器只需要按顺序计算该系列的下一个元素， 每次请求另一个元素时。 虽然不像访问那样灵活 序列的任意元素（称为 <em>随机访问</em> ）、 <em>顺序访问</em> 顺序数据通常足以满足数据处理应用程序的需要。 函数 map 是惰性的：调用它并不执行计算 需要计算其结果的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def double_and_print(x):</span><br><span class="line">        print(&#x27;***&#x27;, x, &#x27;=&gt;&#x27;, 2*x, &#x27;***&#x27;)</span><br><span class="line">        return 2*x</span><br><span class="line">&gt;&gt;&gt; s = range(3, 7)</span><br><span class="line">&gt;&gt;&gt; doubled = map(double_and_print, s)  # double_and_print not yet called</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called once</span><br><span class="line">*** 3 =&gt; 6 ***</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; next(doubled)                       # double_and_print called again</span><br><span class="line">*** 4 =&gt; 8 ***</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; list(doubled)                       # double_and_print called twice more</span><br><span class="line">*** 5 =&gt; 10 ***</span><br><span class="line">*** 6 =&gt; 12 ***</span><br><span class="line">[10, 12]</span><br></pre></td></tr></table></figure><h2 id="迭代器-1">迭代器</h2><p>可迭代的 Letters 实例 b_to_k 和 LetterIter 迭代器 实例 first_iterator 和 second_iterator的 不同之处在于 字母 实例不会改变，而迭代器实例会改变 每次调用 next （或等效地，每次调用 <strong>next</strong> ）。 迭代器通过顺序数据跟踪进度，而可迭代器 代表数据本身。</p><p>Python 中的许多内置函数都采用可迭代参数并返回迭代器。 函数 map 例如， 接受一个函数和一个可迭代对象。 它返回 将函数参数应用于每个元素的结果的迭代器 在可迭代的参数中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;  caps   =   map  (  lambda   x  :   x  .  upper  (),   b_to_k ) </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;B&#x27; </span><br><span class="line"> &gt;&gt;&gt; next  (  caps ) </span><br><span class="line"> &#x27;C&#x27;</span><br></pre></td></tr></table></figure><h2 id="生成器">生成器</h2><p>生成器函数是生成值而不是返回值的函数 普通函数返回一次； 一个生成器函数可以产生多次 生成器是通过调用生成器函数自动创建的迭代器 当调用生成器函数时，它返回一个迭代其产量的生成器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def plus_minus(x):</span><br><span class="line">... yield x</span><br><span class="line">... yield -x</span><br><span class="line">&gt;&gt;&gt; t = plus_minus(3)</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">-3</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">&lt;generator object plus_minus ...&gt;</span><br></pre></td></tr></table></figure><h2 id="高阶函数">高阶函数</h2><h3 id="嵌套定义">嵌套定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sqrt(a):</span><br><span class="line">        def sqrt_update(x):</span><br><span class="line">            return average(x, a/x)</span><br><span class="line">        def sqrt_close(x):</span><br><span class="line">            return approx_eq(x * x, a)</span><br><span class="line">        return improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></table></figure><p>与局部赋值一样，局部 <code>def</code> 语句只影响当前局部帧。这些函数仅在求解 <code>sqrt</code> 时在作用域内。与求解过程一致，这些局部 <code>def</code> 语句在调用 <code>sqrt</code> 之前都不会被求解。</p><p>词法作用域（Lexical scope）：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， <code>sqrt_update</code> 引用名称 <code>a</code>，它是其封闭函数 <code>sqrt</code> 的形式参数。这种在嵌套定义之间共享名称的规则称为词法作用域。最重要的是，内部函数可以访问定义它们的环境中的名称（而不是它们被调用的位置）。</p><p>我们需要对我们的环境模型实现两个扩展来启用词法作用域。</p><ol type="1"><li>每个用户定义的函数都有一个父环境：定义它的环境。</li><li>调用用户定义的函数时，其局部帧会继承其父环境。 Python 中词法作用域的两个关键优势。</li></ol><ul><li>局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。</li><li>局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。</li></ul><h3 id="lambda">lambda</h3><p>不像 定义 语句、lambda 表达式可以用作运算符或 调用表达式的操作数。 这是因为它们只是一行 计算结果为函数的表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; what = lambda x : x + 5</span><br><span class="line">&gt;&gt;&gt; what</span><br><span class="line">&lt;function &lt;lambda&gt; at 0xf3f490&gt;</span><br><span class="line">&gt;&gt;&gt; (lambda y: y + 5)(4)</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="类">类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Account:</span><br><span class="line">     def __init__(self, account_holder):</span><br><span class="line">            self.balance = 0</span><br><span class="line">            self.holder = account_holder</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>内置函数 <code>getattr</code> 还按名称返回对象的属性。它是点表示法的函数等效物。使用 <code>getattr</code> ，我们可以使用字符串查找属性，就像我们对调度字典所做的那样。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(spock_account, &#x27;balance&#x27;)</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>我们还可以测试应该对象是否具有 <code>hassattr</code> 的名命属性。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(spock_account, &#x27;deposit&#x27;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>我们可以通过对点表达式的返回值调用 <code>type</code> 来查看交互式解释器的差异。作为类的属性，方法只是一个函数，但作为实例的属性，它是一个绑定方法：</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(Account.deposit)</span><br><span class="line">&lt;class &#x27;Function&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(spock_account.deposit)</span><br><span class="line">&lt;class &#x27;method&#x27;&gt;</span><br></pre></td></tr></table></figure><p>这两个结果的区别仅在于第一个是参数为 <code>self</code> 和 <code>amount</code> 的标准双参数函数。第二种是单参数方法，调用方法时，名称 <code>self</code> 将自动绑定到名为 <code>spock_account</code> 的对象，而参数 <code>amount</code> 将绑定到传递给方法的参数。这两个值（无论是函数值还是绑定方法值）都与相同的 <code>deposit</code> 函数体相关联。 在某些情况下，有一些实例变量和方法与对象的维护和一致性相关，我们不希望对象的用户看到或使用。它们不是类定义的抽象的一部分，而是实现的一部分。Python 的约定规定，如果属性名称以下划线开头，则只能在类本身的方法中访问它，而不是用户访问。</p><p>计算点表达式：</p><ol type="1"><li>点表达式左侧的 <code>&lt;expression&gt;</code> ，生成点表达式的对象。</li><li><code>&lt;name&gt;</code> 与该对象的实例属性匹配；如果存在具有该名称的属性，则返回属性值。</li><li>如果实例属性中没有 <code>&lt;name&gt;</code> ，则在类中查找 <code>&lt;name&gt;</code>，生成类属性。</li><li>除非它是函数，否则返回属性值。如果是函数，则返回该名称绑定的方法。</li></ol><h2 id="约束传递-propagating-constraints">约束传递 (Propagating Constraints)</h2><p>可变数据允许我们模拟具有变化的系统，也允许我们构建新的抽象类型。在这个扩展示例中，我们结合了非局部赋值、列表和字典来构建一个支持多方向计算的基于约束系统。将程序表示为约束是一种声明式编程，在这种编程中，程序员声明要解决的问题的结构，而不是抽象出问题解决方案的具体计算方式的细节。</p><p>计算机程序传统上被组织为单向计算，它对预先指定的参数执行操作以产生所需的输出。另一方面，我们通常希望根据数量之间的关系对系统进行建模。例如，我们之前考虑过理想气体定律，它通过玻尔兹曼常数 (k) 将理想气体的压力 (p)、体积 (v)、数量 (n) 和温度 (t) 联系起来：</p><p><code>p * v = n * k * t</code></p><p>这样的方程不是单向的。给定任何四个量，我们可以使用这个方程来计算第五个。然而，将方程式翻译成传统的计算机语言会迫使我们选择一个量来根据其他四个量进行计算。因此，计算压力的函数不能用于计算温度，即使这两个量的计算来自同一个方程。</p><p>在本节中，我们概述了线性关系的一般模型的设计。我们定义了在数量之间保持的原始约束，例如强制数学关系 a + b = c 的 adder(a, b, c) 约束。</p><p>我们还定义了一种组合方式，以便可以组合原始约束来表达更复杂的关系。这样，我们的程序就类似于一种编程语言。我们通过构建一个网络来组合约束，在该网络中约束由连接器 (connector) 连接。连接器是一个对象，它“持有”一个值并且可以参与一个或多个约束。</p><p>例如，我们知道华氏温度和摄氏温度之间的关系是：</p><p><code>9 * c = 5 * (f - 32)</code></p><p>该等式是 c 和 f 之间的复杂约束。这样的约束可以被认为是一个由原始加法器 (adder) 、乘法器 (multiplier) 和常量 (constant) 约束组成的网络。</p><figure><img src="https://composingprograms.netlify.app/sicp/celsius_fahrenheit_constraint.png" alt="" /><figcaption>celsius_fahrenheit_constraint</figcaption></figure><p>在此图中，我们在左侧看到一个乘数框，其中包含三个端子，标记为 a 、b 和 c。这些将乘数连接到网络的其余部分，如下所示：终端连接到连接器 celsius，该连接器将保持摄氏温度。b 端子连接到连接器 w，该连接器链接到常量 9。乘数盒约束为 a 和 b 乘积的 c 端链接到另一个乘法盒的 c 端，其 b 连接到常量 5，其 a 连接到和约束中的项之一。</p><p>这种网络的计算过程如下：当一个连接器被赋予一个值时（由用户或由它链接到的约束框），它会唤醒所有相关的约束（除了刚刚唤醒它的约束） 以告诉他们它有值。每个被唤醒的约束框之后轮流询问其连接器，以查看是否有足够的信息来确定连接器的值。如果有，该框设置该连接器，然后唤醒所有关联的约束，依此类推。例如，在摄氏度和华氏度之间的转换中， w、 x 和 y 立即被常量框分别设置为 9、 5 和 32。连接器唤醒乘法器和加法器，它们确定没有足够的信息继续进行。如果用户（或网络的其他部分）将摄氏连接器设置为一个值（比如 25），最左边的乘法器将被唤醒，它将 u 设置为 25 * 9 = 225。然后你唤醒第二个乘法器，将 v 设置为 45，v 唤醒加法器，将 fahrenheit 连接器设置为 77。</p><p><strong>使用约束系统 (Using the Constraint System)</strong>。要使用约束系统执行上述温度计算，我们首先通过调用连接器构造函数创建两个命名连接器，摄氏度 celsius 和华氏度 fahrenheit。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius = connector(&#x27;Celsius&#x27;)</span><br><span class="line">&gt;&gt;&gt; fahrenheit = connector(&#x27;Fahrenheit&#x27;)</span><br></pre></td></tr></table></figure><p>然后，我们将这些连接器链接到一个反映上图的网络中。函数转换器 (converter) 组装网络中的各种连接器和约束。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def converter(c, f):</span><br><span class="line">        &quot;&quot;&quot;用约束条件连接 c 到 f ，将摄氏度转换为华氏度.&quot;&quot;&quot;</span><br><span class="line">        u, v, w, x, y = [connector() for _ in range(5)]</span><br><span class="line">        multiplier(c, w, u)</span><br><span class="line">        multiplier(v, x, u)</span><br><span class="line">        adder(v, y, f)</span><br><span class="line">        constant(w, 9)</span><br><span class="line">        constant(x, 5)</span><br><span class="line">        constant(y, 32)</span><br></pre></td></tr></table></figure><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; converter(celsius, fahrenheit)</span><br></pre></td></tr></table></figure><p>我们将使用消息传递系统来协调约束和连接器。约束是不包含局部状态本身的字典。它们对消息的响应是非纯函数，会更改它们约束的连接器。</p><p>连接器是保存当前值并响应操纵该值的消息的字典。约束不会直接更改连接器的值，而是通过发送消息来更改，以便连接器可以通知其他约束以响应更改。这样，一个连接器既代表了一个数字，同时也封装了连接器的行为。</p><p>我们可以发送给连接器的一条消息是设置它的值。在这里，我们（ “ user ” ）将 celsius 的值设置为 25。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;set_val&#x27;](&#x27;user&#x27;, 25)</span><br><span class="line">Celsius = 25</span><br><span class="line">Fahrenheit = 77.0</span><br></pre></td></tr></table></figure><p>不仅 celsius 的值变为 25，而且它的值通过网络传播，因此 fahrenheit 的值也发生变化。打印这些更改是因为我们在构造它们时命名了这两个连接器。</p><p>现在我们可以尝试将 fahrenheit 度设置为一个新值，比如 212。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Contradiction detected: 77.0 vs 212</span><br></pre></td></tr></table></figure><p>连接器抱怨说它感觉到了一个矛盾：它的值为 77.0，而有人试图将它设置为 212。如果我们真的想用新值应用到网络，我们可以告诉 celsius 忘记它的旧值：</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; celsius[&#x27;forget&#x27;](&#x27;user&#x27;)</span><br><span class="line">Celsius is forgotten</span><br><span class="line">Fahrenheit is forgotten</span><br></pre></td></tr></table></figure><p>连接器 celsius 发现最初设置其值的用户现在收回该值，因此 celsius 同意失去其值，并将这一事实通知网络的其余部分。这个信息最终传播到 fahrenheit，它现在发现它没有理由继续相信它自己的值是 77。因此，它也放弃了它的值。</p><p>现在 fahrenheit 没有值，我们可以将其设置为 212：</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fahrenheit[&#x27;set_val&#x27;](&#x27;user&#x27;, 212)</span><br><span class="line">Fahrenheit = 212</span><br><span class="line">Celsius = 100.0</span><br></pre></td></tr></table></figure><p>这个新值在通过网络传播时会迫使 celsius 的值变为 100。我们使用了完全相同的网络来计算给定 celsius 的 fahrenheit 和给定 fahrenheit 的 celsius。这种计算的非方向性是基于约束的系统的显着特征。</p><p><strong>实施约束系统 (Implementing the Constraint System)</strong>。正如我们所见，连接器是将消息名称映射到函数和数据值的字典。我们将实施响应以下消息的连接器：</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; connector [&#x27;set_val&#x27;](source, value)  &quot;&quot;&quot;表示 source 在请求连接器将当前值设为 value&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;has_val&#x27;]()  &quot;&quot;&quot;返回连接器是否已经具有值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;val&#x27;]  &quot;&quot;&quot;是连接器的当前值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;forget&#x27;](source)  &quot;&quot;&quot;告诉连接器 source 请求遗忘它的值&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; connector [&#x27;connect&#x27;](source)  &quot;&quot;&quot;告诉连接器参与新的约束，即 source&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>约束也是字典，它通过两条消息从连接器接收信息：</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; constraint[\&#x27;new_val&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器具有新的值。&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; constraint[\&#x27;forget&#x27;]()  &quot;&quot;&quot;表示与约束相连的某个连接器遗忘了值。&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>当约束收到这些消息时，它们会将消息传播到其他连接器。</p><p>adder 函数在三个连接器上构造一个加法器约束，其中前两个必须与第三个相加：a + b = c。为了支持多向约束传播，加法器还必须指定它从 c 中减去 a 得到 b，同样地从 c 中减去 b 得到 a。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import add, sub</span><br><span class="line">&gt;&gt;&gt; def adder(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a+b=c&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, add, sub, sub)</span><br></pre></td></tr></table></figure><p>我们想实现一个通用的三元（三向）约束，它使用来自 adder 的三个连接器和三个函数来创建一个接受 new_val 和 forget 消息的约束。对消息的响应是局部函数，它们被放置在称为约束的字典中。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_ternary_constraint(a, b, c, ab, ca, cb):</span><br><span class="line">        &quot;&quot;&quot;约束ab(a,b)=c，ca(c,a)=b，cb(c,b)=a。&quot;&quot;&quot;</span><br><span class="line">        def new_value():</span><br><span class="line">            av, bv, cv = [connector[&#x27;has_val&#x27;]() for connector in (a, b, c)]</span><br><span class="line">            if av and bv:</span><br><span class="line">                c[&#x27;set_val&#x27;](constraint, ab(a[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">            elif av and cv:</span><br><span class="line">                b[&#x27;set_val&#x27;](constraint, ca(c[&#x27;val&#x27;], a[&#x27;val&#x27;]))</span><br><span class="line">            elif bv and cv:</span><br><span class="line">                a[&#x27;set_val&#x27;](constraint, cb(c[&#x27;val&#x27;], b[&#x27;val&#x27;]))</span><br><span class="line">        def forget_value():</span><br><span class="line">            for connector in (a, b, c):</span><br><span class="line">                connector[&#x27;forget&#x27;](constraint)</span><br><span class="line">        constraint = &#123;&#x27;new_val&#x27;: new_value, &#x27;forget&#x27;: forget_value&#125;</span><br><span class="line">        for connector in (a, b, c):</span><br><span class="line">            connector[&#x27;connect&#x27;](constraint)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure><p>称为约束的字典是一个调度字典，也是约束对象本身。它响应约束接收到的两条消息，但也作为调用其连接器的 source 参数传递。</p><p>每当约束被告知其连接器之一具有值时，就会调用约束的局部函数 new_value。该函数首先检查 a 和 b 是否都有值。如果是，它告诉 c 将其值设置为函数 ab 的返回值，在加法器的情况下为 add。约束将自身（约束）作为连接器的 source 参数传递，该连接器是加法器对象。如果 a 和 b 不同时都有值，则约束检查 a 和 c，依此类推。</p><p>如果约束被告知它的一个连接器遗忘了它的值，它会请求它的所有连接器遗忘它们的值。（实际上只有那些由此约束设置的值会丢失。）</p><p>乘法器与加法器非常相似。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import mul, truediv</span><br><span class="line">&gt;&gt;&gt; def multiplier(a, b, c):</span><br><span class="line">        &quot;&quot;&quot;约束a*b=c.&quot;&quot;&quot;</span><br><span class="line">        return make_ternary_constraint(a, b, c, mul, truediv, truediv)</span><br></pre></td></tr></table></figure><p>常量也是一种约束，但它永远不会发送任何消息，因为它只涉及它在构造时设置的单个连接器。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def constant(connector, value):</span><br><span class="line">        &quot;&quot;&quot;常量赋值.&quot;&quot;&quot;</span><br><span class="line">        constraint = &#123;&#125;</span><br><span class="line">        connector[&#x27;set_val&#x27;](constraint, value)</span><br><span class="line">        return constraint</span><br></pre></td></tr></table></figure><p>这三个约束足以实现我们的温度转换网络。</p><p><strong>连接器表示 (Representing connectors)</strong>。连接器表示为包含值的字典，也有具备局部状态的响应函数。连接器必须跟踪为其提供当前值的信息提供者，以及它参与的约束列表。</p><p>构造函数连接器具有用于设置和遗忘值的局部函数，这些值是对来自约束的消息的响应。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def connector(name=None):</span><br><span class="line">        &quot;&quot;&quot;限制条件之间的连接器.&quot;&quot;&quot;</span><br><span class="line">        informant = None</span><br><span class="line">        constraints = []</span><br><span class="line">        def set_value(source, value):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            val = connector[&#x27;val&#x27;]</span><br><span class="line">            if val is None:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = source, value</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;=&#x27;, value)</span><br><span class="line">                inform_all_except(source, &#x27;new_val&#x27;, constraints)</span><br><span class="line">            else:</span><br><span class="line">                if val != value:</span><br><span class="line">                    print(&#x27;Contradiction detected:&#x27;, val, &#x27;vs&#x27;, value)</span><br><span class="line">        def forget_value(source):</span><br><span class="line">            nonlocal informant</span><br><span class="line">            if informant == source:</span><br><span class="line">                informant, connector[&#x27;val&#x27;] = None, None</span><br><span class="line">                if name is not None:</span><br><span class="line">                    print(name, &#x27;is forgotten&#x27;)</span><br><span class="line">                inform_all_except(source, &#x27;forget&#x27;, constraints)</span><br><span class="line">        connector = &#123;&#x27;val&#x27;: None,</span><br><span class="line">                     &#x27;set_val&#x27;: set_value,</span><br><span class="line">                     &#x27;forget&#x27;: forget_value,</span><br><span class="line">                     &#x27;has_val&#x27;: lambda: connector[&#x27;val&#x27;] is not None,</span><br><span class="line">                     &#x27;connect&#x27;: lambda source: constraints.append(source)&#125;</span><br><span class="line">        return connector</span><br></pre></td></tr></table></figure><p>连接器也是约束用于与连接器通信的五个消息的调度字典。四个响应是函数，最后的响应是值本身。</p><p>当有设置连接器值的请求时调用局部函数 set_value。如果连接器当前没有值，它将设置它的值并记住请求设置值的源约束作为信息提供者。然后连接器将通知它的所有参与约束，除了请求设置值的约束。这是使用以下迭代函数完成的。</p><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def inform_all_except(source, message, constraints):</span><br><span class="line">        &quot;&quot;&quot;告知信息除了source外的所有约束条件，。&quot;&quot;&quot;</span><br><span class="line">        for c in constraints:</span><br><span class="line">            if c != source:</span><br><span class="line">                c[message]()</span><br></pre></td></tr></table></figure><p>如果要求连接器遗忘其值，它会调用局部函数 forget-value，该函数首先检查以确保请求来自与最初设置值相同的约束。如果是这样，连接器会通知其关联的约束有关值的丢失。</p><p>对消息 has_val 的响应表明连接器是否有值。 对消息连接的响应将源约束添加到约束列表中。</p><p>我们设计的约束程序引入了许多将在面向对象编程中再次出现的思想。约束和连接器都是通过消息操作的抽象。当连接器的值发生变化时，它会通过一条消息进行更改，该消息不仅会更改值，还会验证它（检查源）并传播其效果（通知其他约束）。事实上，我们将在本章后面使用具有字符串值键和函数值的字典的类似架构来实现面向对象的系统</p><h2 id="debug">debug</h2><p>请注意，回溯中的行似乎是配对在一起的。 该对中的第一行具有以下格式： 文件“<文件名>”，第 <编号> 行，<函数></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File &quot;&lt;file name&gt;&quot;, line &lt;number&gt;, in &lt;function&gt;</span><br></pre></td></tr></table></figure><p>该行为您提供以下信息： 文件名：包含问题的文件的名称。 Number：文件中引起问题的行号，或包含下一个函数调用的行号 函数：可以在其中找到该行的函数的名称。 回溯消息中的最后一行是错误语句。 错误语句具有以下格式： <错误类型>：<错误消息> 这一行为您提供了两条信息： 错误类型：引起的错误类型（例如SyntaxError，TypeError）。 这些通常具有足够的描述性，可以帮助您缩小错误原因的搜索范围。 错误消息：更详细地描述导致错误的原因。 不同的错误类型会产生不同的错误消息。</p><h2 id="running-doctests">Running doctests</h2><p>Python has a great way to quickly write tests for your code. These are called doctests, and look like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    &quot;&quot;&quot;A random function.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; foo(4)</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; foo(5)</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>The lines in the docstring that look like interpreter outputs are the <strong>doctests</strong>. To run them, go to your terminal and type:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest file.py</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m doctest file.py -v</span><br><span class="line">除了告诉你哪些文档测试失败之外，它还会 告诉您哪些文档测试通过了。</span><br></pre></td></tr></table></figure><p>许多程序员喜欢研究他们的代码的一种方法是使用交互式 REPL。 也就是说，您可以在其中直接运行函数并检查其输出的终端。 通常，要完成此操作，您可以运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -i file.py</span><br></pre></td></tr></table></figure><h3 id="使用-assert声明">使用 <code>assert</code>声明</h3><p>Python 有一个特性称为 <code>assert</code>语句，它可以让您测试条件是否为真，并打印错误 否则在一行中消息。 如果您知道某些条件在某些点需要为真，这会很有用 在你的程序中。 例如，如果您正在编写一个接受整数并将其加倍的函数，那么它可能会很有用 确保您的输入实际上是一个整数。 然后你可以编写以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def double(x):</span><br><span class="line">    assert isinstance(x, int), &quot;The input to double(x) must be an integer&quot;</span><br><span class="line">    return 2 * x</span><br></pre></td></tr></table></figure><p>请注意，我们并没有真正调试 <code>double</code>在这里，我们正在做的是确保任何拨打电话的人 <code>double</code>正在以正确的论点这样做。 例如，如果我们有一个函数 <code>g</code>接受一个字符串和一个数字 并将字符串的长度添加到数字的两倍，其实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def g(x, y):</span><br><span class="line">    return double(x) + y # should be double(y) + len(x)</span><br></pre></td></tr></table></figure><h3 id="syntaxerror"><code>SyntaxError</code></h3><ul><li><p><strong>原因</strong> ：代码语法错误</p></li><li><p><strong>示例</strong> ：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    def incorrect(f)</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></p></li><li><p><strong>解决办法</strong> ： <code>^</code>符号指向包含的代码 无效的语法。 错误消息没有告诉你 <em>什么</em> 是 错了，但它确实告诉你 <em>在哪里</em> 。</p></li><li><p><strong>注意</strong> ：Python 将检查 <code>SyntaxErrors</code>执行之前 任何代码。 这与其他错误不同，其他错误仅 在运行时引发。</p></li></ul><h3 id="indentationerror"><code>IndentationError</code></h3><ul><li><p><strong>原因</strong> ：缩进不当</p></li><li><p><strong>示例</strong> ：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  File &quot;file name&quot;, line number</span><br><span class="line">    print(&#x27;improper indentation&#x27;)</span><br><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure></p></li><li><p><strong>解决方案</strong> ：显示缩进不正确的行。 只需重新缩进即可。</p></li><li><p><strong>注意</strong> ：如果制表符和空格不一致，Python 将提出其中之一。 确保使用空格！ （只是少了点 在 Python 中使用空格和所有 cs61a 内容通常令人头痛 使用空格）。</p></li></ul><h3 id="typeerror"><code>TypeError</code></h3><ul><li><p><strong>原因一</strong> ：</p><ul><li><p>原始运算符的操作数类型无效。 你是 可能尝试加/减/乘/除不兼容 类型。</p></li><li><p><strong>示例</strong> ：</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: unsupported operand type(s) for +: &#x27;function&#x27; and &#x27;int&#x27;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><strong>原因2</strong> ：</p><ul><li><p>在函数调用中使用非函数对象。</p></li><li><p><strong>示例</strong> ：</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; square = 3</span><br><span class="line">&gt;&gt;&gt; square(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &#x27;int&#x27; object is not callable</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><strong>原因3</strong> ：</p><ul><li><p>向函数传递错误数量的参数。</p></li><li><p><strong>示例</strong> ：</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: add expected 2 arguments, got 1</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="nameerror"><code>NameError</code></h3><ul><li><p><strong>原因</strong> ：变量没有分配给任何东西或者没有分配 存在。 这包括函数名称。</p></li><li><p><strong>示例</strong> ：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  y = x + 3</span><br><span class="line">NameError: global name &#x27;x&#x27; is not defined</span><br></pre></td></tr></table></figure></p></li><li><p><strong>解决方案</strong> ：确保您正在初始化变量（即 在使用之前为变量分配一个值）。</p></li><li><p><strong>注意</strong> ：错误消息显示“全局名称”的原因是 因为Python将从a开始搜索变量 函数的本地框架。 如果在那里找不到该变量， Python将继续搜索父框架，直到到达 全球框架。 如果仍然找不到变量，Python 引发错误。</p></li></ul><h3 id="indexerror"><code>IndexError</code></h3><ul><li><p><strong>原因</strong> ：尝试索引序列（例如元组、列表、 string）的数字超过了序列的大小。</p></li><li><p><strong>示例</strong> ：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File &quot;file name&quot;, line number</span><br><span class="line">  x[100]</span><br><span class="line">IndexError: tuple index out of range</span><br></pre></td></tr></table></figure></p></li><li><p><strong>解决方案</strong> ：确保索引在范围内 顺序。 如果您使用变量作为索引（例如 <code>seq[x]</code>, 确保变量被分配给正确的索引。</p></li></ul><h2 id="object">object</h2><p>因为两个列表可能内容相同，但实际上是不同的列表，所以我们需要一种方法来测试两个对象是否是同一个。Python 包括两个比较运算符，称为 is 和 is not，它们测试两个表达式实际上是否计算为相同的对象。如果两个对象的当前值相等，则它们是相同的，并且对一个对象的任何更改都将始终反映在另一个对象中。身份是比相等更强大的条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suits is [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; suits == [&#x27;heart&#x27;, &#x27;diamond&#x27;, &#x27;spade&#x27;, &#x27;club&#x27;]</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>字典也确实有一些限制：</p><ul><li>字典的键不能是或包含可变值。</li><li>对于给定的键，最多只能有一个对应的值。 非局部语句 (nonlocal statement)。当我们调用 make_withdraw 时，我们将 balance 绑定到初始金额。然后我们定义并返回一个局部函数 withdraw，它会在调用时更新并返回 balance 的值。</li></ul><p>python</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_withdraw(balance):</span><br><span class="line">        &quot;&quot;&quot;返回一个每次调用都会减少余额的 withdraw 函数&quot;&quot;&quot;</span><br><span class="line">        def withdraw(amount):</span><br><span class="line">            nonlocal balance                 # 声明 balance 是非局部的</span><br><span class="line">            if amount &gt; balance:</span><br><span class="line">                return &#x27;Insufficient funds&#x27;</span><br><span class="line">            balance = balance - amount       # 重新绑定</span><br><span class="line">            return balance</span><br><span class="line">        return withdraw</span><br></pre></td></tr></table></figure><p>非局部语句声明：每当我们更改 balance 的绑定时，绑定关系都会在已经绑定 balance 的第一帧中更改。回想一下，如果没有非局部语句，赋值语句将始终在当前环境的第一帧中绑定。非局部语句指示名称不会出现在第一个（局部）帧或最后一个（全局）帧，而是其他地方。</p><h2 id="错题集">错题集</h2><h3 id="递增子序列">递增子序列</h3><figure class="highlight plaintext"><figcaption><span>inc_subseqs(s):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Assuming that S is a list, return a nested list of all subsequences</span><br><span class="line"></span><br><span class="line">    of S (a list of lists) for which the elements of the subsequence</span><br><span class="line"></span><br><span class="line">    are strictly nondecreasing. The subsequences can appear in any order.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs = inc_subseqs([1, 3, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1, 2], [1, 3], [2], [3]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; inc_subseqs([])</span><br><span class="line"></span><br><span class="line">    [[]]</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; seqs2 = inc_subseqs([1, 1, 2])</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; sorted(seqs2)</span><br><span class="line"></span><br><span class="line">    [[], [1], [1], [1, 1], [1, 1, 2], [1, 2], [1, 2], [2]]</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def subseq_helper(s, prev):</span><br><span class="line"></span><br><span class="line">        if not s:</span><br><span class="line"></span><br><span class="line">            return [[]]</span><br><span class="line"></span><br><span class="line">        elif s[0] &lt; prev:</span><br><span class="line"></span><br><span class="line">            return subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            a = subseq_helper(s[1::],s[0])</span><br><span class="line"></span><br><span class="line">            b = subseq_helper(s[1::],prev)</span><br><span class="line"></span><br><span class="line">            return insert_into_all(s[0], a) + b</span><br><span class="line"></span><br><span class="line">    return subseq_helper(s,0)</span><br><span class="line"></span><br><span class="line">seqs = inc_subseqs([1, 3, 2])</span><br></pre></td></tr></table></figure><h3 id="反转奇数深度树的标签">反转奇数深度树的标签</h3><figure class="highlight plaintext"><figcaption><span>t.is_leaf():</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">        return </span><br><span class="line">    label_list = []</span><br><span class="line">    for b in t.branches:</span><br><span class="line">        label_list.append(b.label)</span><br><span class="line">    for b, new_label in zip(t.branches, reversed(label_list)):</span><br><span class="line">        b.label = new_label</span><br><span class="line">        for bb in b.branches:</span><br><span class="line">            reverse_other(bb)</span><br><span class="line"></span><br><span class="line">我的解法：</span><br><span class="line">def helper(t,depth):</span><br><span class="line"></span><br><span class="line">        if depth%2==0:</span><br><span class="line"></span><br><span class="line">            if t.is_leaf():</span><br><span class="line"></span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            else:</span><br><span class="line"></span><br><span class="line">                for branch in t.branches:</span><br><span class="line"></span><br><span class="line">                    helper(branch,depth+1)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line"></span><br><span class="line">            labels=[]</span><br><span class="line"></span><br><span class="line">            brans=t.branches</span><br><span class="line"></span><br><span class="line">            for branch in brans:</span><br><span class="line"></span><br><span class="line">                labels.insert(0,branch.label)</span><br><span class="line"></span><br><span class="line">            for new_label,new_branch in zip(labels,brans):</span><br><span class="line"></span><br><span class="line">                new_branch.label=new_label</span><br><span class="line"></span><br><span class="line">            for bran in brans:</span><br><span class="line"></span><br><span class="line">                helper(bran,depth+1)</span><br><span class="line"></span><br><span class="line">    helper(t,1)</span><br></pre></td></tr></table></figure><h3 id="生成器的生成器">生成器的生成器</h3><figure class="highlight plaintext"><figcaption><span>make_generators_generator(g):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Generates all the &quot;sub&quot;-generators of the generator returned by</span><br><span class="line"></span><br><span class="line">    the generator function g.</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_m_ints_to(n, m):</span><br><span class="line"></span><br><span class="line">    ...     i = 0</span><br><span class="line"></span><br><span class="line">    ...     while (i &lt;= n):</span><br><span class="line"></span><br><span class="line">    ...         yield i</span><br><span class="line"></span><br><span class="line">    ...         i += m</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; def every_3_ints_to_10():</span><br><span class="line"></span><br><span class="line">    ...     for item in every_m_ints_to(10, 3):</span><br><span class="line"></span><br><span class="line">    ...         yield item</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; for gen in make_generators_generator(every_3_ints_to_10):</span><br><span class="line"></span><br><span class="line">    ...     print(&quot;Next Generator:&quot;)</span><br><span class="line"></span><br><span class="line">    ...     for item in gen:</span><br><span class="line"></span><br><span class="line">    ...         print(item)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    Next Generator:</span><br><span class="line"></span><br><span class="line">    0</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line"></span><br><span class="line">    6</span><br><span class="line"></span><br><span class="line">    9</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    &quot;*** YOUR CODE HERE ***&quot;</span><br><span class="line"></span><br><span class="line">    def gen_helper(lst):</span><br><span class="line"></span><br><span class="line">        yield from lst</span><br><span class="line"></span><br><span class="line">    yield_sofar = []</span><br><span class="line"></span><br><span class="line">    gg = g()</span><br><span class="line"></span><br><span class="line">    for x in gg:</span><br><span class="line"></span><br><span class="line">        yield_sofar.append(x)</span><br><span class="line"></span><br><span class="line">        yield gen_helper(yield_sofar.copy())</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="生成器生成树的搜索路径">生成器生成树的搜索路径</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if t.label == value:</span><br><span class="line">        yield [value]</span><br><span class="line">    for b in t.branches:</span><br><span class="line">        for path in path_yielder(b, value):</span><br><span class="line">            yield [t.label] + path</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;python语言特性&quot;&gt;python语言特性&lt;/h2&gt;
&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;
&lt;p&gt;名称也可以与函数绑定。例如，名称 &lt;code&gt;max&lt;/code&gt; 就和我们之前使用的 &lt;code&gt;max&lt;/code&gt; 函数进行了绑定。与数字不同，函数很难以文本呈现，因此当询问一个函数时，Python 会打印一个标识来描述：</summary>
    
    
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据结构与算法" scheme="https://thinklive1.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="伯克利" scheme="https://thinklive1.github.io/tags/%E4%BC%AF%E5%85%8B%E5%88%A9/"/>
    
    <category term="课程笔记" scheme="https://thinklive1.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="python" scheme="https://thinklive1.github.io/tags/python/"/>
    
    <category term="数据结构与算法" scheme="https://thinklive1.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>blacksouls人物解析</title>
    <link href="https://thinklive1.github.io/2023/09/29/black%20souls%E4%BA%BA%E7%89%A9%E8%A7%A3%E6%9E%90/"/>
    <id>https://thinklive1.github.io/2023/09/29/black%20souls%E4%BA%BA%E7%89%A9%E8%A7%A3%E6%9E%90/</id>
    <published>2023-09-29T02:18:45.993Z</published>
    <updated>2023-11-27T12:47:59.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尸龙贾巴沃克">尸龙贾巴沃克</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在天之繁星哟！命数已定之众哟！尽管去为爱所煎熬吧，为嫉妒之苦吧！呜呼！感激涕零吧！为这幸灾乐祸暗黑舞台点缀色彩就好！！！</span><br></pre></td></tr></table></figure><p>象征着腐败与神秘的紫黑色，遍布全身的缝合痕迹与绷带，恶魔一样的卷曲角，晦暗如死尸的肤色，以及左眼燃烧着的灵魂之火（致敬黑岩射手可能性微存），<code>尸龙</code>姐姐的人物形象无时无刻不在传达着神秘强大而阴暗的气氛，本视频将对<code>尸龙</code>的整个人物进行解析 <span id="more"></span> <code>尸龙</code>在爱丽丝镜中奇遇的原型是一首小诗，这首诗的大意是勇者手提沃伯尔之剑斩杀邪龙<code>贾巴沃克</code>，游戏中也承袭了这一设定，<code>贾巴沃克</code>一直都以死尸的形象登场 要解析这一角色，我们首先从最直接的行为说起，按游戏的时间线，<code>尸龙</code>姐姐大概做了以下这些事 1把童话（具体哪本未知，根据混沌迷宫的狼外婆信息推测可能是小红帽）给了渴望母爱的玛丽.苏，从而激发了虫虫的创作能力，导致她创造出一代的箱庭。顺便一提，关于<code>尸龙</code>和<code>玛丽苏</code>的关系，游戏里没有直接证据支持姐妹说，混沌迷宫提到黑山羊有两个子嗣，米兰达认为<code>尸龙</code>有黑山羊的气息，且明显<code>尸龙</code>和<code>玛丽苏</code>有一定关系，这些是确定的，但并未明说姐妹，有人从克苏鲁的设定中寻找论据，但本人对克系了解不多在此不评价。 2红偶像约会中电影《三人的茶会》提及茶会时期的三人曾经打倒过贾巴沃奇，不知是否和<code>尸龙</code>有关，此外<code>尸龙</code>也曾被昔日的勇者，如今的猎头兔打倒，自称在之后洗心革面，但相关资料太少，我们不知道是不是她放水或另有隐情 3格林被引导进<code>玛丽苏</code>的箱庭开始一代的故事，此时<code>尸龙</code>（不知道<code>玛丽苏</code>是否知情）已经乱入到一代的不思议之国，为格林一行人提供帮助，通关d结局后找她对话，她会直接把二代给剧透了，不过由于时间线上d结局应该直接接上二代，所以“正史”上可能没有这件事，顺便一提，一代的不思议之国是爱丽丝的箱庭，或者说<code>玛丽苏</code>的仿造品，也没有定论，所以很难推测<code>尸龙</code>是入侵还是本来就在那里 4来到二代时间线，由于不思议之国是奈亚的箱庭，而黑山羊则是奈亚的“配偶”，所以<code>尸龙</code>出现在这倒是理所应当，此时的<code>尸龙</code>以四噩梦之一的身份登场，，但工作内容则是在卡罗尔川上堆雪人，以及在格林面前装出温柔大姐姐的形象，十足的关系户做派。 里路线中，格林和米兰达等人可以先后对战三噩梦，以及杀死其余两个噩梦后现出真身的<code>尸龙</code>，值得一提的是这似乎是她全系列中唯一一次全力出手，并且在此战中死亡，但考虑到支配者的特性，是否死透了依旧存疑 以上就是<code>尸龙</code>在系列中的行动，接下来我将对这些行动的目的与<code>尸龙</code>的性格进行归纳。 <code>尸龙</code>首先是一个安静的观察者，一代中她只是在一棵树下扮尸体，二代则在河边堆雪人，如果格林不找她，在里线之前不会和她有任何交集，然而，隐藏和善表面下的真相是<code>尸龙</code>其实是个性格扭曲唯恐天下不乱的乐子人，是她启发了<code>玛丽苏</code>创造自己的黑童话箱庭，间接引发之后所有的故事，而一开始的目的可能只是以<code>玛丽苏</code>面对求而不得的母爱痛苦挣扎的样子为乐，也是她诅咒了狩猎邪龙的英雄，使兔子一族成为贪食尸体的魔兽，其中被沃波尔斩下头颅可能是她行事风格的分界线，其自述死前曾是无恶不作的邪龙，在复活后变得收敛，但其实依旧不改邪龙本质，只是变得只在关键时刻推波助澜 而将这两种性格统一起来的则是她的创作欲，没错，和<code>玛丽苏</code>一样，<code>尸龙</code>对创作也有自己的执念，在<code>玛丽苏</code>涌现起黑暗的创作力之后，<code>尸龙</code>意识到，<code>玛丽苏</code>那邪恶的灵魂一定程度其实是自己的作品，如果说<code>玛丽苏</code>是支配者中第一个创造故事的人，<code>尸龙</code>就是第一个“创作者”，这激发出她内心最深层的欲望，那就是创作出足够黑暗污秽的灵魂，方法则是让一个灵魂在无尽的痛苦与求而不得中循环。 可以说在这点上<code>尸龙</code>和奈亚有一定的共同点，就是让格林经历无数次的痛苦循环，但二者还是有着分歧，奈亚想要的是格林求而不得的爱，<code>尸龙</code>则想要格林本就污秽的灵魂更加黑暗。 这时我们就可以理解<code>尸龙</code>的行为了，由于里线实际上也处于轮回之中，所以对<code>尸龙</code>来说，告诉格林一些真相只会让他的反抗更加激烈，也会在反抗之后更加绝望，这样才符合她的目的。 而以上依旧是<code>贾巴沃克</code>的表层性格，而她隐藏最深的性格则是扭曲的独占欲，在卡罗尔川的地牢中有个四个雪人，分别是<code>玛丽苏</code>，小红帽，爱丽丝和格林，此外，班达斯奈奇的住处也有着一个写着想将其变为收藏品的雪人（sen0才能看到真相），可见<code>尸龙</code>内心最深的欲望其实是独占欲，培育最污秽的灵魂，随后将其收藏起来，这才是<code>尸龙</code>的愿景，但她为何要隐藏这一欲望呢，在qf<code>尸龙</code>失败的逆监禁剧情里，由于<code>尸龙</code>发现格林的灵魂已经黑暗到想要独占自己，<code>尸龙</code>就会唯一一次直接暴露自己的独占欲来收割这个丰硕的成果，然而，奈亚或者其他支配者绝不会容忍这种行为，所以一旦<code>尸龙</code>试图独占格林就会立刻被排除出世界，这就是<code>尸龙</code>一直压抑着独占欲的原因。 此外，根据dlc3入口处的对话以及数量庞大的雪人，或许可以猜测<code>尸龙</code>曾经一边观察一边玩弄过很多灵魂，但这些灵魂最后都因为经历过多的痛苦和绝望后变得麻木，因此才会对有着无穷成长性的格林视若珍宝 一切温柔的言语都不过是为了将格林引导向更绝望的结局，独占污秽的黑之魂，玩到腻后就扔掉，对<code>贾巴沃克</code>之魂的描述为包藏在虚伪的母性之下的独占欲之影可谓恰如其分。 值得一提的是，独占欲这种感情不止在<code>尸龙</code>一人上出现，大部分支配者都有着这种感情，如白之女王诺登就承认自己多次有独占格林的想法，爱丽丝01也曾吐露自己害怕不可控制地想要独占格林，但她们与<code>尸龙</code>的区别则是，她们能够理解人类的爱，并为了人类的幸福选择放手，与红白女王的对比或许也是<code>尸龙</code>人物形象设计的一个目的 现在可以做一个总结了，<code>尸龙</code>姐姐是一个对格林有着强烈爱意的角色，她的母性是虚伪的，但这种爱意却不是，尽管她扭曲，残酷，自私，虚伪，但是她始终知道自己要做什么并理性地付出行动，即使失败了也不失风度从容自若，相较于虫虫几乎写在脸上的扭曲性格，直截了当的作恶行径，以及一有挫败就大呼小叫的行径，<code>尸龙</code>的感情更加内敛，行事也更加隐秘，但可谓是个很有恶人魅力的反派角色 同时，由于bs的碎片化叙事并且尚未完结，关于<code>尸龙</code>依旧有很多谜团，例如她和<code>玛丽苏</code>以及其他支配者的具体关系，里线中她是不是仍然在演戏，她究竟为何会给<code>玛丽苏</code>童话书，<code>尸龙</code>等三噩梦和三个爱丽丝的关系等等，就期待续作的解答了 大家都来和<code>尸龙</code>姐姐做朋友吧，尸门</p><h1 id="玛丽苏">玛丽苏</h1><p><code>玛丽苏</code>，作为bs中自称的女主角，是bs唯二个三代都有出场（包括红森）的支配者，还有一个是<code>贾巴沃克</code>），在此过程中做过的好事可谓数不胜数，罄竹难书，我们来按着时间线整理一下 1一开始的<code>玛丽苏</code>是个渴望母爱的孩子，尽管我们不知道bs设定下一开始的支配者到底会不会有类似人类的亲情，她掌管自己的世界，倾听子民的祈祷，开始感到厌烦，这时<code>贾巴沃克</code>不知出于什么目的，送了她一本童话书，这本书，我们不知道是哪个童话，但本人猜测很可能这本书的作者是<code>玛丽苏</code>第一个抓住的，并在黑之魂的融合中有重要地位，根据青鸟的文本，卡罗尔并不是第一个抓住的素材，所以基本可以排除梦游仙境，结合男主角格林的名字和混沌迷宫的狼外婆，我个人猜测是小红帽，她开始渴望创作自己的故事来打动母亲，至少一开始是这样，她派遣属下四处收集童话作者的灵魂作为素材，同时肆意进行同人创作。 2<code>玛丽苏</code>的处女作是小红帽，也是她第二得意的作品，根据一些信息，小红帽的灵魂可能以现实世界的一个女学生为素材，在魔改剧情的同时，她还给了小红帽注定20岁早逝的设定，并可能赋予了小红帽通过镜子穿梭位面之类的特殊能力来担任女主角，但不知道为什么她又不满意，想做一个男主角出来，但她对小红帽的善后却颇有些问题，小红帽不仅杀穿了红森，而且还能意识到她这个黑幕的存在。 3缝合了众多童话作家灵魂的格林诞生了，并被赋予了给周围的女主角带来不幸的设定，格林污秽的黑之魂有成为支配者的潜质，<code>玛丽苏</code>甚至还大胆地保留了他的部分创作能力，因为最关键的改变权能在她手上，为什么叫做格林则未知，可能是最初的童话书就是格林童话的一本，这之后格林不知道为什么，以什么身份在一个叫不思议之国的地方和叫爱丽丝和祈祷主的存在开起了茶会，随后格林与爱丽丝01相恋，嫉妒的祈祷主呼唤了<code>玛丽苏</code>，导致格林被带走了，连同格林不知何时创造出的故事们也被篡改 4基于以上提到的各种童话故事素材，<code>玛丽苏</code>魔改出了失落帝国的箱庭，把格林放进去经历一次次绝望故事的轮回，自己则担任女主角欣赏故事，还设计把母亲叫了进来欣赏自己的大作。不知多少次循环后，这个大好局面被打破了，母亲黑山羊为了逃离这个世界和她战斗，连圣森都磨灭了，战胜母亲后，奈亚丽丝前来捡漏带走格林进行新一轮追寻爱的游戏，本来想顺带着把<code>玛丽苏</code>也灭了，但在诺登的劝阻以及可能的其他考量下放过了她 5奈亚，红女王，白女王中的某位或若干位剥夺了她的改变权能，把她囚禁在库因兰德，失去权能的她改名为玛丽安，但不知何时也不知何人前来探访了她，到格林试图从梦中醒来的里线，玛丽安乘乱逃出，由于正史上不太可能发生f结局，所以此时应该是g结局，也有可能正史上g结局有少许与游戏不同，不管怎么说此时的玛丽安应该被格林小红帽两人打败，但h结局中可以看到她没有死，而且不知道怎么逃了出来 可以说，bs中的一切悲剧，<code>玛丽苏</code>至少有五成功劳，接下来让我们来分析一下<code>玛丽苏</code>的角色特质。 首先，最直接的一点，<code>玛丽苏</code>是个典型的支配者，高高在上地支配着人类这样的低等种族，但<code>玛丽苏</code>特殊之处在于，她可能是最能理解人类感情的支配者之一，首先我们就可以看到她居然渴望所谓的母爱，而根据2代大部分支配者的表现，即使因融入皮套逐渐有了感情，也没有第二个有亲情这种非常类似人类感情的支配者，此外，她还以玩弄人类的灵魂为乐，当然有这种兴趣的支配者恐怕不少，但这股风气可以说是<code>玛丽苏</code>带起来的，也是她最先玩出各种花样。 因此可以引出<code>玛丽苏</code>的第二个特点了，她是很像人类的一个支配者，尽管理解非常片面，但她确实懂得并拥有不少人性，而她为什么这么喜欢玩弄人类呢？这也很容易理解，一般来说越通人性的动物越被人类亲近，逗猫逗狗远远比逗蚂蚁有意思，因为这些宠物的智力和人类更接近，人类可以很容易地理解它们在想什么，然后在逗弄它们的过程中获得一种智力上的优越感，以及一种“支配感”，这恐怕就是<code>玛丽苏</code>看到自己编排的好戏上演的感觉。 这点可以说是我们对<code>玛丽苏</code>进行解析的基石，毕竟任何角色首先都是人的投影，而人性越丰富，就有越多的性格侧面。 <code>玛丽苏</code>第三个特点就是由此衍生的纯粹性，当然，此处并不是说纯洁善良云云，而是某种意义上的纯粹之恶，很多支配者在扮演人类后都会被皮套影响而恐慌或纠结，但<code>玛丽苏</code>却没有这种烦恼，她以融入人类扮演人类为乐（小精灵也算类人种族），她作为支配者的漆黑本性和人性之恶完美地兼容了，不会有徘徊二者之间的身份认同问题，而她大部分所作所为也就是为了践行人性之恶，什么是恶呢，比较狭隘的解释就是为了为了自己的利益或者取乐而伤害他人，而<code>玛丽苏</code>的邪恶就很纯粹，就是为了取乐，甚至有损自己利益也要作恶，如果解救了被囚禁的<code>玛丽苏</code>，此时她会自认为东山再起，但她想的不是第一时间抹杀已经成长了的格林或者藏起来，而是想再让格林经历一次悲惨的故事，可以说她作恶的动机相当纯粹，也相当执着。 在此之上的第四个特点，就是她的创作者身份，很多支配者都会赞扬她的创作能力，连奈亚构建的不思议之国都有不少<code>玛丽苏</code>箱庭的影子，但这种创造力也只是对于支配者来说了，如果我们用人类的视角看如何呢？寿司在访谈时轻蔑地说到“她说到底也只是<code>玛丽苏</code>，也只能整点二次创作了”可以说道出了<code>玛丽苏</code>所谓创作的本质，说到底，<code>玛丽苏</code>就是那种典型的黑深残小鬼，把一个可能有很多种解释的作品曲解为单一的猎奇世界观，当然不是说这样不行，如果原创一个黑深残世界观自娱自乐当然是可以接受的，但<code>玛丽苏</code>的行为就是最恶劣的一种同人女行为，魔改原来的作品，把自己做成角色代入进去搞cp，还要把所有其他角色踩一遍，情节和人物关系只要对自己代入的角色有利就行，然后把这部除了自己看谁也不会喜欢的同人拿给原作者看，我就不详细说这种行为的恶劣程度了，但这种作品折射出来的创作观我必须要辩驳一下。 当然，本视频所有讨论只局限于二次元文化内， 荒木飞吕彦认为漫画有四要素，角色、剧情、世界观、主题，我们就用这四个维度来剖析<code>玛丽苏</code>的所谓创作。 首先是角色，直接创作一个鲜活的灵魂对强大的支配者来说也是一件难事，所以对于角色的选取，<code>玛丽苏</code>很可能都是使用现实存在的灵魂然后再魔改来适配进童话或者传说的人物，因此她笔下所谓角色虽然很多但其实并不是她自己的功劳，而她为了把这些灵魂塞进角色对设定随意删改，把小红帽的外婆和母亲缝成了一笔烂账，人物关系更是一团乱麻，怎么方便怎么来，角色设定连基本的自洽也做不到，水平着实不敢恭维 随后是世界观，失落帝国这个箱庭本质上来说就是个童话故事的缝合体，没有历史演化，没有详细设定，这并不是一个鲜活的世界观，只不过是一个临时搭建的舞台而已，当然，很多线性的故事并不需要一个多详尽的世界观，在这点上<code>玛丽苏</code>只能说无功无过 最后是剧情和主题，<code>玛丽苏</code>的主题是简单粗暴的黑深残，剧情则是当常规的rpg剧本演到最后的happy end时毫无铺垫伏笔地急转直下变成bad end，当然，能设置这么大规模的箱庭，还写了不少支线剧情，证明<code>玛丽苏</code>确实是有一些笔力的，但首先，她的角色基本靠抓人，故事则都有童话原型，故事演变她只需要把握大方向，其他可以让角色自己来，而最后没有任何铺垫的bad end依旧表明了她创作的失败，如果一个设定没有任何铺垫和暗示，直到使用时才抛出，那只能证明这部作品情节编排的失败，因为一部作品的生命周期不是作者创作出来就结束了的，而要等到读者看完理解了故事才会结束，这个过程作者读者应该处于相对公平的地位，根据故事的设定，人物有充分的理由这样行动，这样才能让读者认同这个故事，而<code>玛丽苏</code>却完全相反，滥用作者的权能让故事不仅没有逻辑，还自相矛盾，很明显，对<code>玛丽苏</code>来说她是作者也自认为是唯一的读者，那些被抓走被改造的灵魂不过是用完即扔的工具罢了，不需要自圆其说，只要自己看得高兴就行了，或许就支配者的立场来说她不过是自娱自乐罢了，但对人类（至少灵魂上是人类），以及同样作为创作者的格林来说，首先就绝不可能认同这种恶行，更不可能认同自己的作品被改成这样的烂作 说到这里，就可以讨论一下<code>玛丽苏</code>对于格林的看法了，直观地说，是<code>玛丽苏</code>创造了名为格林的污秽黑之魂，但其实在最初，是格林等童话作家激发了<code>玛丽苏</code>的创作欲，因此，事实上，两者是相互创造的关系，<code>玛丽苏</code>创造格林的目的，首先是为了成为她作品的男主角，让她能够代入女主角的位置欣赏这个故事，这样说来似乎格林除了男主角的身份和其他角色也没什么本质的不同。但格林还有一点对<code>玛丽苏</code>有着重大意义，就是他童话作家灵魂集合体的身份，即使自我中心如<code>玛丽苏</code>这种存在，也会有对别人欣赏自己作品的渴望，因此<code>玛丽苏</code>特地设置了一个c结局，用演戏的形式让格林得以了解她的整个创作生涯，至于目的，除了单纯的表现欲和欣赏格林的痛苦以外，恐怕也有一丝希望作为原作者的格林认同自己的心情，哪怕是厌恶，<code>玛丽苏</code>也想得到一些对创作的反馈，而格林是唯一能在创作这个领域和她有一些共鸣的人，作者，读者，男主角，格林三位一体的身份对<code>玛丽苏</code>来说，可以说是难得的知己，尽管这种关系非常扭曲，但不能否认，在这点上<code>玛丽苏</code>作为创作者的心情是有些真心的。而<code>玛丽苏</code>会渴望认同这点，一开始是希望得到母爱，但在得到格林这个玩具之后，<code>玛丽苏</code>就一点也不在意黑山羊的死活了，这也是佐证。 最后不得不提的是，<code>玛丽苏</code>的特殊性质，很大程度上她是寿司这个作者的投影，我个人觉得<code>玛丽苏</code>这个角色有不少表达寿司自己创作观的成分，这也解释了寿司为何这么偏爱她当然，一部好的作品，任何角色都是基于自己的设定和世界观行动，不可能因为是作者的投影就有特别待遇，所以可以说，<code>玛丽苏</code>虽然很大程度上是寿司的投影，但投影的目的其实是对比，<code>玛丽苏</code>的创作肤浅，笔下的故事只是无聊的黑深残，但寿司却喜欢在绝望时写一些希望，在希望中铺设绝望，最后的反转再怎么说都是有因可循，单论创作的层次来说就高出绿虫子太多了，当然，我也不是在吹寿司笔力多高，因为高出<code>玛丽苏</code>这个水平的创作者多如牛毛。 寿司设置<code>玛丽苏</code>这个角色，其实是使用了一种嵌套的结构来讲故事，首层是童话的原作，这些是毋庸置疑的好故事，随后是虫子和奈亚魔改出的箱庭，是烂故事的典型，最后一层寿司想讲的重点其实是格林怎么察觉真相，挣脱出烂故事的循环，书写自己的结局的故事，在这三层中，第一层<code>玛丽苏</code>是读者，格林等人是作者，只出现在设定层面，第二层<code>玛丽苏</code>是一半作者一半角色，格林是一半读者一半角色，体现在abc结局，最后一层中寿司是唯一的作者，<code>玛丽苏</code>和格林就都是角色了，体现在d结局以及之后的二代，这种层层演变虽然有些炫技，但确实非常有意思。 就<code>玛丽苏</code>这个角色而言，整个泛二次元文化里她这样的反派也不常见，究其原因，则是因为一个有能力玩弄主角取乐的boss必然会导致战力失衡，冲突不起来，让读者感到憋屈，因此想要打败这种boss要么机械降神唯心爆发，比如一代c结局（虽然是演的），要么引入新的boss和同伴体系取代她如d结局，也因此，虽然我个人很喜欢一代，但一代的真结局d结局远没有2代h结局震撼 来做个总结吧，<code>玛丽苏</code>无疑是个纯粹邪恶的支配者，一个烂到骨子里的创作者，她作为创作者无疑是失败的，但作为bs这个故事里的角色反而是很成功的，不仅纯粹有特点，还有很多角色侧面可以挖掘，寿司巧妙地利用她读者，创作者和角色的三重身份来塑造她的多面性，颇有荒木在漫画术中写的“在作恶道路上高歌猛进”的成功反派角色风格。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;尸龙贾巴沃克&quot;&gt;尸龙贾巴沃克&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在天之繁星哟！命数已定之众哟！尽管去为爱所煎熬吧，为嫉妒之苦吧！呜呼！感激涕零吧！为这幸灾乐祸暗黑舞台点缀色彩就好！！！&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;象征着腐败与神秘的紫黑色，遍布全身的缝合痕迹与绷带，恶魔一样的卷曲角，晦暗如死尸的肤色，以及左眼燃烧着的灵魂之火（致敬黑岩射手可能性微存），&lt;code&gt;尸龙&lt;/code&gt;姐姐的人物形象无时无刻不在传达着神秘强大而阴暗的气氛，本视频将对&lt;code&gt;尸龙&lt;/code&gt;的整个人物进行解析</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="black souls" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/black-souls/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="black souls" scheme="https://thinklive1.github.io/tags/black-souls/"/>
    
  </entry>
  
  <entry>
    <title>blacksouls剧情解析</title>
    <link href="https://thinklive1.github.io/2023/09/29/black%20souls%E5%89%A7%E6%83%85%E8%A7%A3%E6%9E%90/"/>
    <id>https://thinklive1.github.io/2023/09/29/black%20souls%E5%89%A7%E6%83%85%E8%A7%A3%E6%9E%90/</id>
    <published>2023-09-29T02:18:45.993Z</published>
    <updated>2023-11-27T12:47:59.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冬之钟">冬之钟</h1><p>由于black souls的故事远远没有完结，因此现阶段我们很难对<code>红白女王</code>与<code>梅贝尔</code>这些与格林牵扯极深的支配者们进行什么定论，只能就已有的剧情和文本进行一些归纳，本期视频我将就bs2比较难懂的一处地方，冬之钟的主线事件，进行一些个人向的分析。 <span id="more"></span> 在冬之钟最后一章地图能遇到5个白熊，白熊的身份迄今为止依然是谜团，但他们提供了整整五段发生在支配者之间的重要对话，我将概括一下这五段对话提供的主要信息以便进一步的分析 我们按解包后的地图顺序开始， 第一段对话发生于<code>梅贝尔</code>和妹妹爱丽丝之间，可以猜测妹妹爱丽丝属于支配者之一，数量众多的支配者都在奈亚的箱庭占据一个角色以便和格林繁殖，但随着时间推移，支配者们发现扮演角色的同时，他们也在被角色同化（<code>梅贝尔</code>所言），因此纷纷退场，妹妹爱丽丝也逐渐被角色影响对格林产生好感，此外，姐姐爱丽丝不知何故地退场。 第二场对话发生于<code>梅贝尔</code>和白之女王之间，对话中提及冬之钟正是白女王的箱庭，而白之女王由于爱上了格林自愿放弃女王的身份去守护他，而<code>梅贝尔</code>则对这场追寻爱的闹剧，以及陪着胡闹的其他支配者感到无聊，向白女王提出一个让格林摆脱循环，并且能够独占他的计划。 第三第四场对话都发生于红白女王之间，<code>红女王</code>为陷入痛苦轮回的格林而痛苦，不断进行自残，白女王制止了她，两人由于同样爱上格林而心意相通 第四场对话则告诉我们，<code>红女王</code>接过了白女王的权王冠（推测为箱庭权限），并以此创造出库因兰德，并使其能排除奈亚的监视，两人密谋让格林挣脱循环的方法，<code>红女王</code>恳请白女王放弃对格林的独占欲，白女王同意了，此外，<code>梅贝尔</code>也知晓这一计划，并根据后面的行动来看，她不知为何也参与了这个计划 第五场对话发生于白女王和玛丽苏之间，白女王夺走了玛丽苏的改变能力，并且根据混沌迷宫的情报，将其赋予了古兰剧场，玛丽苏察觉白女王爱上了格林，并且等待着格林的到来，结尾，玛丽苏等到了一个神秘人（黑山羊？） 总结这些信息，我们可以推测出针对格林，一共提出了两个计划，一个是<code>梅贝尔</code>怂恿的独占计划，一个是红偶像策划的拯救计划，这两个计划都必须有<code>诺登</code>的参与，但此时我们并不知道<code>诺登</code>的真正想法是哪个 在推进h结局的过程后，格林会有两个选择，1是和暗黑舞台合二为一2是打败舞台，夺取舞台的改变能力， “此时”的冬之钟虽然沉睡，但相信<code>诺登</code>依旧有一定的控制能力，然而不同于G结局的阻拦，此时的<code>诺登</code>选择了旁观，并在最后支持格林任意一个选择 总结一下大致发生的事件（以下事件的时间顺序难以具体确定） 1<code>诺登</code>作为支配者之一管理着自己的箱庭冬之钟，和奈亚创造自己箱庭的时间关系未知 2奈亚将格林带到箱庭，邀请支配者们参加繁殖游戏，根据牛津学院人偶爱丽丝的说法，是舞台装置创造出了让格林在舞台上登场的皮套（格林的灵魂出自玛丽苏的手笔，因此推测只能创造皮套），并且在创造格林时两者间确立了深远的联系，白女王也参加了这个游戏，可以肯定白女王为了心爱的格林才舍弃了王冠（王冠可能指代管理箱庭的权能），因此推测白女王在爱上格林后可能以放弃王冠为代价，得到了管理奈亚箱庭的权限和陪伴在格林身边的权力 3红偶像被奈亚切割，由于茶会时期她曾经打倒初代红之女王，因此此刻可以说她的身份是第二任红之女王，为格林自责的她不断紫餐，得到了白女王的同情，白女王将自己原来的王冠权能移交给被奈亚切割的<code>红女王</code>，让她在原冬之钟的地盘上创造出自己的箱庭。 4红白女王合谋，或者其中之一从奈亚手中夺走了玛丽苏并囚禁起来，为了避免红白女王相互猜疑，二者将从玛丽苏手上得到的改变能力赋予舞台装置古兰，创造出一个新的支配者暗黑舞台，藏于处于过去时间线的冬之钟，同时由于处于过去的时间线，冬之钟几乎没有被发现的风险，通过dlc3经常出现的齿轮与其他信息可以推测，舞台装置拥有着影响整个箱庭以及舞台上大部分“演员”的能力，即在部分地图的bg和格林脑中的“齿轮声”，是不思议之国这场戏的核心，此外，由于<code>诺登</code>为了管理这个箱庭必须借助舞台的力量，而红白女王理论上权能接近，因此本视频中猜测红白女王都有部分操控舞台的权限 4由于支配者们发现扮演箱庭的角色会改变自己的本质，因此纷纷退出，白女王被迫用自己和格林的子嗣填补空缺 5<code>梅贝尔</code>认为这场游戏无聊透顶，一场剧本烂透的戏剧重复多少遍也只会让人厌倦（她自己是这么说的），因此她怂恿白女王让格林脱出循环，并抢先独占他 6<code>红女王</code>努力让自己的领域能排除奈亚的监视，并在此向白女王提出了拯救格林的计划，这个计划<code>梅贝尔</code>也知情，白女王同意了拯救计划，我们不知道白女王听到这两个计划的顺序，但他们明显是冲突的 7可能是人为，可能是自发，舞台觉醒了自我意识呼唤着格林的爱，同时在<code>梅贝尔</code>的指引下格林也朝着舞台进发，一场死斗在所难免，可以推测，在夺取舞台能力的结局中，<code>诺登</code>执行了<code>红女王</code>的拯救计划，舍身为格林断后，使其在爱丽丝01，即现在的红偶像的帮助下回到现实。在舞台与格林合一的bad end中，<code>诺登</code>执行了<code>梅贝尔</code>提出的独占计划，该结局中<code>诺登</code>辅佐着通过合体得到创作能力的格林与奈亚进行斗争，并且前往世界尽头来逃避一切纷争和毁灭，顺便一提，我觉得这结局也不算坏，白女王很可能会确保格林在融合中占据主导，此时格林成为了名副其实的支配者，和白女王的结合甚至能和奈亚势均力敌，不过寿司在采访中提到执着于爱丽丝身份的奈亚无法发挥全力就是了，毫无疑问这时的格林是目前为止的（格林）战力巅峰。 这就是冬之钟里发生的主要事件了，下面我将对事件的主要参与者，红白女王和虚无的少女进行分析。 首先是参与程度较低的<code>梅贝尔</code>，<code>梅贝尔</code>虽然入局较浅，但却是格林的引导者，并帮助拖延了一下奈亚，也是她告诉我们打破这一循环只能正面和舞台装置对决，那么她的目的是什么呢？ 首先，<code>梅贝尔</code>在混沌迷宫中会直接提及支配者间不可避免将爆发战争，并且导致阿撒托斯的苏醒毁灭一切，而身份不是支配者却可能得到支配者之器的格林，才能发动不会惊醒阿撒托斯的箱庭战争，这可能是她帮助格林的首要目的 其次，<code>梅贝尔</code>是个不可救药的收藏狂，她的箱庭是个巨大的垃圾场，什么都有，因此她也想把格林培养成一个完美收藏品或者棋子 最后，在个人感情上，很难定论<code>梅贝尔</code>到底产生了多少感情，她自称对永无止境的劣质戏剧循环感到厌倦，才会帮助格林创造自己的故事，但又在背叛剧情中声称想要让格林得到更高的器随后利用他，最后如果试图救她又会说自己涌现出了一些对格林的爱，由于信息过少，很难知道她到底觉醒了多少感情。 不过可以肯定的是，如果是<code>梅贝尔</code>真有意背叛动机是不充分的，如果她只需要格林成为拥有支配者之器的棋子，那么独占和拯救计划都能实现这个目的，并且由于白女王看着，融合后大概率是格林占主导地位，无非是好不好操控的问题，因此猜测<code>梅贝尔</code>实际上是真心帮助格林，只是在用激将法，或者习惯性毒舌。 冬之钟的棋局不管怎么走<code>梅贝尔</code>都不是输家，如果独占计划成功，白女王和格林则会成为一股对抗奈亚甚至其他支配者的强大力量，如果拯救计划成功，格林则会成为一个有着支配者的器，却对大部分支配者恨之入骨的棋子或潜在盟友，不论哪个结果都对<code>梅贝尔</code>阻止阿撒托斯苏醒的目的有利，而她的损失不过是万千分身中的一个而已 随后则是红之女王，尽管游戏中没有直接说<code>红女王</code>就是一代的爱丽丝01，以及茶会中的爱丽丝，但大量证据表明她和爱丽丝01有着千丝万缕的关系，爱丽丝01也极有可能就是茶会爱丽丝，所以本视频采纳这一说法，可以说最早钻进人类皮套的她是人性化最深的支配者，她人类的一面深爱格林，但又恐惧支配者的一面暴露，因此自觉配不上格林，甚至认为是自己导致了格林的一切悲剧，顺便一提关于茶会以及更早时期的资料实在太少，所以我们现在对这段剧情的讨论很可能是不完整甚至有较大误解的，因此在此我只能尽可能保守地做一些推测，由于支配者本性难以剥离，在她身上有着强烈的自毁倾向，想爱，却又自觉没有资格去爱，因此她只能用紫餐的方式填补内心的负罪感，H结局中，她以几乎自杀的方式当着奈亚的面帮助格林逃离了奈亚的掌控，可以说为了格林，<code>红女王</code>自降身份把自己变成了棋子，而且是必死的棋子，只为了能在后续将奈亚一军。 等待着这个叛徒的是什么结局，我们只能发挥一下想象力了 最后则是冬之钟的核心人物，白之女王<code>诺登</code>，<code>诺登</code>的原型之一是爱丽丝梦游仙境的白兔先生，白兔最明显的元素就是他永远匆忙的样子和怀表，这点也在<code>诺登</code>身上得以体现，白女王作为这场繁殖游戏事实上的管理者，为了协调任性的演员们可谓操碎了心，在轮回的最后，台上的演员几乎全部是她的子嗣（兔子可是繁殖力非常强的生物），可以猜测在制定剧本和排练上她也得下不少功夫，而dlc3的核心意象，齿轮，其实可以说既指着暗黑舞台的齿轮带动了戏码的上演，也指着<code>诺登</code>怀表的齿轮，<code>诺登</code>就是那个负责在指针快点到达终点前让齿轮倒转，重新开始计时的人，这也是为何她会在结局中说为齿轮停止感到害怕，让齿轮转动是她的职责，在她的内心深处或许也有着对无尽循环中格林真正爱上自己并一起逃到世界尽头的希望，但最后她选择成全格林真正的爱，而放弃管理齿轮的职责则意味着她与自己支配者的身份完全决裂，将一切奉献给人类的爱。此外，<code>诺登</code>的支配者原型则是所谓的幻梦境之主，这或许解释了为何是她在实际上管理着二代这个巨大的梦境 我在尸龙的人物解析说，类似尸龙的独占欲在红白女王身上也出现过，但<code>红女王</code>由于害怕自己的支配者本性选择放手，那么白女王呢？在h结局中，<code>梅贝尔</code>被古兰（推测，也可能是奈亚）针对性的陷阱解决，但拥有舞台权限的红白女王应该不受影响，<code>红女王</code>为了最后拯救格林必须蛰伏，因此辅助格林对抗古兰以及奈亚的任务只能交给白女王，但即使在此时此刻，白女王依旧有着独占格林的选项，如果她控制或者协助舞台装置强迫和格林融合，就可以抢先一步独占所有支配者都垂涎的格林，但如果把舞台的改变能力给予格林，那么失去王冠和舞台的<code>诺登</code>则会失去自己在棋局上的几乎所有棋子，面对这种选择，<code>诺登</code>将选择权给了格林，不能说她是完全无私的，但面对这样的诱惑，她也会尊重格林的选择，这不得不说是非常伟大的爱 可以说白女王是一个有着两面性的角色，她支配者的一面始终对格林有着独占欲，但她人性的一面始终压抑着这些黑暗的感情，她是一个徘徊于人与神界限的存在，但无论如何，她都尊重并支持着格林的选择，所以她闪耀着人性光辉的一面始终是压过支配者的黑暗一面的。 让我们给这幕疯狂剧场的落幕做一个总结吧，这局棋是红白女王和<code>梅贝尔</code>设下的，目的是为了让格林得到古兰的改变能力并逃离奈亚的箱庭，其中没有舞台权限的<code>梅贝尔</code>负责引导格林，<code>红女王</code>则在最后帮助得到改变能力的格林摆脱奈亚掌控，而白女王则有着最关键的决策权，即是否利用舞台独占格林，但她最后将决定权给了格林，而格林真正的选择应该是夺取舞台的改变能力，因此最后白女王舍弃了一切帮助格林逃离崩坏的舞台。 这场棋局中，<code>梅贝尔</code>横竖不亏，<code>红女王</code>陷入必死之局，最关键的棋手就是白女王，只要她愿意，随时可以下出必赢的一着，但最后她依旧选择了放弃自己的棋子，把终结棋局的希望留给了格林 在经历如此多的牺牲之后，格林终于从棋子升为了棋手，只是不知道他又会下出怎样的一着</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;冬之钟&quot;&gt;冬之钟&lt;/h1&gt;
&lt;p&gt;由于black souls的故事远远没有完结，因此现阶段我们很难对&lt;code&gt;红白女王&lt;/code&gt;与&lt;code&gt;梅贝尔&lt;/code&gt;这些与格林牵扯极深的支配者们进行什么定论，只能就已有的剧情和文本进行一些归纳，本期视频我将就bs2比较难懂的一处地方，冬之钟的主线事件，进行一些个人向的分析。</summary>
    
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="black souls" scheme="https://thinklive1.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/black-souls/"/>
    
    
    <category term="游戏杂谈" scheme="https://thinklive1.github.io/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/"/>
    
    <category term="black souls" scheme="https://thinklive1.github.io/tags/black-souls/"/>
    
  </entry>
  
</feed>
